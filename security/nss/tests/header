#! /bin/sh

########################################################################
#
# /u/sonmi/bin/header - /u/svbld/bin/init/nss/header
#
# variables, utilities and shellfunctions global to NSS QA
# needs to work on all Unix platforms
#
# included from (don't expect this to be up to date)
# --------------------------------------------------
#   qa_stat
#   mksymlinks 
#   nssqa 
#
# parameters
# ----------
#   nssversion (supported: 30b, 31, tip 32)
#   builddate (default - today)
#
# options
# -------
#   -y answer all questions with y - use at your own risk... ignores warnings 
#   -s silent (only usefull with -y)
#   -h, -? - you guessed right - displays this text
#   -d debug
#   -f <filename> - write the (error)output to filename
#   -fcronfile produces the resultfiles in the same locations
#       as would have been produced with -cron
#   -m <mailinglist> - send filename to mailinglist (csl) only useful
#       with -f
#   -cron equivalient to -y -s -d -f $RESULTDIR/$HOST.<scriptname>
#   -t  run on a tinderbox build that means: local, from the startlocation
#
# special strings
# ---------------
#   FIXME ... known problems, search for this string
#   NOTE .... unexpected behavior
#
# moduls (not yet)
# ----------------
#   --# INIT
#   --# USERCOM
#   --# UTILS
#
# FIXME - split in init / usercom / utils
#
########################################################################

#------------------------------# INIT #------------------------------

# below the option flags get initialized

if [ -z "$QASCRIPT_DIR" ]
then
    QASCRIPT_DIR=`dirname $0`
    if [ "$QASCRIPT_DIR" = '.' ]
    then
        QASCRIPT_DIR=`pwd`
    fi
fi
export QASCRIPT_DIR

O_HWACC=OFF
O_ALWAYS_YES=OFF    # turned on by -y answer all questions with y 

if [ -z "$O_INIT" ] # header is global, some including scripts may not
then                # want the init to run, the others don't need to bother
    O_INIT=ON
fi
if [ -z "$O_PARAM" ] # header is global, some including scripts may not
then                 # require parameters, the others don't need to bother
    O_PARAM=ON
fi
if [ -z "$O_OPTIONS" ]    # header is global, some including scripts may not
then                # permit options, they don't need to bother
    O_OPTIONS=OFF
fi
O_SILENT=OFF        # turned on by -s silent (only usefull with -y)
O_DEBUG=OFF         # turned on by -d - calls to Debug produce output when ON
O_FILE=OFF          # turned on by -f echo all output to a file $FILENAME
O_CRON=OFF          # turned on by -cron cron use only
O_CRONFILE=OFF      # turned on by -cron cron and -fcron
O_LOCAL=OFF         # turned on by -l run on a local build in $MOZROOT
O_MAIL=OFF          # turned on by -m - sends email
O_TBX=OFF           # turned on by -t run on a tinderbox build
                    # that means: local, from the startlocation

if  [ -z "$DOMSUF" ]
then
    
    DOMSUF=red.iplanet.com
    DS_WAS_SET=FALSE
else
    DS_WAS_SET=TRUE
fi

TMPFILES=""

WAIT_FOR=600  # if waiting for an event sleep n seconds before rechecking 
              # recomended value 10 minutes 600
WAIT_TIMES=30 # recheck n times before giving up - recomended 30 - total of 5h

if [ -z "$QAYEAR" ]   # may I introduce - the y2k+1 bug? QA for last year 
then                  # might not work
    QAYEAR=`date +%Y`
fi

if [ -z "$TMP" ]        
then
    if [  -z "$TEMP" ]
    then
        TMP="/tmp"
    else
        TMP=$TEMP
    fi
fi
if [ ! -w "$TMP" ]        
then
    echo "Can't write to tmp directory $TMP - exiting"
    echo "Can't write to tmp directory $TMP - exiting" >&2
    exit 1
fi

KILLPIDS="$TMP/killpids.$$"
export KILLERPIDS
TMPFILES="$TMPFILES $KILLPIDS"

KILL_SELFSERV=OFF   # if sourcing script sets this to on cleanup will also 
                    # kill the running selfserv processes

                    # Set the masterbuilds 
if [ -z "$UX_MASTERBUILD" ]
then                     
    UX_MASTERBUILD=y2sun2_Solaris8
fi
if [ -z "$NT_MASTERBUILD" ]
then                     
    NT_MASTERBUILD=blowfish_NT4.0_Win95
    NT_MB_WAS_SET=FALSE      # in this case later functions can override if
                             # they find a different build that looks like NT
else
    NT_MB_WAS_SET=TRUE
fi
if [ -z "$MASTERBUILD" ]    
then
    MASTERBUILD=$UX_MASTERBUILD
fi

                    # Set the default build
if [ -z "$BUILDNUMBER" ]    
then
    BUILDNUMBER=1
fi
export BUILDNUMBER
O_LDIR=OFF          #local QA dir for NT, temporary

if [ -z "$WIN_WAIT_FOREVER" ]    # header is global, some including scripts 
then                # want the init to wait forever for directories to
                    # appear (windows only) if OFF exit, if ON wait forever
    WIN_WAIT_FOREVER=OFF
fi

                          # NOTE: following variables have to change 
                          # from release to release
if [ -z "$BC_MASTER" ]    # master directory for backwardscompatibility testing
then                      # a linux compiler bug prevents us from doing the 
                          # testing against a rtm - so we rebuild the branch
    if [ "`uname -sp`" != "SunOS i386" ] ; then
        BC_MASTER="nss32/builds/20010510.1-nss-3.2-ref"
    else
        BC_MASTER="nss32/builds/20010530.1.nss321_rtm_solaris"
    fi
fi
BC_RELEASE=3.2
export BC_RELEASE

EARLY_EXIT=TRUE     #before the report file has been created, causes Exit to 
                    #create it

UX_D0=/h/blds-sca15a/export/builds/mccrel/nss

################################### glob_init ##########################
# global shell function, main initialisation function
########################################################################
glob_init()
{
    if [ $O_PARAM = "ON" ] ; then
        eval_opts $*    # parse parameters and options - set flags
    fi
                        # if running from cron HOST needs to be known early, 
    init_host            # so the output file name can be constructed. 
    . $QASCRIPT_DIR/set_environment #finds out if we are running on Windows
    Debug "OPerating system: $os_name $os_full"
    if [ $O_WIN = "ON" ] ; then
        write_to_tmpfile
        MASTERBUILD=$NT_MASTERBUILD
    fi
    umask 0    
    init_dirs
    init_files
    init_vars
}

################################### init_vars ###########################
# global shell function, sets the environment variables, part of init 
########################################################################
init_vars()
{
    if [ -z "$LOGNAME" ]
    then
        if [ $O_WIN = "ON" ]
        then
            LOGNAME=$USERNAME
        else
            LOGNAME=$USER
        fi
        if [ -z "$LOGNAME" ]
        then
            LOGNAME=$UNAME
            if [ -z "$LOGNAME" ]
            then
                LOGNAME=`basename $HOME`
            fi
        fi
    fi
    if [ -z "$LOGNAME" ]
    then
        Exit "Can't determine current user"
    fi
    case $HOST in
        iws-perf)
            O_HWACC=ON
            HWACC_LIST="rainbow ncipher"
            #MODUTIL="-add rainbow -libfile /usr/lib/libcryptoki22.so"
            export HWACC_LIST
            ;;
        *)
            O_HWACC=OFF
            ;;
    esac
   export O_HWACC
}

########################## find_nt_masterbuild #########################
# global shell function, sets the nt masterbuild directories, part of init 
########################################################################
find_nt_masterbuild()
{
    NT_MASTERDIR=${D2}/${NT_MASTERBUILD}
    if [ "${NT_MB_WAS_SET}" = "FALSE" -a ! -d $NT_MASTERDIR ] ; then
        if [ -d ${D2}/*NT4* ] ; then
            NT_MASTERBUILD=` cd ${D2}; ls -d *NT4* `
            Debug "NT_MASTERBUILD $NT_MASTERBUILD"
            NT_MASTERDIR=${D2}/${NT_MASTERBUILD}
        fi
    fi
    Debug "NT_MASTERDIR $NT_MASTERDIR"
}

set_d2()
{
    if [ "$O_TBX" = "ON" ] ; then
        D2="$TBX_D2"
        LOCALDIST=${UXDIST}
    else
        D2=${D1}/builds/${QAYEAR}${BUILDDATE}.${BUILDNUMBER}
        LOCALDIST=${D2}/${MASTERBUILD}/mozilla/dist
    fi
}

tbx_dirs()
{
    Debug "Set directories for tinderbox"
    if [ "$O_WIN" = "ON" ] ; then
        win_set_d1 #also gets the TMP straight and we need the D1 later
    else
        D1="$UX_D0"/nss$NSSVER
    fi
    if [ -z "${RESULTDIR}" ] ; then # needs to be different for tinderbox
        Debug "Setting RESULTDIR for tinderbox"
        RESULTDIR="${D1}/tinderbox/tests_results/security/${HOST}-`date +%Y%m%d-%H.%M`"
        #RESULTDIR=${UX_MASTERDIR}/mozilla/tests_results/security
    fi
    TBX_D2=`cd ../../../../..;pwd`
    D1="${TBX_D2}/../.." 
    set_d2
    UX_MASTERDIR=`cd ../../../..;pwd`
    NT_MASTERDIR=$UX_MASTERDIR
    MOZILLA_ROOT=$UX_MASTERDIR/mozilla

    UXDIST=${MOZILLA_ROOT}/dist
    NTDIST=${UXDIST}

    if [ -z "${TESTDIR}" ] ; then 
        Debug "Setting TESTDIR for tinderbox"
        TESTDIR=${RESULTDIR}
    fi
    if [ -n "$TESTDIR" ] ; then
        if [ ! -d $TESTDIR ] ; then
            Debug "Making TESTDIR for tinderbox"
            mkdir -p $TESTDIR
        fi
    fi
    export TESTDIR
    Debug "RESULTDIR $RESULTDIR TESTDIR $TESTDIR"

    TESTSCRIPTDIR=`pwd`
    COMMON=${TESTSCRIPTDIR}/common

    set_objdir
    debug_dirs
    export_dirs
}

################################### init_dirs ###########################
# global shell function, sets the directories, part of init 
########################################################################
init_dirs()
{
    if [ "$O_TBX" = "ON" ] ; then
        tbx_dirs
        return
    elif [ "$O_WIN" = "ON" ] ; then
        win_set_d1
    else
        D1="$UX_D0"/nss$NSSVER
    fi

    set_d2

    if [ -z "${BCDIST}" ] ; then
        #BCDIST=/h/blds-sca15a/export/builds/mccrel/nss/${BC_MASTER}/${MASTERBUILD}/mozilla/dist
        BCDIST=${D1}/../${BC_MASTER}/${MASTERBUILD}/mozilla/dist
        if [ ! -d $BCDIST ] ; then
            ask "Backward compatibility dierectory $BCDIST does not exist, continue" "y" "n" || Exit
        fi
    fi

    UX_MASTERDIR=${D2}/${UX_MASTERBUILD}
    find_nt_masterbuild

    if [ "$O_WIN" = "ON" ]
    then
        MOZILLA_ROOT=${NT_MASTERDIR}/mozilla
    else
        MOZILLA_ROOT=${UX_MASTERDIR}/mozilla
    fi

    UXDIST=${UX_MASTERDIR}/mozilla/dist
    NTDIST=${NT_MASTERDIR}/mozilla/dist

    if [ -z "${RESULTDIR}" ] ; then 
        RESULTDIR=${UX_MASTERDIR}/mozilla/tests_results/security
    fi

    TESTSCRIPTDIR=${MOZILLA_ROOT}/security/nss/tests

    if [ ! -d $TESTSCRIPTDIR ]
    then
        if [ "$O_WIN" = "ON" -a "$WIN_WAIT_FOREVER" = "ON" ]
        then
            WaitForever $TESTSCRIPTDIR/all.sh 1
        else
            Exit "Test directory $TESTSCRIPTDIR does not exist"
        fi
    fi

    COMMON=${TESTSCRIPTDIR}/common

    set_objdir
    debug_dirs
    export_dirs
}

debug_dirs()
{
    Debug "NTDIST $NTDIST"
    Debug "UXDIST $UXDIST"
    Debug "TESTSCRIPTDIR $TESTSCRIPTDIR"
    Debug "RESULTDIR $RESULTDIR"
    Debug "TMP $TMP"
    Debug "LOCALDIST_BIN $LOCALDIST_BIN"
    Debug "COMMON $COMMON"
    Debug "MOZILLA_ROOT $MOZILLA_ROOT"
    Debug "BCDIST $BCDIST"
}

export_dirs()
{
    export D1 D2 NTDIST UXDIST RESULTDIR TESTSCRIPTDIR BCDIST
    export UX_MASTERDIR NT_MASTERDIR COMMON MOZILLA_ROOT
}

################################### init_files ###########################
# global shell function, sets filenames, initializes files, part of init 
########################################################################
init_files()
{
    if [ $O_CRONFILE = "ON" ]
    then
        Debug "attempting to create resultfiles"
        NEWFILENAME=$RESULTDIR/$HOST.`basename $0`
        if [ ! -d $RESULTDIR ]
        then
            mkdir -p $RESULTDIR || Exit "Error: can't make $RESULTDIR"
        fi
        if [ ! -w $RESULTDIR ] ; then
            Exit "can't touch $NEWFILENAME"
        fi
        Debug "About to touch $NEWFILENAME "
        touch $NEWFILENAME || Exit "Error: can't touch $NEWFILENAME"
        Debug "About to cat $FILENAME >>$NEWFILENAME "
        cat $FILENAME >>$NEWFILENAME || Exit "Error: can't append $FILENAME to $NEWFILENAME"
        TMPFILES="$TMPFILES $FILENAME"
        FILENAME=$NEWFILENAME
        Debug "Writing output to $FILENAME"
    fi
}

################################### eval_opts ##########################
# global shell function, for NT and cron operation, first a tmpfile 
# needs to be created
########################################################################
write_to_tmpfile()
{
    O_CRONFILE=ON
    O_FILE=ON
    FILENAME=${TMP}/nsstmp.$$    # for now write to the temporary file
                                 # since we don't know the hostname yet
                                 # will be inserted to the real file later
    TMPFILES="$TMPFILES nsstmp.$$"        
    touch $FILENAME || Exit "Error: can't touch $FILENAME"
    Debug "Writing output to $FILENAME"
}

############################# turn_on_cronoptions ######################
# global shell function, turns on options needed for cron and tinderbox
########################################################################
turn_on_cronoptions()
{
    O_CRON=ON
    O_SILENT=ON
    O_DEBUG=ON                # FIXME take out!
    O_ALWAYS_YES=ON
    write_to_tmpfile
}

################################### eval_opts ##########################
# global shell function, evapuates options and parameters, sets flags
# variables and defaults
########################################################################
eval_opts()
{
  while [ -n "$1" ]
  do
    case $1 in
        -cron)
            turn_on_cronoptions
            ;;
        -T*|-t*)
            O_TBX=ON
            turn_on_cronoptions
            O_SILENT=OFF	#FIXME debug only
            ;;
        -S*|-s*)
            O_SILENT=ON
            ;;
        -Y*|-y)
            O_ALWAYS_YES=ON
            ;;
        -d*|-D)
            O_DEBUG=ON
            #set -x
            ;;
        -m*|-M*)
            O_MAIL=ON
            shift
            MAILINGLIST=$1
            if [ -z "$MAILINGLIST" ]
            then
                glob_usage "Error: -m requires a mailinglist to follow, for example sonmi,wtc,nelsonb "
            fi
            Debug "Sending result to $MAILINGLIST"
            ;;
        -fcron*|-F[Cc][Rr][Oo][Nn]*)
            write_to_tmpfile
            ;;
        -f|-F)
            O_FILE=ON
            shift
            FILENAME=$1
            if [ -z "$FILENAME" ]
            then
                glob_usage "Error: -f requires a filename to follow"
            fi
            #rm -f $FILENAME 2>/dev/null
            touch $FILENAME || Exit "Error: can't touch $FILENAME"
                                    #NOTE we append rather that creating
            Debug "Writing output to $FILENAME"
            ;;
        -h|-help|"-?")
            glob_usage
            ;;
        -*)
            glob_usage "Error: Can't handle option $1"
            ;;
        ?*)
            NSSVER=$1
            if [ -z "$NSSVER" ]        
            then
                NSSVER="tip"
                Debug "NSS Version: Parameters missing - defaulting to tip!"
            else
                BUILDDATE=$2
                if [ -z "$BUILDDATE" ] 
                then
                    BUILDDATE=`date +%m%d`
                    Debug "Builddate: Parameters missing - defaulting to today!"
                else
                    shift
                fi
            fi
            ;;
    esac
    shift
  done

  if [ -z "$BUILDDATE" ]         
  then
      BUILDDATE=`date +%m%d`
      Debug "Builddate: Parameters missing - defaulting to today!"
  fi
  if [ -z "$NSSVER" ]            
  then
      NSSVER="tip"
      Debug "NSS Version: Parameters missing - defaulting to tip!"
  fi
  
  Debug "Builddate $BUILDDATE NssVersion $NSSVER"
  export BUILDDATE NSSVER
  export O_CRON O_SILENT O_DEBUG O_ALWAYS_YES O_TBX
}

######################### win_set_d1 ################################
# global shell function, interactively finds the directories in case
# windows can't get to the default
########################################################################
win_set_d1()
{
    Debug "set Windows Directories..."
    TMP=`echo "$TMP" | sed -e 's/\\\/\//g'`
    Debug "TMP reformated to $TMP"
    if [ "$O_CYGNUS" = ON ]
    then
        D1=/cygdrive/w/nss/nss$NSSVER
    else
        D1=w:/nss/nss$NSSVER
    fi
    if [ ! -w $D1 ]
    then
        Echo "Windows special... can't write in $D1"
        if [ "$O_CYGNUS" = ON ]
        then
            D1=/cygdrive/u/nss/nss$NSSVER
        else
            D1="u:/nss/nss$NSSVER"
        fi
    else
        Debug "D1 set to $D1"
        return
    fi

    while [ ! -w $D1 ]
    do
        if [ "$O_CRONFILE" = "ON" ] 
        then
            Exit "cant write in $D1" 
        fi
        Warning "cant write in $D1" 
        Echo "input start directory (u:/nss, d:/src/nss, f:/shared/nss) "
        read D
        if [ -n "$D" ]
        then
            D1=$D/nss$NSSVER
        fi
    done
    Debug "D1 set to $D1"
}

########################### init_host ##################################
# global shell function, sets required variables HOST and DOMSUF, and asks
# the user if it has been set right
########################################################################
set_host()
{
    init_host
}
init_host()
{
    init_host_done=0

    if [ $DS_WAS_SET = FALSE ] #give chance to overwrite, espec. for NT
    then
        Debug "Domainname was not set..."
        DOMSUF=`domainname 2>/dev/null`
        if [ -z "$DOMSUF" ]
        then
            Debug "domainname command did not work ..."
            DOMSUF=`echo $HOST | grep '\.' | sed -e "s/[^\.]*\.//"`
    
            if [ -z "$DOMSUF" ]
            then
                Debug "Domainname not part of the hostname"
                DOMSUF=`cat /etc/defaultdomain 2>/dev/null`
                if [ -z "$DOMSUF" ]
                then
                    Debug "Domainname needs to be hardcoded to red.iplanet.com"
                    DOMSUF="red.iplanet.com"
                fi
            fi
        fi
    fi
    case $HOST in
        *\.*)
            Debug "HOSTNAME $HOST contains Dot"
            HOST=`echo $HOST | sed -e "s/\..*//"`
            ;;
    esac
    if [ -z "$HOST" ]
    then
        HOST=`uname -n`
        case $HOST in
            *\.*)
                Debug "HOSTNAME $HOST contains Dot"
                HOST=`echo $HOST | sed -e "s/\..*//"`
                ;;
        esac
    fi
    if [ $O_DEBUG = "ON" ]
    then
        while [ $init_host_done -eq 0 ]
        do
            Echo
            ask "DOMSUF=$DOMSUF, HOST=$HOST - OK", "y" "n" &&
                init_host_done=1
            if [ $init_host_done -eq 0 ]
            then
                Echo "input DOMSUF: "
                read D
                if [ -n "$D" ]
                then
                    DOMSUF=$D
                fi
                Echo "input HOST: "
                read H
                if [ -n "$H" ]
                then
                    HOST=$H
                fi
            fi
        done
    fi
    export HOST DOMSUF
    Debug "HOST: $HOST, DOMSUF: $DOMSUF"
}

#-----------------------------# UTILS #----------------------------------

########################### qa_stat_get_sysinfo ########################
# local shell function, tries to determine the QA operating system
########################################################################
qa_stat_get_sysinfo()
{
    case $1 in
        ?*) REM_SYS=$1
            GET_SYSINFO="rsh $1"
            ;;
        *)  REM_SYS=""
            GET_SYSINFO=""
            ;;
    esac
    QA_SYS=`$GET_SYSINFO uname -sr`
    echo $QA_SYS | grep Linux >/dev/null &&
              QA_RHVER=`$GET_SYSINFO cat /etc/redhat-release`
    if [ -n "$QA_RHVER" ]
    then
        QA_OS=`echo $REM_SYS $QA_RHVER | sed -e "s/Red Hat /RH /" \
                    -e "s/ release//"`
    else
        case $QA_SYS in
            *SunOS*5.8*)
                ISAINFO=`$GET_SYSINFO isainfo -v`
                IS_64=`echo $ISAINFO | grep 64 >/dev/null && \
                    echo 64 bit`
                IS_I386=`echo $ISAINFO | grep i386 >/dev/null && \
                    echo i86pc`
                if [ -n "$IS_I386" ] ; then IS_64="$IS_I386"; fi;
                if [ -z "$IS_64" ] ; then IS_64="32 bit"; fi;
                ;;
            *HP*)
                IS_64=`$GET_SYSINFO getconf KERNEL_BITS |
                    grep 64 >/dev/null && echo 64 bit`
                if [ -z "$IS_64" ] ; then IS_64="32 bit"; fi;
                ;;
            *AIX*)
                IS_64=`$GET_SYSINFO lslpp -l |
                    grep "bos.64bit"> /dev/null && echo 64 bit`
                if [ -z "$IS_64" ] ; then IS_64="32 bit"; fi;
                ;;
        esac
        QA_OS=`echo "$REM_SYS $QA_SYS $IS_64"`
    fi
    if [ "$O_SILENT" != ON ] ; then
        echo $QA_OS
    fi
    QA_OS_STRING=`echo $QA_OS | sed -e "s/^[_ ]//" -e "s/ /_/g"`
}

################################### set_objdir #########################
# global shell function, sets the object directories and DIST
########################################################################
set_objdir()
{
    OBJDIR=`cd ${TESTSCRIPTDIR}/common; gmake objdir_name`
    OS_ARCH=`cd ${TESTSCRIPTDIR}/common; gmake os_arch`
    
    #at this point $MASTERBUILD needs to be either NT or unix

    set_d2
    LOCALDIST_BIN=${LOCALDIST}/${OBJDIR}/bin
    DIST=$LOCALDIST

    if [ -z "${TEST_LEVEL}" ] ; then 
        TEST_LEVEL=0
    fi
    bc ${TEST_LEVEL}   #set the path for the backward compatibility test

    PATH_CONTAINS_BIN="TRUE"
    export PATH_CONTAINS_BIN

    export OBJDIR OS_ARCH LOCALDIST LOCALDIST_BIN DIST PATH 
}

########################### bc #########################################
# global shell function , sets paths for the backward compatibility test
########################################################################
bc()
{
  DON_T_SET_PATHS="TRUE"
  case $1 in
    0)
      #unset TESTDIR
      TESTDIR=${RESULTDIR}
      if [ "$O_WIN" = "ON" -a "$O_CYGNUS" != ON ] ; then
          PATH="$TESTSCRIPTDIR;$LOCALDIST_BIN;$BASEPATH"
      else
          PATH=$TESTSCRIPTDIR:$LOCALDIST_BIN:$BASEPATH
      fi
      BC_ACTION=""
      DON_T_SET_PATHS="FALSE" #let init.sh override - FIXME - check if necessary
      ;;
    1)
      TESTDIR=${RESULTDIR}/bc_libs
      BC_ACTION="backward compatibility shlibs in $BC_MASTER to new binaries"
      LD_LIBRARY_PATH=${BCDIST}/${OBJDIR}/lib
      if [ "$O_WIN" = "ON" ] ; then
          if [ "$O_CYGNUS" = ON ] ; then
              PATH=$TESTSCRIPTDIR:$LOCALDIST_BIN:$BASEPATH:$LD_LIBRARY_PATH
          else
              PATH="$TESTSCRIPTDIR;$LOCALDIST_BIN;$BASEPATH;$LD_LIBRARY_PATH"
          fi
      else
          PATH=$TESTSCRIPTDIR:$LOCALDIST_BIN:$BASEPATH
      fi
      Debug "1st stage of backward compatibility test"
      ;;
    *)
      TESTDIR=${RESULTDIR}/bc_bins
      BC_ACTION="backward compatibility of binaries in $BC_MASTER to new libs"
      BCDIST_BIN=${BCDIST}/${OBJDIR}/bin
      LD_LIBRARY_PATH=${LOCALDIST}/${OBJDIR}/lib
      if [ "$O_WIN" = "ON" ] ; then
          if [ "$O_CYGNUS" = ON ] ; then
              PATH=$TESTSCRIPTDIR:$BCDIST_BIN:$BASEPATH:$LD_LIBRARY_PATH
          else
              PATH="$TESTSCRIPTDIR;$BCDIST_BIN;$BASEPATH;$LD_LIBRARY_PATH"
          fi
      else
          PATH=$TESTSCRIPTDIR:$BCDIST_BIN:$BASEPATH
      fi
      Debug "2nd stage of backward compatibility test"
      ;;
  esac
  if [ -n "$TESTDIR" ] ; then
      if [ ! -d $TESTDIR ] ; then
          mkdir -p $TESTDIR
      fi
      export TESTDIR
  fi
  SHLIB_PATH=${LD_LIBRARY_PATH}
  LIBPATH=${LD_LIBRARY_PATH}
  Debug "PATH $PATH"
  Debug "LD_LIBRARY_PATH $LD_LIBRARY_PATH"
  export PATH LD_LIBRARY_PATH SHLIB_PATH LIBPATH
  export DON_T_SET_PATHS BC_ACTION
}

########################### Ps #########################################
# global shell function , attempts a platform specific ps
########################################################################
Ps()
{
#AIX, OSF ps -ef, solaris /usr/5bin/ps -ef, win ps -ef but no user id
#linux ps -ef, HP

    if [ $os_name = "SunOS" ]
    then
        /usr/5bin/ps -ef
    else
        ps -ef
    fi
}

########################### kill_by_name ################################
# global shell function , kills the process whose name is given as 
# parameter 
########################################################################
kill_by_name()
{
    for PID in `Ps | grep "$1" | grep -v grep | \
        sed -e "s/^ *//g" -e "s/^[^ ]* //" -e "s/^ *//g" -e "s/ .*//g"`
    do
        if [ $O_WIN = "ON" -a $O_CYGNUS = "ON" ]
        then
            ask "Do you want to kill Process $PID (`Ps | grep $PID | \
                grep -v grep | awk '{ print $1, $2, $6, $7, $8, $9 }' | \
                sed -e "s/[0-9]:[0-6][0-9]//g" | grep $PID `)" \
                "y" "n" && {
                kill $PID
                sleep 1
                kill -9 $PID 2>/dev/null
            }
        else
            ask "Do you want to kill Process $PID (`Ps | grep $PID | \
                grep -v grep | awk '{ print $1, $2, $8, $9, $10, $11 }' | \
                sed -e "s/[0-9]:[0-6][0-9]//g" | grep $PID `)" \
                "y" "n" && {
                kill $PID
                sleep 1
                kill -9 $PID 2>/dev/null
            }
        fi
    done
}

############################### early_exit ###################################
# global shell function , attempts a little more usefull user notification
# of a complete failure
########################################################################

early_exit()
{
    if [ -z "$DOCDIR" ]
    then
        DOCDIR=`dirname $0`/../doc
    fi
    if [ -f $DOCDIR/QAerror.html ]
    then
        Debug "Found QA errorheader"
        rm ${FILENAME}.err 2>/dev/null
        cp $DOCDIR/QAerror.html ${FILENAME}.err
        echo "$1" >>${FILENAME}.err
        echo '</font></b></h1>' >>${FILENAME}.err
        if [ -n "$FILENAME" -a -f "$FILENAME" ]
        then
            cat $FILENAME | sed -e "s/^/<br>/" >>${FILENAME}.err
        fi
        echo '</body></html>' >>${FILENAME}.err
        cat ${FILENAME}.err | $RMAIL $MAILINGLIST
        
        rm ${FILENAME}.err 2>/dev/null
        #echo "cat ${FILENAME}.err | $RMAIL $MAILINGLIST "
    fi
}

############################### Exit ###################################
# global shell function , central exiting point
# cleanup: temporary files, kill the remaining selfservers if sourcing
# script sets KILL_SELFSERV 
########################################################################
Exit()
{
    Echo $1    
    if [ "$O_CRON" = "OFF" ] 
    then
        echo $1 >&2
    fi
    if [ -f "${KILLPIDS}" ]
    then
        Debug "Attempting to kill background processes...`cat ${KILLPIDS}`"
        kill `cat "${KILLPIDS}"` 
        sleep 1
        kill -9  `cat "${KILLPIDS}"`
    fi
    if [ -n "${TMPFILES}" ]
    then
        Debug "rm -f ${TMPFILES}"
        rm -f $TMPFILES 2>/dev/null
    fi
    O_ALWAYS_YES=ON # set to non-interactive - don't ask anymore questions here
    if [ $KILL_SELFSERV = "ON" ]
    then
        kill_by_name selfserv
    fi
    if [ $O_MAIL = "ON" -a $O_FILE = "ON" ]
    then
        if [ $EARLY_EXIT = TRUE ]    #before the report file has been created
        then
            early_exit "$1"
        elif [ -n "$FILENAME" -a -f "$FILENAME" ]
        then
            cat $FILENAME | $RMAIL $MAILINGLIST
        fi
        #rm $FILENAME 2>/dev/null
    elif  [ $O_MAIL = "ON" -a $EARLY_EXIT = TRUE ]
    then
        early_exit "$1"
        rm $FILENAME 2>/dev/null
    fi
    #chmod a+rw ${RESULTDIR} ${RESULTDIR}/* ${RESULTDIR}/*/* &
    if [ -n "$O_TBX" -a "$O_TBX" = "ON" ] ; then
        exit $TBX_EXIT
    else
        exit
    fi
}

trap "rm -f ${TMPFILES} 2>/dev/null; Exit 'killed... cleaning up...'" 2 3 15

################################ Wait ##################################
# global shell function to wait for an event to happen, 1st parameter
# filename to watch, 2nd parameter 0 - wait for it to disappear, 1 wait
# for it to be created.
# uses the variables WAIT_FOR and WAIT_TIMES
# WAIT_FOR: if waiting for an event sleep n seconds before rechecking 
#     recomended value 10 minutes 600
# WAIT_TIMES: recheck n times before giving up to prevent endless loop
#     recomended 30 - total of 5h
########################################################################

Wait()
{
    i=0
    Debug "Waiting for $1"
    while [ $i -lt $WAIT_TIMES ]
    do
        i=`expr $i + 1`
        if [ -f "$1" -a $2 -eq 1 ]   # if file exists and is supposed to 
        then
            return
        fi
        if [ ! -f "$1" -a $2 -eq 0 ] # not exists and not supposed to exist
        then
            return
        fi
        Debug "Waiting for $1, loop #$i, about to sleep $WAIT_FOR seconds zzzz..."
        sleep $WAIT_FOR
    done
    TOTAL=`expr $WAIT_TIMES \* $WAIT_FOR / 60`
    Exit "I HAVE WAITED LONG ENOUGH FOR $1 NOW, I'M GONE! (THAT WAS A TOTAL OF $TOTAL MINUTES) I have better things to do... "
}

################################ WaitForever ##################################
# global shell function to wait for an event to happen, 1st parameter
# filename to watch, 2nd parameter 0 - wait for it to disappear, 1 wait
# for it to be created.
# because we daon't have any relyable cron on NT...
########################################################################

WaitForever()
{
    i=0
    Debug "Waiting for $1"
    TOTAL=0
    while [ 1 ]
    do
        i=`expr $i + 1`
        if [ -f "$1" -a $2 -eq 1 ] # if file exists and is supposed to 
        then
            return
        fi
        if [ ! -f "$1" -a $2 -eq 0 ] # not exists and not supposed to exist
        then
            return
        fi
        Debug "Waiting for $1, loop #$i, about to sleep $WAIT_FOR seconds Total $TOTAL"
        sleep $WAIT_FOR
        TOTAL=`expr $i \* $WAIT_FOR / 60`
        if [ -n "$MAX_FOREVER" ] # we are cheating. Forever can be very short...
        then
            if [ "$TOTAL" -gt "$MAX_FOREVER" ] 
            then
                Exit "I HAVE WAITED LONG ENOUGH FOR $1 NOW, I'M GONE! (THAT WAS A TOTAL OF $TOTAL MINUTES) I have better things to do... "
            fi
        fi
    done
}
################################### is_running #########################
# global shell function , implements primitive locking mechanism
# filename is passed as a parameter, if filename.* exists we assume calling
# script is running already and exit, otherwise filename.processid is 
# created 
########################################################################
is_running()
{
    Debug "Testing if $0 is already running... file ${1} - ${1}.$$"
    if [ -f ${1}.* ]
    then
        Exit "$0 seems to be running already ($1 exists) - Exiting"
    fi
    TMPFILES="$TMPFILES ${1}.$$"
    echo "running $0 on `date` PID $$" >${1}.$$
    Debug "wrote \"running $0 on `date` PID $$\" to ${1}.$$"
    
}

#---------------------------# USERCOM #---------------------------------
############################## Echo #####################################
# global shell function , depending on the options the output gets written 
# to a file, or is being discarded
# FIXME  \n and \c are mistreates by differnet shells, and linux has /bin/echo
# instead of /usr/bin/echo
########################################################################
Echo ()
{
    if [ $O_SILENT = OFF ]
    then
        echo "$*"
        #/usr/bin/echo "$*"
    fi
    if [ $O_FILE = ON ]
    then
        echo "$*" >>$FILENAME
    fi
}

################################### ask ################################
# global shell function, Asks the a question, and gives the returns 0
# on the 1st choice, 1 on the 2nd choice
#
# PARAMETERS:
#    $1 question text
#    $2 1st choice
#    $3 2nd choice
#
# MODIFIERS:
#    -y O_ALWAYS_YES will assume a first choice always (not neccessaryly "y")
#
# RETURN:
#    0 - User picked 1st choice
#    1 - User picked 2nd choice
#
# EXAMPLE
#    ask "Would you like to continue" "y" "n" || Exit
#        will produce the string "Would you like to continue (y/n) ?",
#        read input from keyboard (or assume a yes with option -y)
#        - on a yes it will return 0, on a no it will return 1, the 
#        shell interprets it as error and the || Exit will be executed
#
# NOTE: NEVER use "n" as the second parameter - it will mess up -y
#    don't ask "Continue" "n" "y" || Exit # it will Exit on a "y"
#
########################################################################
Ask()
{
    ask $*
}

ask()
{
    if [ $O_ALWAYS_YES = ON ]
    then
        Echo "$1 ($2/$3) ?"
        Echo "YES!"
        return 0
    fi
    A=""
    while [ 1 ]
    do
    
        Echo "$1 ($2/$3) ?"
        read A
        if [ -n "$A" ]
        then
            if [ $A = $2 ]
            then
                return 0
            elif [ $A = $3 ]
            then
                return 1
            fi
        fi
    done
    return 0
}

################################### Warning ############################
# global shell function, Asks the user a "... continue? (y/n)" question, 
# and exits when the user answers with no
# NOTE -y will answer the warnings always with yes
########################################################################
Warning ()
{
    ask "WARNING: $0: \n $* continue " "y" "n" || Exit 
}

################################### Debug ############################
# global shell function, when option -d Debugging output is written
########################################################################
Debug()
{
    if [ $O_DEBUG = ON ]
    then
        Echo "DEBUG: (`date +%H:%M`) $0: $*"
    fi
}

################################### line ###############################
# global shell function, supposed to make output more readable...
########################################################################
line()
{
Echo
#Echo "======================================================================="
#Echo
}

################################### opt_usage ##########################
# global shell function, tells user about available options
########################################################################
opt_usage()
{
    if [ $O_OPTIONS = "ON" ]
    then
        Echo
        line
        Echo
        Echo "    -y answer all questions with y - use at your own risk..."
        Echo "    -s silent (only usefull with -y)"
        Echo "    -h, -? - you guessed right - displays this text"
        Echo "    -d debug"
        Echo "    -f <filename> - write the (error)output to filename"
        Echo "    -fcronfile produces the resultfiles in the same locations"
        Echo "        as would have been produced with -cron"
        Echo "    -m <mailinglist> - send filename to mailinglist (csl "
        Echo "         example sonmi,nelsonb,wtc) only useful with -f"
        Echo "    -cron equivalient to -y -s -d -f \$RESULTDIR/\$HOST.nssqa"
        Echo "    -l <mozroot> run on a local build"
        Echo "    -t run on a tinderbox build (included -cron)"
    fi
    
}

################################### glob_usage #########################
# global shell function, how to use the calling script (parameters, options)
########################################################################
glob_usage()
{
    line
    Echo $1
    Echo
    if [ $O_OPTIONS = "ON" ]
    then
        Echo "usage $0 [options] nssversion builddate"
    else
        Echo "usage $0 nssversion builddate"
    fi
        
    Echo " for example: $0 30b 0926"
    Echo "     $0 31 1002"
    opt_usage
    Echo
    Exit "$1"
}

tell()
{
    if [ $O_SILENT = OFF ]
    then
        line
        pwd
        ls -CF
        line
    fi
    if [ $O_FILE = ON ]
    then
        line
        pwd >>$FILENAME
        ls -CF >>$FILENAME
        line 
    fi
}

if [ $O_INIT = "ON" ]
then
    glob_init $*
fi
EARLY_EXIT=FALSE
