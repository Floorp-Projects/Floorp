var Debugger =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// SingleModulePlugin
/******/ 		const smpCache = this.smpCache = this.smpCache || {};
/******/ 		const smpMap = this.smpMap = this.smpMap || new Map();
/******/ 		function sanitizeString(text) {
/******/ 		   return text.replace(/__webpack_require__\(\d+\)/g,"");
/******/ 		}
/******/ 		function getModuleBody(id) {
/******/ 		  if (smpCache.hasOwnProperty(id)) {
/******/ 		    return smpCache[id];
/******/ 		  }
/******/
/******/ 		  const body = sanitizeString(String(modules[id]));
/******/ 		  smpCache[id] = body;
/******/ 		  return body;
/******/ 		}
/******/ 		if (!installedModules[moduleId]) {
/******/ 			const body = getModuleBody(moduleId);
/******/ 			if (smpMap.has(body)) {
/******/ 				installedModules[moduleId] = installedModules[smpMap.get(body)];
/******/ 			}
/******/ 			else {
/******/ 				smpMap.set(body, moduleId)
/******/ 			}
/******/ 		}
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/assets/build";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	
	var _require = __webpack_require__(3),
	    bindActionCreators = _require.bindActionCreators,
	    combineReducers = _require.combineReducers;
	
	var ReactDOM = __webpack_require__(22);
	
	var _require2 = __webpack_require__(23),
	    getClient = _require2.getClient,
	    firefox = _require2.firefox;
	
	var _require3 = __webpack_require__(129),
	    renderRoot = _require3.renderRoot,
	    bootstrap = _require3.bootstrap,
	    L10N = _require3.L10N,
	    unmountRoot = _require3.unmountRoot;
	
	var _require4 = __webpack_require__(197),
	    getValue = _require4.getValue,
	    isFirefoxPanel = _require4.isFirefoxPanel;
	
	var configureStore = __webpack_require__(244);
	
	var _require5 = __webpack_require__(254),
	    onConnect = _require5.onConnect,
	    onFirefoxConnect = _require5.onFirefoxConnect;
	
	var reducers = __webpack_require__(288);
	var selectors = __webpack_require__(303);
	
	var App = __webpack_require__(304);
	
	var createStore = configureStore({
	  log: getValue("logging.actions"),
	  makeThunkArgs: (args, state) => {
	    return Object.assign({}, args, { client: getClient(state) });
	  }
	});
	
	var store = createStore(combineReducers(reducers));
	var actions = bindActionCreators(__webpack_require__(314), store.dispatch);
	
	if (!isFirefoxPanel()) {
	  window.L10N = L10N;
	  window.L10N.setBundle(__webpack_require__(636));
	}
	
	window.appStore = store;
	
	// Expose the bound actions so external things can do things like
	// selecting a source.
	window.actions = {
	  selectSource: actions.selectSource,
	  selectSourceURL: actions.selectSourceURL
	};
	
	// Globals needed for mocha integration tests
	window.getGlobalsForTesting = () => {
	  return {
	    debuggerStore: store,
	    launchpadStore: window.launchpadStore,
	    selectors,
	    actions
	  };
	};
	
	if (isFirefoxPanel()) {
	  (function () {
	    var sourceMap = __webpack_require__(316);
	    var prettyPrint = __webpack_require__(383);
	
	    module.exports = {
	      bootstrap: (_ref) => {
	        var threadClient = _ref.threadClient,
	            tabTarget = _ref.tabTarget,
	            toolbox = _ref.toolbox;
	
	        firefox.setThreadClient(threadClient);
	        firefox.setTabTarget(tabTarget);
	        renderRoot(React, ReactDOM, App, store);
	        firefox.initPage(actions);
	        return onFirefoxConnect(actions, firefox);
	      },
	      destroy: () => {
	        unmountRoot(ReactDOM);
	        sourceMap.destroyWorker();
	        prettyPrint.destroyWorker();
	      },
	      store: store,
	      actions: actions,
	      selectors: selectors,
	      client: firefox.clientCommands
	    };
	  })();
	} else {
	  bootstrap(React, ReactDOM, App, actions, store).then(conn => onConnect(conn, actions));
	}

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = devtoolsRequire("devtools/client/shared/vendor/react");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;
	
	var _createStore = __webpack_require__(4);
	
	var _createStore2 = _interopRequireDefault(_createStore);
	
	var _combineReducers = __webpack_require__(17);
	
	var _combineReducers2 = _interopRequireDefault(_combineReducers);
	
	var _bindActionCreators = __webpack_require__(19);
	
	var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);
	
	var _applyMiddleware = __webpack_require__(20);
	
	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);
	
	var _compose = __webpack_require__(21);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	var _warning = __webpack_require__(18);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/*
	* This is a dummy function to check if the function name has been altered by minification.
	* If the function has been minified and NODE_ENV !== 'production', warn the user.
	*/
	function isCrushed() {}
	
	if (false) {
	  (0, _warning2["default"])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
	}
	
	exports.createStore = _createStore2["default"];
	exports.combineReducers = _combineReducers2["default"];
	exports.bindActionCreators = _bindActionCreators2["default"];
	exports.applyMiddleware = _applyMiddleware2["default"];
	exports.compose = _compose2["default"];

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.ActionTypes = undefined;
	exports["default"] = createStore;
	
	var _isPlainObject = __webpack_require__(5);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _symbolObservable = __webpack_require__(15);
	
	var _symbolObservable2 = _interopRequireDefault(_symbolObservable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = exports.ActionTypes = {
	  INIT: '@@redux/INIT'
	};
	
	/**
	 * Creates a Redux store that holds the state tree.
	 * The only way to change the data in the store is to call `dispatch()` on it.
	 *
	 * There should only be a single store in your app. To specify how different
	 * parts of the state tree respond to actions, you may combine several reducers
	 * into a single reducer function by using `combineReducers`.
	 *
	 * @param {Function} reducer A function that returns the next state tree, given
	 * the current state tree and the action to handle.
	 *
	 * @param {any} [initialState] The initial state. You may optionally specify it
	 * to hydrate the state from the server in universal apps, or to restore a
	 * previously serialized user session.
	 * If you use `combineReducers` to produce the root reducer function, this must be
	 * an object with the same shape as `combineReducers` keys.
	 *
	 * @param {Function} enhancer The store enhancer. You may optionally specify it
	 * to enhance the store with third-party capabilities such as middleware,
	 * time travel, persistence, etc. The only store enhancer that ships with Redux
	 * is `applyMiddleware()`.
	 *
	 * @returns {Store} A Redux store that lets you read the state, dispatch actions
	 * and subscribe to changes.
	 */
	function createStore(reducer, initialState, enhancer) {
	  var _ref2;
	
	  if (typeof initialState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = initialState;
	    initialState = undefined;
	  }
	
	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }
	
	    return enhancer(createStore)(reducer, initialState);
	  }
	
	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }
	
	  var currentReducer = reducer;
	  var currentState = initialState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;
	
	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }
	
	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }
	
	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected listener to be a function.');
	    }
	
	    var isSubscribed = true;
	
	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);
	
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }
	
	      isSubscribed = false;
	
	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }
	
	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing “what changed”. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!(0, _isPlainObject2["default"])(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }
	
	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }
	
	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }
	
	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }
	
	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i]();
	    }
	
	    return action;
	  }
	
	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }
	
	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }
	
	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/zenparsing/es-observable
	   */
	  function observable() {
	    var _ref;
	
	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	
	      subscribe: function subscribe(observer) {
	        if (typeof observer !== 'object') {
	          throw new TypeError('Expected the observer to be an object.');
	        }
	
	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }
	
	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return { unsubscribe: unsubscribe };
	      }
	    }, _ref[_symbolObservable2["default"]] = function () {
	      return this;
	    }, _ref;
	  }
	
	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });
	
	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[_symbolObservable2["default"]] = observable, _ref2;
	}

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(6),
	    getPrototype = __webpack_require__(12),
	    isObjectLike = __webpack_require__(14);
	
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';
	
	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);
	
	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString.call(Ctor) == objectCtorString;
	}
	
	module.exports = isPlainObject;


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(7),
	    getRawTag = __webpack_require__(10),
	    objectToString = __webpack_require__(11);
	
	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';
	
	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
	
	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}
	
	module.exports = baseGetTag;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(8);
	
	/** Built-in value references. */
	var Symbol = root.Symbol;
	
	module.exports = Symbol;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var freeGlobal = __webpack_require__(9);
	
	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();
	
	module.exports = root;


/***/ },
/* 9 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
	
	module.exports = freeGlobal;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(7);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;
	
	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
	
	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];
	
	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}
	
	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}
	
	module.exports = getRawTag;


/***/ },
/* 11 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;
	
	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}
	
	module.exports = objectToString;


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(13);
	
	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);
	
	module.exports = getPrototype;


/***/ },
/* 13 */
/***/ function(module, exports) {

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}
	
	module.exports = overArg;


/***/ },
/* 14 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}
	
	module.exports = isObjectLike;


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global window */
	'use strict';
	
	module.exports = __webpack_require__(16)(global || window || this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 16 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function symbolObservablePonyfill(root) {
		var result;
		var Symbol = root.Symbol;
	
		if (typeof Symbol === 'function') {
			if (Symbol.observable) {
				result = Symbol.observable;
			} else {
				result = Symbol('observable');
				Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}
	
		return result;
	};


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = combineReducers;
	
	var _createStore = __webpack_require__(4);
	
	var _isPlainObject = __webpack_require__(5);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _warning = __webpack_require__(18);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function getUndefinedStateErrorMessage(key, action) {
	  var actionType = action && action.type;
	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';
	
	  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
	}
	
	function getUnexpectedStateShapeWarningMessage(inputState, reducers, action) {
	  var reducerKeys = Object.keys(reducers);
	  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';
	
	  if (reducerKeys.length === 0) {
	    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
	  }
	
	  if (!(0, _isPlainObject2["default"])(inputState)) {
	    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
	  }
	
	  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
	    return !reducers.hasOwnProperty(key);
	  });
	
	  if (unexpectedKeys.length > 0) {
	    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
	  }
	}
	
	function assertReducerSanity(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });
	
	    if (typeof initialState === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
	    }
	
	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
	    if (typeof reducer(undefined, { type: type }) === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
	    }
	  });
	}
	
	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */
	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};
	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];
	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  var finalReducerKeys = Object.keys(finalReducers);
	
	  var sanityError;
	  try {
	    assertReducerSanity(finalReducers);
	  } catch (e) {
	    sanityError = e;
	  }
	
	  return function combination() {
	    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    var action = arguments[1];
	
	    if (sanityError) {
	      throw sanityError;
	    }
	
	    if (false) {
	      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action);
	      if (warningMessage) {
	        (0, _warning2["default"])(warningMessage);
	      }
	    }
	
	    var hasChanged = false;
	    var nextState = {};
	    for (var i = 0; i < finalReducerKeys.length; i++) {
	      var key = finalReducerKeys[i];
	      var reducer = finalReducers[key];
	      var previousStateForKey = state[key];
	      var nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === 'undefined') {
	        var errorMessage = getUndefinedStateErrorMessage(key, action);
	        throw new Error(errorMessage);
	      }
	      nextState[key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    return hasChanged ? nextState : state;
	  };
	}

/***/ },
/* 18 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that if you enable
	    // "break on all exceptions" in your console,
	    // it would pause the execution at this line.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 19 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = bindActionCreators;
	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(undefined, arguments));
	  };
	}
	
	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass a single function as the first argument,
	 * and get a function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */
	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }
	
	  if (typeof actionCreators !== 'object' || actionCreators === null) {
	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
	  }
	
	  var keys = Object.keys(actionCreators);
	  var boundActionCreators = {};
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var actionCreator = actionCreators[key];
	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }
	  return boundActionCreators;
	}

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports["default"] = applyMiddleware;
	
	var _compose = __webpack_require__(21);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  return function (createStore) {
	    return function (reducer, initialState, enhancer) {
	      var store = createStore(reducer, initialState, enhancer);
	      var _dispatch = store.dispatch;
	      var chain = [];
	
	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        }
	      };
	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = _compose2["default"].apply(undefined, chain)(store.dispatch);
	
	      return _extends({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

/***/ },
/* 21 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = compose;
	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */
	
	function compose() {
	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }
	
	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  } else {
	    var _ret = function () {
	      var last = funcs[funcs.length - 1];
	      var rest = funcs.slice(0, -1);
	      return {
	        v: function v() {
	          return rest.reduceRight(function (composed, f) {
	            return f(composed);
	          }, last.apply(undefined, arguments));
	        }
	      };
	    }();
	
	    if (typeof _ret === "object") return _ret.v;
	  }
	}

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ReactDOM v15.3.1
	 *
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	// Based off https://github.com/ForbesLindesay/umd/blob/master/template.js
	;(function(f) {
	  // CommonJS
	  if (true) {
	    module.exports = f(__webpack_require__(2));
	
	  // RequireJS
	  } else if (typeof define === "function" && define.amd) {
	    define(['react'], f);
	
	  // <script>
	  } else {
	    var g;
	    if (typeof window !== "undefined") {
	      g = window;
	    } else if (typeof global !== "undefined") {
	      g = global;
	    } else if (typeof self !== "undefined") {
	      g = self;
	    } else {
	      // works providing we're not in "use strict";
	      // needed for Java 8 Nashorn
	      // see https://github.com/facebook/react/issues/3037
	      g = this;
	    }
	    g.ReactDOM = f(g.React);
	  }
	
	})(function(React) {
	  return React.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
	});


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	const { Task } = __webpack_require__(24);
	const firefox = __webpack_require__(25);
	const chrome = __webpack_require__(123);
	const { createSource } = __webpack_require__(122);
	
	let clientType = null;
	function getClient() {
	  if (clientType === "chrome" || clientType === "node") {
	    return chrome.clientCommands;
	  }
	
	  return firefox.clientCommands;
	}
	
	function startDebugging(connTarget, actions) {
	  if (connTarget.type === "node") {
	    return startDebuggingNode(connTarget.param, actions);
	  }
	
	  const target = connTarget.type === "chrome" ? chrome : firefox;
	  return startDebuggingTab(target, connTarget.param, actions);
	}
	
	function startDebuggingNode(tabId, actions) {
	  return Task.spawn(function* () {
	    clientType = "node";
	
	    const tabs = yield chrome.connectNodeClient();
	    const tab = tabs.find(t => t.id.indexOf(tabId) !== -1);
	
	    yield chrome.connectNode(tab.tab);
	    chrome.initPage(actions, { clientType });
	
	    return { tabs, tab, client: chrome };
	  });
	}
	
	function startDebuggingTab(targetEnv, tabId, actions) {
	  return Task.spawn(function* () {
	    const tabs = yield targetEnv.connectClient();
	    const tab = tabs.find(t => t.id.indexOf(tabId) !== -1);
	    yield targetEnv.connectTab(tab.tab);
	
	    clientType = targetEnv === firefox ? "firefox" : "chrome";
	    targetEnv.initPage(actions, { clientType });
	
	    return { tabs, tab, client: targetEnv };
	  });
	}
	
	module.exports = {
	  getClient,
	  startDebugging,
	  firefox,
	  chrome,
	  createSource
	};

/***/ },
/* 24 */
/***/ function(module, exports) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80 filetype=javascript: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
	 * You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	/**
	 * This object provides the public module functions.
	 */
	const Task = {
	  // XXX: Not sure if this works in all cases...
	  async: function (task) {
	    return function () {
	      return Task.spawn(task, this, arguments);
	    };
	  },
	
	  /**
	   * Creates and starts a new task.
	   * @param task A generator function
	   * @return A promise, resolved when the task terminates
	   */
	  spawn: function (task, scope, args) {
	    return new Promise(function (resolve, reject) {
	      const iterator = task.apply(scope, args);
	
	      const callNext = lastValue => {
	        const iteration = iterator.next(lastValue);
	        Promise.resolve(iteration.value).then(value => {
	          if (iteration.done) {
	            resolve(value);
	          } else {
	            callNext(value);
	          }
	        }).catch(error => {
	          reject(error);
	          iterator.throw(error);
	        });
	      };
	
	      callNext(undefined);
	    });
	  }
	};
	
	module.exports = { Task };

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	const { DebuggerClient, DebuggerTransport,
	  TargetFactory, WebsocketTransport } = __webpack_require__(26);
	const { getValue } = __webpack_require__(65);
	const { setupCommands, clientCommands } = __webpack_require__(120);
	const { setupEvents, clientEvents } = __webpack_require__(121);
	
	let debuggerClient = null;
	let threadClient = null;
	let tabTarget = null;
	
	function getThreadClient() {
	  return threadClient;
	}
	
	function setThreadClient(client) {
	  threadClient = client;
	}
	
	function getTabTarget() {
	  return tabTarget;
	}
	
	function setTabTarget(target) {
	  tabTarget = target;
	}
	
	function lookupTabTarget(tab) {
	  const options = { client: debuggerClient, form: tab, chrome: false };
	  return TargetFactory.forRemoteTab(options);
	}
	
	function createTabs(tabs) {
	  return tabs.map(tab => {
	    return {
	      title: tab.title,
	      url: tab.url,
	      id: tab.actor,
	      tab,
	      clientType: "firefox"
	    };
	  });
	}
	
	function connectClient() {
	  const useProxy = !getValue("firefox.webSocketConnection");
	  const firefoxHost = getValue(useProxy ? "firefox.proxyHost" : "firefox.webSocketHost");
	
	  const socket = new WebSocket(`ws://${ firefoxHost }`);
	  const transport = useProxy ? new DebuggerTransport(socket) : new WebsocketTransport(socket);
	
	  return new Promise((resolve, reject) => {
	    debuggerClient = new DebuggerClient(transport);
	    debuggerClient.connect().then(() => {
	      if (debuggerClient !== null) {
	        return debuggerClient.listTabs().then(response => {
	          resolve(createTabs(response.tabs));
	        });
	      }
	      return resolve([]);
	    }).catch(err => {
	      console.log(err);
	      resolve([]);
	    });
	  });
	}
	
	function connectTab(tab) {
	  return new Promise((resolve, reject) => {
	    window.addEventListener("beforeunload", () => {
	      const tt = getTabTarget();
	      if (tt !== null) {
	        tt.destroy();
	      }
	    });
	
	    lookupTabTarget(tab).then(target => {
	      tabTarget = target;
	      target.activeTab.attachThread({}, (res, _threadClient) => {
	        threadClient = _threadClient;
	        threadClient.resume();
	        resolve();
	      });
	    });
	  });
	}
	
	function initPage(actions) {
	  tabTarget = getTabTarget();
	  threadClient = getThreadClient();
	
	  if (!threadClient || !tabTarget) {
	    return;
	  }
	
	  setupCommands({ threadClient, tabTarget, debuggerClient });
	
	  if (actions) {
	    // Listen to all the requested events.
	    setupEvents({ threadClient, actions });
	    Object.keys(clientEvents).forEach(eventName => {
	      if (threadClient) {
	        threadClient.addListener(eventName, clientEvents[eventName]);
	      }
	    });
	  }
	}
	
	module.exports = {
	  connectClient,
	  connectTab,
	  clientCommands,
	  clientEvents,
	  getThreadClient,
	  setThreadClient,
	  getTabTarget,
	  setTabTarget,
	  initPage
	};

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	const { KeyShortcuts } = __webpack_require__(27);
	const { DebuggerTransport } = __webpack_require__(41);
	const { DebuggerClient } = __webpack_require__(53);
	const PrefsHelper = __webpack_require__(57).PrefsHelper;
	const { TargetFactory } = __webpack_require__(58);
	const DevToolsUtils = __webpack_require__(42);
	const AppConstants = __webpack_require__(44);
	const EventEmitter = __webpack_require__(34);
	const WebsocketTransport = __webpack_require__(59);
	const Menu = __webpack_require__(60);
	const MenuItem = __webpack_require__(61);
	const Tree = __webpack_require__(62);
	const sourceUtils = __webpack_require__(63);
	const frame = __webpack_require__(64);
	
	module.exports = {
	  KeyShortcuts,
	  PrefsHelper,
	  DebuggerClient,
	  DebuggerTransport,
	  TargetFactory,
	  DevToolsUtils,
	  AppConstants,
	  EventEmitter,
	  WebsocketTransport,
	  Menu,
	  MenuItem,
	  Tree,
	  sourceUtils,
	  frame
	};


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	const { Services: { appinfo }} = __webpack_require__(28);
	const EventEmitter = __webpack_require__(34);
	const isOSX = appinfo.OS === "Darwin";
	"use strict";
	
	// List of electron keys mapped to DOM API (DOM_VK_*) key code
	const ElectronKeysMapping = {
	  "F1": "DOM_VK_F1",
	  "F2": "DOM_VK_F2",
	  "F3": "DOM_VK_F3",
	  "F4": "DOM_VK_F4",
	  "F5": "DOM_VK_F5",
	  "F6": "DOM_VK_F6",
	  "F7": "DOM_VK_F7",
	  "F8": "DOM_VK_F8",
	  "F9": "DOM_VK_F9",
	  "F10": "DOM_VK_F10",
	  "F11": "DOM_VK_F11",
	  "F12": "DOM_VK_F12",
	  "F13": "DOM_VK_F13",
	  "F14": "DOM_VK_F14",
	  "F15": "DOM_VK_F15",
	  "F16": "DOM_VK_F16",
	  "F17": "DOM_VK_F17",
	  "F18": "DOM_VK_F18",
	  "F19": "DOM_VK_F19",
	  "F20": "DOM_VK_F20",
	  "F21": "DOM_VK_F21",
	  "F22": "DOM_VK_F22",
	  "F23": "DOM_VK_F23",
	  "F24": "DOM_VK_F24",
	  "Space": "DOM_VK_SPACE",
	  "Backspace": "DOM_VK_BACK_SPACE",
	  "Delete": "DOM_VK_DELETE",
	  "Insert": "DOM_VK_INSERT",
	  "Return": "DOM_VK_RETURN",
	  "Enter": "DOM_VK_RETURN",
	  "Up": "DOM_VK_UP",
	  "Down": "DOM_VK_DOWN",
	  "Left": "DOM_VK_LEFT",
	  "Right": "DOM_VK_RIGHT",
	  "Home": "DOM_VK_HOME",
	  "End": "DOM_VK_END",
	  "PageUp": "DOM_VK_PAGE_UP",
	  "PageDown": "DOM_VK_PAGE_DOWN",
	  "Escape": "DOM_VK_ESCAPE",
	  "Esc": "DOM_VK_ESCAPE",
	  "Tab": "DOM_VK_TAB",
	  "VolumeUp": "DOM_VK_VOLUME_UP",
	  "VolumeDown": "DOM_VK_VOLUME_DOWN",
	  "VolumeMute": "DOM_VK_VOLUME_MUTE",
	  "PrintScreen": "DOM_VK_PRINTSCREEN",
	};
	
	/**
	 * Helper to listen for keyboard events decribed in .properties file.
	 *
	 * let shortcuts = new KeyShortcuts({
	 *   window
	 * });
	 * shortcuts.on("Ctrl+F", event => {
	 *   // `event` is the KeyboardEvent which relates to the key shortcuts
	 * });
	 *
	 * @param DOMWindow window
	 *        The window object of the document to listen events from.
	 * @param DOMElement target
	 *        Optional DOM Element on which we should listen events from.
	 *        If omitted, we listen for all events fired on `window`.
	 */
	function KeyShortcuts({ window, target }) {
	  this.window = window;
	  this.target = target || window;
	  this.keys = new Map();
	  this.eventEmitter = new EventEmitter();
	  this.target.addEventListener("keydown", this);
	}
	
	/*
	 * Parse an electron-like key string and return a normalized object which
	 * allow efficient match on DOM key event. The normalized object matches DOM
	 * API.
	 *
	 * @param DOMWindow window
	 *        Any DOM Window object, just to fetch its `KeyboardEvent` object
	 * @param String str
	 *        The shortcut string to parse, following this document:
	 *        https://github.com/electron/electron/blob/master/docs/api/accelerator.md
	 */
	KeyShortcuts.parseElectronKey = function(window, str) {
	  let modifiers = str.split("+");
	  let key = modifiers.pop();
	
	  let shortcut = {
	    ctrl: false,
	    meta: false,
	    alt: false,
	    shift: false,
	    // Set for character keys
	    key: undefined,
	    // Set for non-character keys
	    keyCode: undefined,
	  };
	  for (let mod of modifiers) {
	    if (mod === "Alt") {
	      shortcut.alt = true;
	    } else if (["Command", "Cmd"].includes(mod)) {
	      shortcut.meta = true;
	    } else if (["CommandOrControl", "CmdOrCtrl"].includes(mod)) {
	      if (isOSX) {
	        shortcut.meta = true;
	      } else {
	        shortcut.ctrl = true;
	      }
	    } else if (["Control", "Ctrl"].includes(mod)) {
	      shortcut.ctrl = true;
	    } else if (mod === "Shift") {
	      shortcut.shift = true;
	    } else {
	      console.error("Unsupported modifier:", mod, "from key:", str);
	      return null;
	    }
	  }
	
	  // Plus is a special case. It's a character key and shouldn't be matched
	  // against a keycode as it is only accessible via Shift/Capslock
	  if (key === "Plus") {
	    key = "+";
	  }
	
	  if (typeof key === "string" && key.length === 1) {
	    // Match any single character
	    shortcut.key = key.toLowerCase();
	  } else if (key in ElectronKeysMapping) {
	    // Maps the others manually to DOM API DOM_VK_*
	    key = ElectronKeysMapping[key];
	    shortcut.keyCode = window.KeyboardEvent[key];
	    // Used only to stringify the shortcut
	    shortcut.keyCodeString = key;
	    shortcut.key = key;
	  } else {
	    console.error("Unsupported key:", key);
	    return null;
	  }
	
	  return shortcut;
	};
	
	KeyShortcuts.stringify = function(shortcut) {
	  let list = [];
	  if (shortcut.alt) {
	    list.push("Alt");
	  }
	  if (shortcut.ctrl) {
	    list.push("Ctrl");
	  }
	  if (shortcut.meta) {
	    list.push("Cmd");
	  }
	  if (shortcut.shift) {
	    list.push("Shift");
	  }
	  let key;
	  if (shortcut.key) {
	    key = shortcut.key.toUpperCase();
	  } else {
	    key = shortcut.keyCodeString;
	  }
	  list.push(key);
	  return list.join("+");
	};
	
	KeyShortcuts.prototype = {
	  destroy() {
	    this.target.removeEventListener("keydown", this);
	    this.keys.clear();
	  },
	
	  doesEventMatchShortcut(event, shortcut) {
	    if (shortcut.meta != event.metaKey) {
	      return false;
	    }
	    if (shortcut.ctrl != event.ctrlKey) {
	      return false;
	    }
	    if (shortcut.alt != event.altKey) {
	      return false;
	    }
	    // Shift is a special modifier, it may implicitely be required if the
	    // expected key is a special character accessible via shift.
	    if (shortcut.shift != event.shiftKey && event.key &&
	        event.key.match(/[a-zA-Z]/)) {
	      return false;
	    }
	    if (shortcut.keyCode) {
	      return event.keyCode == shortcut.keyCode;
	    } else if (event.key in ElectronKeysMapping) {
	      return ElectronKeysMapping[event.key] === shortcut.key;
	    }
	
	    // get the key from the keyCode if key is not provided.
	    let key = event.key || String.fromCharCode(event.keyCode);
	
	    // For character keys, we match if the final character is the expected one.
	    // But for digits we also accept indirect match to please azerty keyboard,
	    // which requires Shift to be pressed to get digits.
	    return key.toLowerCase() == shortcut.key ||
	      (shortcut.key.match(/^[0-9]$/) &&
	       event.keyCode == shortcut.key.charCodeAt(0));
	  },
	
	  handleEvent(event) {
	    for (let [key, shortcut] of this.keys) {
	      if (this.doesEventMatchShortcut(event, shortcut)) {
	        this.eventEmitter.emit(key, event);
	      }
	    }
	  },
	
	  on(key, listener) {
	    if (typeof listener !== "function") {
	      throw new Error("KeyShortcuts.on() expects a function as " +
	                      "second argument");
	    }
	    if (!this.keys.has(key)) {
	      let shortcut = KeyShortcuts.parseElectronKey(this.window, key);
	      // The key string is wrong and we were unable to compute the key shortcut
	      if (!shortcut) {
	        return;
	      }
	      this.keys.set(key, shortcut);
	    }
	    this.eventEmitter.on(key, listener);
	  },
	
	  off(key, listener) {
	    this.eventEmitter.off(key, listener);
	  },
	};
	exports.KeyShortcuts = KeyShortcuts;


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	const Services = __webpack_require__(29);
	const SplitBox = __webpack_require__(30);
	// const SplitBoxCSS = require("./client/shared/components/splitter/SplitBox.css")
	const sprintf = __webpack_require__(33).sprintf;
	
	module.exports = {
	  Services,
	  SplitBox,
	  // SplitBoxCSS,
	  sprintf
	};


/***/ },
/* 29 */
/***/ function(module, exports) {

	module.exports = devtoolsRequire("Services");

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	const ReactDOM = __webpack_require__(31);
	const Draggable = React.createFactory(__webpack_require__(32));
	const { DOM: dom, PropTypes } = React;
	
	/**
	 * This component represents a Splitter. The splitter supports vertical
	 * as well as horizontal mode.
	 */
	const SplitBox = React.createClass({
	
	  propTypes: {
	    // Custom class name. You can use more names separated by a space.
	    className: PropTypes.string,
	    // Initial size of controlled panel.
	    initialSize: PropTypes.any,
	    // Optional initial width of controlled panel.
	    initialWidth: PropTypes.number,
	    // Optional initial height of controlled panel.
	    initialHeight: PropTypes.number,
	    // Left/top panel
	    startPanel: PropTypes.any,
	    // Left/top panel collapse state.
	    startPanelCollapsed: PropTypes.bool,
	    // Min panel size.
	    minSize: PropTypes.any,
	    // Max panel size.
	    maxSize: PropTypes.any,
	    // Right/bottom panel
	    endPanel: PropTypes.any,
	    // Right/bottom panel collapse state.
	    endPanelCollapsed: PropTypes.bool,
	    // True if the right/bottom panel should be controlled.
	    endPanelControl: PropTypes.bool,
	    // Size of the splitter handle bar.
	    splitterSize: PropTypes.number,
	    // True if the splitter bar is vertical (default is vertical).
	    vert: PropTypes.bool,
	    // Optional style properties passed into the splitbox
	    style: PropTypes.object
	  },
	
	  displayName: "SplitBox",
	
	  getDefaultProps() {
	    return {
	      splitterSize: 5,
	      vert: true,
	      endPanelControl: false,
	      endPanelCollapsed: false,
	      startPanelCollapsed: false
	    };
	  },
	
	  /**
	   * The state stores the current orientation (vertical or horizontal)
	   * and the current size (width/height). All these values can change
	   * during the component's life time.
	   */
	  getInitialState() {
	    return {
	      vert: this.props.vert,
	      width: this.props.initialWidth || this.props.initialSize,
	      height: this.props.initialHeight || this.props.initialSize
	    };
	  },
	
	  componentWillReceiveProps(nextProps) {
	    if (this.props.vert !== nextProps.vert) {
	      this.setState({ vert: nextProps.vert });
	    }
	  },
	
	  // Dragging Events
	
	  /**
	   * Set 'resizing' cursor on entire document during splitter dragging.
	   * This avoids cursor-flickering that happens when the mouse leaves
	   * the splitter bar area (happens frequently).
	   */
	  onStartMove() {
	    const splitBox = ReactDOM.findDOMNode(this);
	    const doc = splitBox.ownerDocument;
	    let defaultCursor = doc.documentElement.style.cursor;
	    doc.documentElement.style.cursor =
	      (this.state.vert ? "ew-resize" : "ns-resize");
	
	    splitBox.classList.add("dragging");
	
	    this.setState({
	      defaultCursor: defaultCursor
	    });
	  },
	
	  onStopMove() {
	    const splitBox = ReactDOM.findDOMNode(this);
	    const doc = splitBox.ownerDocument;
	    doc.documentElement.style.cursor = this.state.defaultCursor;
	
	    splitBox.classList.remove("dragging");
	  },
	
	  screenX() {
	    // NOTE: in practice the window might have a border which calls for comparing window.outerWidth and window.innerWidth
	    return window.screenX;
	  },
	
	  screenY() {
	    // NOTE: in practice the window might have a border which calls for comparing window.outerHeight and window.innerHeight
	    return window.screenY;
	  },
	
	  /**
	   * Adjust size of the controlled panel. Depending on the current
	   * orientation we either remember the width or height of
	   * the splitter box.
	   */
	  onMove(x, y) {
	    const node = ReactDOM.findDOMNode(this);
	    const doc = node.ownerDocument;
	    const win = doc.defaultView;
	
	    let size;
	    let { endPanelControl } = this.props;
	
	    if (this.state.vert) {
	      // Switch the control flag in case of RTL. Note that RTL
	      // has impact on vertical splitter only.
	      let dir = win.getComputedStyle(doc.documentElement).direction;
	      if (dir == "rtl") {
	        endPanelControl = !endPanelControl;
	      }
	
	      let innerOffset = x - this.screenX();
	      size = endPanelControl ?
	        (node.offsetLeft + node.offsetWidth) - innerOffset :
	        innerOffset - node.offsetLeft;
	
	      this.setState({
	        width: size
	      });
	    } else {
	      let innerOffset = y - this.screenY();
	      size = endPanelControl ?
	        (node.offsetTop + node.offsetHeight) - innerOffset :
	        innerOffset - node.offsetTop;
	
	      this.setState({
	        height: size
	      });
	    }
	  },
	
	  // Rendering
	  preparePanelStyles() {
	    const vert = this.state.vert;
	    const {
	      minSize, maxSize, startPanelCollapsed, endPanelControl,
	      endPanelCollapsed } = this.props;
	    let leftPanelStyle, rightPanelStyle;
	
	    // Set proper size for panels depending on the current state.
	    if (vert) {
	      let startWidth = endPanelControl ? null : this.state.width,
	        endWidth = endPanelControl ? this.state.width : null;
	
	      leftPanelStyle = {
	        maxWidth: endPanelControl ? null : maxSize,
	        minWidth: endPanelControl ? null : minSize,
	        width: startPanelCollapsed ? 0 : startWidth
	      };
	      rightPanelStyle = {
	        maxWidth: endPanelControl ? maxSize : null,
	        minWidth: endPanelControl ? minSize : null,
	        width: endPanelCollapsed ? 0 : endWidth
	      };
	    } else {
	      let startHeight = endPanelControl ? null : this.state.height,
	        endHeight = endPanelControl ? this.state.height : null;
	
	      leftPanelStyle = {
	        maxHeight: endPanelControl ? null : maxSize,
	        minHeight: endPanelControl ? null : minSize,
	        height: endPanelCollapsed ? maxSize : startHeight
	      };
	      rightPanelStyle = {
	        maxHeight: endPanelControl ? maxSize : null,
	        minHeight: endPanelControl ? minSize : null,
	        height: startPanelCollapsed ? maxSize : endHeight
	      };
	    }
	
	    return { leftPanelStyle, rightPanelStyle };
	  },
	
	  render() {
	    const vert = this.state.vert;
	    const {
	      startPanelCollapsed,
	      startPanel,
	      endPanel,
	      endPanelControl,
	      splitterSize,
	      endPanelCollapsed
	    } = this.props;
	
	    let style = Object.assign({}, this.props.style);
	
	    // Calculate class names list.
	    let classNames = ["split-box"];
	    classNames.push(vert ? "vert" : "horz");
	    if (this.props.className) {
	      classNames = classNames.concat(this.props.className.split(" "));
	    }
	
	    const { leftPanelStyle, rightPanelStyle } = this.preparePanelStyles();
	
	    // Calculate splitter size
	    let splitterStyle = {
	      flex: `0 0 ${splitterSize}px`
	    };
	
	    return (
	      dom.div({
	        className: classNames.join(" "),
	        style: style },
	        !startPanelCollapsed ?
	          dom.div({
	            className: endPanelControl ? "uncontrolled" : "controlled",
	            style: leftPanelStyle },
	            startPanel
	          ) : null,
	        Draggable({
	          className: "splitter",
	          style: splitterStyle,
	          onStart: this.onStartMove,
	          onStop: this.onStopMove,
	          onMove: this.onMove
	        }),
	        !endPanelCollapsed ?
	          dom.div({
	            className: endPanelControl ? "controlled" : "uncontrolled",
	            style: rightPanelStyle },
	            endPanel
	          ) : null
	      )
	    );
	  }
	});
	
	module.exports = SplitBox;


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ReactDOM v0.14.7
	 *
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	// Based off https://github.com/ForbesLindesay/umd/blob/master/template.js
	;(function(f) {
	  // CommonJS
	  if (true) {
	    module.exports = f(__webpack_require__(2));
	
	  // RequireJS
	  } else if (typeof define === "function" && define.amd) {
	    define(['react'], f);
	
	  // <script>
	  } else {
	    var g;
	    if (typeof window !== "undefined") {
	      g = window;
	    } else if (typeof global !== "undefined") {
	      g = global;
	    } else if (typeof self !== "undefined") {
	      g = self;
	    } else {
	      // works providing we're not in "use strict";
	      // needed for Java 8 Nashorn
	      // see https://github.com/facebook/react/issues/3037
	      g = this;
	    }
	    g.ReactDOM = f(g.React);
	  }
	
	})(function(React) {
	  return React.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
	});


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
	 * You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	const React = __webpack_require__(2);
	const ReactDOM = __webpack_require__(31);
	const { DOM: dom, PropTypes } = React;
	
	const Draggable = React.createClass({
	  displayName: "Draggable",
	
	  propTypes: {
	    onMove: PropTypes.func.isRequired,
	    onStart: PropTypes.func,
	    onStop: PropTypes.func,
	    style: PropTypes.object,
	    className: PropTypes.string
	  },
	
	  startDragging(ev) {
	    ev.preventDefault();
	    const doc = ReactDOM.findDOMNode(this).ownerDocument;
	    doc.addEventListener("mousemove", this.onMove);
	    doc.addEventListener("mouseup", this.onUp);
	    this.props.onStart && this.props.onStart();
	  },
	
	  onMove(ev) {
	    ev.preventDefault();
	    // Use screen coordinates so, moving mouse over iframes
	    // doesn't mangle (relative) coordinates.
	    this.props.onMove(ev.screenX, ev.screenY);
	  },
	
	  onUp(ev) {
	    ev.preventDefault();
	    const doc = ReactDOM.findDOMNode(this).ownerDocument;
	    doc.removeEventListener("mousemove", this.onMove);
	    doc.removeEventListener("mouseup", this.onUp);
	    this.props.onStop && this.props.onStop();
	  },
	
	  render() {
	    return dom.div({
	      style: this.props.style,
	      className: this.props.className,
	      onMouseDown: this.startDragging
	    });
	  }
	});
	
	module.exports = Draggable;


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2007-2016, Alexandru Marasteanu <hello [at) alexei (dot] ro>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 * * Redistributions of source code must retain the above copyright
	 *   notice, this list of conditions and the following disclaimer.
	 * * Redistributions in binary form must reproduce the above copyright
	 *   notice, this list of conditions and the following disclaimer in the
	 *   documentation and/or other materials provided with the distribution.
	 * * Neither the name of this software nor the names of its contributors may be
	 *   used to endorse or promote products derived from this software without
	 *   specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
	 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 *
	 */
	
	/* globals window, exports, define */
	
	(function(window) {
	    'use strict'
	
	    var re = {
	        not_string: /[^s]/,
	        not_bool: /[^t]/,
	        not_type: /[^T]/,
	        not_primitive: /[^v]/,
	        number: /[diefg]/,
	        numeric_arg: /bcdiefguxX/,
	        json: /[j]/,
	        not_json: /[^j]/,
	        text: /^[^\x25]+/,
	        modulo: /^\x25{2}/,
	        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijosStTuvxX])/,
	        key: /^([a-z_][a-z_\d]*)/i,
	        key_access: /^\.([a-z_][a-z_\d]*)/i,
	        index_access: /^\[(\d+)\]/,
	        sign: /^[\+\-]/
	    }
	
	    function sprintf() {
	        var key = arguments[0], cache = sprintf.cache
	        if (!(cache[key] && cache.hasOwnProperty(key))) {
	            cache[key] = sprintf.parse(key)
	        }
	        return sprintf.format.call(null, cache[key], arguments)
	    }
	
	    sprintf.format = function(parse_tree, argv) {
	        var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = ''
	        for (i = 0; i < tree_length; i++) {
	            node_type = get_type(parse_tree[i])
	            if (node_type === 'string') {
	                output[output.length] = parse_tree[i]
	            }
	            else if (node_type === 'array') {
	                match = parse_tree[i] // convenience purposes only
	                if (match[2]) { // keyword argument
	                    arg = argv[cursor]
	                    for (k = 0; k < match[2].length; k++) {
	                        if (!arg.hasOwnProperty(match[2][k])) {
	                            throw new Error(sprintf('[sprintf] property "%s" does not exist', match[2][k]))
	                        }
	                        arg = arg[match[2][k]]
	                    }
	                }
	                else if (match[1]) { // positional argument (explicit)
	                    arg = argv[match[1]]
	                }
	                else { // positional argument (implicit)
	                    arg = argv[cursor++]
	                }
	
	                if (re.not_type.test(match[8]) && re.not_primitive.test(match[8]) && get_type(arg) == 'function') {
	                    arg = arg()
	                }
	
	                if (re.numeric_arg.test(match[8]) && (get_type(arg) != 'number' && isNaN(arg))) {
	                    throw new TypeError(sprintf("[sprintf] expecting number but found %s", get_type(arg)))
	                }
	
	                if (re.number.test(match[8])) {
	                    is_positive = arg >= 0
	                }
	
	                switch (match[8]) {
	                    case 'b':
	                        arg = parseInt(arg, 10).toString(2)
	                    break
	                    case 'c':
	                        arg = String.fromCharCode(parseInt(arg, 10))
	                    break
	                    case 'd':
	                    case 'i':
	                        arg = parseInt(arg, 10)
	                    break
	                    case 'j':
	                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)
	                    break
	                    case 'e':
	                        arg = match[7] ? parseFloat(arg).toExponential(match[7]) : parseFloat(arg).toExponential()
	                    break
	                    case 'f':
	                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)
	                    break
	                    case 'g':
	                        arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg)
	                    break
	                    case 'o':
	                        arg = arg.toString(8)
	                    break
	                    case 's':
	                    case 'S':
	                        arg = String(arg)
	                        arg = (match[7] ? arg.substring(0, match[7]) : arg)
	                    break
	                    case 't':
	                        arg = String(!!arg)
	                        arg = (match[7] ? arg.substring(0, match[7]) : arg)
	                    break
	                    case 'T':
	                        arg = get_type(arg)
	                        arg = (match[7] ? arg.substring(0, match[7]) : arg)
	                    break
	                    case 'u':
	                        arg = parseInt(arg, 10) >>> 0
	                    break
	                    case 'v':
	                        arg = arg.valueOf()
	                        arg = (match[7] ? arg.substring(0, match[7]) : arg)
	                    break
	                    case 'x':
	                        arg = parseInt(arg, 10).toString(16)
	                    break
	                    case 'X':
	                        arg = parseInt(arg, 10).toString(16).toUpperCase()
	                    break
	                }
	                if (re.json.test(match[8])) {
	                    output[output.length] = arg
	                }
	                else {
	                    if (re.number.test(match[8]) && (!is_positive || match[3])) {
	                        sign = is_positive ? '+' : '-'
	                        arg = arg.toString().replace(re.sign, '')
	                    }
	                    else {
	                        sign = ''
	                    }
	                    pad_character = match[4] ? match[4] === '0' ? '0' : match[4].charAt(1) : ' '
	                    pad_length = match[6] - (sign + arg).length
	                    pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : '') : ''
	                    output[output.length] = match[5] ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)
	                }
	            }
	        }
	        return output.join('')
	    }
	
	    sprintf.cache = {}
	
	    sprintf.parse = function(fmt) {
	        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0
	        while (_fmt) {
	            if ((match = re.text.exec(_fmt)) !== null) {
	                parse_tree[parse_tree.length] = match[0]
	            }
	            else if ((match = re.modulo.exec(_fmt)) !== null) {
	                parse_tree[parse_tree.length] = '%'
	            }
	            else if ((match = re.placeholder.exec(_fmt)) !== null) {
	                if (match[2]) {
	                    arg_names |= 1
	                    var field_list = [], replacement_field = match[2], field_match = []
	                    if ((field_match = re.key.exec(replacement_field)) !== null) {
	                        field_list[field_list.length] = field_match[1]
	                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
	                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
	                                field_list[field_list.length] = field_match[1]
	                            }
	                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
	                                field_list[field_list.length] = field_match[1]
	                            }
	                            else {
	                                throw new SyntaxError("[sprintf] failed to parse named argument key")
	                            }
	                        }
	                    }
	                    else {
	                        throw new SyntaxError("[sprintf] failed to parse named argument key")
	                    }
	                    match[2] = field_list
	                }
	                else {
	                    arg_names |= 2
	                }
	                if (arg_names === 3) {
	                    throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported")
	                }
	                parse_tree[parse_tree.length] = match
	            }
	            else {
	                throw new SyntaxError("[sprintf] unexpected placeholder")
	            }
	            _fmt = _fmt.substring(match[0].length)
	        }
	        return parse_tree
	    }
	
	    var vsprintf = function(fmt, argv, _argv) {
	        _argv = (argv || []).slice(0)
	        _argv.splice(0, 0, fmt)
	        return sprintf.apply(null, _argv)
	    }
	
	    /**
	     * helpers
	     */
	    function get_type(variable) {
	        if (typeof variable === 'number') {
	            return 'number'
	        }
	        else if (typeof variable === 'string') {
	            return 'string'
	        }
	        else {
	            return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()
	        }
	    }
	
	    var preformattedPadding = {
	        '0': ['', '0', '00', '000', '0000', '00000', '000000', '0000000'],
	        ' ': ['', ' ', '  ', '   ', '    ', '     ', '      ', '       '],
	        '_': ['', '_', '__', '___', '____', '_____', '______', '_______'],
	    }
	    function str_repeat(input, multiplier) {
	        if (multiplier >= 0 && multiplier <= 7 && preformattedPadding[input]) {
	            return preformattedPadding[input][multiplier]
	        }
	        return Array(multiplier + 1).join(input)
	    }
	
	    /**
	     * export to either browser or node.js
	     */
	    if (true) {
	        exports.sprintf = sprintf
	        exports.vsprintf = vsprintf
	    }
	    else {
	        window.sprintf = sprintf
	        window.vsprintf = vsprintf
	
	        if (typeof define === 'function' && define.amd) {
	            define(function() {
	                return {
	                    sprintf: sprintf,
	                    vsprintf: vsprintf
	                }
	            })
	        }
	    }
	})(typeof window === 'undefined' ? this : window);


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	/**
	 * EventEmitter.
	 */
	
	var EventEmitter = function EventEmitter() {};
	module.exports = EventEmitter;
	
	const { Cu } = __webpack_require__(35);
	const promise = __webpack_require__(40);
	
	/**
	 * Decorate an object with event emitter functionality.
	 *
	 * @param Object aObjectToDecorate
	 *        Bind all public methods of EventEmitter to
	 *        the aObjectToDecorate object.
	 */
	EventEmitter.decorate = function EventEmitter_decorate (aObjectToDecorate) {
	  let emitter = new EventEmitter();
	  aObjectToDecorate.on = emitter.on.bind(emitter);
	  aObjectToDecorate.off = emitter.off.bind(emitter);
	  aObjectToDecorate.once = emitter.once.bind(emitter);
	  aObjectToDecorate.emit = emitter.emit.bind(emitter);
	};
	
	EventEmitter.prototype = {
	  /**
	   * Connect a listener.
	   *
	   * @param string aEvent
	   *        The event name to which we're connecting.
	   * @param function aListener
	   *        Called when the event is fired.
	   */
	  on: function EventEmitter_on(aEvent, aListener) {
	    if (!this._eventEmitterListeners)
	      this._eventEmitterListeners = new Map();
	    if (!this._eventEmitterListeners.has(aEvent)) {
	      this._eventEmitterListeners.set(aEvent, []);
	    }
	    this._eventEmitterListeners.get(aEvent).push(aListener);
	  },
	
	  /**
	   * Listen for the next time an event is fired.
	   *
	   * @param string aEvent
	   *        The event name to which we're connecting.
	   * @param function aListener
	   *        (Optional) Called when the event is fired. Will be called at most
	   *        one time.
	   * @return promise
	   *        A promise which is resolved when the event next happens. The
	   *        resolution value of the promise is the first event argument. If
	   *        you need access to second or subsequent event arguments (it's rare
	   *        that this is needed) then use aListener
	   */
	  once: function EventEmitter_once(aEvent, aListener) {
	    let deferred = promise.defer();
	
	    let handler = (aEvent, aFirstArg, ...aRest) => {
	      this.off(aEvent, handler);
	      if (aListener) {
	        aListener.apply(null, [aEvent, aFirstArg, ...aRest]);
	      }
	      deferred.resolve(aFirstArg);
	    };
	
	    handler._originalListener = aListener;
	    this.on(aEvent, handler);
	
	    return deferred.promise;
	  },
	
	  /**
	   * Remove a previously-registered event listener.  Works for events
	   * registered with either on or once.
	   *
	   * @param string aEvent
	   *        The event name whose listener we're disconnecting.
	   * @param function aListener
	   *        The listener to remove.
	   */
	  off: function EventEmitter_off(aEvent, aListener) {
	    if (!this._eventEmitterListeners)
	      return;
	    let listeners = this._eventEmitterListeners.get(aEvent);
	    if (listeners) {
	      this._eventEmitterListeners.set(aEvent, listeners.filter(l => {
	        return l !== aListener && l._originalListener !== aListener;
	      }));
	    }
	  },
	
	  /**
	   * Emit an event.  All arguments to this method will
	   * be sent to listener functions.
	   */
	  emit: function EventEmitter_emit(aEvent) {
	    if (!this._eventEmitterListeners || !this._eventEmitterListeners.has(aEvent)) {
	      return;
	    }
	
	    let originalListeners = this._eventEmitterListeners.get(aEvent);
	    for (let listener of this._eventEmitterListeners.get(aEvent)) {
	      // If the object was destroyed during event emission, stop
	      // emitting.
	      if (!this._eventEmitterListeners) {
	        break;
	      }
	
	      // If listeners were removed during emission, make sure the
	      // event handler we're going to fire wasn't removed.
	      if (originalListeners === this._eventEmitterListeners.get(aEvent) ||
	          this._eventEmitterListeners.get(aEvent).some(l => l === listener)) {
	        try {
	          listener.apply(null, arguments);
	        }
	        catch (ex) {
	          // Prevent a bad listener from interfering with the others.
	          let msg = ex + ": " + ex.stack;
	          //console.error(msg);
	          console.log(msg);
	        }
	      }
	    }
	  },
	};


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A sham for https://developer.mozilla.org/en-US/Add-ons/SDK/Low-Level_APIs/chrome
	 */
	
	var { inDOMUtils } = __webpack_require__(36);
	
	var ourServices = {
	  inIDOMUtils: inDOMUtils,
	  nsIClipboardHelper: {
	    copyString: () => {}
	  },
	  nsIXULChromeRegistry: {
	    isLocaleRTL: () => {return false;}
	  },
	  nsIDOMParser: {
	
	  },
	};
	
	module.exports = {
	  Cc: name => {
	    if(typeof console !== "undefined") {
	      console.log('Cc sham for', name);
	    }
	    return {
	      getService: (name) => ourServices[name],
	      createInstance: (iface) => ourServices[iface],
	    };
	  },
	  CC: (name, iface, method) => {
	    if(typeof console !== "undefined") {
	      console.log('CC sham for', name, iface, method);
	    }
	    return {
	    };
	  },
	  Ci: {
	    nsIThread: {
	      "DISPATCH_NORMAL":0,
	      "DISPATCH_SYNC":1
	    },
	    nsIDOMNode: typeof HTMLElement !== "undefined" ? HTMLElement : null,
	    nsIFocusManager: {
	      MOVEFOCUS_BACKWARD: 2,
	      MOVEFOCUS_FORWARD: 1,
	    },
	    nsIDOMKeyEvent: {
	
	    },
	    nsIDOMCSSRule: {"UNKNOWN_RULE":0,"STYLE_RULE":1,"CHARSET_RULE":2,"IMPORT_RULE":3,"MEDIA_RULE":4,"FONT_FACE_RULE":5,"PAGE_RULE":6,"KEYFRAMES_RULE":7,"KEYFRAME_RULE":8,"MOZ_KEYFRAMES_RULE":7,"MOZ_KEYFRAME_RULE":8,"NAMESPACE_RULE":10,"COUNTER_STYLE_RULE":11,"SUPPORTS_RULE":12,"FONT_FEATURE_VALUES_RULE":14},
	    inIDOMUtils: "inIDOMUtils",
	    nsIClipboardHelper: "nsIClipboardHelper",
	    nsIXULChromeRegistry: "nsIXULChromeRegistry",
	  },
	  Cu: {
	    reportError: msg => { (typeof console !== "undefined") ? console.error(msg) : dump(msg) },
	    callFunctionWithAsyncStack: fn => fn(),
	  },
	  Cr: {},
	  components: {
	    isSuccessCode: () => (returnCode & 0x80000000) === 0,
	  }
	};


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	// A sham for inDOMUtils.
	
	"use strict";
	
	var { CSSLexer } = __webpack_require__(37);
	var { cssColors } = __webpack_require__(38);
	var { cssProperties } = __webpack_require__(39);
	
	var cssRGBMap;
	
	// From inIDOMUtils.idl.
	var EXCLUDE_SHORTHANDS = (1 << 0);
	var INCLUDE_ALIASES = (1 << 1);
	var TYPE_LENGTH = 0;
	var TYPE_PERCENTAGE = 1;
	var TYPE_COLOR = 2;
	var TYPE_URL = 3;
	var TYPE_ANGLE = 4;
	var TYPE_FREQUENCY = 5;
	var TYPE_TIME = 6;
	var TYPE_GRADIENT = 7;
	var TYPE_TIMING_FUNCTION = 8;
	var TYPE_IMAGE_RECT = 9;
	var TYPE_NUMBER = 10;
	
	function getCSSLexer(text) {
	  return new CSSLexer(text);
	}
	
	function rgbToColorName(r, g, b) {
	  if (!cssRGBMap) {
	    cssRGBMap = new Map();
	    for (let name in cssColors) {
	      cssRGBMap.set(JSON.stringify(cssColors[name]), name);
	    }
	  }
	  let value = cssRGBMap.get(JSON.stringify([r, g, b]));
	  if (!value) {
	    throw new Error("no such color");
	  }
	  return value;
	}
	
	// Taken from dom/tests/mochitest/ajax/mochikit/MochiKit/Color.js
	function _hslValue(n1, n2, hue) {
	  if (hue > 6.0) {
	    hue -= 6.0;
	  } else if (hue < 0.0) {
	    hue += 6.0;
	  }
	  var val;
	  if (hue < 1.0) {
	    val = n1 + (n2 - n1) * hue;
	  } else if (hue < 3.0) {
	    val = n2;
	  } else if (hue < 4.0) {
	    val = n1 + (n2 - n1) * (4.0 - hue);
	  } else {
	    val = n1;
	  }
	  return val;
	}
	
	// Taken from dom/tests/mochitest/ajax/mochikit/MochiKit/Color.js
	// and then modified.
	function hslToRGB([hue, saturation, lightness]) {
	  var red;
	  var green;
	  var blue;
	  if (saturation === 0) {
	    red = lightness;
	    green = lightness;
	    blue = lightness;
	  } else {
	    var m2;
	    if (lightness <= 0.5) {
	      m2 = lightness * (1.0 + saturation);
	    } else {
	      m2 = lightness + saturation - (lightness * saturation);
	    }
	    var m1 = (2.0 * lightness) - m2;
	    var f = _hslValue;
	    var h6 = hue * 6.0;
	    red = f(m1, m2, h6 + 2);
	    green = f(m1, m2, h6);
	    blue = f(m1, m2, h6 - 2);
	  }
	  return [red, green, blue];
	}
	
	function colorToRGBA(name) {
	  name = name.trim().toLowerCase();
	  if (name in cssColors) {
	    return cssColors[name];
	  }
	
	  if (name === "transparent") {
	    return [0, 0, 0, 0];
	  }
	
	  let lexer = getCSSLexer(name);
	
	  let getToken = function() {
	    while (true) {
	      let token = lexer.nextToken();
	      if (!token || token.tokenType !== "comment" ||
	          token.tokenType !== "whitespace") {
	        return token;
	      }
	    }
	  };
	
	  let requireComma = function(token) {
	    if (token.tokenType !== "symbol" || token.text !== ",") {
	      return null;
	    }
	    return getToken();
	  };
	
	  let func = getToken();
	  if (!func || func.tokenType !== "function") {
	    return null;
	  }
	  let alpha = false;
	  if (func.text === "rgb" || func.text === "hsl") {
	    // Nothing.
	  } else if (func.text === "rgba" || func.text === "hsla") {
	    alpha = true;
	  } else {
	    return null;
	  }
	
	  let vals = [];
	  for (let i = 0; i < 3; ++i) {
	    let token = getToken();
	    if (i > 0) {
	      token = requireComma(token);
	    }
	    if (token.tokenType !== "number" || !token.isInteger) {
	      return null;
	    }
	    let num = token.number;
	    if (num < 0) {
	      num = 0;
	    } else if (num > 255) {
	      num = 255;
	    }
	    vals.push(num);
	  }
	
	  if (func.text === "hsl" || func.text === "hsla") {
	    vals = hslToRGB(vals);
	  }
	
	  if (alpha) {
	    let token = requireComma(getToken());
	    if (token.tokenType !== "number") {
	      return null;
	    }
	    let num = token.number;
	    if (num < 0) {
	      num = 0;
	    } else if (num > 1) {
	      num = 1;
	    }
	    vals.push(num);
	  } else {
	    vals.push(1);
	  }
	
	  let parenToken = getToken();
	  if (!parenToken || parenToken.tokenType !== "symbol" ||
	      parenToken.text !== ")") {
	    return null;
	  }
	  if (getToken() !== null) {
	    return null;
	  }
	
	  return vals;
	}
	
	function isValidCSSColor(name) {
	  return colorToRGBA(name) !== null;
	}
	
	function isVariable(name) {
	  return name.startsWith("--");
	}
	
	function cssPropertyIsShorthand(name) {
	  if (isVariable(name)) {
	    return false;
	  }
	  if (!(name in cssProperties)) {
	    throw Error("unknown property " + name);
	  }
	  return !!cssProperties[name].subproperties;
	}
	
	function getSubpropertiesForCSSProperty(name) {
	  if (isVariable(name)) {
	    return [name];
	  }
	  if (!(name in cssProperties)) {
	    throw Error("unknown property " + name);
	  }
	  if ("subproperties" in cssProperties[name]) {
	    return cssProperties[name].subproperties.slice();
	  }
	  return [name];
	}
	
	function getCSSValuesForProperty(name) {
	  if (isVariable(name)) {
	    return ["initial", "inherit", "unset"];
	  }
	  if (!(name in cssProperties)) {
	    throw Error("unknown property " + name);
	  }
	  return cssProperties[name].values.slice();
	}
	
	function getCSSPropertyNames(flags) {
	  let names = Object.keys(cssProperties);
	  if ((flags & EXCLUDE_SHORTHANDS) !== 0) {
	    names = names.filter((name) => cssProperties[name].subproperties);
	  }
	  if ((flags & INCLUDE_ALIASES) === 0) {
	    names = names.filter((name) => !cssProperties[name].alias);
	  }
	  return names;
	}
	
	function cssPropertySupportsType(name, type) {
	  if (isVariable(name)) {
	    return false;
	  }
	  if (!(name in cssProperties)) {
	    throw Error("unknown property " + name);
	  }
	  return (cssProperties[name].supports & (1 << type)) !== 0;
	}
	
	function isInheritedProperty(name) {
	  if (isVariable(name)) {
	    return true;
	  }
	  if (!(name in cssProperties)) {
	    return false;
	  }
	  return cssProperties[name].inherited;
	}
	
	function cssPropertyIsValid(name, value) {
	  if (isVariable(name)) {
	    return true;
	  }
	  if (!(name in cssProperties)) {
	    return false;
	  }
	  let elt = document.createElement("div");
	  elt.style = name + ":" + value;
	  return elt.style.length > 0;
	}
	
	exports.inDOMUtils = {
	  getCSSLexer,
	  rgbToColorName,
	  colorToRGBA,
	  isValidCSSColor,
	  cssPropertyIsShorthand,
	  getSubpropertiesForCSSProperty,
	  getCSSValuesForProperty,
	  getCSSPropertyNames,
	  cssPropertySupportsType,
	  isInheritedProperty,
	  cssPropertyIsValid,
	
	  // Constants.
	  EXCLUDE_SHORTHANDS,
	  INCLUDE_ALIASES,
	  TYPE_LENGTH,
	  TYPE_PERCENTAGE,
	  TYPE_COLOR,
	  TYPE_URL,
	  TYPE_ANGLE,
	  TYPE_FREQUENCY,
	  TYPE_TIME,
	  TYPE_GRADIENT,
	  TYPE_TIMING_FUNCTION,
	  TYPE_IMAGE_RECT,
	  TYPE_NUMBER,
	};


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	(function (root, factory) {
	    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
	    // Rhino, and plain browser loading.
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports !== 'undefined') {
	        factory(exports);
	    } else {
	        factory(root);
	    }
	}(this, function (exports) {
	
	function between(num, first, last) { return num >= first && num <= last; }
	function digit(code) { return between(code, 0x30,0x39); }
	function hexdigit(code) { return digit(code) || between(code, 0x41,0x46) || between(code, 0x61,0x66); }
	function uppercaseletter(code) { return between(code, 0x41,0x5a); }
	function lowercaseletter(code) { return between(code, 0x61,0x7a); }
	function letter(code) { return uppercaseletter(code) || lowercaseletter(code); }
	function nonascii(code) { return code >= 0x80; }
	function namestartchar(code) { return letter(code) || nonascii(code) || code == 0x5f; }
	function namechar(code) { return namestartchar(code) || digit(code) || code == 0x2d; }
	function nonprintable(code) { return between(code, 0,8) || code == 0xb || between(code, 0xe,0x1f) || code == 0x7f; }
	function newline(code) { return code == 0xa; }
	function whitespace(code) { return newline(code) || code == 9 || code == 0x20; }
	
	var maximumallowedcodepoint = 0x10ffff;
	
	var InvalidCharacterError = function(message) {
		this.message = message;
	};
	InvalidCharacterError.prototype = new Error;
	InvalidCharacterError.prototype.name = 'InvalidCharacterError';
	
	function stringFromCode(code) {
		if(code <= 0xffff) return String.fromCharCode(code);
		// Otherwise, encode astral char as surrogate pair.
		code -= Math.pow(2, 20);
		var lead = Math.floor(code/Math.pow(2, 10)) + 0xd800;
		var trail = code % Math.pow(2, 10) + 0xdc00;
		return String.fromCharCode(lead) + String.fromCharCode(trail);
	}
	
	function* tokenize(str, options) {
		if (options === undefined) {
			options = {};
		}
		if (options.loc === undefined) {
			options.loc = false;
		}
		if (options.offsets === undefined) {
			options.offsets = false;
		}
		if (options.keepComments === undefined) {
			options.keepComments = false;
		}
		if (options.startOffset === undefined) {
			options.startOffset = 0;
		}
	
		var i = options.startOffset - 1;
		var code;
	
		// Line number information.
		var line = 0;
		var column = 0;
		// The only use of lastLineLength is in reconsume().
		var lastLineLength = 0;
		var incrLineno = function() {
			line += 1;
			lastLineLength = column;
			column = 0;
		};
		var locStart = {line:line, column:column};
		var offsetStart = i;
	
		var codepoint = function(i) {
			if(i >= str.length) {
				return -1;
			}
			return str.charCodeAt(i);
		};
		var next = function(num) {
			if(num === undefined)
				num = 1;
			if(num > 3)
				throw "Spec Error: no more than three codepoints of lookahead.";
	
			var rcode;
			for (var offset = i + 1; num-- > 0; ++offset) {
				rcode = codepoint(offset);
				if (rcode === 0xd && codepoint(offset+1) === 0xa) {
					++offset;
					rcode = 0xa;
				} else if (rcode === 0xd || rcode === 0xc) {
					rcode = 0xa;
				} else if (rcode === 0x0) {
					rcode = 0xfffd;
				}
			}
	
			return rcode;
		};
		var consume = function(num) {
			if(num === undefined)
				num = 1;
			while(num-- > 0) {
				++i;
				code = codepoint(i);
				if (code === 0xd && codepoint(i+1) === 0xa) {
					++i;
					code = 0xa;
				} else if (code === 0xd || code === 0xc) {
					code = 0xa;
				} else if (code === 0x0) {
					code = 0xfffd;
				}
				if(newline(code)) incrLineno();
				else column++;
			}
			return true;
		};
		var reconsume = function() {
			i -= 1;		// This is ok even in the \r\n case.
			if (newline(code)) {
				line -= 1;
				column = lastLineLength;
			} else {
				column -= 1;
			}
			return true;
		};
		var eof = function(codepoint) {
			if(codepoint === undefined) codepoint = code;
			return codepoint == -1;
		};
		var donothing = function() {};
		var parseerror = function() { console.log("Parse error at index " + i + ", processing codepoint 0x" + code.toString(16) + ".");return true; };
	
		var consumeAToken = function() {
			consume();
			if (!options.keepComments) {
				while(code == 0x2f && next() == 0x2a) {
					consumeAComment();
					consume();
				}
			}
			locStart.line = line;
			locStart.column = column;
			offsetStart = i;
			if(whitespace(code)) {
				while(whitespace(next())) consume();
				return new WhitespaceToken;
			}
			else if(code == 0x2f && next() == 0x2a) return consumeAComment();
			else if(code == 0x22) return consumeAStringToken();
			else if(code == 0x23) {
				if(namechar(next()) || areAValidEscape(next(1), next(2))) {
					var token = new HashToken();
					if(wouldStartAnIdentifier(next(1), next(2), next(3))) {
						token.type = "id";
						token.tokenType = "id";
					}
					token.value = consumeAName();
					token.text = token.value;
					return token;
				} else {
					return new DelimToken(code);
				}
			}
			else if(code == 0x24) {
				if(next() == 0x3d) {
					consume();
					return new SuffixMatchToken();
				} else {
					return new DelimToken(code);
				}
			}
			else if(code == 0x27) return consumeAStringToken();
			else if(code == 0x28) return new OpenParenToken();
			else if(code == 0x29) return new CloseParenToken();
			else if(code == 0x2a) {
				if(next() == 0x3d) {
					consume();
					return new SubstringMatchToken();
				} else {
					return new DelimToken(code);
				}
			}
			else if(code == 0x2b) {
				if(startsWithANumber()) {
					reconsume();
					return consumeANumericToken();
				} else {
					return new DelimToken(code);
				}
			}
			else if(code == 0x2c) return new CommaToken();
			else if(code == 0x2d) {
				if(startsWithANumber()) {
					reconsume();
					return consumeANumericToken();
				} else if(next(1) == 0x2d && next(2) == 0x3e) {
					consume(2);
					return new CDCToken();
				} else if(startsWithAnIdentifier()) {
					reconsume();
					return consumeAnIdentlikeToken();
				} else {
					return new DelimToken(code);
				}
			}
			else if(code == 0x2e) {
				if(startsWithANumber()) {
					reconsume();
					return consumeANumericToken();
				} else {
					return new DelimToken(code);
				}
			}
			else if(code == 0x3a) return new ColonToken;
			else if(code == 0x3b) return new SemicolonToken;
			else if(code == 0x3c) {
				if(next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) {
					consume(3);
					return new CDOToken();
				} else {
					return new DelimToken(code);
				}
			}
			else if(code == 0x40) {
				if(wouldStartAnIdentifier(next(1), next(2), next(3))) {
					return new AtKeywordToken(consumeAName());
				} else {
					return new DelimToken(code);
				}
			}
			else if(code == 0x5b) return new OpenSquareToken();
			else if(code == 0x5c) {
				if(startsWithAValidEscape()) {
					reconsume();
					return consumeAnIdentlikeToken();
				} else {
					parseerror();
					return new DelimToken(code);
				}
			}
			else if(code == 0x5d) return new CloseSquareToken();
			else if(code == 0x5e) {
				if(next() == 0x3d) {
					consume();
					return new PrefixMatchToken();
				} else {
					return new DelimToken(code);
				}
			}
			else if(code == 0x7b) return new OpenCurlyToken();
			else if(code == 0x7c) {
				if(next() == 0x3d) {
					consume();
					return new DashMatchToken();
				// } else if(next() == 0x7c) {
				// 	consume();
				// 	return new ColumnToken();
				} else {
					return new DelimToken(code);
				}
			}
			else if(code == 0x7d) return new CloseCurlyToken();
			else if(code == 0x7e) {
				if(next() == 0x3d) {
					consume();
					return new IncludeMatchToken();
				} else {
					return new DelimToken(code);
				}
			}
			else if(digit(code)) {
				reconsume();
				return consumeANumericToken();
			}
			else if(namestartchar(code)) {
				reconsume();
				return consumeAnIdentlikeToken();
			}
			else if(eof()) return new EOFToken();
			else return new DelimToken(code);
		};
	
		var consumeAComment = function() {
			consume();
			var comment = "";
			while(true) {
				consume();
				if(code == 0x2a && next() == 0x2f) {
					consume();
					break;
				} else if(eof()) {
					break;
				}
				comment += stringFromCode(code);
			}
			return new CommentToken(comment);
		};
	
		var consumeANumericToken = function() {
			var num = consumeANumber();
			var token;
			if(wouldStartAnIdentifier(next(1), next(2), next(3))) {
				token = new DimensionToken();
				token.value = num.value;
				token.repr = num.repr;
				token.type = num.type;
				token.unit = consumeAName();
				token.text = token.unit;
			} else if(next() == 0x25) {
				consume();
				token = new PercentageToken();
				token.value = num.value;
				token.repr = num.repr;
			} else {
				var token = new NumberToken();
				token.value = num.value;
				token.repr = num.repr;
				token.type = num.type;
			}
			token.number = token.value;
			token.isInteger = token.type === "integer";
			// FIXME hasSign
			return token;
		};
	
		var consumeAnIdentlikeToken = function() {
			var str = consumeAName();
			if(str.toLowerCase() == "url" && next() == 0x28) {
				consume();
				while(whitespace(next(1)) && whitespace(next(2)))
					consume();
				if((next() == 0x22 || next() == 0x27) ||
				   (whitespace(next()) && (next(2) == 0x22 || next(2) == 0x27))) {
					while(whitespace(next()))
						consume();
					consume();
					let str = consumeAStringToken();
					while(whitespace(next()))
						consume();
					// The closing paren.
					consume();
					return new URLToken(str.text);
				} else {
					return consumeAURLToken();
				}
			} else if(next() == 0x28) {
				consume();
				return new FunctionToken(str);
			} else {
				return new IdentToken(str);
			}
		};
	
		var consumeAStringToken = function(endingCodePoint) {
			if(endingCodePoint === undefined) endingCodePoint = code;
			var string = "";
			while(consume()) {
				if(code == endingCodePoint || eof()) {
					return new StringToken(string);
				} else if(newline(code)) {
					reconsume();
					return new BadStringToken(string);
				} else if(code == 0x5c) {
					if(eof(next())) {
						donothing();
					} else if(newline(next())) {
						consume();
					} else {
						string += stringFromCode(consumeEscape());
					}
				} else {
					string += stringFromCode(code);
				}
			}
		};
	
		var consumeAURLToken = function() {
			var token = new URLToken("");
			while(whitespace(next())) consume();
			if(eof(next())) return token;
			while(consume()) {
				if(code == 0x29 || eof()) {
					break;
				} else if(whitespace(code)) {
					while(whitespace(next()))
						consume();
					if(next() == 0x29 || eof(next())) {
						consume();
						break;
					} else {
						consumeTheRemnantsOfABadURL();
						return new BadURLToken();
					}
				} else if(code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) {
					parseerror();
					consumeTheRemnantsOfABadURL();
					return new BadURLToken();
				} else if(code == 0x5c) {
					if(startsWithAValidEscape()) {
						token.value += stringFromCode(consumeEscape());
					} else {
						parseerror();
						consumeTheRemnantsOfABadURL();
						return new BadURLToken();
					}
				} else {
					token.value += stringFromCode(code);
				}
			}
			token.text = token.value;
			return token;
		};
	
		var consumeEscape = function() {
			// Assume the the current character is the \
			// and the next code point is not a newline.
			consume();
			if(hexdigit(code)) {
				// Consume 1-6 hex digits
				var digits = [code];
				for(var total = 0; total < 5; total++) {
					if(hexdigit(next())) {
						consume();
						digits.push(code);
					} else {
						break;
					}
				}
				if(whitespace(next())) consume();
				var value = parseInt(digits.map(function(x){return String.fromCharCode(x);}).join(''), 16);
				if( value > maximumallowedcodepoint ) value = 0xfffd;
				return value;
			} else if(eof()) {
				return 0xfffd;
			} else {
				return code;
			}
		};
	
		var areAValidEscape = function(c1, c2) {
			if(c1 != 0x5c) return false;
			if(newline(c2)) return false;
			return true;
		};
		var startsWithAValidEscape = function() {
			return areAValidEscape(code, next());
		};
	
		var wouldStartAnIdentifier = function(c1, c2, c3) {
			if(c1 == 0x2d) {
				return namestartchar(c2) || c2 == 0x2d || areAValidEscape(c2, c3);
			} else if(namestartchar(c1)) {
				return true;
			} else if(c1 == 0x5c) {
				return areAValidEscape(c1, c2);
			} else {
				return false;
			}
		};
		var startsWithAnIdentifier = function() {
			return wouldStartAnIdentifier(code, next(1), next(2));
		};
	
		var wouldStartANumber = function(c1, c2, c3) {
			if(c1 == 0x2b || c1 == 0x2d) {
				if(digit(c2)) return true;
				if(c2 == 0x2e && digit(c3)) return true;
				return false;
			} else if(c1 == 0x2e) {
				if(digit(c2)) return true;
				return false;
			} else if(digit(c1)) {
				return true;
			} else {
				return false;
			}
		};
		var startsWithANumber = function() {
			return wouldStartANumber(code, next(1), next(2));
		};
	
		var consumeAName = function() {
			var result = "";
			while(consume()) {
				if(namechar(code)) {
					result += stringFromCode(code);
				} else if(startsWithAValidEscape()) {
					result += stringFromCode(consumeEscape());
				} else {
					reconsume();
					return result;
				}
			}
		};
	
		var consumeANumber = function() {
			var repr = [];
			var type = "integer";
			if(next() == 0x2b || next() == 0x2d) {
				consume();
				repr += stringFromCode(code);
			}
			while(digit(next())) {
				consume();
				repr += stringFromCode(code);
			}
			if(next(1) == 0x2e && digit(next(2))) {
				consume();
				repr += stringFromCode(code);
				consume();
				repr += stringFromCode(code);
				type = "number";
				while(digit(next())) {
					consume();
					repr += stringFromCode(code);
				}
			}
			var c1 = next(1), c2 = next(2), c3 = next(3);
			if((c1 == 0x45 || c1 == 0x65) && digit(c2)) {
				consume();
				repr += stringFromCode(code);
				consume();
				repr += stringFromCode(code);
				type = "number";
				while(digit(next())) {
					consume();
					repr += stringFromCode(code);
				}
			} else if((c1 == 0x45 || c1 == 0x65) && (c2 == 0x2b || c2 == 0x2d) && digit(c3)) {
				consume();
				repr += stringFromCode(code);
				consume();
				repr += stringFromCode(code);
				consume();
				repr += stringFromCode(code);
				type = "number";
				while(digit(next())) {
					consume();
					repr += stringFromCode(code);
				}
			}
			var value = convertAStringToANumber(repr);
			return {type:type, value:value, repr:repr};
		};
	
		var convertAStringToANumber = function(string) {
			// CSS's number rules are identical to JS, afaik.
			return +string;
		};
	
		var consumeTheRemnantsOfABadURL = function() {
			while(consume()) {
				if(code == 0x2d || eof()) {
					return;
				} else if(startsWithAValidEscape()) {
					consumeEscape();
					donothing();
				} else {
					donothing();
				}
			}
		};
	
	
	
		var iterationCount = 0;
		while(!eof(next())) {
			var token = consumeAToken();
			if (options.loc) {
				token.loc = {};
				token.loc.start = {line:locStart.line, column:locStart.column};
				token.loc.end = {line:line, column:column};
			}
			if (options.offsets) {
				token.startOffset = offsetStart;
				token.endOffset = i + 1;
			}
			yield token;
			iterationCount++;
			if(iterationCount > str.length*2) return "I'm infinite-looping!";
		}
	}
	
	function CSSParserToken() { throw "Abstract Base Class"; }
	CSSParserToken.prototype.toJSON = function() {
		return {token: this.tokenType};
	};
	CSSParserToken.prototype.toString = function() { return this.tokenType; };
	CSSParserToken.prototype.toSource = function() { return ''+this; };
	
	function BadStringToken(text) {
		this.text = text;
		return this;
	}
	BadStringToken.prototype = Object.create(CSSParserToken.prototype);
	BadStringToken.prototype.tokenType = "bad_string";
	
	function BadURLToken() { return this; }
	BadURLToken.prototype = Object.create(CSSParserToken.prototype);
	BadURLToken.prototype.tokenType = "bad_url";
	
	function WhitespaceToken() { return this; }
	WhitespaceToken.prototype = Object.create(CSSParserToken.prototype);
	WhitespaceToken.prototype.tokenType = "whitespace";
	WhitespaceToken.prototype.toString = function() { return "WS"; };
	WhitespaceToken.prototype.toSource = function() { return " "; };
	
	function CDOToken() { return this; }
	CDOToken.prototype = Object.create(CSSParserToken.prototype);
	CDOToken.prototype.tokenType = "htmlcomment";
	CDOToken.prototype.toSource = function() { return "<!--"; };
	
	function CDCToken() { return this; }
	CDCToken.prototype = Object.create(CSSParserToken.prototype);
	CDCToken.prototype.tokenType = "htmlcomment";
	CDCToken.prototype.toSource = function() { return "-->"; };
	
	function ColonToken() { return this; }
	ColonToken.prototype = Object.create(CSSParserToken.prototype);
	ColonToken.prototype.tokenType = "symbol";
	ColonToken.prototype.text = ":";
	
	function SemicolonToken() { return this; }
	SemicolonToken.prototype = Object.create(CSSParserToken.prototype);
	SemicolonToken.prototype.tokenType = "symbol";
	SemicolonToken.prototype.text = ";";
	
	function CommaToken() { return this; }
	CommaToken.prototype = Object.create(CSSParserToken.prototype);
	CommaToken.prototype.tokenType = "symbol";
	CommaToken.prototype.text = ",";
	
	function GroupingToken() { throw "Abstract Base Class"; }
	GroupingToken.prototype = Object.create(CSSParserToken.prototype);
	
	function OpenCurlyToken() { this.value = "{"; this.mirror = "}"; return this; }
	OpenCurlyToken.prototype = Object.create(GroupingToken.prototype);
	OpenCurlyToken.prototype.tokenType = "symbol";
	OpenCurlyToken.prototype.text = "{";
	
	function CloseCurlyToken() { this.value = "}"; this.mirror = "{"; return this; }
	CloseCurlyToken.prototype = Object.create(GroupingToken.prototype);
	CloseCurlyToken.prototype.tokenType = "symbol";
	CloseCurlyToken.prototype.text = "}";
	
	function OpenSquareToken() { this.value = "["; this.mirror = "]"; return this; }
	OpenSquareToken.prototype = Object.create(GroupingToken.prototype);
	OpenSquareToken.prototype.tokenType = "symbol";
	OpenSquareToken.prototype.text = "[";
	
	function CloseSquareToken() { this.value = "]"; this.mirror = "["; return this; }
	CloseSquareToken.prototype = Object.create(GroupingToken.prototype);
	CloseSquareToken.prototype.tokenType = "symbol";
	CloseSquareToken.prototype.text = "]";
	
	function OpenParenToken() { this.value = "("; this.mirror = ")"; return this; }
	OpenParenToken.prototype = Object.create(GroupingToken.prototype);
	OpenParenToken.prototype.tokenType = "symbol";
	OpenParenToken.prototype.text = "(";
	
	function CloseParenToken() { this.value = ")"; this.mirror = "("; return this; }
	CloseParenToken.prototype = Object.create(GroupingToken.prototype);
	CloseParenToken.prototype.tokenType = "symbol";
	CloseParenToken.prototype.text = ")";
	
	function IncludeMatchToken() { return this; }
	IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);
	IncludeMatchToken.prototype.tokenType = "includes";
	
	function DashMatchToken() { return this; }
	DashMatchToken.prototype = Object.create(CSSParserToken.prototype);
	DashMatchToken.prototype.tokenType = "dashmatch";
	
	function PrefixMatchToken() { return this; }
	PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);
	PrefixMatchToken.prototype.tokenType = "beginsmatch";
	
	function SuffixMatchToken() { return this; }
	SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);
	SuffixMatchToken.prototype.tokenType = "endsmatch";
	
	function SubstringMatchToken() { return this; }
	SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);
	SubstringMatchToken.prototype.tokenType = "containsmatch";
	
	function ColumnToken() { return this; }
	ColumnToken.prototype = Object.create(CSSParserToken.prototype);
	ColumnToken.prototype.tokenType = "||";
	
	function EOFToken() { return this; }
	EOFToken.prototype = Object.create(CSSParserToken.prototype);
	EOFToken.prototype.tokenType = "EOF";
	EOFToken.prototype.toSource = function() { return ""; };
	
	function DelimToken(code) {
		this.value = stringFromCode(code);
		this.text = this.value;
		return this;
	}
	DelimToken.prototype = Object.create(CSSParserToken.prototype);
	DelimToken.prototype.tokenType = "symbol";
	DelimToken.prototype.toString = function() { return "DELIM("+this.value+")"; };
	DelimToken.prototype.toJSON = function() {
		var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
		json.value = this.value;
		return json;
	};
	DelimToken.prototype.toSource = function() {
		if(this.value == "\\")
			return "\\\n";
		else
			return this.value;
	};
	
	function StringValuedToken() { throw "Abstract Base Class"; }
	StringValuedToken.prototype = Object.create(CSSParserToken.prototype);
	StringValuedToken.prototype.ASCIIMatch = function(str) {
		return this.value.toLowerCase() == str.toLowerCase();
	};
	StringValuedToken.prototype.toJSON = function() {
		var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
		json.value = this.value;
		return json;
	};
	
	function IdentToken(val) {
		this.value = val;
		this.text = val;
	}
	IdentToken.prototype = Object.create(StringValuedToken.prototype);
	IdentToken.prototype.tokenType = "ident";
	IdentToken.prototype.toString = function() { return "IDENT("+this.value+")"; };
	IdentToken.prototype.toSource = function() {
		return escapeIdent(this.value);
	};
	
	function FunctionToken(val) {
		this.value = val;
		this.text = val;
		this.mirror = ")";
	}
	FunctionToken.prototype = Object.create(StringValuedToken.prototype);
	FunctionToken.prototype.tokenType = "function";
	FunctionToken.prototype.toString = function() { return "FUNCTION("+this.value+")"; };
	FunctionToken.prototype.toSource = function() {
		return escapeIdent(this.value) + "(";
	};
	
	function AtKeywordToken(val) {
		this.value = val;
		this.text = val;
	}
	AtKeywordToken.prototype = Object.create(StringValuedToken.prototype);
	AtKeywordToken.prototype.tokenType = "at";
	AtKeywordToken.prototype.toString = function() { return "AT("+this.value+")"; };
	AtKeywordToken.prototype.toSource = function() {
		return "@" + escapeIdent(this.value);
	};
	
	function HashToken(val) {
		this.value = val;
		this.text = val;
		this.type = "unrestricted";
	}
	HashToken.prototype = Object.create(StringValuedToken.prototype);
	HashToken.prototype.tokenType = "hash";
	HashToken.prototype.toString = function() { return "HASH("+this.value+")"; };
	HashToken.prototype.toJSON = function() {
		var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
		json.value = this.value;
		json.type = this.type;
		return json;
	};
	HashToken.prototype.toSource = function() {
		if(this.type == "id") {
			return "#" + escapeIdent(this.value);
		} else {
			return "#" + escapeHash(this.value);
		}
	};
	
	function StringToken(val) {
		this.value = val;
		this.text = val;
	}
	StringToken.prototype = Object.create(StringValuedToken.prototype);
	StringToken.prototype.tokenType = "string";
	StringToken.prototype.toString = function() {
		return '"' + escapeString(this.value) + '"';
	};
	
	function CommentToken(val) {
		this.value = val;
	}
	CommentToken.prototype = Object.create(StringValuedToken.prototype);
	CommentToken.prototype.tokenType = "comment";
	CommentToken.prototype.toString = function() {
		return '/*' + this.value + '*/';
	}
	CommentToken.prototype.toSource = CommentToken.prototype.toString;
	
	function URLToken(val) {
		this.value = val;
		this.text = val;
	}
	URLToken.prototype = Object.create(StringValuedToken.prototype);
	URLToken.prototype.tokenType = "url";
	URLToken.prototype.toString = function() { return "URL("+this.value+")"; };
	URLToken.prototype.toSource = function() {
		return 'url("' + escapeString(this.value) + '")';
	};
	
	function NumberToken() {
		this.value = null;
		this.type = "integer";
		this.repr = "";
	}
	NumberToken.prototype = Object.create(CSSParserToken.prototype);
	NumberToken.prototype.tokenType = "number";
	NumberToken.prototype.toString = function() {
		if(this.type == "integer")
			return "INT("+this.value+")";
		return "NUMBER("+this.value+")";
	};
	NumberToken.prototype.toJSON = function() {
		var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
		json.value = this.value;
		json.type = this.type;
		json.repr = this.repr;
		return json;
	};
	NumberToken.prototype.toSource = function() { return this.repr; };
	
	function PercentageToken() {
		this.value = null;
		this.repr = "";
	}
	PercentageToken.prototype = Object.create(CSSParserToken.prototype);
	PercentageToken.prototype.tokenType = "percentage";
	PercentageToken.prototype.toString = function() { return "PERCENTAGE("+this.value+")"; };
	PercentageToken.prototype.toJSON = function() {
		var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
		json.value = this.value;
		json.repr = this.repr;
		return json;
	};
	PercentageToken.prototype.toSource = function() { return this.repr + "%"; };
	
	function DimensionToken() {
		this.value = null;
		this.type = "integer";
		this.repr = "";
		this.unit = "";
	}
	DimensionToken.prototype = Object.create(CSSParserToken.prototype);
	DimensionToken.prototype.tokenType = "dimension";
	DimensionToken.prototype.toString = function() { return "DIM("+this.value+","+this.unit+")"; };
	DimensionToken.prototype.toJSON = function() {
		var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
		json.value = this.value;
		json.type = this.type;
		json.repr = this.repr;
		json.unit = this.unit;
		return json;
	};
	DimensionToken.prototype.toSource = function() {
		var source = this.repr;
		var unit = escapeIdent(this.unit);
		if(unit[0].toLowerCase() == "e" && (unit[1] == "-" || between(unit.charCodeAt(1), 0x30, 0x39))) {
			// Unit is ambiguous with scinot
			// Remove the leading "e", replace with escape.
			unit = "\\65 " + unit.slice(1, unit.length);
		}
		return source+unit;
	};
	
	function escapeIdent(string) {
		string = ''+string;
		var result = '';
		var firstcode = string.charCodeAt(0);
		for(var i = 0; i < string.length; i++) {
			var code = string.charCodeAt(i);
			if(code === 0x0) {
				throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
			}
	
			if(
				between(code, 0x1, 0x1f) || code == 0x7f ||
				(i === 0 && between(code, 0x30, 0x39)) ||
				(i == 1 && between(code, 0x30, 0x39) && firstcode == 0x2d)
			) {
				result += '\\' + code.toString(16) + ' ';
			} else if(
				code >= 0x80 ||
				code == 0x2d ||
				code == 0x5f ||
				between(code, 0x30, 0x39) ||
				between(code, 0x41, 0x5a) ||
				between(code, 0x61, 0x7a)
			) {
				result += string[i];
			} else {
				result += '\\' + string[i];
			}
		}
		return result;
	}
	
	function escapeHash(string) {
		// Escapes the contents of "unrestricted"-type hash tokens.
		// Won't preserve the ID-ness of "id"-type hash tokens;
		// use escapeIdent() for that.
		string = ''+string;
		var result = '';
		for(var i = 0; i < string.length; i++) {
			var code = string.charCodeAt(i);
			if(code === 0x0) {
				throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
			}
	
			if(
				code >= 0x80 ||
				code == 0x2d ||
				code == 0x5f ||
				between(code, 0x30, 0x39) ||
				between(code, 0x41, 0x5a) ||
				between(code, 0x61, 0x7a)
			) {
				result += string[i];
			} else {
				result += '\\' + code.toString(16) + ' ';
			}
		}
		return result;
	}
	
	function escapeString(string) {
		string = ''+string;
		var result = '';
		for(var i = 0; i < string.length; i++) {
			var code = string.charCodeAt(i);
	
			if(code === 0x0) {
				throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
			}
	
			if(between(code, 0x1, 0x1f) || code == 0x7f) {
				result += '\\' + code.toString(16) + ' ';
			} else if(code == 0x22 || code == 0x5c) {
				result += '\\' + string[i];
			} else {
				result += string[i];
			}
		}
		return result;
	}
	
	// Exportation.
	exports.tokenize = tokenize;
	exports.IdentToken = IdentToken;
	exports.FunctionToken = FunctionToken;
	exports.AtKeywordToken = AtKeywordToken;
	exports.HashToken = HashToken;
	exports.StringToken = StringToken;
	exports.BadStringToken = BadStringToken;
	exports.URLToken = URLToken;
	exports.BadURLToken = BadURLToken;
	exports.DelimToken = DelimToken;
	exports.NumberToken = NumberToken;
	exports.PercentageToken = PercentageToken;
	exports.DimensionToken = DimensionToken;
	exports.IncludeMatchToken = IncludeMatchToken;
	exports.DashMatchToken = DashMatchToken;
	exports.PrefixMatchToken = PrefixMatchToken;
	exports.SuffixMatchToken = SuffixMatchToken;
	exports.SubstringMatchToken = SubstringMatchToken;
	exports.ColumnToken = ColumnToken;
	exports.WhitespaceToken = WhitespaceToken;
	exports.CDOToken = CDOToken;
	exports.CDCToken = CDCToken;
	exports.ColonToken = ColonToken;
	exports.SemicolonToken = SemicolonToken;
	exports.CommaToken = CommaToken;
	exports.OpenParenToken = OpenParenToken;
	exports.CloseParenToken = CloseParenToken;
	exports.OpenSquareToken = OpenSquareToken;
	exports.CloseSquareToken = CloseSquareToken;
	exports.OpenCurlyToken = OpenCurlyToken;
	exports.CloseCurlyToken = CloseCurlyToken;
	exports.EOFToken = EOFToken;
	exports.CSSParserToken = CSSParserToken;
	exports.GroupingToken = GroupingToken;
	
	function TokenStream(tokens) {
		// Assume that tokens is a iterator.
		this.tokens = tokens;
		this.token = undefined;
		this.stored = [];
	}
	TokenStream.prototype.consume = function(num) {
		if(num === undefined) num = 1;
		while (num-- > 0) {
			if (this.stored.length > 0) {
				this.token = this.stored.shift();
			} else {
				var n = this.tokens.next();
				while (!n.done && n.value instanceof CommentToken) {
					n = this.tokens.next();
				}
				if (n.done) {
					this.token = new EOFToken();
					break;
				}
				this.token = n.value;
			}
		}
		//console.log(this.i, this.token);
		return true;
	};
	TokenStream.prototype.next = function() {
		if (this.stored.length === 0) {
			var n = this.tokens.next();
			while (!n.done && n.value instanceof CommentToken) {
				n = this.tokens.next();
			}
			if (n.done)
				return new EOFToken();
			this.stored.push(n.value);
		}
		return this.stored[0];
	};
	TokenStream.prototype.reconsume = function() {
		this.stored.unshift(this.token);
	};
	
	function parseerror(s, msg) {
		console.log("Parse error at token " + s.i + ": " + s.token + ".\n" + msg);
		return true;
	}
	function donothing(){ return true; }
	
	function consumeAListOfRules(s, topLevel) {
		var rules = [];
		var rule;
		while(s.consume()) {
			if(s.token instanceof WhitespaceToken) {
				continue;
			} else if(s.token instanceof EOFToken) {
				return rules;
			} else if(s.token instanceof CDOToken || s.token instanceof CDCToken) {
				if(topLevel == "top-level") continue;
				s.reconsume();
				if(rule = consumeAQualifiedRule(s)) rules.push(rule);
			} else if(s.token instanceof AtKeywordToken) {
				s.reconsume();
				if(rule = consumeAnAtRule(s)) rules.push(rule);
			} else {
				s.reconsume();
				if(rule = consumeAQualifiedRule(s)) rules.push(rule);
			}
		}
	}
	
	function consumeAnAtRule(s) {
		s.consume();
		var rule = new AtRule(s.token.value);
		while(s.consume()) {
			if(s.token instanceof SemicolonToken || s.token instanceof EOFToken) {
				return rule;
			} else if(s.token instanceof OpenCurlyToken) {
				rule.value = consumeASimpleBlock(s);
				return rule;
			} else {
				s.reconsume();
				rule.prelude.push(consumeAComponentValue(s));
			}
		}
	}
	
	function consumeAQualifiedRule(s) {
		var rule = new QualifiedRule();
		while(s.consume()) {
			if(s.token instanceof EOFToken) {
				parseerror(s, "Hit EOF when trying to parse the prelude of a qualified rule.");
				return;
			} else if(s.token instanceof OpenCurlyToken) {
				rule.value = consumeASimpleBlock(s);
				return rule;
			} else {
				s.reconsume();
				rule.prelude.push(consumeAComponentValue(s));
			}
		}
	}
	
	function consumeAListOfDeclarations(s) {
		var decls = [];
		while(s.consume()) {
			if(s.token instanceof WhitespaceToken || s.token instanceof SemicolonToken) {
				donothing();
			} else if(s.token instanceof EOFToken) {
				return decls;
			} else if(s.token instanceof AtKeywordToken) {
				s.reconsume();
				decls.push(consumeAnAtRule(s));
			} else if(s.token instanceof IdentToken) {
				var temp = [s.token];
				while(!(s.next() instanceof SemicolonToken || s.next() instanceof EOFToken))
					temp.push(consumeAComponentValue(s));
				var decl;
				if(decl = consumeADeclaration(new TokenStream(temp))) decls.push(decl);
			} else {
				parseerror(s);
				s.reconsume();
				while(!(s.next() instanceof SemicolonToken || s.next() instanceof EOFToken))
					consumeAComponentValue(s);
			}
		}
	}
	
	function consumeADeclaration(s) {
		// Assumes that the next input token will be an ident token.
		s.consume();
		var decl = new Declaration(s.token.value);
		while(s.next() instanceof WhitespaceToken) s.consume();
		if(!(s.next() instanceof ColonToken)) {
			parseerror(s);
			return;
		} else {
			s.consume();
		}
		while(!(s.next() instanceof EOFToken)) {
			decl.value.push(consumeAComponentValue(s));
		}
		var foundImportant = false;
		for(var i = decl.value.length - 1; i >= 0; i--) {
			if(decl.value[i] instanceof WhitespaceToken) {
				continue;
			} else if(decl.value[i] instanceof IdentToken && decl.value[i].ASCIIMatch("important")) {
				foundImportant = true;
			} else if(foundImportant && decl.value[i] instanceof DelimToken && decl.value[i].value == "!") {
				decl.value.splice(i, decl.value.length);
				decl.important = true;
				break;
			} else {
				break;
			}
		}
		return decl;
	}
	
	function consumeAComponentValue(s) {
		s.consume();
		if(s.token instanceof OpenCurlyToken || s.token instanceof OpenSquareToken || s.token instanceof OpenParenToken)
			return consumeASimpleBlock(s);
		if(s.token instanceof FunctionToken)
			return consumeAFunction(s);
		return s.token;
	}
	
	function consumeASimpleBlock(s) {
		var mirror = s.token.mirror;
		var block = new SimpleBlock(s.token.value);
		block.startToken = s.token;
		while(s.consume()) {
			if(s.token instanceof EOFToken || (s.token instanceof GroupingToken && s.token.value == mirror))
				return block;
			else {
				s.reconsume();
				block.value.push(consumeAComponentValue(s));
			}
		}
	}
	
	function consumeAFunction(s) {
		var func = new Func(s.token.value);
		while(s.consume()) {
			if(s.token instanceof EOFToken || s.token instanceof CloseParenToken)
				return func;
			else {
				s.reconsume();
				func.value.push(consumeAComponentValue(s));
			}
		}
	}
	
	function normalizeInput(input) {
		if(typeof input == "string")
			return new TokenStream(tokenize(input));
		if(input instanceof TokenStream)
			return input;
		if(typeof (input.next) == "function")
			return new TokenStream(input);
		if(input.length !== undefined)
			return new TokenStream(input[Symbol.iterator]());
		else throw SyntaxError(input);
	}
	
	function parseAStylesheet(s) {
		s = normalizeInput(s);
		var sheet = new Stylesheet();
		sheet.value = consumeAListOfRules(s, "top-level");
		return sheet;
	}
	
	function parseAListOfRules(s) {
		s = normalizeInput(s);
		return consumeAListOfRules(s);
	}
	
	function parseARule(s) {
		s = normalizeInput(s);
		while(s.next() instanceof WhitespaceToken) s.consume();
		if(s.next() instanceof EOFToken) throw SyntaxError();
		var rule;
		var startToken = s.next();
		if(startToken instanceof AtKeywordToken) {
			rule = consumeAnAtRule(s);
		} else {
			rule = consumeAQualifiedRule(s);
			if(!rule) throw SyntaxError();
		}
		rule.startToken = startToken;
		rule.endToken = s.token;
		return rule;
	}
	
	function parseADeclaration(s) {
		s = normalizeInput(s);
		while(s.next() instanceof WhitespaceToken) s.consume();
		if(!(s.next() instanceof IdentToken)) throw SyntaxError();
		var decl = consumeADeclaration(s);
		if(decl)
			return decl;
		else
			throw SyntaxError();
	}
	
	function parseAListOfDeclarations(s) {
		s = normalizeInput(s);
		return consumeAListOfDeclarations(s);
	}
	
	function parseAComponentValue(s) {
		s = normalizeInput(s);
		while(s.next() instanceof WhitespaceToken) s.consume();
		if(s.next() instanceof EOFToken) throw SyntaxError();
		var val = consumeAComponentValue(s);
		if(!val) throw SyntaxError();
		while(s.next() instanceof WhitespaceToken) s.consume();
		if(s.next() instanceof EOFToken)
			return val;
		throw SyntaxError();
	}
	
	function parseAListOfComponentValues(s) {
		s = normalizeInput(s);
		var vals = [];
		while(true) {
			var val = consumeAComponentValue(s);
			if(val instanceof EOFToken)
				return vals;
			else
				vals.push(val);
		}
	}
	
	function parseACommaSeparatedListOfComponentValues(s) {
		s = normalizeInput(s);
		var listOfCVLs = [];
		while(true) {
			var vals = [];
			while(true) {
				var val = consumeAComponentValue(s);
				if(val instanceof EOFToken) {
					listOfCVLs.push(vals);
					return listOfCVLs;
				} else if(val instanceof CommaToken) {
					listOfCVLs.push(vals);
					break;
				} else {
					vals.push(val);
				}
			}
		}
	}
	
	
	function CSSParserRule() { throw "Abstract Base Class"; }
	CSSParserRule.prototype.toString = function(indent) {
		return JSON.stringify(this,null,indent);
	};
	CSSParserRule.prototype.toJSON = function() {
		return {type:this.type, value:this.value};
	};
	
	function Stylesheet() {
		this.value = [];
		return this;
	}
	Stylesheet.prototype = Object.create(CSSParserRule.prototype);
	Stylesheet.prototype.type = "STYLESHEET";
	
	function AtRule(name) {
		this.name = name;
		this.prelude = [];
		this.value = null;
		return this;
	}
	AtRule.prototype = Object.create(CSSParserRule.prototype);
	AtRule.prototype.type = "AT-RULE";
	AtRule.prototype.toJSON = function() {
		var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
		json.name = this.name;
		json.prelude = this.prelude;
		return json;
	};
	
	function QualifiedRule() {
		this.prelude = [];
		this.value = [];
		return this;
	}
	QualifiedRule.prototype = Object.create(CSSParserRule.prototype);
	QualifiedRule.prototype.type = "QUALIFIED-RULE";
	QualifiedRule.prototype.toJSON = function() {
		var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
		json.prelude = this.prelude;
		return json;
	};
	
	function Declaration(name) {
		this.name = name;
		this.value = [];
		this.important = false;
		return this;
	}
	Declaration.prototype = Object.create(CSSParserRule.prototype);
	Declaration.prototype.type = "DECLARATION";
	Declaration.prototype.toJSON = function() {
		var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
		json.name = this.name;
		json.important = this.important;
		return json;
	};
	
	function SimpleBlock(type) {
		this.name = type;
		this.value = [];
		return this;
	}
	SimpleBlock.prototype = Object.create(CSSParserRule.prototype);
	SimpleBlock.prototype.type = "BLOCK";
	SimpleBlock.prototype.toJSON = function() {
		var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
		json.name = this.name;
		return json;
	};
	
	function Func(name) {
		this.name = name;
		this.value = [];
		return this;
	}
	Func.prototype = Object.create(CSSParserRule.prototype);
	Func.prototype.type = "FUNCTION";
	Func.prototype.toJSON = function() {
		var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
		json.name = this.name;
		return json;
	};
	
	function CSSLexer(text) {
		this.stream = tokenize(text, {
			loc: true,
			offsets: true,
			keepComments: true
		});
		this.lineNumber = 0;
		this.columnNumber = 0;
		return this;
	}
	
	CSSLexer.prototype.performEOFFixup = function(input, preserveBackslash) {
		// Just lie for now.
		return "";
	};
	
	CSSLexer.prototype.nextToken = function() {
		if (!this.stream) {
			return null;
		}
		let v = this.stream.next();
		if (v.done || v.value.tokenType === "EOF") {
			this.stream = null;
			return null;
		}
		this.lineNumber = v.value.loc.start.line;
		this.columnNumber = v.value.loc.start.column;
		return v.value;
	};
	
	// Exportation.
	exports.CSSParserRule = CSSParserRule;
	exports.Stylesheet = Stylesheet;
	exports.AtRule = AtRule;
	exports.QualifiedRule = QualifiedRule;
	exports.Declaration = Declaration;
	exports.SimpleBlock = SimpleBlock;
	exports.Func = Func;
	exports.parseAStylesheet = parseAStylesheet;
	exports.parseAListOfRules = parseAListOfRules;
	exports.parseARule = parseARule;
	exports.parseADeclaration = parseADeclaration;
	exports.parseAListOfDeclarations = parseAListOfDeclarations;
	exports.parseAComponentValue = parseAComponentValue;
	exports.parseAListOfComponentValues = parseAListOfComponentValues;
	exports.parseACommaSeparatedListOfComponentValues = parseACommaSeparatedListOfComponentValues;
	exports.CSSLexer = CSSLexer;
	
	}));


/***/ },
/* 38 */
/***/ function(module, exports) {

	// auto-generated from nsColorNameList.h
	var cssColors = {
	  aliceblue: [240, 248, 255],
	  antiquewhite: [250, 235, 215],
	  aqua: [0, 255, 255],
	  aquamarine: [127, 255, 212],
	  azure: [240, 255, 255],
	  beige: [245, 245, 220],
	  bisque: [255, 228, 196],
	  black: [0, 0, 0],
	  blanchedalmond: [255, 235, 205],
	  blue: [0, 0, 255],
	  blueviolet: [138, 43, 226],
	  brown: [165, 42, 42],
	  burlywood: [222, 184, 135],
	  cadetblue: [95, 158, 160],
	  chartreuse: [127, 255, 0],
	  chocolate: [210, 105, 30],
	  coral: [255, 127, 80],
	  cornflowerblue: [100, 149, 237],
	  cornsilk: [255, 248, 220],
	  crimson: [220, 20, 60],
	  cyan: [0, 255, 255],
	  darkblue: [0, 0, 139],
	  darkcyan: [0, 139, 139],
	  darkgoldenrod: [184, 134, 11],
	  darkgray: [169, 169, 169],
	  darkgreen: [0, 100, 0],
	  darkgrey: [169, 169, 169],
	  darkkhaki: [189, 183, 107],
	  darkmagenta: [139, 0, 139],
	  darkolivegreen: [85, 107, 47],
	  darkorange: [255, 140, 0],
	  darkorchid: [153, 50, 204],
	  darkred: [139, 0, 0],
	  darksalmon: [233, 150, 122],
	  darkseagreen: [143, 188, 143],
	  darkslateblue: [72, 61, 139],
	  darkslategray: [47, 79, 79],
	  darkslategrey: [47, 79, 79],
	  darkturquoise: [0, 206, 209],
	  darkviolet: [148, 0, 211],
	  deeppink: [255, 20, 147],
	  deepskyblue: [0, 191, 255],
	  dimgray: [105, 105, 105],
	  dimgrey: [105, 105, 105],
	  dodgerblue: [30, 144, 255],
	  firebrick: [178, 34, 34],
	  floralwhite: [255, 250, 240],
	  forestgreen: [34, 139, 34],
	  fuchsia: [255, 0, 255],
	  gainsboro: [220, 220, 220],
	  ghostwhite: [248, 248, 255],
	  gold: [255, 215, 0],
	  goldenrod: [218, 165, 32],
	  gray: [128, 128, 128],
	  grey: [128, 128, 128],
	  green: [0, 128, 0],
	  greenyellow: [173, 255, 47],
	  honeydew: [240, 255, 240],
	  hotpink: [255, 105, 180],
	  indianred: [205, 92, 92],
	  indigo: [75, 0, 130],
	  ivory: [255, 255, 240],
	  khaki: [240, 230, 140],
	  lavender: [230, 230, 250],
	  lavenderblush: [255, 240, 245],
	  lawngreen: [124, 252, 0],
	  lemonchiffon: [255, 250, 205],
	  lightblue: [173, 216, 230],
	  lightcoral: [240, 128, 128],
	  lightcyan: [224, 255, 255],
	  lightgoldenrodyellow: [250, 250, 210],
	  lightgray: [211, 211, 211],
	  lightgreen: [144, 238, 144],
	  lightgrey: [211, 211, 211],
	  lightpink: [255, 182, 193],
	  lightsalmon: [255, 160, 122],
	  lightseagreen: [32, 178, 170],
	  lightskyblue: [135, 206, 250],
	  lightslategray: [119, 136, 153],
	  lightslategrey: [119, 136, 153],
	  lightsteelblue: [176, 196, 222],
	  lightyellow: [255, 255, 224],
	  lime: [0, 255, 0],
	  limegreen: [50, 205, 50],
	  linen: [250, 240, 230],
	  magenta: [255, 0, 255],
	  maroon: [128, 0, 0],
	  mediumaquamarine: [102, 205, 170],
	  mediumblue: [0, 0, 205],
	  mediumorchid: [186, 85, 211],
	  mediumpurple: [147, 112, 219],
	  mediumseagreen: [60, 179, 113],
	  mediumslateblue: [123, 104, 238],
	  mediumspringgreen: [0, 250, 154],
	  mediumturquoise: [72, 209, 204],
	  mediumvioletred: [199, 21, 133],
	  midnightblue: [25, 25, 112],
	  mintcream: [245, 255, 250],
	  mistyrose: [255, 228, 225],
	  moccasin: [255, 228, 181],
	  navajowhite: [255, 222, 173],
	  navy: [0, 0, 128],
	  oldlace: [253, 245, 230],
	  olive: [128, 128, 0],
	  olivedrab: [107, 142, 35],
	  orange: [255, 165, 0],
	  orangered: [255, 69, 0],
	  orchid: [218, 112, 214],
	  palegoldenrod: [238, 232, 170],
	  palegreen: [152, 251, 152],
	  paleturquoise: [175, 238, 238],
	  palevioletred: [219, 112, 147],
	  papayawhip: [255, 239, 213],
	  peachpuff: [255, 218, 185],
	  peru: [205, 133, 63],
	  pink: [255, 192, 203],
	  plum: [221, 160, 221],
	  powderblue: [176, 224, 230],
	  purple: [128, 0, 128],
	  rebeccapurple: [102, 51, 153],
	  red: [255, 0, 0],
	  rosybrown: [188, 143, 143],
	  royalblue: [65, 105, 225],
	  saddlebrown: [139, 69, 19],
	  salmon: [250, 128, 114],
	  sandybrown: [244, 164, 96],
	  seagreen: [46, 139, 87],
	  seashell: [255, 245, 238],
	  sienna: [160, 82, 45],
	  silver: [192, 192, 192],
	  skyblue: [135, 206, 235],
	  slateblue: [106, 90, 205],
	  slategray: [112, 128, 144],
	  slategrey: [112, 128, 144],
	  snow: [255, 250, 250],
	  springgreen: [0, 255, 127],
	  steelblue: [70, 130, 180],
	  tan: [210, 180, 140],
	  teal: [0, 128, 128],
	  thistle: [216, 191, 216],
	  tomato: [255, 99, 71],
	  turquoise: [64, 224, 208],
	  violet: [238, 130, 238],
	  wheat: [245, 222, 179],
	  white: [255, 255, 255],
	  whitesmoke: [245, 245, 245],
	  yellow: [255, 255, 0],
	  yellowgreen: [154, 205, 50],
	};
	module.exports = { cssColors };


/***/ },
/* 39 */
/***/ function(module, exports) {

	// auto-generated by means you would rather not know
	var cssProperties = {
	  "-moz-appearance": {
	    inherited: false,
	    supports: 0,
	    values: ["-moz-gtk-info-bar", "-moz-mac-disclosure-button-closed", "-moz-mac-disclosure-button-open", "-moz-mac-fullscreen-button", "-moz-mac-help-button", "-moz-mac-vibrancy-dark", "-moz-mac-vibrancy-light", "-moz-win-borderless-glass", "-moz-win-browsertabbar-toolbox", "-moz-win-communications-toolbox", "-moz-win-exclude-glass", "-moz-win-glass", "-moz-win-media-toolbox", "-moz-window-button-box", "-moz-window-button-box-maximized", "-moz-window-button-close", "-moz-window-button-maximize", "-moz-window-button-minimize", "-moz-window-button-restore", "-moz-window-frame-bottom", "-moz-window-frame-left", "-moz-window-frame-right", "-moz-window-titlebar", "-moz-window-titlebar-maximized", "button", "button-arrow-down", "button-arrow-next", "button-arrow-previous", "button-arrow-up", "button-bevel", "button-focus", "caret", "checkbox", "checkbox-container", "checkbox-label", "checkmenuitem", "dialog", "dualbutton", "groupbox", "inherit", "initial", "listbox", "listitem", "menuarrow", "menubar", "menucheckbox", "menuimage", "menuitem", "menuitemtext", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menupopup", "menuradio", "menuseparator", "meterbar", "meterchunk", "none", "number-input", "progressbar", "progressbar-vertical", "progresschunk", "progresschunk-vertical", "radio", "radio-container", "radio-label", "radiomenuitem", "range", "range-thumb", "resizer", "resizerpanel", "scale-horizontal", "scale-vertical", "scalethumb-horizontal", "scalethumb-vertical", "scalethumbend", "scalethumbstart", "scalethumbtick", "scrollbar", "scrollbar-small", "scrollbarbutton-down", "scrollbarbutton-left", "scrollbarbutton-right", "scrollbarbutton-up", "scrollbarthumb-horizontal", "scrollbarthumb-vertical", "scrollbartrack-horizontal", "scrollbartrack-vertical", "searchfield", "separator", "spinner", "spinner-downbutton", "spinner-textfield", "spinner-upbutton", "splitter", "statusbar", "statusbarpanel", "tab", "tab-scroll-arrow-back", "tab-scroll-arrow-forward", "tabpanel", "tabpanels", "textfield", "textfield-multiline", "toolbar", "toolbarbutton", "toolbarbutton-dropdown", "toolbargripper", "toolbox", "tooltip", "treeheader", "treeheadercell", "treeheadersortarrow", "treeitem", "treeline", "treetwisty", "treetwistyopen", "treeview", "unset", "window", ],
	  },
	  "-moz-outline-radius-topleft": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-outline-radius-topright": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-outline-radius-bottomright": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-outline-radius-bottomleft": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-tab-size": {
	    inherited: true,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "animation-delay": {
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "animation-direction": {
	    inherited: false,
	    supports: 0,
	    values: ["alternate", "alternate-reverse", "inherit", "initial", "normal", "reverse", "unset", ],
	  },
	  "animation-duration": {
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "animation-fill-mode": {
	    inherited: false,
	    supports: 0,
	    values: ["backwards", "both", "forwards", "inherit", "initial", "none", "unset", ],
	  },
	  "animation-iteration-count": {
	    inherited: false,
	    supports: 1024,
	    values: ["infinite", "inherit", "initial", "unset", ],
	  },
	  "animation-name": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "none", "unset", ],
	  },
	  "animation-play-state": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "paused", "running", "unset", ],
	  },
	  "animation-timing-function": {
	    inherited: false,
	    supports: 256,
	    values: ["cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "step-end", "step-start", "steps", "unset", ],
	  },
	  "background-attachment": {
	    inherited: false,
	    supports: 0,
	    values: ["fixed", "inherit", "initial", "local", "scroll", "unset", ],
	  },
	  "background-clip": {
	    inherited: false,
	    supports: 0,
	    values: ["border-box", "content-box", "inherit", "initial", "padding-box", "unset", ],
	  },
	  "background-color": {
	    inherited: false,
	    supports: 4,
	    values: ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "background-image": {
	    inherited: false,
	    supports: 648,
	    values: ["-moz-element", "-moz-image-rect", "-moz-linear-gradient", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "inherit", "initial", "linear-gradient", "none", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "unset", "url", ],
	  },
	  "background-blend-mode": {
	    inherited: false,
	    supports: 0,
	    values: ["color", "color-burn", "color-dodge", "darken", "difference", "exclusion", "hard-light", "hue", "inherit", "initial", "lighten", "luminosity", "multiply", "normal", "overlay", "saturation", "screen", "soft-light", "unset", ],
	  },
	  "background-origin": {
	    inherited: false,
	    supports: 0,
	    values: ["border-box", "content-box", "inherit", "initial", "padding-box", "unset", ],
	  },
	  "background-position": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "background-repeat": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "no-repeat", "repeat", "repeat-x", "repeat-y", "unset", ],
	  },
	  "background-size": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-binding": {
	    inherited: false,
	    supports: 8,
	    values: ["inherit", "initial", "none", "unset", "url", ],
	  },
	  "block-size": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "border-block-end-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-block-end-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "border-block-end-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "border-block-start-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-block-start-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "border-block-start-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "border-bottom-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "-moz-border-bottom-colors": {
	    inherited: false,
	    supports: 4,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "border-bottom-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "border-bottom-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "border-collapse": {
	    inherited: true,
	    supports: 0,
	    values: ["collapse", "inherit", "initial", "separate", "unset", ],
	  },
	  "border-image-source": {
	    inherited: false,
	    supports: 648,
	    values: ["-moz-element", "-moz-image-rect", "-moz-linear-gradient", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "inherit", "initial", "linear-gradient", "none", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "unset", "url", ],
	  },
	  "border-image-slice": {
	    inherited: false,
	    supports: 1026,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "border-image-width": {
	    inherited: false,
	    supports: 1027,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "border-image-outset": {
	    inherited: false,
	    supports: 1025,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "border-image-repeat": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "border-inline-end-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-inline-end-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "border-inline-end-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "border-inline-start-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-inline-start-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "border-inline-start-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "border-left-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "-moz-border-left-colors": {
	    inherited: false,
	    supports: 4,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "border-left-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "border-left-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "border-right-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "-moz-border-right-colors": {
	    inherited: false,
	    supports: 4,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "border-right-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "border-right-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "border-spacing": {
	    inherited: true,
	    supports: 1,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "border-top-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "-moz-border-top-colors": {
	    inherited: false,
	    supports: 4,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "border-top-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "border-top-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "border-top-left-radius": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "border-top-right-radius": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "border-bottom-right-radius": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "border-bottom-left-radius": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "bottom": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "box-decoration-break": {
	    inherited: false,
	    supports: 0,
	    values: ["clone", "inherit", "initial", "slice", "unset", ],
	  },
	  "box-shadow": {
	    inherited: false,
	    supports: 5,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "box-sizing": {
	    inherited: false,
	    supports: 0,
	    values: ["border-box", "content-box", "inherit", "initial", "padding-box", "unset", ],
	  },
	  "caption-side": {
	    inherited: true,
	    supports: 0,
	    values: ["bottom", "bottom-outside", "inherit", "initial", "left", "right", "top", "top-outside", "unset", ],
	  },
	  "clear": {
	    inherited: false,
	    supports: 0,
	    values: ["both", "inherit", "initial", "inline-end", "inline-start", "left", "none", "right", "unset", ],
	  },
	  "clip": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "color": {
	    inherited: true,
	    supports: 4,
	    values: ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "-moz-column-count": {
	    inherited: false,
	    supports: 1024,
	    values: ["auto", "inherit", "initial", "unset", ],
	  },
	  "-moz-column-fill": {
	    inherited: false,
	    supports: 0,
	    values: ["auto", "balance", "inherit", "initial", "unset", ],
	  },
	  "-moz-column-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "-moz-column-gap": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "normal", "unset", ],
	  },
	  "-moz-column-rule-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "-moz-column-rule-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "-moz-column-rule-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "contain": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "layout", "none", "paint", "strict", "style", "unset", ],
	  },
	  "content": {
	    inherited: false,
	    supports: 8,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-control-character-visibility": {
	    inherited: true,
	    supports: 0,
	    values: ["hidden", "inherit", "initial", "unset", "visible", ],
	  },
	  "counter-increment": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "counter-reset": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "cursor": {
	    inherited: true,
	    supports: 8,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "direction": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "ltr", "rtl", "unset", ],
	  },
	  "display": {
	    inherited: false,
	    supports: 0,
	    values: ["-moz-box", "-moz-deck", "-moz-grid", "-moz-grid-group", "-moz-grid-line", "-moz-groupbox", "-moz-inline-box", "-moz-inline-grid", "-moz-inline-stack", "-moz-popup", "-moz-stack", "block", "contents", "flex", "grid", "inherit", "initial", "inline", "inline-block", "inline-flex", "inline-grid", "inline-table", "list-item", "none", "ruby", "ruby-base", "ruby-base-container", "ruby-text", "ruby-text-container", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "unset", ],
	  },
	  "empty-cells": {
	    inherited: true,
	    supports: 0,
	    values: ["hide", "inherit", "initial", "show", "unset", ],
	  },
	  "align-content": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "align-items": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "align-self": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "flex-basis": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "flex-direction": {
	    inherited: false,
	    supports: 0,
	    values: ["column", "column-reverse", "inherit", "initial", "row", "row-reverse", "unset", ],
	  },
	  "flex-grow": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "flex-shrink": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "flex-wrap": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "nowrap", "unset", "wrap", "wrap-reverse", ],
	  },
	  "order": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "justify-content": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "justify-items": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "justify-self": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "float": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "inline-end", "inline-start", "left", "none", "right", "unset", ],
	  },
	  "-moz-float-edge": {
	    inherited: false,
	    supports: 0,
	    values: ["content-box", "inherit", "initial", "margin-box", "unset", ],
	  },
	  "font-family": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "font-feature-settings": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "font-kerning": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "none", "normal", "unset", ],
	  },
	  "font-language-override": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "normal", "unset", ],
	  },
	  "font-size": {
	    inherited: true,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "large", "larger", "medium", "small", "smaller", "unset", "x-large", "x-small", "xx-large", "xx-small", ],
	  },
	  "font-size-adjust": {
	    inherited: true,
	    supports: 1024,
	    values: ["inherit", "initial", "none", "unset", ],
	  },
	  "font-stretch": {
	    inherited: true,
	    supports: 0,
	    values: ["condensed", "expanded", "extra-condensed", "extra-expanded", "inherit", "initial", "normal", "semi-condensed", "semi-expanded", "ultra-condensed", "ultra-expanded", "unset", ],
	  },
	  "font-style": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "italic", "normal", "oblique", "unset", ],
	  },
	  "font-synthesis": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "font-variant-alternates": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "font-variant-caps": {
	    inherited: true,
	    supports: 0,
	    values: ["all-petite-caps", "all-small-caps", "inherit", "initial", "normal", "petite-caps", "small-caps", "titling-caps", "unicase", "unset", ],
	  },
	  "font-variant-east-asian": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "font-variant-ligatures": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "font-variant-numeric": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "font-variant-position": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "normal", "sub", "super", "unset", ],
	  },
	  "font-weight": {
	    inherited: true,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-force-broken-image-icon": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-auto-flow": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-auto-columns": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-auto-rows": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-template-areas": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-template-columns": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-template-rows": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-column-start": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-column-end": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-row-start": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-row-end": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-column-gap": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "grid-row-gap": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "height": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "image-orientation": {
	    inherited: true,
	    supports: 16,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-image-region": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "ime-mode": {
	    inherited: false,
	    supports: 0,
	    values: ["active", "auto", "disabled", "inactive", "inherit", "initial", "normal", "unset", ],
	  },
	  "inline-size": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "left": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "letter-spacing": {
	    inherited: true,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "normal", "unset", ],
	  },
	  "line-height": {
	    inherited: true,
	    supports: 1027,
	    values: ["-moz-block-height", "inherit", "initial", "normal", "unset", ],
	  },
	  "list-style-image": {
	    inherited: true,
	    supports: 8,
	    values: ["inherit", "initial", "none", "unset", "url", ],
	  },
	  "list-style-position": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "inside", "outside", "unset", ],
	  },
	  "list-style-type": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "margin-block-end": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "margin-block-start": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "margin-bottom": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "margin-inline-end": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "margin-inline-start": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "margin-left": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "margin-right": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "margin-top": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "marker-offset": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "max-block-size": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "none", "unset", ],
	  },
	  "max-height": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "calc", "inherit", "initial", "none", "unset", ],
	  },
	  "max-inline-size": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "calc", "inherit", "initial", "none", "unset", ],
	  },
	  "max-width": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "calc", "inherit", "initial", "none", "unset", ],
	  },
	  "min-height": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "min-block-size": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "min-inline-size": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "min-width": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "mix-blend-mode": {
	    inherited: false,
	    supports: 0,
	    values: ["color", "color-burn", "color-dodge", "darken", "difference", "exclusion", "hard-light", "hue", "inherit", "initial", "lighten", "luminosity", "multiply", "normal", "overlay", "saturation", "screen", "soft-light", "unset", ],
	  },
	  "isolation": {
	    inherited: false,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "isolate", "unset", ],
	  },
	  "object-fit": {
	    inherited: false,
	    supports: 0,
	    values: ["contain", "cover", "fill", "inherit", "initial", "none", "scale-down", "unset", ],
	  },
	  "object-position": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "offset-block-end": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "offset-block-start": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "offset-inline-end": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "offset-inline-start": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "opacity": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-orient": {
	    inherited: false,
	    supports: 0,
	    values: ["block", "horizontal", "inherit", "initial", "inline", "unset", "vertical", ],
	  },
	  "outline-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "outline-style": {
	    inherited: false,
	    supports: 0,
	    values: ["auto", "dashed", "dotted", "double", "groove", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "outline-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "outline-offset": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "overflow-x": {
	    inherited: false,
	    supports: 0,
	    values: ["-moz-hidden-unscrollable", "auto", "hidden", "inherit", "initial", "scroll", "unset", "visible", ],
	  },
	  "overflow-y": {
	    inherited: false,
	    supports: 0,
	    values: ["-moz-hidden-unscrollable", "auto", "hidden", "inherit", "initial", "scroll", "unset", "visible", ],
	  },
	  "padding-block-end": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "padding-block-start": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "padding-bottom": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "padding-inline-end": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "padding-inline-start": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "padding-left": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "padding-right": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "padding-top": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "page-break-after": {
	    inherited: false,
	    supports: 0,
	    values: ["always", "auto", "avoid", "inherit", "initial", "left", "right", "unset", ],
	  },
	  "page-break-before": {
	    inherited: false,
	    supports: 0,
	    values: ["always", "auto", "avoid", "inherit", "initial", "left", "right", "unset", ],
	  },
	  "page-break-inside": {
	    inherited: false,
	    supports: 0,
	    values: ["auto", "avoid", "inherit", "initial", "unset", ],
	  },
	  "paint-order": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "pointer-events": {
	    inherited: true,
	    supports: 0,
	    values: ["all", "auto", "fill", "inherit", "initial", "none", "painted", "stroke", "unset", "visible", "visiblefill", "visiblepainted", "visiblestroke", ],
	  },
	  "position": {
	    inherited: false,
	    supports: 0,
	    values: ["absolute", "fixed", "inherit", "initial", "relative", "static", "sticky", "unset", ],
	  },
	  "quotes": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "resize": {
	    inherited: false,
	    supports: 0,
	    values: ["both", "horizontal", "inherit", "initial", "none", "unset", "vertical", ],
	  },
	  "right": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "ruby-align": {
	    inherited: true,
	    supports: 0,
	    values: ["center", "inherit", "initial", "space-around", "space-between", "start", "unset", ],
	  },
	  "ruby-position": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "over", "under", "unset", ],
	  },
	  "scroll-behavior": {
	    inherited: false,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "smooth", "unset", ],
	  },
	  "scroll-snap-coordinate": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "scroll-snap-destination": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "scroll-snap-points-x": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "scroll-snap-points-y": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "scroll-snap-type-x": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "mandatory", "none", "proximity", "unset", ],
	  },
	  "scroll-snap-type-y": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "mandatory", "none", "proximity", "unset", ],
	  },
	  "table-layout": {
	    inherited: false,
	    supports: 0,
	    values: ["auto", "fixed", "inherit", "initial", "unset", ],
	  },
	  "text-align": {
	    inherited: true,
	    supports: 0,
	    values: ["-moz-center", "-moz-left", "-moz-right", "center", "end", "inherit", "initial", "justify", "left", "right", "start", "unset", ],
	  },
	  "-moz-text-align-last": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "center", "end", "inherit", "initial", "justify", "left", "right", "start", "unset", ],
	  },
	  "text-decoration-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "text-decoration-line": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "text-decoration-style": {
	    inherited: false,
	    supports: 0,
	    values: ["-moz-none", "dashed", "dotted", "double", "inherit", "initial", "solid", "unset", "wavy", ],
	  },
	  "text-indent": {
	    inherited: true,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "text-orientation": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "mixed", "sideways", "sideways-right", "unset", "upright", ],
	  },
	  "text-overflow": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "text-shadow": {
	    inherited: true,
	    supports: 5,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-text-size-adjust": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "none", "unset", ],
	  },
	  "text-transform": {
	    inherited: true,
	    supports: 0,
	    values: ["capitalize", "full-width", "inherit", "initial", "lowercase", "none", "unset", "uppercase", ],
	  },
	  "transform": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "transform-box": {
	    inherited: false,
	    supports: 0,
	    values: ["border-box", "fill-box", "inherit", "initial", "unset", "view-box", ],
	  },
	  "transform-origin": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "perspective-origin": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "perspective": {
	    inherited: false,
	    supports: 1,
	    values: ["inherit", "initial", "none", "unset", ],
	  },
	  "transform-style": {
	    inherited: false,
	    supports: 0,
	    values: ["flat", "inherit", "initial", "preserve-3d", "unset", ],
	  },
	  "backface-visibility": {
	    inherited: false,
	    supports: 0,
	    values: ["hidden", "inherit", "initial", "unset", "visible", ],
	  },
	  "top": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "transition-delay": {
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "transition-duration": {
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "transition-property": {
	    inherited: false,
	    supports: 0,
	    values: ["all", "inherit", "initial", "none", "unset", ],
	  },
	  "transition-timing-function": {
	    inherited: false,
	    supports: 256,
	    values: ["cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "step-end", "step-start", "steps", "unset", ],
	  },
	  "unicode-bidi": {
	    inherited: false,
	    supports: 0,
	    values: ["isolate", "isolate-override", "plaintext", "bidi-override", "embed", "inherit", "initial", "normal", "unset", ],
	  },
	  "-moz-user-focus": {
	    inherited: true,
	    supports: 0,
	    values: ["ignore", "inherit", "initial", "none", "normal", "select-after", "select-all", "select-before", "select-menu", "select-same", "unset", ],
	  },
	  "-moz-user-input": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "disabled", "enabled", "inherit", "initial", "none", "unset", ],
	  },
	  "-moz-user-modify": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "read-only", "read-write", "unset", "write-only", ],
	  },
	  "-moz-user-select": {
	    inherited: false,
	    supports: 0,
	    values: ["-moz-all", "-moz-none", "-moz-text", "all", "auto", "element", "elements", "inherit", "initial", "none", "text", "toggle", "tri-state", "unset", ],
	  },
	  "vertical-align": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "-moz-middle-with-baseline", "baseline", "bottom", "calc", "inherit", "initial", "middle", "sub", "super", "text-bottom", "text-top", "top", "unset", ],
	  },
	  "visibility": {
	    inherited: true,
	    supports: 0,
	    values: ["collapse", "hidden", "inherit", "initial", "unset", "visible", ],
	  },
	  "white-space": {
	    inherited: true,
	    supports: 0,
	    values: ["-moz-pre-space", "inherit", "initial", "normal", "nowrap", "pre", "pre-line", "pre-wrap", "unset", ],
	  },
	  "width": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "-moz-window-dragging": {
	    inherited: true,
	    supports: 0,
	    values: ["drag", "inherit", "initial", "no-drag", "unset", ],
	  },
	  "word-break": {
	    inherited: true,
	    supports: 0,
	    values: ["break-all", "inherit", "initial", "keep-all", "normal", "unset", ],
	  },
	  "word-spacing": {
	    inherited: true,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "normal", "unset", ],
	  },
	  "word-wrap": {
	    inherited: true,
	    supports: 0,
	    values: ["break-word", "inherit", "initial", "normal", "unset", ],
	  },
	  "hyphens": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "manual", "none", "unset", ],
	  },
	  "writing-mode": {
	    inherited: true,
	    supports: 0,
	    values: ["horizontal-tb", "inherit", "initial", "lr", "lr-tb", "rl", "rl-tb", "sideways-lr", "sideways-rl", "tb", "tb-rl", "unset", "vertical-lr", "vertical-rl", ],
	  },
	  "z-index": {
	    inherited: false,
	    supports: 1024,
	    values: ["auto", "inherit", "initial", "unset", ],
	  },
	  "-moz-box-align": {
	    inherited: false,
	    supports: 0,
	    values: ["baseline", "center", "end", "inherit", "initial", "start", "stretch", "unset", ],
	  },
	  "-moz-box-direction": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "normal", "reverse", "unset", ],
	  },
	  "-moz-box-flex": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-box-orient": {
	    inherited: false,
	    supports: 0,
	    values: ["block-axis", "horizontal", "inherit", "initial", "inline-axis", "unset", "vertical", ],
	  },
	  "-moz-box-pack": {
	    inherited: false,
	    supports: 0,
	    values: ["center", "end", "inherit", "initial", "justify", "start", "unset", ],
	  },
	  "-moz-box-ordinal-group": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-stack-sizing": {
	    inherited: false,
	    supports: 0,
	    values: ["ignore", "inherit", "initial", "stretch-to-fit", "unset", ],
	  },
	  "clip-path": {
	    inherited: false,
	    supports: 8,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "clip-rule": {
	    inherited: true,
	    supports: 0,
	    values: ["evenodd", "inherit", "initial", "nonzero", "unset", ],
	  },
	  "color-interpolation": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "linearrgb", "srgb", "unset", ],
	  },
	  "color-interpolation-filters": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "linearrgb", "srgb", "unset", ],
	  },
	  "dominant-baseline": {
	    inherited: false,
	    supports: 0,
	    values: ["alphabetic", "auto", "central", "hanging", "ideographic", "inherit", "initial", "mathematical", "middle", "no-change", "reset-size", "text-after-edge", "text-before-edge", "unset", "use-script", ],
	  },
	  "fill": {
	    inherited: true,
	    supports: 12,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "fill-opacity": {
	    inherited: true,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "fill-rule": {
	    inherited: true,
	    supports: 0,
	    values: ["evenodd", "inherit", "initial", "nonzero", "unset", ],
	  },
	  "filter": {
	    inherited: false,
	    supports: 8,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "flood-color": {
	    inherited: false,
	    supports: 4,
	    values: ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "flood-opacity": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "image-rendering": {
	    inherited: true,
	    supports: 0,
	    values: ["-moz-crisp-edges", "auto", "inherit", "initial", "optimizequality", "optimizespeed", "unset", ],
	  },
	  "lighting-color": {
	    inherited: false,
	    supports: 4,
	    values: ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "marker-end": {
	    inherited: true,
	    supports: 8,
	    values: ["inherit", "initial", "none", "unset", "url", ],
	  },
	  "marker-mid": {
	    inherited: true,
	    supports: 8,
	    values: ["inherit", "initial", "none", "unset", "url", ],
	  },
	  "marker-start": {
	    inherited: true,
	    supports: 8,
	    values: ["inherit", "initial", "none", "unset", "url", ],
	  },
	  "mask": {
	    inherited: false,
	    supports: 8,
	    values: ["inherit", "initial", "none", "unset", "url", ],
	  },
	  "mask-type": {
	    inherited: false,
	    supports: 0,
	    values: ["alpha", "inherit", "initial", "luminance", "unset", ],
	  },
	  "shape-rendering": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "crispedges", "geometricprecision", "inherit", "initial", "optimizespeed", "unset", ],
	  },
	  "stop-color": {
	    inherited: false,
	    supports: 4,
	    values: ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "stop-opacity": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "stroke": {
	    inherited: true,
	    supports: 12,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "stroke-dasharray": {
	    inherited: true,
	    supports: 1027,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "stroke-dashoffset": {
	    inherited: true,
	    supports: 1027,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "stroke-linecap": {
	    inherited: true,
	    supports: 0,
	    values: ["butt", "inherit", "initial", "round", "square", "unset", ],
	  },
	  "stroke-linejoin": {
	    inherited: true,
	    supports: 0,
	    values: ["bevel", "inherit", "initial", "miter", "round", "unset", ],
	  },
	  "stroke-miterlimit": {
	    inherited: true,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "stroke-opacity": {
	    inherited: true,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "stroke-width": {
	    inherited: true,
	    supports: 1027,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "text-anchor": {
	    inherited: true,
	    supports: 0,
	    values: ["end", "inherit", "initial", "middle", "start", "unset", ],
	  },
	  "text-rendering": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "geometricprecision", "inherit", "initial", "optimizelegibility", "optimizespeed", "unset", ],
	  },
	  "vector-effect": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "non-scaling-stroke", "none", "unset", ],
	  },
	  "will-change": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-outline-radius": {
	    subproperties: ["-moz-outline-radius-topleft", "-moz-outline-radius-topright", "-moz-outline-radius-bottomright", "-moz-outline-radius-bottomleft", ],
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "all": {
	    subproperties: ["-moz-appearance", "-moz-outline-radius-topleft", "-moz-outline-radius-topright", "-moz-outline-radius-bottomright", "-moz-outline-radius-bottomleft", "-moz-tab-size", "-x-system-font", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "background-attachment", "background-clip", "background-color", "background-image", "background-blend-mode", "background-origin", "background-position", "background-repeat", "background-size", "-moz-binding", "block-size", "border-block-end-color", "border-block-end-style", "border-block-end-width", "border-block-start-color", "border-block-start-style", "border-block-start-width", "border-bottom-color", "-moz-border-bottom-colors", "border-bottom-style", "border-bottom-width", "border-collapse", "border-image-source", "border-image-slice", "border-image-width", "border-image-outset", "border-image-repeat", "border-inline-end-color", "border-inline-end-style", "border-inline-end-width", "border-inline-start-color", "border-inline-start-style", "border-inline-start-width", "border-left-color", "-moz-border-left-colors", "border-left-style", "border-left-width", "border-right-color", "-moz-border-right-colors", "border-right-style", "border-right-width", "border-spacing", "border-top-color", "-moz-border-top-colors", "border-top-style", "border-top-width", "border-top-left-radius", "border-top-right-radius", "border-bottom-right-radius", "border-bottom-left-radius", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "caption-side", "clear", "clip", "color", "-moz-column-count", "-moz-column-fill", "-moz-column-width", "-moz-column-gap", "-moz-column-rule-color", "-moz-column-rule-style", "-moz-column-rule-width", "contain", "content", "-moz-control-character-visibility", "counter-increment", "counter-reset", "cursor", "display", "empty-cells", "align-content", "align-items", "align-self", "flex-basis", "flex-direction", "flex-grow", "flex-shrink", "flex-wrap", "order", "justify-content", "justify-items", "justify-self", "float", "-moz-float-edge", "font-family", "font-feature-settings", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "-moz-osx-font-smoothing", "font-stretch", "font-style", "font-synthesis", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-weight", "-moz-force-broken-image-icon", "grid-auto-flow", "grid-auto-columns", "grid-auto-rows", "grid-template-areas", "grid-template-columns", "grid-template-rows", "grid-column-start", "grid-column-end", "grid-row-start", "grid-row-end", "grid-column-gap", "grid-row-gap", "height", "image-orientation", "-moz-image-region", "ime-mode", "inline-size", "left", "letter-spacing", "line-height", "list-style-image", "list-style-position", "list-style-type", "margin-block-end", "margin-block-start", "margin-bottom", "margin-inline-end", "margin-inline-start", "margin-left", "margin-right", "margin-top", "marker-offset", "max-block-size", "max-height", "max-inline-size", "max-width", "-moz-min-font-size-ratio", "min-height", "min-block-size", "min-inline-size", "min-width", "mix-blend-mode", "isolation", "object-fit", "object-position", "offset-block-end", "offset-block-start", "offset-inline-end", "offset-inline-start", "opacity", "-moz-orient", "outline-color", "outline-style", "outline-width", "outline-offset", "overflow-clip-box", "overflow-x", "overflow-y", "padding-block-end", "padding-block-start", "padding-bottom", "padding-inline-end", "padding-inline-start", "padding-left", "padding-right", "padding-top", "page-break-after", "page-break-before", "page-break-inside", "paint-order", "pointer-events", "position", "quotes", "resize", "right", "ruby-align", "ruby-position", "scroll-behavior", "scroll-snap-coordinate", "scroll-snap-destination", "scroll-snap-points-x", "scroll-snap-points-y", "scroll-snap-type-x", "scroll-snap-type-y", "table-layout", "text-align", "-moz-text-align-last", "text-combine-upright", "text-decoration-color", "text-decoration-line", "text-decoration-style", "text-indent", "text-orientation", "text-overflow", "text-shadow", "-moz-text-size-adjust", "text-transform", "transform", "transform-box", "transform-origin", "perspective-origin", "perspective", "transform-style", "backface-visibility", "top", "-moz-top-layer", "touch-action", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "-moz-user-focus", "-moz-user-input", "-moz-user-modify", "-moz-user-select", "vertical-align", "visibility", "white-space", "width", "-moz-window-dragging", "-moz-window-shadow", "word-break", "word-spacing", "word-wrap", "hyphens", "writing-mode", "z-index", "-moz-box-align", "-moz-box-direction", "-moz-box-flex", "-moz-box-orient", "-moz-box-pack", "-moz-box-ordinal-group", "-moz-stack-sizing", "clip-path", "clip-rule", "color-interpolation", "color-interpolation-filters", "dominant-baseline", "fill", "fill-opacity", "fill-rule", "filter", "flood-color", "flood-opacity", "image-rendering", "lighting-color", "marker-end", "marker-mid", "marker-start", "mask", "mask-type", "shape-rendering", "stop-color", "stop-opacity", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-rendering", "vector-effect", "will-change", ],
	    inherited: false,
	    supports: 2015,
	    values: ["-moz-all", "-moz-available", "-moz-block-height", "-moz-box", "-moz-calc", "-moz-center", "-moz-crisp-edges", "-moz-deck", "-moz-element", "-moz-fit-content", "-moz-grid", "-moz-grid-group", "-moz-grid-line", "-moz-groupbox", "-moz-gtk-info-bar", "-moz-hidden-unscrollable", "-moz-image-rect", "-moz-inline-box", "-moz-inline-grid", "-moz-inline-stack", "-moz-left", "-moz-linear-gradient", "-moz-mac-disclosure-button-closed", "-moz-mac-disclosure-button-open", "-moz-mac-fullscreen-button", "-moz-mac-help-button", "-moz-mac-vibrancy-dark", "-moz-mac-vibrancy-light", "-moz-max-content", "-moz-middle-with-baseline", "-moz-min-content", "-moz-none", "-moz-popup", "-moz-pre-space", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "-moz-right", "-moz-stack", "-moz-text", "-moz-use-text-color", "-moz-win-borderless-glass", "-moz-win-browsertabbar-toolbox", "-moz-win-communications-toolbox", "-moz-win-exclude-glass", "-moz-win-glass", "-moz-win-media-toolbox", "-moz-window-button-box", "-moz-window-button-box-maximized", "-moz-window-button-close", "-moz-window-button-maximize", "-moz-window-button-minimize", "-moz-window-button-restore", "-moz-window-frame-bottom", "-moz-window-frame-left", "-moz-window-frame-right", "-moz-window-titlebar", "-moz-window-titlebar-maximized", "absolute", "active", "aliceblue", "all", "all-petite-caps", "all-small-caps", "alpha", "alphabetic", "alternate", "alternate-reverse", "always", "antiquewhite", "aqua", "aquamarine", "auto", "avoid", "azure", "backwards", "balance", "baseline", "beige", "bevel", "bisque", "black", "blanchedalmond", "block", "block-axis", "blue", "blueviolet", "border-box", "both", "bottom", "bottom-outside", "break-all", "break-word", "brown", "burlywood", "butt", "button", "button-arrow-down", "button-arrow-next", "button-arrow-previous", "button-arrow-up", "button-bevel", "button-focus", "cadetblue", "calc", "capitalize", "caret", "center", "central", "chartreuse", "checkbox", "checkbox-container", "checkbox-label", "checkmenuitem", "chocolate", "clone", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse", "condensed", "contain", "content-box", "contents", "coral", "cornflowerblue", "cornsilk", "cover", "crimson", "crispedges", "cubic-bezier", "currentColor", "cyan", "darkblue", "darkcyan", "darken", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dialog", "difference", "dimgray", "dimgrey", "disabled", "dodgerblue", "dotted", "double", "drag", "dualbutton", "ease", "ease-in", "ease-in-out", "ease-out", "element", "elements", "enabled", "end", "evenodd", "exclusion", "expanded", "extra-condensed", "extra-expanded", "fill", "fill-box", "firebrick", "fixed", "flat", "flex", "floralwhite", "forestgreen", "forwards", "fuchsia", "full-width", "gainsboro", "geometricprecision", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "grid", "groove", "groupbox", "hanging", "hard-light", "hidden", "hide", "honeydew", "horizontal", "horizontal-tb", "hotpink", "hsl", "hsla", "hue", "ideographic", "ignore", "inactive", "indianred", "indigo", "infinite", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-end", "inline-flex", "inline-grid", "inline-start", "inline-table", "inset", "inside", "isolate", "italic", "ivory", "justify", "keep-all", "khaki", "large", "larger", "lavender", "lavenderblush", "lawngreen", "layout", "left", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lighten", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linear", "linear-gradient", "linearrgb", "linen", "list-item", "listbox", "listitem", "local", "lowercase", "lr", "lr-tb", "luminance", "luminosity", "magenta", "mandatory", "manual", "margin-box", "maroon", "mathematical", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "menuarrow", "menubar", "menucheckbox", "menuimage", "menuitem", "menuitemtext", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menupopup", "menuradio", "menuseparator", "meterbar", "meterchunk", "middle", "midnightblue", "mintcream", "mistyrose", "miter", "mixed", "moccasin", "multiply", "navajowhite", "navy", "no-change", "no-drag", "no-repeat", "non-scaling-stroke", "none", "nonzero", "normal", "nowrap", "number-input", "oblique", "oldlace", "olive", "olivedrab", "optimizelegibility", "optimizequality", "optimizespeed", "orange", "orangered", "orchid", "outset", "outside", "over", "overlay", "padding-box", "paint", "painted", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "paused", "peachpuff", "peru", "petite-caps", "pink", "plum", "powderblue", "pre", "pre-line", "pre-wrap", "preserve-3d", "progressbar", "progressbar-vertical", "progresschunk", "progresschunk-vertical", "proximity", "purple", "radial-gradient", "radio", "radio-container", "radio-label", "radiomenuitem", "range", "range-thumb", "read-only", "read-write", "rebeccapurple", "red", "relative", "repeat", "repeat-x", "repeat-y", "repeating-linear-gradient", "repeating-radial-gradient", "reset-size", "resizer", "resizerpanel", "reverse", "rgb", "rgba", "ridge", "right", "rl", "rl-tb", "rosybrown", "round", "row", "row-reverse", "royalblue", "ruby", "ruby-base", "ruby-base-container", "ruby-text", "ruby-text-container", "running", "saddlebrown", "salmon", "sandybrown", "saturation", "scale-down", "scale-horizontal", "scale-vertical", "scalethumb-horizontal", "scalethumb-vertical", "scalethumbend", "scalethumbstart", "scalethumbtick", "screen", "scroll", "scrollbar", "scrollbar-small", "scrollbarbutton-down", "scrollbarbutton-left", "scrollbarbutton-right", "scrollbarbutton-up", "scrollbarthumb-horizontal", "scrollbarthumb-vertical", "scrollbartrack-horizontal", "scrollbartrack-vertical", "seagreen", "searchfield", "seashell", "select-after", "select-all", "select-before", "select-menu", "select-same", "semi-condensed", "semi-expanded", "separate", "separator", "show", "sideways", "sideways-lr", "sideways-right", "sideways-rl", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "slice", "small", "small-caps", "smaller", "smooth", "snow", "soft-light", "solid", "space-around", "space-between", "spinner", "spinner-downbutton", "spinner-textfield", "spinner-upbutton", "splitter", "springgreen", "square", "srgb", "start", "static", "statusbar", "statusbarpanel", "steelblue", "step-end", "step-start", "steps", "sticky", "stretch", "stretch-to-fit", "strict", "stroke", "style", "sub", "super", "tab", "tab-scroll-arrow-back", "tab-scroll-arrow-forward", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "tabpanel", "tabpanels", "tan", "tb", "tb-rl", "teal", "text", "text-after-edge", "text-before-edge", "text-bottom", "text-top", "textfield", "textfield-multiline", "thick", "thin", "thistle", "titling-caps", "toggle", "tomato", "toolbar", "toolbarbutton", "toolbarbutton-dropdown", "toolbargripper", "toolbox", "tooltip", "top", "top-outside", "transparent", "treeheader", "treeheadercell", "treeheadersortarrow", "treeitem", "treeline", "treetwisty", "treetwistyopen", "treeview", "tri-state", "turquoise", "ultra-condensed", "ultra-expanded", "under", "unicase", "unset", "uppercase", "upright", "url", "use-script", "vertical", "vertical-lr", "vertical-rl", "view-box", "violet", "visible", "visiblefill", "visiblepainted", "visiblestroke", "wavy", "wheat", "white", "whitesmoke", "window", "wrap", "wrap-reverse", "write-only", "x-large", "x-small", "xx-large", "xx-small", "yellow", "yellowgreen", ],
	  },
	  "animation": {
	    subproperties: ["animation-duration", "animation-timing-function", "animation-delay", "animation-direction", "animation-fill-mode", "animation-iteration-count", "animation-play-state", "animation-name", ],
	    inherited: false,
	    supports: 1344,
	    values: ["alternate", "alternate-reverse", "backwards", "both", "cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "forwards", "infinite", "inherit", "initial", "linear", "none", "normal", "paused", "reverse", "running", "step-end", "step-start", "steps", "unset", ],
	  },
	  "background": {
	    subproperties: ["background-color", "background-image", "background-repeat", "background-attachment", "background-position", "background-clip", "background-origin", "background-size", ],
	    inherited: false,
	    supports: 655,
	    values: ["-moz-element", "-moz-image-rect", "-moz-linear-gradient", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "border-box", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "content-box", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "fixed", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linear-gradient", "linen", "local", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "no-repeat", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "padding-box", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "radial-gradient", "rebeccapurple", "red", "repeat", "repeat-x", "repeat-y", "repeating-linear-gradient", "repeating-radial-gradient", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "scroll", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "url", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border": {
	    subproperties: ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width", "border-top-style", "border-right-style", "border-bottom-style", "border-left-style", "border-top-color", "border-right-color", "border-bottom-color", "border-left-color", "-moz-border-top-colors", "-moz-border-right-colors", "-moz-border-bottom-colors", "-moz-border-left-colors", "border-image-source", "border-image-slice", "border-image-width", "border-image-outset", "border-image-repeat", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-element", "-moz-image-rect", "-moz-linear-gradient", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linear-gradient", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "radial-gradient", "rebeccapurple", "red", "repeating-linear-gradient", "repeating-radial-gradient", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "url", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-block-end": {
	    subproperties: ["border-block-end-width", "border-block-end-style", "border-block-end-color", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-block-start": {
	    subproperties: ["border-block-start-width", "border-block-start-style", "border-block-start-color", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-bottom": {
	    subproperties: ["border-bottom-width", "border-bottom-style", "border-bottom-color", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-color": {
	    subproperties: ["border-top-color", "border-right-color", "border-bottom-color", "border-left-color", ],
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-image": {
	    subproperties: ["border-image-source", "border-image-slice", "border-image-width", "border-image-outset", "border-image-repeat", ],
	    inherited: false,
	    supports: 1675,
	    values: ["-moz-element", "-moz-image-rect", "-moz-linear-gradient", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "inherit", "initial", "linear-gradient", "none", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "unset", "url", ],
	  },
	  "border-inline-end": {
	    subproperties: ["border-inline-end-width", "border-inline-end-style", "border-inline-end-color", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-inline-start": {
	    subproperties: ["border-inline-start-width", "border-inline-start-style", "border-inline-start-color", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-left": {
	    subproperties: ["border-left-width", "border-left-style", "border-left-color", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-right": {
	    subproperties: ["border-right-width", "border-right-style", "border-right-color", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-style": {
	    subproperties: ["border-top-style", "border-right-style", "border-bottom-style", "border-left-style", ],
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "border-top": {
	    subproperties: ["border-top-width", "border-top-style", "border-top-color", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-width": {
	    subproperties: ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width", ],
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "border-radius": {
	    subproperties: ["border-top-left-radius", "border-top-right-radius", "border-bottom-right-radius", "border-bottom-left-radius", ],
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-columns": {
	    subproperties: ["-moz-column-count", "-moz-column-width", ],
	    inherited: false,
	    supports: 1025,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "-moz-column-rule": {
	    subproperties: ["-moz-column-rule-width", "-moz-column-rule-style", "-moz-column-rule-color", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "flex": {
	    subproperties: ["flex-grow", "flex-shrink", "flex-basis", ],
	    inherited: false,
	    supports: 1027,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "flex-flow": {
	    subproperties: ["flex-direction", "flex-wrap", ],
	    inherited: false,
	    supports: 0,
	    values: ["column", "column-reverse", "inherit", "initial", "nowrap", "row", "row-reverse", "unset", "wrap", "wrap-reverse", ],
	  },
	  "font": {
	    subproperties: ["font-family", "font-style", "font-weight", "font-size", "line-height", "font-size-adjust", "font-stretch", "-x-system-font", "font-feature-settings", "font-language-override", "font-kerning", "font-synthesis", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", ],
	    inherited: true,
	    supports: 1027,
	    values: ["-moz-block-height", "-moz-calc", "all-petite-caps", "all-small-caps", "auto", "calc", "condensed", "expanded", "extra-condensed", "extra-expanded", "inherit", "initial", "italic", "large", "larger", "medium", "none", "normal", "oblique", "petite-caps", "semi-condensed", "semi-expanded", "small", "small-caps", "smaller", "sub", "super", "titling-caps", "ultra-condensed", "ultra-expanded", "unicase", "unset", "x-large", "x-small", "xx-large", "xx-small", ],
	  },
	  "font-variant": {
	    subproperties: ["font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", ],
	    inherited: true,
	    supports: 0,
	    values: ["all-petite-caps", "all-small-caps", "inherit", "initial", "normal", "petite-caps", "small-caps", "sub", "super", "titling-caps", "unicase", "unset", ],
	  },
	  "grid-template": {
	    subproperties: ["grid-template-areas", "grid-template-columns", "grid-template-rows", ],
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid": {
	    subproperties: ["grid-template-areas", "grid-template-columns", "grid-template-rows", "grid-auto-flow", "grid-auto-columns", "grid-auto-rows", "grid-column-gap", "grid-row-gap", ],
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "grid-column": {
	    subproperties: ["grid-column-start", "grid-column-end", ],
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-row": {
	    subproperties: ["grid-row-start", "grid-row-end", ],
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-area": {
	    subproperties: ["grid-row-start", "grid-column-start", "grid-row-end", "grid-column-end", ],
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-gap": {
	    subproperties: ["grid-column-gap", "grid-row-gap", ],
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "list-style": {
	    subproperties: ["list-style-type", "list-style-image", "list-style-position", ],
	    inherited: true,
	    supports: 8,
	    values: ["inherit", "initial", "inside", "none", "outside", "unset", "url", ],
	  },
	  "margin": {
	    subproperties: ["margin-top", "margin-right", "margin-bottom", "margin-left", ],
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "outline": {
	    subproperties: ["outline-width", "outline-style", "outline-color", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "auto", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "overflow": {
	    subproperties: ["overflow-x", "overflow-y", ],
	    inherited: false,
	    supports: 0,
	    values: ["-moz-hidden-unscrollable", "auto", "hidden", "inherit", "initial", "scroll", "unset", "visible", ],
	  },
	  "padding": {
	    subproperties: ["padding-top", "padding-right", "padding-bottom", "padding-left", ],
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "scroll-snap-type": {
	    subproperties: ["scroll-snap-type-x", "scroll-snap-type-y", ],
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "mandatory", "none", "proximity", "unset", ],
	  },
	  "text-decoration": {
	    subproperties: ["text-decoration-color", "text-decoration-line", "text-decoration-style", ],
	    inherited: false,
	    supports: 4,
	    values: ["-moz-none", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wavy", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "transition": {
	    subproperties: ["transition-property", "transition-duration", "transition-timing-function", "transition-delay", ],
	    inherited: false,
	    supports: 320,
	    values: ["all", "cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "none", "step-end", "step-start", "steps", "unset", ],
	  },
	  "marker": {
	    subproperties: ["marker-start", "marker-mid", "marker-end", ],
	    inherited: true,
	    supports: 8,
	    values: ["inherit", "initial", "none", "unset", "url", ],
	  },
	  "-moz-transform": {
	    alias: true,
	    subproperties: ["transform", ],
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-transform-origin": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-perspective-origin": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-perspective": {
	    alias: true,
	    inherited: false,
	    supports: 1,
	    values: ["inherit", "initial", "none", "unset", ],
	  },
	  "-moz-transform-style": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["flat", "inherit", "initial", "preserve-3d", "unset", ],
	  },
	  "-moz-backface-visibility": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["hidden", "inherit", "initial", "unset", "visible", ],
	  },
	  "-moz-border-image": {
	    alias: true,
	    subproperties: ["border-image-source", "border-image-slice", "border-image-width", "border-image-outset", "border-image-repeat", ],
	    inherited: false,
	    supports: 1675,
	    values: ["-moz-element", "-moz-image-rect", "-moz-linear-gradient", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "inherit", "initial", "linear-gradient", "none", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "unset", "url", ],
	  },
	  "-moz-transition": {
	    alias: true,
	    subproperties: ["transition-property", "transition-duration", "transition-timing-function", "transition-delay", ],
	    inherited: false,
	    supports: 320,
	    values: ["all", "cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "none", "step-end", "step-start", "steps", "unset", ],
	  },
	  "-moz-transition-delay": {
	    alias: true,
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-transition-duration": {
	    alias: true,
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-transition-property": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["all", "inherit", "initial", "none", "unset", ],
	  },
	  "-moz-transition-timing-function": {
	    alias: true,
	    inherited: false,
	    supports: 256,
	    values: ["cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "step-end", "step-start", "steps", "unset", ],
	  },
	  "-moz-animation": {
	    alias: true,
	    subproperties: ["animation-duration", "animation-timing-function", "animation-delay", "animation-direction", "animation-fill-mode", "animation-iteration-count", "animation-play-state", "animation-name", ],
	    inherited: false,
	    supports: 1344,
	    values: ["alternate", "alternate-reverse", "backwards", "both", "cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "forwards", "infinite", "inherit", "initial", "linear", "none", "normal", "paused", "reverse", "running", "step-end", "step-start", "steps", "unset", ],
	  },
	  "-moz-animation-delay": {
	    alias: true,
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-animation-direction": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["alternate", "alternate-reverse", "inherit", "initial", "normal", "reverse", "unset", ],
	  },
	  "-moz-animation-duration": {
	    alias: true,
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-animation-fill-mode": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["backwards", "both", "forwards", "inherit", "initial", "none", "unset", ],
	  },
	  "-moz-animation-iteration-count": {
	    alias: true,
	    inherited: false,
	    supports: 1024,
	    values: ["infinite", "inherit", "initial", "unset", ],
	  },
	  "-moz-animation-name": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "none", "unset", ],
	  },
	  "-moz-animation-play-state": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "paused", "running", "unset", ],
	  },
	  "-moz-animation-timing-function": {
	    alias: true,
	    inherited: false,
	    supports: 256,
	    values: ["cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "step-end", "step-start", "steps", "unset", ],
	  },
	  "-moz-box-sizing": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["border-box", "content-box", "inherit", "initial", "padding-box", "unset", ],
	  },
	  "-moz-font-feature-settings": {
	    alias: true,
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-font-language-override": {
	    alias: true,
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "normal", "unset", ],
	  },
	  "-moz-padding-end": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "-moz-padding-start": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "-moz-margin-end": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "-moz-margin-start": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "-moz-border-end": {
	    alias: true,
	    subproperties: ["border-inline-end-width", "border-inline-end-style", "border-inline-end-color", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "-moz-border-end-color": {
	    alias: true,
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "-moz-border-end-style": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "-moz-border-end-width": {
	    alias: true,
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "-moz-border-start": {
	    alias: true,
	    subproperties: ["border-inline-start-width", "border-inline-start-style", "border-inline-start-color", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "-moz-border-start-color": {
	    alias: true,
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "-moz-border-start-style": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "-moz-border-start-width": {
	    alias: true,
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "-moz-hyphens": {
	    alias: true,
	    inherited: true,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "manual", "none", "unset", ],
	  },
	  "-webkit-animation": {
	    alias: true,
	    subproperties: ["animation-duration", "animation-timing-function", "animation-delay", "animation-direction", "animation-fill-mode", "animation-iteration-count", "animation-play-state", "animation-name", ],
	    inherited: false,
	    supports: 1344,
	    values: ["alternate", "alternate-reverse", "backwards", "both", "cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "forwards", "infinite", "inherit", "initial", "linear", "none", "normal", "paused", "reverse", "running", "step-end", "step-start", "steps", "unset", ],
	  },
	  "-webkit-animation-delay": {
	    alias: true,
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-animation-direction": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["alternate", "alternate-reverse", "inherit", "initial", "normal", "reverse", "unset", ],
	  },
	  "-webkit-animation-duration": {
	    alias: true,
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-animation-fill-mode": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["backwards", "both", "forwards", "inherit", "initial", "none", "unset", ],
	  },
	  "-webkit-animation-iteration-count": {
	    alias: true,
	    inherited: false,
	    supports: 1024,
	    values: ["infinite", "inherit", "initial", "unset", ],
	  },
	  "-webkit-animation-name": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "none", "unset", ],
	  },
	  "-webkit-animation-play-state": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "paused", "running", "unset", ],
	  },
	  "-webkit-animation-timing-function": {
	    alias: true,
	    inherited: false,
	    supports: 256,
	    values: ["cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "step-end", "step-start", "steps", "unset", ],
	  },
	  "-webkit-text-size-adjust": {
	    alias: true,
	    inherited: true,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "none", "unset", ],
	  },
	  "-webkit-transform": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-transform-origin": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-transform-style": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["flat", "inherit", "initial", "preserve-3d", "unset", ],
	  },
	  "-webkit-backface-visibility": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["hidden", "inherit", "initial", "unset", "visible", ],
	  },
	  "-webkit-perspective": {
	    alias: true,
	    inherited: false,
	    supports: 1,
	    values: ["inherit", "initial", "none", "unset", ],
	  },
	  "-webkit-perspective-origin": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-transition": {
	    alias: true,
	    subproperties: ["transition-property", "transition-duration", "transition-timing-function", "transition-delay", ],
	    inherited: false,
	    supports: 320,
	    values: ["all", "cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "none", "step-end", "step-start", "steps", "unset", ],
	  },
	  "-webkit-transition-delay": {
	    alias: true,
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-transition-duration": {
	    alias: true,
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-transition-property": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["all", "inherit", "initial", "none", "unset", ],
	  },
	  "-webkit-transition-timing-function": {
	    alias: true,
	    inherited: false,
	    supports: 256,
	    values: ["cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "step-end", "step-start", "steps", "unset", ],
	  },
	  "-webkit-border-radius": {
	    alias: true,
	    subproperties: ["border-top-left-radius", "border-top-right-radius", "border-bottom-right-radius", "border-bottom-left-radius", ],
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-border-top-left-radius": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-border-top-right-radius": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-border-bottom-left-radius": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-border-bottom-right-radius": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-appearance": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["-moz-gtk-info-bar", "-moz-mac-disclosure-button-closed", "-moz-mac-disclosure-button-open", "-moz-mac-fullscreen-button", "-moz-mac-help-button", "-moz-mac-vibrancy-dark", "-moz-mac-vibrancy-light", "-moz-win-borderless-glass", "-moz-win-browsertabbar-toolbox", "-moz-win-communications-toolbox", "-moz-win-exclude-glass", "-moz-win-glass", "-moz-win-media-toolbox", "-moz-window-button-box", "-moz-window-button-box-maximized", "-moz-window-button-close", "-moz-window-button-maximize", "-moz-window-button-minimize", "-moz-window-button-restore", "-moz-window-frame-bottom", "-moz-window-frame-left", "-moz-window-frame-right", "-moz-window-titlebar", "-moz-window-titlebar-maximized", "button", "button-arrow-down", "button-arrow-next", "button-arrow-previous", "button-arrow-up", "button-bevel", "button-focus", "caret", "checkbox", "checkbox-container", "checkbox-label", "checkmenuitem", "dialog", "dualbutton", "groupbox", "inherit", "initial", "listbox", "listitem", "menuarrow", "menubar", "menucheckbox", "menuimage", "menuitem", "menuitemtext", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menupopup", "menuradio", "menuseparator", "meterbar", "meterchunk", "none", "number-input", "progressbar", "progressbar-vertical", "progresschunk", "progresschunk-vertical", "radio", "radio-container", "radio-label", "radiomenuitem", "range", "range-thumb", "resizer", "resizerpanel", "scale-horizontal", "scale-vertical", "scalethumb-horizontal", "scalethumb-vertical", "scalethumbend", "scalethumbstart", "scalethumbtick", "scrollbar", "scrollbar-small", "scrollbarbutton-down", "scrollbarbutton-left", "scrollbarbutton-right", "scrollbarbutton-up", "scrollbarthumb-horizontal", "scrollbarthumb-vertical", "scrollbartrack-horizontal", "scrollbartrack-vertical", "searchfield", "separator", "spinner", "spinner-downbutton", "spinner-textfield", "spinner-upbutton", "splitter", "statusbar", "statusbarpanel", "tab", "tab-scroll-arrow-back", "tab-scroll-arrow-forward", "tabpanel", "tabpanels", "textfield", "textfield-multiline", "toolbar", "toolbarbutton", "toolbarbutton-dropdown", "toolbargripper", "toolbox", "tooltip", "treeheader", "treeheadercell", "treeheadersortarrow", "treeitem", "treeline", "treetwisty", "treetwistyopen", "treeview", "unset", "window", ],
	  },
	  "-webkit-background-clip": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["border-box", "content-box", "inherit", "initial", "padding-box", "unset", ],
	  },
	  "-webkit-background-origin": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["border-box", "content-box", "inherit", "initial", "padding-box", "unset", ],
	  },
	  "-webkit-background-size": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-border-image": {
	    alias: true,
	    subproperties: ["border-image-source", "border-image-slice", "border-image-width", "border-image-outset", "border-image-repeat", ],
	    inherited: false,
	    supports: 1675,
	    values: ["-moz-element", "-moz-image-rect", "-moz-linear-gradient", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "inherit", "initial", "linear-gradient", "none", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "unset", "url", ],
	  },
	  "-webkit-border-image-outset": {
	    alias: true,
	    inherited: false,
	    supports: 1025,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-border-image-repeat": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-border-image-slice": {
	    alias: true,
	    inherited: false,
	    supports: 1026,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-border-image-source": {
	    alias: true,
	    inherited: false,
	    supports: 648,
	    values: ["-moz-element", "-moz-image-rect", "-moz-linear-gradient", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "inherit", "initial", "linear-gradient", "none", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "unset", "url", ],
	  },
	  "-webkit-border-image-width": {
	    alias: true,
	    inherited: false,
	    supports: 1027,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-box-shadow": {
	    alias: true,
	    inherited: false,
	    supports: 5,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-box-sizing": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["border-box", "content-box", "inherit", "initial", "padding-box", "unset", ],
	  },
	  "-webkit-box-flex": {
	    alias: true,
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-box-ordinal-group": {
	    alias: true,
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-box-align": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-box-pack": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-user-select": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["-moz-all", "-moz-none", "-moz-text", "all", "auto", "element", "elements", "inherit", "initial", "none", "text", "toggle", "tri-state", "unset", ],
	  },
	};
	module.exports = { cssProperties };


/***/ },
/* 40 */
/***/ function(module, exports) {

	/*
	 * A sham for https://dxr.mozilla.org/mozilla-central/source/toolkit/modules/Promise.jsm
	 */
	
	/**
	 * Promise.jsm is mostly the Promise web API with a `defer` method. Just drop this in here,
	 * and use the native web API (although building with webpack/babel, it may replace this
	 * with it's own version if we want to target environments that do not have `Promise`.
	 */
	
	let p = typeof window != "undefined" ?  window.Promise : Promise;
	p.defer = function defer() {
	  var resolve, reject;
	  var promise = new Promise(function() {
	    resolve = arguments[0];
	    reject = arguments[1];
	  });
	  return {
	    resolve: resolve,
	    reject: reject,
	    promise: promise
	  };
	}
	
	module.exports = p;


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-env browser */
	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	// TODO: Get rid of this code once the marionette server loads transport.js as
	// an SDK module (see bug 1000814)
	
	"use strict";
	
	const DevToolsUtils = __webpack_require__(42);
	const { dumpn, dumpv } = DevToolsUtils;
	const StreamUtils = __webpack_require__(48);
	const { Packet, JSONPacket, BulkPacket } =
	  __webpack_require__(49);
	const promise = __webpack_require__(40);
	const EventEmitter = __webpack_require__(34);
	const utf8 = __webpack_require__(52);
	
	const PACKET_HEADER_MAX = 200;
	
	/**
	 * An adapter that handles data transfers between the debugger client and
	 * server. It can work with both nsIPipe and nsIServerSocket transports so
	 * long as the properly created input and output streams are specified.
	 * (However, for intra-process connections, LocalDebuggerTransport, below,
	 * is more efficient than using an nsIPipe pair with DebuggerTransport.)
	 *
	 * @param input nsIAsyncInputStream
	 *        The input stream.
	 * @param output nsIAsyncOutputStream
	 *        The output stream.
	 *
	 * Given a DebuggerTransport instance dt:
	 * 1) Set dt.hooks to a packet handler object (described below).
	 * 2) Call dt.ready() to begin watching for input packets.
	 * 3) Call dt.send() / dt.startBulkSend() to send packets.
	 * 4) Call dt.close() to close the connection, and disengage from the event
	 *    loop.
	 *
	 * A packet handler is an object with the following methods:
	 *
	 * - onPacket(packet) - called when we have received a complete packet.
	 *   |packet| is the parsed form of the packet --- a JavaScript value, not
	 *   a JSON-syntax string.
	 *
	 * - onBulkPacket(packet) - called when we have switched to bulk packet
	 *   receiving mode. |packet| is an object containing:
	 *   * actor:  Name of actor that will receive the packet
	 *   * type:   Name of actor's method that should be called on receipt
	 *   * length: Size of the data to be read
	 *   * stream: This input stream should only be used directly if you can ensure
	 *             that you will read exactly |length| bytes and will not close the
	 *             stream when reading is complete
	 *   * done:   If you use the stream directly (instead of |copyTo| below), you
	 *             must signal completion by resolving / rejecting this deferred.
	 *             If it's rejected, the transport will be closed.  If an Error is
	 *             supplied as a rejection value, it will be logged via |dumpn|.
	 *             If you do use |copyTo|, resolving is taken care of for you when
	 *             copying completes.
	 *   * copyTo: A helper function for getting your data out of the stream that
	 *             meets the stream handling requirements above, and has the
	 *             following signature:
	 *     @param  output nsIAsyncOutputStream
	 *             The stream to copy to.
	 *     @return Promise
	 *             The promise is resolved when copying completes or rejected if any
	 *             (unexpected) errors occur.
	 *             This object also emits "progress" events for each chunk that is
	 *             copied.  See stream-utils.js.
	 *
	 * - onClosed(reason) - called when the connection is closed. |reason| is
	 *   an optional nsresult or object, typically passed when the transport is
	 *   closed due to some error in a underlying stream.
	 *
	 * See ./packets.js and the Remote Debugging Protocol specification for more
	 * details on the format of these packets.
	 */
	function DebuggerTransport(socket) {
	  EventEmitter.decorate(this);
	
	  this._socket = socket;
	
	  // The current incoming (possibly partial) header, which will determine which
	  // type of Packet |_incoming| below will become.
	  this._incomingHeader = "";
	  // The current incoming Packet object
	  this._incoming = null;
	  // A queue of outgoing Packet objects
	  this._outgoing = [];
	
	  this.hooks = null;
	  this.active = false;
	
	  this._incomingEnabled = true;
	  this._outgoingEnabled = true;
	
	  this.close = this.close.bind(this);
	}
	
	DebuggerTransport.prototype = {
	  /**
	   * Transmit an object as a JSON packet.
	   *
	   * This method returns immediately, without waiting for the entire
	   * packet to be transmitted, registering event handlers as needed to
	   * transmit the entire packet. Packets are transmitted in the order
	   * they are passed to this method.
	   */
	  send: function(object) {
	    this.emit("send", object);
	
	    let packet = new JSONPacket(this);
	    packet.object = object;
	    this._outgoing.push(packet);
	    this._flushOutgoing();
	  },
	
	  /**
	   * Transmit streaming data via a bulk packet.
	   *
	   * This method initiates the bulk send process by queuing up the header data.
	   * The caller receives eventual access to a stream for writing.
	   *
	   * N.B.: Do *not* attempt to close the stream handed to you, as it will
	   * continue to be used by this transport afterwards.  Most users should
	   * instead use the provided |copyFrom| function instead.
	   *
	   * @param header Object
	   *        This is modeled after the format of JSON packets above, but does not
	   *        actually contain the data, but is instead just a routing header:
	   *          * actor:  Name of actor that will receive the packet
	   *          * type:   Name of actor's method that should be called on receipt
	   *          * length: Size of the data to be sent
	   * @return Promise
	   *         The promise will be resolved when you are allowed to write to the
	   *         stream with an object containing:
	   *           * stream:   This output stream should only be used directly if
	   *                       you can ensure that you will write exactly |length|
	   *                       bytes and will not close the stream when writing is
	   *                       complete
	   *           * done:     If you use the stream directly (instead of |copyFrom|
	   *                       below), you must signal completion by resolving /
	   *                       rejecting this deferred.  If it's rejected, the
	   *                       transport will be closed.  If an Error is supplied as
	   *                       a rejection value, it will be logged via |dumpn|.  If
	   *                       you do use |copyFrom|, resolving is taken care of for
	   *                       you when copying completes.
	   *           * copyFrom: A helper function for getting your data onto the
	   *                       stream that meets the stream handling requirements
	   *                       above, and has the following signature:
	   *             @param  input nsIAsyncInputStream
	   *                     The stream to copy from.
	   *             @return Promise
	   *                     The promise is resolved when copying completes or
	   *                     rejected if any (unexpected) errors occur.
	   *                     This object also emits "progress" events for each chunk
	   *                     that is copied.  See stream-utils.js.
	   */
	  startBulkSend: function(header) {
	    this.emit("startBulkSend", header);
	
	    let packet = new BulkPacket(this);
	    packet.header = header;
	    this._outgoing.push(packet);
	    this._flushOutgoing();
	    return packet.streamReadyForWriting;
	  },
	
	  /**
	   * Close the transport.
	   * @param reason nsresult / object (optional)
	   *        The status code or error message that corresponds to the reason for
	   *        closing the transport (likely because a stream closed or failed).
	   */
	  close: function(reason) {
	    this.emit("onClosed", reason);
	
	    this.active = false;
	    this._socket.close();
	    this._destroyIncoming();
	    this._destroyAllOutgoing();
	    if (this.hooks) {
	      this.hooks.onClosed(reason);
	      this.hooks = null;
	    }
	    if (reason) {
	      dumpn("Transport closed: " + DevToolsUtils.safeErrorString(reason));
	    } else {
	      dumpn("Transport closed.");
	    }
	  },
	
	  /**
	   * The currently outgoing packet (at the top of the queue).
	   */
	  get _currentOutgoing() {
	    return this._outgoing[0];
	  },
	
	  /**
	   * Flush data to the outgoing stream.  Waits until the output stream notifies
	   * us that it is ready to be written to (via onOutputStreamReady).
	   */
	  _flushOutgoing: function() {
	    if (!this._outgoingEnabled || this._outgoing.length === 0) {
	      return;
	    }
	
	    // If the top of the packet queue has nothing more to send, remove it.
	    if (this._currentOutgoing.done) {
	      this._finishCurrentOutgoing();
	    }
	
	    if (this._outgoing.length > 0) {
	      setTimeout(this.onOutputStreamReady.bind(this), 0);
	    }
	  },
	
	  /**
	   * Pause this transport's attempts to write to the output stream.  This is
	   * used when we've temporarily handed off our output stream for writing bulk
	   * data.
	   */
	  pauseOutgoing: function() {
	    this._outgoingEnabled = false;
	  },
	
	  /**
	   * Resume this transport's attempts to write to the output stream.
	   */
	  resumeOutgoing: function() {
	    this._outgoingEnabled = true;
	    this._flushOutgoing();
	  },
	
	  // nsIOutputStreamCallback
	  /**
	   * This is called when the output stream is ready for more data to be written.
	   * The current outgoing packet will attempt to write some amount of data, but
	   * may not complete.
	   */
	  onOutputStreamReady: DevToolsUtils.makeInfallible(function() {
	    if (!this._outgoingEnabled || this._outgoing.length === 0) {
	      return;
	    }
	
	    try {
	      this._currentOutgoing.write({
	        write: data => {
	          let count = data.length;
	          this._socket.send(data);
	          return count;
	        }
	      });
	    } catch(e) {
	      if (e.result != Cr.NS_BASE_STREAM_WOULD_BLOCK) {
	        this.close(e.result);
	        return;
	      } else {
	        throw e;
	      }
	    }
	
	    this._flushOutgoing();
	  }, "DebuggerTransport.prototype.onOutputStreamReady"),
	
	  /**
	   * Remove the current outgoing packet from the queue upon completion.
	   */
	  _finishCurrentOutgoing: function() {
	    if (this._currentOutgoing) {
	      this._currentOutgoing.destroy();
	      this._outgoing.shift();
	    }
	  },
	
	  /**
	   * Clear the entire outgoing queue.
	   */
	  _destroyAllOutgoing: function() {
	    for (let packet of this._outgoing) {
	      packet.destroy();
	    }
	    this._outgoing = [];
	  },
	
	  /**
	   * Initialize the input stream for reading. Once this method has been called,
	   * we watch for packets on the input stream, and pass them to the appropriate
	   * handlers via this.hooks.
	   */
	  ready: function() {
	    this.active = true;
	    this._waitForIncoming();
	  },
	
	  /**
	   * Asks the input stream to notify us (via onInputStreamReady) when it is
	   * ready for reading.
	   */
	  _waitForIncoming: function() {
	    if (this._incomingEnabled && !this._socket.onmessage) {
	      this._socket.onmessage = this.onInputStreamReady.bind(this);
	    }
	  },
	
	  /**
	   * Pause this transport's attempts to read from the input stream.  This is
	   * used when we've temporarily handed off our input stream for reading bulk
	   * data.
	   */
	  pauseIncoming: function() {
	    this._incomingEnabled = false;
	  },
	
	  /**
	   * Resume this transport's attempts to read from the input stream.
	   */
	  resumeIncoming: function() {
	    this._incomingEnabled = true;
	    this._flushIncoming();
	    this._waitForIncoming();
	  },
	
	  // nsIInputStreamCallback
	  /**
	   * Called when the stream is either readable or closed.
	   */
	  onInputStreamReady:
	  DevToolsUtils.makeInfallible(function(event) {
	    let data = event.data;
	    // TODO: ws-tcp-proxy decodes utf-8, but the transport expects to see the
	    // encoded bytes.  Simplest step is to re-encode for now.
	    data = utf8.encode(data);
	    let stream = {
	      available() {
	        return data.length;
	      },
	      readBytes(count) {
	        let result = data.slice(0, count);
	        data = data.slice(count);
	        return result;
	      },
	    };
	
	    try {
	      while (data && this._incomingEnabled &&
	             this._processIncoming(stream, stream.available())) {}
	      this._waitForIncoming();
	    } catch(e) {
	      if (e.result != Cr.NS_BASE_STREAM_WOULD_BLOCK) {
	        this.close(e.result);
	      } else {
	        throw e;
	      }
	    }
	  }, "DebuggerTransport.prototype.onInputStreamReady"),
	
	  /**
	   * Process the incoming data.  Will create a new currently incoming Packet if
	   * needed.  Tells the incoming Packet to read as much data as it can, but
	   * reading may not complete.  The Packet signals that its data is ready for
	   * delivery by calling one of this transport's _on*Ready methods (see
	   * ./packets.js and the _on*Ready methods below).
	   * @return boolean
	   *         Whether incoming stream processing should continue for any
	   *         remaining data.
	   */
	  _processIncoming: function(stream, count) {
	    dumpv("Data available: " + count);
	
	    if (!count) {
	      dumpv("Nothing to read, skipping");
	      return false;
	    }
	
	    try {
	      if (!this._incoming) {
	        dumpv("Creating a new packet from incoming");
	
	        if (!this._readHeader(stream)) {
	          return false; // Not enough data to read packet type
	        }
	
	        // Attempt to create a new Packet by trying to parse each possible
	        // header pattern.
	        this._incoming = Packet.fromHeader(this._incomingHeader, this);
	        if (!this._incoming) {
	          throw new Error("No packet types for header: " +
	                          this._incomingHeader);
	        }
	      }
	
	      if (!this._incoming.done) {
	        // We have an incomplete packet, keep reading it.
	        dumpv("Existing packet incomplete, keep reading");
	        this._incoming.read(stream);
	      }
	    } catch(e) {
	      let msg = "Error reading incoming packet: (" + e + " - " + e.stack + ")";
	      dumpn(msg);
	
	      // Now in an invalid state, shut down the transport.
	      this.close();
	      return false;
	    }
	
	    if (!this._incoming.done) {
	      // Still not complete, we'll wait for more data.
	      dumpv("Packet not done, wait for more");
	      return true;
	    }
	
	    // Ready for next packet
	    this._flushIncoming();
	    return true;
	  },
	
	  /**
	   * Read as far as we can into the incoming data, attempting to build up a
	   * complete packet header (which terminates with ":").  We'll only read up to
	   * PACKET_HEADER_MAX characters.
	   * @return boolean
	   *         True if we now have a complete header.
	   */
	  _readHeader: function(stream) {
	    let amountToRead = PACKET_HEADER_MAX - this._incomingHeader.length;
	    this._incomingHeader +=
	      StreamUtils.delimitedRead(stream, ":", amountToRead);
	    if (dumpv.wantVerbose) {
	      dumpv("Header read: " + this._incomingHeader);
	    }
	
	    if (this._incomingHeader.endsWith(":")) {
	      if (dumpv.wantVerbose) {
	        dumpv("Found packet header successfully: " + this._incomingHeader);
	      }
	      return true;
	    }
	
	    if (this._incomingHeader.length >= PACKET_HEADER_MAX) {
	      throw new Error("Failed to parse packet header!");
	    }
	
	    // Not enough data yet.
	    return false;
	  },
	
	  /**
	   * If the incoming packet is done, log it as needed and clear the buffer.
	   */
	  _flushIncoming: function() {
	    if (!this._incoming.done) {
	      return;
	    }
	    if (dumpn.wantLogging) {
	      dumpn("Got: " + this._incoming);
	    }
	    this._destroyIncoming();
	  },
	
	  /**
	   * Handler triggered by an incoming JSONPacket completing it's |read| method.
	   * Delivers the packet to this.hooks.onPacket.
	   */
	  _onJSONObjectReady: function(object) {
	    DevToolsUtils.executeSoon(DevToolsUtils.makeInfallible(() => {
	      // Ensure the transport is still alive by the time this runs.
	      if (this.active) {
	        this.emit("onPacket", object);
	        this.hooks.onPacket(object);
	      }
	    }, "DebuggerTransport instance's this.hooks.onPacket"));
	  },
	
	  /**
	   * Handler triggered by an incoming BulkPacket entering the |read| phase for
	   * the stream portion of the packet.  Delivers info about the incoming
	   * streaming data to this.hooks.onBulkPacket.  See the main comment on the
	   * transport at the top of this file for more details.
	   */
	  _onBulkReadReady: function(...args) {
	    DevToolsUtils.executeSoon(DevToolsUtils.makeInfallible(() => {
	      // Ensure the transport is still alive by the time this runs.
	      if (this.active) {
	        this.emit("onBulkPacket", ...args);
	        this.hooks.onBulkPacket(...args);
	      }
	    }, "DebuggerTransport instance's this.hooks.onBulkPacket"));
	  },
	
	  /**
	   * Remove all handlers and references related to the current incoming packet,
	   * either because it is now complete or because the transport is closing.
	   */
	  _destroyIncoming: function() {
	    if (this._incoming) {
	      this._incoming.destroy();
	    }
	    this._incomingHeader = "";
	    this._incoming = null;
	  }
	
	};
	
	exports.DebuggerTransport = DebuggerTransport;
	
	/**
	 * An adapter that handles data transfers between the debugger client and
	 * server when they both run in the same process. It presents the same API as
	 * DebuggerTransport, but instead of transmitting serialized messages across a
	 * connection it merely calls the packet dispatcher of the other side.
	 *
	 * @param other LocalDebuggerTransport
	 *        The other endpoint for this debugger connection.
	 *
	 * @see DebuggerTransport
	 */
	function LocalDebuggerTransport(other) {
	  EventEmitter.decorate(this);
	
	  this.other = other;
	  this.hooks = null;
	
	  /*
	   * A packet number, shared between this and this.other. This isn't used
	   * by the protocol at all, but it makes the packet traces a lot easier to
	   * follow.
	   */
	  this._serial = this.other ? this.other._serial : { count: 0 };
	  this.close = this.close.bind(this);
	}
	
	LocalDebuggerTransport.prototype = {
	  /**
	   * Transmit a message by directly calling the onPacket handler of the other
	   * endpoint.
	   */
	  send: function(packet) {
	    this.emit("send", packet);
	
	    let serial = this._serial.count++;
	    if (dumpn.wantLogging) {
	      /* Check 'from' first, as 'echo' packets have both. */
	      if (packet.from) {
	        dumpn("Packet " + serial + " sent from " + uneval(packet.from));
	      } else if (packet.to) {
	        dumpn("Packet " + serial + " sent to " + uneval(packet.to));
	      }
	    }
	    this._deepFreeze(packet);
	    let other = this.other;
	    if (other) {
	      DevToolsUtils.executeSoon(DevToolsUtils.makeInfallible(() => {
	        // Avoid the cost of JSON.stringify() when logging is disabled.
	        if (dumpn.wantLogging) {
	          dumpn("Received packet " + serial + ": " + JSON.stringify(packet, null, 2));
	        }
	        if (other.hooks) {
	          other.emit("onPacket", packet);
	          other.hooks.onPacket(packet);
	        }
	      }, "LocalDebuggerTransport instance's this.other.hooks.onPacket"));
	    }
	  },
	
	  /**
	   * Send a streaming bulk packet directly to the onBulkPacket handler of the
	   * other endpoint.
	   *
	   * This case is much simpler than the full DebuggerTransport, since there is
	   * no primary stream we have to worry about managing while we hand it off to
	   * others temporarily.  Instead, we can just make a single use pipe and be
	   * done with it.
	   */
	  startBulkSend: function({actor, type, length}) {
	    this.emit("startBulkSend", {actor, type, length});
	
	    let serial = this._serial.count++;
	
	    dumpn("Sent bulk packet " + serial + " for actor " + actor);
	    if (!this.other) {
	      return;
	    }
	
	    let pipe = new Pipe(true, true, 0, 0, null);
	
	    DevToolsUtils.executeSoon(DevToolsUtils.makeInfallible(() => {
	      dumpn("Received bulk packet " + serial);
	      if (!this.other.hooks) {
	        return;
	      }
	
	      // Receiver
	      let deferred = promise.defer();
	      let packet = {
	        actor: actor,
	        type: type,
	        length: length,
	        copyTo: (output) => {
	          let copying =
	            StreamUtils.copyStream(pipe.inputStream, output, length);
	          deferred.resolve(copying);
	          return copying;
	        },
	        stream: pipe.inputStream,
	        done: deferred
	      };
	
	      this.other.emit("onBulkPacket", packet);
	      this.other.hooks.onBulkPacket(packet);
	
	      // Await the result of reading from the stream
	      deferred.promise.then(() => pipe.inputStream.close(), this.close);
	    }, "LocalDebuggerTransport instance's this.other.hooks.onBulkPacket"));
	
	    // Sender
	    let sendDeferred = promise.defer();
	
	    // The remote transport is not capable of resolving immediately here, so we
	    // shouldn't be able to either.
	    DevToolsUtils.executeSoon(() => {
	      let copyDeferred = promise.defer();
	
	      sendDeferred.resolve({
	        copyFrom: (input) => {
	          let copying =
	            StreamUtils.copyStream(input, pipe.outputStream, length);
	          copyDeferred.resolve(copying);
	          return copying;
	        },
	        stream: pipe.outputStream,
	        done: copyDeferred
	      });
	
	      // Await the result of writing to the stream
	      copyDeferred.promise.then(() => pipe.outputStream.close(), this.close);
	    });
	
	    return sendDeferred.promise;
	  },
	
	  /**
	   * Close the transport.
	   */
	  close: function() {
	    this.emit("close");
	
	    if (this.other) {
	      // Remove the reference to the other endpoint before calling close(), to
	      // avoid infinite recursion.
	      let other = this.other;
	      this.other = null;
	      other.close();
	    }
	    if (this.hooks) {
	      try {
	        this.hooks.onClosed();
	      } catch(ex) {
	        console.error(ex);
	      }
	      this.hooks = null;
	    }
	  },
	
	  /**
	   * An empty method for emulating the DebuggerTransport API.
	   */
	  ready: function() {},
	
	  /**
	   * Helper function that makes an object fully immutable.
	   */
	  _deepFreeze: function(object) {
	    Object.freeze(object);
	    for (let prop in object) {
	      // Freeze the properties that are objects, not on the prototype, and not
	      // already frozen. Note that this might leave an unfrozen reference
	      // somewhere in the object if there is an already frozen object containing
	      // an unfrozen object.
	      if (object.hasOwnProperty(prop) && typeof object === "object" &&
	          !Object.isFrozen(object)) {
	        this._deepFreeze(o[prop]);
	      }
	    }
	  }
	};
	
	exports.LocalDebuggerTransport = LocalDebuggerTransport;
	
	/**
	 * A transport for the debugging protocol that uses nsIMessageSenders to
	 * exchange packets with servers running in child processes.
	 *
	 * In the parent process, |sender| should be the nsIMessageSender for the
	 * child process. In a child process, |sender| should be the child process
	 * message manager, which sends packets to the parent.
	 *
	 * |prefix| is a string included in the message names, to distinguish
	 * multiple servers running in the same child process.
	 *
	 * This transport exchanges messages named 'debug:<prefix>:packet', where
	 * <prefix> is |prefix|, whose data is the protocol packet.
	 */
	function ChildDebuggerTransport(sender, prefix) {
	  EventEmitter.decorate(this);
	
	  this._sender = sender.QueryInterface(Ci.nsIMessageSender);
	  this._messageName = "debug:" + prefix + ":packet";
	}
	
	/*
	 * To avoid confusion, we use 'message' to mean something that
	 * nsIMessageSender conveys, and 'packet' to mean a remote debugging
	 * protocol packet.
	 */
	ChildDebuggerTransport.prototype = {
	  constructor: ChildDebuggerTransport,
	
	  hooks: null,
	
	  ready: function () {
	    this._sender.addMessageListener(this._messageName, this);
	  },
	
	  close: function () {
	    this._sender.removeMessageListener(this._messageName, this);
	    this.emit("onClosed");
	    this.hooks.onClosed();
	  },
	
	  receiveMessage: function ({data}) {
	    this.emit("onPacket", data);
	    this.hooks.onPacket(data);
	  },
	
	  send: function (packet) {
	    this.emit("send", packet);
	    this._sender.sendAsyncMessage(this._messageName, packet);
	  },
	
	  startBulkSend: function() {
	    throw new Error("Can't send bulk data to child processes.");
	  }
	};
	
	exports.ChildDebuggerTransport = ChildDebuggerTransport;
	
	// WorkerDebuggerTransport is defined differently depending on whether we are
	// on the main thread or a worker thread. In the former case, we are required
	// by the devtools loader, and isWorker will be false. Otherwise, we are
	// required by the worker loader, and isWorker will be true.
	//
	// Each worker debugger supports only a single connection to the main thread.
	// However, its theoretically possible for multiple servers to connect to the
	// same worker. Consequently, each transport has a connection id, to allow
	// messages from multiple connections to be multiplexed on a single channel.
	
	if (typeof WorkerGlobalScope === 'undefined') { // i.e. not in a worker
	  (function () { // Main thread
	    /**
	     * A transport that uses a WorkerDebugger to send packets from the main
	     * thread to a worker thread.
	     */
	    function WorkerDebuggerTransport(dbg, id) {
	      this._dbg = dbg;
	      this._id = id;
	      this.onMessage = this._onMessage.bind(this);
	    }
	
	    WorkerDebuggerTransport.prototype = {
	      constructor: WorkerDebuggerTransport,
	
	      ready: function () {
	        this._dbg.addListener(this);
	      },
	
	      close: function () {
	        this._dbg.removeListener(this);
	        if (this.hooks) {
	          this.hooks.onClosed();
	        }
	      },
	
	      send: function (packet) {
	        this._dbg.postMessage(JSON.stringify({
	          type: "message",
	          id: this._id,
	          message: packet
	        }));
	      },
	
	      startBulkSend: function () {
	        throw new Error("Can't send bulk data from worker threads!");
	      },
	
	      _onMessage: function (message) {
	        let packet = JSON.parse(message);
	        if (packet.type !== "message" || packet.id !== this._id) {
	          return;
	        }
	
	        if (this.hooks) {
	          this.hooks.onPacket(packet.message);
	        }
	      }
	    };
	
	    exports.WorkerDebuggerTransport = WorkerDebuggerTransport;
	  }).call(this);
	} else {
	  (function () { // Worker thread
	    /*
	     * A transport that uses a WorkerDebuggerGlobalScope to send packets from a
	     * worker thread to the main thread.
	     */
	    function WorkerDebuggerTransport(scope, id) {
	      this._scope = scope;
	      this._id = id;
	      this._onMessage = this._onMessage.bind(this);
	    }
	
	    WorkerDebuggerTransport.prototype = {
	      constructor: WorkerDebuggerTransport,
	
	      ready: function () {
	        this._scope.addEventListener("message", this._onMessage);
	      },
	
	      close: function () {
	        this._scope.removeEventListener("message", this._onMessage);
	        if (this.hooks) {
	          this.hooks.onClosed();
	        }
	      },
	
	      send: function (packet) {
	        this._scope.postMessage(JSON.stringify({
	          type: "message",
	          id: this._id,
	          message: packet
	        }));
	      },
	
	      startBulkSend: function () {
	        throw new Error("Can't send bulk data from worker threads!");
	      },
	
	      _onMessage: function (event) {
	        let packet = JSON.parse(event.data);
	        if (packet.type !== "message" || packet.id !== this._id) {
	          return;
	        }
	
	        if (this.hooks) {
	          this.hooks.onPacket(packet.message);
	        }
	      }
	    };
	
	    exports.WorkerDebuggerTransport = WorkerDebuggerTransport;
	  }).call(this);
	}


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	/* General utilities used throughout devtools. */
	var { Ci, Cu, Cc, components } = __webpack_require__(35);
	const { Services } = __webpack_require__(28);
	var promise = __webpack_require__(40);
	
	const { FileUtils } = __webpack_require__(43);
	
	/**
	 * Turn the error |aError| into a string, without fail.
	 */
	exports.safeErrorString = function safeErrorString(aError) {
	  try {
	    let errorString = aError.toString();
	    if (typeof errorString == "string") {
	      // Attempt to attach a stack to |errorString|. If it throws an error, or
	      // isn't a string, don't use it.
	      try {
	        if (aError.stack) {
	          let stack = aError.stack.toString();
	          if (typeof stack == "string") {
	            errorString += "\nStack: " + stack;
	          }
	        }
	      } catch (ee) { }
	
	      // Append additional line and column number information to the output,
	      // since it might not be part of the stringified error.
	      if (typeof aError.lineNumber == "number" && typeof aError.columnNumber == "number") {
	        errorString += "Line: " + aError.lineNumber + ", column: " + aError.columnNumber;
	      }
	
	      return errorString;
	    }
	  } catch (ee) { }
	
	  // We failed to find a good error description, so do the next best thing.
	  return Object.prototype.toString.call(aError);
	};
	
	/**
	 * Report that |aWho| threw an exception, |aException|.
	 */
	exports.reportException = function reportException(aWho, aException) {
	  let msg = aWho + " threw an exception: " + exports.safeErrorString(aException);
	
	  console.log(msg);
	
	//  if (Cu && console.error) {
	//    /*
	//     * Note that the xpcshell test harness registers an observer for
	//     * console messages, so when we're running tests, this will cause
	//     * the test to quit.
	//     */
	//    console.error(msg);
	//  }
	};
	
	/**
	 * Given a handler function that may throw, return an infallible handler
	 * function that calls the fallible handler, and logs any exceptions it
	 * throws.
	 *
	 * @param aHandler function
	 *      A handler function, which may throw.
	 * @param aName string
	 *      A name for aHandler, for use in error messages. If omitted, we use
	 *      aHandler.name.
	 *
	 * (SpiderMonkey does generate good names for anonymous functions, but we
	 * don't have a way to get at them from JavaScript at the moment.)
	 */
	exports.makeInfallible = function makeInfallible(aHandler, aName) {
	  if (!aName)
	    aName = aHandler.name;
	
	  return function(/* arguments */) {
	    // try {
	    return aHandler.apply(this, arguments);
	    // } catch (ex) {
	    //   let who = "Handler function";
	    //   if (aName) {
	    //     who += " " + aName;
	    //   }
	    //   return exports.reportException(who, ex);
	    // }
	  };
	};
	
	/**
	 * Waits for the next tick in the event loop to execute a callback.
	 */
	exports.executeSoon = function executeSoon(aFn) {
	  setTimeout(aFn, 0);
	};
	
	/**
	 * Waits for the next tick in the event loop.
	 *
	 * @return Promise
	 *         A promise that is resolved after the next tick in the event loop.
	 */
	exports.waitForTick = function waitForTick() {
	  let deferred = promise.defer();
	  exports.executeSoon(deferred.resolve);
	  return deferred.promise;
	};
	
	/**
	 * Waits for the specified amount of time to pass.
	 *
	 * @param number aDelay
	 *        The amount of time to wait, in milliseconds.
	 * @return Promise
	 *         A promise that is resolved after the specified amount of time passes.
	 */
	exports.waitForTime = function waitForTime(aDelay) {
	  let deferred = promise.defer();
	  setTimeout(deferred.resolve, aDelay);
	  return deferred.promise;
	};
	
	/**
	 * Like Array.prototype.forEach, but doesn't cause jankiness when iterating over
	 * very large arrays by yielding to the browser and continuing execution on the
	 * next tick.
	 *
	 * @param Array aArray
	 *        The array being iterated over.
	 * @param Function aFn
	 *        The function called on each item in the array. If a promise is
	 *        returned by this function, iterating over the array will be paused
	 *        until the respective promise is resolved.
	 * @returns Promise
	 *          A promise that is resolved once the whole array has been iterated
	 *          over, and all promises returned by the aFn callback are resolved.
	 */
	exports.yieldingEach = function yieldingEach(aArray, aFn) {
	  const deferred = promise.defer();
	
	  let i = 0;
	  let len = aArray.length;
	  let outstanding = [deferred.promise];
	
	  (function loop() {
	    const start = Date.now();
	
	    while (i < len) {
	      // Don't block the main thread for longer than 16 ms at a time. To
	      // maintain 60fps, you have to render every frame in at least 16ms; we
	      // aren't including time spent in non-JS here, but this is Good
	      // Enough(tm).
	      if (Date.now() - start > 16) {
	        exports.executeSoon(loop);
	        return;
	      }
	
	      try {
	        outstanding.push(aFn(aArray[i], i++));
	      } catch (e) {
	        deferred.reject(e);
	        return;
	      }
	    }
	
	    deferred.resolve();
	  }());
	
	  return promise.all(outstanding);
	};
	
	/**
	 * Like XPCOMUtils.defineLazyGetter, but with a |this| sensitive getter that
	 * allows the lazy getter to be defined on a prototype and work correctly with
	 * instances.
	 *
	 * @param Object aObject
	 *        The prototype object to define the lazy getter on.
	 * @param String aKey
	 *        The key to define the lazy getter on.
	 * @param Function aCallback
	 *        The callback that will be called to determine the value. Will be
	 *        called with the |this| value of the current instance.
	 */
	exports.defineLazyPrototypeGetter =
	function defineLazyPrototypeGetter(aObject, aKey, aCallback) {
	  Object.defineProperty(aObject, aKey, {
	    configurable: true,
	    get: function() {
	      const value = aCallback.call(this);
	
	      Object.defineProperty(this, aKey, {
	        configurable: true,
	        writable: true,
	        value: value
	      });
	
	      return value;
	    }
	  });
	};
	
	/**
	 * Safely get the property value from a Debugger.Object for a given key. Walks
	 * the prototype chain until the property is found.
	 *
	 * @param Debugger.Object aObject
	 *        The Debugger.Object to get the value from.
	 * @param String aKey
	 *        The key to look for.
	 * @return Any
	 */
	exports.getProperty = function getProperty(aObj, aKey) {
	  let root = aObj;
	  try {
	    do {
	      const desc = aObj.getOwnPropertyDescriptor(aKey);
	      if (desc) {
	        if ("value" in desc) {
	          return desc.value;
	        }
	        // Call the getter if it's safe.
	        return exports.hasSafeGetter(desc) ? desc.get.call(root).return : undefined;
	      }
	      aObj = aObj.proto;
	    } while (aObj);
	  } catch (e) {
	    // If anything goes wrong report the error and return undefined.
	    exports.reportException("getProperty", e);
	  }
	  return undefined;
	};
	
	/**
	 * Determines if a descriptor has a getter which doesn't call into JavaScript.
	 *
	 * @param Object aDesc
	 *        The descriptor to check for a safe getter.
	 * @return Boolean
	 *         Whether a safe getter was found.
	 */
	exports.hasSafeGetter = function hasSafeGetter(aDesc) {
	  // Scripted functions that are CCWs will not appear scripted until after
	  // unwrapping.
	  try {
	    let fn = aDesc.get.unwrap();
	    return fn && fn.callable && fn.class == "Function" && fn.script === undefined;
	  } catch (e) {
	    // Avoid exception 'Object in compartment marked as invisible to Debugger'
	    return false;
	  }
	};
	
	/**
	 * Check if it is safe to read properties and execute methods from the given JS
	 * object. Safety is defined as being protected from unintended code execution
	 * from content scripts (or cross-compartment code).
	 *
	 * See bugs 945920 and 946752 for discussion.
	 *
	 * @type Object aObj
	 *       The object to check.
	 * @return Boolean
	 *         True if it is safe to read properties from aObj, or false otherwise.
	 */
	exports.isSafeJSObject = function isSafeJSObject(aObj) {
	  // If we are running on a worker thread, Cu is not available. In this case,
	  // we always return false, just to be on the safe side.
	  if (isWorker) {
	    return false;
	  }
	
	  if (Cu.getGlobalForObject(aObj) ==
	      Cu.getGlobalForObject(exports.isSafeJSObject)) {
	    return true; // aObj is not a cross-compartment wrapper.
	  }
	
	  let principal = Cu.getObjectPrincipal(aObj);
	  if (Services.scriptSecurityManager.isSystemPrincipal(principal)) {
	    return true; // allow chrome objects
	  }
	
	  return Cu.isXrayWrapper(aObj);
	};
	
	exports.dumpn = function dumpn(str) {
	  if (exports.dumpn.wantLogging) {
	    console.log("DBG-SERVER: " + str + "\n");
	  }
	};
	
	// We want wantLogging to be writable. The exports object is frozen by the
	// loader, so define it on dumpn instead.
	exports.dumpn.wantLogging = false;
	
	/**
	 * A verbose logger for low-level tracing.
	 */
	exports.dumpv = function(msg) {
	  if (exports.dumpv.wantVerbose) {
	    exports.dumpn(msg);
	  }
	};
	
	// We want wantLogging to be writable. The exports object is frozen by the
	// loader, so define it on dumpn instead.
	exports.dumpv.wantVerbose = false;
	
	/**
	 * Utility function for updating an object with the properties of
	 * other objects.
	 *
	 * @param aTarget Object
	 *        The object being updated.
	 * @param aNewAttrs Object
	 *        The rest params are objects to update aTarget with. You
	 *        can pass as many as you like.
	 */
	exports.update = function update(aTarget, ...aArgs) {
	  for (let attrs of aArgs) {
	    for (let key in attrs) {
	      let desc = Object.getOwnPropertyDescriptor(attrs, key);
	
	      if (desc) {
	        Object.defineProperty(aTarget, key, desc);
	      }
	    }
	  }
	
	  return aTarget;
	};
	
	/**
	 * Utility function for getting the values from an object as an array
	 *
	 * @param aObject Object
	 *        The object to iterate over
	 */
	exports.values = function values(aObject) {
	  return Object.keys(aObject).map(k => aObject[k]);
	};
	
	/**
	 * Defines a getter on a specified object that will be created upon first use.
	 *
	 * @param aObject
	 *        The object to define the lazy getter on.
	 * @param aName
	 *        The name of the getter to define on aObject.
	 * @param aLambda
	 *        A function that returns what the getter should return.  This will
	 *        only ever be called once.
	 */
	exports.defineLazyGetter = function defineLazyGetter(aObject, aName, aLambda) {
	  Object.defineProperty(aObject, aName, {
	    get: function() {
	      delete aObject[aName];
	      return aObject[aName] = aLambda.apply(aObject);
	    },
	    configurable: true,
	    enumerable: true
	  });
	};
	
	// DEPRECATED: use DevToolsUtils.assert(condition, message) instead!
	let haveLoggedDeprecationMessage = false;
	exports.dbg_assert = function dbg_assert(cond, e) {
	  if (!haveLoggedDeprecationMessage) {
	    haveLoggedDeprecationMessage = true;
	    const deprecationMessage = "DevToolsUtils.dbg_assert is deprecated! Use DevToolsUtils.assert instead!"
	          + Error().stack;
	    console.log(deprecationMessage);
	    if (typeof console === "object" && console && console.warn) {
	      console.warn(deprecationMessage);
	    }
	  }
	
	  if (!cond) {
	    return e;
	  }
	};
	
	const { AppConstants } = __webpack_require__(44);
	
	/**
	 * No operation. The empty function.
	 */
	exports.noop = function() { };
	
	function reallyAssert(condition, message) {
	  if (!condition) {
	    const err = new Error("Assertion failure: " + message);
	    exports.reportException("DevToolsUtils.assert", err);
	    throw err;
	  }
	}
	
	/**
	 * DevToolsUtils.assert(condition, message)
	 *
	 * @param Boolean condition
	 * @param String message
	 *
	 * Assertions are enabled when any of the following are true:
	 *   - This is a DEBUG_JS_MODULES build
	 *   - This is a DEBUG build
	 *   - DevToolsUtils.testing is set to true
	 *
	 * If assertions are enabled, then `condition` is checked and if false-y, the
	 * assertion failure is logged and then an error is thrown.
	 *
	 * If assertions are not enabled, then this function is a no-op.
	 *
	 * This is an improvement over `dbg_assert`, which doesn't actually cause any
	 * fatal behavior, and is therefore much easier to accidentally ignore.
	 */
	Object.defineProperty(exports, "assert", {
	  get: () => (AppConstants.DEBUG || AppConstants.DEBUG_JS_MODULES || this.testing)
	    ? reallyAssert
	    : exports.noop,
	});
	
	/**
	 * Defines a getter on a specified object for a module.  The module will not
	 * be imported until first use.
	 *
	 * @param aObject
	 *        The object to define the lazy getter on.
	 * @param aName
	 *        The name of the getter to define on aObject for the module.
	 * @param aResource
	 *        The URL used to obtain the module.
	 * @param aSymbol
	 *        The name of the symbol exported by the module.
	 *        This parameter is optional and defaults to aName.
	 */
	exports.defineLazyModuleGetter = function defineLazyModuleGetter(aObject, aName,
	                                                                 aResource,
	                                                                 aSymbol)
	{
	  this.defineLazyGetter(aObject, aName, function XPCU_moduleLambda() {
	    var temp = {};
	    Cu.import(aResource, temp);
	    return temp[aSymbol || aName];
	  });
	};
	
	const { NetUtil } = __webpack_require__(45);
	
	const { TextDecoder, OS } = __webpack_require__(46);
	
	const NetworkHelper = __webpack_require__(47);
	
	/**
	 * Performs a request to load the desired URL and returns a promise.
	 *
	 * @param aURL String
	 *        The URL we will request.
	 * @param aOptions Object
	 *        An object with the following optional properties:
	 *        - loadFromCache: if false, will bypass the cache and
	 *          always load fresh from the network (default: true)
	 *        - policy: the nsIContentPolicy type to apply when fetching the URL
	 *        - window: the window to get the loadGroup from
	 *        - charset: the charset to use if the channel doesn't provide one
	 * @returns Promise that resolves with an object with the following members on
	 *          success:
	 *           - content: the document at that URL, as a string,
	 *           - contentType: the content type of the document
	 *
	 *          If an error occurs, the promise is rejected with that error.
	 *
	 * XXX: It may be better to use nsITraceableChannel to get to the sources
	 * without relying on caching when we can (not for eval, etc.):
	 * http://www.softwareishard.com/blog/firebug/nsitraceablechannel-intercept-http-traffic/
	 */
	function mainThreadFetch(aURL, aOptions = { loadFromCache: true,
	                                          policy: Ci.nsIContentPolicy.TYPE_OTHER,
	                                          window: null,
	                                          charset: null }) {
	  // Create a channel.
	  let url = aURL.split(" -> ").pop();
	  let channel;
	  try {
	    channel = newChannelForURL(url, aOptions);
	  } catch (ex) {
	    return promise.reject(ex);
	  }
	
	  // Set the channel options.
	  channel.loadFlags = aOptions.loadFromCache
	    ? channel.LOAD_FROM_CACHE
	    : channel.LOAD_BYPASS_CACHE;
	
	  if (aOptions.window) {
	    // Respect private browsing.
	    channel.loadGroup = aOptions.window.QueryInterface(Ci.nsIInterfaceRequestor)
	                          .getInterface(Ci.nsIWebNavigation)
	                          .QueryInterface(Ci.nsIDocumentLoader)
	                          .loadGroup;
	  }
	
	  let deferred = promise.defer();
	  let onResponse = (stream, status, request) => {
	    if (!components.isSuccessCode(status)) {
	      deferred.reject(new Error(`Failed to fetch ${url}. Code ${status}.`));
	      return;
	    }
	
	    try {
	      // We cannot use NetUtil to do the charset conversion as if charset
	      // information is not available and our default guess is wrong the method
	      // might fail and we lose the stream data. This means we can't fall back
	      // to using the locale default encoding (bug 1181345).
	
	      // Read and decode the data according to the locale default encoding.
	      let available = stream.available();
	      let source = NetUtil.readInputStreamToString(stream, available);
	      stream.close();
	
	      // If the channel or the caller has correct charset information, the
	      // content will be decoded correctly. If we have to fall back to UTF-8 and
	      // the guess is wrong, the conversion fails and convertToUnicode returns
	      // the input unmodified. Essentially we try to decode the data as UTF-8
	      // and if that fails, we use the locale specific default encoding. This is
	      // the best we can do if the source does not provide charset info.
	      let charset = channel.contentCharset || aOptions.charset || "UTF-8";
	      let unicodeSource = NetworkHelper.convertToUnicode(source, charset);
	
	      deferred.resolve({
	        content: unicodeSource,
	        contentType: request.contentType
	      });
	    } catch (ex) {
	      let uri = request.originalURI;
	      if (ex.name === "NS_BASE_STREAM_CLOSED" && uri instanceof Ci.nsIFileURL) {
	        // Empty files cause NS_BASE_STREAM_CLOSED exception. Use OS.File to
	        // differentiate between empty files and other errors (bug 1170864).
	        // This can be removed when bug 982654 is fixed.
	
	        uri.QueryInterface(Ci.nsIFileURL);
	        let result = OS.File.read(uri.file.path).then(bytes => {
	          // Convert the bytearray to a String.
	          let decoder = new TextDecoder();
	          let content = decoder.decode(bytes);
	
	          // We can't detect the contentType without opening a channel
	          // and that failed already. This is the best we can do here.
	          return {
	            content,
	            contentType: "text/plain"
	          };
	        });
	
	        deferred.resolve(result);
	      } else {
	        deferred.reject(ex);
	      }
	    }
	  };
	
	  // Open the channel
	  try {
	    NetUtil.asyncFetch(channel, onResponse);
	  } catch (ex) {
	    return promise.reject(ex);
	  }
	
	  return deferred.promise;
	}
	
	/**
	 * Opens a channel for given URL. Tries a bit harder than NetUtil.newChannel.
	 *
	 * @param {String} url - The URL to open a channel for.
	 * @param {Object} options - The options object passed to @method fetch.
	 * @return {nsIChannel} - The newly created channel. Throws on failure.
	 */
	function newChannelForURL(url, { policy }) {
	  let channelOptions = {
	    contentPolicyType: policy,
	    loadUsingSystemPrincipal: true,
	    uri: url
	  };
	
	  try {
	    return NetUtil.newChannel(channelOptions);
	  } catch (e) {
	    // In the xpcshell tests, the script url is the absolute path of the test
	    // file, which will make a malformed URI error be thrown. Add the file
	    // scheme to see if it helps.
	    channelOptions.uri = "file://" + url;
	
	    return NetUtil.newChannel(channelOptions);
	  }
	}
	
	// Fetch is defined differently depending on whether we are on the main thread
	// or a worker thread.
	if (typeof WorkerGlobalScope === "undefined") { // i.e. not in a worker
	  exports.fetch = mainThreadFetch;
	} else {
	  // Services is not available in worker threads, nor is there any other way
	  // to fetch a URL. We need to enlist the help from the main thread here, by
	  // issuing an rpc request, to fetch the URL on our behalf.
	  exports.fetch = function(url, options) {
	    return rpc("fetch", url, options);
	  };
	}
	
	/**
	 * Returns a promise that is resolved or rejected when all promises have settled
	 * (resolved or rejected).
	 *
	 * This differs from Promise.all, which will reject immediately after the first
	 * rejection, instead of waiting for the remaining promises to settle.
	 *
	 * @param values
	 *        Iterable of promises that may be pending, resolved, or rejected. When
	 *        when all promises have settled (resolved or rejected), the returned
	 *        promise will be resolved or rejected as well.
	 *
	 * @return A new promise that is fulfilled when all values have settled
	 *         (resolved or rejected). Its resolution value will be an array of all
	 *         resolved values in the given order, or undefined if values is an
	 *         empty array. The reject reason will be forwarded from the first
	 *         promise in the list of given promises to be rejected.
	 */
	exports.settleAll = values => {
	  if (values === null || typeof (values[Symbol.iterator]) != "function") {
	    throw new Error("settleAll() expects an iterable.");
	  }
	
	  let deferred = promise.defer();
	
	  values = Array.isArray(values) ? values : [...values];
	  let countdown = values.length;
	  let resolutionValues = new Array(countdown);
	  let rejectionValue;
	  let rejectionOccurred = false;
	
	  if (!countdown) {
	    deferred.resolve(resolutionValues);
	    return deferred.promise;
	  }
	
	  function checkForCompletion() {
	    if (--countdown > 0) {
	      return;
	    }
	    if (!rejectionOccurred) {
	      deferred.resolve(resolutionValues);
	    } else {
	      deferred.reject(rejectionValue);
	    }
	  }
	
	  for (let i = 0; i < values.length; i++) {
	    let index = i;
	    let value = values[i];
	    let resolver = result => {
	      resolutionValues[index] = result;
	      checkForCompletion();
	    };
	    let rejecter = error => {
	      if (!rejectionOccurred) {
	        rejectionValue = error;
	        rejectionOccurred = true;
	      }
	      checkForCompletion();
	    };
	
	    if (value && typeof (value.then) == "function") {
	      value.then(resolver, rejecter);
	    } else {
	      // Given value is not a promise, forward it as a resolution value.
	      resolver(value);
	    }
	  }
	
	  return deferred.promise;
	};
	
	/**
	 * When the testing flag is set, various behaviors may be altered from
	 * production mode, typically to enable easier testing or enhanced debugging.
	 */
	var testing = false;
	Object.defineProperty(exports, "testing", {
	  get: function() {
	    return testing;
	  },
	  set: function(state) {
	    testing = state;
	  }
	});
	
	/**
	 * Open the file at the given path for reading.
	 *
	 * @param {String} filePath
	 *
	 * @returns Promise<nsIInputStream>
	 */
	exports.openFileStream = function(filePath) {
	  return new Promise((resolve, reject) => {
	    const uri = NetUtil.newURI(new FileUtils.File(filePath));
	    NetUtil.asyncFetch(
	      { uri, loadUsingSystemPrincipal: true },
	      (stream, result) => {
	        if (!components.isSuccessCode(result)) {
	          reject(new Error(`Could not open "${filePath}": result = ${result}`));
	          return;
	        }
	
	        resolve(stream);
	      }
	    );
	  });
	};
	
	exports.isGenerator = function(fn) {
	  if (typeof fn !== "function") {
	    return false;
	  }
	  let proto = Object.getPrototypeOf(fn);
	  if (!proto) {
	    return false;
	  }
	  let ctor = proto.constructor;
	  if (!ctor) {
	    return false;
	  }
	  return ctor.name == "GeneratorFunction";
	};
	
	exports.isPromise = function(p) {
	  return p && typeof p.then === "function";
	};
	
	/**
	 * Return true if `thing` is a SavedFrame, false otherwise.
	 */
	exports.isSavedFrame = function(thing) {
	  return Object.prototype.toString.call(thing) === "[object SavedFrame]";
	};


/***/ },
/* 43 */
/***/ function(module, exports) {

	/*
	 * A sham for https://dxr.mozilla.org/mozilla-central/source/toolkit/modules/FileUtils.jsm
	 */


/***/ },
/* 44 */
/***/ function(module, exports) {

	/*
	 * A sham for https://dxr.mozilla.org/mozilla-central/source/toolkit/modules/AppConstants.jsm
	 */
	
	module.exports = { AppConstants: {} };


/***/ },
/* 45 */
/***/ function(module, exports) {

	/*
	 * A sham for https://dxr.mozilla.org/mozilla-central/source/netwerk/base/NetUtil.jsm
	 */


/***/ },
/* 46 */
/***/ function(module, exports) {

	/*
	 * A sham for https://dxr.mozilla.org/mozilla-central/source/toolkit/components/osfile/osfile.jsm
	 */


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/* vim:set ts=2 sw=2 sts=2 et: */
	/*
	 * Software License Agreement (BSD License)
	 *
	 * Copyright (c) 2007, Parakey Inc.
	 * All rights reserved.
	 *
	 * Redistribution and use of this software in source and binary forms, with or without modification,
	 * are permitted provided that the following conditions are met:
	 *
	 * * Redistributions of source code must retain the above
	 *   copyright notice, this list of conditions and the
	 *   following disclaimer.
	 *
	 * * Redistributions in binary form must reproduce the above
	 *   copyright notice, this list of conditions and the
	 *   following disclaimer in the documentation and/or other
	 *   materials provided with the distribution.
	 *
	 * * Neither the name of Parakey Inc. nor the names of its
	 *   contributors may be used to endorse or promote products
	 *   derived from this software without specific prior
	 *   written permission of Parakey Inc.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
	 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
	 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
	 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
	 * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
	 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
	
	/*
	 * Creator:
	 *  Joe Hewitt
	 * Contributors
	 *  John J. Barton (IBM Almaden)
	 *  Jan Odvarko (Mozilla Corp.)
	 *  Max Stepanov (Aptana Inc.)
	 *  Rob Campbell (Mozilla Corp.)
	 *  Hans Hillen (Paciello Group, Mozilla)
	 *  Curtis Bartley (Mozilla Corp.)
	 *  Mike Collins (IBM Almaden)
	 *  Kevin Decker
	 *  Mike Ratcliffe (Comartis AG)
	 *  Hernan Rodríguez Colmeiro
	 *  Austin Andrews
	 *  Christoph Dorn
	 *  Steven Roussey (AppCenter Inc, Network54)
	 *  Mihai Sucan (Mozilla Corp.)
	 */
	
	"use strict";
	
	const {components, Cc, Ci, Cu} = __webpack_require__(35);
	const { NetUtil } = __webpack_require__(45);
	const DevToolsUtils = __webpack_require__(42);
	
	// The cache used in the `nsIURL` function.
	const gNSURLStore = new Map();
	
	/**
	 * Helper object for networking stuff.
	 *
	 * Most of the following functions have been taken from the Firebug source. They
	 * have been modified to match the Firefox coding rules.
	 */
	var NetworkHelper = {
	  /**
	   * Converts aText with a given aCharset to unicode.
	   *
	   * @param string aText
	   *        Text to convert.
	   * @param string aCharset
	   *        Charset to convert the text to.
	   * @returns string
	   *          Converted text.
	   */
	  convertToUnicode: function NH_convertToUnicode(aText, aCharset)
	  {
	    let conv = Cc("@mozilla.org/intl/scriptableunicodeconverter").
	               createInstance(Ci.nsIScriptableUnicodeConverter);
	    try {
	      conv.charset = aCharset || "UTF-8";
	      return conv.ConvertToUnicode(aText);
	    }
	    catch (ex) {
	      return aText;
	    }
	  },
	
	  /**
	   * Reads all available bytes from aStream and converts them to aCharset.
	   *
	   * @param nsIInputStream aStream
	   * @param string aCharset
	   * @returns string
	   *          UTF-16 encoded string based on the content of aStream and aCharset.
	   */
	  readAndConvertFromStream: function NH_readAndConvertFromStream(aStream, aCharset)
	  {
	    let text = null;
	    try {
	      text = NetUtil.readInputStreamToString(aStream, aStream.available())
	      return this.convertToUnicode(text, aCharset);
	    }
	    catch (err) {
	      return text;
	    }
	  },
	
	   /**
	   * Reads the posted text from aRequest.
	   *
	   * @param nsIHttpChannel aRequest
	   * @param string aCharset
	   *        The content document charset, used when reading the POSTed data.
	   * @returns string or null
	   *          Returns the posted string if it was possible to read from aRequest
	   *          otherwise null.
	   */
	  readPostTextFromRequest: function NH_readPostTextFromRequest(aRequest, aCharset)
	  {
	    if (aRequest instanceof Ci.nsIUploadChannel) {
	      let iStream = aRequest.uploadStream;
	
	      let isSeekableStream = false;
	      if (iStream instanceof Ci.nsISeekableStream) {
	        isSeekableStream = true;
	      }
	
	      let prevOffset;
	      if (isSeekableStream) {
	        prevOffset = iStream.tell();
	        iStream.seek(Ci.nsISeekableStream.NS_SEEK_SET, 0);
	      }
	
	      // Read data from the stream.
	      let text = this.readAndConvertFromStream(iStream, aCharset);
	
	      // Seek locks the file, so seek to the beginning only if necko hasn't
	      // read it yet, since necko doesn't seek to 0 before reading (at lest
	      // not till 459384 is fixed).
	      if (isSeekableStream && prevOffset == 0) {
	        iStream.seek(Ci.nsISeekableStream.NS_SEEK_SET, 0);
	      }
	      return text;
	    }
	    return null;
	  },
	
	  /**
	   * Reads the posted text from the page's cache.
	   *
	   * @param nsIDocShell aDocShell
	   * @param string aCharset
	   * @returns string or null
	   *          Returns the posted string if it was possible to read from
	   *          aDocShell otherwise null.
	   */
	  readPostTextFromPage: function NH_readPostTextFromPage(aDocShell, aCharset)
	  {
	    let webNav = aDocShell.QueryInterface(Ci.nsIWebNavigation);
	    return this.readPostTextFromPageViaWebNav(webNav, aCharset);
	  },
	
	  /**
	   * Reads the posted text from the page's cache, given an nsIWebNavigation
	   * object.
	   *
	   * @param nsIWebNavigation aWebNav
	   * @param string aCharset
	   * @returns string or null
	   *          Returns the posted string if it was possible to read from
	   *          aWebNav, otherwise null.
	   */
	  readPostTextFromPageViaWebNav:
	  function NH_readPostTextFromPageViaWebNav(aWebNav, aCharset)
	  {
	    if (aWebNav instanceof Ci.nsIWebPageDescriptor) {
	      let descriptor = aWebNav.currentDescriptor;
	
	      if (descriptor instanceof Ci.nsISHEntry && descriptor.postData &&
	          descriptor instanceof Ci.nsISeekableStream) {
	        descriptor.seek(NS_SEEK_SET, 0);
	
	        return this.readAndConvertFromStream(descriptor, aCharset);
	      }
	    }
	    return null;
	  },
	
	  /**
	   * Gets the web appId that is associated with aRequest.
	   *
	   * @param nsIHttpChannel aRequest
	   * @returns number|null
	   *          The appId for the given request, if available.
	   */
	  getAppIdForRequest: function NH_getAppIdForRequest(aRequest)
	  {
	    try {
	      return this.getRequestLoadContext(aRequest).appId;
	    } catch (ex) {
	      // request loadContent is not always available.
	    }
	    return null;
	  },
	
	  /**
	   * Gets the topFrameElement that is associated with aRequest. This
	   * works in single-process and multiprocess contexts. It may cross
	   * the content/chrome boundary.
	   *
	   * @param nsIHttpChannel aRequest
	   * @returns nsIDOMElement|null
	   *          The top frame element for the given request.
	   */
	  getTopFrameForRequest: function NH_getTopFrameForRequest(aRequest)
	  {
	    try {
	      return this.getRequestLoadContext(aRequest).topFrameElement;
	    } catch (ex) {
	      // request loadContent is not always available.
	    }
	    return null;
	  },
	
	  /**
	   * Gets the nsIDOMWindow that is associated with aRequest.
	   *
	   * @param nsIHttpChannel aRequest
	   * @returns nsIDOMWindow or null
	   */
	  getWindowForRequest: function NH_getWindowForRequest(aRequest)
	  {
	    try {
	      return this.getRequestLoadContext(aRequest).associatedWindow;
	    } catch (ex) {
	      // TODO: bug 802246 - getWindowForRequest() throws on b2g: there is no
	      // associatedWindow property.
	    }
	    return null;
	  },
	
	  /**
	   * Gets the nsILoadContext that is associated with aRequest.
	   *
	   * @param nsIHttpChannel aRequest
	   * @returns nsILoadContext or null
	   */
	  getRequestLoadContext: function NH_getRequestLoadContext(aRequest)
	  {
	    try {
	      return aRequest.notificationCallbacks.getInterface(Ci.nsILoadContext);
	    } catch (ex) { }
	
	    try {
	      return aRequest.loadGroup.notificationCallbacks.getInterface(Ci.nsILoadContext);
	    } catch (ex) { }
	
	    return null;
	  },
	
	  /**
	   * Determines whether the request has been made for the top level document.
	   *
	   * @param nsIHttpChannel aRequest
	   * @returns Boolean True if the request represents the top level document.
	   */
	  isTopLevelLoad: function(aRequest)
	  {
	    if (aRequest instanceof Ci.nsIChannel) {
	      let loadInfo = aRequest.loadInfo;
	      if (loadInfo && loadInfo.parentOuterWindowID == loadInfo.outerWindowID) {
	        return (aRequest.loadFlags & Ci.nsIChannel.LOAD_DOCUMENT_URI);
	      }
	    }
	
	    return false;
	  },
	
	  /**
	   * Loads the content of aUrl from the cache.
	   *
	   * @param string aUrl
	   *        URL to load the cached content for.
	   * @param string aCharset
	   *        Assumed charset of the cached content. Used if there is no charset
	   *        on the channel directly.
	   * @param function aCallback
	   *        Callback that is called with the loaded cached content if available
	   *        or null if something failed while getting the cached content.
	   */
	  loadFromCache: function NH_loadFromCache(aUrl, aCharset, aCallback)
	  {
	    let channel = NetUtil.newChannel({uri: aUrl, loadUsingSystemPrincipal: true});
	
	    // Ensure that we only read from the cache and not the server.
	    channel.loadFlags = Ci.nsIRequest.LOAD_FROM_CACHE |
	      Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE |
	      Ci.nsICachingChannel.LOAD_BYPASS_LOCAL_CACHE_IF_BUSY;
	
	    NetUtil.asyncFetch(
	      channel,
	      (aInputStream, aStatusCode, aRequest) => {
	        if (!components.isSuccessCode(aStatusCode)) {
	          aCallback(null);
	          return;
	        }
	
	        // Try to get the encoding from the channel. If there is none, then use
	        // the passed assumed aCharset.
	        let aChannel = aRequest.QueryInterface(Ci.nsIChannel);
	        let contentCharset = aChannel.contentCharset || aCharset;
	
	        // Read the content of the stream using contentCharset as encoding.
	        aCallback(this.readAndConvertFromStream(aInputStream, contentCharset));
	      });
	  },
	
	  /**
	   * Parse a raw Cookie header value.
	   *
	   * @param string aHeader
	   *        The raw Cookie header value.
	   * @return array
	   *         Array holding an object for each cookie. Each object holds the
	   *         following properties: name and value.
	   */
	  parseCookieHeader: function NH_parseCookieHeader(aHeader)
	  {
	    let cookies = aHeader.split(";");
	    let result = [];
	
	    cookies.forEach(function(aCookie) {
	      let equal = aCookie.indexOf("=");
	      let name = aCookie.substr(0, equal);
	      let value = aCookie.substr(equal + 1);
	      result.push({name: unescape(name.trim()),
	                   value: unescape(value.trim())});
	    });
	
	    return result;
	  },
	
	  /**
	   * Parse a raw Set-Cookie header value.
	   *
	   * @param string aHeader
	   *        The raw Set-Cookie header value.
	   * @return array
	   *         Array holding an object for each cookie. Each object holds the
	   *         following properties: name, value, secure (boolean), httpOnly
	   *         (boolean), path, domain and expires (ISO date string).
	   */
	  parseSetCookieHeader: function NH_parseSetCookieHeader(aHeader)
	  {
	    let rawCookies = aHeader.split(/\r\n|\n|\r/);
	    let cookies = [];
	
	    rawCookies.forEach(function(aCookie) {
	      let equal = aCookie.indexOf("=");
	      let name = unescape(aCookie.substr(0, equal).trim());
	      let parts = aCookie.substr(equal + 1).split(";");
	      let value = unescape(parts.shift().trim());
	
	      let cookie = {name: name, value: value};
	
	      parts.forEach(function(aPart) {
	        let part = aPart.trim();
	        if (part.toLowerCase() == "secure") {
	          cookie.secure = true;
	        }
	        else if (part.toLowerCase() == "httponly") {
	          cookie.httpOnly = true;
	        }
	        else if (part.indexOf("=") > -1) {
	          let pair = part.split("=");
	          pair[0] = pair[0].toLowerCase();
	          if (pair[0] == "path" || pair[0] == "domain") {
	            cookie[pair[0]] = pair[1];
	          }
	          else if (pair[0] == "expires") {
	            try {
	              pair[1] = pair[1].replace(/-/g, ' ');
	              cookie.expires = new Date(pair[1]).toISOString();
	            }
	            catch (ex) { }
	          }
	        }
	      });
	
	      cookies.push(cookie);
	    });
	
	    return cookies;
	  },
	
	  // This is a list of all the mime category maps jviereck could find in the
	  // firebug code base.
	  mimeCategoryMap: {
	    "text/plain": "txt",
	    "text/html": "html",
	    "text/xml": "xml",
	    "text/xsl": "txt",
	    "text/xul": "txt",
	    "text/css": "css",
	    "text/sgml": "txt",
	    "text/rtf": "txt",
	    "text/x-setext": "txt",
	    "text/richtext": "txt",
	    "text/javascript": "js",
	    "text/jscript": "txt",
	    "text/tab-separated-values": "txt",
	    "text/rdf": "txt",
	    "text/xif": "txt",
	    "text/ecmascript": "js",
	    "text/vnd.curl": "txt",
	    "text/x-json": "json",
	    "text/x-js": "txt",
	    "text/js": "txt",
	    "text/vbscript": "txt",
	    "view-source": "txt",
	    "view-fragment": "txt",
	    "application/xml": "xml",
	    "application/xhtml+xml": "xml",
	    "application/atom+xml": "xml",
	    "application/rss+xml": "xml",
	    "application/vnd.mozilla.maybe.feed": "xml",
	    "application/vnd.mozilla.xul+xml": "xml",
	    "application/javascript": "js",
	    "application/x-javascript": "js",
	    "application/x-httpd-php": "txt",
	    "application/rdf+xml": "xml",
	    "application/ecmascript": "js",
	    "application/http-index-format": "txt",
	    "application/json": "json",
	    "application/x-js": "txt",
	    "multipart/mixed": "txt",
	    "multipart/x-mixed-replace": "txt",
	    "image/svg+xml": "svg",
	    "application/octet-stream": "bin",
	    "image/jpeg": "image",
	    "image/jpg": "image",
	    "image/gif": "image",
	    "image/png": "image",
	    "image/bmp": "image",
	    "application/x-shockwave-flash": "flash",
	    "video/x-flv": "flash",
	    "audio/mpeg3": "media",
	    "audio/x-mpeg-3": "media",
	    "video/mpeg": "media",
	    "video/x-mpeg": "media",
	    "audio/ogg": "media",
	    "application/ogg": "media",
	    "application/x-ogg": "media",
	    "application/x-midi": "media",
	    "audio/midi": "media",
	    "audio/x-mid": "media",
	    "audio/x-midi": "media",
	    "music/crescendo": "media",
	    "audio/wav": "media",
	    "audio/x-wav": "media",
	    "text/json": "json",
	    "application/x-json": "json",
	    "application/json-rpc": "json",
	    "application/x-web-app-manifest+json": "json",
	    "application/manifest+json": "json"
	  },
	
	  /**
	   * Check if the given MIME type is a text-only MIME type.
	   *
	   * @param string aMimeType
	   * @return boolean
	   */
	  isTextMimeType: function NH_isTextMimeType(aMimeType)
	  {
	    if (aMimeType.indexOf("text/") == 0) {
	      return true;
	    }
	
	    // XML and JSON often come with custom MIME types, so in addition to the
	    // standard "application/xml" and "application/json", we also look for
	    // variants like "application/x-bigcorp+xml". For JSON we allow "+json" and
	    // "-json" as suffixes.
	    if (/^application\/\w+(?:[\.-]\w+)*(?:\+xml|[-+]json)$/.test(aMimeType)) {
	      return true;
	    }
	
	    let category = this.mimeCategoryMap[aMimeType] || null;
	    switch (category) {
	      case "txt":
	      case "js":
	      case "json":
	      case "css":
	      case "html":
	      case "svg":
	      case "xml":
	        return true;
	
	      default:
	        return false;
	    }
	  },
	
	  /**
	   * Takes a securityInfo object of nsIRequest, the nsIRequest itself and
	   * extracts security information from them.
	   *
	   * @param object securityInfo
	   *        The securityInfo object of a request. If null channel is assumed
	   *        to be insecure.
	   * @param object httpActivity
	   *        The httpActivity object for the request with at least members
	   *        { private, hostname }.
	   *
	   * @return object
	   *         Returns an object containing following members:
	   *          - state: The security of the connection used to fetch this
	   *                   request. Has one of following string values:
	   *                    * "insecure": the connection was not secure (only http)
	   *                    * "weak": the connection has minor security issues
	   *                    * "broken": secure connection failed (e.g. expired cert)
	   *                    * "secure": the connection was properly secured.
	   *          If state == broken:
	   *            - errorMessage: full error message from nsITransportSecurityInfo.
	   *          If state == secure:
	   *            - protocolVersion: one of TLSv1, TLSv1.1, TLSv1.2.
	   *            - cipherSuite: the cipher suite used in this connection.
	   *            - cert: information about certificate used in this connection.
	   *                    See parseCertificateInfo for the contents.
	   *            - hsts: true if host uses Strict Transport Security, false otherwise
	   *            - hpkp: true if host uses Public Key Pinning, false otherwise
	   *          If state == weak: Same as state == secure and
	   *            - weaknessReasons: list of reasons that cause the request to be
	   *                               considered weak. See getReasonsForWeakness.
	   */
	  parseSecurityInfo: function NH_parseSecurityInfo(securityInfo, httpActivity) {
	    const info = {
	      state: "insecure",
	    };
	
	    // The request did not contain any security info.
	    if (!securityInfo) {
	      return info;
	    }
	
	    /**
	     * Different scenarios to consider here and how they are handled:
	     * - request is HTTP, the connection is not secure
	     *   => securityInfo is null
	     *      => state === "insecure"
	     *
	     * - request is HTTPS, the connection is secure
	     *   => .securityState has STATE_IS_SECURE flag
	     *      => state === "secure"
	     *
	     * - request is HTTPS, the connection has security issues
	     *   => .securityState has STATE_IS_INSECURE flag
	     *   => .errorCode is an NSS error code.
	     *      => state === "broken"
	     *
	     * - request is HTTPS, the connection was terminated before the security
	     *   could be validated
	     *   => .securityState has STATE_IS_INSECURE flag
	     *   => .errorCode is NOT an NSS error code.
	     *   => .errorMessage is not available.
	     *      => state === "insecure"
	     *
	     * - request is HTTPS but it uses a weak cipher or old protocol, see
	     *   https://hg.mozilla.org/mozilla-central/annotate/def6ed9d1c1a/
	     *   security/manager/ssl/nsNSSCallbacks.cpp#l1233
	     * - request is mixed content (which makes no sense whatsoever)
	     *   => .securityState has STATE_IS_BROKEN flag
	     *   => .errorCode is NOT an NSS error code
	     *   => .errorMessage is not available
	     *      => state === "weak"
	     */
	
	    securityInfo.QueryInterface(Ci.nsITransportSecurityInfo);
	    securityInfo.QueryInterface(Ci.nsISSLStatusProvider);
	
	    const wpl = Ci.nsIWebProgressListener;
	    const NSSErrorsService = Cc['@mozilla.org/nss_errors_service;1']
	                               .getService(Ci.nsINSSErrorsService);
	    const SSLStatus = securityInfo.SSLStatus;
	    if (!NSSErrorsService.isNSSErrorCode(securityInfo.errorCode)) {
	      const state = securityInfo.securityState;
	
	      let uri = null;
	      if (httpActivity.channel && httpActivity.channel.URI) {
	        uri = httpActivity.channel.URI;
	      }
	      if (uri && !uri.schemeIs("https") && !uri.schemeIs("wss")) {
	        // it is not enough to look at the transport security info - schemes other than
	        // https and wss are subject to downgrade/etc at the scheme level and should
	        // always be considered insecure
	        info.state = "insecure";
	      } else if (state & wpl.STATE_IS_SECURE) {
	        // The connection is secure if the scheme is sufficient
	        info.state = "secure";
	      } else if (state & wpl.STATE_IS_BROKEN) {
	        // The connection is not secure, there was no error but there's some
	        // minor security issues.
	        info.state = "weak";
	        info.weaknessReasons = this.getReasonsForWeakness(state);
	      } else if (state & wpl.STATE_IS_INSECURE) {
	        // This was most likely an https request that was aborted before
	        // validation. Return info as info.state = insecure.
	        return info;
	      } else {
	        DevToolsUtils.reportException("NetworkHelper.parseSecurityInfo",
	          "Security state " + state + " has no known STATE_IS_* flags.");
	        return info;
	      }
	
	      // Cipher suite.
	      info.cipherSuite = SSLStatus.cipherName;
	
	      // Protocol version.
	      info.protocolVersion = this.formatSecurityProtocol(SSLStatus.protocolVersion);
	
	      // Certificate.
	      info.cert = this.parseCertificateInfo(SSLStatus.serverCert);
	
	      // HSTS and HPKP if available.
	      if (httpActivity.hostname) {
	        const sss = Cc("@mozilla.org/ssservice;1")
	                      .getService(Ci.nsISiteSecurityService);
	
	
	        // SiteSecurityService uses different storage if the channel is
	        // private. Thus we must give isSecureHost correct flags or we
	        // might get incorrect results.
	        let flags = (httpActivity.private) ?
	                      Ci.nsISocketProvider.NO_PERMANENT_STORAGE : 0;
	
	        let host = httpActivity.hostname;
	
	        info.hsts = sss.isSecureHost(sss.HEADER_HSTS, host, flags);
	        info.hpkp = sss.isSecureHost(sss.HEADER_HPKP, host, flags);
	      } else {
	        DevToolsUtils.reportException("NetworkHelper.parseSecurityInfo",
	          "Could not get HSTS/HPKP status as hostname is not available.");
	        info.hsts = false;
	        info.hpkp = false;
	      }
	
	    } else {
	      // The connection failed.
	      info.state = "broken";
	      info.errorMessage = securityInfo.errorMessage;
	    }
	
	    return info;
	  },
	
	  /**
	   * Takes an nsIX509Cert and returns an object with certificate information.
	   *
	   * @param nsIX509Cert cert
	   *        The certificate to extract the information from.
	   * @return object
	   *         An object with following format:
	   *           {
	   *             subject: { commonName, organization, organizationalUnit },
	   *             issuer: { commonName, organization, organizationUnit },
	   *             validity: { start, end },
	   *             fingerprint: { sha1, sha256 }
	   *           }
	   */
	  parseCertificateInfo: function NH_parseCertifificateInfo(cert) {
	    let info = {};
	    if (cert) {
	      info.subject = {
	        commonName: cert.commonName,
	        organization: cert.organization,
	        organizationalUnit: cert.organizationalUnit,
	      };
	
	      info.issuer = {
	        commonName: cert.issuerCommonName,
	        organization: cert.issuerOrganization,
	        organizationUnit: cert.issuerOrganizationUnit,
	      };
	
	      info.validity = {
	        start: cert.validity.notBeforeLocalDay,
	        end: cert.validity.notAfterLocalDay,
	      };
	
	      info.fingerprint = {
	        sha1: cert.sha1Fingerprint,
	        sha256: cert.sha256Fingerprint,
	      };
	    } else {
	      DevToolsUtils.reportException("NetworkHelper.parseCertificateInfo",
	        "Secure connection established without certificate.");
	    }
	
	    return info;
	  },
	
	  /**
	   * Takes protocolVersion of SSLStatus object and returns human readable
	   * description.
	   *
	   * @param Number version
	   *        One of nsISSLStatus version constants.
	   * @return string
	   *         One of TLSv1, TLSv1.1, TLSv1.2 if @param version is valid,
	   *         Unknown otherwise.
	   */
	  formatSecurityProtocol: function NH_formatSecurityProtocol(version) {
	    switch (version) {
	      case Ci.nsISSLStatus.TLS_VERSION_1:
	        return "TLSv1";
	      case Ci.nsISSLStatus.TLS_VERSION_1_1:
	        return "TLSv1.1";
	      case Ci.nsISSLStatus.TLS_VERSION_1_2:
	        return "TLSv1.2";
	      default:
	        DevToolsUtils.reportException("NetworkHelper.formatSecurityProtocol",
	          "protocolVersion " + version + " is unknown.");
	        return "Unknown";
	    }
	  },
	
	  /**
	   * Takes the securityState bitfield and returns reasons for weak connection
	   * as an array of strings.
	   *
	   * @param Number state
	   *        nsITransportSecurityInfo.securityState.
	   *
	   * @return Array[String]
	   *         List of weakness reasons. A subset of { cipher } where
	   *         * cipher: The cipher suite is consireded to be weak (RC4).
	   */
	  getReasonsForWeakness: function NH_getReasonsForWeakness(state) {
	    const wpl = Ci.nsIWebProgressListener;
	
	    // If there's non-fatal security issues the request has STATE_IS_BROKEN
	    // flag set. See https://hg.mozilla.org/mozilla-central/file/44344099d119
	    // /security/manager/ssl/nsNSSCallbacks.cpp#l1233
	    let reasons = [];
	
	    if (state & wpl.STATE_IS_BROKEN) {
	      let isCipher = state & wpl.STATE_USES_WEAK_CRYPTO;
	
	      if (isCipher) {
	        reasons.push("cipher");
	      }
	
	      if (!isCipher) {
	        DevToolsUtils.reportException("NetworkHelper.getReasonsForWeakness",
	          "STATE_IS_BROKEN without a known reason. Full state was: " + state);
	      }
	    }
	
	    return reasons;
	  },
	
	  /**
	   * Parse a url's query string into its components
	   *
	   * @param string aQueryString
	   *        The query part of a url
	   * @return array
	   *         Array of query params {name, value}
	   */
	  parseQueryString: function(aQueryString) {
	    // Make sure there's at least one param available.
	    // Be careful here, params don't necessarily need to have values, so
	    // no need to verify the existence of a "=".
	    if (!aQueryString) {
	      return;
	    }
	
	    // Turn the params string into an array containing { name: value } tuples.
	    let paramsArray = aQueryString.replace(/^[?&]/, "").split("&").map(e => {
	      let param = e.split("=");
	      return {
	        name: param[0] ? NetworkHelper.convertToUnicode(unescape(param[0])) : "",
	        value: param[1] ? NetworkHelper.convertToUnicode(unescape(param[1])) : ""
	      }});
	
	    return paramsArray;
	  },
	
	  /**
	   * Helper for getting an nsIURL instance out of a string.
	   */
	  nsIURL: function(aUrl, aStore = gNSURLStore) {
	    if (aStore.has(aUrl)) {
	      return aStore.get(aUrl);
	    }
	
	    var uri = Services.io.newURI(aUrl).QueryInterface(Ci.nsIURL);
	    aStore.set(aUrl, uri);
	    return uri;
	  }
	};
	
	for (let prop of Object.getOwnPropertyNames(NetworkHelper)) {
	  exports[prop] = NetworkHelper[prop];
	}


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	const { Ci, Cc, Cr, CC } = __webpack_require__(35);
	const { Services } = __webpack_require__(28);
	const { dumpv } = __webpack_require__(42);
	const EventEmitter = __webpack_require__(34);
	const promise = __webpack_require__(40);
	
	const IOUtil = Cc("@mozilla.org/io-util;1").getService(Ci.nsIIOUtil);
	
	const ScriptableInputStream = CC("@mozilla.org/scriptableinputstream;1",
	          "nsIScriptableInputStream", "init");
	
	const BUFFER_SIZE = 0x8000;
	
	/**
	 * This helper function (and its companion object) are used by bulk senders and
	 * receivers to read and write data in and out of other streams.  Functions that
	 * make use of this tool are passed to callers when it is time to read or write
	 * bulk data.  It is highly recommended to use these copier functions instead of
	 * the stream directly because the copier enforces the agreed upon length.
	 * Since bulk mode reuses an existing stream, the sender and receiver must write
	 * and read exactly the agreed upon amount of data, or else the entire transport
	 * will be left in a invalid state.  Additionally, other methods of stream
	 * copying (such as NetUtil.asyncCopy) close the streams involved, which would
	 * terminate the debugging transport, and so it is avoided here.
	 *
	 * Overall, this *works*, but clearly the optimal solution would be able to just
	 * use the streams directly.  If it were possible to fully implement
	 * nsIInputStream / nsIOutputStream in JS, wrapper streams could be created to
	 * enforce the length and avoid closing, and consumers could use familiar stream
	 * utilities like NetUtil.asyncCopy.
	 *
	 * The function takes two async streams and copies a precise number of bytes
	 * from one to the other.  Copying begins immediately, but may complete at some
	 * future time depending on data size.  Use the returned promise to know when
	 * it's complete.
	 *
	 * @param input nsIAsyncInputStream
	 *        The stream to copy from.
	 * @param output nsIAsyncOutputStream
	 *        The stream to copy to.
	 * @param length Integer
	 *        The amount of data that needs to be copied.
	 * @return Promise
	 *         The promise is resolved when copying completes or rejected if any
	 *         (unexpected) errors occur.
	 */
	function copyStream(input, output, length) {
	  let copier = new StreamCopier(input, output, length);
	  return copier.copy();
	}
	
	function StreamCopier(input, output, length) {
	  EventEmitter.decorate(this);
	  this._id = StreamCopier._nextId++;
	  this.input = input;
	  // Save off the base output stream, since we know it's async as we've required
	  this.baseAsyncOutput = output;
	  if (IOUtil.outputStreamIsBuffered(output)) {
	    this.output = output;
	  } else {
	    this.output = Cc("@mozilla.org/network/buffered-output-stream;1")
	                  .createInstance(Ci.nsIBufferedOutputStream);
	    this.output.init(output, BUFFER_SIZE);
	  }
	  this._length = length;
	  this._amountLeft = length;
	  this._deferred = promise.defer();
	
	  this._copy = this._copy.bind(this);
	  this._flush = this._flush.bind(this);
	  this._destroy = this._destroy.bind(this);
	
	  // Copy promise's then method up to this object.
	  // Allows the copier to offer a promise interface for the simple succeed or
	  // fail scenarios, but also emit events (due to the EventEmitter) for other
	  // states, like progress.
	  this.then = this._deferred.promise.then.bind(this._deferred.promise);
	  this.then(this._destroy, this._destroy);
	
	  // Stream ready callback starts as |_copy|, but may switch to |_flush| at end
	  // if flushing would block the output stream.
	  this._streamReadyCallback = this._copy;
	}
	StreamCopier._nextId = 0;
	
	StreamCopier.prototype = {
	
	  copy: function() {
	    // Dispatch to the next tick so that it's possible to attach a progress
	    // event listener, even for extremely fast copies (like when testing).
	    Services.tm.currentThread.dispatch(() => {
	      try {
	        this._copy();
	      } catch (e) {
	        this._deferred.reject(e);
	      }
	    }, 0);
	    return this;
	  },
	
	  _copy: function() {
	    let bytesAvailable = this.input.available();
	    let amountToCopy = Math.min(bytesAvailable, this._amountLeft);
	    this._debug("Trying to copy: " + amountToCopy);
	
	    let bytesCopied;
	    try {
	      bytesCopied = this.output.writeFrom(this.input, amountToCopy);
	    } catch (e) {
	      if (e.result == Cr.NS_BASE_STREAM_WOULD_BLOCK) {
	        this._debug("Base stream would block, will retry");
	        this._debug("Waiting for output stream");
	        this.baseAsyncOutput.asyncWait(this, 0, 0, Services.tm.currentThread);
	        return;
	      } else {
	        throw e;
	      }
	    }
	
	    this._amountLeft -= bytesCopied;
	    this._debug("Copied: " + bytesCopied +
	                ", Left: " + this._amountLeft);
	    this._emitProgress();
	
	    if (this._amountLeft === 0) {
	      this._debug("Copy done!");
	      this._flush();
	      return;
	    }
	
	    this._debug("Waiting for input stream");
	    this.input.asyncWait(this, 0, 0, Services.tm.currentThread);
	  },
	
	  _emitProgress: function() {
	    this.emit("progress", {
	      bytesSent: this._length - this._amountLeft,
	      totalBytes: this._length
	    });
	  },
	
	  _flush: function() {
	    try {
	      this.output.flush();
	    } catch (e) {
	      if (e.result == Cr.NS_BASE_STREAM_WOULD_BLOCK ||
	          e.result == Cr.NS_ERROR_FAILURE) {
	        this._debug("Flush would block, will retry");
	        this._streamReadyCallback = this._flush;
	        this._debug("Waiting for output stream");
	        this.baseAsyncOutput.asyncWait(this, 0, 0, Services.tm.currentThread);
	        return;
	      } else {
	        throw e;
	      }
	    }
	    this._deferred.resolve();
	  },
	
	  _destroy: function() {
	    this._destroy = null;
	    this._copy = null;
	    this._flush = null;
	    this.input = null;
	    this.output = null;
	  },
	
	  // nsIInputStreamCallback
	  onInputStreamReady: function() {
	    this._streamReadyCallback();
	  },
	
	  // nsIOutputStreamCallback
	  onOutputStreamReady: function() {
	    this._streamReadyCallback();
	  },
	
	  _debug: function(msg) {
	    // Prefix logs with the copier ID, which makes logs much easier to
	    // understand when several copiers are running simultaneously
	    dumpv("Copier: " + this._id + " " + msg);
	  }
	
	};
	
	/**
	 * Read from a stream, one byte at a time, up to the next |delimiter|
	 * character, but stopping if we've read |count| without finding it.  Reading
	 * also terminates early if there are less than |count| bytes available on the
	 * stream.  In that case, we only read as many bytes as the stream currently has
	 * to offer.
	 * TODO: This implementation could be removed if bug 984651 is fixed, which
	 *       provides a native version of the same idea.
	 * @param stream nsIInputStream
	 *        The input stream to read from.
	 * @param delimiter string
	 *        The character we're trying to find.
	 * @param count integer
	 *        The max number of characters to read while searching.
	 * @return string
	 *         The data collected.  If the delimiter was found, this string will
	 *         end with it.
	 */
	function delimitedRead(stream, delimiter, count) {
	  dumpv("Starting delimited read for " + delimiter + " up to " +
	        count + " bytes");
	
	  let scriptableStream;
	  if (stream.readBytes) {
	    scriptableStream = stream;
	  } else {
	    scriptableStream = new ScriptableInputStream(stream);
	  }
	
	  let data = "";
	
	  // Don't exceed what's available on the stream
	  count = Math.min(count, stream.available());
	
	  if (count <= 0) {
	    return data;
	  }
	
	  let char;
	  while (char !== delimiter && count > 0) {
	    char = scriptableStream.readBytes(1);
	    count--;
	    data += char;
	  }
	
	  return data;
	}
	
	module.exports = {
	  copyStream: copyStream,
	  delimitedRead: delimitedRead
	};


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	"use strict";
	
	/**
	 * Packets contain read / write functionality for the different packet types
	 * supported by the debugging protocol, so that a transport can focus on
	 * delivery and queue management without worrying too much about the specific
	 * packet types.
	 *
	 * They are intended to be "one use only", so a new packet should be
	 * instantiated for each incoming or outgoing packet.
	 *
	 * A complete Packet type should expose at least the following:
	 *   * read(stream, scriptableStream)
	 *     Called when the input stream has data to read
	 *   * write(stream)
	 *     Called when the output stream is ready to write
	 *   * get done()
	 *     Returns true once the packet is done being read / written
	 *   * destroy()
	 *     Called to clean up at the end of use
	 */
	
	const { Cc, Ci, Cu } = __webpack_require__(35);
	const DevToolsUtils = __webpack_require__(42);
	const { dumpn, dumpv } = DevToolsUtils;
	const StreamUtils = __webpack_require__(48);
	const promise = __webpack_require__(40);
	
	/*DevToolsUtils.defineLazyGetter(this, "unicodeConverter", () => {
	  const unicodeConverter = Cc("@mozilla.org/intl/scriptableunicodeconverter")
	                           .createInstance(Ci.nsIScriptableUnicodeConverter);
	  unicodeConverter.charset = "UTF-8";
	  return unicodeConverter;
	});*/
	const utf8 = __webpack_require__(50);
	
	// The transport's previous check ensured the header length did not exceed 20
	// characters.  Here, we opt for the somewhat smaller, but still large limit of
	// 1 TiB.
	const PACKET_LENGTH_MAX = Math.pow(2, 40);
	
	/**
	 * A generic Packet processing object (extended by two subtypes below).
	 */
	function Packet(transport) {
	  this._transport = transport;
	  this._length = 0;
	}
	
	/**
	 * Attempt to initialize a new Packet based on the incoming packet header we've
	 * received so far.  We try each of the types in succession, trying JSON packets
	 * first since they are much more common.
	 * @param header string
	 *        The packet header string to attempt parsing.
	 * @param transport DebuggerTransport
	 *        The transport instance that will own the packet.
	 * @return Packet
	 *         The parsed packet of the matching type, or null if no types matched.
	 */
	Packet.fromHeader = function(header, transport) {
	  return JSONPacket.fromHeader(header, transport) ||
	         BulkPacket.fromHeader(header, transport);
	};
	
	Packet.prototype = {
	
	  get length() {
	    return this._length;
	  },
	
	  set length(length) {
	    if (length > PACKET_LENGTH_MAX) {
	      throw Error("Packet length " + length + " exceeds the max length of " +
	                  PACKET_LENGTH_MAX);
	    }
	    this._length = length;
	  },
	
	  destroy: function() {
	    this._transport = null;
	  }
	
	};
	
	exports.Packet = Packet;
	
	/**
	 * With a JSON packet (the typical packet type sent via the transport), data is
	 * transferred as a JSON packet serialized into a string, with the string length
	 * prepended to the packet, followed by a colon ([length]:[packet]). The
	 * contents of the JSON packet are specified in the Remote Debugging Protocol
	 * specification.
	 * @param transport DebuggerTransport
	 *        The transport instance that will own the packet.
	 */
	function JSONPacket(transport) {
	  Packet.call(this, transport);
	  this._data = "";
	  this._done = false;
	}
	
	/**
	 * Attempt to initialize a new JSONPacket based on the incoming packet header
	 * we've received so far.
	 * @param header string
	 *        The packet header string to attempt parsing.
	 * @param transport DebuggerTransport
	 *        The transport instance that will own the packet.
	 * @return JSONPacket
	 *         The parsed packet, or null if it's not a match.
	 */
	JSONPacket.fromHeader = function(header, transport) {
	  let match = this.HEADER_PATTERN.exec(header);
	
	  if (!match) {
	    return null;
	  }
	
	  dumpv("Header matches JSON packet");
	  let packet = new JSONPacket(transport);
	  packet.length = +match[1];
	  return packet;
	};
	
	JSONPacket.HEADER_PATTERN = /^(\d+):$/;
	
	JSONPacket.prototype = Object.create(Packet.prototype);
	
	Object.defineProperty(JSONPacket.prototype, "object", {
	  /**
	   * Gets the object (not the serialized string) being read or written.
	   */
	  get: function() { return this._object; },
	
	  /**
	   * Sets the object to be sent when write() is called.
	   */
	  set: function(object) {
	    this._object = object;
	    let data = JSON.stringify(object);
	    this._data = data;
	    this.length = this._data.length;
	  }
	});
	
	JSONPacket.prototype.read = function(stream, scriptableStream) {
	  dumpv("Reading JSON packet");
	
	  // Read in more packet data.
	  this._readData(stream, scriptableStream);
	
	  if (!this.done) {
	    // Don't have a complete packet yet.
	    return;
	  }
	
	  let json = this._data;
	  try {
	    json = utf8.decode(json);
	    this._object = JSON.parse(json);
	  } catch(e) {
	    let msg = "Error parsing incoming packet: " + json + " (" + e +
	              " - " + e.stack + ")";
	    if (console.error) {
	      console.error(msg);
	    }
	    dumpn(msg);
	    return;
	  }
	
	  this._transport._onJSONObjectReady(this._object);
	}
	
	JSONPacket.prototype._readData = function(stream, scriptableStream) {
	  if (!scriptableStream) {
	    scriptableStream = stream;
	  }
	  if (dumpv.wantVerbose) {
	    dumpv("Reading JSON data: _l: " + this.length + " dL: " +
	          this._data.length + " sA: " + stream.available());
	  }
	  let bytesToRead = Math.min(this.length - this._data.length,
	                             stream.available());
	  this._data += scriptableStream.readBytes(bytesToRead);
	  this._done = this._data.length === this.length;
	}
	
	JSONPacket.prototype.write = function(stream) {
	  dumpv("Writing JSON packet");
	
	  if (this._outgoing === undefined) {
	    // Format the serialized packet to a buffer
	    this._outgoing = this.length + ":" + this._data;
	  }
	
	  let written = stream.write(this._outgoing, this._outgoing.length);
	  this._outgoing = this._outgoing.slice(written);
	  this._done = !this._outgoing.length;
	}
	
	Object.defineProperty(JSONPacket.prototype, "done", {
	  get: function() { return this._done; }
	});
	
	JSONPacket.prototype.toString = function() {
	  return JSON.stringify(this._object, null, 2);
	}
	
	exports.JSONPacket = JSONPacket;
	
	/**
	 * With a bulk packet, data is transferred by temporarily handing over the
	 * transport's input or output stream to the application layer for writing data
	 * directly.  This can be much faster for large data sets, and avoids various
	 * stages of copies and data duplication inherent in the JSON packet type.  The
	 * bulk packet looks like:
	 *
	 * bulk [actor] [type] [length]:[data]
	 *
	 * The interpretation of the data portion depends on the kind of actor and the
	 * packet's type.  See the Remote Debugging Protocol Stream Transport spec for
	 * more details.
	 * @param transport DebuggerTransport
	 *        The transport instance that will own the packet.
	 */
	function BulkPacket(transport) {
	  Packet.call(this, transport);
	  this._done = false;
	  this._readyForWriting = promise.defer();
	}
	
	/**
	 * Attempt to initialize a new BulkPacket based on the incoming packet header
	 * we've received so far.
	 * @param header string
	 *        The packet header string to attempt parsing.
	 * @param transport DebuggerTransport
	 *        The transport instance that will own the packet.
	 * @return BulkPacket
	 *         The parsed packet, or null if it's not a match.
	 */
	BulkPacket.fromHeader = function(header, transport) {
	  let match = this.HEADER_PATTERN.exec(header);
	
	  if (!match) {
	    return null;
	  }
	
	  dumpv("Header matches bulk packet");
	  let packet = new BulkPacket(transport);
	  packet.header = {
	    actor: match[1],
	    type: match[2],
	    length: +match[3]
	  };
	  return packet;
	};
	
	BulkPacket.HEADER_PATTERN = /^bulk ([^: ]+) ([^: ]+) (\d+):$/;
	
	BulkPacket.prototype = Object.create(Packet.prototype);
	
	BulkPacket.prototype.read = function(stream) {
	  dumpv("Reading bulk packet, handing off input stream");
	
	  // Temporarily pause monitoring of the input stream
	  this._transport.pauseIncoming();
	
	  let deferred = promise.defer();
	
	  this._transport._onBulkReadReady({
	    actor: this.actor,
	    type: this.type,
	    length: this.length,
	    copyTo: (output) => {
	      dumpv("CT length: " + this.length);
	      let copying = StreamUtils.copyStream(stream, output, this.length);
	      deferred.resolve(copying);
	      return copying;
	    },
	    stream: stream,
	    done: deferred
	  });
	
	  // Await the result of reading from the stream
	  deferred.promise.then(() => {
	    dumpv("onReadDone called, ending bulk mode");
	    this._done = true;
	    this._transport.resumeIncoming();
	  }, this._transport.close);
	
	  // Ensure this is only done once
	  this.read = () => {
	    throw new Error("Tried to read() a BulkPacket's stream multiple times.");
	  };
	}
	
	BulkPacket.prototype.write = function(stream) {
	  dumpv("Writing bulk packet");
	
	  if (this._outgoingHeader === undefined) {
	    dumpv("Serializing bulk packet header");
	    // Format the serialized packet header to a buffer
	    this._outgoingHeader = "bulk " + this.actor + " " + this.type + " " +
	                           this.length + ":";
	  }
	
	  // Write the header, or whatever's left of it to write.
	  if (this._outgoingHeader.length) {
	    dumpv("Writing bulk packet header");
	    let written = stream.write(this._outgoingHeader,
	                               this._outgoingHeader.length);
	    this._outgoingHeader = this._outgoingHeader.slice(written);
	    return;
	  }
	
	  dumpv("Handing off output stream");
	
	  // Temporarily pause the monitoring of the output stream
	  this._transport.pauseOutgoing();
	
	  let deferred = promise.defer();
	
	  this._readyForWriting.resolve({
	    copyFrom: (input) => {
	      dumpv("CF length: " + this.length);
	      let copying = StreamUtils.copyStream(input, stream, this.length);
	      deferred.resolve(copying);
	      return copying;
	    },
	    stream: stream,
	    done: deferred
	  });
	
	  // Await the result of writing to the stream
	  deferred.promise.then(() => {
	    dumpv("onWriteDone called, ending bulk mode");
	    this._done = true;
	    this._transport.resumeOutgoing();
	  }, this._transport.close);
	
	  // Ensure this is only done once
	  this.write = () => {
	    throw new Error("Tried to write() a BulkPacket's stream multiple times.");
	  };
	}
	
	Object.defineProperty(BulkPacket.prototype, "streamReadyForWriting", {
	  get: function() {
	    return this._readyForWriting.promise;
	  }
	});
	
	Object.defineProperty(BulkPacket.prototype, "header", {
	  get: function() {
	    return {
	      actor: this.actor,
	      type: this.type,
	      length: this.length
	    };
	  },
	
	  set: function(header) {
	    this.actor = header.actor;
	    this.type = header.type;
	    this.length = header.length;
	  },
	});
	
	Object.defineProperty(BulkPacket.prototype, "done", {
	  get: function() { return this._done; },
	});
	
	
	BulkPacket.prototype.toString = function() {
	  return "Bulk: " + JSON.stringify(this.header, null, 2);
	}
	
	exports.BulkPacket = BulkPacket;
	
	/**
	 * RawPacket is used to test the transport's error handling of malformed
	 * packets, by writing data directly onto the stream.
	 * @param transport DebuggerTransport
	 *        The transport instance that will own the packet.
	 * @param data string
	 *        The raw string to send out onto the stream.
	 */
	function RawPacket(transport, data) {
	  Packet.call(this, transport);
	  this._data = data;
	  this.length = data.length;
	  this._done = false;
	}
	
	RawPacket.prototype = Object.create(Packet.prototype);
	
	RawPacket.prototype.read = function(stream) {
	  // This hasn't yet been needed for testing.
	  throw Error("Not implmented.");
	}
	
	RawPacket.prototype.write = function(stream) {
	  let written = stream.write(this._data, this._data.length);
	  this._data = this._data.slice(written);
	  this._done = !this._data.length;
	}
	
	Object.defineProperty(RawPacket.prototype, "done", {
	  get: function() { return this._done; }
	});
	
	exports.RawPacket = RawPacket;


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/utf8js v2.0.0 by @mathias */
	;(function(root) {
	
		// Detect free variables `exports`
		var freeExports = typeof exports == 'object' && exports;
	
		// Detect free variable `module`
		var freeModule = typeof module == 'object' && module &&
			module.exports == freeExports && module;
	
		// Detect free variable `global`, from Node.js or Browserified code,
		// and use it as `root`
		var freeGlobal = typeof global == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
			root = freeGlobal;
		}
	
		/*--------------------------------------------------------------------------*/
	
		var stringFromCharCode = String.fromCharCode;
	
		// Taken from https://mths.be/punycode
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			var value;
			var extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		// Taken from https://mths.be/punycode
		function ucs2encode(array) {
			var length = array.length;
			var index = -1;
			var value;
			var output = '';
			while (++index < length) {
				value = array[index];
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
			}
			return output;
		}
	
		function checkScalarValue(codePoint) {
			if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
				throw Error(
					'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
					' is not a scalar value'
				);
			}
		}
		/*--------------------------------------------------------------------------*/
	
		function createByte(codePoint, shift) {
			return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
		}
	
		function encodeCodePoint(codePoint) {
			if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
				return stringFromCharCode(codePoint);
			}
			var symbol = '';
			if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
				symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
			}
			else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
				checkScalarValue(codePoint);
				symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
				symbol += createByte(codePoint, 6);
			}
			else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
				symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
				symbol += createByte(codePoint, 12);
				symbol += createByte(codePoint, 6);
			}
			symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
			return symbol;
		}
	
		function utf8encode(string) {
			var codePoints = ucs2decode(string);
			var length = codePoints.length;
			var index = -1;
			var codePoint;
			var byteString = '';
			while (++index < length) {
				codePoint = codePoints[index];
				byteString += encodeCodePoint(codePoint);
			}
			return byteString;
		}
	
		/*--------------------------------------------------------------------------*/
	
		function readContinuationByte() {
			if (byteIndex >= byteCount) {
				throw Error('Invalid byte index');
			}
	
			var continuationByte = byteArray[byteIndex] & 0xFF;
			byteIndex++;
	
			if ((continuationByte & 0xC0) == 0x80) {
				return continuationByte & 0x3F;
			}
	
			// If we end up here, it’s not a continuation byte
			throw Error('Invalid continuation byte');
		}
	
		function decodeSymbol() {
			var byte1;
			var byte2;
			var byte3;
			var byte4;
			var codePoint;
	
			if (byteIndex > byteCount) {
				throw Error('Invalid byte index');
			}
	
			if (byteIndex == byteCount) {
				return false;
			}
	
			// Read first byte
			byte1 = byteArray[byteIndex] & 0xFF;
			byteIndex++;
	
			// 1-byte sequence (no continuation bytes)
			if ((byte1 & 0x80) == 0) {
				return byte1;
			}
	
			// 2-byte sequence
			if ((byte1 & 0xE0) == 0xC0) {
				var byte2 = readContinuationByte();
				codePoint = ((byte1 & 0x1F) << 6) | byte2;
				if (codePoint >= 0x80) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}
	
			// 3-byte sequence (may include unpaired surrogates)
			if ((byte1 & 0xF0) == 0xE0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
				if (codePoint >= 0x0800) {
					checkScalarValue(codePoint);
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}
	
			// 4-byte sequence
			if ((byte1 & 0xF8) == 0xF0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				byte4 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
					(byte3 << 0x06) | byte4;
				if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
					return codePoint;
				}
			}
	
			throw Error('Invalid UTF-8 detected');
		}
	
		var byteArray;
		var byteCount;
		var byteIndex;
		function utf8decode(byteString) {
			byteArray = ucs2decode(byteString);
			byteCount = byteArray.length;
			byteIndex = 0;
			var codePoints = [];
			var tmp;
			while ((tmp = decodeSymbol()) !== false) {
				codePoints.push(tmp);
			}
			return ucs2encode(codePoints);
		}
	
		/*--------------------------------------------------------------------------*/
	
		var utf8 = {
			'version': '2.0.0',
			'encode': utf8encode,
			'decode': utf8decode
		};
	
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return utf8;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}	else if (freeExports && !freeExports.nodeType) {
			if (freeModule) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = utf8;
			} else { // in Narwhal or RingoJS v0.7.0-
				var object = {};
				var hasOwnProperty = object.hasOwnProperty;
				for (var key in utf8) {
					hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.utf8 = utf8;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(51)(module), (function() { return this; }())))

/***/ },
/* 51 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/utf8js v2.0.0 by @mathias */
	;(function(root) {
	
		// Detect free variables `exports`
		var freeExports = typeof exports == 'object' && exports;
	
		// Detect free variable `module`
		var freeModule = typeof module == 'object' && module &&
			module.exports == freeExports && module;
	
		// Detect free variable `global`, from Node.js or Browserified code,
		// and use it as `root`
		var freeGlobal = typeof global == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
			root = freeGlobal;
		}
	
		/*--------------------------------------------------------------------------*/
	
		var stringFromCharCode = String.fromCharCode;
	
		// Taken from https://mths.be/punycode
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			var value;
			var extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		// Taken from https://mths.be/punycode
		function ucs2encode(array) {
			var length = array.length;
			var index = -1;
			var value;
			var output = '';
			while (++index < length) {
				value = array[index];
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
			}
			return output;
		}
	
		function checkScalarValue(codePoint) {
			if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
				throw Error(
					'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
					' is not a scalar value'
				);
			}
		}
		/*--------------------------------------------------------------------------*/
	
		function createByte(codePoint, shift) {
			return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
		}
	
		function encodeCodePoint(codePoint) {
			if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
				return stringFromCharCode(codePoint);
			}
			var symbol = '';
			if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
				symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
			}
			else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
				checkScalarValue(codePoint);
				symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
				symbol += createByte(codePoint, 6);
			}
			else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
				symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
				symbol += createByte(codePoint, 12);
				symbol += createByte(codePoint, 6);
			}
			symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
			return symbol;
		}
	
		function utf8encode(string) {
			var codePoints = ucs2decode(string);
			var length = codePoints.length;
			var index = -1;
			var codePoint;
			var byteString = '';
			while (++index < length) {
				codePoint = codePoints[index];
				byteString += encodeCodePoint(codePoint);
			}
			return byteString;
		}
	
		/*--------------------------------------------------------------------------*/
	
		function readContinuationByte() {
			if (byteIndex >= byteCount) {
				throw Error('Invalid byte index');
			}
	
			var continuationByte = byteArray[byteIndex] & 0xFF;
			byteIndex++;
	
			if ((continuationByte & 0xC0) == 0x80) {
				return continuationByte & 0x3F;
			}
	
			// If we end up here, it’s not a continuation byte
			throw Error('Invalid continuation byte');
		}
	
		function decodeSymbol() {
			var byte1;
			var byte2;
			var byte3;
			var byte4;
			var codePoint;
	
			if (byteIndex > byteCount) {
				throw Error('Invalid byte index');
			}
	
			if (byteIndex == byteCount) {
				return false;
			}
	
			// Read first byte
			byte1 = byteArray[byteIndex] & 0xFF;
			byteIndex++;
	
			// 1-byte sequence (no continuation bytes)
			if ((byte1 & 0x80) == 0) {
				return byte1;
			}
	
			// 2-byte sequence
			if ((byte1 & 0xE0) == 0xC0) {
				var byte2 = readContinuationByte();
				codePoint = ((byte1 & 0x1F) << 6) | byte2;
				if (codePoint >= 0x80) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}
	
			// 3-byte sequence (may include unpaired surrogates)
			if ((byte1 & 0xF0) == 0xE0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
				if (codePoint >= 0x0800) {
					checkScalarValue(codePoint);
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}
	
			// 4-byte sequence
			if ((byte1 & 0xF8) == 0xF0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				byte4 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
					(byte3 << 0x06) | byte4;
				if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
					return codePoint;
				}
			}
	
			throw Error('Invalid UTF-8 detected');
		}
	
		var byteArray;
		var byteCount;
		var byteIndex;
		function utf8decode(byteString) {
			byteArray = ucs2decode(byteString);
			byteCount = byteArray.length;
			byteIndex = 0;
			var codePoints = [];
			var tmp;
			while ((tmp = decodeSymbol()) !== false) {
				codePoints.push(tmp);
			}
			return ucs2encode(codePoints);
		}
	
		/*--------------------------------------------------------------------------*/
	
		var utf8 = {
			'version': '2.0.0',
			'encode': utf8encode,
			'decode': utf8decode
		};
	
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return utf8;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}	else if (freeExports && !freeExports.nodeType) {
			if (freeModule) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = utf8;
			} else { // in Narwhal or RingoJS v0.7.0-
				var object = {};
				var hasOwnProperty = object.hasOwnProperty;
				for (var key in utf8) {
					hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.utf8 = utf8;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(51)(module), (function() { return this; }())))

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	const { Ci, Cu, components } = __webpack_require__(35);
	const { Services } = __webpack_require__(28);
	const DevToolsUtils = __webpack_require__(42);
	
	// WARNING I swapped the sync one for the async one here
	// const promise = require("resource://devtools/shared/deprecated-sync-thenables.js", {}).Promise;
	const promise = __webpack_require__(40);
	
	const events = __webpack_require__(54);
	const { WebConsoleClient } = __webpack_require__(56);
	/* const { DebuggerSocket } = require("../shared/security/socket");*/
	/* const Authentication = require("../shared/security/auth");*/
	
	const noop = () => {};
	
	/**
	 * TODO: Get rid of this API in favor of EventTarget (bug 1042642)
	 *
	 * Add simple event notification to a prototype object. Any object that has
	 * some use for event notifications or the observer pattern in general can be
	 * augmented with the necessary facilities by passing its prototype to this
	 * function.
	 *
	 * @param aProto object
	 *        The prototype object that will be modified.
	 */
	function eventSource(aProto) {
	  /**
	   * Add a listener to the event source for a given event.
	   *
	   * @param aName string
	   *        The event to listen for.
	   * @param aListener function
	   *        Called when the event is fired. If the same listener
	   *        is added more than once, it will be called once per
	   *        addListener call.
	   */
	  aProto.addListener = function(aName, aListener) {
	    if (typeof aListener != "function") {
	      throw TypeError("Listeners must be functions.");
	    }
	
	    if (!this._listeners) {
	      this._listeners = {};
	    }
	
	    this._getListeners(aName).push(aListener);
	  };
	
	  /**
	   * Add a listener to the event source for a given event. The
	   * listener will be removed after it is called for the first time.
	   *
	   * @param aName string
	   *        The event to listen for.
	   * @param aListener function
	   *        Called when the event is fired.
	   */
	  aProto.addOneTimeListener = function(aName, aListener) {
	    let l = (...args) => {
	      this.removeListener(aName, l);
	      aListener.apply(null, args);
	    };
	    this.addListener(aName, l);
	  };
	
	  /**
	   * Remove a listener from the event source previously added with
	   * addListener().
	   *
	   * @param aName string
	   *        The event name used during addListener to add the listener.
	   * @param aListener function
	   *        The callback to remove. If addListener was called multiple
	   *        times, all instances will be removed.
	   */
	  aProto.removeListener = function(aName, aListener) {
	    if (!this._listeners || (aListener && !this._listeners[aName])) {
	      return;
	    }
	
	    if (!aListener) {
	      this._listeners[aName] = [];
	    }
	    else {
	      this._listeners[aName] =
	        this._listeners[aName].filter(function(l) { return l != aListener; });
	    }
	  };
	
	  /**
	   * Returns the listeners for the specified event name. If none are defined it
	   * initializes an empty list and returns that.
	   *
	   * @param aName string
	   *        The event name.
	   */
	  aProto._getListeners = function(aName) {
	    if (aName in this._listeners) {
	      return this._listeners[aName];
	    }
	    this._listeners[aName] = [];
	    return this._listeners[aName];
	  };
	
	  /**
	   * Notify listeners of an event.
	   *
	   * @param aName string
	   *        The event to fire.
	   * @param arguments
	   *        All arguments will be passed along to the listeners,
	   *        including the name argument.
	   */
	  aProto.emit = function() {
	    if (!this._listeners) {
	      return;
	    }
	
	    let name = arguments[0];
	    let listeners = this._getListeners(name).slice(0);
	
	    for (let listener of listeners) {
	      try {
	        listener.apply(null, arguments);
	      } catch (e) {
	        // Prevent a bad listener from interfering with the others.
	        DevToolsUtils.reportException("notify event '" + name + "'", e);
	      }
	    }
	  };
	}
	
	/**
	 * Set of protocol messages that affect thread state, and the
	 * state the actor is in after each message.
	 */
	const ThreadStateTypes = {
	  "paused": "paused",
	  "resumed": "attached",
	  "detached": "detached"
	};
	
	/**
	 * Set of protocol messages that are sent by the server without a prior request
	 * by the client.
	 */
	const UnsolicitedNotifications = {
	  "consoleAPICall": "consoleAPICall",
	  "eventNotification": "eventNotification",
	  "fileActivity": "fileActivity",
	  "lastPrivateContextExited": "lastPrivateContextExited",
	  "logMessage": "logMessage",
	  "networkEvent": "networkEvent",
	  "networkEventUpdate": "networkEventUpdate",
	  "newGlobal": "newGlobal",
	  "newScript": "newScript",
	  "tabDetached": "tabDetached",
	  "tabListChanged": "tabListChanged",
	  "reflowActivity": "reflowActivity",
	  "addonListChanged": "addonListChanged",
	  "workerListChanged": "workerListChanged",
	  "serviceWorkerRegistrationListChanged": "serviceWorkerRegistrationList",
	  "tabNavigated": "tabNavigated",
	  "frameUpdate": "frameUpdate",
	  "pageError": "pageError",
	  "documentLoad": "documentLoad",
	  "enteredFrame": "enteredFrame",
	  "exitedFrame": "exitedFrame",
	  "appOpen": "appOpen",
	  "appClose": "appClose",
	  "appInstall": "appInstall",
	  "appUninstall": "appUninstall",
	  "evaluationResult": "evaluationResult",
	  "newSource": "newSource",
	  "updatedSource": "updatedSource",
	};
	
	/**
	 * Set of pause types that are sent by the server and not as an immediate
	 * response to a client request.
	 */
	const UnsolicitedPauses = {
	  "resumeLimit": "resumeLimit",
	  "debuggerStatement": "debuggerStatement",
	  "breakpoint": "breakpoint",
	  "DOMEvent": "DOMEvent",
	  "watchpoint": "watchpoint",
	  "exception": "exception"
	};
	
	/**
	 * Creates a client for the remote debugging protocol server. This client
	 * provides the means to communicate with the server and exchange the messages
	 * required by the protocol in a traditional JavaScript API.
	 */
	const DebuggerClient = exports.DebuggerClient = function(aTransport)
	{
	  this._transport = aTransport;
	  this._transport.hooks = this;
	
	  // Map actor ID to client instance for each actor type.
	  this._clients = new Map();
	
	  this._pendingRequests = new Map();
	  this._activeRequests = new Map();
	  this._eventsEnabled = true;
	
	  this.traits = {};
	
	  this.request = this.request.bind(this);
	  this.localTransport = this._transport.onOutputStreamReady === undefined;
	
	  /*
	   * As the first thing on the connection, expect a greeting packet from
	   * the connection's root actor.
	   */
	  this.mainRoot = null;
	  this.expectReply("root", (aPacket) => {
	    this.mainRoot = new RootClient(this, aPacket);
	    this.emit("connected", aPacket.applicationType, aPacket.traits);
	  });
	};
	
	/**
	 * A declarative helper for defining methods that send requests to the server.
	 *
	 * @param aPacketSkeleton
	 *        The form of the packet to send. Can specify fields to be filled from
	 *        the parameters by using the |args| function.
	 * @param telemetry
	 *        The unique suffix of the telemetry histogram id.
	 * @param before
	 *        The function to call before sending the packet. Is passed the packet,
	 *        and the return value is used as the new packet. The |this| context is
	 *        the instance of the client object we are defining a method for.
	 * @param after
	 *        The function to call after the response is received. It is passed the
	 *        response, and the return value is considered the new response that
	 *        will be passed to the callback. The |this| context is the instance of
	 *        the client object we are defining a method for.
	 * @return Request
	 *         The `Request` object that is a Promise object and resolves once
	 *         we receive the response. (See request method for more details)
	 */
	DebuggerClient.requester = function(aPacketSkeleton, config = {}) {
	  let { telemetry, before, after } = config;
	  return DevToolsUtils.makeInfallible(function(...args) {
	    let histogram, startTime;
	    if (telemetry) {
	      let transportType = this._transport.onOutputStreamReady === undefined
	        ? "LOCAL_"
	        : "REMOTE_";
	      let histogramId = "DEVTOOLS_DEBUGGER_RDP_"
	        + transportType + telemetry + "_MS";
	      histogram = Services.telemetry.getHistogramById(histogramId);
	      startTime = +new Date();
	    }
	    let outgoingPacket = {
	      to: aPacketSkeleton.to || this.actor
	    };
	
	    let maxPosition = -1;
	    for (let k of Object.keys(aPacketSkeleton)) {
	      if (aPacketSkeleton[k] instanceof DebuggerClient.Argument) {
	        let { position } = aPacketSkeleton[k];
	        outgoingPacket[k] = aPacketSkeleton[k].getArgument(args);
	        maxPosition = Math.max(position, maxPosition);
	      } else {
	        outgoingPacket[k] = aPacketSkeleton[k];
	      }
	    }
	
	    if (before) {
	      outgoingPacket = before.call(this, outgoingPacket);
	    }
	
	    return this.request(outgoingPacket, DevToolsUtils.makeInfallible((aResponse) => {
	      if (after) {
	        let { from } = aResponse;
	        aResponse = after.call(this, aResponse);
	        if (!aResponse.from) {
	          aResponse.from = from;
	        }
	      }
	
	      // The callback is always the last parameter.
	      let thisCallback = args[maxPosition + 1];
	      if (thisCallback) {
	        thisCallback(aResponse);
	      }
	
	      if (histogram) {
	        histogram.add(+new Date() - startTime);
	      }
	    }, "DebuggerClient.requester request callback"));
	  }, "DebuggerClient.requester");
	};
	
	function args(aPos) {
	  return new DebuggerClient.Argument(aPos);
	}
	
	DebuggerClient.Argument = function(aPosition) {
	  this.position = aPosition;
	};
	
	DebuggerClient.Argument.prototype.getArgument = function(aParams) {
	  if (!(this.position in aParams)) {
	    throw new Error("Bad index into params: " + this.position);
	  }
	  return aParams[this.position];
	};
	
	// Expose these to save callers the trouble of importing DebuggerSocket
	DebuggerClient.socketConnect = function(options) {
	  // Defined here instead of just copying the function to allow lazy-load
	  return DebuggerSocket.connect(options);
	};
	DevToolsUtils.defineLazyGetter(DebuggerClient, "Authenticators", () => {
	  return Authentication.Authenticators;
	});
	DevToolsUtils.defineLazyGetter(DebuggerClient, "AuthenticationResult", () => {
	  return Authentication.AuthenticationResult;
	});
	
	DebuggerClient.prototype = {
	  /**
	   * Connect to the server and start exchanging protocol messages.
	   *
	   * @param aOnConnected function
	   *        If specified, will be called when the greeting packet is
	   *        received from the debugging server.
	   *
	   * @return Promise
	   *         Resolves once connected with an array whose first element
	   *         is the application type, by default "browser", and the second
	   *         element is the traits object (help figure out the features
	   *         and behaviors of the server we connect to. See RootActor).
	   */
	  connect: function(aOnConnected) {
	    return Promise.race([
	      new Promise((resolve, reject) => {
	        this.emit("connect");
	
	        // Also emit the event on the |DebuggerClient| object (not on the instance),
	        // so it's possible to track all instances.
	        events.emit(DebuggerClient, "connect", this);
	
	        this.addOneTimeListener("connected", (aName, aApplicationType, aTraits) => {
	          this.traits = aTraits;
	          if (aOnConnected) {
	            aOnConnected(aApplicationType, aTraits);
	          }
	          resolve([aApplicationType, aTraits]);
	        });
	
	        this._transport.ready();
	      }),
	      new Promise((resolve, reject) => {
	        setTimeout(() => reject(new Error("Connect timeout error")), 6000);
	      })
	    ]);
	  },
	
	  /**
	   * Shut down communication with the debugging server.
	   *
	   * @param aOnClosed function
	   *        If specified, will be called when the debugging connection
	   *        has been closed.
	   */
	  close: function(aOnClosed) {
	    // Disable detach event notifications, because event handlers will be in a
	    // cleared scope by the time they run.
	    this._eventsEnabled = false;
	
	    let cleanup = () => {
	      this._transport.close();
	      this._transport = null;
	    };
	
	    // If the connection is already closed,
	    // there is no need to detach client
	    // as we won't be able to send any message.
	    if (this._closed) {
	      cleanup();
	      if (aOnClosed) {
	        aOnClosed();
	      }
	      return;
	    }
	
	    if (aOnClosed) {
	      this.addOneTimeListener("closed", function(aEvent) {
	        aOnClosed();
	      });
	    }
	
	    // Call each client's `detach` method by calling
	    // lastly registered ones first to give a chance
	    // to detach child clients first.
	    let clients = [...this._clients.values()];
	    this._clients.clear();
	    const detachClients = () => {
	      let client = clients.pop();
	      if (!client) {
	        // All clients detached.
	        cleanup();
	        return;
	      }
	      if (client.detach) {
	        client.detach(detachClients);
	        return;
	      }
	      detachClients();
	    };
	    detachClients();
	  },
	
	  /*
	   * This function exists only to preserve DebuggerClient's interface;
	   * new code should say 'client.mainRoot.listTabs()'.
	   */
	  listTabs: function(aOnResponse) { return this.mainRoot.listTabs(aOnResponse); },
	
	  /*
	   * This function exists only to preserve DebuggerClient's interface;
	   * new code should say 'client.mainRoot.listAddons()'.
	   */
	  listAddons: function(aOnResponse) { return this.mainRoot.listAddons(aOnResponse); },
	
	  getTab: function(aFilter) { return this.mainRoot.getTab(aFilter); },
	
	  /**
	   * Attach to a tab actor.
	   *
	   * @param string aTabActor
	   *        The actor ID for the tab to attach.
	   * @param function aOnResponse
	   *        Called with the response packet and a TabClient
	   *        (which will be undefined on error).
	   */
	  attachTab: function(aTabActor, aOnResponse = noop) {
	    if (this._clients.has(aTabActor)) {
	      let cachedTab = this._clients.get(aTabActor);
	      let cachedResponse = {
	        cacheDisabled: cachedTab.cacheDisabled,
	        javascriptEnabled: cachedTab.javascriptEnabled,
	        traits: cachedTab.traits,
	      };
	      DevToolsUtils.executeSoon(() => aOnResponse(cachedResponse, cachedTab));
	      return promise.resolve([cachedResponse, cachedTab]);
	    }
	
	    let packet = {
	      to: aTabActor,
	      type: "attach"
	    };
	    return this.request(packet).then(aResponse => {
	      let tabClient;
	      if (!aResponse.error) {
	        tabClient = new TabClient(this, aResponse);
	        this.registerClient(tabClient);
	      }
	      aOnResponse(aResponse, tabClient);
	      return [aResponse, tabClient];
	    });
	  },
	
	  attachWorker: function DC_attachWorker(aWorkerActor, aOnResponse = noop) {
	    let workerClient = this._clients.get(aWorkerActor);
	    if (workerClient !== undefined) {
	      let response = {
	        from: workerClient.actor,
	        type: "attached",
	        url: workerClient.url
	      };
	      DevToolsUtils.executeSoon(() => aOnResponse(response, workerClient));
	      return promise.resolve([response, workerClient]);
	    }
	
	    return this.request({ to: aWorkerActor, type: "attach" }).then(aResponse => {
	      if (aResponse.error) {
	        aOnResponse(aResponse, null);
	        return [aResponse, null];
	      }
	
	      let workerClient = new WorkerClient(this, aResponse);
	      this.registerClient(workerClient);
	      aOnResponse(aResponse, workerClient);
	      return [aResponse, workerClient];
	    });
	  },
	
	  /**
	   * Attach to an addon actor.
	   *
	   * @param string aAddonActor
	   *        The actor ID for the addon to attach.
	   * @param function aOnResponse
	   *        Called with the response packet and a AddonClient
	   *        (which will be undefined on error).
	   */
	  attachAddon: function DC_attachAddon(aAddonActor, aOnResponse = noop) {
	    let packet = {
	      to: aAddonActor,
	      type: "attach"
	    };
	    return this.request(packet).then(aResponse => {
	      let addonClient;
	      if (!aResponse.error) {
	        addonClient = new AddonClient(this, aAddonActor);
	        this.registerClient(addonClient);
	        this.activeAddon = addonClient;
	      }
	      aOnResponse(aResponse, addonClient);
	      return [aResponse, addonClient];
	    });
	  },
	
	  /**
	   * Attach to a Web Console actor.
	   *
	   * @param string aConsoleActor
	   *        The ID for the console actor to attach to.
	   * @param array aListeners
	   *        The console listeners you want to start.
	   * @param function aOnResponse
	   *        Called with the response packet and a WebConsoleClient
	   *        instance (which will be undefined on error).
	   */
	  attachConsole:
	  function(aConsoleActor, aListeners, aOnResponse = noop) {
	    let packet = {
	      to: aConsoleActor,
	      type: "startListeners",
	      listeners: aListeners,
	    };
	
	    return this.request(packet).then(aResponse => {
	      let consoleClient;
	      if (!aResponse.error) {
	        if (this._clients.has(aConsoleActor)) {
	          consoleClient = this._clients.get(aConsoleActor);
	        } else {
	          consoleClient = new WebConsoleClient(this, aResponse);
	          this.registerClient(consoleClient);
	        }
	      }
	      aOnResponse(aResponse, consoleClient);
	      return [aResponse, consoleClient];
	    });
	  },
	
	  /**
	   * Attach to a global-scoped thread actor for chrome debugging.
	   *
	   * @param string aThreadActor
	   *        The actor ID for the thread to attach.
	   * @param function aOnResponse
	   *        Called with the response packet and a ThreadClient
	   *        (which will be undefined on error).
	   * @param object aOptions
	   *        Configuration options.
	   *        - useSourceMaps: whether to use source maps or not.
	   */
	  attachThread: function(aThreadActor, aOnResponse = noop, aOptions = {}) {
	    if (this._clients.has(aThreadActor)) {
	      let client = this._clients.get(aThreadActor);
	      DevToolsUtils.executeSoon(() => aOnResponse({}, client));
	      return promise.resolve([{}, client]);
	    }
	
	    let packet = {
	      to: aThreadActor,
	      type: "attach",
	      options: aOptions
	    };
	    return this.request(packet).then(aResponse => {
	      if (!aResponse.error) {
	        var threadClient = new ThreadClient(this, aThreadActor);
	        this.registerClient(threadClient);
	      }
	      aOnResponse(aResponse, threadClient);
	      return [aResponse, threadClient];
	    });
	  },
	
	  /**
	   * Attach to a trace actor.
	   *
	   * @param string aTraceActor
	   *        The actor ID for the tracer to attach.
	   * @param function aOnResponse
	   *        Called with the response packet and a TraceClient
	   *        (which will be undefined on error).
	   */
	  attachTracer: function(aTraceActor, aOnResponse = noop) {
	    if (this._clients.has(aTraceActor)) {
	      let client = this._clients.get(aTraceActor);
	      DevToolsUtils.executeSoon(() => aOnResponse({}, client));
	      return promise.resolve([{}, client]);
	    }
	
	    let packet = {
	      to: aTraceActor,
	      type: "attach"
	    };
	    return this.request(packet).then(aResponse => {
	      if (!aResponse.error) {
	        var traceClient = new TraceClient(this, aTraceActor);
	        this.registerClient(traceClient);
	      }
	      aOnResponse(aResponse, traceClient);
	      return [aResponse, traceClient];
	    });
	  },
	
	  /**
	   * Fetch the ChromeActor for the main process or ChildProcessActor for a
	   * a given child process ID.
	   *
	   * @param number aId
	   *        The ID for the process to attach (returned by `listProcesses`).
	   *        Connected to the main process if omitted, or is 0.
	   */
	  getProcess: function(aId) {
	    let packet = {
	      to: "root",
	      type: "getProcess"
	    };
	    if (typeof (aId) == "number") {
	      packet.id = aId;
	    }
	    return this.request(packet);
	  },
	
	  /**
	   * Release an object actor.
	   *
	   * @param string aActor
	   *        The actor ID to send the request to.
	   * @param aOnResponse function
	   *        If specified, will be called with the response packet when
	   *        debugging server responds.
	   */
	  release: DebuggerClient.requester({
	    to: args(0),
	    type: "release"
	  }, {
	    telemetry: "RELEASE"
	  }),
	
	  /**
	   * Send a request to the debugging server.
	   *
	   * @param aRequest object
	   *        A JSON packet to send to the debugging server.
	   * @param aOnResponse function
	   *        If specified, will be called with the JSON response packet when
	   *        debugging server responds.
	   * @return Request
	   *         This object emits a number of events to allow you to respond to
	   *         different parts of the request lifecycle.
	   *         It is also a Promise object, with a `then` method, that is resolved
	   *         whenever a JSON or a Bulk response is received; and is rejected
	   *         if the response is an error.
	   *         Note: This return value can be ignored if you are using JSON alone,
	   *         because the callback provided in |aOnResponse| will be bound to the
	   *         "json-reply" event automatically.
	   *
	   *         Events emitted:
	   *         * json-reply: The server replied with a JSON packet, which is
	   *           passed as event data.
	   *         * bulk-reply: The server replied with bulk data, which you can read
	   *           using the event data object containing:
	   *           * actor:  Name of actor that received the packet
	   *           * type:   Name of actor's method that was called on receipt
	   *           * length: Size of the data to be read
	   *           * stream: This input stream should only be used directly if you
	   *                     can ensure that you will read exactly |length| bytes
	   *                     and will not close the stream when reading is complete
	   *           * done:   If you use the stream directly (instead of |copyTo|
	   *                     below), you must signal completion by resolving /
	   *                     rejecting this deferred.  If it's rejected, the
	   *                     transport will be closed.  If an Error is supplied as a
	   *                     rejection value, it will be logged via |dumpn|.  If you
	   *                     do use |copyTo|, resolving is taken care of for you
	   *                     when copying completes.
	   *           * copyTo: A helper function for getting your data out of the
	   *                     stream that meets the stream handling requirements
	   *                     above, and has the following signature:
	   *             @param  output nsIAsyncOutputStream
	   *                     The stream to copy to.
	   *             @return Promise
	   *                     The promise is resolved when copying completes or
	   *                     rejected if any (unexpected) errors occur.
	   *                     This object also emits "progress" events for each chunk
	   *                     that is copied.  See stream-utils.js.
	   */
	  request: function(aRequest, aOnResponse) {
	    if (!this.mainRoot) {
	      throw Error("Have not yet received a hello packet from the server.");
	    }
	    let type = aRequest.type || "";
	    if (!aRequest.to) {
	      throw Error("'" + type + "' request packet has no destination.");
	    }
	    if (this._closed) {
	      let msg = "'" + type + "' request packet to " +
	                "'" + aRequest.to + "' " +
	               "can't be sent as the connection is closed.";
	      let resp = { error: "connectionClosed", message: msg };
	      if (aOnResponse) {
	        aOnResponse(resp);
	      }
	      return promise.reject(resp);
	    }
	
	    let request = new Request(aRequest);
	    request.format = "json";
	    request.stack = components.stack;
	    if (aOnResponse) {
	      request.on("json-reply", aOnResponse);
	    }
	
	    this._sendOrQueueRequest(request);
	
	    // Implement a Promise like API on the returned object
	    // that resolves/rejects on request response
	    let deferred = promise.defer();
	    function listenerJson(resp) {
	      request.off("json-reply", listenerJson);
	      request.off("bulk-reply", listenerBulk);
	      if (resp.error) {
	        deferred.reject(resp);
	      } else {
	        deferred.resolve(resp);
	      }
	    }
	    function listenerBulk(resp) {
	      request.off("json-reply", listenerJson);
	      request.off("bulk-reply", listenerBulk);
	      deferred.resolve(resp);
	    }
	    request.on("json-reply", listenerJson);
	    request.on("bulk-reply", listenerBulk);
	    request.then = deferred.promise.then.bind(deferred.promise);
	
	    return request;
	  },
	
	  /**
	   * Transmit streaming data via a bulk request.
	   *
	   * This method initiates the bulk send process by queuing up the header data.
	   * The caller receives eventual access to a stream for writing.
	   *
	   * Since this opens up more options for how the server might respond (it could
	   * send back either JSON or bulk data), and the returned Request object emits
	   * events for different stages of the request process that you may want to
	   * react to.
	   *
	   * @param request Object
	   *        This is modeled after the format of JSON packets above, but does not
	   *        actually contain the data, but is instead just a routing header:
	   *          * actor:  Name of actor that will receive the packet
	   *          * type:   Name of actor's method that should be called on receipt
	   *          * length: Size of the data to be sent
	   * @return Request
	   *         This object emits a number of events to allow you to respond to
	   *         different parts of the request lifecycle.
	   *
	   *         Events emitted:
	   *         * bulk-send-ready: Ready to send bulk data to the server, using the
	   *           event data object containing:
	   *           * stream:   This output stream should only be used directly if
	   *                       you can ensure that you will write exactly |length|
	   *                       bytes and will not close the stream when writing is
	   *                       complete
	   *           * done:     If you use the stream directly (instead of |copyFrom|
	   *                       below), you must signal completion by resolving /
	   *                       rejecting this deferred.  If it's rejected, the
	   *                       transport will be closed.  If an Error is supplied as
	   *                       a rejection value, it will be logged via |dumpn|.  If
	   *                       you do use |copyFrom|, resolving is taken care of for
	   *                       you when copying completes.
	   *           * copyFrom: A helper function for getting your data onto the
	   *                       stream that meets the stream handling requirements
	   *                       above, and has the following signature:
	   *             @param  input nsIAsyncInputStream
	   *                     The stream to copy from.
	   *             @return Promise
	   *                     The promise is resolved when copying completes or
	   *                     rejected if any (unexpected) errors occur.
	   *                     This object also emits "progress" events for each chunk
	   *                     that is copied.  See stream-utils.js.
	   *         * json-reply: The server replied with a JSON packet, which is
	   *           passed as event data.
	   *         * bulk-reply: The server replied with bulk data, which you can read
	   *           using the event data object containing:
	   *           * actor:  Name of actor that received the packet
	   *           * type:   Name of actor's method that was called on receipt
	   *           * length: Size of the data to be read
	   *           * stream: This input stream should only be used directly if you
	   *                     can ensure that you will read exactly |length| bytes
	   *                     and will not close the stream when reading is complete
	   *           * done:   If you use the stream directly (instead of |copyTo|
	   *                     below), you must signal completion by resolving /
	   *                     rejecting this deferred.  If it's rejected, the
	   *                     transport will be closed.  If an Error is supplied as a
	   *                     rejection value, it will be logged via |dumpn|.  If you
	   *                     do use |copyTo|, resolving is taken care of for you
	   *                     when copying completes.
	   *           * copyTo: A helper function for getting your data out of the
	   *                     stream that meets the stream handling requirements
	   *                     above, and has the following signature:
	   *             @param  output nsIAsyncOutputStream
	   *                     The stream to copy to.
	   *             @return Promise
	   *                     The promise is resolved when copying completes or
	   *                     rejected if any (unexpected) errors occur.
	   *                     This object also emits "progress" events for each chunk
	   *                     that is copied.  See stream-utils.js.
	   */
	  startBulkRequest: function(request) {
	    if (!this.traits.bulk) {
	      throw Error("Server doesn't support bulk transfers");
	    }
	    if (!this.mainRoot) {
	      throw Error("Have not yet received a hello packet from the server.");
	    }
	    if (!request.type) {
	      throw Error("Bulk packet is missing the required 'type' field.");
	    }
	    if (!request.actor) {
	      throw Error("'" + request.type + "' bulk packet has no destination.");
	    }
	    if (!request.length) {
	      throw Error("'" + request.type + "' bulk packet has no length.");
	    }
	
	    request = new Request(request);
	    request.format = "bulk";
	
	    this._sendOrQueueRequest(request);
	
	    return request;
	  },
	
	  /**
	   * If a new request can be sent immediately, do so.  Otherwise, queue it.
	   */
	  _sendOrQueueRequest(request) {
	    let actor = request.actor;
	    if (!this._activeRequests.has(actor)) {
	      this._sendRequest(request);
	    } else {
	      this._queueRequest(request);
	    }
	  },
	
	  /**
	   * Send a request.
	   * @throws Error if there is already an active request in flight for the same
	   *         actor.
	   */
	  _sendRequest(request) {
	    let actor = request.actor;
	    this.expectReply(actor, request);
	
	    if (request.format === "json") {
	      this._transport.send(request.request);
	      return false;
	    }
	
	    this._transport.startBulkSend(request.request).then((...args) => {
	      request.emit("bulk-send-ready", ...args);
	    });
	  },
	
	  /**
	   * Queue a request to be sent later.  Queues are only drained when an in
	   * flight request to a given actor completes.
	   */
	  _queueRequest(request) {
	    let actor = request.actor;
	    let queue = this._pendingRequests.get(actor) || [];
	    queue.push(request);
	    this._pendingRequests.set(actor, queue);
	  },
	
	  /**
	   * Attempt the next request to a given actor (if any).
	   */
	  _attemptNextRequest(actor) {
	    if (this._activeRequests.has(actor)) {
	      return;
	    }
	    let queue = this._pendingRequests.get(actor);
	    if (!queue) {
	      return;
	    }
	    let request = queue.shift();
	    if (queue.length === 0) {
	      this._pendingRequests.delete(actor);
	    }
	    this._sendRequest(request);
	  },
	
	  /**
	   * Arrange to hand the next reply from |aActor| to the handler bound to
	   * |aRequest|.
	   *
	   * DebuggerClient.prototype.request / startBulkRequest usually takes care of
	   * establishing the handler for a given request, but in rare cases (well,
	   * greetings from new root actors, is the only case at the moment) we must be
	   * prepared for a "reply" that doesn't correspond to any request we sent.
	   */
	  expectReply: function(aActor, aRequest) {
	    if (this._activeRequests.has(aActor)) {
	      throw Error("clashing handlers for next reply from " + uneval(aActor));
	    }
	
	    // If a handler is passed directly (as it is with the handler for the root
	    // actor greeting), create a dummy request to bind this to.
	    if (typeof aRequest === "function") {
	      let handler = aRequest;
	      aRequest = new Request();
	      aRequest.on("json-reply", handler);
	    }
	
	    this._activeRequests.set(aActor, aRequest);
	  },
	
	  // Transport hooks.
	
	  /**
	   * Called by DebuggerTransport to dispatch incoming packets as appropriate.
	   *
	   * @param aPacket object
	   *        The incoming packet.
	   */
	  onPacket: function(aPacket) {
	    if (!aPacket.from) {
	      DevToolsUtils.reportException(
	        "onPacket",
	        new Error("Server did not specify an actor, dropping packet: " +
	                  JSON.stringify(aPacket)));
	      return;
	    }
	
	    // If we have a registered Front for this actor, let it handle the packet
	    // and skip all the rest of this unpleasantness.
	    let front = this.getActor(aPacket.from);
	    if (front) {
	      front.onPacket(aPacket);
	      return;
	    }
	
	    if (this._clients.has(aPacket.from) && aPacket.type) {
	      let client = this._clients.get(aPacket.from);
	      let type = aPacket.type;
	      if (client.events.indexOf(type) != -1) {
	        client.emit(type, aPacket);
	        // we ignore the rest, as the client is expected to handle this packet.
	        return;
	      }
	    }
	
	    let activeRequest;
	    // See if we have a handler function waiting for a reply from this
	    // actor. (Don't count unsolicited notifications or pauses as
	    // replies.)
	    if (this._activeRequests.has(aPacket.from) &&
	        !(aPacket.type in UnsolicitedNotifications) &&
	        !(aPacket.type == ThreadStateTypes.paused &&
	          aPacket.why.type in UnsolicitedPauses)) {
	      activeRequest = this._activeRequests.get(aPacket.from);
	      this._activeRequests.delete(aPacket.from);
	    }
	
	    // If there is a subsequent request for the same actor, hand it off to the
	    // transport.  Delivery of packets on the other end is always async, even
	    // in the local transport case.
	    this._attemptNextRequest(aPacket.from);
	
	    // Packets that indicate thread state changes get special treatment.
	    if (aPacket.type in ThreadStateTypes &&
	        this._clients.has(aPacket.from) &&
	        typeof this._clients.get(aPacket.from)._onThreadState == "function") {
	      this._clients.get(aPacket.from)._onThreadState(aPacket);
	    }
	
	    // TODO: Bug 1151156 - Remove once Gecko 40 is on b2g-stable.
	    if (!this.traits.noNeedToFakeResumptionOnNavigation) {
	      // On navigation the server resumes, so the client must resume as well.
	      // We achieve that by generating a fake resumption packet that triggers
	      // the client's thread state change listeners.
	      if (aPacket.type == UnsolicitedNotifications.tabNavigated &&
	          this._clients.has(aPacket.from) &&
	          this._clients.get(aPacket.from).thread) {
	        let thread = this._clients.get(aPacket.from).thread;
	        let resumption = { from: thread._actor, type: "resumed" };
	        thread._onThreadState(resumption);
	      }
	    }
	
	    // Only try to notify listeners on events, not responses to requests
	    // that lack a packet type.
	    if (aPacket.type) {
	      this.emit(aPacket.type, aPacket);
	    }
	
	    if (activeRequest) {
	      let emitReply = () => activeRequest.emit("json-reply", aPacket);
	      if (activeRequest.stack) {
	        Cu.callFunctionWithAsyncStack(emitReply, activeRequest.stack,
	                                      "DevTools RDP");
	      } else {
	        emitReply();
	      }
	    }
	  },
	
	  /**
	   * Called by the DebuggerTransport to dispatch incoming bulk packets as
	   * appropriate.
	   *
	   * @param packet object
	   *        The incoming packet, which contains:
	   *        * actor:  Name of actor that will receive the packet
	   *        * type:   Name of actor's method that should be called on receipt
	   *        * length: Size of the data to be read
	   *        * stream: This input stream should only be used directly if you can
	   *                  ensure that you will read exactly |length| bytes and will
	   *                  not close the stream when reading is complete
	   *        * done:   If you use the stream directly (instead of |copyTo|
	   *                  below), you must signal completion by resolving /
	   *                  rejecting this deferred.  If it's rejected, the transport
	   *                  will be closed.  If an Error is supplied as a rejection
	   *                  value, it will be logged via |dumpn|.  If you do use
	   *                  |copyTo|, resolving is taken care of for you when copying
	   *                  completes.
	   *        * copyTo: A helper function for getting your data out of the stream
	   *                  that meets the stream handling requirements above, and has
	   *                  the following signature:
	   *          @param  output nsIAsyncOutputStream
	   *                  The stream to copy to.
	   *          @return Promise
	   *                  The promise is resolved when copying completes or rejected
	   *                  if any (unexpected) errors occur.
	   *                  This object also emits "progress" events for each chunk
	   *                  that is copied.  See stream-utils.js.
	   */
	  onBulkPacket: function(packet) {
	    let { actor, type, length } = packet;
	
	    if (!actor) {
	      DevToolsUtils.reportException(
	        "onBulkPacket",
	        new Error("Server did not specify an actor, dropping bulk packet: " +
	                  JSON.stringify(packet)));
	      return;
	    }
	
	    // See if we have a handler function waiting for a reply from this
	    // actor.
	    if (!this._activeRequests.has(actor)) {
	      return;
	    }
	
	    let activeRequest = this._activeRequests.get(actor);
	    this._activeRequests.delete(actor);
	
	    // If there is a subsequent request for the same actor, hand it off to the
	    // transport.  Delivery of packets on the other end is always async, even
	    // in the local transport case.
	    this._attemptNextRequest(actor);
	
	    activeRequest.emit("bulk-reply", packet);
	  },
	
	  /**
	   * Called by DebuggerTransport when the underlying stream is closed.
	   *
	   * @param aStatus nsresult
	   *        The status code that corresponds to the reason for closing
	   *        the stream.
	   */
	  onClosed: function(aStatus) {
	    this._closed = true;
	    this.emit("closed");
	
	    // Reject all pending and active requests
	    let reject = function(type, request, actor) {
	      // Server can send packets on its own and client only pass a callback
	      // to expectReply, so that there is no request object.
	      let msg;
	      if (request.request) {
	        msg = "'" + request.request.type + "' " + type + " request packet" +
	              " to '" + actor + "' " +
	              "can't be sent as the connection just closed.";
	      } else {
	        msg = "server side packet from '" + actor + "' can't be received " +
	              "as the connection just closed.";
	      }
	      let packet = { error: "connectionClosed", message: msg };
	      request.emit("json-reply", packet);
	    };
	
	    let pendingRequests = new Map(this._pendingRequests);
	    this._pendingRequests.clear();
	    pendingRequests.forEach((list, actor) => {
	      list.forEach(request => reject("pending", request, actor));
	    });
	    let activeRequests = new Map(this._activeRequests);
	    this._activeRequests.clear();
	    activeRequests.forEach(reject.bind(null, "active"));
	
	    // The |_pools| array on the client-side currently is used only by
	    // protocol.js to store active fronts, mirroring the actor pools found in
	    // the server.  So, read all usages of "pool" as "protocol.js front".
	    //
	    // In the normal case where we shutdown cleanly, the toolbox tells each tool
	    // to close, and they each call |destroy| on any fronts they were using.
	    // When |destroy| or |cleanup| is called on a protocol.js front, it also
	    // removes itself from the |_pools| array.  Once the toolbox has shutdown,
	    // the connection is closed, and we reach here.  All fronts (should have
	    // been) |destroy|ed, so |_pools| should empty.
	    //
	    // If the connection instead aborts unexpectedly, we may end up here with
	    // all fronts used during the life of the connection.  So, we call |cleanup|
	    // on them clear their state, reject pending requests, and remove themselves
	    // from |_pools|.  This saves the toolbox from hanging indefinitely, in case
	    // it waits for some server response before shutdown that will now never
	    // arrive.
	    for (let pool of this._pools) {
	      pool.cleanup();
	    }
	  },
	
	  registerClient: function(client) {
	    let actorID = client.actor;
	    if (!actorID) {
	      throw new Error("DebuggerServer.registerClient expects " +
	                      "a client instance with an `actor` attribute.");
	    }
	    if (!Array.isArray(client.events)) {
	      throw new Error("DebuggerServer.registerClient expects " +
	                      "a client instance with an `events` attribute " +
	                      "that is an array.");
	    }
	    if (client.events.length > 0 && typeof (client.emit) != "function") {
	      throw new Error("DebuggerServer.registerClient expects " +
	                      "a client instance with non-empty `events` array to" +
	                      "have an `emit` function.");
	    }
	    if (this._clients.has(actorID)) {
	      throw new Error("DebuggerServer.registerClient already registered " +
	                      "a client for this actor.");
	    }
	    this._clients.set(actorID, client);
	  },
	
	  unregisterClient: function(client) {
	    let actorID = client.actor;
	    if (!actorID) {
	      throw new Error("DebuggerServer.unregisterClient expects " +
	                      "a Client instance with a `actor` attribute.");
	    }
	    this._clients.delete(actorID);
	  },
	
	  /**
	   * Actor lifetime management, echos the server's actor pools.
	   */
	  __pools: null,
	  get _pools() {
	    if (this.__pools) {
	      return this.__pools;
	    }
	    this.__pools = new Set();
	    return this.__pools;
	  },
	
	  addActorPool: function(pool) {
	    this._pools.add(pool);
	  },
	  removeActorPool: function(pool) {
	    this._pools.delete(pool);
	  },
	  getActor: function(actorID) {
	    let pool = this.poolFor(actorID);
	    return pool ? pool.get(actorID) : null;
	  },
	
	  poolFor: function(actorID) {
	    for (let pool of this._pools) {
	      if (pool.has(actorID)) return pool;
	    }
	    return null;
	  },
	
	  /**
	   * Currently attached addon.
	   */
	  activeAddon: null
	};
	
	eventSource(DebuggerClient.prototype);
	
	function Request(request) {
	  this.request = request;
	}
	
	Request.prototype = {
	
	  on: function(type, listener) {
	    events.on(this, type, listener);
	  },
	
	  off: function(type, listener) {
	    events.off(this, type, listener);
	  },
	
	  once: function(type, listener) {
	    events.once(this, type, listener);
	  },
	
	  emit: function(type, ...args) {
	    events.emit(this, type, ...args);
	  },
	
	  get actor() { return this.request.to || this.request.actor; }
	
	};
	
	/**
	 * Creates a tab client for the remote debugging protocol server. This client
	 * is a front to the tab actor created in the server side, hiding the protocol
	 * details in a traditional JavaScript API.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aForm object
	 *        The protocol form for this tab.
	 */
	function TabClient(aClient, aForm) {
	  this.client = aClient;
	  this._actor = aForm.from;
	  this._threadActor = aForm.threadActor;
	  this.javascriptEnabled = aForm.javascriptEnabled;
	  this.cacheDisabled = aForm.cacheDisabled;
	  this.thread = null;
	  this.request = this.client.request;
	  this.traits = aForm.traits || {};
	  this.events = ["workerListChanged"];
	}
	
	TabClient.prototype = {
	  get actor() { return this._actor; },
	  get _transport() { return this.client._transport; },
	
	  /**
	   * Attach to a thread actor.
	   *
	   * @param object aOptions
	   *        Configuration options.
	   *        - useSourceMaps: whether to use source maps or not.
	   * @param function aOnResponse
	   *        Called with the response packet and a ThreadClient
	   *        (which will be undefined on error).
	   */
	  attachThread: function(aOptions = {}, aOnResponse = noop) {
	    if (this.thread) {
	      DevToolsUtils.executeSoon(() => aOnResponse({}, this.thread));
	      return promise.resolve([{}, this.thread]);
	    }
	
	    let packet = {
	      to: this._threadActor,
	      type: "attach",
	      options: aOptions
	    };
	    return this.request(packet).then(aResponse => {
	      if (!aResponse.error) {
	        this.thread = new ThreadClient(this, this._threadActor);
	        this.client.registerClient(this.thread);
	      }
	      aOnResponse(aResponse, this.thread);
	      return [aResponse, this.thread];
	    });
	  },
	
	  /**
	   * Detach the client from the tab actor.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  detach: DebuggerClient.requester({
	    type: "detach"
	  }, {
	    before: function(aPacket) {
	      if (this.thread) {
	        this.thread.detach();
	      }
	      return aPacket;
	    },
	    after: function(aResponse) {
	      this.client.unregisterClient(this);
	      return aResponse;
	    },
	    telemetry: "TABDETACH"
	  }),
	
	  /**
	   * Bring the window to the front.
	   */
	  focus: DebuggerClient.requester({
	    type: "focus"
	  }, {}),
	
	  /**
	   * Reload the page in this tab.
	   *
	   * @param [optional] object options
	   *        An object with a `force` property indicating whether or not
	   *        this reload should skip the cache
	   */
	  reload: function(options = { force: false }) {
	    return this._reload(options);
	  },
	  _reload: DebuggerClient.requester({
	    type: "reload",
	    options: args(0)
	  }, {
	    telemetry: "RELOAD"
	  }),
	
	  /**
	   * Navigate to another URL.
	   *
	   * @param string url
	   *        The URL to navigate to.
	   */
	  navigateTo: DebuggerClient.requester({
	    type: "navigateTo",
	    url: args(0)
	  }, {
	    telemetry: "NAVIGATETO"
	  }),
	
	  /**
	   * Reconfigure the tab actor.
	   *
	   * @param object aOptions
	   *        A dictionary object of the new options to use in the tab actor.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  reconfigure: DebuggerClient.requester({
	    type: "reconfigure",
	    options: args(0)
	  }, {
	    telemetry: "RECONFIGURETAB"
	  }),
	
	  listWorkers: DebuggerClient.requester({
	    type: "listWorkers"
	  }, {
	    telemetry: "LISTWORKERS"
	  }),
	
	  attachWorker: function(aWorkerActor, aOnResponse) {
	    this.client.attachWorker(aWorkerActor, aOnResponse);
	  },
	
	  /**
	   * Resolve a location ({ url, line, column }) to its current
	   * source mapping location.
	   *
	   * @param {String} arg[0].url
	   * @param {Number} arg[0].line
	   * @param {Number?} arg[0].column
	   */
	  resolveLocation: DebuggerClient.requester({
	    type: "resolveLocation",
	    location: args(0)
	  }),
	};
	
	eventSource(TabClient.prototype);
	
	function WorkerClient(aClient, aForm) {
	  this.client = aClient;
	  this._actor = aForm.from;
	  this._isClosed = false;
	  this._url = aForm.url;
	
	  this._onClose = this._onClose.bind(this);
	
	  this.addListener("close", this._onClose);
	
	  this.traits = {};
	}
	
	WorkerClient.prototype = {
	  get _transport() {
	    return this.client._transport;
	  },
	
	  get request() {
	    return this.client.request;
	  },
	
	  get actor() {
	    return this._actor;
	  },
	
	  get url() {
	    return this._url;
	  },
	
	  get isClosed() {
	    return this._isClosed;
	  },
	
	  detach: DebuggerClient.requester({ type: "detach" }, {
	    after: function(aResponse) {
	      if (this.thread) {
	        this.client.unregisterClient(this.thread);
	      }
	      this.client.unregisterClient(this);
	      return aResponse;
	    },
	
	    telemetry: "WORKERDETACH"
	  }),
	
	  attachThread: function(aOptions = {}, aOnResponse = noop) {
	    if (this.thread) {
	      let response = [{
	        type: "connected",
	        threadActor: this.thread._actor,
	        consoleActor: this.consoleActor,
	      }, this.thread];
	      DevToolsUtils.executeSoon(() => aOnResponse(response));
	      return response;
	    }
	
	    // The connect call on server doesn't attach the thread as of version 44.
	    return this.request({
	      to: this._actor,
	      type: "connect",
	      options: aOptions,
	    }).then(connectReponse => {
	      if (connectReponse.error) {
	        aOnResponse(connectReponse, null);
	        return [connectResponse, null];
	      }
	
	      return this.request({
	        to: connectReponse.threadActor,
	        type: "attach",
	        options: aOptions
	      }).then(attachResponse => {
	        if (attachResponse.error) {
	          aOnResponse(attachResponse, null);
	        }
	
	        this.thread = new ThreadClient(this, connectReponse.threadActor);
	        this.consoleActor = connectReponse.consoleActor;
	        this.client.registerClient(this.thread);
	
	        aOnResponse(connectReponse, this.thread);
	        return [connectResponse, this.thread];
	      });
	    });
	  },
	
	  _onClose: function() {
	    this.removeListener("close", this._onClose);
	
	    if (this.thread) {
	      this.client.unregisterClient(this.thread);
	    }
	    this.client.unregisterClient(this);
	    this._isClosed = true;
	  },
	
	  reconfigure: function() {
	    return Promise.resolve();
	  },
	
	  events: ["close"]
	};
	
	eventSource(WorkerClient.prototype);
	
	function AddonClient(aClient, aActor) {
	  this._client = aClient;
	  this._actor = aActor;
	  this.request = this._client.request;
	  this.events = [];
	}
	
	AddonClient.prototype = {
	  get actor() { return this._actor; },
	  get _transport() { return this._client._transport; },
	
	  /**
	   * Detach the client from the addon actor.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  detach: DebuggerClient.requester({
	    type: "detach"
	  }, {
	    after: function(aResponse) {
	      if (this._client.activeAddon === this) {
	        this._client.activeAddon = null;
	      }
	      this._client.unregisterClient(this);
	      return aResponse;
	    },
	    telemetry: "ADDONDETACH"
	  })
	};
	
	/**
	 * A RootClient object represents a root actor on the server. Each
	 * DebuggerClient keeps a RootClient instance representing the root actor
	 * for the initial connection; DebuggerClient's 'listTabs' and
	 * 'listChildProcesses' methods forward to that root actor.
	 *
	 * @param aClient object
	 *      The client connection to which this actor belongs.
	 * @param aGreeting string
	 *      The greeting packet from the root actor we're to represent.
	 *
	 * Properties of a RootClient instance:
	 *
	 * @property actor string
	 *      The name of this child's root actor.
	 * @property applicationType string
	 *      The application type, as given in the root actor's greeting packet.
	 * @property traits object
	 *      The traits object, as given in the root actor's greeting packet.
	 */
	function RootClient(aClient, aGreeting) {
	  this._client = aClient;
	  this.actor = aGreeting.from;
	  this.applicationType = aGreeting.applicationType;
	  this.traits = aGreeting.traits;
	}
	exports.RootClient = RootClient;
	
	RootClient.prototype = {
	  constructor: RootClient,
	
	  /**
	   * List the open tabs.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  listTabs: DebuggerClient.requester({ type: "listTabs" },
	                                     { telemetry: "LISTTABS" }),
	
	  /**
	   * List the installed addons.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  listAddons: DebuggerClient.requester({ type: "listAddons" },
	                                       { telemetry: "LISTADDONS" }),
	
	  /**
	   * List the registered workers.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  listWorkers: DebuggerClient.requester({ type: "listWorkers" },
	                                        { telemetry: "LISTWORKERS" }),
	
	  /**
	   * List the registered service workers.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  listServiceWorkerRegistrations: DebuggerClient.requester({ type: "listServiceWorkerRegistrations" },
	                                                           { telemetry: "LISTSERVICEWORKERREGISTRATIONS" }),
	
	  /**
	   * List the running processes.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  listProcesses: DebuggerClient.requester({ type: "listProcesses" },
	                                          { telemetry: "LISTPROCESSES" }),
	
	  /**
	   * Fetch the TabActor for the currently selected tab, or for a specific
	   * tab given as first parameter.
	   *
	   * @param [optional] object aFilter
	   *        A dictionary object with following optional attributes:
	   *         - outerWindowID: used to match tabs in parent process
	   *         - tabId: used to match tabs in child processes
	   *         - tab: a reference to xul:tab element
	   *        If nothing is specified, returns the actor for the currently
	   *        selected tab.
	   */
	  getTab: function(aFilter) {
	    let packet = {
	      to: this.actor,
	      type: "getTab"
	    };
	
	    if (aFilter) {
	      if (typeof (aFilter.outerWindowID) == "number") {
	        packet.outerWindowID = aFilter.outerWindowID;
	      } else if (typeof (aFilter.tabId) == "number") {
	        packet.tabId = aFilter.tabId;
	      } else if ("tab" in aFilter) {
	        let browser = aFilter.tab.linkedBrowser;
	        if (browser.frameLoader.tabParent) {
	          // Tabs in child process
	          packet.tabId = browser.frameLoader.tabParent.tabId;
	        } else {
	          // Tabs in parent process
	          let windowUtils = browser.contentWindow
	            .QueryInterface(Ci.nsIInterfaceRequestor)
	            .getInterface(Ci.nsIDOMWindowUtils);
	          packet.outerWindowID = windowUtils.outerWindowID;
	        }
	      } else {
	        // Throw if a filter object have been passed but without
	        // any clearly idenfified filter.
	        throw new Error("Unsupported argument given to getTab request");
	      }
	    }
	
	    return this.request(packet);
	  },
	
	  /**
	   * Description of protocol's actors and methods.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  protocolDescription: DebuggerClient.requester({ type: "protocolDescription" },
	                                                 { telemetry: "PROTOCOLDESCRIPTION" }),
	
	  /*
	   * Methods constructed by DebuggerClient.requester require these forwards
	   * on their 'this'.
	   */
	  get _transport() { return this._client._transport; },
	  get request() { return this._client.request; }
	};
	
	/**
	 * Creates a thread client for the remote debugging protocol server. This client
	 * is a front to the thread actor created in the server side, hiding the
	 * protocol details in a traditional JavaScript API.
	 *
	 * @param aClient DebuggerClient|TabClient
	 *        The parent of the thread (tab for tab-scoped debuggers, DebuggerClient
	 *        for chrome debuggers).
	 * @param aActor string
	 *        The actor ID for this thread.
	 */
	function ThreadClient(aClient, aActor) {
	  this._parent = aClient;
	  this.client = aClient instanceof DebuggerClient ? aClient : aClient.client;
	  this._actor = aActor;
	  this._frameCache = [];
	  this._scriptCache = {};
	  this._pauseGrips = {};
	  this._threadGrips = {};
	  this.request = this.client.request;
	}
	
	ThreadClient.prototype = {
	  _state: "paused",
	  get state() { return this._state; },
	  get paused() { return this._state === "paused"; },
	
	  _pauseOnExceptions: false,
	  _ignoreCaughtExceptions: false,
	  _pauseOnDOMEvents: null,
	
	  _actor: null,
	  get actor() { return this._actor; },
	
	  get _transport() { return this.client._transport; },
	
	  _assertPaused: function(aCommand) {
	    if (!this.paused) {
	      throw Error(aCommand + " command sent while not paused. Currently " + this._state);
	    }
	  },
	
	  /**
	   * Resume a paused thread. If the optional aLimit parameter is present, then
	   * the thread will also pause when that limit is reached.
	   *
	   * @param [optional] object aLimit
	   *        An object with a type property set to the appropriate limit (next,
	   *        step, or finish) per the remote debugging protocol specification.
	   *        Use null to specify no limit.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  _doResume: DebuggerClient.requester({
	    type: "resume",
	    resumeLimit: args(0)
	  }, {
	    before: function(aPacket) {
	      this._assertPaused("resume");
	
	      // Put the client in a tentative "resuming" state so we can prevent
	      // further requests that should only be sent in the paused state.
	      this._state = "resuming";
	
	      if (this._pauseOnExceptions) {
	        aPacket.pauseOnExceptions = this._pauseOnExceptions;
	      }
	      if (this._ignoreCaughtExceptions) {
	        aPacket.ignoreCaughtExceptions = this._ignoreCaughtExceptions;
	      }
	      if (this._pauseOnDOMEvents) {
	        aPacket.pauseOnDOMEvents = this._pauseOnDOMEvents;
	      }
	      return aPacket;
	    },
	    after: function(aResponse) {
	      if (aResponse.error) {
	        // There was an error resuming, back to paused state.
	        this._state = "paused";
	      }
	      return aResponse;
	    },
	    telemetry: "RESUME"
	  }),
	
	  /**
	   * Reconfigure the thread actor.
	   *
	   * @param object aOptions
	   *        A dictionary object of the new options to use in the thread actor.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  reconfigure: DebuggerClient.requester({
	    type: "reconfigure",
	    options: args(0)
	  }, {
	    telemetry: "RECONFIGURETHREAD"
	  }),
	
	  /**
	   * Resume a paused thread.
	   */
	  resume: function(aOnResponse) {
	    return this._doResume(null, aOnResponse);
	  },
	
	  /**
	   * Resume then pause without stepping.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  resumeThenPause: function(aOnResponse) {
	    return this._doResume({ type: "break" }, aOnResponse);
	  },
	
	  /**
	   * Step over a function call.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  stepOver: function(aOnResponse) {
	    return this._doResume({ type: "next" }, aOnResponse);
	  },
	
	  /**
	   * Step into a function call.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  stepIn: function(aOnResponse) {
	    return this._doResume({ type: "step" }, aOnResponse);
	  },
	
	  /**
	   * Step out of a function call.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  stepOut: function(aOnResponse) {
	    return this._doResume({ type: "finish" }, aOnResponse);
	  },
	
	  /**
	   * Immediately interrupt a running thread.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  interrupt: function(aOnResponse) {
	    return this._doInterrupt(null, aOnResponse);
	  },
	
	  /**
	   * Pause execution right before the next JavaScript bytecode is executed.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  breakOnNext: function(aOnResponse) {
	    return this._doInterrupt("onNext", aOnResponse);
	  },
	
	  /**
	   * Interrupt a running thread.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  _doInterrupt: DebuggerClient.requester({
	    type: "interrupt",
	    when: args(0)
	  }, {
	    telemetry: "INTERRUPT"
	  }),
	
	  /**
	   * Enable or disable pausing when an exception is thrown.
	   *
	   * @param boolean aFlag
	   *        Enables pausing if true, disables otherwise.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  pauseOnExceptions: function(aPauseOnExceptions,
	                               aIgnoreCaughtExceptions,
	                               aOnResponse = noop) {
	    this._pauseOnExceptions = aPauseOnExceptions;
	    this._ignoreCaughtExceptions = aIgnoreCaughtExceptions;
	
	    // Otherwise send the flag using a standard resume request.
	    if (!this.paused) {
	      return this.interrupt(aResponse => {
	        if (aResponse.error) {
	          // Can't continue if pausing failed.
	          aOnResponse(aResponse);
	          return aResponse;
	        }
	        return this.resume(aOnResponse);
	      });
	    }
	
	    aOnResponse();
	    return promise.resolve();
	  },
	
	  /**
	   * Enable pausing when the specified DOM events are triggered. Disabling
	   * pausing on an event can be realized by calling this method with the updated
	   * array of events that doesn't contain it.
	   *
	   * @param array|string events
	   *        An array of strings, representing the DOM event types to pause on,
	   *        or "*" to pause on all DOM events. Pass an empty array to
	   *        completely disable pausing on DOM events.
	   * @param function onResponse
	   *        Called with the response packet in a future turn of the event loop.
	   */
	  pauseOnDOMEvents: function(events, onResponse = noop) {
	    this._pauseOnDOMEvents = events;
	    // If the debuggee is paused, the value of the array will be communicated in
	    // the next resumption. Otherwise we have to force a pause in order to send
	    // the array.
	    if (this.paused) {
	      DevToolsUtils.executeSoon(() => onResponse({}));
	      return {};
	    }
	    return this.interrupt(response => {
	      // Can't continue if pausing failed.
	      if (response.error) {
	        onResponse(response);
	        return response;
	      }
	      return this.resume(onResponse);
	    });
	  },
	
	  /**
	   * Send a clientEvaluate packet to the debuggee. Response
	   * will be a resume packet.
	   *
	   * @param string aFrame
	   *        The actor ID of the frame where the evaluation should take place.
	   * @param string aExpression
	   *        The expression that will be evaluated in the scope of the frame
	   *        above.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  eval: DebuggerClient.requester({
	    type: "clientEvaluate",
	    frame: args(0),
	    expression: args(1)
	  }, {
	    before: function(aPacket) {
	      this._assertPaused("eval");
	      // Put the client in a tentative "resuming" state so we can prevent
	      // further requests that should only be sent in the paused state.
	      this._state = "resuming";
	      return aPacket;
	    },
	    after: function(aResponse) {
	      if (aResponse.error) {
	        // There was an error resuming, back to paused state.
	        this._state = "paused";
	      }
	      return aResponse;
	    },
	    telemetry: "CLIENTEVALUATE"
	  }),
	
	  /**
	   * Detach from the thread actor.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  detach: DebuggerClient.requester({
	    type: "detach"
	  }, {
	    after: function(aResponse) {
	      this.client.unregisterClient(this);
	      this._parent.thread = null;
	      return aResponse;
	    },
	    telemetry: "THREADDETACH"
	  }),
	
	  /**
	   * Release multiple thread-lifetime object actors. If any pause-lifetime
	   * actors are included in the request, a |notReleasable| error will return,
	   * but all the thread-lifetime ones will have been released.
	   *
	   * @param array actors
	   *        An array with actor IDs to release.
	   */
	  releaseMany: DebuggerClient.requester({
	    type: "releaseMany",
	    actors: args(0),
	  }, {
	    telemetry: "RELEASEMANY"
	  }),
	
	  /**
	   * Promote multiple pause-lifetime object actors to thread-lifetime ones.
	   *
	   * @param array actors
	   *        An array with actor IDs to promote.
	   */
	  threadGrips: DebuggerClient.requester({
	    type: "threadGrips",
	    actors: args(0)
	  }, {
	    telemetry: "THREADGRIPS"
	  }),
	
	  /**
	   * Return the event listeners defined on the page.
	   *
	   * @param aOnResponse Function
	   *        Called with the thread's response.
	   */
	  eventListeners: DebuggerClient.requester({
	    type: "eventListeners"
	  }, {
	    telemetry: "EVENTLISTENERS"
	  }),
	
	  /**
	   * Request the loaded sources for the current thread.
	   *
	   * @param aOnResponse Function
	   *        Called with the thread's response.
	   */
	  getSources: DebuggerClient.requester({
	    type: "sources"
	  }, {
	    telemetry: "SOURCES"
	  }),
	
	  /**
	   * Clear the thread's source script cache. A scriptscleared event
	   * will be sent.
	   */
	  _clearScripts: function() {
	    if (Object.keys(this._scriptCache).length > 0) {
	      this._scriptCache = {};
	      this.emit("scriptscleared");
	    }
	  },
	
	  /**
	   * Request frames from the callstack for the current thread.
	   *
	   * @param aStart integer
	   *        The number of the youngest stack frame to return (the youngest
	   *        frame is 0).
	   * @param aCount integer
	   *        The maximum number of frames to return, or null to return all
	   *        frames.
	   * @param aOnResponse function
	   *        Called with the thread's response.
	   */
	  getFrames: DebuggerClient.requester({
	    type: "frames",
	    start: args(0),
	    count: args(1)
	  }, {
	    telemetry: "FRAMES"
	  }),
	
	  /**
	   * An array of cached frames. Clients can observe the framesadded and
	   * framescleared event to keep up to date on changes to this cache,
	   * and can fill it using the fillFrames method.
	   */
	  get cachedFrames() { return this._frameCache; },
	
	  /**
	   * true if there are more stack frames available on the server.
	   */
	  get moreFrames() {
	    return this.paused && (!this._frameCache || this._frameCache.length == 0
	          || !this._frameCache[this._frameCache.length - 1].oldest);
	  },
	
	  /**
	   * Ensure that at least aTotal stack frames have been loaded in the
	   * ThreadClient's stack frame cache. A framesadded event will be
	   * sent when the stack frame cache is updated.
	   *
	   * @param aTotal number
	   *        The minimum number of stack frames to be included.
	   * @param aCallback function
	   *        Optional callback function called when frames have been loaded
	   * @returns true if a framesadded notification should be expected.
	   */
	  fillFrames: function(aTotal, aCallback = noop) {
	    this._assertPaused("fillFrames");
	    if (this._frameCache.length >= aTotal) {
	      return false;
	    }
	
	    let numFrames = this._frameCache.length;
	
	    this.getFrames(numFrames, aTotal - numFrames, (aResponse) => {
	      if (aResponse.error) {
	        aCallback(aResponse);
	        return;
	      }
	
	      let threadGrips = DevToolsUtils.values(this._threadGrips);
	
	      for (let i in aResponse.frames) {
	        let frame = aResponse.frames[i];
	        if (!frame.where.source) {
	          // Older servers use urls instead, so we need to resolve
	          // them to source actors
	          for (let grip of threadGrips) {
	            if (grip instanceof SourceClient && grip.url === frame.url) {
	              frame.where.source = grip._form;
	            }
	          }
	        }
	
	        this._frameCache[frame.depth] = frame;
	      }
	
	      // If we got as many frames as we asked for, there might be more
	      // frames available.
	      this.emit("framesadded");
	
	      aCallback(aResponse);
	    });
	
	    return true;
	  },
	
	  /**
	   * Clear the thread's stack frame cache. A framescleared event
	   * will be sent.
	   */
	  _clearFrames: function() {
	    if (this._frameCache.length > 0) {
	      this._frameCache = [];
	      this.emit("framescleared");
	    }
	  },
	
	  /**
	   * Return a ObjectClient object for the given object grip.
	   *
	   * @param aGrip object
	   *        A pause-lifetime object grip returned by the protocol.
	   */
	  pauseGrip: function(aGrip) {
	    if (aGrip.actor in this._pauseGrips) {
	      return this._pauseGrips[aGrip.actor];
	    }
	
	    let client = new ObjectClient(this.client, aGrip);
	    this._pauseGrips[aGrip.actor] = client;
	    return client;
	  },
	
	  /**
	   * Get or create a long string client, checking the grip client cache if it
	   * already exists.
	   *
	   * @param aGrip Object
	   *        The long string grip returned by the protocol.
	   * @param aGripCacheName String
	   *        The property name of the grip client cache to check for existing
	   *        clients in.
	   */
	  _longString: function(aGrip, aGripCacheName) {
	    if (aGrip.actor in this[aGripCacheName]) {
	      return this[aGripCacheName][aGrip.actor];
	    }
	
	    let client = new LongStringClient(this.client, aGrip);
	    this[aGripCacheName][aGrip.actor] = client;
	    return client;
	  },
	
	  /**
	   * Return an instance of LongStringClient for the given long string grip that
	   * is scoped to the current pause.
	   *
	   * @param aGrip Object
	   *        The long string grip returned by the protocol.
	   */
	  pauseLongString: function(aGrip) {
	    return this._longString(aGrip, "_pauseGrips");
	  },
	
	  /**
	   * Return an instance of LongStringClient for the given long string grip that
	   * is scoped to the thread lifetime.
	   *
	   * @param aGrip Object
	   *        The long string grip returned by the protocol.
	   */
	  threadLongString: function(aGrip) {
	    return this._longString(aGrip, "_threadGrips");
	  },
	
	  /**
	   * Clear and invalidate all the grip clients from the given cache.
	   *
	   * @param aGripCacheName
	   *        The property name of the grip cache we want to clear.
	   */
	  _clearObjectClients: function(aGripCacheName) {
	    for (let id in this[aGripCacheName]) {
	      this[aGripCacheName][id].valid = false;
	    }
	    this[aGripCacheName] = {};
	  },
	
	  /**
	   * Invalidate pause-lifetime grip clients and clear the list of current grip
	   * clients.
	   */
	  _clearPauseGrips: function() {
	    this._clearObjectClients("_pauseGrips");
	  },
	
	  /**
	   * Invalidate thread-lifetime grip clients and clear the list of current grip
	   * clients.
	   */
	  _clearThreadGrips: function() {
	    this._clearObjectClients("_threadGrips");
	  },
	
	  /**
	   * Handle thread state change by doing necessary cleanup and notifying all
	   * registered listeners.
	   */
	  _onThreadState: function(aPacket) {
	    this._state = ThreadStateTypes[aPacket.type];
	    // The debugger UI may not be initialized yet so we want to keep
	    // the packet around so it knows what to pause state to display
	    // when it's initialized
	    this._lastPausePacket = aPacket.type === "resumed" ? null : aPacket;
	    this._clearFrames();
	    this._clearPauseGrips();
	    aPacket.type === ThreadStateTypes.detached && this._clearThreadGrips();
	    this.client._eventsEnabled && this.emit(aPacket.type, aPacket);
	  },
	
	  getLastPausePacket: function() {
	    return this._lastPausePacket;
	  },
	
	  /**
	   * Return an EnvironmentClient instance for the given environment actor form.
	   */
	  environment: function(aForm) {
	    return new EnvironmentClient(this.client, aForm);
	  },
	
	  /**
	   * Return an instance of SourceClient for the given source actor form.
	   */
	  source: function(aForm) {
	    if (aForm.actor in this._threadGrips) {
	      return this._threadGrips[aForm.actor];
	    }
	
	    return this._threadGrips[aForm.actor] = new SourceClient(this, aForm);
	  },
	
	  /**
	   * Request the prototype and own properties of mutlipleObjects.
	   *
	   * @param aOnResponse function
	   *        Called with the request's response.
	   * @param actors [string]
	   *        List of actor ID of the queried objects.
	   */
	  getPrototypesAndProperties: DebuggerClient.requester({
	    type: "prototypesAndProperties",
	    actors: args(0)
	  }, {
	    telemetry: "PROTOTYPESANDPROPERTIES"
	  }),
	
	  events: ["newSource"]
	};
	
	eventSource(ThreadClient.prototype);
	
	/**
	 * Creates a tracing profiler client for the remote debugging protocol
	 * server. This client is a front to the trace actor created on the
	 * server side, hiding the protocol details in a traditional
	 * JavaScript API.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aActor string
	 *        The actor ID for this thread.
	 */
	function TraceClient(aClient, aActor) {
	  this._client = aClient;
	  this._actor = aActor;
	  this._activeTraces = new Set();
	  this._waitingPackets = new Map();
	  this._expectedPacket = 0;
	  this.request = this._client.request;
	  this.events = [];
	}
	
	TraceClient.prototype = {
	  get actor() { return this._actor; },
	  get tracing() { return this._activeTraces.size > 0; },
	
	  get _transport() { return this._client._transport; },
	
	  /**
	   * Detach from the trace actor.
	   */
	  detach: DebuggerClient.requester({
	    type: "detach"
	  }, {
	    after: function(aResponse) {
	      this._client.unregisterClient(this);
	      return aResponse;
	    },
	    telemetry: "TRACERDETACH"
	  }),
	
	  /**
	   * Start a new trace.
	   *
	   * @param aTrace [string]
	   *        An array of trace types to be recorded by the new trace.
	   *
	   * @param aName string
	   *        The name of the new trace.
	   *
	   * @param aOnResponse function
	   *        Called with the request's response.
	   */
	  startTrace: DebuggerClient.requester({
	    type: "startTrace",
	    name: args(1),
	    trace: args(0)
	  }, {
	    after: function(aResponse) {
	      if (aResponse.error) {
	        return aResponse;
	      }
	
	      if (!this.tracing) {
	        this._waitingPackets.clear();
	        this._expectedPacket = 0;
	      }
	      this._activeTraces.add(aResponse.name);
	
	      return aResponse;
	    },
	    telemetry: "STARTTRACE"
	  }),
	
	  /**
	   * End a trace. If a name is provided, stop the named
	   * trace. Otherwise, stop the most recently started trace.
	   *
	   * @param aName string
	   *        The name of the trace to stop.
	   *
	   * @param aOnResponse function
	   *        Called with the request's response.
	   */
	  stopTrace: DebuggerClient.requester({
	    type: "stopTrace",
	    name: args(0)
	  }, {
	    after: function(aResponse) {
	      if (aResponse.error) {
	        return aResponse;
	      }
	
	      this._activeTraces.delete(aResponse.name);
	
	      return aResponse;
	    },
	    telemetry: "STOPTRACE"
	  })
	};
	
	/**
	 * Grip clients are used to retrieve information about the relevant object.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aGrip object
	 *        A pause-lifetime object grip returned by the protocol.
	 */
	function ObjectClient(aClient, aGrip)
	{
	  this._grip = aGrip;
	  this._client = aClient;
	  this.request = this._client.request;
	}
	exports.ObjectClient = ObjectClient;
	
	ObjectClient.prototype = {
	  get actor() { return this._grip.actor; },
	  get _transport() { return this._client._transport; },
	
	  valid: true,
	
	  get isFrozen() {
	    return this._grip.frozen;
	  },
	  get isSealed() {
	    return this._grip.sealed;
	  },
	  get isExtensible() {
	    return this._grip.extensible;
	  },
	
	  getDefinitionSite: DebuggerClient.requester({
	    type: "definitionSite"
	  }, {
	    before: function(aPacket) {
	      if (this._grip.class != "Function") {
	        throw new Error("getDefinitionSite is only valid for function grips.");
	      }
	      return aPacket;
	    }
	  }),
	
	  /**
	   * Request the names of a function's formal parameters.
	   *
	   * @param aOnResponse function
	   *        Called with an object of the form:
	   *        { parameterNames:[<parameterName>, ...] }
	   *        where each <parameterName> is the name of a parameter.
	   */
	  getParameterNames: DebuggerClient.requester({
	    type: "parameterNames"
	  }, {
	    before: function(aPacket) {
	      if (this._grip.class !== "Function") {
	        throw new Error("getParameterNames is only valid for function grips.");
	      }
	      return aPacket;
	    },
	    telemetry: "PARAMETERNAMES"
	  }),
	
	  /**
	   * Request the names of the properties defined on the object and not its
	   * prototype.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getOwnPropertyNames: DebuggerClient.requester({
	    type: "ownPropertyNames"
	  }, {
	    telemetry: "OWNPROPERTYNAMES"
	  }),
	
	  /**
	   * Request the prototype and own properties of the object.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getPrototypeAndProperties: DebuggerClient.requester({
	    type: "prototypeAndProperties"
	  }, {
	    telemetry: "PROTOTYPEANDPROPERTIES"
	  }),
	
	  /**
	   * Request a PropertyIteratorClient instance to ease listing
	   * properties for this object.
	   *
	   * @param options Object
	   *        A dictionary object with various boolean attributes:
	   *        - ignoreSafeGetters Boolean
	   *          If true, do not iterate over safe getters.
	   *        - ignoreIndexedProperties Boolean
	   *          If true, filters out Array items.
	   *          e.g. properties names between `0` and `object.length`.
	   *        - ignoreNonIndexedProperties Boolean
	   *          If true, filters out items that aren't array items
	   *          e.g. properties names that are not a number between `0`
	   *          and `object.length`.
	   *        - sort Boolean
	   *          If true, the iterator will sort the properties by name
	   *          before dispatching them.
	   * @param aOnResponse function Called with the client instance.
	   */
	  enumProperties: DebuggerClient.requester({
	    type: "enumProperties",
	    options: args(0)
	  }, {
	    after: function(aResponse) {
	      if (aResponse.iterator) {
	        return { iterator: new PropertyIteratorClient(this._client, aResponse.iterator) };
	      }
	      return aResponse;
	    },
	    telemetry: "ENUMPROPERTIES"
	  }),
	
	  /**
	   * Request a PropertyIteratorClient instance to enumerate entries in a
	   * Map/Set-like object.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  enumEntries: DebuggerClient.requester({
	    type: "enumEntries"
	  }, {
	    before: function(packet) {
	      if (!["Map", "WeakMap", "Set", "WeakSet"].includes(this._grip.class)) {
	        throw new Error("enumEntries is only valid for Map/Set-like grips.");
	      }
	      return packet;
	    },
	    after: function(response) {
	      if (response.iterator) {
	        return {
	          iterator: new PropertyIteratorClient(this._client, response.iterator)
	        };
	      }
	      return response;
	    }
	  }),
	
	  /**
	   * Request the property descriptor of the object's specified property.
	   *
	   * @param aName string The name of the requested property.
	   * @param aOnResponse function Called with the request's response.
	   */
	  getProperty: DebuggerClient.requester({
	    type: "property",
	    name: args(0)
	  }, {
	    telemetry: "PROPERTY"
	  }),
	
	  /**
	   * Request the prototype of the object.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getPrototype: DebuggerClient.requester({
	    type: "prototype"
	  }, {
	    telemetry: "PROTOTYPE"
	  }),
	
	  /**
	   * Request the display string of the object.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getDisplayString: DebuggerClient.requester({
	    type: "displayString"
	  }, {
	    telemetry: "DISPLAYSTRING"
	  }),
	
	  /**
	   * Request the scope of the object.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getScope: DebuggerClient.requester({
	    type: "scope"
	  }, {
	    before: function(aPacket) {
	      if (this._grip.class !== "Function") {
	        throw new Error("scope is only valid for function grips.");
	      }
	      return aPacket;
	    },
	    telemetry: "SCOPE"
	  }),
	
	  /**
	   * Request the promises directly depending on the current promise.
	   */
	  getDependentPromises: DebuggerClient.requester({
	    type: "dependentPromises"
	  }, {
	    before: function(aPacket) {
	      if (this._grip.class !== "Promise") {
	        throw new Error("getDependentPromises is only valid for promise " +
	          "grips.");
	      }
	      return aPacket;
	    }
	  }),
	
	  /**
	   * Request the stack to the promise's allocation point.
	   */
	  getPromiseAllocationStack: DebuggerClient.requester({
	    type: "allocationStack"
	  }, {
	    before: function(aPacket) {
	      if (this._grip.class !== "Promise") {
	        throw new Error("getAllocationStack is only valid for promise grips.");
	      }
	      return aPacket;
	    }
	  }),
	
	  /**
	   * Request the stack to the promise's fulfillment point.
	   */
	  getPromiseFulfillmentStack: DebuggerClient.requester({
	    type: "fulfillmentStack"
	  }, {
	    before: function(packet) {
	      if (this._grip.class !== "Promise") {
	        throw new Error("getPromiseFulfillmentStack is only valid for " +
	          "promise grips.");
	      }
	      return packet;
	    }
	  }),
	
	  /**
	   * Request the stack to the promise's rejection point.
	   */
	  getPromiseRejectionStack: DebuggerClient.requester({
	    type: "rejectionStack"
	  }, {
	    before: function(packet) {
	      if (this._grip.class !== "Promise") {
	        throw new Error("getPromiseRejectionStack is only valid for " +
	          "promise grips.");
	      }
	      return packet;
	    }
	  })
	};
	
	/**
	 * A PropertyIteratorClient provides a way to access to property names and
	 * values of an object efficiently, slice by slice.
	 * Note that the properties can be sorted in the backend,
	 * this is controled while creating the PropertyIteratorClient
	 * from ObjectClient.enumProperties.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aGrip Object
	 *        A PropertyIteratorActor grip returned by the protocol via
	 *        TabActor.enumProperties request.
	 */
	function PropertyIteratorClient(aClient, aGrip) {
	  this._grip = aGrip;
	  this._client = aClient;
	  this.request = this._client.request;
	}
	
	PropertyIteratorClient.prototype = {
	  get actor() { return this._grip.actor; },
	
	  /**
	   * Get the total number of properties available in the iterator.
	   */
	  get count() { return this._grip.count; },
	
	  /**
	   * Get one or more property names that correspond to the positions in the
	   * indexes parameter.
	   *
	   * @param indexes Array
	   *        An array of property indexes.
	   * @param aCallback Function
	   *        The function called when we receive the property names.
	   */
	  names: DebuggerClient.requester({
	    type: "names",
	    indexes: args(0)
	  }, {}),
	
	  /**
	   * Get a set of following property value(s).
	   *
	   * @param start Number
	   *        The index of the first property to fetch.
	   * @param count Number
	   *        The number of properties to fetch.
	   * @param aCallback Function
	   *        The function called when we receive the property values.
	   */
	  slice: DebuggerClient.requester({
	    type: "slice",
	    start: args(0),
	    count: args(1)
	  }, {}),
	
	  /**
	   * Get all the property values.
	   *
	   * @param aCallback Function
	   *        The function called when we receive the property values.
	   */
	  all: DebuggerClient.requester({
	    type: "all"
	  }, {}),
	};
	
	/**
	 * A LongStringClient provides a way to access "very long" strings from the
	 * debugger server.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aGrip Object
	 *        A pause-lifetime long string grip returned by the protocol.
	 */
	function LongStringClient(aClient, aGrip) {
	  this._grip = aGrip;
	  this._client = aClient;
	  this.request = this._client.request;
	}
	exports.LongStringClient = LongStringClient;
	
	LongStringClient.prototype = {
	  get actor() { return this._grip.actor; },
	  get length() { return this._grip.length; },
	  get initial() { return this._grip.initial; },
	  get _transport() { return this._client._transport; },
	
	  valid: true,
	
	  /**
	   * Get the substring of this LongString from aStart to aEnd.
	   *
	   * @param aStart Number
	   *        The starting index.
	   * @param aEnd Number
	   *        The ending index.
	   * @param aCallback Function
	   *        The function called when we receive the substring.
	   */
	  substring: DebuggerClient.requester({
	    type: "substring",
	    start: args(0),
	    end: args(1)
	  }, {
	    telemetry: "SUBSTRING"
	  }),
	};
	
	/**
	 * A SourceClient provides a way to access the source text of a script.
	 *
	 * @param aClient ThreadClient
	 *        The thread client parent.
	 * @param aForm Object
	 *        The form sent across the remote debugging protocol.
	 */
	function SourceClient(aClient, aForm) {
	  this._form = aForm;
	  this._isBlackBoxed = aForm.isBlackBoxed;
	  this._isPrettyPrinted = aForm.isPrettyPrinted;
	  this._activeThread = aClient;
	  this._client = aClient.client;
	}
	
	SourceClient.prototype = {
	  get _transport() {
	    return this._client._transport;
	  },
	  get isBlackBoxed() {
	    return this._isBlackBoxed;
	  },
	  get isPrettyPrinted() {
	    return this._isPrettyPrinted;
	  },
	  get actor() {
	    return this._form.actor;
	  },
	  get request() {
	    return this._client.request;
	  },
	  get url() {
	    return this._form.url;
	  },
	
	  /**
	   * Black box this SourceClient's source.
	   *
	   * @param aCallback Function
	   *        The callback function called when we receive the response from the server.
	   */
	  blackBox: DebuggerClient.requester({
	    type: "blackbox"
	  }, {
	    telemetry: "BLACKBOX",
	    after: function(aResponse) {
	      if (!aResponse.error) {
	        this._isBlackBoxed = true;
	        if (this._activeThread) {
	          this._activeThread.emit("blackboxchange", this);
	        }
	      }
	      return aResponse;
	    }
	  }),
	
	  /**
	   * Un-black box this SourceClient's source.
	   *
	   * @param aCallback Function
	   *        The callback function called when we receive the response from the server.
	   */
	  unblackBox: DebuggerClient.requester({
	    type: "unblackbox"
	  }, {
	    telemetry: "UNBLACKBOX",
	    after: function(aResponse) {
	      if (!aResponse.error) {
	        this._isBlackBoxed = false;
	        if (this._activeThread) {
	          this._activeThread.emit("blackboxchange", this);
	        }
	      }
	      return aResponse;
	    }
	  }),
	
	  /**
	   * Get Executable Lines from a source
	   *
	   * @param aCallback Function
	   *        The callback function called when we receive the response from the server.
	   */
	  getExecutableLines: function(cb = noop) {
	    let packet = {
	      to: this._form.actor,
	      type: "getExecutableLines"
	    };
	
	    return this._client.request(packet).then(res => {
	      cb(res.lines);
	      return res.lines;
	    });
	  },
	
	  /**
	   * Get a long string grip for this SourceClient's source.
	   */
	  source: function(aCallback = noop) {
	    let packet = {
	      to: this._form.actor,
	      type: "source"
	    };
	    return this._client.request(packet).then(aResponse => {
	      return this._onSourceResponse(aResponse, aCallback);
	    });
	  },
	
	  /**
	   * Pretty print this source's text.
	   */
	  prettyPrint: function(aIndent, aCallback = noop) {
	    const packet = {
	      to: this._form.actor,
	      type: "prettyPrint",
	      indent: aIndent
	    };
	    return this._client.request(packet).then(aResponse => {
	      if (!aResponse.error) {
	        this._isPrettyPrinted = true;
	        this._activeThread._clearFrames();
	        this._activeThread.emit("prettyprintchange", this);
	      }
	      return this._onSourceResponse(aResponse, aCallback);
	    });
	  },
	
	  /**
	   * Stop pretty printing this source's text.
	   */
	  disablePrettyPrint: function(aCallback = noop) {
	    const packet = {
	      to: this._form.actor,
	      type: "disablePrettyPrint"
	    };
	    return this._client.request(packet).then(aResponse => {
	      if (!aResponse.error) {
	        this._isPrettyPrinted = false;
	        this._activeThread._clearFrames();
	        this._activeThread.emit("prettyprintchange", this);
	      }
	      return this._onSourceResponse(aResponse, aCallback);
	    });
	  },
	
	  _onSourceResponse: function(aResponse, aCallback) {
	    if (aResponse.error) {
	      aCallback(aResponse);
	      return aResponse;
	    }
	
	    if (typeof aResponse.source === "string") {
	      aCallback(aResponse);
	      return aResponse;
	    }
	
	    let { contentType, source } = aResponse;
	    let longString = this._activeThread.threadLongString(source);
	    return longString.substring(0, longString.length).then(function(aResponse) {
	      if (aResponse.error) {
	        aCallback(aResponse);
	        return aReponse;
	      }
	
	      let response = {
	        source: aResponse.substring,
	        contentType: contentType
	      };
	      aCallback(response);
	      return response;
	    });
	  },
	
	  /**
	   * Request to set a breakpoint in the specified location.
	   *
	   * @param object aLocation
	   *        The location and condition of the breakpoint in
	   *        the form of { line[, column, condition] }.
	   * @param function aOnResponse
	   *        Called with the thread's response.
	   */
	  setBreakpoint: function({ line, column, condition, noSliding }, aOnResponse = noop) {
	    // A helper function that sets the breakpoint.
	    let doSetBreakpoint = aCallback => {
	      let root = this._client.mainRoot;
	      let location = {
	        line: line,
	        column: column
	      };
	
	      let packet = {
	        to: this.actor,
	        type: "setBreakpoint",
	        location: location,
	        condition: condition,
	        noSliding: noSliding
	      };
	
	      // Backwards compatibility: send the breakpoint request to the
	      // thread if the server doesn't support Debugger.Source actors.
	      if (!root.traits.debuggerSourceActors) {
	        packet.to = this._activeThread.actor;
	        packet.location.url = this.url;
	      }
	
	      return this._client.request(packet).then(aResponse => {
	        // Ignoring errors, since the user may be setting a breakpoint in a
	        // dead script that will reappear on a page reload.
	        let bpClient;
	        if (aResponse.actor) {
	          bpClient = new BreakpointClient(
	            this._client,
	            this,
	            aResponse.actor,
	            location,
	            root.traits.conditionalBreakpoints ? condition : undefined
	          );
	        }
	        aOnResponse(aResponse, bpClient);
	        if (aCallback) {
	          aCallback();
	        }
	        return [aResponse, bpClient];
	      });
	    };
	
	    // If the debuggee is paused, just set the breakpoint.
	    if (this._activeThread.paused) {
	      return doSetBreakpoint();
	    }
	    // Otherwise, force a pause in order to set the breakpoint.
	    return this._activeThread.interrupt().then(aResponse => {
	      if (aResponse.error) {
	        // Can't set the breakpoint if pausing failed.
	        aOnResponse(aResponse);
	        return aResponse;
	      }
	
	      const { type, why } = aResponse;
	      const cleanUp = type == "paused" && why.type == "interrupted"
	            ? () => this._activeThread.resume()
	            : noop;
	
	      return doSetBreakpoint(cleanUp);
	    });
	  }
	};
	
	/**
	 * Breakpoint clients are used to remove breakpoints that are no longer used.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aSourceClient SourceClient
	 *        The source where this breakpoint exists
	 * @param aActor string
	 *        The actor ID for this breakpoint.
	 * @param aLocation object
	 *        The location of the breakpoint. This is an object with two properties:
	 *        url and line.
	 * @param aCondition string
	 *        The conditional expression of the breakpoint
	 */
	function BreakpointClient(aClient, aSourceClient, aActor, aLocation, aCondition) {
	  this._client = aClient;
	  this._actor = aActor;
	  this.location = aLocation;
	  this.location.actor = aSourceClient.actor;
	  this.location.url = aSourceClient.url;
	  this.source = aSourceClient;
	  this.request = this._client.request;
	
	  // The condition property should only exist if it's a truthy value
	  if (aCondition) {
	    this.condition = aCondition;
	  }
	}
	
	BreakpointClient.prototype = {
	
	  _actor: null,
	  get actor() { return this._actor; },
	  get _transport() { return this._client._transport; },
	
	  /**
	   * Remove the breakpoint from the server.
	   */
	  remove: DebuggerClient.requester({
	    type: "delete"
	  }, {
	    telemetry: "DELETE"
	  }),
	
	  /**
	   * Determines if this breakpoint has a condition
	   */
	  hasCondition: function() {
	    let root = this._client.mainRoot;
	    // XXX bug 990137: We will remove support for client-side handling of
	    // conditional breakpoints
	    if (root.traits.conditionalBreakpoints) {
	      return "condition" in this;
	    } else {
	      return "conditionalExpression" in this;
	    }
	  },
	
	  /**
	   * Get the condition of this breakpoint. Currently we have to
	   * support locally emulated conditional breakpoints until the
	   * debugger servers are updated (see bug 990137). We used a
	   * different property when moving it server-side to ensure that we
	   * are testing the right code.
	   */
	  getCondition: function() {
	    let root = this._client.mainRoot;
	    if (root.traits.conditionalBreakpoints) {
	      return this.condition;
	    } else {
	      return this.conditionalExpression;
	    }
	  },
	
	  /**
	   * Set the condition of this breakpoint
	   */
	  setCondition: function(gThreadClient, aCondition, noSliding) {
	    let root = this._client.mainRoot;
	    let deferred = promise.defer();
	
	    if (root.traits.conditionalBreakpoints) {
	      let info = {
	        line: this.location.line,
	        column: this.location.column,
	        condition: aCondition,
	        noSliding
	      };
	
	      // Remove the current breakpoint and add a new one with the
	      // condition.
	      this.remove(aResponse => {
	        if (aResponse && aResponse.error) {
	          deferred.reject(aResponse);
	          return;
	        }
	
	        this.source.setBreakpoint(info, (aResponse, aNewBreakpoint) => {
	          if (aResponse && aResponse.error) {
	            deferred.reject(aResponse);
	          } else {
	            deferred.resolve(aNewBreakpoint);
	          }
	        });
	      });
	    } else {
	      // The property shouldn't even exist if the condition is blank
	      if (aCondition === "") {
	        delete this.conditionalExpression;
	      }
	      else {
	        this.conditionalExpression = aCondition;
	      }
	      deferred.resolve(this);
	    }
	
	    return deferred.promise;
	  }
	};
	
	eventSource(BreakpointClient.prototype);
	
	/**
	 * Environment clients are used to manipulate the lexical environment actors.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aForm Object
	 *        The form sent across the remote debugging protocol.
	 */
	function EnvironmentClient(aClient, aForm) {
	  this._client = aClient;
	  this._form = aForm;
	  this.request = this._client.request;
	}
	exports.EnvironmentClient = EnvironmentClient;
	
	EnvironmentClient.prototype = {
	
	  get actor() {
	    return this._form.actor;
	  },
	  get _transport() { return this._client._transport; },
	
	  /**
	   * Fetches the bindings introduced by this lexical environment.
	   */
	  getBindings: DebuggerClient.requester({
	    type: "bindings"
	  }, {
	    telemetry: "BINDINGS"
	  }),
	
	  /**
	   * Changes the value of the identifier whose name is name (a string) to that
	   * represented by value (a grip).
	   */
	  assign: DebuggerClient.requester({
	    type: "assign",
	    name: args(0),
	    value: args(1)
	  }, {
	    telemetry: "ASSIGN"
	  })
	};
	
	eventSource(EnvironmentClient.prototype);


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";
	
	module.metadata = {
	  "stability": "unstable"
	};
	
	const UNCAUGHT_ERROR = 'An error event was emitted for which there was no listener.';
	const BAD_LISTENER = 'The event listener must be a function.';
	
	const { ns } = __webpack_require__(55);
	
	const event = ns();
	
	const EVENT_TYPE_PATTERN = /^on([A-Z]\w+$)/;
	exports.EVENT_TYPE_PATTERN = EVENT_TYPE_PATTERN;
	
	// Utility function to access given event `target` object's event listeners for
	// the specific event `type`. If listeners for this type does not exists they
	// will be created.
	const observers = function observers(target, type) {
	  if (!target) throw TypeError("Event target must be an object");
	  let listeners = event(target);
	  return type in listeners ? listeners[type] : listeners[type] = [];
	};
	
	/**
	 * Registers an event `listener` that is called every time events of
	 * specified `type` is emitted on the given event `target`.
	 * @param {Object} target
	 *    Event target object.
	 * @param {String} type
	 *    The type of event.
	 * @param {Function} listener
	 *    The listener function that processes the event.
	 */
	function on(target, type, listener) {
	  if (typeof(listener) !== 'function')
	    throw new Error(BAD_LISTENER);
	
	  let listeners = observers(target, type);
	  if (!~listeners.indexOf(listener))
	    listeners.push(listener);
	}
	exports.on = on;
	
	
	var onceWeakMap = new WeakMap();
	
	
	/**
	 * Registers an event `listener` that is called only the next time an event
	 * of the specified `type` is emitted on the given event `target`.
	 * @param {Object} target
	 *    Event target object.
	 * @param {String} type
	 *    The type of the event.
	 * @param {Function} listener
	 *    The listener function that processes the event.
	 */
	function once(target, type, listener) {
	  let replacement = function observer(...args) {
	    off(target, type, observer);
	    onceWeakMap.delete(listener);
	    listener.apply(target, args);
	  };
	  onceWeakMap.set(listener, replacement);
	  on(target, type, replacement);
	}
	exports.once = once;
	
	/**
	 * Execute each of the listeners in order with the supplied arguments.
	 * All the exceptions that are thrown by listeners during the emit
	 * are caught and can be handled by listeners of 'error' event. Thrown
	 * exceptions are passed as an argument to an 'error' event listener.
	 * If no 'error' listener is registered exception will be logged into an
	 * error console.
	 * @param {Object} target
	 *    Event target object.
	 * @param {String} type
	 *    The type of event.
	 * @params {Object|Number|String|Boolean} args
	 *    Arguments that will be passed to listeners.
	 */
	function emit (target, type, ...args) {
	  emitOnObject(target, type, target, ...args);
	}
	exports.emit = emit;
	
	/**
	 * A variant of emit that allows setting the this property for event listeners
	 */
	function emitOnObject(target, type, thisArg, ...args) {
	  let all = observers(target, '*').length;
	  let state = observers(target, type);
	  let listeners = state.slice();
	  let count = listeners.length;
	  let index = 0;
	
	  // If error event and there are no handlers (explicit or catch-all)
	  // then print error message to the console.
	  if (count === 0 && type === 'error' && all === 0)
	    console.exception(args[0]);
	  while (index < count) {
	    try {
	      let listener = listeners[index];
	      // Dispatch only if listener is still registered.
	      if (~state.indexOf(listener))
	        listener.apply(thisArg, args);
	    }
	    catch (error) {
	      // If exception is not thrown by a error listener and error listener is
	      // registered emit `error` event. Otherwise dump exception to the console.
	      if (type !== 'error') emit(target, 'error', error);
	      else console.exception(error);
	    }
	    index++;
	  }
	   // Also emit on `"*"` so that one could listen for all events.
	  if (type !== '*') emit(target, '*', type, ...args);
	}
	exports.emitOnObject = emitOnObject;
	
	/**
	 * Removes an event `listener` for the given event `type` on the given event
	 * `target`. If no `listener` is passed removes all listeners of the given
	 * `type`. If `type` is not passed removes all the listeners of the given
	 * event `target`.
	 * @param {Object} target
	 *    The event target object.
	 * @param {String} type
	 *    The type of event.
	 * @param {Function} listener
	 *    The listener function that processes the event.
	 */
	function off(target, type, listener) {
	  let length = arguments.length;
	  if (length === 3) {
	    if (onceWeakMap.has(listener)) {
	      listener = onceWeakMap.get(listener);
	      onceWeakMap.delete(listener);
	    }
	
	    let listeners = observers(target, type);
	    let index = listeners.indexOf(listener);
	    if (~index)
	      listeners.splice(index, 1);
	  }
	  else if (length === 2) {
	    observers(target, type).splice(0);
	  }
	  else if (length === 1) {
	    let listeners = event(target);
	    Object.keys(listeners).forEach(type => delete listeners[type]);
	  }
	}
	exports.off = off;
	
	/**
	 * Returns a number of event listeners registered for the given event `type`
	 * on the given event `target`.
	 */
	function count(target, type) {
	  return observers(target, type).length;
	}
	exports.count = count;
	
	/**
	 * Registers listeners on the given event `target` from the given `listeners`
	 * dictionary. Iterates over the listeners and if property name matches name
	 * pattern `onEventType` and property is a function, then registers it as
	 * an `eventType` listener on `target`.
	 *
	 * @param {Object} target
	 *    The type of event.
	 * @param {Object} listeners
	 *    Dictionary of listeners.
	 */
	function setListeners(target, listeners) {
	  Object.keys(listeners || {}).forEach(key => {
	    let match = EVENT_TYPE_PATTERN.exec(key);
	    let type = match && match[1].toLowerCase();
	    if (!type) return;
	
	    let listener = listeners[key];
	    if (typeof(listener) === 'function')
	      on(target, type, listener);
	  });
	}
	exports.setListeners = setListeners;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(51)(module)))

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	"use strict";
	
	module.metadata = {
	  "stability": "unstable"
	};
	
	const create = Object.create;
	const prototypeOf = Object.getPrototypeOf;
	
	/**
	 * Returns a new namespace, function that may can be used to access an
	 * namespaced object of the argument argument. Namespaced object are associated
	 * with owner objects via weak references. Namespaced objects inherit from the
	 * owners ancestor namespaced object. If owner's ancestor is `null` then
	 * namespaced object inherits from given `prototype`. Namespaces can be used
	 * to define internal APIs that can be shared via enclosing `namespace`
	 * function.
	 * @examples
	 *    const internals = ns();
	 *    internals(object).secret = secret;
	 */
	function ns() {
	  const map = new WeakMap();
	  return function namespace(target) {
	    if (!target)        // If `target` is not an object return `target` itself.
	      return target;
	    // If target has no namespaced object yet, create one that inherits from
	    // the target prototype's namespaced object.
	    if (!map.has(target))
	      map.set(target, create(namespace(prototypeOf(target) || null)));
	
	    return map.get(target);
	  };
	};
	
	// `Namespace` is a e4x function in the scope, so we export the function also as
	// `ns` as alias to avoid clashing.
	exports.ns = ns;
	exports.Namespace = ns;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(51)(module)))

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- js-indent-level: 2; indent-tabs-mode: nil -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	"use strict";
	
	const {Cc, Ci, Cu} = __webpack_require__(35);
	const DevToolsUtils = __webpack_require__(42);
	const EventEmitter = __webpack_require__(34);
	const promise = __webpack_require__(40);
	const {LongStringClient} = __webpack_require__(53);
	
	/**
	 * A WebConsoleClient is used as a front end for the WebConsoleActor that is
	 * created on the server, hiding implementation details.
	 *
	 * @param object aDebuggerClient
	 *        The DebuggerClient instance we live for.
	 * @param object aResponse
	 *        The response packet received from the "startListeners" request sent to
	 *        the WebConsoleActor.
	 */
	function WebConsoleClient(aDebuggerClient, aResponse)
	{
	  this._actor = aResponse.from;
	  this._client = aDebuggerClient;
	  this._longStrings = {};
	  this.traits = aResponse.traits || {};
	  this.events = [];
	  this._networkRequests = new Map();
	
	  this.pendingEvaluationResults = new Map();
	  this.onEvaluationResult = this.onEvaluationResult.bind(this);
	  this.onNetworkEvent = this._onNetworkEvent.bind(this);
	  this.onNetworkEventUpdate = this._onNetworkEventUpdate.bind(this);
	
	  this._client.addListener("evaluationResult", this.onEvaluationResult);
	  this._client.addListener("networkEvent", this.onNetworkEvent);
	  this._client.addListener("networkEventUpdate", this.onNetworkEventUpdate);
	  EventEmitter.decorate(this);
	}
	
	exports.WebConsoleClient = WebConsoleClient;
	
	WebConsoleClient.prototype = {
	  _longStrings: null,
	  traits: null,
	
	  /**
	   * Holds the network requests currently displayed by the Web Console. Each key
	   * represents the connection ID and the value is network request information.
	   * @private
	   * @type object
	   */
	  _networkRequests: null,
	
	  getNetworkRequest(actorId) {
	    return this._networkRequests.get(actorId);
	  },
	
	  hasNetworkRequest(actorId) {
	    return this._networkRequests.has(actorId);
	  },
	
	  removeNetworkRequest(actorId) {
	    this._networkRequests.delete(actorId);
	  },
	
	  getNetworkEvents() {
	    return this._networkRequests.values();
	  },
	
	  get actor() { return this._actor; },
	
	  /**
	   * The "networkEvent" message type handler. We redirect any message to
	   * the UI for displaying.
	   *
	   * @private
	   * @param string type
	   *        Message type.
	   * @param object packet
	   *        The message received from the server.
	   */
	  _onNetworkEvent: function (type, packet)
	  {
	    if (packet.from == this._actor) {
	      let actor = packet.eventActor;
	      let networkInfo = {
	        _type: "NetworkEvent",
	        timeStamp: actor.timeStamp,
	        node: null,
	        actor: actor.actor,
	        discardRequestBody: true,
	        discardResponseBody: true,
	        startedDateTime: actor.startedDateTime,
	        request: {
	          url: actor.url,
	          method: actor.method,
	        },
	        isXHR: actor.isXHR,
	        response: {},
	        timings: {},
	        updates: [], // track the list of network event updates
	        private: actor.private,
	        fromCache: actor.fromCache
	      };
	      this._networkRequests.set(actor.actor, networkInfo);
	
	      this.emit("networkEvent", networkInfo);
	    }
	  },
	
	  /**
	   * The "networkEventUpdate" message type handler. We redirect any message to
	   * the UI for displaying.
	   *
	   * @private
	   * @param string type
	   *        Message type.
	   * @param object packet
	   *        The message received from the server.
	   */
	  _onNetworkEventUpdate: function (type, packet)
	  {
	    let networkInfo = this.getNetworkRequest(packet.from);
	    if (!networkInfo) {
	      return;
	    }
	
	    networkInfo.updates.push(packet.updateType);
	
	    switch (packet.updateType) {
	      case "requestHeaders":
	        networkInfo.request.headersSize = packet.headersSize;
	        break;
	      case "requestPostData":
	        networkInfo.discardRequestBody = packet.discardRequestBody;
	        networkInfo.request.bodySize = packet.dataSize;
	        break;
	      case "responseStart":
	        networkInfo.response.httpVersion = packet.response.httpVersion;
	        networkInfo.response.status = packet.response.status;
	        networkInfo.response.statusText = packet.response.statusText;
	        networkInfo.response.headersSize = packet.response.headersSize;
	        networkInfo.response.remoteAddress = packet.response.remoteAddress;
	        networkInfo.response.remotePort = packet.response.remotePort;
	        networkInfo.discardResponseBody = packet.response.discardResponseBody;
	        break;
	      case "responseContent":
	        networkInfo.response.content = {
	          mimeType: packet.mimeType,
	        };
	        networkInfo.response.bodySize = packet.contentSize;
	        networkInfo.response.transferredSize = packet.transferredSize;
	        networkInfo.discardResponseBody = packet.discardResponseBody;
	        break;
	      case "eventTimings":
	        networkInfo.totalTime = packet.totalTime;
	        break;
	      case "securityInfo":
	        networkInfo.securityInfo = packet.state;
	        break;
	    }
	
	    this.emit("networkEventUpdate", {
	      packet: packet,
	      networkInfo
	    });
	  },
	
	  /**
	   * Retrieve the cached messages from the server.
	   *
	   * @see this.CACHED_MESSAGES
	   * @param array types
	   *        The array of message types you want from the server. See
	   *        this.CACHED_MESSAGES for known types.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getCachedMessages: function WCC_getCachedMessages(types, aOnResponse)
	  {
	    let packet = {
	      to: this._actor,
	      type: "getCachedMessages",
	      messageTypes: types,
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Inspect the properties of an object.
	   *
	   * @param string aActor
	   *        The WebConsoleObjectActor ID to send the request to.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  inspectObjectProperties:
	  function WCC_inspectObjectProperties(aActor, aOnResponse)
	  {
	    let packet = {
	      to: aActor,
	      type: "inspectProperties",
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Evaluate a JavaScript expression.
	   *
	   * @param string aString
	   *        The code you want to evaluate.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   * @param object [aOptions={}]
	   *        Options for evaluation:
	   *
	   *        - bindObjectActor: an ObjectActor ID. The OA holds a reference to
	   *        a Debugger.Object that wraps a content object. This option allows
	   *        you to bind |_self| to the D.O of the given OA, during string
	   *        evaluation.
	   *
	   *        See: Debugger.Object.executeInGlobalWithBindings() for information
	   *        about bindings.
	   *
	   *        Use case: the variable view needs to update objects and it does so
	   *        by knowing the ObjectActor it inspects and binding |_self| to the
	   *        D.O of the OA. As such, variable view sends strings like these for
	   *        eval:
	   *          _self["prop"] = value;
	   *
	   *        - frameActor: a FrameActor ID. The FA holds a reference to
	   *        a Debugger.Frame. This option allows you to evaluate the string in
	   *        the frame of the given FA.
	   *
	   *        - url: the url to evaluate the script as. Defaults to
	   *        "debugger eval code".
	   *
	   *        - selectedNodeActor: the NodeActor ID of the current selection in the
	   *        Inspector, if such a selection exists. This is used by helper functions
	   *        that can reference the currently selected node in the Inspector, like
	   *        $0.
	   */
	  evaluateJS: function WCC_evaluateJS(aString, aOnResponse, aOptions = {})
	  {
	    let packet = {
	      to: this._actor,
	      type: "evaluateJS",
	      text: aString,
	      bindObjectActor: aOptions.bindObjectActor,
	      frameActor: aOptions.frameActor,
	      url: aOptions.url,
	      selectedNodeActor: aOptions.selectedNodeActor,
	      selectedObjectActor: aOptions.selectedObjectActor,
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Evaluate a JavaScript expression asynchronously.
	   * See evaluateJS for parameter and response information.
	   */
	  evaluateJSAsync: function(aString, aOnResponse, aOptions = {})
	  {
	    // Pre-37 servers don't support async evaluation.
	    if (!this.traits.evaluateJSAsync) {
	      this.evaluateJS(aString, aOnResponse, aOptions);
	      return;
	    }
	
	    let packet = {
	      to: this._actor,
	      type: "evaluateJSAsync",
	      text: aString,
	      bindObjectActor: aOptions.bindObjectActor,
	      frameActor: aOptions.frameActor,
	      url: aOptions.url,
	      selectedNodeActor: aOptions.selectedNodeActor,
	      selectedObjectActor: aOptions.selectedObjectActor,
	    };
	
	    this._client.request(packet, response => {
	      // Null check this in case the client has been detached while waiting
	      // for a response.
	      if (this.pendingEvaluationResults) {
	        this.pendingEvaluationResults.set(response.resultID, aOnResponse);
	      }
	    });
	  },
	
	  /**
	   * Handler for the actors's unsolicited evaluationResult packet.
	   */
	  onEvaluationResult: function(aNotification, aPacket) {
	    // The client on the main thread can receive notification packets from
	    // multiple webconsole actors: the one on the main thread and the ones
	    // on worker threads.  So make sure we should be handling this request.
	    if (aPacket.from !== this._actor) {
	      return;
	    }
	
	    // Find the associated callback based on this ID, and fire it.
	    // In a sync evaluation, this would have already been called in
	    // direct response to the client.request function.
	    let onResponse = this.pendingEvaluationResults.get(aPacket.resultID);
	    if (onResponse) {
	      onResponse(aPacket);
	      this.pendingEvaluationResults.delete(aPacket.resultID);
	    } else {
	      DevToolsUtils.reportException("onEvaluationResult",
	        "No response handler for an evaluateJSAsync result (resultID: " + aPacket.resultID + ")");
	    }
	  },
	
	  /**
	   * Autocomplete a JavaScript expression.
	   *
	   * @param string aString
	   *        The code you want to autocomplete.
	   * @param number aCursor
	   *        Cursor location inside the string. Index starts from 0.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   * @param string aFrameActor
	   *        The id of the frame actor that made the call.
	   */
	  autocomplete: function WCC_autocomplete(aString, aCursor, aOnResponse, aFrameActor)
	  {
	    let packet = {
	      to: this._actor,
	      type: "autocomplete",
	      text: aString,
	      cursor: aCursor,
	      frameActor: aFrameActor,
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Clear the cache of messages (page errors and console API calls).
	   */
	  clearMessagesCache: function WCC_clearMessagesCache()
	  {
	    let packet = {
	      to: this._actor,
	      type: "clearMessagesCache",
	    };
	    this._client.request(packet);
	  },
	
	  /**
	   * Get Web Console-related preferences on the server.
	   *
	   * @param array aPreferences
	   *        An array with the preferences you want to retrieve.
	   * @param function [aOnResponse]
	   *        Optional function to invoke when the response is received.
	   */
	  getPreferences: function WCC_getPreferences(aPreferences, aOnResponse)
	  {
	    let packet = {
	      to: this._actor,
	      type: "getPreferences",
	      preferences: aPreferences,
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Set Web Console-related preferences on the server.
	   *
	   * @param object aPreferences
	   *        An object with the preferences you want to change.
	   * @param function [aOnResponse]
	   *        Optional function to invoke when the response is received.
	   */
	  setPreferences: function WCC_setPreferences(aPreferences, aOnResponse)
	  {
	    let packet = {
	      to: this._actor,
	      type: "setPreferences",
	      preferences: aPreferences,
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Retrieve the request headers from the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getRequestHeaders: function WCC_getRequestHeaders(aActor, aOnResponse)
	  {
	    let packet = {
	      to: aActor,
	      type: "getRequestHeaders",
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Retrieve the request cookies from the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getRequestCookies: function WCC_getRequestCookies(aActor, aOnResponse)
	  {
	    let packet = {
	      to: aActor,
	      type: "getRequestCookies",
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Retrieve the request post data from the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getRequestPostData: function WCC_getRequestPostData(aActor, aOnResponse)
	  {
	    let packet = {
	      to: aActor,
	      type: "getRequestPostData",
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Retrieve the response headers from the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getResponseHeaders: function WCC_getResponseHeaders(aActor, aOnResponse)
	  {
	    let packet = {
	      to: aActor,
	      type: "getResponseHeaders",
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Retrieve the response cookies from the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getResponseCookies: function WCC_getResponseCookies(aActor, aOnResponse)
	  {
	    let packet = {
	      to: aActor,
	      type: "getResponseCookies",
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Retrieve the response content from the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getResponseContent: function WCC_getResponseContent(aActor, aOnResponse)
	  {
	    let packet = {
	      to: aActor,
	      type: "getResponseContent",
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Retrieve the timing information for the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getEventTimings: function WCC_getEventTimings(aActor, aOnResponse)
	  {
	    let packet = {
	      to: aActor,
	      type: "getEventTimings",
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Retrieve the security information for the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getSecurityInfo: function WCC_getSecurityInfo(aActor, aOnResponse)
	  {
	    let packet = {
	      to: aActor,
	      type: "getSecurityInfo",
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Send a HTTP request with the given data.
	   *
	   * @param string aData
	   *        The details of the HTTP request.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  sendHTTPRequest: function WCC_sendHTTPRequest(aData, aOnResponse) {
	    let packet = {
	      to: this._actor,
	      type: "sendHTTPRequest",
	      request: aData
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Start the given Web Console listeners.
	   *
	   * @see this.LISTENERS
	   * @param array aListeners
	   *        Array of listeners you want to start. See this.LISTENERS for
	   *        known listeners.
	   * @param function aOnResponse
	   *        Function to invoke when the server response is received.
	   */
	  startListeners: function WCC_startListeners(aListeners, aOnResponse)
	  {
	    let packet = {
	      to: this._actor,
	      type: "startListeners",
	      listeners: aListeners,
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Stop the given Web Console listeners.
	   *
	   * @see this.LISTENERS
	   * @param array aListeners
	   *        Array of listeners you want to stop. See this.LISTENERS for
	   *        known listeners.
	   * @param function aOnResponse
	   *        Function to invoke when the server response is received.
	   */
	  stopListeners: function WCC_stopListeners(aListeners, aOnResponse)
	  {
	    let packet = {
	      to: this._actor,
	      type: "stopListeners",
	      listeners: aListeners,
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Return an instance of LongStringClient for the given long string grip.
	   *
	   * @param object aGrip
	   *        The long string grip returned by the protocol.
	   * @return object
	   *         The LongStringClient for the given long string grip.
	   */
	  longString: function WCC_longString(aGrip)
	  {
	    if (aGrip.actor in this._longStrings) {
	      return this._longStrings[aGrip.actor];
	    }
	
	    let client = new LongStringClient(this._client, aGrip);
	    this._longStrings[aGrip.actor] = client;
	    return client;
	  },
	
	  /**
	   * Close the WebConsoleClient. This stops all the listeners on the server and
	   * detaches from the console actor.
	   *
	   * @param function aOnResponse
	   *        Function to invoke when the server response is received.
	   */
	  detach: function WCC_detach(aOnResponse)
	  {
	    this._client.removeListener("evaluationResult", this.onEvaluationResult);
	    this._client.removeListener("networkEvent", this.onNetworkEvent);
	    this._client.removeListener("networkEventUpdate", this.onNetworkEventUpdate);
	    this.stopListeners(null, aOnResponse);
	    this._longStrings = null;
	    this._client = null;
	    this.pendingEvaluationResults.clear();
	    this.pendingEvaluationResults = null;
	    this.clearNetworkRequests();
	    this._networkRequests = null;
	  },
	
	  clearNetworkRequests: function () {
	    this._networkRequests.clear();
	  },
	
	  /**
	   * Fetches the full text of a LongString.
	   *
	   * @param object | string stringGrip
	   *        The long string grip containing the corresponding actor.
	   *        If you pass in a plain string (by accident or because you're lazy),
	   *        then a promise of the same string is simply returned.
	   * @return object Promise
	   *         A promise that is resolved when the full string contents
	   *         are available, or rejected if something goes wrong.
	   */
	  getString: function(stringGrip) {
	    // Make sure this is a long string.
	    if (typeof stringGrip != "object" || stringGrip.type != "longString") {
	      return promise.resolve(stringGrip); // Go home string, you're drunk.
	    }
	
	    // Fetch the long string only once.
	    if (stringGrip._fullText) {
	      return stringGrip._fullText.promise;
	    }
	
	    let deferred = stringGrip._fullText = promise.defer();
	    let { actor, initial, length } = stringGrip;
	    let longStringClient = this.longString(stringGrip);
	
	    longStringClient.substring(initial.length, length, aResponse => {
	      if (aResponse.error) {
	        DevToolsUtils.reportException("getString",
	            aResponse.error + ": " + aResponse.message);
	
	        deferred.reject(aResponse);
	        return;
	      }
	      deferred.resolve(initial + aResponse.substring);
	    });
	
	    return deferred.promise;
	  }
	};


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	const { Services } = __webpack_require__(28);
	const EventEmitter = __webpack_require__(34);
	
	/**
	 * Shortcuts for lazily accessing and setting various preferences.
	 * Usage:
	 *   let prefs = new Prefs("root.path.to.branch", {
	 *     myIntPref: ["Int", "leaf.path.to.my-int-pref"],
	 *     myCharPref: ["Char", "leaf.path.to.my-char-pref"],
	 *     myJsonPref: ["Json", "leaf.path.to.my-json-pref"],
	 *     myFloatPref: ["Float", "leaf.path.to.my-float-pref"]
	 *     ...
	 *   });
	 *
	 * Get/set:
	 *   prefs.myCharPref = "foo";
	 *   let aux = prefs.myCharPref;
	 *
	 * Observe:
	 *   prefs.registerObserver();
	 *   prefs.on("pref-changed", (prefName, prefValue) => {
	 *     ...
	 *   });
	 *
	 * @param string prefsRoot
	 *        The root path to the required preferences branch.
	 * @param object prefsBlueprint
	 *        An object containing { accessorName: [prefType, prefName] } keys.
	 */
	function PrefsHelper(prefsRoot = "", prefsBlueprint = {}) {
	  EventEmitter.decorate(this);
	
	  let cache = new Map();
	
	  for (let accessorName in prefsBlueprint) {
	    let [prefType, prefName] = prefsBlueprint[accessorName];
	    map(this, cache, accessorName, prefType, prefsRoot, prefName);
	  }
	
	  let observer = makeObserver(this, cache, prefsRoot, prefsBlueprint);
	  this.registerObserver = () => observer.register();
	  this.unregisterObserver = () => observer.unregister();
	}
	
	/**
	 * Helper method for getting a pref value.
	 *
	 * @param Map cache
	 * @param string prefType
	 * @param string prefsRoot
	 * @param string prefName
	 * @return any
	 */
	function get(cache, prefType, prefsRoot, prefName) {
	  let cachedPref = cache.get(prefName);
	  if (cachedPref !== undefined) {
	    return cachedPref;
	  }
	  let value = Services.prefs["get" + prefType + "Pref"](
	    [prefsRoot, prefName].join(".")
	  );
	  cache.set(prefName, value);
	  return value;
	}
	
	/**
	 * Helper method for setting a pref value.
	 *
	 * @param Map cache
	 * @param string prefType
	 * @param string prefsRoot
	 * @param string prefName
	 * @param any value
	 */
	function set(cache, prefType, prefsRoot, prefName, value) {
	  Services.prefs["set" + prefType + "Pref"](
	    [prefsRoot, prefName].join("."),
	    value
	  );
	  cache.set(prefName, value);
	}
	
	/**
	 * Maps a property name to a pref, defining lazy getters and setters.
	 * Supported types are "Bool", "Char", "Int", "Float" (sugar around "Char"
	 * type and casting), and "Json" (which is basically just sugar for "Char"
	 * using the standard JSON serializer).
	 *
	 * @param PrefsHelper self
	 * @param Map cache
	 * @param string accessorName
	 * @param string prefType
	 * @param string prefsRoot
	 * @param string prefName
	 * @param array serializer [optional]
	 */
	function map(self, cache, accessorName, prefType, prefsRoot, prefName,
	             serializer = { in: e => e, out: e => e }) {
	  if (prefName in self) {
	    throw new Error(`Can't use ${prefName} because it overrides a property` +
	                    "on the instance.");
	  }
	  if (prefType == "Json") {
	    map(self, cache, accessorName, "Char", prefsRoot, prefName, {
	      in: JSON.parse,
	      out: JSON.stringify
	    });
	    return;
	  }
	  if (prefType == "Float") {
	    map(self, cache, accessorName, "Char", prefsRoot, prefName, {
	      in: Number.parseFloat,
	      out: (n) => n + ""
	    });
	    return;
	  }
	
	  Object.defineProperty(self, accessorName, {
	    get: () => serializer.in(get(cache, prefType, prefsRoot, prefName)),
	    set: (e) => set(cache, prefType, prefsRoot, prefName, serializer.out(e))
	  });
	}
	
	/**
	 * Finds the accessor for the provided pref, based on the blueprint object
	 * used in the constructor.
	 *
	 * @param PrefsHelper self
	 * @param object prefsBlueprint
	 * @return string
	 */
	function accessorNameForPref(somePrefName, prefsBlueprint) {
	  for (let accessorName in prefsBlueprint) {
	    let [, prefName] = prefsBlueprint[accessorName];
	    if (somePrefName == prefName) {
	      return accessorName;
	    }
	  }
	  return "";
	}
	
	/**
	 * Creates a pref observer for `self`.
	 *
	 * @param PrefsHelper self
	 * @param Map cache
	 * @param string prefsRoot
	 * @param object prefsBlueprint
	 * @return object
	 */
	function makeObserver(self, cache, prefsRoot, prefsBlueprint) {
	  return {
	    register: function() {
	      this._branch = Services.prefs.getBranch(prefsRoot + ".");
	      this._branch.addObserver("", this, false);
	    },
	    unregister: function() {
	      this._branch.removeObserver("", this);
	    },
	    observe: function(subject, topic, prefName) {
	      // If this particular pref isn't handled by the blueprint object,
	      // even though it's in the specified branch, ignore it.
	      let accessorName = accessorNameForPref(prefName, prefsBlueprint);
	      if (!(accessorName in self)) {
	        return;
	      }
	      cache.delete(prefName);
	      self.emit("pref-changed", accessorName, self[accessorName]);
	    }
	  };
	}
	
	exports.PrefsHelper = PrefsHelper;


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	const promise = __webpack_require__(40);
	const EventEmitter = __webpack_require__(34);
	
	/* const { DebuggerServer } = require("../../server/main");*/
	const { DebuggerClient } = __webpack_require__(53);
	
	const targets = new WeakMap();
	const promiseTargets = new WeakMap();
	
	/**
	 * Functions for creating Targets
	 */
	exports.TargetFactory = {
	  /**
	   * Construct a Target
	   * @param {XULTab} tab
	   *        The tab to use in creating a new target.
	   *
	   * @return A target object
	   */
	  forTab: function(tab) {
	    let target = targets.get(tab);
	    if (target == null) {
	      target = new TabTarget(tab);
	      targets.set(tab, target);
	    }
	    return target;
	  },
	
	  /**
	   * Return a promise of a Target for a remote tab.
	   * @param {Object} options
	   *        The options object has the following properties:
	   *        {
	   *          form: the remote protocol form of a tab,
	   *          client: a DebuggerClient instance
	   *                  (caller owns this and is responsible for closing),
	   *          chrome: true if the remote target is the whole process
	   *        }
	   *
	   * @return A promise of a target object
	   */
	  forRemoteTab: function(options) {
	    let targetPromise = promiseTargets.get(options);
	    if (targetPromise == null) {
	      let target = new TabTarget(options);
	      targetPromise = target.makeRemote().then(() => target);
	      promiseTargets.set(options, targetPromise);
	    }
	    return targetPromise;
	  },
	
	  forWorker: function(workerClient) {
	    let target = targets.get(workerClient);
	    if (target == null) {
	      target = new WorkerTarget(workerClient);
	      targets.set(workerClient, target);
	    }
	    return target;
	  },
	
	  /**
	   * Creating a target for a tab that is being closed is a problem because it
	   * allows a leak as a result of coming after the close event which normally
	   * clears things up. This function allows us to ask if there is a known
	   * target for a tab without creating a target
	   * @return true/false
	   */
	  isKnownTab: function(tab) {
	    return targets.has(tab);
	  },
	};
	
	/**
	 * A Target represents something that we can debug. Targets are generally
	 * read-only. Any changes that you wish to make to a target should be done via
	 * a Tool that attaches to the target. i.e. a Target is just a pointer saying
	 * "the thing to debug is over there".
	 *
	 * Providing a generalized abstraction of a web-page or web-browser (available
	 * either locally or remotely) is beyond the scope of this class (and maybe
	 * also beyond the scope of this universe) However Target does attempt to
	 * abstract some common events and read-only properties common to many Tools.
	 *
	 * Supported read-only properties:
	 * - name, isRemote, url
	 *
	 * Target extends EventEmitter and provides support for the following events:
	 * - close: The target window has been closed. All tools attached to this
	 *          target should close. This event is not currently cancelable.
	 * - navigate: The target window has navigated to a different URL
	 *
	 * Optional events:
	 * - will-navigate: The target window will navigate to a different URL
	 * - hidden: The target is not visible anymore (for TargetTab, another tab is
	 *           selected)
	 * - visible: The target is visible (for TargetTab, tab is selected)
	 *
	 * Comparing Targets: 2 instances of a Target object can point at the same
	 * thing, so t1 !== t2 and t1 != t2 even when they represent the same object.
	 * To compare to targets use 't1.equals(t2)'.
	 */
	
	/**
	 * A TabTarget represents a page living in a browser tab. Generally these will
	 * be web pages served over http(s), but they don't have to be.
	 */
	function TabTarget(tab) {
	  EventEmitter.decorate(this);
	  this.destroy = this.destroy.bind(this);
	  this._handleThreadState = this._handleThreadState.bind(this);
	  this.on("thread-resumed", this._handleThreadState);
	  this.on("thread-paused", this._handleThreadState);
	  this.activeTab = this.activeConsole = null;
	  // Only real tabs need initialization here. Placeholder objects for remote
	  // targets will be initialized after a makeRemote method call.
	  if (tab && !["client", "form", "chrome"].every(tab.hasOwnProperty, tab)) {
	    this._tab = tab;
	    this._setupListeners();
	  } else {
	    this._form = tab.form;
	    this._client = tab.client;
	    this._chrome = tab.chrome;
	  }
	  // Default isTabActor to true if not explicitly specified
	  if (typeof tab.isTabActor == "boolean") {
	    this._isTabActor = tab.isTabActor;
	  } else {
	    this._isTabActor = true;
	  }
	}
	
	TabTarget.prototype = {
	  _webProgressListener: null,
	
	  /**
	   * Returns a promise for the protocol description from the root actor. Used
	   * internally with `target.actorHasMethod`. Takes advantage of caching if
	   * definition was fetched previously with the corresponding actor information.
	   * Actors are lazily loaded, so not only must the tool using a specific actor
	   * be in use, the actors are only registered after invoking a method (for
	   * performance reasons, added in bug 988237), so to use these actor detection
	   * methods, one must already be communicating with a specific actor of that
	   * type.
	   *
	   * Must be a remote target.
	   *
	   * @return {Promise}
	   * {
	   *   "category": "actor",
	   *   "typeName": "longstractor",
	   *   "methods": [{
	   *     "name": "substring",
	   *     "request": {
	   *       "type": "substring",
	   *       "start": {
	   *         "_arg": 0,
	   *         "type": "primitive"
	   *       },
	   *       "end": {
	   *         "_arg": 1,
	   *         "type": "primitive"
	   *       }
	   *     },
	   *     "response": {
	   *       "substring": {
	   *         "_retval": "primitive"
	   *       }
	   *     }
	   *   }],
	   *  "events": {}
	   * }
	   */
	  getActorDescription: function(actorName) {
	    if (!this.client) {
	      throw new Error("TabTarget#getActorDescription() can only be called on " +
	                      "remote tabs.");
	    }
	
	    let deferred = promise.defer();
	
	    if (this._protocolDescription &&
	        this._protocolDescription.types[actorName]) {
	      deferred.resolve(this._protocolDescription.types[actorName]);
	    } else {
	      this.client.mainRoot.protocolDescription(description => {
	        this._protocolDescription = description;
	        deferred.resolve(description.types[actorName]);
	      });
	    }
	
	    return deferred.promise;
	  },
	
	  /**
	   * Returns a boolean indicating whether or not the specific actor
	   * type exists. Must be a remote target.
	   *
	   * @param {String} actorName
	   * @return {Boolean}
	   */
	  hasActor: function(actorName) {
	    if (!this.client) {
	      throw new Error("TabTarget#hasActor() can only be called on remote " +
	                      "tabs.");
	    }
	    if (this.form) {
	      return !!this.form[actorName + "Actor"];
	    }
	    return false;
	  },
	
	  /**
	   * Queries the protocol description to see if an actor has
	   * an available method. The actor must already be lazily-loaded (read
	   * the restrictions in the `getActorDescription` comments),
	   * so this is for use inside of tool. Returns a promise that
	   * resolves to a boolean. Must be a remote target.
	   *
	   * @param {String} actorName
	   * @param {String} methodName
	   * @return {Promise}
	   */
	  actorHasMethod: function(actorName, methodName) {
	    if (!this.client) {
	      throw new Error("TabTarget#actorHasMethod() can only be called on " +
	                      "remote tabs.");
	    }
	    return this.getActorDescription(actorName).then(desc => {
	      if (desc && desc.methods) {
	        return !!desc.methods.find(method => method.name === methodName);
	      }
	      return false;
	    });
	  },
	
	  /**
	   * Returns a trait from the root actor.
	   *
	   * @param {String} traitName
	   * @return {Mixed}
	   */
	  getTrait: function(traitName) {
	    if (!this.client) {
	      throw new Error("TabTarget#getTrait() can only be called on remote " +
	                      "tabs.");
	    }
	
	    // If the targeted actor exposes traits and has a defined value for this
	    // traits, override the root actor traits
	    if (this.form.traits && traitName in this.form.traits) {
	      return this.form.traits[traitName];
	    }
	
	    return this.client.traits[traitName];
	  },
	
	  get tab() {
	    return this._tab;
	  },
	
	  get form() {
	    return this._form;
	  },
	
	  // Get a promise of the root form returned by a listTabs request. This promise
	  // is cached.
	  get root() {
	    if (!this._root) {
	      this._root = this._getRoot();
	    }
	    return this._root;
	  },
	
	  _getRoot: function() {
	    return new Promise((resolve, reject) => {
	      this.client.listTabs(response => {
	        if (response.error) {
	          reject(new Error(response.error + ": " + response.message));
	          return;
	        }
	
	        resolve(response);
	      });
	    });
	  },
	
	  get client() {
	    return this._client;
	  },
	
	  // Tells us if we are debugging content document
	  // or if we are debugging chrome stuff.
	  // Allows to controls which features are available against
	  // a chrome or a content document.
	  get chrome() {
	    return this._chrome;
	  },
	
	  // Tells us if the related actor implements TabActor interface
	  // and requires to call `attach` request before being used
	  // and `detach` during cleanup
	  get isTabActor() {
	    return this._isTabActor;
	  },
	
	  get window() {
	    // XXX - this is a footgun for e10s - there .contentWindow will be null,
	    // and even though .contentWindowAsCPOW *might* work, it will not work
	    // in all contexts.  Consumers of .window need to be refactored to not
	    // rely on this.
	    // if (Services.appinfo.processType != Ci.nsIXULRuntime.PROCESS_TYPE_DEFAULT) {
	    //   console.error("The .window getter on devtools' |target| object isn't " +
	    //                  "e10s friendly!\n" + Error().stack);
	    // }
	    // Be extra careful here, since this may be called by HS_getHudByWindow
	    // during shutdown.
	    if (this._tab && this._tab.linkedBrowser) {
	      return this._tab.linkedBrowser.contentWindow;
	    }
	    return null;
	  },
	
	  get name() {
	    if (this._tab && this._tab.linkedBrowser.contentDocument) {
	      return this._tab.linkedBrowser.contentDocument.title;
	    }
	    if (this.isAddon) {
	      return this._form.name;
	    }
	    return this._form.title;
	  },
	
	  get url() {
	    return this._tab ? this._tab.linkedBrowser.currentURI.spec :
	                       this._form.url;
	  },
	
	  get isRemote() {
	    return !this.isLocalTab;
	  },
	
	  get isAddon() {
	    return !!(this._form && this._form.actor &&
	              this._form.actor.match(/conn\d+\.addon\d+/));
	  },
	
	  get isLocalTab() {
	    return !!this._tab;
	  },
	
	  get isMultiProcess() {
	    return !this.window;
	  },
	
	  get isThreadPaused() {
	    return !!this._isThreadPaused;
	  },
	
	  /**
	   * Adds remote protocol capabilities to the target, so that it can be used
	   * for tools that support the Remote Debugging Protocol even for local
	   * connections.
	   */
	  makeRemote: function() {
	    if (this._remote) {
	      return this._remote.promise;
	    }
	
	    this._remote = promise.defer();
	
	    if (this.isLocalTab) {
	      // Since a remote protocol connection will be made, let's start the
	      // DebuggerServer here, once and for all tools.
	      if (!DebuggerServer.initialized) {
	        DebuggerServer.init();
	        DebuggerServer.addBrowserActors();
	      }
	
	      this._client = new DebuggerClient(DebuggerServer.connectPipe());
	      // A local TabTarget will never perform chrome debugging.
	      this._chrome = false;
	    }
	
	    this._setupRemoteListeners();
	
	    let attachTab = () => {
	      this._client.attachTab(this._form.actor, (response, tabClient) => {
	        if (!tabClient) {
	          this._remote.reject("Unable to attach to the tab");
	          return;
	        }
	        this.activeTab = tabClient;
	        this.threadActor = response.threadActor;
	        attachConsole();
	      });
	    };
	
	    let onConsoleAttached = (response, consoleClient) => {
	      if (!consoleClient) {
	        this._remote.reject("Unable to attach to the console");
	        return;
	      }
	      this.activeConsole = consoleClient;
	      this._remote.resolve(null);
	    };
	
	    let attachConsole = () => {
	      this._client.attachConsole(this._form.consoleActor,
	                                 [ "NetworkActivity" ],
	                                 onConsoleAttached);
	    };
	
	    if (this.isLocalTab) {
	      this._client.connect(() => {
	        this._client.getTab({ tab: this.tab }).then(response => {
	          this._form = response.tab;
	          attachTab();
	        });
	      });
	    } else if (this.isTabActor) {
	      // In the remote debugging case, the protocol connection will have been
	      // already initialized in the connection screen code.
	      attachTab();
	    } else {
	      // AddonActor and chrome debugging on RootActor doesn't inherits from
	      // TabActor and doesn't need to be attached.
	      attachConsole();
	    }
	
	    return this._remote.promise;
	  },
	
	  /**
	   * Listen to the different events.
	   */
	  _setupListeners: function() {
	    this._webProgressListener = new TabWebProgressListener(this);
	    this.tab.linkedBrowser.addProgressListener(this._webProgressListener);
	    this.tab.addEventListener("TabClose", this);
	    this.tab.parentNode.addEventListener("TabSelect", this);
	    this.tab.ownerDocument.defaultView.addEventListener("unload", this);
	  },
	
	  /**
	   * Teardown event listeners.
	   */
	  _teardownListeners: function() {
	    if (this._webProgressListener) {
	      this._webProgressListener.destroy();
	    }
	
	    this._tab.ownerDocument.defaultView.removeEventListener("unload", this);
	    this._tab.removeEventListener("TabClose", this);
	    this._tab.parentNode.removeEventListener("TabSelect", this);
	  },
	
	  /**
	   * Setup listeners for remote debugging, updating existing ones as necessary.
	   */
	  _setupRemoteListeners: function() {
	    this.client.addListener("closed", this.destroy);
	
	    this._onTabDetached = (aType, aPacket) => {
	      // We have to filter message to ensure that this detach is for this tab
	      if (aPacket.from == this._form.actor) {
	        this.destroy();
	      }
	    };
	    this.client.addListener("tabDetached", this._onTabDetached);
	
	    this._onTabNavigated = (aType, aPacket) => {
	      let event = Object.create(null);
	      event.url = aPacket.url;
	      event.title = aPacket.title;
	      event.nativeConsoleAPI = aPacket.nativeConsoleAPI;
	      event.isFrameSwitching = aPacket.isFrameSwitching;
	      // Send any stored event payload (DOMWindow or nsIRequest) for backwards
	      // compatibility with non-remotable tools.
	      if (aPacket.state == "start") {
	        event._navPayload = this._navRequest;
	        this.emit("will-navigate", event);
	        this._navRequest = null;
	      } else {
	        event._navPayload = this._navWindow;
	        this.emit("navigate", event);
	        this._navWindow = null;
	      }
	    };
	    this.client.addListener("tabNavigated", this._onTabNavigated);
	
	    this._onFrameUpdate = (aType, aPacket) => {
	      this.emit("frame-update", aPacket);
	    };
	    this.client.addListener("frameUpdate", this._onFrameUpdate);
	  },
	
	  /**
	   * Teardown listeners for remote debugging.
	   */
	  _teardownRemoteListeners: function() {
	    this.client.removeListener("closed", this.destroy);
	    this.client.removeListener("tabNavigated", this._onTabNavigated);
	    this.client.removeListener("tabDetached", this._onTabDetached);
	    this.client.removeListener("frameUpdate", this._onFrameUpdate);
	  },
	
	  /**
	   * Handle tabs events.
	   */
	  handleEvent: function(event) {
	    switch (event.type) {
	      case "TabClose":
	      case "unload":
	        this.destroy();
	        break;
	      case "TabSelect":
	        if (this.tab.selected) {
	          this.emit("visible", event);
	        } else {
	          this.emit("hidden", event);
	        }
	        break;
	    }
	  },
	
	  /**
	   * Handle script status.
	   */
	  _handleThreadState: function(event) {
	    switch (event) {
	      case "thread-resumed":
	        this._isThreadPaused = false;
	        break;
	      case "thread-paused":
	        this._isThreadPaused = true;
	        break;
	    }
	  },
	
	  /**
	   * Target is not alive anymore.
	   */
	  destroy: function() {
	    // If several things call destroy then we give them all the same
	    // destruction promise so we're sure to destroy only once
	    if (this._destroyer) {
	      return this._destroyer.promise;
	    }
	
	    this._destroyer = promise.defer();
	
	    // Before taking any action, notify listeners that destruction is imminent.
	    this.emit("close");
	
	    // First of all, do cleanup tasks that pertain to both remoted and
	    // non-remoted targets.
	    this.off("thread-resumed", this._handleThreadState);
	    this.off("thread-paused", this._handleThreadState);
	
	    if (this._tab) {
	      this._teardownListeners();
	    }
	
	    let cleanupAndResolve = () => {
	      this._cleanup();
	      this._destroyer.resolve(null);
	    };
	    // If this target was not remoted, the promise will be resolved before the
	    // function returns.
	    if (this._tab && !this._client) {
	      cleanupAndResolve();
	    } else if (this._client) {
	      // If, on the other hand, this target was remoted, the promise will be
	      // resolved after the remote connection is closed.
	      this._teardownRemoteListeners();
	
	      if (this.isLocalTab) {
	        // We started with a local tab and created the client ourselves, so we
	        // should close it.
	        this._client.close(cleanupAndResolve);
	      } else if (this.activeTab) {
	        // The client was handed to us, so we are not responsible for closing
	        // it. We just need to detach from the tab, if already attached.
	        // |detach| may fail if the connection is already dead, so proceed with
	        // cleanup directly after this.
	        this.activeTab.detach();
	        cleanupAndResolve();
	      } else {
	        cleanupAndResolve();
	      }
	    }
	
	    return this._destroyer.promise;
	  },
	
	  /**
	   * Clean up references to what this target points to.
	   */
	  _cleanup: function() {
	    if (this._tab) {
	      targets.delete(this._tab);
	    } else {
	      promiseTargets.delete(this._form);
	    }
	    this.activeTab = null;
	    this.activeConsole = null;
	    this._client = null;
	    this._tab = null;
	    this._form = null;
	    this._remote = null;
	  },
	
	  toString: function() {
	    let id = this._tab ? this._tab : (this._form && this._form.actor);
	    return `TabTarget:${id}`;
	  },
	};
	
	function WorkerTarget(workerClient) {
	  EventEmitter.decorate(this);
	  this._workerClient = workerClient;
	}
	
	/**
	 * A WorkerTarget represents a worker. Unlike TabTarget, which can represent
	 * either a local or remote tab, WorkerTarget always represents a remote worker.
	 * Moreover, unlike TabTarget, which is constructed with a placeholder object
	 * for remote tabs (from which a TabClient can then be lazily obtained),
	 * WorkerTarget is constructed with a WorkerClient directly.
	 *
	 * WorkerClient is designed to mimic the interface of TabClient as closely as
	 * possible. This allows us to debug workers as if they were ordinary tabs,
	 * requiring only minimal changes to the rest of the frontend.
	 */
	WorkerTarget.prototype = {
	  destroy: function() {},
	
	  get isRemote() {
	    return true;
	  },
	
	  get isTabActor() {
	    return true;
	  },
	
	  get url() {
	    return this._workerClient.url;
	  },
	
	  get isWorkerTarget() {
	    return true;
	  },
	
	  get form() {
	    return {
	      consoleActor: this._workerClient.consoleActor
	    };
	  },
	
	  get activeTab() {
	    return this._workerClient;
	  },
	
	  get client() {
	    return this._workerClient.client;
	  },
	
	  destroy: function() {},
	
	  hasActor: function(name) {
	    return false;
	  },
	
	  getTrait: function() {
	    return undefined;
	  },
	
	  makeRemote: function() {
	    return Promise.resolve();
	  }
	};


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	"use strict";
	
	const EventEmitter = __webpack_require__(34);
	
	function WebSocketDebuggerTransport(socket) {
	  EventEmitter.decorate(this);
	
	  this.active = false;
	  this.hooks = null;
	  this.socket = socket;
	}
	
	WebSocketDebuggerTransport.prototype = {
	  ready() {
	    if (this.active) {
	      return;
	    }
	
	    this.socket.addEventListener("message", this);
	    this.socket.addEventListener("close", this);
	
	    this.active = true;
	  },
	
	  send(object) {
	    this.emit("send", object);
	    if (this.socket) {
	      this.socket.send(JSON.stringify(object));
	    }
	  },
	
	  startBulkSend() {
	    throw new Error("Bulk send is not supported by WebSocket transport");
	  },
	
	  close() {
	    this.emit("close");
	    this.active = false;
	
	    this.socket.removeEventListener("message", this);
	    this.socket.removeEventListener("close", this);
	    this.socket.close();
	    this.socket = null;
	
	    if (this.hooks) {
	      this.hooks.onClosed();
	      this.hooks = null;
	    }
	  },
	
	  handleEvent(event) {
	    switch (event.type) {
	      case "message":
	        this.onMessage(event);
	        break;
	      case "close":
	        this.close();
	        break;
	    }
	  },
	
	  onMessage({ data }) {
	    if (typeof data !== "string") {
	      throw new Error("Binary messages are not supported by WebSocket transport");
	    }
	
	    let object = JSON.parse(data);
	    this.emit("packet", object);
	    if (this.hooks) {
	      this.hooks.onPacket(object);
	    }
	  },
	};
	
	module.exports = WebSocketDebuggerTransport;


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	"use strict";
	
	const EventEmitter = __webpack_require__(34);
	
	/**
	 * A partial implementation of the Menu API provided by electron:
	 * https://github.com/electron/electron/blob/master/docs/api/menu.md.
	 *
	 * Extra features:
	 *  - Emits an 'open' and 'close' event when the menu is opened/closed
	
	 * @param String id (non standard)
	 *        Needed so tests can confirm the XUL implementation is working
	 */
	function Menu({ id = null } = {}) {
	  this.menuitems = [];
	  this.id = id;
	
	  Object.defineProperty(this, "items", {
	    get() {
	      return this.menuitems;
	    }
	  });
	
	  EventEmitter.decorate(this);
	}
	
	/**
	 * Add an item to the end of the Menu
	 *
	 * @param {MenuItem} menuItem
	 */
	Menu.prototype.append = function (menuItem) {
	  this.menuitems.push(menuItem);
	};
	
	/**
	 * Add an item to a specified position in the menu
	 *
	 * @param {int} pos
	 * @param {MenuItem} menuItem
	 */
	Menu.prototype.insert = function (pos, menuItem) {
	  throw Error("Not implemented");
	};
	
	/**
	 * Show the Menu at a specified location on the screen
	 *
	 * Missing features:
	 *   - browserWindow - BrowserWindow (optional) - Default is null.
	 *   - positioningItem Number - (optional) OS X
	 *
	 * @param {int} screenX
	 * @param {int} screenY
	 * @param Toolbox toolbox (non standard)
	 *        Needed so we in which window to inject XUL
	 */
	Menu.prototype.popup = function (screenX, screenY, toolbox) {
	  let doc = toolbox.doc;
	  let popupset = doc.querySelector("popupset");
	  // See bug 1285229, on Windows, opening the same popup multiple times in a
	  // row ends up duplicating the popup. The newly inserted popup doesn't
	  // dismiss the old one. So remove any previously displayed popup before
	  // opening a new one.
	  let popup = popupset.querySelector("menupopup[menu-api=\"true\"]");
	  if (popup) {
	    popup.hidePopup();
	  }
	
	  popup = this.createPopup(doc)
	  popup.setAttribute("menu-api", "true");
	
	  if (this.id) {
	    popup.id = this.id;
	  }
	  this._createMenuItems(popup);
	
	  // Remove the menu from the DOM once it's hidden.
	  popup.addEventListener("popuphidden", (e) => {
	    if (e.target === popup) {
	      popup.remove();
	      this.emit("close", popup);
	    }
	  });
	
	  popup.addEventListener("popupshown", (e) => {
	    if (e.target === popup) {
	      this.emit("open", popup);
	    }
	  });
	
	  popupset.appendChild(popup);
	  popup.openPopupAtScreen(screenX, screenY, true);
	};
	
	Menu.prototype.createPopup = function(doc) {
	  return doc.createElement("menupopup");
	}
	
	Menu.prototype._createMenuItems = function (parent) {
	  let doc = parent.ownerDocument;
	  this.menuitems.forEach(item => {
	    if (!item.visible) {
	      return;
	    }
	
	    if (item.submenu) {
	      let menupopup = doc.createElement("menupopup");
	      item.submenu._createMenuItems(menupopup);
	
	      let menu = doc.createElement("menu");
	      menu.appendChild(menupopup);
	      menu.setAttribute("label", item.label);
	      if (item.disabled) {
	        menu.setAttribute("disabled", "true");
	      }
	      if (item.accesskey) {
	        menu.setAttribute("accesskey", item.accesskey);
	      }
	      if (item.id) {
	        menu.id = item.id;
	      }
	      parent.appendChild(menu);
	    } else if (item.type === "separator") {
	      let menusep = doc.createElement("menuseparator");
	      parent.appendChild(menusep);
	    } else {
	      let menuitem = doc.createElement("menuitem");
	      menuitem.setAttribute("label", item.label);
	      menuitem.textContent = item.label;
	      menuitem.addEventListener("command", () => item.click());
	
	      if (item.type === "checkbox") {
	        menuitem.setAttribute("type", "checkbox");
	      }
	      if (item.type === "radio") {
	        menuitem.setAttribute("type", "radio");
	      }
	      if (item.disabled) {
	        menuitem.setAttribute("disabled", "true");
	      }
	      if (item.checked) {
	        menuitem.setAttribute("checked", "true");
	      }
	      if (item.accesskey) {
	        menuitem.setAttribute("accesskey", item.accesskey);
	      }
	      if (item.id) {
	        menuitem.id = item.id;
	      }
	
	      parent.appendChild(menuitem);
	    }
	  });
	};
	
	Menu.setApplicationMenu = () => {
	  throw Error("Not implemented");
	};
	
	Menu.sendActionToFirstResponder = () => {
	  throw Error("Not implemented");
	};
	
	Menu.buildFromTemplate = () => {
	  throw Error("Not implemented");
	};
	
	module.exports = Menu;


/***/ },
/* 61 */
/***/ function(module, exports) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	"use strict";
	
	/**
	 * A partial implementation of the MenuItem API provided by electron:
	 * https://github.com/electron/electron/blob/master/docs/api/menu-item.md.
	 *
	 * Missing features:
	 *   - id String - Unique within a single menu. If defined then it can be used
	 *                 as a reference to this item by the position attribute.
	 *   - role String - Define the action of the menu item; when specified the
	 *                   click property will be ignored
	 *   - sublabel String
	 *   - accelerator Accelerator
	 *   - icon NativeImage
	 *   - position String - This field allows fine-grained definition of the
	 *                       specific location within a given menu.
	 *
	 * Implemented features:
	 *  @param Object options
	 *    Function click
	 *      Will be called with click(menuItem, browserWindow) when the menu item
	 *       is clicked
	 *    String type
	 *      Can be normal, separator, submenu, checkbox or radio
	 *    String label
	 *    Boolean enabled
	 *      If false, the menu item will be greyed out and unclickable.
	 *    Boolean checked
	 *      Should only be specified for checkbox or radio type menu items.
	 *    Menu submenu
	 *      Should be specified for submenu type menu items. If submenu is specified,
	 *      the type: 'submenu' can be omitted. If the value is not a Menu then it
	 *      will be automatically converted to one using Menu.buildFromTemplate.
	 *    Boolean visible
	 *      If false, the menu item will be entirely hidden.
	 */
	function MenuItem({
	    accesskey = null,
	    checked = false,
	    click = () => {},
	    disabled = false,
	    label = "",
	    id = null,
	    submenu = null,
	    type = "normal",
	    visible = true,
	} = { }) {
	  this.accesskey = accesskey;
	  this.checked = checked;
	  this.click = click;
	  this.disabled = disabled;
	  this.id = id;
	  this.label = label;
	  this.submenu = submenu;
	  this.type = type;
	  this.visible = visible;
	}
	
	module.exports = MenuItem;


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
	 * You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	const { DOM: dom, createClass, createFactory, PropTypes } = __webpack_require__(2);
	// const { ViewHelpers } =
	// require("resource://devtools/client/shared/widgets/ViewHelpers.jsm");
	// let { VirtualScroll } = require("react-virtualized");
	// VirtualScroll = createFactory(VirtualScroll);
	
	const AUTO_EXPAND_DEPTH = 0; // depth
	
	/**
	 * An arrow that displays whether its node is expanded (▼) or collapsed
	 * (▶). When its node has no children, it is hidden.
	 */
	const ArrowExpander = createFactory(createClass({
	  displayName: "ArrowExpander",
	
	  shouldComponentUpdate(nextProps, nextState) {
	    return this.props.item !== nextProps.item
	      || this.props.visible !== nextProps.visible
	      || this.props.expanded !== nextProps.expanded;
	  },
	
	  render() {
	    const attrs = {
	      className: "arrow theme-twisty",
	      onClick: this.props.expanded
	        ? () => this.props.onCollapse(this.props.item)
	        : e => this.props.onExpand(this.props.item, e.altKey)
	    };
	
	    if (this.props.expanded) {
	      attrs.className += " open";
	    }
	
	    if (!this.props.visible) {
	      attrs.style = Object.assign({}, this.props.style || {}, {
	        visibility: "hidden"
	      });
	    }
	
	    return dom.div(attrs, this.props.children);
	  }
	}));
	
	const TreeNode = createFactory(createClass({
	  displayName: "TreeNode",
	
	  componentDidMount() {
	    if (this.props.focused) {
	      this.refs.button.focus();
	    }
	  },
	
	  componentDidUpdate() {
	    if (this.props.focused) {
	      this.refs.button.focus();
	    }
	  },
	
	  shouldComponentUpdate(nextProps) {
	    return this.props.item !== nextProps.item ||
	      this.props.focused !== nextProps.focused ||
	      this.props.expanded !== nextProps.expanded;
	  },
	
	  render() {
	    const arrow = ArrowExpander({
	      item: this.props.item,
	      expanded: this.props.expanded,
	      visible: this.props.hasChildren,
	      onExpand: this.props.onExpand,
	      onCollapse: this.props.onCollapse,
	    });
	
	    let isOddRow = this.props.index % 2;
	    return dom.div(
	      {
	        className: `tree-node div ${isOddRow ? "tree-node-odd" : ""}`,
	        onFocus: this.props.onFocus,
	        onClick: this.props.onFocus,
	        onBlur: this.props.onBlur,
	        style: {
	          padding: 0,
	          margin: 0
	        }
	      },
	
	      this.props.renderItem(this.props.item,
	                            this.props.depth,
	                            this.props.focused,
	                            arrow,
	                            this.props.expanded),
	
	      // XXX: OSX won't focus/blur regular elements even if you set tabindex
	      // unless there is an input/button child.
	      dom.button(this._buttonAttrs)
	    );
	  },
	
	  _buttonAttrs: {
	    ref: "button",
	    style: {
	      opacity: 0,
	      width: "0 !important",
	      height: "0 !important",
	      padding: "0 !important",
	      outline: "none",
	      MozAppearance: "none",
	      // XXX: Despite resetting all of the above properties (and margin), the
	      // button still ends up with ~79px width, so we set a large negative
	      // margin to completely hide it.
	      MozMarginStart: "-1000px !important",
	    }
	  }
	}));
	
	/**
	 * Create a function that calls the given function `fn` only once per animation
	 * frame.
	 *
	 * @param {Function} fn
	 * @returns {Function}
	 */
	function oncePerAnimationFrame(fn) {
	  let animationId = null;
	  let argsToPass = null;
	  return function(...args) {
	    argsToPass = args;
	    if (animationId !== null) {
	      return;
	    }
	
	    animationId = requestAnimationFrame(() => {
	      fn.call(this, ...argsToPass);
	      animationId = null;
	      argsToPass = null;
	    });
	  };
	}
	
	const NUMBER_OF_OFFSCREEN_ITEMS = 1;
	
	/**
	 * A generic tree component. See propTypes for the public API.
	 *
	 * @see `devtools/client/memory/components/test/mochitest/head.js` for usage
	 * @see `devtools/client/memory/components/heap.js` for usage
	 */
	const Tree = module.exports = createClass({
	  displayName: "Tree",
	
	  propTypes: {
	    // Required props
	
	    // A function to get an item's parent, or null if it is a root.
	    getParent: PropTypes.func.isRequired,
	    // A function to get an item's children.
	    getChildren: PropTypes.func.isRequired,
	    // A function which takes an item and ArrowExpander and returns a
	    // component.
	    renderItem: PropTypes.func.isRequired,
	    // A function which returns the roots of the tree (forest).
	    getRoots: PropTypes.func.isRequired,
	    // A function to get a unique key for the given item.
	    getKey: PropTypes.func.isRequired,
	    // A function to get whether an item is expanded or not. If an item is not
	    // expanded, then it must be collapsed.
	    isExpanded: PropTypes.func.isRequired,
	    // The height of an item in the tree including margin and padding, in
	    // pixels.
	    itemHeight: PropTypes.number.isRequired,
	
	    // Optional props
	
	    // The currently focused item, if any such item exists.
	    focused: PropTypes.any,
	    // Handle when a new item is focused.
	    onFocus: PropTypes.func,
	    // The depth to which we should automatically expand new items.
	    autoExpandDepth: PropTypes.number,
	    // Should auto expand all new items or just the new items under the first
	    // root item.
	    autoExpandAll: PropTypes.bool,
	    // Optional event handlers for when items are expanded or collapsed.
	    onExpand: PropTypes.func,
	    onCollapse: PropTypes.func,
	  },
	
	  getDefaultProps() {
	    return {
	      autoExpandDepth: AUTO_EXPAND_DEPTH,
	      autoExpandAll: true
	    };
	  },
	
	  getInitialState() {
	    return {
	      scroll: 0,
	      height: window.innerHeight,
	      seen: new Set(),
	    };
	  },
	
	  componentDidMount() {
	    window.addEventListener("resize", this._updateHeight);
	    this._autoExpand(this.props);
	    this._updateHeight();
	  },
	
	  componentWillUnmount() {
	    window.removeEventListener("resize", this._updateHeight);
	  },
	
	  componentWillReceiveProps(nextProps) {
	    this._autoExpand(nextProps);
	    this._updateHeight();
	  },
	
	  _autoExpand(props) {
	    if (!props.autoExpandDepth) {
	      return;
	    }
	
	    // Automatically expand the first autoExpandDepth levels for new items. Do
	    // not use the usual DFS infrastructure because we don't want to ignore
	    // collapsed nodes.
	    const autoExpand = (item, currentDepth) => {
	      if (currentDepth >= props.autoExpandDepth ||
	          this.state.seen.has(item)) {
	        return;
	      }
	
	      props.onExpand(item);
	      this.state.seen.add(item);
	
	      const children = props.getChildren(item);
	      const length = children.length;
	      for (let i = 0; i < length; i++) {
	        autoExpand(children[i], currentDepth + 1);
	      }
	    };
	
	    const roots = props.getRoots();
	    const length = roots.length;
	    if (props.autoExpandAll) {
	      for (let i = 0; i < length; i++) {
	        autoExpand(roots[i], 0);
	      }
	    } else if (length != 0) {
	      autoExpand(roots[0], 0);
	    }
	  },
	
	  render() {
	    const traversal = this._dfsFromRoots();
	
	    // Remove `NUMBER_OF_OFFSCREEN_ITEMS` from `begin` and add `2 *
	    // NUMBER_OF_OFFSCREEN_ITEMS` to `end` so that the top and bottom of the
	    // page are filled with the `NUMBER_OF_OFFSCREEN_ITEMS` previous and next
	    // items respectively, rather than whitespace if the item is not in full
	    // view.
	    // const begin = Math.max(((this.state.scroll / this.props.itemHeight) | 0) - NUMBER_OF_OFFSCREEN_ITEMS, 0);
	    // const end = begin + (2 * NUMBER_OF_OFFSCREEN_ITEMS) + ((this.state.height / this.props.itemHeight) | 0);
	    // const toRender = traversal;
	
	    // const nodes = [
	    //   dom.div({
	    //     key: "top-spacer",
	    //     style: {
	    //       padding: 0,
	    //       margin: 0,
	    //       height: begin * this.props.itemHeight + "px"
	    //     }
	    //   })
	    // ];
	
	    const renderItem = i => {
	      let { item, depth } = traversal[i];
	      return TreeNode({
	        key: this.props.getKey(item, i),
	        index: i,
	        item: item,
	        depth: depth,
	        renderItem: this.props.renderItem,
	        focused: this.props.focused === item,
	        expanded: this.props.isExpanded(item),
	        hasChildren: !!this.props.getChildren(item).length,
	        onExpand: this._onExpand,
	        onCollapse: this._onCollapse,
	        onFocus: () => this._focus(i, item),
	      });
	    };
	
	    // nodes.push(dom.div({
	    //   key: "bottom-spacer",
	    //   style: {
	    //     padding: 0,
	    //     margin: 0,
	    //     height: (traversal.length - 1 - end) * this.props.itemHeight + "px"
	    //   }
	    // }));
	
	    const style = Object.assign({}, this.props.style || {}, {
	      padding: 0,
	      margin: 0
	    });
	
	    return dom.div(
	      {
	        className: "tree",
	        ref: "tree",
	        onKeyDown: this._onKeyDown,
	        onKeyPress: this._preventArrowKeyScrolling,
	        onKeyUp: this._preventArrowKeyScrolling,
	        onScroll: this._onScroll,
	        style
	      },
	      // VirtualScroll({
	      //   width: this.props.width,
	      //   height: this.props.height,
	      //   rowsCount: traversal.length,
	      //   rowHeight: this.props.itemHeight,
	      //   rowRenderer: renderItem
	      // })
	      traversal.map((v, i) => renderItem(i))
	    );
	  },
	
	  _preventArrowKeyScrolling(e) {
	    switch (e.key) {
	      case "ArrowUp":
	      case "ArrowDown":
	      case "ArrowLeft":
	      case "ArrowRight":
	        e.preventDefault();
	        e.stopPropagation();
	        if (e.nativeEvent) {
	          if (e.nativeEvent.preventDefault) {
	            e.nativeEvent.preventDefault();
	          }
	          if (e.nativeEvent.stopPropagation) {
	            e.nativeEvent.stopPropagation();
	          }
	        }
	    }
	  },
	
	  /**
	   * Updates the state's height based on clientHeight.
	   */
	  _updateHeight() {
	    this.setState({
	      height: this.refs.tree.clientHeight
	    });
	  },
	
	  /**
	   * Perform a pre-order depth-first search from item.
	   */
	  _dfs(item, maxDepth = Infinity, traversal = [], _depth = 0) {
	    traversal.push({ item, depth: _depth });
	
	    if (!this.props.isExpanded(item)) {
	      return traversal;
	    }
	
	    const nextDepth = _depth + 1;
	
	    if (nextDepth > maxDepth) {
	      return traversal;
	    }
	
	    const children = this.props.getChildren(item);
	    const length = children.length;
	    for (let i = 0; i < length; i++) {
	      this._dfs(children[i], maxDepth, traversal, nextDepth);
	    }
	
	    return traversal;
	  },
	
	  /**
	   * Perform a pre-order depth-first search over the whole forest.
	   */
	  _dfsFromRoots(maxDepth = Infinity) {
	    const traversal = [];
	
	    const roots = this.props.getRoots();
	    const length = roots.length;
	    for (let i = 0; i < length; i++) {
	      this._dfs(roots[i], maxDepth, traversal);
	    }
	
	    return traversal;
	  },
	
	  /**
	   * Expands current row.
	   *
	   * @param {Object} item
	   * @param {Boolean} expandAllChildren
	   */
	  _onExpand: oncePerAnimationFrame(function(item, expandAllChildren) {
	    if (this.props.onExpand) {
	      this.props.onExpand(item);
	
	      if (expandAllChildren) {
	        const children = this._dfs(item);
	        const length = children.length;
	        for (let i = 0; i < length; i++) {
	          this.props.onExpand(children[i].item);
	        }
	      }
	    }
	  }),
	
	  /**
	   * Collapses current row.
	   *
	   * @param {Object} item
	   */
	  _onCollapse: oncePerAnimationFrame(function(item) {
	    if (this.props.onCollapse) {
	      this.props.onCollapse(item);
	    }
	  }),
	
	  /**
	   * Sets the passed in item to be the focused item.
	   *
	   * @param {Number} index
	   *        The index of the item in a full DFS traversal (ignoring collapsed
	   *        nodes). Ignored if `item` is undefined.
	   *
	   * @param {Object|undefined} item
	   *        The item to be focused, or undefined to focus no item.
	   */
	  _focus(index, item) {
	    if (item !== undefined) {
	      const itemStartPosition = index * this.props.itemHeight;
	      const itemEndPosition = (index + 1) * this.props.itemHeight;
	
	      // Note that if the height of the viewport (this.state.height) is less than
	      // `this.props.itemHeight`, we could accidentally try and scroll both up and
	      // down in a futile attempt to make both the item's start and end positions
	      // visible. Instead, give priority to the start of the item by checking its
	      // position first, and then using an "else if", rather than a separate "if",
	      // for the end position.
	      if (this.state.scroll > itemStartPosition) {
	        this.refs.tree.scrollTop = itemStartPosition;
	      } else if ((this.state.scroll + this.state.height) < itemEndPosition) {
	        this.refs.tree.scrollTop = itemEndPosition - this.state.height;
	      }
	    }
	
	    if (this.props.onFocus) {
	      this.props.onFocus(item);
	    }
	  },
	
	  /**
	   * Sets the state to have no focused item.
	   */
	  _onBlur() {
	    this._focus(0, undefined);
	  },
	
	  /**
	   * Fired on a scroll within the tree's container, updates
	   * the stored position of the view port to handle virtual view rendering.
	   *
	   * @param {Event} e
	   */
	  _onScroll: oncePerAnimationFrame(function(e) {
	    this.setState({
	      scroll: Math.max(this.refs.tree.scrollTop, 0),
	      height: this.refs.tree.clientHeight
	    });
	  }),
	
	  /**
	   * Handles key down events in the tree's container.
	   *
	   * @param {Event} e
	   */
	  _onKeyDown(e) {
	    if (this.props.focused == null) {
	      return;
	    }
	
	    // Allow parent nodes to use navigation arrows with modifiers.
	    if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
	      return;
	    }
	
	    this._preventArrowKeyScrolling(e);
	
	    switch (e.key) {
	      case "ArrowUp":
	        this._focusPrevNode();
	        return;
	
	      case "ArrowDown":
	        this._focusNextNode();
	        return;
	
	      case "ArrowLeft":
	        if (this.props.isExpanded(this.props.focused)
	            && this.props.getChildren(this.props.focused).length) {
	          this._onCollapse(this.props.focused);
	        } else {
	          this._focusParentNode();
	        }
	        return;
	
	      case "ArrowRight":
	        if (!this.props.isExpanded(this.props.focused)) {
	          this._onExpand(this.props.focused);
	        } else {
	          this._focusNextNode();
	        }
	        return;
	    }
	  },
	
	  /**
	   * Sets the previous node relative to the currently focused item, to focused.
	   */
	  _focusPrevNode: oncePerAnimationFrame(function() {
	    // Start a depth first search and keep going until we reach the currently
	    // focused node. Focus the previous node in the DFS, if it exists. If it
	    // doesn't exist, we're at the first node already.
	
	    let prev;
	    let prevIndex;
	
	    const traversal = this._dfsFromRoots();
	    const length = traversal.length;
	    for (let i = 0; i < length; i++) {
	      const item = traversal[i].item;
	      if (item === this.props.focused) {
	        break;
	      }
	      prev = item;
	      prevIndex = i;
	    }
	
	    if (prev === undefined) {
	      return;
	    }
	
	    this._focus(prevIndex, prev);
	  }),
	
	  /**
	   * Handles the down arrow key which will focus either the next child
	   * or sibling row.
	   */
	  _focusNextNode: oncePerAnimationFrame(function() {
	    // Start a depth first search and keep going until we reach the currently
	    // focused node. Focus the next node in the DFS, if it exists. If it
	    // doesn't exist, we're at the last node already.
	
	    const traversal = this._dfsFromRoots();
	    const length = traversal.length;
	    let i = 0;
	
	    while (i < length) {
	      if (traversal[i].item === this.props.focused) {
	        break;
	      }
	      i++;
	    }
	
	    if (i + 1 < traversal.length) {
	      this._focus(i + 1, traversal[i + 1].item);
	    }
	  }),
	
	  /**
	   * Handles the left arrow key, going back up to the current rows'
	   * parent row.
	   */
	  _focusParentNode: oncePerAnimationFrame(function() {
	    const parent = this.props.getParent(this.props.focused);
	    if (!parent) {
	      return;
	    }
	
	    const traversal = this._dfsFromRoots();
	    const length = traversal.length;
	    let parentIndex = 0;
	    for (; parentIndex < length; parentIndex++) {
	      if (traversal[parentIndex].item === parent) {
	        break;
	      }
	    }
	
	    this._focus(parentIndex, parent);
	  }),
	});


/***/ },
/* 63 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";
	
	// const { LocalizationHelper } = require("devtools/shared/l10n");
	//
	// const l10n = new LocalizationHelper("devtools/client/locales/components.properties");
	// const UNKNOWN_SOURCE_STRING = l10n.getStr("frame.unknownSource");
	
	const l10n = {
	  getStr: () => {}
	}
	
	// Character codes used in various parsing helper functions.
	const CHAR_CODE_A = "a".charCodeAt(0);
	const CHAR_CODE_C = "c".charCodeAt(0);
	const CHAR_CODE_D = "d".charCodeAt(0);
	const CHAR_CODE_E = "e".charCodeAt(0);
	const CHAR_CODE_F = "f".charCodeAt(0);
	const CHAR_CODE_H = "h".charCodeAt(0);
	const CHAR_CODE_I = "i".charCodeAt(0);
	const CHAR_CODE_J = "j".charCodeAt(0);
	const CHAR_CODE_L = "l".charCodeAt(0);
	const CHAR_CODE_M = "m".charCodeAt(0);
	const CHAR_CODE_O = "o".charCodeAt(0);
	const CHAR_CODE_P = "p".charCodeAt(0);
	const CHAR_CODE_R = "r".charCodeAt(0);
	const CHAR_CODE_S = "s".charCodeAt(0);
	const CHAR_CODE_T = "t".charCodeAt(0);
	const CHAR_CODE_U = "u".charCodeAt(0);
	const CHAR_CODE_COLON = ":".charCodeAt(0);
	const CHAR_CODE_SLASH = "/".charCodeAt(0);
	const CHAR_CODE_CAP_S = "S".charCodeAt(0);
	
	// The cache used in the `parseURL` function.
	const gURLStore = new Map();
	// The cache used in the `getSourceNames` function.
	const gSourceNamesStore = new Map();
	
	/**
	 * Takes a string and returns an object containing all the properties
	 * available on an URL instance, with additional properties (fileName),
	 * Leverages caching.
	 *
	 * @param {String} location
	 * @return {Object?} An object containing most properties available
	 *                   in https://developer.mozilla.org/en-US/docs/Web/API/URL
	 */
	
	function parseURL(location) {
	  let url = gURLStore.get(location);
	
	  if (url !== void 0) {
	    return url;
	  }
	
	  try {
	    url = new URL(location);
	    // The callers were generally written to expect a URL from
	    // sdk/url, which is subtly different.  So, work around some
	    // important differences here.
	    url = {
	      href: url.href,
	      protocol: url.protocol,
	      host: url.host,
	      hostname: url.hostname,
	      port: url.port || null,
	      pathname: url.pathname,
	      search: url.search,
	      hash: url.hash,
	      username: url.username,
	      password: url.password,
	      origin: url.origin,
	    };
	
	    // Definitions:
	    // Example: https://foo.com:8888/file.js
	    // `hostname`: "foo.com"
	    // `host`: "foo.com:8888"
	    let isChrome = isChromeScheme(location);
	
	    url.fileName = url.pathname ?
	      (url.pathname.slice(url.pathname.lastIndexOf("/") + 1) || "/") :
	      "/";
	
	    if (isChrome) {
	      url.hostname = null;
	      url.host = null;
	    }
	
	    gURLStore.set(location, url);
	    return url;
	  } catch (e) {
	    gURLStore.set(location, null);
	    return null;
	  }
	}
	
	/**
	 * Parse a source into a short and long name as well as a host name.
	 *
	 * @param {String} source
	 *        The source to parse. Can be a URI or names like "(eval)" or
	 *        "self-hosted".
	 * @return {Object}
	 *         An object with the following properties:
	 *           - {String} short: A short name for the source.
	 *             - "http://page.com/test.js#go?q=query" -> "test.js"
	 *           - {String} long: The full, long name for the source, with
	               hash/query stripped.
	 *             - "http://page.com/test.js#go?q=query" -> "http://page.com/test.js"
	 *           - {String?} host: If available, the host name for the source.
	 *             - "http://page.com/test.js#go?q=query" -> "page.com"
	 */
	function getSourceNames(source) {
	  let data = gSourceNamesStore.get(source);
	
	  if (data) {
	    return data;
	  }
	
	  let short, long, host;
	  const sourceStr = source ? String(source) : "";
	
	  // If `data:...` uri
	  if (isDataScheme(sourceStr)) {
	    let commaIndex = sourceStr.indexOf(",");
	    if (commaIndex > -1) {
	      // The `short` name for a data URI becomes `data:` followed by the actual
	      // encoded content, omitting the MIME type, and charset.
	      short = `data:${sourceStr.substring(commaIndex + 1)}`.slice(0, 100);
	      let result = { short, long: sourceStr };
	      gSourceNamesStore.set(source, result);
	      return result;
	    }
	  }
	
	  // If Scratchpad URI, like "Scratchpad/1"; no modifications,
	  // and short/long are the same.
	  if (isScratchpadScheme(sourceStr)) {
	    let result = { short: sourceStr, long: sourceStr };
	    gSourceNamesStore.set(source, result);
	    return result;
	  }
	
	  const parsedUrl = parseURL(sourceStr);
	
	  if (!parsedUrl) {
	    // Malformed URI.
	    long = sourceStr;
	    short = sourceStr.slice(0, 100);
	  } else {
	    host = parsedUrl.host;
	
	    long = parsedUrl.href;
	    if (parsedUrl.hash) {
	      long = long.replace(parsedUrl.hash, "");
	    }
	    if (parsedUrl.search) {
	      long = long.replace(parsedUrl.search, "");
	    }
	
	    short = parsedUrl.fileName;
	    // If `short` is just a slash, and we actually have a path,
	    // strip the slash and parse again to get a more useful short name.
	    // e.g. "http://foo.com/bar/" -> "bar", rather than "/"
	    if (short === "/" && parsedUrl.pathname !== "/") {
	      short = parseURL(long.replace(/\/$/, "")).fileName;
	    }
	  }
	
	  if (!short) {
	    if (!long) {
	      long = UNKNOWN_SOURCE_STRING;
	    }
	    short = long.slice(0, 100);
	  }
	
	  let result = { short, long, host };
	  gSourceNamesStore.set(source, result);
	  return result;
	}
	
	// For the functions below, we assume that we will never access the location
	// argument out of bounds, which is indeed the vast majority of cases.
	//
	// They are written this way because they are hot. Each frame is checked for
	// being content or chrome when processing the profile.
	
	function isColonSlashSlash(location, i = 0) {
	  return location.charCodeAt(++i) === CHAR_CODE_COLON &&
	         location.charCodeAt(++i) === CHAR_CODE_SLASH &&
	         location.charCodeAt(++i) === CHAR_CODE_SLASH;
	}
	
	/**
	 * Checks for a Scratchpad URI, like "Scratchpad/1"
	 */
	function isScratchpadScheme(location, i = 0) {
	  return location.charCodeAt(i) === CHAR_CODE_CAP_S &&
	         location.charCodeAt(++i) === CHAR_CODE_C &&
	         location.charCodeAt(++i) === CHAR_CODE_R &&
	         location.charCodeAt(++i) === CHAR_CODE_A &&
	         location.charCodeAt(++i) === CHAR_CODE_T &&
	         location.charCodeAt(++i) === CHAR_CODE_C &&
	         location.charCodeAt(++i) === CHAR_CODE_H &&
	         location.charCodeAt(++i) === CHAR_CODE_P &&
	         location.charCodeAt(++i) === CHAR_CODE_A &&
	         location.charCodeAt(++i) === CHAR_CODE_D &&
	         location.charCodeAt(++i) === CHAR_CODE_SLASH;
	}
	
	function isDataScheme(location, i = 0) {
	  return location.charCodeAt(i) === CHAR_CODE_D &&
	         location.charCodeAt(++i) === CHAR_CODE_A &&
	         location.charCodeAt(++i) === CHAR_CODE_T &&
	         location.charCodeAt(++i) === CHAR_CODE_A &&
	         location.charCodeAt(++i) === CHAR_CODE_COLON;
	}
	
	function isContentScheme(location, i = 0) {
	  let firstChar = location.charCodeAt(i);
	
	  switch (firstChar) {
	    // "http://" or "https://"
	    case CHAR_CODE_H:
	      if (location.charCodeAt(++i) === CHAR_CODE_T &&
	          location.charCodeAt(++i) === CHAR_CODE_T &&
	          location.charCodeAt(++i) === CHAR_CODE_P) {
	        if (location.charCodeAt(i + 1) === CHAR_CODE_S) {
	          ++i;
	        }
	        return isColonSlashSlash(location, i);
	      }
	      return false;
	
	    // "file://"
	    case CHAR_CODE_F:
	      if (location.charCodeAt(++i) === CHAR_CODE_I &&
	          location.charCodeAt(++i) === CHAR_CODE_L &&
	          location.charCodeAt(++i) === CHAR_CODE_E) {
	        return isColonSlashSlash(location, i);
	      }
	      return false;
	
	    // "app://"
	    case CHAR_CODE_A:
	      if (location.charCodeAt(++i) == CHAR_CODE_P &&
	          location.charCodeAt(++i) == CHAR_CODE_P) {
	        return isColonSlashSlash(location, i);
	      }
	      return false;
	
	    default:
	      return false;
	  }
	}
	
	function isChromeScheme(location, i = 0) {
	  let firstChar = location.charCodeAt(i);
	
	  switch (firstChar) {
	    // "chrome://"
	    case CHAR_CODE_C:
	      if (location.charCodeAt(++i) === CHAR_CODE_H &&
	          location.charCodeAt(++i) === CHAR_CODE_R &&
	          location.charCodeAt(++i) === CHAR_CODE_O &&
	          location.charCodeAt(++i) === CHAR_CODE_M &&
	          location.charCodeAt(++i) === CHAR_CODE_E) {
	        return isColonSlashSlash(location, i);
	      }
	      return false;
	
	    // "resource://"
	    case CHAR_CODE_R:
	      if (location.charCodeAt(++i) === CHAR_CODE_E &&
	          location.charCodeAt(++i) === CHAR_CODE_S &&
	          location.charCodeAt(++i) === CHAR_CODE_O &&
	          location.charCodeAt(++i) === CHAR_CODE_U &&
	          location.charCodeAt(++i) === CHAR_CODE_R &&
	          location.charCodeAt(++i) === CHAR_CODE_C &&
	          location.charCodeAt(++i) === CHAR_CODE_E) {
	        return isColonSlashSlash(location, i);
	      }
	      return false;
	
	    // "jar:file://"
	    case CHAR_CODE_J:
	      if (location.charCodeAt(++i) === CHAR_CODE_A &&
	          location.charCodeAt(++i) === CHAR_CODE_R &&
	          location.charCodeAt(++i) === CHAR_CODE_COLON &&
	          location.charCodeAt(++i) === CHAR_CODE_F &&
	          location.charCodeAt(++i) === CHAR_CODE_I &&
	          location.charCodeAt(++i) === CHAR_CODE_L &&
	          location.charCodeAt(++i) === CHAR_CODE_E) {
	        return isColonSlashSlash(location, i);
	      }
	      return false;
	
	    default:
	      return false;
	  }
	}
	
	/**
	 * A utility method to get the file name from a sourcemapped location
	 * The sourcemap location can be in any form. This method returns a
	 * formatted file name for different cases like Windows or OSX.
	 * @param source
	 * @returns String
	 */
	function getSourceMappedFile(source) {
	  // If sourcemapped source is a OSX path, return
	  // the characters after last "/".
	  // If sourcemapped source is a Windowss path, return
	  // the characters after last "\\".
	  if (source.lastIndexOf("/") >= 0) {
	    source = source.slice(source.lastIndexOf("/") + 1);
	  } else if (source.lastIndexOf("\\") >= 0) {
	    source = source.slice(source.lastIndexOf("\\") + 1);
	  }
	  return source;
	}
	
	exports.parseURL = parseURL;
	exports.getSourceNames = getSourceNames;
	exports.isScratchpadScheme = isScratchpadScheme;
	exports.isChromeScheme = isChromeScheme;
	exports.isContentScheme = isContentScheme;
	exports.isDataScheme = isDataScheme;
	exports.getSourceMappedFile = getSourceMappedFile;


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
	 * You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	"use strict";
	
	const { DOM: dom, createClass, PropTypes } = __webpack_require__(2);
	const { getSourceNames, parseURL,
	        isScratchpadScheme, getSourceMappedFile } = __webpack_require__(63);
	// const { LocalizationHelper } = require("devtools/shared/l10n");
	//
	// const l10n = new LocalizationHelper("devtools/client/locales/components.properties");
	// const webl10n = new LocalizationHelper("devtools/client/locales/webconsole.properties");
	
	const l10n = { getStr: () => {} };
	const webl10n = { getStr: () => {} };
	
	module.exports = createClass({
	  displayName: "Frame",
	
	  propTypes: {
	    // SavedFrame, or an object containing all the required properties.
	    frame: PropTypes.shape({
	      functionDisplayName: PropTypes.string,
	      source: PropTypes.string.isRequired,
	      line: PropTypes.oneOfType([ PropTypes.string, PropTypes.number ]),
	      column: PropTypes.oneOfType([ PropTypes.string, PropTypes.number ]),
	    }).isRequired,
	    // Clicking on the frame link -- probably should link to the debugger.
	    onClick: PropTypes.func.isRequired,
	    // Option to display a function name before the source link.
	    showFunctionName: PropTypes.bool,
	    // Option to display a function name even if it's anonymous.
	    showAnonymousFunctionName: PropTypes.bool,
	    // Option to display a host name after the source link.
	    showHost: PropTypes.bool,
	    // Option to display a host name if the filename is empty or just '/'
	    showEmptyPathAsHost: PropTypes.bool,
	    // Option to display a full source instead of just the filename.
	    showFullSourceUrl: PropTypes.bool,
	    // Service to enable the source map feature for console.
	    sourceMapService: PropTypes.object,
	  },
	
	  getDefaultProps() {
	    return {
	      showFunctionName: false,
	      showAnonymousFunctionName: false,
	      showHost: false,
	      showEmptyPathAsHost: false,
	      showFullSourceUrl: false,
	    };
	  },
	
	  componentWillMount() {
	    const sourceMapService = this.props.sourceMapService;
	    if (sourceMapService) {
	      const source = this.getSource();
	      sourceMapService.subscribe(source, this.onSourceUpdated);
	    }
	  },
	
	  componentWillUnmount() {
	    const sourceMapService = this.props.sourceMapService;
	    if (sourceMapService) {
	      const source = this.getSource();
	      sourceMapService.unsubscribe(source, this.onSourceUpdated);
	    }
	  },
	
	  /**
	   * Component method to update the FrameView when a resolved location is available
	   * @param event
	   * @param location
	   */
	  onSourceUpdated(event, location, resolvedLocation) {
	    const frame = this.getFrame(resolvedLocation);
	    this.setState({
	      frame,
	      isSourceMapped: true,
	    });
	  },
	
	  /**
	   * Utility method to convert the Frame object to the
	   * Source Object model required by SourceMapService
	   * @param frame
	   * @returns {{url: *, line: *, column: *}}
	   */
	  getSource(frame) {
	    frame = frame || this.props.frame;
	    const { source, line, column } = frame;
	    return {
	      url: source,
	      line,
	      column,
	    };
	  },
	
	  /**
	   * Utility method to convert the Source object model to the
	   * Frame object model required by FrameView class.
	   * @param source
	   * @returns {{source: *, line: *, column: *, functionDisplayName: *}}
	   */
	  getFrame(source) {
	    const { url, line, column } = source;
	    return {
	      source: url,
	      line,
	      column,
	      functionDisplayName: this.props.frame.functionDisplayName,
	    };
	  },
	
	  render() {
	    let frame, isSourceMapped;
	    let {
	      onClick,
	      showFunctionName,
	      showAnonymousFunctionName,
	      showHost,
	      showEmptyPathAsHost,
	      showFullSourceUrl
	    } = this.props;
	
	    if (this.state && this.state.isSourceMapped) {
	      frame = this.state.frame;
	      isSourceMapped = this.state.isSourceMapped;
	    } else {
	      frame = this.props.frame;
	    }
	
	    let source = frame.source ? String(frame.source) : "";
	    let line = frame.line != void 0 ? Number(frame.line) : null;
	    let column = frame.column != void 0 ? Number(frame.column) : null;
	
	    const { short, long, host } = getSourceNames(source);
	    // Reparse the URL to determine if we should link this; `getSourceNames`
	    // has already cached this indirectly. We don't want to attempt to
	    // link to "self-hosted" and "(unknown)". However, we do want to link
	    // to Scratchpad URIs.
	    // Source mapped sources might not necessary linkable, but they
	    // are still valid in the debugger.
	    const isLinkable = !!(isScratchpadScheme(source) || parseURL(source))
	      || isSourceMapped;
	    const elements = [];
	    const sourceElements = [];
	    let sourceEl;
	
	    let tooltip = long;
	
	    // If the source is linkable and line > 0
	    const shouldDisplayLine = isLinkable && line;
	
	    // Exclude all falsy values, including `0`, as even
	    // a number 0 for line doesn't make sense, and should not be displayed.
	    // If source isn't linkable, don't attempt to append line and column
	    // info, as this probably doesn't make sense.
	    if (shouldDisplayLine) {
	      tooltip += `:${line}`;
	      // Intentionally exclude 0
	      if (column) {
	        tooltip += `:${column}`;
	      }
	    }
	
	    let attributes = {
	      "data-url": long,
	      className: "frame-link",
	    };
	
	    if (showFunctionName) {
	      let functionDisplayName = frame.functionDisplayName;
	      if (!functionDisplayName && showAnonymousFunctionName) {
	        functionDisplayName = webl10n.getStr("stacktrace.anonymousFunction");
	      }
	
	      if (functionDisplayName) {
	        elements.push(
	          dom.span({ className: "frame-link-function-display-name" },
	            functionDisplayName),
	          " "
	        );
	      }
	    }
	
	    let displaySource = showFullSourceUrl ? long : short;
	    if (isSourceMapped) {
	      displaySource = getSourceMappedFile(displaySource);
	    } else if (showEmptyPathAsHost && (displaySource === "" || displaySource === "/")) {
	      displaySource = host;
	    }
	
	    sourceElements.push(dom.span({
	      className: "frame-link-filename",
	    }, displaySource));
	
	    // If source is linkable, and we have a line number > 0
	    if (shouldDisplayLine) {
	      let lineInfo = `:${line}`;
	      // Add `data-line` attribute for testing
	      attributes["data-line"] = line;
	
	      // Intentionally exclude 0
	      if (column) {
	        lineInfo += `:${column}`;
	        // Add `data-column` attribute for testing
	        attributes["data-column"] = column;
	      }
	
	      sourceElements.push(dom.span({ className: "frame-link-line" }, lineInfo));
	    }
	
	    // Inner el is useful for achieving ellipsis on the left and correct LTR/RTL
	    // ordering. See CSS styles for frame-link-source-[inner] and bug 1290056.
	    let sourceInnerEl = dom.span({
	      className: "frame-link-source-inner",
	      title: isLinkable ?
	        l10n.getFormatStr("frame.viewsourceindebugger", tooltip) : tooltip,
	    }, sourceElements);
	
	    // If source is not a URL (self-hosted, eval, etc.), don't make
	    // it an anchor link, as we can't link to it.
	    if (isLinkable) {
	      sourceEl = dom.a({
	        onClick: e => {
	          e.preventDefault();
	          onClick(this.getSource(frame));
	        },
	        href: source,
	        className: "frame-link-source",
	        draggable: false,
	      }, sourceInnerEl);
	    } else {
	      sourceEl = dom.span({
	        className: "frame-link-source",
	      }, sourceInnerEl);
	    }
	    elements.push(sourceEl);
	
	    if (showHost && host) {
	      elements.push(" ", dom.span({ className: "frame-link-host" }, host));
	    }
	
	    return dom.span(attributes, ...elements);
	  }
	});


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	const feature = __webpack_require__(66);
	
	module.exports = feature;


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	const pick = __webpack_require__(67);
	let config;
	
	const flag = __webpack_require__(119);
	
	/**
	 * Gets a config value for a given key
	 * e.g "chrome.webSocketPort"
	 */
	function getValue(key) {
	  return pick(config, key);
	}
	
	function isEnabled(key) {
	  return config.features && config.features[key];
	}
	
	function isDevelopment() {
	  if (isFirefoxPanel()) {
	    // Default to production if compiling for the Firefox panel
	    return ("production") === "development";
	  }
	  return ("production") !== "production";
	}
	
	function isTesting() {
	  return flag.testing;
	}
	
	function isFirefoxPanel() {
	  return ("firefox-panel") == "firefox-panel";
	}
	
	function isApplication() {
	  return ("firefox-panel") == "application";
	}
	
	function isFirefox() {
	  return /firefox/i.test(navigator.userAgent);
	}
	
	function setConfig(value) {
	  config = value;
	}
	
	function getConfig() {
	  return config;
	}
	
	module.exports = {
	  isEnabled,
	  getValue,
	  isDevelopment,
	  isTesting,
	  isFirefoxPanel,
	  isApplication,
	  isFirefox,
	  getConfig,
	  setConfig
	};


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(68);
	
	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}
	
	module.exports = get;


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(69),
	    toKey = __webpack_require__(118);
	
	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = castPath(path, object);
	
	  var index = 0,
	      length = path.length;
	
	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}
	
	module.exports = baseGet;


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(70),
	    isKey = __webpack_require__(71),
	    stringToPath = __webpack_require__(80),
	    toString = __webpack_require__(115);
	
	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value, object) {
	  if (isArray(value)) {
	    return value;
	  }
	  return isKey(value, object) ? [value] : stringToPath(toString(value));
	}
	
	module.exports = castPath;


/***/ },
/* 70 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;
	
	module.exports = isArray;


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(70),
	    isSymbol = __webpack_require__(72);
	
	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;
	
	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}
	
	module.exports = isKey;


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(73),
	    isObjectLike = __webpack_require__(79);
	
	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';
	
	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag);
	}
	
	module.exports = isSymbol;


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(74),
	    getRawTag = __webpack_require__(77),
	    objectToString = __webpack_require__(78);
	
	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';
	
	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
	
	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  value = Object(value);
	  return (symToStringTag && symToStringTag in value)
	    ? getRawTag(value)
	    : objectToString(value);
	}
	
	module.exports = baseGetTag;


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(75);
	
	/** Built-in value references. */
	var Symbol = root.Symbol;
	
	module.exports = Symbol;


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	var freeGlobal = __webpack_require__(76);
	
	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();
	
	module.exports = root;


/***/ },
/* 76 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
	
	module.exports = freeGlobal;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(74);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;
	
	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
	
	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];
	
	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}
	
	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}
	
	module.exports = getRawTag;


/***/ },
/* 78 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;
	
	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}
	
	module.exports = objectToString;


/***/ },
/* 79 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}
	
	module.exports = isObjectLike;


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	var memoizeCapped = __webpack_require__(81);
	
	/** Used to match property names within property paths. */
	var reLeadingDot = /^\./,
	    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
	
	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;
	
	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoizeCapped(function(string) {
	  var result = [];
	  if (reLeadingDot.test(string)) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});
	
	module.exports = stringToPath;


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var memoize = __webpack_require__(82);
	
	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;
	
	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped(func) {
	  var result = memoize(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });
	
	  var cache = result.cache;
	  return result;
	}
	
	module.exports = memoizeCapped;


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	var MapCache = __webpack_require__(83);
	
	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';
	
	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;
	
	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}
	
	// Expose `MapCache`.
	memoize.Cache = MapCache;
	
	module.exports = memoize;


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var mapCacheClear = __webpack_require__(84),
	    mapCacheDelete = __webpack_require__(109),
	    mapCacheGet = __webpack_require__(112),
	    mapCacheHas = __webpack_require__(113),
	    mapCacheSet = __webpack_require__(114);
	
	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;
	
	module.exports = MapCache;


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var Hash = __webpack_require__(85),
	    ListCache = __webpack_require__(100),
	    Map = __webpack_require__(108);
	
	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}
	
	module.exports = mapCacheClear;


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var hashClear = __webpack_require__(86),
	    hashDelete = __webpack_require__(96),
	    hashGet = __webpack_require__(97),
	    hashHas = __webpack_require__(98),
	    hashSet = __webpack_require__(99);
	
	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;
	
	module.exports = Hash;


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(87);
	
	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}
	
	module.exports = hashClear;


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(88);
	
	/* Built-in method references that are verified to be native. */
	var nativeCreate = getNative(Object, 'create');
	
	module.exports = nativeCreate;


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsNative = __webpack_require__(89),
	    getValue = __webpack_require__(95);
	
	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}
	
	module.exports = getNative;


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(90),
	    isMasked = __webpack_require__(92),
	    isObject = __webpack_require__(91),
	    toSource = __webpack_require__(94);
	
	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
	
	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);
	
	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}
	
	module.exports = baseIsNative;


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(73),
	    isObject = __webpack_require__(91);
	
	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';
	
	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}
	
	module.exports = isFunction;


/***/ },
/* 91 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}
	
	module.exports = isObject;


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	var coreJsData = __webpack_require__(93);
	
	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());
	
	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}
	
	module.exports = isMasked;


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(75);
	
	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];
	
	module.exports = coreJsData;


/***/ },
/* 94 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var funcProto = Function.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}
	
	module.exports = toSource;


/***/ },
/* 95 */
/***/ function(module, exports) {

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}
	
	module.exports = getValue;


/***/ },
/* 96 */
/***/ function(module, exports) {

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}
	
	module.exports = hashDelete;


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(87);
	
	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}
	
	module.exports = hashGet;


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(87);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	}
	
	module.exports = hashHas;


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(87);
	
	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';
	
	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}
	
	module.exports = hashSet;


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	var listCacheClear = __webpack_require__(101),
	    listCacheDelete = __webpack_require__(102),
	    listCacheGet = __webpack_require__(105),
	    listCacheHas = __webpack_require__(106),
	    listCacheSet = __webpack_require__(107);
	
	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;
	
	module.exports = ListCache;


/***/ },
/* 101 */
/***/ function(module, exports) {

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}
	
	module.exports = listCacheClear;


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(103);
	
	/** Used for built-in method references. */
	var arrayProto = Array.prototype;
	
	/** Built-in value references. */
	var splice = arrayProto.splice;
	
	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}
	
	module.exports = listCacheDelete;


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(104);
	
	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}
	
	module.exports = assocIndexOf;


/***/ },
/* 104 */
/***/ function(module, exports) {

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}
	
	module.exports = eq;


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(103);
	
	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  return index < 0 ? undefined : data[index][1];
	}
	
	module.exports = listCacheGet;


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(103);
	
	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}
	
	module.exports = listCacheHas;


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(103);
	
	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}
	
	module.exports = listCacheSet;


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(88),
	    root = __webpack_require__(75);
	
	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map');
	
	module.exports = Map;


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(110);
	
	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}
	
	module.exports = mapCacheDelete;


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	var isKeyable = __webpack_require__(111);
	
	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}
	
	module.exports = getMapData;


/***/ },
/* 111 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}
	
	module.exports = isKeyable;


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(110);
	
	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}
	
	module.exports = mapCacheGet;


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(110);
	
	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}
	
	module.exports = mapCacheHas;


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(110);
	
	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;
	
	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}
	
	module.exports = mapCacheSet;


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	var baseToString = __webpack_require__(116);
	
	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}
	
	module.exports = toString;


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(74),
	    arrayMap = __webpack_require__(117),
	    isArray = __webpack_require__(70),
	    isSymbol = __webpack_require__(72);
	
	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;
	
	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;
	
	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}
	
	module.exports = baseToString;


/***/ },
/* 117 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);
	
	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}
	
	module.exports = arrayMap;


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	var isSymbol = __webpack_require__(72);
	
	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;
	
	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}
	
	module.exports = toKey;


/***/ },
/* 119 */
/***/ function(module, exports) {

	module.exports = devtoolsRequire("devtools/shared/flags");

/***/ },
/* 120 */
/***/ function(module, exports) {

	let bpClients;
	let threadClient;
	let tabTarget;
	let debuggerClient;
	let propertiesRequestCache = new Set();
	
	function setupCommands(dependencies) {
	  threadClient = dependencies.threadClient;
	  tabTarget = dependencies.tabTarget;
	  debuggerClient = dependencies.debuggerClient;
	  bpClients = {};
	}
	
	function resume() {
	  return new Promise(resolve => {
	    threadClient.resume(resolve);
	  });
	}
	
	function stepIn() {
	  return new Promise(resolve => {
	    threadClient.stepIn(resolve);
	  });
	}
	
	function stepOver() {
	  return new Promise(resolve => {
	    threadClient.stepOver(resolve);
	  });
	}
	
	function stepOut() {
	  return new Promise(resolve => {
	    threadClient.stepOut(resolve);
	  });
	}
	
	function breakOnNext() {
	  return threadClient.breakOnNext();
	}
	
	function sourceContents(sourceId) {
	  const sourceClient = threadClient.source({ actor: sourceId });
	  return sourceClient.source();
	}
	
	function setBreakpoint(location, condition, noSliding) {
	  const sourceClient = threadClient.source({ actor: location.sourceId });
	
	  return sourceClient.setBreakpoint({
	    line: location.line,
	    column: location.column,
	    condition,
	    noSliding
	  }).then(res => onNewBreakpoint(location, res));
	}
	
	function onNewBreakpoint(location, res) {
	  const bpClient = res[1];
	  let actualLocation = res[0].actualLocation;
	  bpClients[bpClient.actor] = bpClient;
	
	  // Firefox only returns `actualLocation` if it actually changed,
	  // but we want it always to exist. Format `actualLocation` if it
	  // exists, otherwise use `location`.
	  actualLocation = actualLocation ? {
	    sourceId: actualLocation.source.actor,
	    line: actualLocation.line,
	    column: actualLocation.column
	  } : location;
	
	  return {
	    id: bpClient.actor,
	    actualLocation
	  };
	}
	
	function removeBreakpoint(breakpointId) {
	  const bpClient = bpClients[breakpointId];
	  delete bpClients[breakpointId];
	  return bpClient.remove();
	}
	
	function setBreakpointCondition(breakpointId, location, condition, noSliding) {
	  let bpClient = bpClients[breakpointId];
	  delete bpClients[breakpointId];
	
	  return bpClient.setCondition(threadClient, condition, noSliding).then(_bpClient => onNewBreakpoint(location, [{}, _bpClient]));
	}
	
	function evaluate(script, { frameId }) {
	  const params = frameId ? { frameActor: frameId } : {};
	  return new Promise(resolve => {
	    tabTarget.activeConsole.evaluateJS(script, result => resolve(result), params);
	  });
	}
	
	function debuggeeCommand(script) {
	  tabTarget.activeConsole.evaluateJS(script, () => {}, {});
	
	  if (!debuggerClient) {
	    return;
	  }
	
	  const consoleActor = tabTarget.form.consoleActor;
	  const request = debuggerClient._activeRequests.get(consoleActor);
	  request.emit("json-reply", {});
	  debuggerClient._activeRequests.delete(consoleActor);
	
	  return Promise.resolve();
	}
	
	function navigate(url) {
	  return tabTarget.activeTab.navigateTo(url);
	}
	
	function reload() {
	  return tabTarget.activeTab.reload();
	}
	
	function getProperties(grip) {
	  if (propertiesRequestCache.has(grip.actor)) {
	    return Promise.resolve();
	  }
	
	  propertiesRequestCache.add(grip.actor);
	  const objClient = threadClient.pauseGrip(grip);
	
	  return objClient.getPrototypeAndProperties().then(resp => {
	    return resp;
	  });
	}
	
	function pauseOnExceptions(shouldPauseOnExceptions, shouldIgnoreCaughtExceptions) {
	  return threadClient.pauseOnExceptions(shouldPauseOnExceptions, shouldIgnoreCaughtExceptions);
	}
	
	function prettyPrint(sourceId, indentSize) {
	  const sourceClient = threadClient.source({ actor: sourceId });
	  return sourceClient.prettyPrint(indentSize);
	}
	
	function disablePrettyPrint(sourceId) {
	  const sourceClient = threadClient.source({ actor: sourceId });
	  return sourceClient.disablePrettyPrint();
	}
	
	function interrupt() {
	  return threadClient.interrupt();
	}
	
	function eventListeners() {
	  return threadClient.eventListeners();
	}
	
	function pauseGrip(func) {
	  return threadClient.pauseGrip(func);
	}
	
	const clientCommands = {
	  interrupt,
	  eventListeners,
	  pauseGrip,
	  resume,
	  stepIn,
	  stepOut,
	  stepOver,
	  breakOnNext,
	  sourceContents,
	  setBreakpoint,
	  removeBreakpoint,
	  setBreakpointCondition,
	  evaluate,
	  debuggeeCommand,
	  navigate,
	  reload,
	  getProperties,
	  pauseOnExceptions,
	  prettyPrint,
	  disablePrettyPrint
	};
	
	module.exports = {
	  setupCommands,
	  clientCommands
	};

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	let paused = (() => {
	  var _ref = _asyncToGenerator(function* (_, packet) {
	    // If paused by an explicit interrupt, which are generated by the
	    // slow script dialog and internal events such as setting
	    // breakpoints, ignore the event.
	    if (packet.why.type === "interrupted" && !packet.why.onNext) {
	      return;
	    }
	
	    // Eagerly fetch the frames
	    const response = yield threadClient.getFrames(0, CALL_STACK_PAGE_SIZE);
	
	    const pause = createPause(packet, response);
	
	    actions.paused(pause);
	  });
	
	  return function paused(_x, _x2) {
	    return _ref.apply(this, arguments);
	  };
	})();
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	const { createPause, createSource } = __webpack_require__(122);
	
	const { isEnabled } = __webpack_require__(65);
	
	const CALL_STACK_PAGE_SIZE = 1000;
	
	let threadClient;
	let actions;
	
	function setupEvents(dependencies) {
	  threadClient = dependencies.threadClient;
	  actions = dependencies.actions;
	}
	
	function resumed(_, packet) {
	  actions.resumed(packet);
	}
	
	function newSource(_, { source }) {
	  actions.newSource(createSource(source));
	
	  if (isEnabled("eventListeners")) {
	    actions.fetchEventListeners();
	  }
	}
	
	const clientEvents = {
	  paused,
	  resumed,
	  newSource
	};
	
	module.exports = {
	  setupEvents,
	  clientEvents
	};

/***/ },
/* 122 */
/***/ function(module, exports) {

	
	// This module converts Firefox specific types to the generic types
	
	function createFrame(frame) {
	  let title;
	  if (frame.type == "call") {
	    let c = frame.callee;
	    title = c.name || c.userDisplayName || c.displayName || "(anonymous)";
	  } else {
	    title = `(${ frame.type })`;
	  }
	
	  return {
	    id: frame.actor,
	    displayName: title,
	    location: {
	      sourceId: frame.where.source.actor,
	      line: frame.where.line,
	      column: frame.where.column
	    },
	    this: frame.this,
	    scope: frame.environment
	  };
	}
	
	function createSource(source) {
	  return {
	    id: source.actor,
	    url: source.url,
	    isPrettyPrinted: false,
	    sourceMapURL: source.sourceMapURL
	  };
	}
	
	function createPause(packet, response) {
	  return Object.assign({}, packet, {
	    frame: createFrame(packet.frame),
	    frames: response.frames.map(createFrame)
	  });
	}
	
	module.exports = {
	  createFrame,
	  createSource,
	  createPause
	};

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	const CDP = __webpack_require__(124);
	const { getValue } = __webpack_require__(65);
	const networkRequest = __webpack_require__(125);
	const { setupCommands, clientCommands } = __webpack_require__(126);
	const { setupEvents, clientEvents } = __webpack_require__(128);
	
	let connection;
	
	function createTabs(tabs, { type, clientType } = {}) {
	  return tabs.filter(tab => {
	    return tab.type == type;
	  }).map(tab => {
	    return {
	      title: tab.title,
	      url: tab.url,
	      id: tab.id,
	      tab,
	      clientType
	    };
	  });
	}
	
	window.criRequest = function (options, callback) {
	  const { host, port, path } = options;
	  const url = `http://${ host }:${ port }${ path }`;
	
	  networkRequest(url).then(res => callback(null, res.content)).catch(err => callback(err));
	};
	
	function connectClient() {
	  if (!getValue("chrome.debug")) {
	    return Promise.resolve(createTabs([]));
	  }
	
	  return CDP.List({
	    port: getValue("chrome.port"),
	    host: getValue("chrome.host")
	  }).then(tabs => createTabs(tabs, {
	    clientType: "chrome", type: "page"
	  }));
	}
	
	function connectNodeClient() {
	  if (!getValue("node.debug")) {
	    return Promise.resolve(createTabs([]));
	  }
	
	  return CDP.List({
	    port: getValue("node.port"),
	    host: getValue("node.host")
	  }).then(tabs => createTabs(tabs, {
	    clientType: "node", type: "node"
	  }));
	}
	
	function connectTab(tab) {
	  return CDP({ tab: tab.webSocketDebuggerUrl }).then(conn => {
	    connection = conn;
	  });
	}
	
	function connectNode(tab) {
	  return CDP({ tab: tab.webSocketDebuggerUrl }).then(conn => {
	    connection = conn;
	    window.addEventListener("beforeunload", () => {
	      connection.onclose = function disable() {};
	      connection.close();
	    });
	  });
	}
	
	function initPage(actions, { clientType }) {
	  const { Debugger, Runtime, Page } = connection;
	
	  setupCommands({ Debugger, Runtime, Page });
	  setupEvents({ actions, Page, clientType });
	
	  Debugger.enable();
	  Debugger.setPauseOnExceptions({ state: "none" });
	  Debugger.setAsyncCallStackDepth({ maxDepth: 0 });
	
	  Runtime.enable();
	
	  if (clientType == "node") {
	    Runtime.runIfWaitingForDebugger();
	  }
	
	  if (clientType == "chrome") {
	    Page.enable();
	  }
	
	  Debugger.scriptParsed(clientEvents.scriptParsed);
	  Debugger.scriptFailedToParse(clientEvents.scriptFailedToParse);
	  Debugger.paused(clientEvents.paused);
	  Debugger.resumed(clientEvents.resumed);
	}
	
	module.exports = {
	  connectClient,
	  connectNodeClient,
	  clientCommands,
	  connectNode,
	  connectTab,
	  initPage
	};

/***/ },
/* 124 */
/***/ function(module, exports) {

	module.exports=function(e){function t(i){if(n[i])return n[i].exports;var r=n[i]={exports:{},id:i,loaded:!1};return e[i].call(r.exports,r,r.exports,t),r.loaded=!0,r.exports}var n={};return t.m=e,t.c=n,t.p="",t(0)}([function(e,t,n){(function(t){"use strict";var i=n(2),r=n(3),o=n(41);e.exports=function(e,n){"function"==typeof e&&(n=e,e=void 0);var r=new i;return"function"==typeof n?(t.nextTick(function(){new o(e,r)}),r.on("connect",n)):new Promise(function(t,n){r.on("connect",t),r.on("error",n),r.on("disconnect",function(){n(new Error("Disconnected"))}),new o(e,r)})},e.exports.listTabs=r.List,e.exports.spawnTab=r.New,e.exports.closeTab=r.Close,e.exports.Protocol=r.Protocol,e.exports.List=r.List,e.exports.New=r.New,e.exports.Activate=r.Activate,e.exports.Close=r.Close,e.exports.Version=r.Version}).call(t,n(1))},function(e,t){function n(){throw new Error("setTimeout has not been defined")}function i(){throw new Error("clearTimeout has not been defined")}function r(e){if(d===setTimeout)return setTimeout(e,0);if((d===n||!d)&&setTimeout)return d=setTimeout,setTimeout(e,0);try{return d(e,0)}catch(t){try{return d.call(null,e,0)}catch(t){return d.call(this,e,0)}}}function o(e){if(l===clearTimeout)return clearTimeout(e);if((l===i||!l)&&clearTimeout)return l=clearTimeout,clearTimeout(e);try{return l(e)}catch(t){try{return l.call(null,e)}catch(t){return l.call(this,e)}}}function a(){f&&u&&(f=!1,u.length?h=u.concat(h):y=-1,h.length&&s())}function s(){if(!f){var e=r(a);f=!0;for(var t=h.length;t;){for(u=h,h=[];++y<t;)u&&u[y].run();y=-1,t=h.length}u=null,f=!1,o(e)}}function p(e,t){this.fun=e,this.array=t}function c(){}var d,l,m=e.exports={};!function(){try{d="function"==typeof setTimeout?setTimeout:n}catch(e){d=n}try{l="function"==typeof clearTimeout?clearTimeout:i}catch(e){l=i}}();var u,h=[],f=!1,y=-1;m.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)t[n-1]=arguments[n];h.push(new p(e,t)),1!==h.length||f||r(s)},p.prototype.run=function(){this.fun.apply(null,this.array)},m.title="browser",m.browser=!0,m.env={},m.argv=[],m.version="",m.versions={},m.on=c,m.addListener=c,m.once=c,m.off=c,m.removeListener=c,m.removeAllListeners=c,m.emit=c,m.binding=function(e){throw new Error("process.binding is not supported")},m.cwd=function(){return"/"},m.chdir=function(e){throw new Error("process.chdir is not supported")},m.umask=function(){return 0}},function(e,t){function n(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function i(e){return"function"==typeof e}function r(e){return"number"==typeof e}function o(e){return"object"==typeof e&&null!==e}function a(e){return void 0===e}e.exports=n,n.EventEmitter=n,n.prototype._events=void 0,n.prototype._maxListeners=void 0,n.defaultMaxListeners=10,n.prototype.setMaxListeners=function(e){if(!r(e)||e<0||isNaN(e))throw TypeError("n must be a positive number");return this._maxListeners=e,this},n.prototype.emit=function(e){var t,n,r,s,p,c;if(this._events||(this._events={}),"error"===e&&(!this._events.error||o(this._events.error)&&!this._events.error.length)){if(t=arguments[1],t instanceof Error)throw t;var d=new Error('Uncaught, unspecified "error" event. ('+t+")");throw d.context=t,d}if(n=this._events[e],a(n))return!1;if(i(n))switch(arguments.length){case 1:n.call(this);break;case 2:n.call(this,arguments[1]);break;case 3:n.call(this,arguments[1],arguments[2]);break;default:s=Array.prototype.slice.call(arguments,1),n.apply(this,s)}else if(o(n))for(s=Array.prototype.slice.call(arguments,1),c=n.slice(),r=c.length,p=0;p<r;p++)c[p].apply(this,s);return!0},n.prototype.addListener=function(e,t){var r;if(!i(t))throw TypeError("listener must be a function");return this._events||(this._events={}),this._events.newListener&&this.emit("newListener",e,i(t.listener)?t.listener:t),this._events[e]?o(this._events[e])?this._events[e].push(t):this._events[e]=[this._events[e],t]:this._events[e]=t,o(this._events[e])&&!this._events[e].warned&&(r=a(this._maxListeners)?n.defaultMaxListeners:this._maxListeners,r&&r>0&&this._events[e].length>r&&(this._events[e].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[e].length),"function"==typeof console.trace&&console.trace())),this},n.prototype.on=n.prototype.addListener,n.prototype.once=function(e,t){function n(){this.removeListener(e,n),r||(r=!0,t.apply(this,arguments))}if(!i(t))throw TypeError("listener must be a function");var r=!1;return n.listener=t,this.on(e,n),this},n.prototype.removeListener=function(e,t){var n,r,a,s;if(!i(t))throw TypeError("listener must be a function");if(!this._events||!this._events[e])return this;if(n=this._events[e],a=n.length,r=-1,n===t||i(n.listener)&&n.listener===t)delete this._events[e],this._events.removeListener&&this.emit("removeListener",e,t);else if(o(n)){for(s=a;s-- >0;)if(n[s]===t||n[s].listener&&n[s].listener===t){r=s;break}if(r<0)return this;1===n.length?(n.length=0,delete this._events[e]):n.splice(r,1),this._events.removeListener&&this.emit("removeListener",e,t)}return this},n.prototype.removeAllListeners=function(e){var t,n;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[e]&&delete this._events[e],this;if(0===arguments.length){for(t in this._events)"removeListener"!==t&&this.removeAllListeners(t);return this.removeAllListeners("removeListener"),this._events={},this}if(n=this._events[e],i(n))this.removeListener(e,n);else if(n)for(;n.length;)this.removeListener(e,n[n.length-1]);return delete this._events[e],this},n.prototype.listeners=function(e){var t;return t=this._events&&this._events[e]?i(this._events[e])?[this._events[e]]:this._events[e].slice():[]},n.prototype.listenerCount=function(e){if(this._events){var t=this._events[e];if(i(t))return 1;if(t)return t.length}return 0},n.listenerCount=function(e,t){return e.listenerCount(t)}},function(e,t,n){(function(t){"use strict";function i(e,t){e.host=e.host||c.HOST,e.port=e.port||c.PORT,d(s,e,t)}function r(e){return function(t,n){return"function"==typeof t&&(n=t,t=void 0),t=t||{},"function"!=typeof n?new Promise(function(n,i){e(t,function(e,t){e?i(e):n(t)})}):void e(t,n)}}function o(e,n,i){function r(e){return e.split(".").map(function(e){return parseInt(e)})}var o=n["WebKit-Version"],a=n["V8-Version"],s=o.match(/\s\(@(\b[0-9a-f]{5,40}\b)/),c=s[1],l=c<=202666,m=void 0;if(l)m=["https://src.chromium.org/blink/trunk/Source/devtools/protocol.json?p="+c];else{var u="53.0.2758.1",h="55.0.2854.3",f=r(n.Browser.split("/")[1]),y=f[2]<=r(u)[2],g=f[2]<=r(h)[2];y?m=["https://chromium.googlesource.com/chromium/src/+/"+c+"/third_party/WebKit/Source/devtools/protocol.json?format=TEXT"]:g?m=["https://chromium.googlesource.com/chromium/src/+/"+c+"/third_party/WebKit/Source/core/inspector/browser_protocol.json?format=TEXT","https://chromium.googlesource.com/chromium/src/+/"+c+"/third_party/WebKit/Source/platform/v8_inspector/js_protocol.json?format=TEXT"]:a?m=["https://chromium.googlesource.com/chromium/src/+/"+c+"/third_party/WebKit/Source/core/inspector/browser_protocol.json?format=TEXT","https://chromium.googlesource.com/v8/v8/+/"+a+"/src/inspector/js_protocol.json?format=TEXT"]:(console.error("Warning: the protocol might be outdated, see: https://groups.google.com/d/topic/chrome-debugging-protocol/HjyOKainKus/discussion"),m=["https://chromium.googlesource.com/chromium/src/+/"+c+"/third_party/WebKit/Source/core/inspector/browser_protocol.json?format=TEXT","https://chromium.googlesource.com/chromium/src/+/"+h+"/third_party/WebKit/Source/platform/v8_inspector/js_protocol.json?format=TEXT"])}var b=[];m.forEach(function(e){d(p,e,function(e,n){var r=void 0;if(!e)try{l||(n=new t(n,"base64").toString()),r=JSON.parse(n)}catch(e){}if(b.push(r),b.length===m.length){if(b.indexOf(void 0)!==-1)return void i(new Error("Cannot fetch from Chromium repo"));b.forEach(function(e,t){0!==t&&Array.prototype.push.apply(b[0].domains,e.domains)}),i(null,b[0])}})})}function a(e,t,n){e.path="/json/protocol",i(e,function(e,t){e?n(e):n(null,JSON.parse(t))})}var s=n(8),p=n(37),c=n(38),d=n(39);e.exports.Protocol=r(function(t,i){if(!t.remote){var r=n(40);return void i(null,{remote:!1,descriptor:r})}e.exports.Version(t,function(e,n){if(e)return void i(e);var r=(n[0]||n).Browser,s=void 0;if(r.match(/^Chrome\//))s=o;else if(r.match(/^Microsoft Edge /))s=a;else{if(!r.match(/^node.js\//))return void i(new Error("Unknown implementation"));s=a}s(t,n,function(e,t){return e?void i(e):void i(null,{remote:!0,descriptor:t})})})}),e.exports.List=r(function(e,t){e.path="/json/list",i(e,function(e,n){e?t(e):t(null,JSON.parse(n))})}),e.exports.New=r(function(e,t){e.path="/json/new",Object.prototype.hasOwnProperty.call(e,"url")&&(e.path+="?"+e.url),i(e,function(e,n){e?t(e):t(null,JSON.parse(n))})}),e.exports.Activate=r(function(e,t){e.path="/json/activate/"+e.id,i(e,function(e){t(e?e:null)})}),e.exports.Close=r(function(e,t){e.path="/json/close/"+e.id,i(e,function(e){t(e?e:null)})}),e.exports.Version=r(function(e,t){e.path="/json/version",i(e,function(e,n){e?t(e):t(null,JSON.parse(n))})})}).call(t,n(4).Buffer)},function(e,t,n){(function(e,i){"use strict";function r(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()&&"function"==typeof e.subarray&&0===e.subarray(1,1).byteLength}catch(e){return!1}}function o(){return e.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function a(t,n){if(o()<n)throw new RangeError("Invalid typed array length");return e.TYPED_ARRAY_SUPPORT?(t=new Uint8Array(n),t.__proto__=e.prototype):(null===t&&(t=new e(n)),t.length=n),t}function e(t,n,i){if(!(e.TYPED_ARRAY_SUPPORT||this instanceof e))return new e(t,n,i);if("number"==typeof t){if("string"==typeof n)throw new Error("If encoding is specified then the first argument must be a string");return d(this,t)}return s(this,t,n,i)}function s(e,t,n,i){if("number"==typeof t)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer?u(e,t,n,i):"string"==typeof t?l(e,t,n):h(e,t)}function p(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function c(e,t,n,i){return p(t),t<=0?a(e,t):void 0!==n?"string"==typeof i?a(e,t).fill(n,i):a(e,t).fill(n):a(e,t)}function d(t,n){if(p(n),t=a(t,n<0?0:0|f(n)),!e.TYPED_ARRAY_SUPPORT)for(var i=0;i<n;++i)t[i]=0;return t}function l(t,n,i){if("string"==typeof i&&""!==i||(i="utf8"),!e.isEncoding(i))throw new TypeError('"encoding" must be a valid string encoding');var r=0|g(n,i);t=a(t,r);var o=t.write(n,i);return o!==r&&(t=t.slice(0,o)),t}function m(e,t){var n=t.length<0?0:0|f(t.length);e=a(e,n);for(var i=0;i<n;i+=1)e[i]=255&t[i];return e}function u(t,n,i,r){if(n.byteLength,i<0||n.byteLength<i)throw new RangeError("'offset' is out of bounds");if(n.byteLength<i+(r||0))throw new RangeError("'length' is out of bounds");return n=void 0===i&&void 0===r?new Uint8Array(n):void 0===r?new Uint8Array(n,i):new Uint8Array(n,i,r),e.TYPED_ARRAY_SUPPORT?(t=n,t.__proto__=e.prototype):t=m(t,n),t}function h(t,n){if(e.isBuffer(n)){var i=0|f(n.length);return t=a(t,i),0===t.length?t:(n.copy(t,0,0,i),t)}if(n){if("undefined"!=typeof ArrayBuffer&&n.buffer instanceof ArrayBuffer||"length"in n)return"number"!=typeof n.length||J(n.length)?a(t,0):m(t,n);if("Buffer"===n.type&&Z(n.data))return m(t,n.data)}throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}function f(e){if(e>=o())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+o().toString(16)+" bytes");return 0|e}function y(t){return+t!=t&&(t=0),e.alloc(+t)}function g(t,n){if(e.isBuffer(t))return t.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(t)||t instanceof ArrayBuffer))return t.byteLength;"string"!=typeof t&&(t=""+t);var i=t.length;if(0===i)return 0;for(var r=!1;;)switch(n){case"ascii":case"latin1":case"binary":return i;case"utf8":case"utf-8":case void 0:return z(t).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*i;case"hex":return i>>>1;case"base64":return Y(t).length;default:if(r)return z(t).length;n=(""+n).toLowerCase(),r=!0}}function b(e,t,n){var i=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===n||n>this.length)&&(n=this.length),n<=0)return"";if(n>>>=0,t>>>=0,n<=t)return"";for(e||(e="utf8");;)switch(e){case"hex":return D(this,t,n);case"utf8":case"utf-8":return j(this,t,n);case"ascii":return E(this,t,n);case"latin1":case"binary":return A(this,t,n);case"base64":return $(this,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return P(this,t,n);default:if(i)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),i=!0}}function v(e,t,n){var i=e[t];e[t]=e[n],e[n]=i}function w(t,n,i,r,o){if(0===t.length)return-1;if("string"==typeof i?(r=i,i=0):i>2147483647?i=2147483647:i<-2147483648&&(i=-2147483648),i=+i,isNaN(i)&&(i=o?0:t.length-1),i<0&&(i=t.length+i),i>=t.length){if(o)return-1;i=t.length-1}else if(i<0){if(!o)return-1;i=0}if("string"==typeof n&&(n=e.from(n,r)),e.isBuffer(n))return 0===n.length?-1:S(t,n,i,r,o);if("number"==typeof n)return n&=255,e.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?o?Uint8Array.prototype.indexOf.call(t,n,i):Uint8Array.prototype.lastIndexOf.call(t,n,i):S(t,[n],i,r,o);throw new TypeError("val must be string, number or Buffer")}function S(e,t,n,i,r){function o(e,t){return 1===a?e[t]:e.readUInt16BE(t*a)}var a=1,s=e.length,p=t.length;if(void 0!==i&&(i=String(i).toLowerCase(),"ucs2"===i||"ucs-2"===i||"utf16le"===i||"utf-16le"===i)){if(e.length<2||t.length<2)return-1;a=2,s/=2,p/=2,n/=2}var c;if(r){var d=-1;for(c=n;c<s;c++)if(o(e,c)===o(t,d===-1?0:c-d)){if(d===-1&&(d=c),c-d+1===p)return d*a}else d!==-1&&(c-=c-d),d=-1}else for(n+p>s&&(n=s-p),c=n;c>=0;c--){for(var l=!0,m=0;m<p;m++)if(o(e,c+m)!==o(t,m)){l=!1;break}if(l)return c}return-1}function x(e,t,n,i){n=Number(n)||0;var r=e.length-n;i?(i=Number(i),i>r&&(i=r)):i=r;var o=t.length;if(o%2!==0)throw new TypeError("Invalid hex string");i>o/2&&(i=o/2);for(var a=0;a<i;++a){var s=parseInt(t.substr(2*a,2),16);if(isNaN(s))return a;e[n+a]=s}return a}function I(e,t,n,i){return G(z(t,e.length-n),e,n,i)}function T(e,t,n,i){return G(V(t),e,n,i)}function R(e,t,n,i){return T(e,t,n,i)}function k(e,t,n,i){return G(Y(t),e,n,i)}function C(e,t,n,i){return G(X(t,e.length-n),e,n,i)}function $(e,t,n){return 0===t&&n===e.length?K.fromByteArray(e):K.fromByteArray(e.slice(t,n))}function j(e,t,n){n=Math.min(e.length,n);for(var i=[],r=t;r<n;){var o=e[r],a=null,s=o>239?4:o>223?3:o>191?2:1;if(r+s<=n){var p,c,d,l;switch(s){case 1:o<128&&(a=o);break;case 2:p=e[r+1],128===(192&p)&&(l=(31&o)<<6|63&p,l>127&&(a=l));break;case 3:p=e[r+1],c=e[r+2],128===(192&p)&&128===(192&c)&&(l=(15&o)<<12|(63&p)<<6|63&c,l>2047&&(l<55296||l>57343)&&(a=l));break;case 4:p=e[r+1],c=e[r+2],d=e[r+3],128===(192&p)&&128===(192&c)&&128===(192&d)&&(l=(15&o)<<18|(63&p)<<12|(63&c)<<6|63&d,l>65535&&l<1114112&&(a=l))}}null===a?(a=65533,s=1):a>65535&&(a-=65536,i.push(a>>>10&1023|55296),a=56320|1023&a),i.push(a),r+=s}return O(i)}function O(e){var t=e.length;if(t<=ee)return String.fromCharCode.apply(String,e);for(var n="",i=0;i<t;)n+=String.fromCharCode.apply(String,e.slice(i,i+=ee));return n}function E(e,t,n){var i="";n=Math.min(e.length,n);for(var r=t;r<n;++r)i+=String.fromCharCode(127&e[r]);return i}function A(e,t,n){var i="";n=Math.min(e.length,n);for(var r=t;r<n;++r)i+=String.fromCharCode(e[r]);return i}function D(e,t,n){var i=e.length;(!t||t<0)&&(t=0),(!n||n<0||n>i)&&(n=i);for(var r="",o=t;o<n;++o)r+=H(e[o]);return r}function P(e,t,n){for(var i=e.slice(t,n),r="",o=0;o<i.length;o+=2)r+=String.fromCharCode(i[o]+256*i[o+1]);return r}function L(e,t,n){if(e%1!==0||e<0)throw new RangeError("offset is not uint");if(e+t>n)throw new RangeError("Trying to access beyond buffer length")}function N(t,n,i,r,o,a){if(!e.isBuffer(t))throw new TypeError('"buffer" argument must be a Buffer instance');if(n>o||n<a)throw new RangeError('"value" argument is out of bounds');if(i+r>t.length)throw new RangeError("Index out of range")}function M(e,t,n,i){t<0&&(t=65535+t+1);for(var r=0,o=Math.min(e.length-n,2);r<o;++r)e[n+r]=(t&255<<8*(i?r:1-r))>>>8*(i?r:1-r)}function q(e,t,n,i){t<0&&(t=4294967295+t+1);for(var r=0,o=Math.min(e.length-n,4);r<o;++r)e[n+r]=t>>>8*(i?r:3-r)&255}function U(e,t,n,i,r,o){if(n+i>e.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("Index out of range")}function _(e,t,n,i,r){return r||U(e,t,n,4,3.4028234663852886e38,-3.4028234663852886e38),Q.write(e,t,n,i,23,4),n+4}function F(e,t,n,i,r){return r||U(e,t,n,8,1.7976931348623157e308,-1.7976931348623157e308),Q.write(e,t,n,i,52,8),n+8}function B(e){if(e=W(e).replace(te,""),e.length<2)return"";for(;e.length%4!==0;)e+="=";return e}function W(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}function H(e){return e<16?"0"+e.toString(16):e.toString(16)}function z(e,t){t=t||1/0;for(var n,i=e.length,r=null,o=[],a=0;a<i;++a){if(n=e.charCodeAt(a),n>55295&&n<57344){if(!r){if(n>56319){(t-=3)>-1&&o.push(239,191,189);continue}if(a+1===i){(t-=3)>-1&&o.push(239,191,189);continue}r=n;continue}if(n<56320){(t-=3)>-1&&o.push(239,191,189),r=n;continue}n=(r-55296<<10|n-56320)+65536}else r&&(t-=3)>-1&&o.push(239,191,189);if(r=null,n<128){if((t-=1)<0)break;o.push(n)}else if(n<2048){if((t-=2)<0)break;o.push(n>>6|192,63&n|128)}else if(n<65536){if((t-=3)<0)break;o.push(n>>12|224,n>>6&63|128,63&n|128)}else{if(!(n<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;o.push(n>>18|240,n>>12&63|128,n>>6&63|128,63&n|128)}}return o}function V(e){for(var t=[],n=0;n<e.length;++n)t.push(255&e.charCodeAt(n));return t}function X(e,t){for(var n,i,r,o=[],a=0;a<e.length&&!((t-=2)<0);++a)n=e.charCodeAt(a),i=n>>8,r=n%256,o.push(r),o.push(i);return o}function Y(e){return K.toByteArray(B(e))}function G(e,t,n,i){for(var r=0;r<i&&!(r+n>=t.length||r>=e.length);++r)t[r+n]=e[r];return r}function J(e){return e!==e}var K=n(5),Q=n(6),Z=n(7);t.Buffer=e,t.SlowBuffer=y,t.INSPECT_MAX_BYTES=50,e.TYPED_ARRAY_SUPPORT=void 0!==i.TYPED_ARRAY_SUPPORT?i.TYPED_ARRAY_SUPPORT:r(),t.kMaxLength=o(),e.poolSize=8192,e._augment=function(t){return t.__proto__=e.prototype,t},e.from=function(e,t,n){return s(null,e,t,n)},e.TYPED_ARRAY_SUPPORT&&(e.prototype.__proto__=Uint8Array.prototype,e.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&e[Symbol.species]===e&&Object.defineProperty(e,Symbol.species,{value:null,configurable:!0})),e.alloc=function(e,t,n){return c(null,e,t,n)},e.allocUnsafe=function(e){return d(null,e)},e.allocUnsafeSlow=function(e){return d(null,e)},e.isBuffer=function(e){return!(null==e||!e._isBuffer)},e.compare=function(t,n){if(!e.isBuffer(t)||!e.isBuffer(n))throw new TypeError("Arguments must be Buffers");if(t===n)return 0;for(var i=t.length,r=n.length,o=0,a=Math.min(i,r);o<a;++o)if(t[o]!==n[o]){i=t[o],r=n[o];break}return i<r?-1:r<i?1:0},e.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},e.concat=function(t,n){if(!Z(t))throw new TypeError('"list" argument must be an Array of Buffers');if(0===t.length)return e.alloc(0);var i;if(void 0===n)for(n=0,i=0;i<t.length;++i)n+=t[i].length;var r=e.allocUnsafe(n),o=0;for(i=0;i<t.length;++i){var a=t[i];if(!e.isBuffer(a))throw new TypeError('"list" argument must be an Array of Buffers');a.copy(r,o),o+=a.length}return r},e.byteLength=g,e.prototype._isBuffer=!0,e.prototype.swap16=function(){var e=this.length;if(e%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<e;t+=2)v(this,t,t+1);return this},e.prototype.swap32=function(){var e=this.length;if(e%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<e;t+=4)v(this,t,t+3),v(this,t+1,t+2);return this},e.prototype.swap64=function(){var e=this.length;if(e%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<e;t+=8)v(this,t,t+7),v(this,t+1,t+6),v(this,t+2,t+5),v(this,t+3,t+4);return this},e.prototype.toString=function(){var e=0|this.length;return 0===e?"":0===arguments.length?j(this,0,e):b.apply(this,arguments)},e.prototype.equals=function(t){if(!e.isBuffer(t))throw new TypeError("Argument must be a Buffer");return this===t||0===e.compare(this,t)},e.prototype.inspect=function(){var e="",n=t.INSPECT_MAX_BYTES;return this.length>0&&(e=this.toString("hex",0,n).match(/.{2}/g).join(" "),this.length>n&&(e+=" ... ")),"<Buffer "+e+">"},e.prototype.compare=function(t,n,i,r,o){if(!e.isBuffer(t))throw new TypeError("Argument must be a Buffer");if(void 0===n&&(n=0),void 0===i&&(i=t?t.length:0),void 0===r&&(r=0),void 0===o&&(o=this.length),n<0||i>t.length||r<0||o>this.length)throw new RangeError("out of range index");if(r>=o&&n>=i)return 0;if(r>=o)return-1;if(n>=i)return 1;if(n>>>=0,i>>>=0,r>>>=0,o>>>=0,this===t)return 0;for(var a=o-r,s=i-n,p=Math.min(a,s),c=this.slice(r,o),d=t.slice(n,i),l=0;l<p;++l)if(c[l]!==d[l]){a=c[l],s=d[l];break}return a<s?-1:s<a?1:0},e.prototype.includes=function(e,t,n){return this.indexOf(e,t,n)!==-1},e.prototype.indexOf=function(e,t,n){return w(this,e,t,n,!0)},e.prototype.lastIndexOf=function(e,t,n){return w(this,e,t,n,!1)},e.prototype.write=function(e,t,n,i){if(void 0===t)i="utf8",n=this.length,t=0;else if(void 0===n&&"string"==typeof t)i=t,n=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t|=0,isFinite(n)?(n|=0,void 0===i&&(i="utf8")):(i=n,n=void 0)}var r=this.length-t;if((void 0===n||n>r)&&(n=r),e.length>0&&(n<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");i||(i="utf8");for(var o=!1;;)switch(i){case"hex":return x(this,e,t,n);case"utf8":case"utf-8":return I(this,e,t,n);case"ascii":return T(this,e,t,n);case"latin1":case"binary":return R(this,e,t,n);case"base64":return k(this,e,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return C(this,e,t,n);default:if(o)throw new TypeError("Unknown encoding: "+i);i=(""+i).toLowerCase(),o=!0}},e.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var ee=4096;e.prototype.slice=function(t,n){var i=this.length;t=~~t,n=void 0===n?i:~~n,t<0?(t+=i,t<0&&(t=0)):t>i&&(t=i),n<0?(n+=i,n<0&&(n=0)):n>i&&(n=i),n<t&&(n=t);var r;if(e.TYPED_ARRAY_SUPPORT)r=this.subarray(t,n),r.__proto__=e.prototype;else{var o=n-t;r=new e(o,void 0);for(var a=0;a<o;++a)r[a]=this[a+t]}return r},e.prototype.readUIntLE=function(e,t,n){e|=0,t|=0,n||L(e,t,this.length);for(var i=this[e],r=1,o=0;++o<t&&(r*=256);)i+=this[e+o]*r;return i},e.prototype.readUIntBE=function(e,t,n){e|=0,t|=0,n||L(e,t,this.length);for(var i=this[e+--t],r=1;t>0&&(r*=256);)i+=this[e+--t]*r;return i},e.prototype.readUInt8=function(e,t){return t||L(e,1,this.length),this[e]},e.prototype.readUInt16LE=function(e,t){return t||L(e,2,this.length),this[e]|this[e+1]<<8},e.prototype.readUInt16BE=function(e,t){return t||L(e,2,this.length),this[e]<<8|this[e+1]},e.prototype.readUInt32LE=function(e,t){return t||L(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},e.prototype.readUInt32BE=function(e,t){return t||L(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},e.prototype.readIntLE=function(e,t,n){e|=0,t|=0,n||L(e,t,this.length);for(var i=this[e],r=1,o=0;++o<t&&(r*=256);)i+=this[e+o]*r;return r*=128,i>=r&&(i-=Math.pow(2,8*t)),i},e.prototype.readIntBE=function(e,t,n){e|=0,t|=0,n||L(e,t,this.length);for(var i=t,r=1,o=this[e+--i];i>0&&(r*=256);)o+=this[e+--i]*r;return r*=128,o>=r&&(o-=Math.pow(2,8*t)),o},e.prototype.readInt8=function(e,t){return t||L(e,1,this.length),128&this[e]?(255-this[e]+1)*-1:this[e]},e.prototype.readInt16LE=function(e,t){t||L(e,2,this.length);var n=this[e]|this[e+1]<<8;return 32768&n?4294901760|n:n},e.prototype.readInt16BE=function(e,t){t||L(e,2,this.length);var n=this[e+1]|this[e]<<8;return 32768&n?4294901760|n:n},e.prototype.readInt32LE=function(e,t){return t||L(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},e.prototype.readInt32BE=function(e,t){return t||L(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},e.prototype.readFloatLE=function(e,t){return t||L(e,4,this.length),Q.read(this,e,!0,23,4)},e.prototype.readFloatBE=function(e,t){return t||L(e,4,this.length),Q.read(this,e,!1,23,4)},e.prototype.readDoubleLE=function(e,t){return t||L(e,8,this.length),Q.read(this,e,!0,52,8)},e.prototype.readDoubleBE=function(e,t){return t||L(e,8,this.length),Q.read(this,e,!1,52,8)},e.prototype.writeUIntLE=function(e,t,n,i){if(e=+e,t|=0,n|=0,!i){var r=Math.pow(2,8*n)-1;N(this,e,t,n,r,0)}var o=1,a=0;for(this[t]=255&e;++a<n&&(o*=256);)this[t+a]=e/o&255;return t+n},e.prototype.writeUIntBE=function(e,t,n,i){if(e=+e,t|=0,n|=0,!i){var r=Math.pow(2,8*n)-1;N(this,e,t,n,r,0)}var o=n-1,a=1;for(this[t+o]=255&e;--o>=0&&(a*=256);)this[t+o]=e/a&255;return t+n},e.prototype.writeUInt8=function(t,n,i){return t=+t,n|=0,i||N(this,t,n,1,255,0),e.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),this[n]=255&t,n+1},e.prototype.writeUInt16LE=function(t,n,i){return t=+t,n|=0,i||N(this,t,n,2,65535,0),e.TYPED_ARRAY_SUPPORT?(this[n]=255&t,this[n+1]=t>>>8):M(this,t,n,!0),n+2},e.prototype.writeUInt16BE=function(t,n,i){return t=+t,n|=0,i||N(this,t,n,2,65535,0),e.TYPED_ARRAY_SUPPORT?(this[n]=t>>>8,this[n+1]=255&t):M(this,t,n,!1),n+2},e.prototype.writeUInt32LE=function(t,n,i){return t=+t,n|=0,i||N(this,t,n,4,4294967295,0),e.TYPED_ARRAY_SUPPORT?(this[n+3]=t>>>24,this[n+2]=t>>>16,this[n+1]=t>>>8,this[n]=255&t):q(this,t,n,!0),n+4},e.prototype.writeUInt32BE=function(t,n,i){return t=+t,n|=0,i||N(this,t,n,4,4294967295,0),e.TYPED_ARRAY_SUPPORT?(this[n]=t>>>24,this[n+1]=t>>>16,this[n+2]=t>>>8,this[n+3]=255&t):q(this,t,n,!1),n+4},e.prototype.writeIntLE=function(e,t,n,i){if(e=+e,t|=0,!i){var r=Math.pow(2,8*n-1);N(this,e,t,n,r-1,-r)}var o=0,a=1,s=0;for(this[t]=255&e;++o<n&&(a*=256);)e<0&&0===s&&0!==this[t+o-1]&&(s=1),this[t+o]=(e/a>>0)-s&255;return t+n},e.prototype.writeIntBE=function(e,t,n,i){if(e=+e,t|=0,!i){var r=Math.pow(2,8*n-1);N(this,e,t,n,r-1,-r)}var o=n-1,a=1,s=0;for(this[t+o]=255&e;--o>=0&&(a*=256);)e<0&&0===s&&0!==this[t+o+1]&&(s=1),this[t+o]=(e/a>>0)-s&255;return t+n},e.prototype.writeInt8=function(t,n,i){return t=+t,n|=0,i||N(this,t,n,1,127,-128),e.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),t<0&&(t=255+t+1),this[n]=255&t,n+1},e.prototype.writeInt16LE=function(t,n,i){return t=+t,n|=0,i||N(this,t,n,2,32767,-32768),e.TYPED_ARRAY_SUPPORT?(this[n]=255&t,this[n+1]=t>>>8):M(this,t,n,!0),n+2},e.prototype.writeInt16BE=function(t,n,i){return t=+t,n|=0,i||N(this,t,n,2,32767,-32768),e.TYPED_ARRAY_SUPPORT?(this[n]=t>>>8,this[n+1]=255&t):M(this,t,n,!1),n+2},e.prototype.writeInt32LE=function(t,n,i){return t=+t,n|=0,i||N(this,t,n,4,2147483647,-2147483648),e.TYPED_ARRAY_SUPPORT?(this[n]=255&t,this[n+1]=t>>>8,this[n+2]=t>>>16,this[n+3]=t>>>24):q(this,t,n,!0),n+4},e.prototype.writeInt32BE=function(t,n,i){return t=+t,n|=0,i||N(this,t,n,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),e.TYPED_ARRAY_SUPPORT?(this[n]=t>>>24,this[n+1]=t>>>16,this[n+2]=t>>>8,this[n+3]=255&t):q(this,t,n,!1),n+4},e.prototype.writeFloatLE=function(e,t,n){return _(this,e,t,!0,n)},e.prototype.writeFloatBE=function(e,t,n){return _(this,e,t,!1,n)},e.prototype.writeDoubleLE=function(e,t,n){return F(this,e,t,!0,n)},e.prototype.writeDoubleBE=function(e,t,n){return F(this,e,t,!1,n)},e.prototype.copy=function(t,n,i,r){if(i||(i=0),r||0===r||(r=this.length),n>=t.length&&(n=t.length),n||(n=0),r>0&&r<i&&(r=i),r===i)return 0;if(0===t.length||0===this.length)return 0;if(n<0)throw new RangeError("targetStart out of bounds");if(i<0||i>=this.length)throw new RangeError("sourceStart out of bounds");if(r<0)throw new RangeError("sourceEnd out of bounds");r>this.length&&(r=this.length),t.length-n<r-i&&(r=t.length-n+i);var o,a=r-i;if(this===t&&i<n&&n<r)for(o=a-1;o>=0;--o)t[o+n]=this[o+i];else if(a<1e3||!e.TYPED_ARRAY_SUPPORT)for(o=0;o<a;++o)t[o+n]=this[o+i];else Uint8Array.prototype.set.call(t,this.subarray(i,i+a),n);return a},e.prototype.fill=function(t,n,i,r){if("string"==typeof t){if("string"==typeof n?(r=n,n=0,i=this.length):"string"==typeof i&&(r=i,i=this.length),1===t.length){var o=t.charCodeAt(0);o<256&&(t=o)}if(void 0!==r&&"string"!=typeof r)throw new TypeError("encoding must be a string");if("string"==typeof r&&!e.isEncoding(r))throw new TypeError("Unknown encoding: "+r)}else"number"==typeof t&&(t&=255);if(n<0||this.length<n||this.length<i)throw new RangeError("Out of range index");if(i<=n)return this;n>>>=0,i=void 0===i?this.length:i>>>0,t||(t=0);var a;if("number"==typeof t)for(a=n;a<i;++a)this[a]=t;else{var s=e.isBuffer(t)?t:z(new e(t,r).toString()),p=s.length;for(a=0;a<i-n;++a)this[a+n]=s[a%p]}return this};var te=/[^+\/0-9A-Za-z-_]/g}).call(t,n(4).Buffer,function(){return this}())},function(e,t){"use strict";function n(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");return"="===e[t-2]?2:"="===e[t-1]?1:0}function i(e){return 3*e.length/4-n(e)}function r(e){var t,i,r,o,a,s,p=e.length;a=n(e),s=new d(3*p/4-a),r=a>0?p-4:p;var l=0;for(t=0,i=0;t<r;t+=4,i+=3)o=c[e.charCodeAt(t)]<<18|c[e.charCodeAt(t+1)]<<12|c[e.charCodeAt(t+2)]<<6|c[e.charCodeAt(t+3)],s[l++]=o>>16&255,s[l++]=o>>8&255,s[l++]=255&o;return 2===a?(o=c[e.charCodeAt(t)]<<2|c[e.charCodeAt(t+1)]>>4,s[l++]=255&o):1===a&&(o=c[e.charCodeAt(t)]<<10|c[e.charCodeAt(t+1)]<<4|c[e.charCodeAt(t+2)]>>2,s[l++]=o>>8&255,s[l++]=255&o),s}function o(e){return p[e>>18&63]+p[e>>12&63]+p[e>>6&63]+p[63&e]}function a(e,t,n){for(var i,r=[],a=t;a<n;a+=3)i=(e[a]<<16)+(e[a+1]<<8)+e[a+2],r.push(o(i));return r.join("")}function s(e){for(var t,n=e.length,i=n%3,r="",o=[],s=16383,c=0,d=n-i;c<d;c+=s)o.push(a(e,c,c+s>d?d:c+s));return 1===i?(t=e[n-1],r+=p[t>>2],r+=p[t<<4&63],r+="=="):2===i&&(t=(e[n-2]<<8)+e[n-1],r+=p[t>>10],r+=p[t>>4&63],r+=p[t<<2&63],r+="="),o.push(r),o.join("")}t.byteLength=i,t.toByteArray=r,t.fromByteArray=s;for(var p=[],c=[],d="undefined"!=typeof Uint8Array?Uint8Array:Array,l="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",m=0,u=l.length;m<u;++m)p[m]=l[m],c[l.charCodeAt(m)]=m;c["-".charCodeAt(0)]=62,c["_".charCodeAt(0)]=63},function(e,t){t.read=function(e,t,n,i,r){var o,a,s=8*r-i-1,p=(1<<s)-1,c=p>>1,d=-7,l=n?r-1:0,m=n?-1:1,u=e[t+l];for(l+=m,o=u&(1<<-d)-1,u>>=-d,d+=s;d>0;o=256*o+e[t+l],l+=m,d-=8);for(a=o&(1<<-d)-1,o>>=-d,d+=i;d>0;a=256*a+e[t+l],l+=m,d-=8);if(0===o)o=1-c;else{if(o===p)return a?NaN:(u?-1:1)*(1/0);a+=Math.pow(2,i),o-=c}return(u?-1:1)*a*Math.pow(2,o-i)},t.write=function(e,t,n,i,r,o){var a,s,p,c=8*o-r-1,d=(1<<c)-1,l=d>>1,m=23===r?Math.pow(2,-24)-Math.pow(2,-77):0,u=i?0:o-1,h=i?1:-1,f=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(s=isNaN(t)?1:0,a=d):(a=Math.floor(Math.log(t)/Math.LN2),t*(p=Math.pow(2,-a))<1&&(a--,p*=2),t+=a+l>=1?m/p:m*Math.pow(2,1-l),t*p>=2&&(a++,p/=2),a+l>=d?(s=0,a=d):a+l>=1?(s=(t*p-1)*Math.pow(2,r),a+=l):(s=t*Math.pow(2,l-1)*Math.pow(2,r),a=0));r>=8;e[n+u]=255&s,u+=h,s/=256,r-=8);for(a=a<<r|s,c+=r;c>0;e[n+u]=255&a,u+=h,a/=256,c-=8);e[n+u-h]|=128*f}},function(e,t){var n={}.toString;e.exports=Array.isArray||function(e){return"[object Array]"==n.call(e)}},function(e,t,n){var i=e.exports,r=(n(2).EventEmitter,n(9)),o=n(31);i.request=function(e,t){"string"==typeof e&&(e=o.parse(e)),e||(e={}),e.host||e.port||(e.port=parseInt(window.location.port,10)),!e.host&&e.hostname&&(e.host=e.hostname),e.protocol||(e.scheme?e.protocol=e.scheme+":":e.protocol=window.location.protocol),e.host||(e.host=window.location.hostname||window.location.host),/:/.test(e.host)&&(e.port||(e.port=e.host.split(":")[1]),e.host=e.host.split(":")[0]),e.port||(e.port="https:"==e.protocol?443:80);
	var n=new r(new a,e);return t&&n.on("response",t),n},i.get=function(e,t){e.method="GET";var n=i.request(e,t);return n.end(),n},i.Agent=function(){},i.Agent.defaultMaxSockets=4;var a=function(){if("undefined"==typeof window)throw new Error("no window object present");if(window.XMLHttpRequest)return window.XMLHttpRequest;if(window.ActiveXObject){for(var e=["Msxml2.XMLHTTP.6.0","Msxml2.XMLHTTP.3.0","Microsoft.XMLHTTP"],t=0;t<e.length;t++)try{var n=new window.ActiveXObject(e[t]);return function(){if(n){var i=n;return n=null,i}return new window.ActiveXObject(e[t])}}catch(e){}throw new Error("ajax not supported in this browser")}throw new Error("ajax not supported in this browser")}();i.STATUS_CODES={100:"Continue",101:"Switching Protocols",102:"Processing",200:"OK",201:"Created",202:"Accepted",203:"Non-Authoritative Information",204:"No Content",205:"Reset Content",206:"Partial Content",207:"Multi-Status",300:"Multiple Choices",301:"Moved Permanently",302:"Moved Temporarily",303:"See Other",304:"Not Modified",305:"Use Proxy",307:"Temporary Redirect",400:"Bad Request",401:"Unauthorized",402:"Payment Required",403:"Forbidden",404:"Not Found",405:"Method Not Allowed",406:"Not Acceptable",407:"Proxy Authentication Required",408:"Request Time-out",409:"Conflict",410:"Gone",411:"Length Required",412:"Precondition Failed",413:"Request Entity Too Large",414:"Request-URI Too Large",415:"Unsupported Media Type",416:"Requested Range Not Satisfiable",417:"Expectation Failed",418:"I'm a teapot",422:"Unprocessable Entity",423:"Locked",424:"Failed Dependency",425:"Unordered Collection",426:"Upgrade Required",428:"Precondition Required",429:"Too Many Requests",431:"Request Header Fields Too Large",500:"Internal Server Error",501:"Not Implemented",502:"Bad Gateway",503:"Service Unavailable",504:"Gateway Time-out",505:"HTTP Version Not Supported",506:"Variant Also Negotiates",507:"Insufficient Storage",509:"Bandwidth Limit Exceeded",510:"Not Extended",511:"Network Authentication Required"}},function(e,t,n){var i=n(10),r=n(26),o=n(30),a=n(11),s=e.exports=function(e,t){var n=this;n.writable=!0,n.xhr=e,n.body=[],n.uri=(t.protocol||"http:")+"//"+t.host+(t.port?":"+t.port:"")+(t.path||"/"),"undefined"==typeof t.withCredentials&&(t.withCredentials=!0);try{e.withCredentials=t.withCredentials}catch(e){}if(t.responseType)try{e.responseType=t.responseType}catch(e){}if(e.open(t.method||"GET",n.uri,!0),e.onerror=function(e){n.emit("error",new Error("Network error"))},n._headers={},t.headers)for(var i=p(t.headers),a=0;a<i.length;a++){var s=i[a];if(n.isSafeRequestHeader(s)){var c=t.headers[s];n.setHeader(s,c)}}t.auth&&this.setHeader("Authorization","Basic "+o.btoa(t.auth));var d=new r;d.on("close",function(){n.emit("close")}),d.on("ready",function(){n.emit("response",d)}),d.on("error",function(e){n.emit("error",e)}),e.onreadystatechange=function(){e.__aborted||d.handle(e)}};a(s,i),s.prototype.setHeader=function(e,t){this._headers[e.toLowerCase()]=t},s.prototype.getHeader=function(e){return this._headers[e.toLowerCase()]},s.prototype.removeHeader=function(e){delete this._headers[e.toLowerCase()]},s.prototype.write=function(e){this.body.push(e)},s.prototype.destroy=function(e){this.xhr.__aborted=!0,this.xhr.abort(),this.emit("close")},s.prototype.end=function(e){void 0!==e&&this.body.push(e);for(var t=p(this._headers),n=0;n<t.length;n++){var i=t[n],r=this._headers[i];if(c(r))for(var o=0;o<r.length;o++)this.xhr.setRequestHeader(i,r[o]);else this.xhr.setRequestHeader(i,r)}if(0===this.body.length)this.xhr.send("");else if("string"==typeof this.body[0])this.xhr.send(this.body.join(""));else if(c(this.body[0])){for(var a=[],n=0;n<this.body.length;n++)a.push.apply(a,this.body[n]);this.xhr.send(a)}else if(/Array/.test(Object.prototype.toString.call(this.body[0]))){for(var s=0,n=0;n<this.body.length;n++)s+=this.body[n].length;for(var a=new this.body[0].constructor(s),d=0,n=0;n<this.body.length;n++)for(var m=this.body[n],o=0;o<m.length;o++)a[d++]=m[o];this.xhr.send(a)}else if(l(this.body[0]))this.xhr.send(this.body[0]);else{for(var a="",n=0;n<this.body.length;n++)a+=this.body[n].toString();this.xhr.send(a)}},s.unsafeHeaders=["accept-charset","accept-encoding","access-control-request-headers","access-control-request-method","connection","content-length","cookie","cookie2","content-transfer-encoding","date","expect","host","keep-alive","origin","referer","te","trailer","transfer-encoding","upgrade","user-agent","via"],s.prototype.isSafeRequestHeader=function(e){return!!e&&d(s.unsafeHeaders,e.toLowerCase())===-1};var p=Object.keys||function(e){var t=[];for(var n in e)t.push(n);return t},c=Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)},d=function(e,t){if(e.indexOf)return e.indexOf(t);for(var n=0;n<e.length;n++)if(e[n]===t)return n;return-1},l=function(e){return"undefined"!=typeof Blob&&e instanceof Blob||("undefined"!=typeof ArrayBuffer&&e instanceof ArrayBuffer||("undefined"!=typeof FormData&&e instanceof FormData||void 0))}},function(e,t,n){function i(){r.call(this)}e.exports=i;var r=n(2).EventEmitter,o=n(11);o(i,r),i.Readable=n(12),i.Writable=n(22),i.Duplex=n(23),i.Transform=n(24),i.PassThrough=n(25),i.Stream=i,i.prototype.pipe=function(e,t){function n(t){e.writable&&!1===e.write(t)&&c.pause&&c.pause()}function i(){c.readable&&c.resume&&c.resume()}function o(){d||(d=!0,e.end())}function a(){d||(d=!0,"function"==typeof e.destroy&&e.destroy())}function s(e){if(p(),0===r.listenerCount(this,"error"))throw e}function p(){c.removeListener("data",n),e.removeListener("drain",i),c.removeListener("end",o),c.removeListener("close",a),c.removeListener("error",s),e.removeListener("error",s),c.removeListener("end",p),c.removeListener("close",p),e.removeListener("close",p)}var c=this;c.on("data",n),e.on("drain",i),e._isStdio||t&&t.end===!1||(c.on("end",o),c.on("close",a));var d=!1;return c.on("error",s),e.on("error",s),c.on("end",p),c.on("close",p),e.on("close",p),e.emit("pipe",c),e}},function(e,t){"function"==typeof Object.create?e.exports=function(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}})}:e.exports=function(e,t){e.super_=t;var n=function(){};n.prototype=t.prototype,e.prototype=new n,e.prototype.constructor=e}},function(e,t,n){(function(i){t=e.exports=n(13),t.Stream=n(10),t.Readable=t,t.Writable=n(18),t.Duplex=n(17),t.Transform=n(20),t.PassThrough=n(21),i.browser||"disable"!==i.env.READABLE_STREAM||(e.exports=n(10))}).call(t,n(1))},function(e,t,n){(function(t){function i(e,t){var i=n(17);e=e||{};var r=e.highWaterMark,o=e.objectMode?16:16384;this.highWaterMark=r||0===r?r:o,this.highWaterMark=~~this.highWaterMark,this.buffer=[],this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.objectMode=!!e.objectMode,t instanceof i&&(this.objectMode=this.objectMode||!!e.readableObjectMode),this.defaultEncoding=e.defaultEncoding||"utf8",this.ranOut=!1,this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,e.encoding&&($||($=n(19).StringDecoder),this.decoder=new $(e.encoding),this.encoding=e.encoding)}function r(e){n(17);return this instanceof r?(this._readableState=new i(e,this),this.readable=!0,void k.call(this)):new r(e)}function o(e,t,n,i,r){var o=c(t,n);if(o)e.emit("error",o);else if(C.isNullOrUndefined(n))t.reading=!1,t.ended||d(e,t);else if(t.objectMode||n&&n.length>0)if(t.ended&&!r){var s=new Error("stream.push() after EOF");e.emit("error",s)}else if(t.endEmitted&&r){var s=new Error("stream.unshift() after end event");e.emit("error",s)}else!t.decoder||r||i||(n=t.decoder.write(n)),r||(t.reading=!1),t.flowing&&0===t.length&&!t.sync?(e.emit("data",n),e.read(0)):(t.length+=t.objectMode?1:n.length,r?t.buffer.unshift(n):t.buffer.push(n),t.needReadable&&l(e)),u(e,t);else r||(t.reading=!1);return a(t)}function a(e){return!e.ended&&(e.needReadable||e.length<e.highWaterMark||0===e.length)}function s(e){if(e>=O)e=O;else{e--;for(var t=1;t<32;t<<=1)e|=e>>t;e++}return e}function p(e,t){return 0===t.length&&t.ended?0:t.objectMode?0===e?0:1:isNaN(e)||C.isNull(e)?t.flowing&&t.buffer.length?t.buffer[0].length:t.length:e<=0?0:(e>t.highWaterMark&&(t.highWaterMark=s(e)),e>t.length?t.ended?t.length:(t.needReadable=!0,0):e)}function c(e,t){var n=null;return C.isBuffer(t)||C.isString(t)||C.isNullOrUndefined(t)||e.objectMode||(n=new TypeError("Invalid non-string/buffer chunk")),n}function d(e,t){if(t.decoder&&!t.ended){var n=t.decoder.end();n&&n.length&&(t.buffer.push(n),t.length+=t.objectMode?1:n.length)}t.ended=!0,l(e)}function l(e){var n=e._readableState;n.needReadable=!1,n.emittedReadable||(j("emitReadable",n.flowing),n.emittedReadable=!0,n.sync?t.nextTick(function(){m(e)}):m(e))}function m(e){j("emit readable"),e.emit("readable"),b(e)}function u(e,n){n.readingMore||(n.readingMore=!0,t.nextTick(function(){h(e,n)}))}function h(e,t){for(var n=t.length;!t.reading&&!t.flowing&&!t.ended&&t.length<t.highWaterMark&&(j("maybeReadMore read 0"),e.read(0),n!==t.length);)n=t.length;t.readingMore=!1}function f(e){return function(){var t=e._readableState;j("pipeOnDrain",t.awaitDrain),t.awaitDrain&&t.awaitDrain--,0===t.awaitDrain&&R.listenerCount(e,"data")&&(t.flowing=!0,b(e))}}function y(e,n){n.resumeScheduled||(n.resumeScheduled=!0,t.nextTick(function(){g(e,n)}))}function g(e,t){t.resumeScheduled=!1,e.emit("resume"),b(e),t.flowing&&!t.reading&&e.read(0)}function b(e){var t=e._readableState;if(j("flow",t.flowing),t.flowing)do var n=e.read();while(null!==n&&t.flowing)}function v(e,t){var n,i=t.buffer,r=t.length,o=!!t.decoder,a=!!t.objectMode;if(0===i.length)return null;if(0===r)n=null;else if(a)n=i.shift();else if(!e||e>=r)n=o?i.join(""):T.concat(i,r),i.length=0;else if(e<i[0].length){var s=i[0];n=s.slice(0,e),i[0]=s.slice(e)}else if(e===i[0].length)n=i.shift();else{n=o?"":new T(e);for(var p=0,c=0,d=i.length;c<d&&p<e;c++){var s=i[0],l=Math.min(e-p,s.length);o?n+=s.slice(0,l):s.copy(n,p,0,l),l<s.length?i[0]=s.slice(l):i.shift(),p+=l}}return n}function w(e){var n=e._readableState;if(n.length>0)throw new Error("endReadable called on non-empty stream");n.endEmitted||(n.ended=!0,t.nextTick(function(){n.endEmitted||0!==n.length||(n.endEmitted=!0,e.readable=!1,e.emit("end"))}))}function S(e,t){for(var n=0,i=e.length;n<i;n++)t(e[n],n)}function x(e,t){for(var n=0,i=e.length;n<i;n++)if(e[n]===t)return n;return-1}e.exports=r;var I=n(14),T=n(4).Buffer;r.ReadableState=i;var R=n(2).EventEmitter;R.listenerCount||(R.listenerCount=function(e,t){return e.listeners(t).length});var k=n(10),C=n(15);C.inherits=n(11);var $,j=n(16);j=j&&j.debuglog?j.debuglog("stream"):function(){},C.inherits(r,k),r.prototype.push=function(e,t){var n=this._readableState;return C.isString(e)&&!n.objectMode&&(t=t||n.defaultEncoding,t!==n.encoding&&(e=new T(e,t),t="")),o(this,n,e,t,!1)},r.prototype.unshift=function(e){var t=this._readableState;return o(this,t,e,"",!0)},r.prototype.setEncoding=function(e){return $||($=n(19).StringDecoder),this._readableState.decoder=new $(e),this._readableState.encoding=e,this};var O=8388608;r.prototype.read=function(e){j("read",e);var t=this._readableState,n=e;if((!C.isNumber(e)||e>0)&&(t.emittedReadable=!1),0===e&&t.needReadable&&(t.length>=t.highWaterMark||t.ended))return j("read: emitReadable",t.length,t.ended),0===t.length&&t.ended?w(this):l(this),null;if(e=p(e,t),0===e&&t.ended)return 0===t.length&&w(this),null;var i=t.needReadable;j("need readable",i),(0===t.length||t.length-e<t.highWaterMark)&&(i=!0,j("length less than watermark",i)),(t.ended||t.reading)&&(i=!1,j("reading or ended",i)),i&&(j("do read"),t.reading=!0,t.sync=!0,0===t.length&&(t.needReadable=!0),this._read(t.highWaterMark),t.sync=!1),i&&!t.reading&&(e=p(n,t));var r;return r=e>0?v(e,t):null,C.isNull(r)&&(t.needReadable=!0,e=0),t.length-=e,0!==t.length||t.ended||(t.needReadable=!0),n!==e&&t.ended&&0===t.length&&w(this),C.isNull(r)||this.emit("data",r),r},r.prototype._read=function(e){this.emit("error",new Error("not implemented"))},r.prototype.pipe=function(e,n){function i(e){j("onunpipe"),e===l&&o()}function r(){j("onend"),e.end()}function o(){j("cleanup"),e.removeListener("close",p),e.removeListener("finish",c),e.removeListener("drain",y),e.removeListener("error",s),e.removeListener("unpipe",i),l.removeListener("end",r),l.removeListener("end",o),l.removeListener("data",a),!m.awaitDrain||e._writableState&&!e._writableState.needDrain||y()}function a(t){j("ondata");var n=e.write(t);!1===n&&(j("false write response, pause",l._readableState.awaitDrain),l._readableState.awaitDrain++,l.pause())}function s(t){j("onerror",t),d(),e.removeListener("error",s),0===R.listenerCount(e,"error")&&e.emit("error",t)}function p(){e.removeListener("finish",c),d()}function c(){j("onfinish"),e.removeListener("close",p),d()}function d(){j("unpipe"),l.unpipe(e)}var l=this,m=this._readableState;switch(m.pipesCount){case 0:m.pipes=e;break;case 1:m.pipes=[m.pipes,e];break;default:m.pipes.push(e)}m.pipesCount+=1,j("pipe count=%d opts=%j",m.pipesCount,n);var u=(!n||n.end!==!1)&&e!==t.stdout&&e!==t.stderr,h=u?r:o;m.endEmitted?t.nextTick(h):l.once("end",h),e.on("unpipe",i);var y=f(l);return e.on("drain",y),l.on("data",a),e._events&&e._events.error?I(e._events.error)?e._events.error.unshift(s):e._events.error=[s,e._events.error]:e.on("error",s),e.once("close",p),e.once("finish",c),e.emit("pipe",l),m.flowing||(j("pipe resume"),l.resume()),e},r.prototype.unpipe=function(e){var t=this._readableState;if(0===t.pipesCount)return this;if(1===t.pipesCount)return e&&e!==t.pipes?this:(e||(e=t.pipes),t.pipes=null,t.pipesCount=0,t.flowing=!1,e&&e.emit("unpipe",this),this);if(!e){var n=t.pipes,i=t.pipesCount;t.pipes=null,t.pipesCount=0,t.flowing=!1;for(var r=0;r<i;r++)n[r].emit("unpipe",this);return this}var r=x(t.pipes,e);return r===-1?this:(t.pipes.splice(r,1),t.pipesCount-=1,1===t.pipesCount&&(t.pipes=t.pipes[0]),e.emit("unpipe",this),this)},r.prototype.on=function(e,n){var i=k.prototype.on.call(this,e,n);if("data"===e&&!1!==this._readableState.flowing&&this.resume(),"readable"===e&&this.readable){var r=this._readableState;if(!r.readableListening)if(r.readableListening=!0,r.emittedReadable=!1,r.needReadable=!0,r.reading)r.length&&l(this,r);else{var o=this;t.nextTick(function(){j("readable nexttick read 0"),o.read(0)})}}return i},r.prototype.addListener=r.prototype.on,r.prototype.resume=function(){var e=this._readableState;return e.flowing||(j("resume"),e.flowing=!0,e.reading||(j("resume read 0"),this.read(0)),y(this,e)),this},r.prototype.pause=function(){return j("call pause flowing=%j",this._readableState.flowing),!1!==this._readableState.flowing&&(j("pause"),this._readableState.flowing=!1,this.emit("pause")),this},r.prototype.wrap=function(e){var t=this._readableState,n=!1,i=this;e.on("end",function(){if(j("wrapped end"),t.decoder&&!t.ended){var e=t.decoder.end();e&&e.length&&i.push(e)}i.push(null)}),e.on("data",function(r){if(j("wrapped data"),t.decoder&&(r=t.decoder.write(r)),r&&(t.objectMode||r.length)){var o=i.push(r);o||(n=!0,e.pause())}});for(var r in e)C.isFunction(e[r])&&C.isUndefined(this[r])&&(this[r]=function(t){return function(){return e[t].apply(e,arguments)}}(r));var o=["error","close","destroy","pause","resume"];return S(o,function(t){e.on(t,i.emit.bind(i,t))}),i._read=function(t){j("wrapped _read",t),n&&(n=!1,e.resume())},i},r._fromList=v}).call(t,n(1))},function(e,t){e.exports=Array.isArray||function(e){return"[object Array]"==Object.prototype.toString.call(e)}},function(e,t,n){(function(e){function n(e){return Array.isArray?Array.isArray(e):"[object Array]"===y(e)}function i(e){return"boolean"==typeof e}function r(e){return null===e}function o(e){return null==e}function a(e){return"number"==typeof e}function s(e){return"string"==typeof e}function p(e){return"symbol"==typeof e}function c(e){return void 0===e}function d(e){return"[object RegExp]"===y(e)}function l(e){return"object"==typeof e&&null!==e}function m(e){return"[object Date]"===y(e)}function u(e){return"[object Error]"===y(e)||e instanceof Error}function h(e){return"function"==typeof e}function f(e){return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"==typeof e||"undefined"==typeof e}function y(e){return Object.prototype.toString.call(e)}t.isArray=n,t.isBoolean=i,t.isNull=r,t.isNullOrUndefined=o,t.isNumber=a,t.isString=s,t.isSymbol=p,t.isUndefined=c,t.isRegExp=d,t.isObject=l,t.isDate=m,t.isError=u,t.isFunction=h,t.isPrimitive=f,t.isBuffer=e.isBuffer}).call(t,n(4).Buffer)},function(e,t){},function(e,t,n){(function(t){function i(e){return this instanceof i?(p.call(this,e),c.call(this,e),e&&e.readable===!1&&(this.readable=!1),e&&e.writable===!1&&(this.writable=!1),this.allowHalfOpen=!0,e&&e.allowHalfOpen===!1&&(this.allowHalfOpen=!1),void this.once("end",r)):new i(e)}function r(){this.allowHalfOpen||this._writableState.ended||t.nextTick(this.end.bind(this))}function o(e,t){for(var n=0,i=e.length;n<i;n++)t(e[n],n)}e.exports=i;var a=Object.keys||function(e){var t=[];for(var n in e)t.push(n);return t},s=n(15);s.inherits=n(11);var p=n(13),c=n(18);s.inherits(i,p),o(a(c.prototype),function(e){i.prototype[e]||(i.prototype[e]=c.prototype[e])})}).call(t,n(1))},function(e,t,n){(function(t){function i(e,t,n){this.chunk=e,this.encoding=t,this.callback=n}function r(e,t){var i=n(17);e=e||{};var r=e.highWaterMark,o=e.objectMode?16:16384;this.highWaterMark=r||0===r?r:o,this.objectMode=!!e.objectMode,t instanceof i&&(this.objectMode=this.objectMode||!!e.writableObjectMode),this.highWaterMark=~~this.highWaterMark,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1;var a=e.decodeStrings===!1;this.decodeStrings=!a,this.defaultEncoding=e.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(e){u(t,e)},this.writecb=null,this.writelen=0,this.buffer=[],this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1}function o(e){var t=n(17);return this instanceof o||this instanceof t?(this._writableState=new r(e,this),this.writable=!0,void I.call(this)):new o(e)}function a(e,n,i){var r=new Error("write after end");e.emit("error",r),t.nextTick(function(){i(r)})}function s(e,n,i,r){var o=!0;if(!(x.isBuffer(i)||x.isString(i)||x.isNullOrUndefined(i)||n.objectMode)){var a=new TypeError("Invalid non-string/buffer chunk");e.emit("error",a),t.nextTick(function(){r(a)}),o=!1}return o}function p(e,t,n){return!e.objectMode&&e.decodeStrings!==!1&&x.isString(t)&&(t=new S(t,n)),t}function c(e,t,n,r,o){n=p(t,n,r),x.isBuffer(n)&&(r="buffer");var a=t.objectMode?1:n.length;t.length+=a;var s=t.length<t.highWaterMark;return s||(t.needDrain=!0),t.writing||t.corked?t.buffer.push(new i(n,r,o)):d(e,t,!1,a,n,r,o),s}function d(e,t,n,i,r,o,a){t.writelen=i,t.writecb=a,t.writing=!0,t.sync=!0,n?e._writev(r,t.onwrite):e._write(r,o,t.onwrite),t.sync=!1}function l(e,n,i,r,o){i?t.nextTick(function(){n.pendingcb--,o(r)}):(n.pendingcb--,o(r)),e._writableState.errorEmitted=!0,e.emit("error",r)}function m(e){e.writing=!1,e.writecb=null,e.length-=e.writelen,e.writelen=0}function u(e,n){var i=e._writableState,r=i.sync,o=i.writecb;if(m(i),n)l(e,i,r,n,o);else{var a=g(e,i);a||i.corked||i.bufferProcessing||!i.buffer.length||y(e,i),r?t.nextTick(function(){h(e,i,a,o)}):h(e,i,a,o)}}function h(e,t,n,i){n||f(e,t),t.pendingcb--,i(),v(e,t)}function f(e,t){0===t.length&&t.needDrain&&(t.needDrain=!1,e.emit("drain"))}function y(e,t){if(t.bufferProcessing=!0,e._writev&&t.buffer.length>1){for(var n=[],i=0;i<t.buffer.length;i++)n.push(t.buffer[i].callback);t.pendingcb++,d(e,t,!0,t.length,t.buffer,"",function(e){for(var i=0;i<n.length;i++)t.pendingcb--,n[i](e)}),t.buffer=[]}else{for(var i=0;i<t.buffer.length;i++){var r=t.buffer[i],o=r.chunk,a=r.encoding,s=r.callback,p=t.objectMode?1:o.length;if(d(e,t,!1,p,o,a,s),t.writing){i++;break}}i<t.buffer.length?t.buffer=t.buffer.slice(i):t.buffer.length=0}t.bufferProcessing=!1}function g(e,t){return t.ending&&0===t.length&&!t.finished&&!t.writing}function b(e,t){t.prefinished||(t.prefinished=!0,e.emit("prefinish"))}function v(e,t){var n=g(e,t);return n&&(0===t.pendingcb?(b(e,t),t.finished=!0,e.emit("finish")):b(e,t)),n}function w(e,n,i){n.ending=!0,v(e,n),i&&(n.finished?t.nextTick(i):e.once("finish",i)),n.ended=!0}e.exports=o;var S=n(4).Buffer;o.WritableState=r;var x=n(15);x.inherits=n(11);var I=n(10);x.inherits(o,I),o.prototype.pipe=function(){this.emit("error",new Error("Cannot pipe. Not readable."))},o.prototype.write=function(e,t,n){var i=this._writableState,r=!1;return x.isFunction(t)&&(n=t,t=null),x.isBuffer(e)?t="buffer":t||(t=i.defaultEncoding),x.isFunction(n)||(n=function(){}),i.ended?a(this,i,n):s(this,i,e,n)&&(i.pendingcb++,r=c(this,i,e,t,n)),r},o.prototype.cork=function(){var e=this._writableState;e.corked++},o.prototype.uncork=function(){var e=this._writableState;e.corked&&(e.corked--,e.writing||e.corked||e.finished||e.bufferProcessing||!e.buffer.length||y(this,e))},o.prototype._write=function(e,t,n){n(new Error("not implemented"))},o.prototype._writev=null,o.prototype.end=function(e,t,n){var i=this._writableState;x.isFunction(e)?(n=e,e=null,t=null):x.isFunction(t)&&(n=t,t=null),x.isNullOrUndefined(e)||this.write(e,t),i.corked&&(i.corked=1,this.uncork()),i.ending||i.finished||w(this,i,n)}}).call(t,n(1))},function(e,t,n){function i(e){if(e&&!p(e))throw new Error("Unknown encoding: "+e)}function r(e){return e.toString(this.encoding)}function o(e){this.charReceived=e.length%2,this.charLength=this.charReceived?2:0}function a(e){this.charReceived=e.length%3,this.charLength=this.charReceived?3:0}var s=n(4).Buffer,p=s.isEncoding||function(e){switch(e&&e.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return!0;default:return!1}},c=t.StringDecoder=function(e){switch(this.encoding=(e||"utf8").toLowerCase().replace(/[-_]/,""),i(e),this.encoding){case"utf8":this.surrogateSize=3;break;case"ucs2":case"utf16le":this.surrogateSize=2,this.detectIncompleteChar=o;break;case"base64":this.surrogateSize=3,this.detectIncompleteChar=a;break;default:return void(this.write=r)}this.charBuffer=new s(6),this.charReceived=0,this.charLength=0};c.prototype.write=function(e){for(var t="";this.charLength;){var n=e.length>=this.charLength-this.charReceived?this.charLength-this.charReceived:e.length;if(e.copy(this.charBuffer,this.charReceived,0,n),this.charReceived+=n,this.charReceived<this.charLength)return"";e=e.slice(n,e.length),t=this.charBuffer.slice(0,this.charLength).toString(this.encoding);var i=t.charCodeAt(t.length-1);if(!(i>=55296&&i<=56319)){if(this.charReceived=this.charLength=0,0===e.length)return t;break}this.charLength+=this.surrogateSize,t=""}this.detectIncompleteChar(e);var r=e.length;this.charLength&&(e.copy(this.charBuffer,0,e.length-this.charReceived,r),r-=this.charReceived),t+=e.toString(this.encoding,0,r);var r=t.length-1,i=t.charCodeAt(r);if(i>=55296&&i<=56319){var o=this.surrogateSize;return this.charLength+=o,this.charReceived+=o,this.charBuffer.copy(this.charBuffer,o,0,o),e.copy(this.charBuffer,0,0,o),t.substring(0,r)}return t},c.prototype.detectIncompleteChar=function(e){for(var t=e.length>=3?3:e.length;t>0;t--){var n=e[e.length-t];if(1==t&&n>>5==6){this.charLength=2;break}if(t<=2&&n>>4==14){this.charLength=3;break}if(t<=3&&n>>3==30){this.charLength=4;break}}this.charReceived=t},c.prototype.end=function(e){var t="";if(e&&e.length&&(t=this.write(e)),this.charReceived){var n=this.charReceived,i=this.charBuffer,r=this.encoding;t+=i.slice(0,n).toString(r)}return t}},function(e,t,n){function i(e,t){this.afterTransform=function(e,n){return r(t,e,n)},this.needTransform=!1,this.transforming=!1,this.writecb=null,this.writechunk=null}function r(e,t,n){var i=e._transformState;i.transforming=!1;var r=i.writecb;if(!r)return e.emit("error",new Error("no writecb in Transform class"));i.writechunk=null,i.writecb=null,p.isNullOrUndefined(n)||e.push(n),r&&r(t);var o=e._readableState;o.reading=!1,(o.needReadable||o.length<o.highWaterMark)&&e._read(o.highWaterMark)}function o(e){if(!(this instanceof o))return new o(e);s.call(this,e),this._transformState=new i(e,this);var t=this;this._readableState.needReadable=!0,this._readableState.sync=!1,this.once("prefinish",function(){p.isFunction(this._flush)?this._flush(function(e){a(t,e)}):a(t)})}function a(e,t){if(t)return e.emit("error",t);var n=e._writableState,i=e._transformState;if(n.length)throw new Error("calling transform done when ws.length != 0");if(i.transforming)throw new Error("calling transform done when still transforming");return e.push(null)}e.exports=o;var s=n(17),p=n(15);p.inherits=n(11),p.inherits(o,s),o.prototype.push=function(e,t){return this._transformState.needTransform=!1,s.prototype.push.call(this,e,t)},o.prototype._transform=function(e,t,n){throw new Error("not implemented")},o.prototype._write=function(e,t,n){var i=this._transformState;if(i.writecb=n,i.writechunk=e,i.writeencoding=t,!i.transforming){var r=this._readableState;(i.needTransform||r.needReadable||r.length<r.highWaterMark)&&this._read(r.highWaterMark)}},o.prototype._read=function(e){var t=this._transformState;p.isNull(t.writechunk)||!t.writecb||t.transforming?t.needTransform=!0:(t.transforming=!0,this._transform(t.writechunk,t.writeencoding,t.afterTransform))}},function(e,t,n){function i(e){return this instanceof i?void r.call(this,e):new i(e)}e.exports=i;var r=n(20),o=n(15);o.inherits=n(11),o.inherits(i,r),i.prototype._transform=function(e,t,n){n(null,e)}},function(e,t,n){e.exports=n(18)},function(e,t,n){e.exports=n(17)},function(e,t,n){e.exports=n(20)},function(e,t,n){e.exports=n(21)},function(e,t,n){function i(e){for(var t=e.getAllResponseHeaders().split(/\r?\n/),n={},i=0;i<t.length;i++){var r=t[i];if(""!==r){var o=r.match(/^([^:]+):\s*(.*)/);if(o){var a=o[1].toLowerCase(),s=o[2];void 0!==n[a]?p(n[a])?n[a].push(s):n[a]=[n[a],s]:n[a]=s}else n[r]=!0}}return n}var r=n(10),o=n(27),a=e.exports=function(e){this.offset=0,this.readable=!0};o.inherits(a,r);var s={streaming:!0,status2:!0};a.prototype.getResponse=function(e){var t=String(e.responseType).toLowerCase();return"blob"===t?e.responseBlob||e.response:"arraybuffer"===t?e.response:e.responseText},a.prototype.getHeader=function(e){return this.headers[e.toLowerCase()]},a.prototype.handle=function(e){if(2===e.readyState&&s.status2){try{this.statusCode=e.status,this.headers=i(e)}catch(e){s.status2=!1}s.status2&&this.emit("ready")}else if(s.streaming&&3===e.readyState){try{this.statusCode||(this.statusCode=e.status,this.headers=i(e),this.emit("ready"))}catch(e){}try{this._emitData(e)}catch(e){s.streaming=!1}}else 4===e.readyState&&(this.statusCode||(this.statusCode=e.status,this.emit("ready")),this._emitData(e),e.error?this.emit("error",this.getResponse(e)):this.emit("end"),this.emit("close"))},a.prototype._emitData=function(e){var t=this.getResponse(e);return t.toString().match(/ArrayBuffer/)?(this.emit("data",new Uint8Array(t,this.offset)),void(this.offset=t.byteLength)):void(t.length>this.offset&&(this.emit("data",t.slice(this.offset)),this.offset=t.length))};var p=Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)}},function(e,t,n){(function(e,i){function r(e,n){var i={seen:[],stylize:a};return arguments.length>=3&&(i.depth=arguments[2]),arguments.length>=4&&(i.colors=arguments[3]),f(n)?i.showHidden=n:n&&t._extend(i,n),S(i.showHidden)&&(i.showHidden=!1),S(i.depth)&&(i.depth=2),S(i.colors)&&(i.colors=!1),S(i.customInspect)&&(i.customInspect=!0),i.colors&&(i.stylize=o),p(i,e,i.depth)}function o(e,t){var n=r.styles[t];return n?"["+r.colors[n][0]+"m"+e+"["+r.colors[n][1]+"m":e}function a(e,t){return e}function s(e){var t={};return e.forEach(function(e,n){t[e]=!0}),t}function p(e,n,i){if(e.customInspect&&n&&k(n.inspect)&&n.inspect!==t.inspect&&(!n.constructor||n.constructor.prototype!==n)){var r=n.inspect(i,e);return v(r)||(r=p(e,r,i)),r}var o=c(e,n);if(o)return o;var a=Object.keys(n),f=s(a);if(e.showHidden&&(a=Object.getOwnPropertyNames(n)),R(n)&&(a.indexOf("message")>=0||a.indexOf("description")>=0))return d(n);if(0===a.length){if(k(n)){var y=n.name?": "+n.name:"";return e.stylize("[Function"+y+"]","special")}if(x(n))return e.stylize(RegExp.prototype.toString.call(n),"regexp");if(T(n))return e.stylize(Date.prototype.toString.call(n),"date");if(R(n))return d(n)}var g="",b=!1,w=["{","}"];if(h(n)&&(b=!0,w=["[","]"]),k(n)){var S=n.name?": "+n.name:"";g=" [Function"+S+"]"}if(x(n)&&(g=" "+RegExp.prototype.toString.call(n)),T(n)&&(g=" "+Date.prototype.toUTCString.call(n)),R(n)&&(g=" "+d(n)),0===a.length&&(!b||0==n.length))return w[0]+g+w[1];if(i<0)return x(n)?e.stylize(RegExp.prototype.toString.call(n),"regexp"):e.stylize("[Object]","special");e.seen.push(n);var I;return I=b?l(e,n,i,f,a):a.map(function(t){return m(e,n,i,f,t,b)}),e.seen.pop(),u(I,g,w)}function c(e,t){if(S(t))return e.stylize("undefined","undefined");if(v(t)){var n="'"+JSON.stringify(t).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return e.stylize(n,"string")}return b(t)?e.stylize(""+t,"number"):f(t)?e.stylize(""+t,"boolean"):y(t)?e.stylize("null","null"):void 0}function d(e){return"["+Error.prototype.toString.call(e)+"]"}function l(e,t,n,i,r){for(var o=[],a=0,s=t.length;a<s;++a)E(t,String(a))?o.push(m(e,t,n,i,String(a),!0)):o.push("");return r.forEach(function(r){r.match(/^\d+$/)||o.push(m(e,t,n,i,r,!0))}),o}function m(e,t,n,i,r,o){var a,s,c;if(c=Object.getOwnPropertyDescriptor(t,r)||{value:t[r]},c.get?s=c.set?e.stylize("[Getter/Setter]","special"):e.stylize("[Getter]","special"):c.set&&(s=e.stylize("[Setter]","special")),E(i,r)||(a="["+r+"]"),s||(e.seen.indexOf(c.value)<0?(s=y(n)?p(e,c.value,null):p(e,c.value,n-1),s.indexOf("\n")>-1&&(s=o?s.split("\n").map(function(e){return"  "+e}).join("\n").substr(2):"\n"+s.split("\n").map(function(e){return"   "+e}).join("\n"))):s=e.stylize("[Circular]","special")),S(a)){if(o&&r.match(/^\d+$/))return s;a=JSON.stringify(""+r),a.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(a=a.substr(1,a.length-2),a=e.stylize(a,"name")):(a=a.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),a=e.stylize(a,"string"))}return a+": "+s}function u(e,t,n){var i=0,r=e.reduce(function(e,t){return i++,t.indexOf("\n")>=0&&i++,e+t.replace(/\u001b\[\d\d?m/g,"").length+1},0);return r>60?n[0]+(""===t?"":t+"\n ")+" "+e.join(",\n  ")+" "+n[1]:n[0]+t+" "+e.join(", ")+" "+n[1]}function h(e){return Array.isArray(e)}function f(e){return"boolean"==typeof e}function y(e){return null===e}function g(e){return null==e}function b(e){return"number"==typeof e}function v(e){return"string"==typeof e}function w(e){return"symbol"==typeof e}function S(e){return void 0===e}function x(e){return I(e)&&"[object RegExp]"===$(e)}function I(e){return"object"==typeof e&&null!==e}function T(e){return I(e)&&"[object Date]"===$(e)}function R(e){return I(e)&&("[object Error]"===$(e)||e instanceof Error)}function k(e){return"function"==typeof e}function C(e){return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"==typeof e||"undefined"==typeof e}function $(e){return Object.prototype.toString.call(e)}function j(e){return e<10?"0"+e.toString(10):e.toString(10)}function O(){var e=new Date,t=[j(e.getHours()),j(e.getMinutes()),j(e.getSeconds())].join(":");return[e.getDate(),L[e.getMonth()],t].join(" ")}function E(e,t){return Object.prototype.hasOwnProperty.call(e,t)}var A=/%[sdj%]/g;t.format=function(e){if(!v(e)){for(var t=[],n=0;n<arguments.length;n++)t.push(r(arguments[n]));return t.join(" ")}for(var n=1,i=arguments,o=i.length,a=String(e).replace(A,function(e){if("%%"===e)return"%";if(n>=o)return e;switch(e){case"%s":return String(i[n++]);case"%d":return Number(i[n++]);case"%j":try{return JSON.stringify(i[n++])}catch(e){return"[Circular]"}default:return e}}),s=i[n];n<o;s=i[++n])a+=y(s)||!I(s)?" "+s:" "+r(s);return a},t.deprecate=function(n,r){function o(){
	if(!a){if(i.throwDeprecation)throw new Error(r);i.traceDeprecation?console.trace(r):console.error(r),a=!0}return n.apply(this,arguments)}if(S(e.process))return function(){return t.deprecate(n,r).apply(this,arguments)};if(i.noDeprecation===!0)return n;var a=!1;return o};var D,P={};t.debuglog=function(e){if(S(D)&&(D=i.env.NODE_DEBUG||""),e=e.toUpperCase(),!P[e])if(new RegExp("\\b"+e+"\\b","i").test(D)){var n=i.pid;P[e]=function(){var i=t.format.apply(t,arguments);console.error("%s %d: %s",e,n,i)}}else P[e]=function(){};return P[e]},t.inspect=r,r.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},r.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},t.isArray=h,t.isBoolean=f,t.isNull=y,t.isNullOrUndefined=g,t.isNumber=b,t.isString=v,t.isSymbol=w,t.isUndefined=S,t.isRegExp=x,t.isObject=I,t.isDate=T,t.isError=R,t.isFunction=k,t.isPrimitive=C,t.isBuffer=n(28);var L=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];t.log=function(){console.log("%s - %s",O(),t.format.apply(t,arguments))},t.inherits=n(29),t._extend=function(e,t){if(!t||!I(t))return e;for(var n=Object.keys(t),i=n.length;i--;)e[n[i]]=t[n[i]];return e}}).call(t,function(){return this}(),n(1))},function(e,t){e.exports=function(e){return e&&"object"==typeof e&&"function"==typeof e.copy&&"function"==typeof e.fill&&"function"==typeof e.readUInt8}},function(e,t){"function"==typeof Object.create?e.exports=function(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}})}:e.exports=function(e,t){e.super_=t;var n=function(){};n.prototype=t.prototype,e.prototype=new n,e.prototype.constructor=e}},function(e,t,n){!function(){function e(e){this.message=e}var n=t,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";e.prototype=new Error,e.prototype.name="InvalidCharacterError",n.btoa||(n.btoa=function(t){for(var n,r,o=0,a=i,s="";t.charAt(0|o)||(a="=",o%1);s+=a.charAt(63&n>>8-o%1*8)){if(r=t.charCodeAt(o+=.75),r>255)throw new e("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");n=n<<8|r}return s}),n.atob||(n.atob=function(t){if(t=t.replace(/=+$/,""),t.length%4==1)throw new e("'atob' failed: The string to be decoded is not correctly encoded.");for(var n,r,o=0,a=0,s="";r=t.charAt(a++);~r&&(n=o%4?64*n+r:r,o++%4)?s+=String.fromCharCode(255&n>>(-2*o&6)):0)r=i.indexOf(r);return s})}()},function(e,t,n){function i(){this.protocol=null,this.slashes=null,this.auth=null,this.host=null,this.port=null,this.hostname=null,this.hash=null,this.search=null,this.query=null,this.pathname=null,this.path=null,this.href=null}function r(e,t,n){if(e&&c(e)&&e instanceof i)return e;var r=new i;return r.parse(e,t,n),r}function o(e){return p(e)&&(e=r(e)),e instanceof i?e.format():i.prototype.format.call(e)}function a(e,t){return r(e,!1,!0).resolve(t)}function s(e,t){return e?r(e,!1,!0).resolveObject(t):t}function p(e){return"string"==typeof e}function c(e){return"object"==typeof e&&null!==e}function d(e){return null===e}function l(e){return null==e}var m=n(32);t.parse=r,t.resolve=a,t.resolveObject=s,t.format=o,t.Url=i;var u=/^([a-z0-9.+-]+:)/i,h=/:[0-9]*$/,f=["<",">",'"',"`"," ","\r","\n","\t"],y=["{","}","|","\\","^","`"].concat(f),g=["'"].concat(y),b=["%","/","?",";","#"].concat(g),v=["/","?","#"],w=255,S=/^[a-z0-9A-Z_-]{0,63}$/,x=/^([a-z0-9A-Z_-]{0,63})(.*)$/,I={javascript:!0,"javascript:":!0},T={javascript:!0,"javascript:":!0},R={http:!0,https:!0,ftp:!0,gopher:!0,file:!0,"http:":!0,"https:":!0,"ftp:":!0,"gopher:":!0,"file:":!0},k=n(34);i.prototype.parse=function(e,t,n){if(!p(e))throw new TypeError("Parameter 'url' must be a string, not "+typeof e);var i=e;i=i.trim();var r=u.exec(i);if(r){r=r[0];var o=r.toLowerCase();this.protocol=o,i=i.substr(r.length)}if(n||r||i.match(/^\/\/[^@\/]+@[^@\/]+/)){var a="//"===i.substr(0,2);!a||r&&T[r]||(i=i.substr(2),this.slashes=!0)}if(!T[r]&&(a||r&&!R[r])){for(var s=-1,c=0;c<v.length;c++){var d=i.indexOf(v[c]);d!==-1&&(s===-1||d<s)&&(s=d)}var l,h;h=s===-1?i.lastIndexOf("@"):i.lastIndexOf("@",s),h!==-1&&(l=i.slice(0,h),i=i.slice(h+1),this.auth=decodeURIComponent(l)),s=-1;for(var c=0;c<b.length;c++){var d=i.indexOf(b[c]);d!==-1&&(s===-1||d<s)&&(s=d)}s===-1&&(s=i.length),this.host=i.slice(0,s),i=i.slice(s),this.parseHost(),this.hostname=this.hostname||"";var f="["===this.hostname[0]&&"]"===this.hostname[this.hostname.length-1];if(!f)for(var y=this.hostname.split(/\./),c=0,C=y.length;c<C;c++){var $=y[c];if($&&!$.match(S)){for(var j="",O=0,E=$.length;O<E;O++)j+=$.charCodeAt(O)>127?"x":$[O];if(!j.match(S)){var A=y.slice(0,c),D=y.slice(c+1),P=$.match(x);P&&(A.push(P[1]),D.unshift(P[2])),D.length&&(i="/"+D.join(".")+i),this.hostname=A.join(".");break}}}if(this.hostname.length>w?this.hostname="":this.hostname=this.hostname.toLowerCase(),!f){for(var L=this.hostname.split("."),N=[],c=0;c<L.length;++c){var M=L[c];N.push(M.match(/[^A-Za-z0-9_-]/)?"xn--"+m.encode(M):M)}this.hostname=N.join(".")}var q=this.port?":"+this.port:"",U=this.hostname||"";this.host=U+q,this.href+=this.host,f&&(this.hostname=this.hostname.substr(1,this.hostname.length-2),"/"!==i[0]&&(i="/"+i))}if(!I[o])for(var c=0,C=g.length;c<C;c++){var _=g[c],F=encodeURIComponent(_);F===_&&(F=escape(_)),i=i.split(_).join(F)}var B=i.indexOf("#");B!==-1&&(this.hash=i.substr(B),i=i.slice(0,B));var W=i.indexOf("?");if(W!==-1?(this.search=i.substr(W),this.query=i.substr(W+1),t&&(this.query=k.parse(this.query)),i=i.slice(0,W)):t&&(this.search="",this.query={}),i&&(this.pathname=i),R[o]&&this.hostname&&!this.pathname&&(this.pathname="/"),this.pathname||this.search){var q=this.pathname||"",M=this.search||"";this.path=q+M}return this.href=this.format(),this},i.prototype.format=function(){var e=this.auth||"";e&&(e=encodeURIComponent(e),e=e.replace(/%3A/i,":"),e+="@");var t=this.protocol||"",n=this.pathname||"",i=this.hash||"",r=!1,o="";this.host?r=e+this.host:this.hostname&&(r=e+(this.hostname.indexOf(":")===-1?this.hostname:"["+this.hostname+"]"),this.port&&(r+=":"+this.port)),this.query&&c(this.query)&&Object.keys(this.query).length&&(o=k.stringify(this.query));var a=this.search||o&&"?"+o||"";return t&&":"!==t.substr(-1)&&(t+=":"),this.slashes||(!t||R[t])&&r!==!1?(r="//"+(r||""),n&&"/"!==n.charAt(0)&&(n="/"+n)):r||(r=""),i&&"#"!==i.charAt(0)&&(i="#"+i),a&&"?"!==a.charAt(0)&&(a="?"+a),n=n.replace(/[?#]/g,function(e){return encodeURIComponent(e)}),a=a.replace("#","%23"),t+r+n+a+i},i.prototype.resolve=function(e){return this.resolveObject(r(e,!1,!0)).format()},i.prototype.resolveObject=function(e){if(p(e)){var t=new i;t.parse(e,!1,!0),e=t}var n=new i;if(Object.keys(this).forEach(function(e){n[e]=this[e]},this),n.hash=e.hash,""===e.href)return n.href=n.format(),n;if(e.slashes&&!e.protocol)return Object.keys(e).forEach(function(t){"protocol"!==t&&(n[t]=e[t])}),R[n.protocol]&&n.hostname&&!n.pathname&&(n.path=n.pathname="/"),n.href=n.format(),n;if(e.protocol&&e.protocol!==n.protocol){if(!R[e.protocol])return Object.keys(e).forEach(function(t){n[t]=e[t]}),n.href=n.format(),n;if(n.protocol=e.protocol,e.host||T[e.protocol])n.pathname=e.pathname;else{for(var r=(e.pathname||"").split("/");r.length&&!(e.host=r.shift()););e.host||(e.host=""),e.hostname||(e.hostname=""),""!==r[0]&&r.unshift(""),r.length<2&&r.unshift(""),n.pathname=r.join("/")}if(n.search=e.search,n.query=e.query,n.host=e.host||"",n.auth=e.auth,n.hostname=e.hostname||e.host,n.port=e.port,n.pathname||n.search){var o=n.pathname||"",a=n.search||"";n.path=o+a}return n.slashes=n.slashes||e.slashes,n.href=n.format(),n}var s=n.pathname&&"/"===n.pathname.charAt(0),c=e.host||e.pathname&&"/"===e.pathname.charAt(0),m=c||s||n.host&&e.pathname,u=m,h=n.pathname&&n.pathname.split("/")||[],r=e.pathname&&e.pathname.split("/")||[],f=n.protocol&&!R[n.protocol];if(f&&(n.hostname="",n.port=null,n.host&&(""===h[0]?h[0]=n.host:h.unshift(n.host)),n.host="",e.protocol&&(e.hostname=null,e.port=null,e.host&&(""===r[0]?r[0]=e.host:r.unshift(e.host)),e.host=null),m=m&&(""===r[0]||""===h[0])),c)n.host=e.host||""===e.host?e.host:n.host,n.hostname=e.hostname||""===e.hostname?e.hostname:n.hostname,n.search=e.search,n.query=e.query,h=r;else if(r.length)h||(h=[]),h.pop(),h=h.concat(r),n.search=e.search,n.query=e.query;else if(!l(e.search)){if(f){n.hostname=n.host=h.shift();var y=!!(n.host&&n.host.indexOf("@")>0)&&n.host.split("@");y&&(n.auth=y.shift(),n.host=n.hostname=y.shift())}return n.search=e.search,n.query=e.query,d(n.pathname)&&d(n.search)||(n.path=(n.pathname?n.pathname:"")+(n.search?n.search:"")),n.href=n.format(),n}if(!h.length)return n.pathname=null,n.search?n.path="/"+n.search:n.path=null,n.href=n.format(),n;for(var g=h.slice(-1)[0],b=(n.host||e.host)&&("."===g||".."===g)||""===g,v=0,w=h.length;w>=0;w--)g=h[w],"."==g?h.splice(w,1):".."===g?(h.splice(w,1),v++):v&&(h.splice(w,1),v--);if(!m&&!u)for(;v--;v)h.unshift("..");!m||""===h[0]||h[0]&&"/"===h[0].charAt(0)||h.unshift(""),b&&"/"!==h.join("/").substr(-1)&&h.push("");var S=""===h[0]||h[0]&&"/"===h[0].charAt(0);if(f){n.hostname=n.host=S?"":h.length?h.shift():"";var y=!!(n.host&&n.host.indexOf("@")>0)&&n.host.split("@");y&&(n.auth=y.shift(),n.host=n.hostname=y.shift())}return m=m||n.host&&h.length,m&&!S&&h.unshift(""),h.length?n.pathname=h.join("/"):(n.pathname=null,n.path=null),d(n.pathname)&&d(n.search)||(n.path=(n.pathname?n.pathname:"")+(n.search?n.search:"")),n.auth=e.auth||n.auth,n.slashes=n.slashes||e.slashes,n.href=n.format(),n},i.prototype.parseHost=function(){var e=this.host,t=h.exec(e);t&&(t=t[0],":"!==t&&(this.port=t.substr(1)),e=e.substr(0,e.length-t.length)),e&&(this.hostname=e)}},function(e,t,n){var i;(function(e,r){!function(o){function a(e){throw RangeError(A[e])}function s(e,t){for(var n=e.length,i=[];n--;)i[n]=t(e[n]);return i}function p(e,t){var n=e.split("@"),i="";n.length>1&&(i=n[0]+"@",e=n[1]),e=e.replace(E,".");var r=e.split("."),o=s(r,t).join(".");return i+o}function c(e){for(var t,n,i=[],r=0,o=e.length;r<o;)t=e.charCodeAt(r++),t>=55296&&t<=56319&&r<o?(n=e.charCodeAt(r++),56320==(64512&n)?i.push(((1023&t)<<10)+(1023&n)+65536):(i.push(t),r--)):i.push(t);return i}function d(e){return s(e,function(e){var t="";return e>65535&&(e-=65536,t+=L(e>>>10&1023|55296),e=56320|1023&e),t+=L(e)}).join("")}function l(e){return e-48<10?e-22:e-65<26?e-65:e-97<26?e-97:S}function m(e,t){return e+22+75*(e<26)-((0!=t)<<5)}function u(e,t,n){var i=0;for(e=n?P(e/R):e>>1,e+=P(e/t);e>D*I>>1;i+=S)e=P(e/D);return P(i+(D+1)*e/(e+T))}function h(e){var t,n,i,r,o,s,p,c,m,h,f=[],y=e.length,g=0,b=C,v=k;for(n=e.lastIndexOf($),n<0&&(n=0),i=0;i<n;++i)e.charCodeAt(i)>=128&&a("not-basic"),f.push(e.charCodeAt(i));for(r=n>0?n+1:0;r<y;){for(o=g,s=1,p=S;r>=y&&a("invalid-input"),c=l(e.charCodeAt(r++)),(c>=S||c>P((w-g)/s))&&a("overflow"),g+=c*s,m=p<=v?x:p>=v+I?I:p-v,!(c<m);p+=S)h=S-m,s>P(w/h)&&a("overflow"),s*=h;t=f.length+1,v=u(g-o,t,0==o),P(g/t)>w-b&&a("overflow"),b+=P(g/t),g%=t,f.splice(g++,0,b)}return d(f)}function f(e){var t,n,i,r,o,s,p,d,l,h,f,y,g,b,v,T=[];for(e=c(e),y=e.length,t=C,n=0,o=k,s=0;s<y;++s)f=e[s],f<128&&T.push(L(f));for(i=r=T.length,r&&T.push($);i<y;){for(p=w,s=0;s<y;++s)f=e[s],f>=t&&f<p&&(p=f);for(g=i+1,p-t>P((w-n)/g)&&a("overflow"),n+=(p-t)*g,t=p,s=0;s<y;++s)if(f=e[s],f<t&&++n>w&&a("overflow"),f==t){for(d=n,l=S;h=l<=o?x:l>=o+I?I:l-o,!(d<h);l+=S)v=d-h,b=S-h,T.push(L(m(h+v%b,0))),d=P(v/b);T.push(L(m(d,0))),o=u(n,g,i==r),n=0,++i}++n,++t}return T.join("")}function y(e){return p(e,function(e){return j.test(e)?h(e.slice(4).toLowerCase()):e})}function g(e){return p(e,function(e){return O.test(e)?"xn--"+f(e):e})}var b=("object"==typeof t&&t&&!t.nodeType&&t,"object"==typeof e&&e&&!e.nodeType&&e,"object"==typeof r&&r);b.global!==b&&b.window!==b&&b.self!==b||(o=b);var v,w=2147483647,S=36,x=1,I=26,T=38,R=700,k=72,C=128,$="-",j=/^xn--/,O=/[^\x20-\x7E]/,E=/[\x2E\u3002\uFF0E\uFF61]/g,A={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},D=S-x,P=Math.floor,L=String.fromCharCode;v={version:"1.3.2",ucs2:{decode:c,encode:d},decode:h,encode:f,toASCII:g,toUnicode:y},i=function(){return v}.call(t,n,t,e),!(void 0!==i&&(e.exports=i))}(this)}).call(t,n(33)(e),function(){return this}())},function(e,t){e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children=[],e.webpackPolyfill=1),e}},function(e,t,n){"use strict";t.decode=t.parse=n(35),t.encode=t.stringify=n(36)},function(e,t){"use strict";function n(e,t){return Object.prototype.hasOwnProperty.call(e,t)}e.exports=function(e,t,i,r){t=t||"&",i=i||"=";var o={};if("string"!=typeof e||0===e.length)return o;var a=/\+/g;e=e.split(t);var s=1e3;r&&"number"==typeof r.maxKeys&&(s=r.maxKeys);var p=e.length;s>0&&p>s&&(p=s);for(var c=0;c<p;++c){var d,l,m,u,h=e[c].replace(a,"%20"),f=h.indexOf(i);f>=0?(d=h.substr(0,f),l=h.substr(f+1)):(d=h,l=""),m=decodeURIComponent(d),u=decodeURIComponent(l),n(o,m)?Array.isArray(o[m])?o[m].push(u):o[m]=[o[m],u]:o[m]=u}return o}},function(e,t){"use strict";var n=function(e){switch(typeof e){case"string":return e;case"boolean":return e?"true":"false";case"number":return isFinite(e)?e:"";default:return""}};e.exports=function(e,t,i,r){return t=t||"&",i=i||"=",null===e&&(e=void 0),"object"==typeof e?Object.keys(e).map(function(r){var o=encodeURIComponent(n(r))+i;return Array.isArray(e[r])?e[r].map(function(e){return o+encodeURIComponent(n(e))}).join(t):o+encodeURIComponent(n(e[r]))}).join(t):r?encodeURIComponent(n(r))+i+encodeURIComponent(n(e)):""}},function(e,t,n){var i=n(8),r=e.exports;for(var o in i)i.hasOwnProperty(o)&&(r[o]=i[o]);r.request=function(e,t){return e||(e={}),e.scheme="https",i.request.call(this,e,t)}},function(e,t){"use strict";e.exports.HOST="localhost",e.exports.PORT=9222},function(e,t){e.exports=function(e,t,n){window.criRequest(t,n)}},function(e,t){e.exports={version:{major:"1",minor:"2"},domains:[{domain:"Inspector",experimental:!0,types:[],commands:[{name:"enable",description:"Enables inspector domain notifications."},{name:"disable",description:"Disables inspector domain notifications."}],events:[{name:"detached",description:"Fired when remote debugging connection is about to be terminated. Contains detach reason.",parameters:[{name:"reason",type:"string",description:"The reason why connection has been terminated."}]},{name:"targetCrashed",description:"Fired when debugging target has crashed"}]},{domain:"Memory",experimental:!0,types:[{id:"PressureLevel",type:"string",enum:["moderate","critical"],description:"Memory pressure level."}],commands:[{name:"getDOMCounters",returns:[{name:"documents",type:"integer"},{name:"nodes",type:"integer"},{name:"jsEventListeners",type:"integer"}]},{name:"setPressureNotificationsSuppressed",description:"Enable/disable suppressing memory pressure notifications in all processes.",parameters:[{name:"suppressed",type:"boolean",description:"If true, memory pressure notifications will be suppressed."}]},{name:"simulatePressureNotification",description:"Simulate a memory pressure notification in all processes.",parameters:[{name:"level",$ref:"PressureLevel",description:"Memory pressure level of the notification."}]}]},{domain:"Page",description:"Actions and events related to the inspected page belong to the page domain.",dependencies:["Debugger","DOM"],types:[{id:"ResourceType",type:"string",enum:["Document","Stylesheet","Image","Media","Font","Script","TextTrack","XHR","Fetch","EventSource","WebSocket","Manifest","Other"],description:"Resource type as it was perceived by the rendering engine."},{id:"FrameId",type:"string",description:"Unique frame identifier."},{id:"Frame",type:"object",description:"Information about the Frame on the page.",properties:[{name:"id",type:"string",description:"Frame unique identifier."},{name:"parentId",type:"string",optional:!0,description:"Parent frame identifier."},{name:"loaderId",$ref:"Network.LoaderId",description:"Identifier of the loader associated with this frame."},{name:"name",type:"string",optional:!0,description:"Frame's name as specified in the tag."},{name:"url",type:"string",description:"Frame document's URL."},{name:"securityOrigin",type:"string",description:"Frame document's security origin."},{name:"mimeType",type:"string",description:"Frame document's mimeType as determined by the browser."}]},{id:"FrameResource",type:"object",description:"Information about the Resource on the page.",properties:[{name:"url",type:"string",description:"Resource URL."},{name:"type",$ref:"ResourceType",description:"Type of this resource."},{name:"mimeType",type:"string",description:"Resource mimeType as determined by the browser."},{name:"lastModified",$ref:"Network.Timestamp",description:"last-modified timestamp as reported by server.",optional:!0},{name:"contentSize",type:"number",description:"Resource content size.",optional:!0},{name:"failed",type:"boolean",optional:!0,description:"True if the resource failed to load."},{name:"canceled",type:"boolean",optional:!0,description:"True if the resource was canceled during loading."}],experimental:!0},{id:"FrameResourceTree",type:"object",description:"Information about the Frame hierarchy along with their cached resources.",properties:[{name:"frame",$ref:"Frame",description:"Frame information for this tree item."},{name:"childFrames",type:"array",optional:!0,items:{$ref:"FrameResourceTree"},description:"Child frames."},{name:"resources",type:"array",items:{$ref:"FrameResource"},description:"Information about frame resources."}],experimental:!0},{id:"ScriptIdentifier",type:"string",description:"Unique script identifier.",experimental:!0},{id:"NavigationEntry",type:"object",description:"Navigation history entry.",properties:[{name:"id",type:"integer",description:"Unique id of the navigation history entry."},{name:"url",type:"string",description:"URL of the navigation history entry."},{name:"title",type:"string",description:"Title of the navigation history entry."}],experimental:!0},{id:"ScreencastFrameMetadata",type:"object",description:"Screencast frame metadata.",properties:[{name:"offsetTop",type:"number",experimental:!0,description:"Top offset in DIP."},{name:"pageScaleFactor",type:"number",experimental:!0,description:"Page scale factor."},{name:"deviceWidth",type:"number",experimental:!0,description:"Device screen width in DIP."},{name:"deviceHeight",type:"number",experimental:!0,description:"Device screen height in DIP."},{name:"scrollOffsetX",type:"number",experimental:!0,description:"Position of horizontal scroll in CSS pixels."},{name:"scrollOffsetY",type:"number",experimental:!0,description:"Position of vertical scroll in CSS pixels."},{name:"timestamp",type:"number",optional:!0,experimental:!0,description:"Frame swap timestamp."}],experimental:!0},{id:"DialogType",description:"Javascript dialog type.",type:"string",enum:["alert","confirm","prompt","beforeunload"],experimental:!0},{id:"AppManifestError",description:"Error while paring app manifest.",type:"object",properties:[{name:"message",type:"string",description:"Error message."},{name:"critical",type:"integer",description:"If criticial, this is a non-recoverable parse error."},{name:"line",type:"integer",description:"Error line."},{name:"column",type:"integer",description:"Error column."}],experimental:!0},{id:"NavigationResponse",description:"Proceed: allow the navigation; Cancel: cancel the navigation; CancelAndIgnore: cancels the navigation and makes the requester of the navigation acts like the request was never made.",type:"string",enum:["Proceed","Cancel","CancelAndIgnore"],experimental:!0},{id:"LayoutViewport",type:"object",description:"Layout viewport position and dimensions.",experimental:!0,properties:[{name:"pageX",type:"integer",description:"Horizontal offset relative to the document (CSS pixels)."},{name:"pageY",type:"integer",description:"Vertical offset relative to the document (CSS pixels)."},{name:"clientWidth",type:"integer",description:"Width (CSS pixels), excludes scrollbar if present."},{name:"clientHeight",type:"integer",description:"Height (CSS pixels), excludes scrollbar if present."}]},{id:"VisualViewport",type:"object",description:"Visual viewport position, dimensions, and scale.",experimental:!0,properties:[{name:"offsetX",type:"number",description:"Horizontal offset relative to the layout viewport (CSS pixels)."},{name:"offsetY",type:"number",description:"Vertical offset relative to the layout viewport (CSS pixels)."},{name:"pageX",type:"number",description:"Horizontal offset relative to the document (CSS pixels)."},{name:"pageY",type:"number",description:"Vertical offset relative to the document (CSS pixels)."},{name:"clientWidth",type:"number",description:"Width (CSS pixels), excludes scrollbar if present."},{name:"clientHeight",type:"number",description:"Height (CSS pixels), excludes scrollbar if present."},{name:"scale",type:"number",description:"Scale relative to the ideal viewport (size at width=device-width)."}]}],commands:[{name:"enable",description:"Enables page domain notifications."},{name:"disable",description:"Disables page domain notifications."},{name:"addScriptToEvaluateOnLoad",parameters:[{name:"scriptSource",type:"string"}],returns:[{name:"identifier",$ref:"ScriptIdentifier",description:"Identifier of the added script."}],experimental:!0},{name:"removeScriptToEvaluateOnLoad",parameters:[{name:"identifier",$ref:"ScriptIdentifier"}],experimental:!0},{name:"setAutoAttachToCreatedPages",parameters:[{name:"autoAttach",type:"boolean",description:"If true, browser will open a new inspector window for every page created from this one."}],description:"Controls whether browser will open a new inspector window for connected pages.",experimental:!0},{name:"reload",parameters:[{name:"ignoreCache",type:"boolean",optional:!0,description:"If true, browser cache is ignored (as if the user pressed Shift+refresh)."},{name:"scriptToEvaluateOnLoad",type:"string",optional:!0,description:"If set, the script will be injected into all frames of the inspected page after reload."}],description:"Reloads given page optionally ignoring the cache."},{name:"navigate",parameters:[{name:"url",type:"string",description:"URL to navigate the page to."}],returns:[{name:"frameId",$ref:"FrameId",experimental:!0,description:"Frame id that will be navigated."}],description:"Navigates current page to the given URL."},{name:"stopLoading",description:"Force the page stop all navigations and pending resource fetches.",experimental:!0},{name:"getNavigationHistory",returns:[{name:"currentIndex",type:"integer",description:"Index of the current navigation history entry."},{name:"entries",type:"array",items:{$ref:"NavigationEntry"},description:"Array of navigation history entries."}],description:"Returns navigation history for the current page.",experimental:!0},{name:"navigateToHistoryEntry",parameters:[{name:"entryId",type:"integer",description:"Unique id of the entry to navigate to."}],description:"Navigates current page to the given history entry.",experimental:!0},{name:"getCookies",returns:[{name:"cookies",type:"array",items:{$ref:"Network.Cookie"},description:"Array of cookie objects."}],description:"Returns all browser cookies. Depending on the backend support, will return detailed cookie information in the <code>cookies</code> field.",experimental:!0,redirect:"Network"},{name:"deleteCookie",parameters:[{name:"cookieName",type:"string",description:"Name of the cookie to remove."},{name:"url",type:"string",description:"URL to match cooke domain and path."}],description:"Deletes browser cookie with given name, domain and path.",experimental:!0,redirect:"Network"},{name:"getResourceTree",description:"Returns present frame / resource tree structure.",returns:[{name:"frameTree",$ref:"FrameResourceTree",description:"Present frame / resource tree structure."}],experimental:!0},{name:"getResourceContent",description:"Returns content of the given resource.",parameters:[{name:"frameId",$ref:"FrameId",description:"Frame id to get resource for."},{name:"url",type:"string",description:"URL of the resource to get content for."}],returns:[{name:"content",type:"string",description:"Resource content."},{name:"base64Encoded",type:"boolean",description:"True, if content was served as base64."}],experimental:!0},{name:"searchInResource",description:"Searches for given string in resource content.",parameters:[{name:"frameId",$ref:"FrameId",description:"Frame id for resource to search in."},{name:"url",type:"string",description:"URL of the resource to search in."},{name:"query",type:"string",description:"String to search for."},{name:"caseSensitive",type:"boolean",optional:!0,description:"If true, search is case sensitive."},{name:"isRegex",type:"boolean",optional:!0,description:"If true, treats string parameter as regex."}],returns:[{name:"result",type:"array",items:{$ref:"Debugger.SearchMatch"},description:"List of search matches."}],experimental:!0},{name:"setDocumentContent",description:"Sets given markup as the document's HTML.",parameters:[{name:"frameId",$ref:"FrameId",description:"Frame id to set HTML for."},{name:"html",type:"string",description:"HTML content to set."}],experimental:!0},{name:"setDeviceMetricsOverride",description:'Overrides the values of device screen dimensions (window.screen.width, window.screen.height, window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media query results).',parameters:[{name:"width",type:"integer",description:"Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override."},{name:"height",type:"integer",description:"Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override."},{name:"deviceScaleFactor",type:"number",description:"Overriding device scale factor value. 0 disables the override."},{name:"mobile",type:"boolean",description:"Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more."},{name:"fitWindow",type:"boolean",description:"Whether a view that exceeds the available browser window area should be scaled down to fit."},{name:"scale",type:"number",optional:!0,description:"Scale to apply to resulting view image. Ignored in |fitWindow| mode."},{name:"offsetX",type:"number",optional:!0,description:"X offset to shift resulting view image by. Ignored in |fitWindow| mode."},{name:"offsetY",type:"number",optional:!0,description:"Y offset to shift resulting view image by. Ignored in |fitWindow| mode."},{name:"screenWidth",type:"integer",optional:!0,description:"Overriding screen width value in pixels (minimum 0, maximum 10000000). Only used for |mobile==true|."},{name:"screenHeight",type:"integer",optional:!0,description:"Overriding screen height value in pixels (minimum 0, maximum 10000000). Only used for |mobile==true|."},{name:"positionX",type:"integer",optional:!0,description:"Overriding view X position on screen in pixels (minimum 0, maximum 10000000). Only used for |mobile==true|."},{name:"positionY",type:"integer",optional:!0,description:"Overriding view Y position on screen in pixels (minimum 0, maximum 10000000). Only used for |mobile==true|."},{name:"screenOrientation",$ref:"Emulation.ScreenOrientation",optional:!0,description:"Screen orientation override."}],redirect:"Emulation",experimental:!0},{name:"clearDeviceMetricsOverride",description:"Clears the overriden device metrics.",redirect:"Emulation",experimental:!0},{name:"setGeolocationOverride",description:"Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position unavailable.",parameters:[{name:"latitude",type:"number",optional:!0,description:"Mock latitude"},{name:"longitude",type:"number",optional:!0,description:"Mock longitude"},{name:"accuracy",type:"number",optional:!0,description:"Mock accuracy"}],redirect:"Emulation"},{name:"clearGeolocationOverride",description:"Clears the overriden Geolocation Position and Error.",redirect:"Emulation"},{name:"setDeviceOrientationOverride",description:"Overrides the Device Orientation.",parameters:[{name:"alpha",type:"number",description:"Mock alpha"},{name:"beta",type:"number",description:"Mock beta"},{name:"gamma",type:"number",description:"Mock gamma"}],redirect:"DeviceOrientation",experimental:!0},{name:"clearDeviceOrientationOverride",description:"Clears the overridden Device Orientation.",redirect:"DeviceOrientation",experimental:!0},{name:"setTouchEmulationEnabled",parameters:[{name:"enabled",type:"boolean",description:"Whether the touch event emulation should be enabled."},{name:"configuration",type:"string",enum:["mobile","desktop"],optional:!0,description:"Touch/gesture events configuration. Default: current platform."}],description:"Toggles mouse event-based touch event emulation.",experimental:!0,redirect:"Emulation"},{name:"captureScreenshot",description:"Capture page screenshot.",returns:[{name:"data",type:"string",description:"Base64-encoded image data (PNG)."}],experimental:!0},{name:"startScreencast",description:"Starts sending each frame using the <code>screencastFrame</code> event.",parameters:[{name:"format",type:"string",optional:!0,enum:["jpeg","png"],description:"Image compression format."},{name:"quality",type:"integer",optional:!0,description:"Compression quality from range [0..100]."},{name:"maxWidth",type:"integer",optional:!0,description:"Maximum screenshot width."},{name:"maxHeight",type:"integer",optional:!0,description:"Maximum screenshot height."},{name:"everyNthFrame",type:"integer",optional:!0,description:"Send every n-th frame."}],experimental:!0},{name:"stopScreencast",description:"Stops sending each frame in the <code>screencastFrame</code>.",experimental:!0},{name:"screencastFrameAck",description:"Acknowledges that a screencast frame has been received by the frontend.",parameters:[{name:"sessionId",type:"integer",description:"Frame number."}],experimental:!0},{name:"handleJavaScriptDialog",description:"Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).",parameters:[{name:"accept",type:"boolean",description:"Whether to accept or dismiss the dialog."},{name:"promptText",type:"string",optional:!0,description:"The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog."}]},{name:"setColorPickerEnabled",parameters:[{name:"enabled",type:"boolean",description:"Shows / hides color picker"}],description:"Shows / hides color picker",experimental:!0},{name:"configureOverlay",parameters:[{name:"suspended",type:"boolean",optional:!0,description:"Whether overlay should be suspended and not consume any resources."},{name:"message",type:"string",optional:!0,description:"Overlay message to display."}],experimental:!0,description:"Configures overlay."},{name:"getAppManifest",experimental:!0,returns:[{name:"url",type:"string",description:"Manifest location."},{name:"errors",type:"array",items:{$ref:"AppManifestError"}},{name:"data",type:"string",optional:!0,description:"Manifest content."}]},{name:"requestAppBanner",experimental:!0},{name:"setControlNavigations",parameters:[{name:"enabled",type:"boolean"}],description:"Toggles navigation throttling which allows programatic control over navigation and redirect response.",experimental:!0},{name:"processNavigation",parameters:[{name:"response",$ref:"NavigationResponse"},{name:"navigationId",type:"integer"}],description:"Should be sent in response to a navigationRequested or a redirectRequested event, telling the browser how to handle the navigation.",experimental:!0},{name:"getLayoutMetrics",description:"Returns metrics relating to the layouting of the page, such as viewport bounds/scale.",experimental:!0,returns:[{name:"layoutViewport",$ref:"LayoutViewport",description:"Metrics relating to the layout viewport."},{name:"visualViewport",
	$ref:"VisualViewport",description:"Metrics relating to the visual viewport."}]}],events:[{name:"domContentEventFired",parameters:[{name:"timestamp",type:"number"}]},{name:"loadEventFired",parameters:[{name:"timestamp",type:"number"}]},{name:"frameAttached",description:"Fired when frame has been attached to its parent.",parameters:[{name:"frameId",$ref:"FrameId",description:"Id of the frame that has been attached."},{name:"parentFrameId",$ref:"FrameId",description:"Parent frame identifier."}]},{name:"frameNavigated",description:"Fired once navigation of the frame has completed. Frame is now associated with the new loader.",parameters:[{name:"frame",$ref:"Frame",description:"Frame object."}]},{name:"frameDetached",description:"Fired when frame has been detached from its parent.",parameters:[{name:"frameId",$ref:"FrameId",description:"Id of the frame that has been detached."}]},{name:"frameStartedLoading",description:"Fired when frame has started loading.",parameters:[{name:"frameId",$ref:"FrameId",description:"Id of the frame that has started loading."}],experimental:!0},{name:"frameStoppedLoading",description:"Fired when frame has stopped loading.",parameters:[{name:"frameId",$ref:"FrameId",description:"Id of the frame that has stopped loading."}],experimental:!0},{name:"frameScheduledNavigation",description:"Fired when frame schedules a potential navigation.",parameters:[{name:"frameId",$ref:"FrameId",description:"Id of the frame that has scheduled a navigation."},{name:"delay",type:"number",description:"Delay (in seconds) until the navigation is scheduled to begin. The navigation is not guaranteed to start."}],experimental:!0},{name:"frameClearedScheduledNavigation",description:"Fired when frame no longer has a scheduled navigation.",parameters:[{name:"frameId",$ref:"FrameId",description:"Id of the frame that has cleared its scheduled navigation."}],experimental:!0},{name:"frameResized",experimental:!0},{name:"javascriptDialogOpening",description:"Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to open.",parameters:[{name:"message",type:"string",description:"Message that will be displayed by the dialog."},{name:"type",$ref:"DialogType",description:"Dialog type."}]},{name:"javascriptDialogClosed",description:"Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been closed.",parameters:[{name:"result",type:"boolean",description:"Whether dialog was confirmed."}]},{name:"screencastFrame",description:"Compressed image data requested by the <code>startScreencast</code>.",parameters:[{name:"data",type:"string",description:"Base64-encoded compressed image."},{name:"metadata",$ref:"ScreencastFrameMetadata",description:"Screencast frame metadata."},{name:"sessionId",type:"integer",description:"Frame number."}],experimental:!0},{name:"screencastVisibilityChanged",description:"Fired when the page with currently enabled screencast was shown or hidden </code>.",parameters:[{name:"visible",type:"boolean",description:"True if the page is visible."}],experimental:!0},{name:"colorPicked",description:"Fired when a color has been picked.",parameters:[{name:"color",$ref:"DOM.RGBA",description:"RGBA of the picked color."}],experimental:!0},{name:"interstitialShown",description:"Fired when interstitial page was shown"},{name:"interstitialHidden",description:"Fired when interstitial page was hidden"},{name:"navigationRequested",description:"Fired when a navigation is started if navigation throttles are enabled.  The navigation will be deferred until processNavigation is called.",parameters:[{name:"isInMainFrame",type:"boolean",description:"Whether the navigation is taking place in the main frame or in a subframe."},{name:"isRedirect",type:"boolean",description:"Whether the navigation has encountered a server redirect or not."},{name:"navigationId",type:"integer"},{name:"url",type:"string",description:"URL of requested navigation."}]}]},{domain:"Rendering",description:"This domain allows to control rendering of the page.",experimental:!0,commands:[{name:"setShowPaintRects",description:"Requests that backend shows paint rectangles",parameters:[{name:"result",type:"boolean",description:"True for showing paint rectangles"}]},{name:"setShowDebugBorders",description:"Requests that backend shows debug borders on layers",parameters:[{name:"show",type:"boolean",description:"True for showing debug borders"}]},{name:"setShowFPSCounter",description:"Requests that backend shows the FPS counter",parameters:[{name:"show",type:"boolean",description:"True for showing the FPS counter"}]},{name:"setShowScrollBottleneckRects",description:"Requests that backend shows scroll bottleneck rects",parameters:[{name:"show",type:"boolean",description:"True for showing scroll bottleneck rects"}]},{name:"setShowViewportSizeOnResize",description:"Paints viewport size upon main frame resize.",parameters:[{name:"show",type:"boolean",description:"Whether to paint size or not."}]}]},{domain:"Emulation",description:"This domain emulates different environments for the page.",types:[{id:"ScreenOrientation",type:"object",description:"Screen orientation.",properties:[{name:"type",type:"string",enum:["portraitPrimary","portraitSecondary","landscapePrimary","landscapeSecondary"],description:"Orientation type."},{name:"angle",type:"integer",description:"Orientation angle."}]},{id:"VirtualTimePolicy",type:"string",enum:["advance","pause","pauseIfNetworkFetchesPending"],experimental:!0,description:"advance: If the scheduler runs out of immediate work, the virtual time base may fast forward to allow the next delayed task (if any) to run; pause: The virtual time base may not advance; pauseIfNetworkFetchesPending: The virtual time base may not advance if there are any pending resource fetches."}],commands:[{name:"setDeviceMetricsOverride",description:'Overrides the values of device screen dimensions (window.screen.width, window.screen.height, window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media query results).',parameters:[{name:"width",type:"integer",description:"Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override."},{name:"height",type:"integer",description:"Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override."},{name:"deviceScaleFactor",type:"number",description:"Overriding device scale factor value. 0 disables the override."},{name:"mobile",type:"boolean",description:"Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text autosizing and more."},{name:"fitWindow",type:"boolean",description:"Whether a view that exceeds the available browser window area should be scaled down to fit."},{name:"scale",type:"number",optional:!0,experimental:!0,description:"Scale to apply to resulting view image. Ignored in |fitWindow| mode."},{name:"offsetX",type:"number",optional:!0,deprecated:!0,experimental:!0,description:"Not used."},{name:"offsetY",type:"number",optional:!0,deprecated:!0,experimental:!0,description:"Not used."},{name:"screenWidth",type:"integer",optional:!0,experimental:!0,description:"Overriding screen width value in pixels (minimum 0, maximum 10000000). Only used for |mobile==true|."},{name:"screenHeight",type:"integer",optional:!0,experimental:!0,description:"Overriding screen height value in pixels (minimum 0, maximum 10000000). Only used for |mobile==true|."},{name:"positionX",type:"integer",optional:!0,experimental:!0,description:"Overriding view X position on screen in pixels (minimum 0, maximum 10000000). Only used for |mobile==true|."},{name:"positionY",type:"integer",optional:!0,experimental:!0,description:"Overriding view Y position on screen in pixels (minimum 0, maximum 10000000). Only used for |mobile==true|."},{name:"screenOrientation",$ref:"ScreenOrientation",optional:!0,description:"Screen orientation override."}]},{name:"clearDeviceMetricsOverride",description:"Clears the overriden device metrics."},{name:"forceViewport",description:"Overrides the visible area of the page. The change is hidden from the page, i.e. the observable scroll position and page scale does not change. In effect, the command moves the specified area of the page into the top-left corner of the frame.",experimental:!0,parameters:[{name:"x",type:"number",description:"X coordinate of top-left corner of the area (CSS pixels)."},{name:"y",type:"number",description:"Y coordinate of top-left corner of the area (CSS pixels)."},{name:"scale",type:"number",description:"Scale to apply to the area (relative to a page scale of 1.0)."}]},{name:"resetViewport",description:"Resets the visible area of the page to the original viewport, undoing any effects of the <code>forceViewport</code> command.",experimental:!0},{name:"resetPageScaleFactor",experimental:!0,description:"Requests that page scale factor is reset to initial values."},{name:"setPageScaleFactor",description:"Sets a specified page scale factor.",experimental:!0,parameters:[{name:"pageScaleFactor",type:"number",description:"Page scale factor."}]},{name:"setVisibleSize",description:"Resizes the frame/viewport of the page. Note that this does not affect the frame's container (e.g. browser window). Can be used to produce screenshots of the specified size. Not supported on Android.",experimental:!0,parameters:[{name:"width",type:"integer",description:"Frame width (DIP)."},{name:"height",type:"integer",description:"Frame height (DIP)."}]},{name:"setScriptExecutionDisabled",description:"Switches script execution in the page.",experimental:!0,parameters:[{name:"value",type:"boolean",description:"Whether script execution should be disabled in the page."}]},{name:"setGeolocationOverride",description:"Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position unavailable.",experimental:!0,parameters:[{name:"latitude",type:"number",optional:!0,description:"Mock latitude"},{name:"longitude",type:"number",optional:!0,description:"Mock longitude"},{name:"accuracy",type:"number",optional:!0,description:"Mock accuracy"}]},{name:"clearGeolocationOverride",description:"Clears the overriden Geolocation Position and Error.",experimental:!0},{name:"setTouchEmulationEnabled",parameters:[{name:"enabled",type:"boolean",description:"Whether the touch event emulation should be enabled."},{name:"configuration",type:"string",enum:["mobile","desktop"],optional:!0,description:"Touch/gesture events configuration. Default: current platform."}],description:"Toggles mouse event-based touch event emulation."},{name:"setEmulatedMedia",parameters:[{name:"media",type:"string",description:"Media type to emulate. Empty string disables the override."}],description:"Emulates the given media for CSS media queries."},{name:"setCPUThrottlingRate",parameters:[{name:"rate",type:"number",description:"Throttling rate as a slowdown factor (1 is no throttle, 2 is 2x slowdown, etc)."}],experimental:!0,description:"Enables CPU throttling to emulate slow CPUs."},{name:"canEmulate",description:"Tells whether emulation is supported.",returns:[{name:"result",type:"boolean",description:"True if emulation is supported."}],experimental:!0},{name:"setVirtualTimePolicy",description:"Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets the current virtual time policy.  Note this supersedes any previous time budget.",parameters:[{name:"policy",$ref:"VirtualTimePolicy"},{name:"budget",type:"integer",optional:!0,description:"If set, after this many virtual milliseconds have elapsed virtual time will be paused and a virtualTimeBudgetExpired event is sent."}],experimental:!0}],events:[{name:"virtualTimeBudgetExpired",experimental:!0,description:"Notification sent after the virual time budget for the current VirtualTimePolicy has run out."}]},{domain:"Security",description:"Security",experimental:!0,types:[{id:"CertificateId",type:"integer",description:"An internal certificate ID value."},{id:"SecurityState",type:"string",enum:["unknown","neutral","insecure","warning","secure","info"],description:"The security level of a page or resource."},{id:"SecurityStateExplanation",type:"object",properties:[{name:"securityState",$ref:"SecurityState",description:"Security state representing the severity of the factor being explained."},{name:"summary",type:"string",description:"Short phrase describing the type of factor."},{name:"description",type:"string",description:"Full text explanation of the factor."},{name:"hasCertificate",type:"boolean",description:"True if the page has a certificate."}],description:"An explanation of an factor contributing to the security state."},{id:"InsecureContentStatus",type:"object",properties:[{name:"ranMixedContent",type:"boolean",description:"True if the page was loaded over HTTPS and ran mixed (HTTP) content such as scripts."},{name:"displayedMixedContent",type:"boolean",description:"True if the page was loaded over HTTPS and displayed mixed (HTTP) content such as images."},{name:"ranContentWithCertErrors",type:"boolean",description:"True if the page was loaded over HTTPS without certificate errors, and ran content such as scripts that were loaded with certificate errors."},{name:"displayedContentWithCertErrors",type:"boolean",description:"True if the page was loaded over HTTPS without certificate errors, and displayed content such as images that were loaded with certificate errors."},{name:"ranInsecureContentStyle",$ref:"SecurityState",description:"Security state representing a page that ran insecure content."},{name:"displayedInsecureContentStyle",$ref:"SecurityState",description:"Security state representing a page that displayed insecure content."}],description:"Information about insecure content on the page."}],commands:[{name:"enable",description:"Enables tracking security state changes."},{name:"disable",description:"Disables tracking security state changes."},{name:"showCertificateViewer",description:"Displays native dialog with the certificate details."}],events:[{name:"securityStateChanged",description:"The security state of the page changed.",parameters:[{name:"securityState",$ref:"SecurityState",description:"Security state."},{name:"explanations",type:"array",items:{$ref:"SecurityStateExplanation"},description:"List of explanations for the security state. If the overall security state is `insecure` or `warning`, at least one corresponding explanation should be included.",optional:!0},{name:"insecureContentStatus",$ref:"InsecureContentStatus",description:"Information about insecure content on the page.",optional:!0},{name:"schemeIsCryptographic",type:"boolean",description:"True if the page was loaded over cryptographic transport such as HTTPS.",optional:!0}]}]},{domain:"Network",description:"Network domain allows tracking network activities of the page. It exposes information about http, file, data and other requests and responses, their headers, bodies, timing, etc.",dependencies:["Runtime","Security"],types:[{id:"LoaderId",type:"string",description:"Unique loader identifier."},{id:"RequestId",type:"string",description:"Unique request identifier."},{id:"Timestamp",type:"number",description:"Number of seconds since epoch."},{id:"Headers",type:"object",description:"Request / response headers as keys / values of JSON object."},{id:"ConnectionType",type:"string",enum:["none","cellular2g","cellular3g","cellular4g","bluetooth","ethernet","wifi","wimax","other"],description:"Loading priority of a resource request."},{id:"CookieSameSite",type:"string",enum:["Strict","Lax"],description:"Represents the cookie's 'SameSite' status: https://tools.ietf.org/html/draft-west-first-party-cookies"},{id:"ResourceTiming",type:"object",description:"Timing information for the request.",properties:[{name:"requestTime",type:"number",description:"Timing's requestTime is a baseline in seconds, while the other numbers are ticks in milliseconds relatively to this requestTime."},{name:"proxyStart",type:"number",description:"Started resolving proxy."},{name:"proxyEnd",type:"number",description:"Finished resolving proxy."},{name:"dnsStart",type:"number",description:"Started DNS address resolve."},{name:"dnsEnd",type:"number",description:"Finished DNS address resolve."},{name:"connectStart",type:"number",description:"Started connecting to the remote host."},{name:"connectEnd",type:"number",description:"Connected to the remote host."},{name:"sslStart",type:"number",description:"Started SSL handshake."},{name:"sslEnd",type:"number",description:"Finished SSL handshake."},{name:"workerStart",type:"number",description:"Started running ServiceWorker.",experimental:!0},{name:"workerReady",type:"number",description:"Finished Starting ServiceWorker.",experimental:!0},{name:"sendStart",type:"number",description:"Started sending request."},{name:"sendEnd",type:"number",description:"Finished sending request."},{name:"pushStart",type:"number",description:"Time the server started pushing request.",experimental:!0},{name:"pushEnd",type:"number",description:"Time the server finished pushing request.",experimental:!0},{name:"receiveHeadersEnd",type:"number",description:"Finished receiving response headers."}]},{id:"ResourcePriority",type:"string",enum:["VeryLow","Low","Medium","High","VeryHigh"],description:"Loading priority of a resource request."},{id:"Request",type:"object",description:"HTTP request data.",properties:[{name:"url",type:"string",description:"Request URL."},{name:"method",type:"string",description:"HTTP request method."},{name:"headers",$ref:"Headers",description:"HTTP request headers."},{name:"postData",type:"string",optional:!0,description:"HTTP POST request data."},{name:"mixedContentType",optional:!0,type:"string",enum:["blockable","optionally-blockable","none"],description:"The mixed content status of the request, as defined in http://www.w3.org/TR/mixed-content/"},{name:"initialPriority",$ref:"ResourcePriority",description:"Priority of the resource request at the time request is sent."}]},{id:"SignedCertificateTimestamp",type:"object",description:"Details of a signed certificate timestamp (SCT).",properties:[{name:"status",type:"string",description:"Validation status."},{name:"origin",type:"string",description:"Origin."},{name:"logDescription",type:"string",description:"Log name / description."},{name:"logId",type:"string",description:"Log ID."},{name:"timestamp",$ref:"Timestamp",description:"Issuance date."},{name:"hashAlgorithm",type:"string",description:"Hash algorithm."},{name:"signatureAlgorithm",type:"string",description:"Signature algorithm."},{name:"signatureData",type:"string",description:"Signature data."}]},{id:"SecurityDetails",type:"object",description:"Security details about a request.",properties:[{name:"protocol",type:"string",description:'Protocol name (e.g. "TLS 1.2" or "QUIC").'},{name:"keyExchange",type:"string",description:"Key Exchange used by the connection, or the empty string if not applicable."},{name:"keyExchangeGroup",type:"string",optional:!0,description:"(EC)DH group used by the connection, if applicable."},{name:"cipher",type:"string",description:"Cipher name."},{name:"mac",type:"string",optional:!0,description:"TLS MAC. Note that AEAD ciphers do not have separate MACs."},{name:"certificateId",$ref:"Security.CertificateId",description:"Certificate ID value."},{name:"subjectName",type:"string",description:"Certificate subject name."},{name:"sanList",type:"array",items:{type:"string"},description:"Subject Alternative Name (SAN) DNS names and IP addresses."},{name:"issuer",type:"string",description:"Name of the issuing CA."},{name:"validFrom",$ref:"Timestamp",description:"Certificate valid from date."},{name:"validTo",$ref:"Timestamp",description:"Certificate valid to (expiration) date"},{name:"signedCertificateTimestampList",type:"array",items:{$ref:"SignedCertificateTimestamp"},description:"List of signed certificate timestamps (SCTs)."}]},{id:"BlockedReason",type:"string",description:"The reason why request was blocked.",enum:["csp","mixed-content","origin","inspector","subresource-filter","other"],experimental:!0},{id:"Response",type:"object",description:"HTTP response data.",properties:[{name:"url",type:"string",description:"Response URL. This URL can be different from CachedResource.url in case of redirect."},{name:"status",type:"number",description:"HTTP response status code."},{name:"statusText",type:"string",description:"HTTP response status text."},{name:"headers",$ref:"Headers",description:"HTTP response headers."},{name:"headersText",type:"string",optional:!0,description:"HTTP response headers text."},{name:"mimeType",type:"string",description:"Resource mimeType as determined by the browser."},{name:"requestHeaders",$ref:"Headers",optional:!0,description:"Refined HTTP request headers that were actually transmitted over the network."},{name:"requestHeadersText",type:"string",optional:!0,description:"HTTP request headers text."},{name:"connectionReused",type:"boolean",description:"Specifies whether physical connection was actually reused for this request."},{name:"connectionId",type:"number",description:"Physical connection id that was actually used for this request."},{name:"remoteIPAddress",type:"string",optional:!0,experimental:!0,description:"Remote IP address."},{name:"remotePort",type:"integer",optional:!0,experimental:!0,description:"Remote port."},{name:"fromDiskCache",type:"boolean",optional:!0,description:"Specifies that the request was served from the disk cache."},{name:"fromServiceWorker",type:"boolean",optional:!0,description:"Specifies that the request was served from the ServiceWorker."},{name:"encodedDataLength",type:"number",optional:!1,description:"Total number of bytes received for this request so far."},{name:"timing",$ref:"ResourceTiming",optional:!0,description:"Timing information for the given request."},{name:"protocol",type:"string",optional:!0,description:"Protocol used to fetch this request."},{name:"securityState",$ref:"Security.SecurityState",description:"Security state of the request resource."},{name:"securityDetails",$ref:"SecurityDetails",optional:!0,description:"Security details for the request."}]},{id:"WebSocketRequest",type:"object",description:"WebSocket request data.",experimental:!0,properties:[{name:"headers",$ref:"Headers",description:"HTTP request headers."}]},{id:"WebSocketResponse",type:"object",description:"WebSocket response data.",experimental:!0,properties:[{name:"status",type:"number",description:"HTTP response status code."},{name:"statusText",type:"string",description:"HTTP response status text."},{name:"headers",$ref:"Headers",description:"HTTP response headers."},{name:"headersText",type:"string",optional:!0,description:"HTTP response headers text."},{name:"requestHeaders",$ref:"Headers",optional:!0,description:"HTTP request headers."},{name:"requestHeadersText",type:"string",optional:!0,description:"HTTP request headers text."}]},{id:"WebSocketFrame",type:"object",description:"WebSocket frame data.",experimental:!0,properties:[{name:"opcode",type:"number",description:"WebSocket frame opcode."},{name:"mask",type:"boolean",description:"WebSocke frame mask."},{name:"payloadData",type:"string",description:"WebSocke frame payload data."}]},{id:"CachedResource",type:"object",description:"Information about the cached resource.",properties:[{name:"url",type:"string",description:"Resource URL. This is the url of the original network request."},{name:"type",$ref:"Page.ResourceType",description:"Type of this resource."},{name:"response",$ref:"Response",optional:!0,description:"Cached response data."},{name:"bodySize",type:"number",description:"Cached response body size."}]},{id:"Initiator",type:"object",description:"Information about the request initiator.",properties:[{name:"type",type:"string",enum:["parser","script","other"],description:"Type of this initiator."},{name:"stack",$ref:"Runtime.StackTrace",optional:!0,description:"Initiator JavaScript stack trace, set for Script only."},{name:"url",type:"string",optional:!0,description:"Initiator URL, set for Parser type only."},{name:"lineNumber",type:"number",optional:!0,description:"Initiator line number, set for Parser type only (0-based)."}]},{id:"Cookie",type:"object",description:"Cookie object",properties:[{name:"name",type:"string",description:"Cookie name."},{name:"value",type:"string",description:"Cookie value."},{name:"domain",type:"string",description:"Cookie domain."},{name:"path",type:"string",description:"Cookie path."},{name:"expires",type:"number",description:"Cookie expiration date as the number of seconds since the UNIX epoch."},{name:"size",type:"integer",description:"Cookie size."},{name:"httpOnly",type:"boolean",description:"True if cookie is http-only."},{name:"secure",type:"boolean",description:"True if cookie is secure."},{name:"session",type:"boolean",description:"True in case of session cookie."},{name:"sameSite",$ref:"CookieSameSite",optional:!0,description:"Cookie SameSite type."}],experimental:!0}],commands:[{name:"enable",description:"Enables network tracking, network events will now be delivered to the client.",parameters:[{name:"maxTotalBufferSize",type:"integer",optional:!0,experimental:!0,description:"Buffer size in bytes to use when preserving network payloads (XHRs, etc)."},{name:"maxResourceBufferSize",type:"integer",optional:!0,experimental:!0,description:"Per-resource buffer size in bytes to use when preserving network payloads (XHRs, etc)."}]},{name:"disable",description:"Disables network tracking, prevents network events from being sent to the client."},{name:"setUserAgentOverride",description:"Allows overriding user agent with the given string.",parameters:[{name:"userAgent",type:"string",description:"User agent to use."}]},{name:"setExtraHTTPHeaders",description:"Specifies whether to always send extra HTTP headers with the requests from this page.",parameters:[{name:"headers",$ref:"Headers",description:"Map with extra HTTP headers."}]},{name:"getResponseBody",description:"Returns content served for the given request.",parameters:[{name:"requestId",$ref:"RequestId",description:"Identifier of the network request to get content for."}],returns:[{name:"body",type:"string",description:"Response body."},{name:"base64Encoded",type:"boolean",description:"True, if content was sent as base64."}]},{name:"addBlockedURL",description:"Blocks specific URL from loading.",parameters:[{name:"url",type:"string",description:"URL to block."}],experimental:!0},{name:"removeBlockedURL",description:"Cancels blocking of a specific URL from loading.",parameters:[{name:"url",type:"string",description:"URL to stop blocking."}],experimental:!0},{name:"replayXHR",description:"This method sends a new XMLHttpRequest which is identical to the original one. The following parameters should be identical: method, url, async, request body, extra headers, withCredentials attribute, user, password.",parameters:[{name:"requestId",$ref:"RequestId",description:"Identifier of XHR to replay."}],experimental:!0},{name:"setMonitoringXHREnabled",parameters:[{name:"enabled",type:"boolean",description:"Monitoring enabled state."}],description:"Toggles monitoring of XMLHttpRequest. If <code>true</code>, console will receive messages upon each XHR issued.",experimental:!0},{name:"canClearBrowserCache",description:"Tells whether clearing browser cache is supported.",returns:[{name:"result",type:"boolean",description:"True if browser cache can be cleared."}]},{name:"clearBrowserCache",description:"Clears browser cache."},{name:"canClearBrowserCookies",description:"Tells whether clearing browser cookies is supported.",returns:[{name:"result",type:"boolean",description:"True if browser cookies can be cleared."}]},{name:"clearBrowserCookies",description:"Clears browser cookies."},{name:"getCookies",returns:[{name:"cookies",type:"array",items:{$ref:"Cookie"},description:"Array of cookie objects."}],description:"Returns all browser cookies. Depending on the backend support, will return detailed cookie information in the <code>cookies</code> field.",experimental:!0},{name:"deleteCookie",parameters:[{name:"cookieName",type:"string",description:"Name of the cookie to remove."},{name:"url",type:"string",description:"URL to match cooke domain and path."}],description:"Deletes browser cookie with given name, domain and path.",experimental:!0},{name:"setCookie",parameters:[{name:"url",type:"string",description:"The request-URI to associate with the setting of the cookie. This value can affect the default domain and path values of the created cookie."},{name:"name",type:"string",description:"The name of the cookie."},{name:"value",type:"string",description:"The value of the cookie."},{name:"domain",type:"string",optional:!0,description:"If omitted, the cookie becomes a host-only cookie."},{name:"path",type:"string",optional:!0,description:"Defaults to the path portion of the url parameter."},{name:"secure",type:"boolean",optional:!0,description:"Defaults ot false."},{name:"httpOnly",type:"boolean",optional:!0,description:"Defaults to false."},{name:"sameSite",$ref:"CookieSameSite",optional:!0,description:"Defaults to browser default behavior."},{name:"expirationDate",$ref:"Timestamp",optional:!0,description:"If omitted, the cookie becomes a session cookie."}],returns:[{name:"success",type:"boolean",description:"True if successfully set cookie."}],description:"Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.",experimental:!0},{name:"canEmulateNetworkConditions",description:"Tells whether emulation of network conditions is supported.",returns:[{name:"result",type:"boolean",description:"True if emulation of network conditions is supported."}],experimental:!0},{name:"emulateNetworkConditions",description:"Activates emulation of network conditions.",parameters:[{name:"offline",type:"boolean",description:"True to emulate internet disconnection."},{name:"latency",type:"number",description:"Additional latency (ms)."},{name:"downloadThroughput",type:"number",description:"Maximal aggregated download throughput."},{name:"uploadThroughput",type:"number",description:"Maximal aggregated upload throughput."},{name:"connectionType",$ref:"ConnectionType",optional:!0,description:"Connection type if known."}]},{name:"setCacheDisabled",parameters:[{name:"cacheDisabled",type:"boolean",description:"Cache disabled state."}],description:"Toggles ignoring cache for each request. If <code>true</code>, cache will not be used."},{name:"setBypassServiceWorker",parameters:[{name:"bypass",type:"boolean",description:"Bypass service worker and load from network."}],experimental:!0,description:"Toggles ignoring of service worker for each request."},{name:"setDataSizeLimitsForTest",parameters:[{name:"maxTotalSize",type:"integer",description:"Maximum total buffer size."},{name:"maxResourceSize",type:"integer",description:"Maximum per-resource size."}],description:"For testing.",experimental:!0},{name:"getCertificate",description:"Returns the DER-encoded certificate.",parameters:[{name:"origin",type:"string",description:"Origin to get certificate for."}],returns:[{name:"tableNames",type:"array",items:{type:"string"}}],experimental:!0}],events:[{name:"resourceChangedPriority",description:"Fired when resource loading priority is changed",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"newPriority",$ref:"ResourcePriority",description:"New priority"},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."}],experimental:!0},{name:"requestWillBeSent",description:"Fired when page is about to send HTTP request.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"frameId",$ref:"Page.FrameId",description:"Frame identifier.",experimental:!0},{name:"loaderId",$ref:"LoaderId",description:"Loader identifier."},{name:"documentURL",type:"string",description:"URL of the document this request is loaded for."
	},{name:"request",$ref:"Request",description:"Request data."},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."},{name:"wallTime",$ref:"Timestamp",experimental:!0,description:"UTC Timestamp."},{name:"initiator",$ref:"Initiator",description:"Request initiator."},{name:"redirectResponse",optional:!0,$ref:"Response",description:"Redirect response data."},{name:"type",$ref:"Page.ResourceType",optional:!0,experimental:!0,description:"Type of this resource."}]},{name:"requestServedFromCache",description:"Fired if request ended up loading from cache.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."}]},{name:"responseReceived",description:"Fired when HTTP response is available.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"frameId",$ref:"Page.FrameId",description:"Frame identifier.",experimental:!0},{name:"loaderId",$ref:"LoaderId",description:"Loader identifier."},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."},{name:"type",$ref:"Page.ResourceType",description:"Resource type."},{name:"response",$ref:"Response",description:"Response data."}]},{name:"dataReceived",description:"Fired when data chunk was received over the network.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."},{name:"dataLength",type:"integer",description:"Data chunk length."},{name:"encodedDataLength",type:"integer",description:"Actual bytes received (might be less than dataLength for compressed encodings)."}]},{name:"loadingFinished",description:"Fired when HTTP request has finished loading.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."},{name:"encodedDataLength",type:"number",description:"Total number of bytes received for this request."}]},{name:"loadingFailed",description:"Fired when HTTP request has failed to load.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."},{name:"type",$ref:"Page.ResourceType",description:"Resource type."},{name:"errorText",type:"string",description:"User friendly error message."},{name:"canceled",type:"boolean",optional:!0,description:"True if loading was canceled."},{name:"blockedReason",$ref:"BlockedReason",optional:!0,description:"The reason why loading was blocked, if any.",experimental:!0}]},{name:"webSocketWillSendHandshakeRequest",description:"Fired when WebSocket is about to initiate handshake.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."},{name:"wallTime",$ref:"Timestamp",experimental:!0,description:"UTC Timestamp."},{name:"request",$ref:"WebSocketRequest",description:"WebSocket request data."}],experimental:!0},{name:"webSocketHandshakeResponseReceived",description:"Fired when WebSocket handshake response becomes available.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."},{name:"response",$ref:"WebSocketResponse",description:"WebSocket response data."}],experimental:!0},{name:"webSocketCreated",description:"Fired upon WebSocket creation.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"url",type:"string",description:"WebSocket request URL."},{name:"initiator",$ref:"Initiator",optional:!0,description:"Request initiator."}],experimental:!0},{name:"webSocketClosed",description:"Fired when WebSocket is closed.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."}],experimental:!0},{name:"webSocketFrameReceived",description:"Fired when WebSocket frame is received.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."},{name:"response",$ref:"WebSocketFrame",description:"WebSocket response data."}],experimental:!0},{name:"webSocketFrameError",description:"Fired when WebSocket frame error occurs.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."},{name:"errorMessage",type:"string",description:"WebSocket frame error message."}],experimental:!0},{name:"webSocketFrameSent",description:"Fired when WebSocket frame is sent.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."},{name:"response",$ref:"WebSocketFrame",description:"WebSocket response data."}],experimental:!0},{name:"eventSourceMessageReceived",description:"Fired when EventSource message is received.",parameters:[{name:"requestId",$ref:"RequestId",description:"Request identifier."},{name:"timestamp",$ref:"Timestamp",description:"Timestamp."},{name:"eventName",type:"string",description:"Message type."},{name:"eventId",type:"string",description:"Message identifier."},{name:"data",type:"string",description:"Message content."}],experimental:!0}]},{domain:"Database",experimental:!0,types:[{id:"DatabaseId",type:"string",description:"Unique identifier of Database object.",experimental:!0},{id:"Database",type:"object",description:"Database object.",experimental:!0,properties:[{name:"id",$ref:"DatabaseId",description:"Database ID."},{name:"domain",type:"string",description:"Database domain."},{name:"name",type:"string",description:"Database name."},{name:"version",type:"string",description:"Database version."}]},{id:"Error",type:"object",description:"Database error.",properties:[{name:"message",type:"string",description:"Error message."},{name:"code",type:"integer",description:"Error code."}]}],commands:[{name:"enable",description:"Enables database tracking, database events will now be delivered to the client."},{name:"disable",description:"Disables database tracking, prevents database events from being sent to the client."},{name:"getDatabaseTableNames",parameters:[{name:"databaseId",$ref:"DatabaseId"}],returns:[{name:"tableNames",type:"array",items:{type:"string"}}]},{name:"executeSQL",parameters:[{name:"databaseId",$ref:"DatabaseId"},{name:"query",type:"string"}],returns:[{name:"columnNames",type:"array",optional:!0,items:{type:"string"}},{name:"values",type:"array",optional:!0,items:{type:"any"}},{name:"sqlError",$ref:"Error",optional:!0}]}],events:[{name:"addDatabase",parameters:[{name:"database",$ref:"Database"}]}]},{domain:"IndexedDB",dependencies:["Runtime"],experimental:!0,types:[{id:"DatabaseWithObjectStores",type:"object",description:"Database with an array of object stores.",properties:[{name:"name",type:"string",description:"Database name."},{name:"version",type:"integer",description:"Database version."},{name:"objectStores",type:"array",items:{$ref:"ObjectStore"},description:"Object stores in this database."}]},{id:"ObjectStore",type:"object",description:"Object store.",properties:[{name:"name",type:"string",description:"Object store name."},{name:"keyPath",$ref:"KeyPath",description:"Object store key path."},{name:"autoIncrement",type:"boolean",description:"If true, object store has auto increment flag set."},{name:"indexes",type:"array",items:{$ref:"ObjectStoreIndex"},description:"Indexes in this object store."}]},{id:"ObjectStoreIndex",type:"object",description:"Object store index.",properties:[{name:"name",type:"string",description:"Index name."},{name:"keyPath",$ref:"KeyPath",description:"Index key path."},{name:"unique",type:"boolean",description:"If true, index is unique."},{name:"multiEntry",type:"boolean",description:"If true, index allows multiple entries for a key."}]},{id:"Key",type:"object",description:"Key.",properties:[{name:"type",type:"string",enum:["number","string","date","array"],description:"Key type."},{name:"number",type:"number",optional:!0,description:"Number value."},{name:"string",type:"string",optional:!0,description:"String value."},{name:"date",type:"number",optional:!0,description:"Date value."},{name:"array",type:"array",optional:!0,items:{$ref:"Key"},description:"Array value."}]},{id:"KeyRange",type:"object",description:"Key range.",properties:[{name:"lower",$ref:"Key",optional:!0,description:"Lower bound."},{name:"upper",$ref:"Key",optional:!0,description:"Upper bound."},{name:"lowerOpen",type:"boolean",description:"If true lower bound is open."},{name:"upperOpen",type:"boolean",description:"If true upper bound is open."}]},{id:"DataEntry",type:"object",description:"Data entry.",properties:[{name:"key",$ref:"Runtime.RemoteObject",description:"Key object."},{name:"primaryKey",$ref:"Runtime.RemoteObject",description:"Primary key object."},{name:"value",$ref:"Runtime.RemoteObject",description:"Value object."}]},{id:"KeyPath",type:"object",description:"Key path.",properties:[{name:"type",type:"string",enum:["null","string","array"],description:"Key path type."},{name:"string",type:"string",optional:!0,description:"String value."},{name:"array",type:"array",optional:!0,items:{type:"string"},description:"Array value."}]}],commands:[{name:"enable",description:"Enables events from backend."},{name:"disable",description:"Disables events from backend."},{name:"requestDatabaseNames",parameters:[{name:"securityOrigin",type:"string",description:"Security origin."}],returns:[{name:"databaseNames",type:"array",items:{type:"string"},description:"Database names for origin."}],description:"Requests database names for given security origin."},{name:"requestDatabase",parameters:[{name:"securityOrigin",type:"string",description:"Security origin."},{name:"databaseName",type:"string",description:"Database name."}],returns:[{name:"databaseWithObjectStores",$ref:"DatabaseWithObjectStores",description:"Database with an array of object stores."}],description:"Requests database with given name in given frame."},{name:"requestData",parameters:[{name:"securityOrigin",type:"string",description:"Security origin."},{name:"databaseName",type:"string",description:"Database name."},{name:"objectStoreName",type:"string",description:"Object store name."},{name:"indexName",type:"string",description:"Index name, empty string for object store data requests."},{name:"skipCount",type:"integer",description:"Number of records to skip."},{name:"pageSize",type:"integer",description:"Number of records to fetch."},{name:"keyRange",$ref:"KeyRange",optional:!0,description:"Key range."}],returns:[{name:"objectStoreDataEntries",type:"array",items:{$ref:"DataEntry"},description:"Array of object store data entries."},{name:"hasMore",type:"boolean",description:"If true, there are more entries to fetch in the given range."}],description:"Requests data from object store or index."},{name:"clearObjectStore",parameters:[{name:"securityOrigin",type:"string",description:"Security origin."},{name:"databaseName",type:"string",description:"Database name."},{name:"objectStoreName",type:"string",description:"Object store name."}],returns:[],description:"Clears all entries from an object store."}]},{domain:"CacheStorage",experimental:!0,types:[{id:"CacheId",type:"string",description:"Unique identifier of the Cache object."},{id:"DataEntry",type:"object",description:"Data entry.",properties:[{name:"request",type:"string",description:"Request url spec."},{name:"response",type:"string",description:"Response stataus text."}]},{id:"Cache",type:"object",description:"Cache identifier.",properties:[{name:"cacheId",$ref:"CacheId",description:"An opaque unique id of the cache."},{name:"securityOrigin",type:"string",description:"Security origin of the cache."},{name:"cacheName",type:"string",description:"The name of the cache."}]}],commands:[{name:"requestCacheNames",parameters:[{name:"securityOrigin",type:"string",description:"Security origin."}],returns:[{name:"caches",type:"array",items:{$ref:"Cache"},description:"Caches for the security origin."}],description:"Requests cache names."},{name:"requestEntries",parameters:[{name:"cacheId",$ref:"CacheId",description:"ID of cache to get entries from."},{name:"skipCount",type:"integer",description:"Number of records to skip."},{name:"pageSize",type:"integer",description:"Number of records to fetch."}],returns:[{name:"cacheDataEntries",type:"array",items:{$ref:"DataEntry"},description:"Array of object store data entries."},{name:"hasMore",type:"boolean",description:"If true, there are more entries to fetch in the given range."}],description:"Requests data from cache."},{name:"deleteCache",parameters:[{name:"cacheId",$ref:"CacheId",description:"Id of cache for deletion."}],description:"Deletes a cache."},{name:"deleteEntry",parameters:[{name:"cacheId",$ref:"CacheId",description:"Id of cache where the entry will be deleted."},{name:"request",type:"string",description:"URL spec of the request."}],description:"Deletes a cache entry."}]},{domain:"DOMStorage",experimental:!0,description:"Query and modify DOM storage.",types:[{id:"StorageId",type:"object",description:"DOM Storage identifier.",experimental:!0,properties:[{name:"securityOrigin",type:"string",description:"Security origin for the storage."},{name:"isLocalStorage",type:"boolean",description:"Whether the storage is local storage (not session storage)."}]},{id:"Item",type:"array",description:"DOM Storage item.",experimental:!0,items:{type:"string"}}],commands:[{name:"enable",description:"Enables storage tracking, storage events will now be delivered to the client."},{name:"disable",description:"Disables storage tracking, prevents storage events from being sent to the client."},{name:"getDOMStorageItems",parameters:[{name:"storageId",$ref:"StorageId"}],returns:[{name:"entries",type:"array",items:{$ref:"Item"}}]},{name:"setDOMStorageItem",parameters:[{name:"storageId",$ref:"StorageId"},{name:"key",type:"string"},{name:"value",type:"string"}]},{name:"removeDOMStorageItem",parameters:[{name:"storageId",$ref:"StorageId"},{name:"key",type:"string"}]}],events:[{name:"domStorageItemsCleared",parameters:[{name:"storageId",$ref:"StorageId"}]},{name:"domStorageItemRemoved",parameters:[{name:"storageId",$ref:"StorageId"},{name:"key",type:"string"}]},{name:"domStorageItemAdded",parameters:[{name:"storageId",$ref:"StorageId"},{name:"key",type:"string"},{name:"newValue",type:"string"}]},{name:"domStorageItemUpdated",parameters:[{name:"storageId",$ref:"StorageId"},{name:"key",type:"string"},{name:"oldValue",type:"string"},{name:"newValue",type:"string"}]}]},{domain:"ApplicationCache",experimental:!0,types:[{id:"ApplicationCacheResource",type:"object",description:"Detailed application cache resource information.",properties:[{name:"url",type:"string",description:"Resource url."},{name:"size",type:"integer",description:"Resource size."},{name:"type",type:"string",description:"Resource type."}]},{id:"ApplicationCache",type:"object",description:"Detailed application cache information.",properties:[{name:"manifestURL",type:"string",description:"Manifest URL."},{name:"size",type:"number",description:"Application cache size."},{name:"creationTime",type:"number",description:"Application cache creation time."},{name:"updateTime",type:"number",description:"Application cache update time."},{name:"resources",type:"array",items:{$ref:"ApplicationCacheResource"},description:"Application cache resources."}]},{id:"FrameWithManifest",type:"object",description:"Frame identifier - manifest URL pair.",properties:[{name:"frameId",$ref:"Page.FrameId",description:"Frame identifier."},{name:"manifestURL",type:"string",description:"Manifest URL."},{name:"status",type:"integer",description:"Application cache status."}]}],commands:[{name:"getFramesWithManifests",returns:[{name:"frameIds",type:"array",items:{$ref:"FrameWithManifest"},description:"Array of frame identifiers with manifest urls for each frame containing a document associated with some application cache."}],description:"Returns array of frame identifiers with manifest urls for each frame containing a document associated with some application cache."},{name:"enable",description:"Enables application cache domain notifications."},{name:"getManifestForFrame",parameters:[{name:"frameId",$ref:"Page.FrameId",description:"Identifier of the frame containing document whose manifest is retrieved."}],returns:[{name:"manifestURL",type:"string",description:"Manifest URL for document in the given frame."}],description:"Returns manifest URL for document in the given frame."},{name:"getApplicationCacheForFrame",parameters:[{name:"frameId",$ref:"Page.FrameId",description:"Identifier of the frame containing document whose application cache is retrieved."}],returns:[{name:"applicationCache",$ref:"ApplicationCache",description:"Relevant application cache data for the document in given frame."}],description:"Returns relevant application cache data for the document in given frame."}],events:[{name:"applicationCacheStatusUpdated",parameters:[{name:"frameId",$ref:"Page.FrameId",description:"Identifier of the frame containing document whose application cache updated status."},{name:"manifestURL",type:"string",description:"Manifest URL."},{name:"status",type:"integer",description:"Updated application cache status."}]},{name:"networkStateUpdated",parameters:[{name:"isNowOnline",type:"boolean"}]}]},{domain:"DOM",description:"This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object that has an <code>id</code>. This <code>id</code> can be used to get additional information on the Node, resolve it into the JavaScript object wrapper, etc. It is important that client receives DOM events only for the nodes that are known to the client. Backend keeps track of the nodes that were sent to the client and never sends the same node twice. It is client's responsibility to collect information about the nodes that were sent to the client.<p>Note that <code>iframe</code> owner elements will return corresponding document elements as their child nodes.</p>",dependencies:["Runtime"],types:[{id:"NodeId",type:"integer",description:"Unique DOM node identifier."},{id:"BackendNodeId",type:"integer",description:"Unique DOM node identifier used to reference a node that may not have been pushed to the front-end.",experimental:!0},{id:"BackendNode",type:"object",properties:[{name:"nodeType",type:"integer",description:"<code>Node</code>'s nodeType."},{name:"nodeName",type:"string",description:"<code>Node</code>'s nodeName."},{name:"backendNodeId",$ref:"BackendNodeId"}],experimental:!0,description:"Backend node with a friendly name."},{id:"PseudoType",type:"string",enum:["first-line","first-letter","before","after","backdrop","selection","first-line-inherited","scrollbar","scrollbar-thumb","scrollbar-button","scrollbar-track","scrollbar-track-piece","scrollbar-corner","resizer","input-list-button"],description:"Pseudo element type."},{id:"ShadowRootType",type:"string",enum:["user-agent","open","closed"],description:"Shadow root type."},{id:"Node",type:"object",properties:[{name:"nodeId",$ref:"NodeId",description:"Node identifier that is passed into the rest of the DOM messages as the <code>nodeId</code>. Backend will only push node with given <code>id</code> once. It is aware of all requested nodes and will only fire DOM events for nodes known to the client."},{name:"backendNodeId",$ref:"BackendNodeId",description:"The BackendNodeId for this node.",experimental:!0},{name:"nodeType",type:"integer",description:"<code>Node</code>'s nodeType."},{name:"nodeName",type:"string",description:"<code>Node</code>'s nodeName."},{name:"localName",type:"string",description:"<code>Node</code>'s localName."},{name:"nodeValue",type:"string",description:"<code>Node</code>'s nodeValue."},{name:"childNodeCount",type:"integer",optional:!0,description:"Child count for <code>Container</code> nodes."},{name:"children",type:"array",optional:!0,items:{$ref:"Node"},description:"Child nodes of this node when requested with children."},{name:"attributes",type:"array",optional:!0,items:{type:"string"},description:"Attributes of the <code>Element</code> node in the form of flat array <code>[name1, value1, name2, value2]</code>."},{name:"documentURL",type:"string",optional:!0,description:"Document URL that <code>Document</code> or <code>FrameOwner</code> node points to."},{name:"baseURL",type:"string",optional:!0,description:"Base URL that <code>Document</code> or <code>FrameOwner</code> node uses for URL completion.",experimental:!0},{name:"publicId",type:"string",optional:!0,description:"<code>DocumentType</code>'s publicId."},{name:"systemId",type:"string",optional:!0,description:"<code>DocumentType</code>'s systemId."},{name:"internalSubset",type:"string",optional:!0,description:"<code>DocumentType</code>'s internalSubset."},{name:"xmlVersion",type:"string",optional:!0,description:"<code>Document</code>'s XML version in case of XML documents."},{name:"name",type:"string",optional:!0,description:"<code>Attr</code>'s name."},{name:"value",type:"string",optional:!0,description:"<code>Attr</code>'s value."},{name:"pseudoType",$ref:"PseudoType",optional:!0,description:"Pseudo element type for this node."},{name:"shadowRootType",$ref:"ShadowRootType",optional:!0,description:"Shadow root type."},{name:"frameId",$ref:"Page.FrameId",optional:!0,description:"Frame ID for frame owner elements.",experimental:!0},{name:"contentDocument",$ref:"Node",optional:!0,description:"Content document for frame owner elements."},{name:"shadowRoots",type:"array",optional:!0,items:{$ref:"Node"},description:"Shadow root list for given element host.",experimental:!0},{name:"templateContent",$ref:"Node",optional:!0,description:"Content document fragment for template elements.",experimental:!0},{name:"pseudoElements",type:"array",items:{$ref:"Node"},optional:!0,description:"Pseudo elements associated with this node.",experimental:!0},{name:"importedDocument",$ref:"Node",optional:!0,description:"Import document for the HTMLImport links."},{name:"distributedNodes",type:"array",items:{$ref:"BackendNode"},optional:!0,description:"Distributed nodes for given insertion point.",experimental:!0}],description:"DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes. DOMNode is a base node mirror type."},{id:"RGBA",type:"object",properties:[{name:"r",type:"integer",description:"The red component, in the [0-255] range."},{name:"g",type:"integer",description:"The green component, in the [0-255] range."},{name:"b",type:"integer",description:"The blue component, in the [0-255] range."},{name:"a",type:"number",optional:!0,description:"The alpha component, in the [0-1] range (default: 1)."}],description:"A structure holding an RGBA color."},{id:"Quad",type:"array",items:{type:"number"},minItems:8,maxItems:8,description:"An array of quad vertices, x immediately followed by y for each point, points clock-wise.",experimental:!0},{id:"BoxModel",type:"object",experimental:!0,properties:[{name:"content",$ref:"Quad",description:"Content box"},{name:"padding",$ref:"Quad",description:"Padding box"},{name:"border",$ref:"Quad",description:"Border box"},{name:"margin",$ref:"Quad",description:"Margin box"},{name:"width",type:"integer",description:"Node width"},{name:"height",type:"integer",description:"Node height"},{name:"shapeOutside",$ref:"ShapeOutsideInfo",optional:!0,description:"Shape outside coordinates"}],description:"Box model."},{id:"ShapeOutsideInfo",type:"object",experimental:!0,properties:[{name:"bounds",$ref:"Quad",description:"Shape bounds"},{name:"shape",type:"array",items:{type:"any"},description:"Shape coordinate details"},{name:"marginShape",type:"array",items:{type:"any"},description:"Margin shape bounds"}],description:"CSS Shape Outside details."},{id:"Rect",type:"object",experimental:!0,properties:[{name:"x",type:"number",description:"X coordinate"},{name:"y",type:"number",description:"Y coordinate"},{name:"width",type:"number",description:"Rectangle width"},{name:"height",type:"number",description:"Rectangle height"}],description:"Rectangle."},{id:"HighlightConfig",type:"object",properties:[{name:"showInfo",type:"boolean",optional:!0,description:"Whether the node info tooltip should be shown (default: false)."},{name:"showRulers",type:"boolean",optional:!0,description:"Whether the rulers should be shown (default: false)."},{name:"showExtensionLines",type:"boolean",optional:!0,description:"Whether the extension lines from node to the rulers should be shown (default: false)."},{name:"displayAsMaterial",type:"boolean",optional:!0,experimental:!0},{name:"contentColor",$ref:"RGBA",optional:!0,description:"The content box highlight fill color (default: transparent)."},{name:"paddingColor",$ref:"RGBA",optional:!0,description:"The padding highlight fill color (default: transparent)."},{name:"borderColor",$ref:"RGBA",optional:!0,description:"The border highlight fill color (default: transparent)."},{name:"marginColor",$ref:"RGBA",optional:!0,description:"The margin highlight fill color (default: transparent)."},{name:"eventTargetColor",$ref:"RGBA",optional:!0,experimental:!0,description:"The event target element highlight fill color (default: transparent)."},{name:"shapeColor",$ref:"RGBA",optional:!0,experimental:!0,description:"The shape outside fill color (default: transparent)."},{name:"shapeMarginColor",$ref:"RGBA",optional:!0,experimental:!0,description:"The shape margin fill color (default: transparent)."},{name:"selectorList",type:"string",optional:!0,description:"Selectors to highlight relevant nodes."}],description:"Configuration data for the highlighting of page elements."},{id:"InspectMode",type:"string",experimental:!0,enum:["searchForNode","searchForUAShadowDOM","none"]}],commands:[{name:"enable",description:"Enables DOM agent for the given page."},{name:"disable",description:"Disables DOM agent for the given page."},{name:"getDocument",parameters:[{name:"depth",type:"integer",optional:!0,description:"The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.",experimental:!0},{name:"pierce",type:"boolean",optional:!0,description:"Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false).",experimental:!0}],returns:[{name:"root",$ref:"Node",description:"Resulting node."}],description:"Returns the root DOM node (and optionally the subtree) to the caller."},{name:"collectClassNamesFromSubtree",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to collect class names."}],returns:[{name:"classNames",type:"array",items:{type:"string"},description:"Class name list."}],description:"Collects class names for the node with given id and all of it's child nodes.",experimental:!0},{name:"requestChildNodes",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to get children for."},{name:"depth",type:"integer",optional:!0,description:"The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.",experimental:!0},{name:"pierce",type:"boolean",optional:!0,description:"Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false).",experimental:!0}],description:"Requests that children of the node with given id are returned to the caller in form of <code>setChildNodes</code> events where not only immediate children are retrieved, but all children down to the specified depth."},{name:"querySelector",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to query upon."},{name:"selector",type:"string",description:"Selector string."}],returns:[{name:"nodeId",$ref:"NodeId",description:"Query selector result."}],description:"Executes <code>querySelector</code> on a given node."},{name:"querySelectorAll",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to query upon."},{name:"selector",type:"string",description:"Selector string."}],returns:[{name:"nodeIds",type:"array",items:{$ref:"NodeId"},description:"Query selector result."}],description:"Executes <code>querySelectorAll</code> on a given node."},{name:"setNodeName",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to set name for."},{name:"name",type:"string",description:"New node's name."}],returns:[{name:"nodeId",$ref:"NodeId",description:"New node's id."}],description:"Sets node name for a node with given id."},{name:"setNodeValue",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to set value for."},{name:"value",type:"string",description:"New node's value."}],description:"Sets node value for a node with given id."},{name:"removeNode",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to remove."}],description:"Removes node with given id."},{name:"setAttributeValue",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the element to set attribute for."},{name:"name",type:"string",description:"Attribute name."},{name:"value",type:"string",description:"Attribute value."}],description:"Sets attribute for an element with given id."},{name:"setAttributesAsText",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the element to set attributes for."},{name:"text",type:"string",description:"Text with a number of attributes. Will parse this text using HTML parser."},{name:"name",type:"string",optional:!0,description:"Attribute name to replace with new attributes derived from text in case text parsed successfully."}],description:"Sets attributes on element with given id. This method is useful when user edits some existing attribute value and types in several attribute name/value pairs."},{name:"removeAttribute",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the element to remove attribute from."},{name:"name",type:"string",description:"Name of the attribute to remove."}],description:"Removes attribute with given name from an element with given id."},{name:"getOuterHTML",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to get markup for."}],returns:[{name:"outerHTML",type:"string",description:"Outer HTML markup."}],description:"Returns node's HTML markup."},{name:"setOuterHTML",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to set markup for."},{name:"outerHTML",type:"string",description:"Outer HTML markup to set."}],description:"Sets node HTML markup, returns new node id."},{name:"performSearch",parameters:[{name:"query",type:"string",description:"Plain text or query selector or XPath search query."},{name:"includeUserAgentShadowDOM",type:"boolean",optional:!0,description:"True to search in user agent shadow DOM.",experimental:!0}],returns:[{name:"searchId",type:"string",description:"Unique search session identifier."},{name:"resultCount",type:"integer",description:"Number of search results."}],description:"Searches for a given string in the DOM tree. Use <code>getSearchResults</code> to access search results or <code>cancelSearch</code> to end this search session.",experimental:!0},{name:"getSearchResults",parameters:[{name:"searchId",type:"string",description:"Unique search session identifier."},{name:"fromIndex",type:"integer",description:"Start index of the search result to be returned."},{name:"toIndex",type:"integer",description:"End index of the search result to be returned."}],returns:[{name:"nodeIds",type:"array",items:{$ref:"NodeId"},description:"Ids of the search result nodes."}],description:"Returns search results from given <code>fromIndex</code> to given <code>toIndex</code> from the sarch with the given identifier.",experimental:!0},{name:"discardSearchResults",parameters:[{name:"searchId",type:"string",description:"Unique search session identifier."}],description:"Discards search results from the session with the given id. <code>getSearchResults</code> should no longer be called for that search.",
	experimental:!0},{name:"requestNode",parameters:[{name:"objectId",$ref:"Runtime.RemoteObjectId",description:"JavaScript object id to convert into node."}],returns:[{name:"nodeId",$ref:"NodeId",description:"Node id for given object."}],description:"Requests that the node is sent to the caller given the JavaScript node object reference. All nodes that form the path from the node to the root are also sent to the client as a series of <code>setChildNodes</code> notifications."},{name:"setInspectMode",experimental:!0,parameters:[{name:"mode",$ref:"InspectMode",description:"Set an inspection mode."},{name:"highlightConfig",$ref:"HighlightConfig",optional:!0,description:"A descriptor for the highlight appearance of hovered-over nodes. May be omitted if <code>enabled == false</code>."}],description:"Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted. Backend then generates 'inspectNodeRequested' event upon element selection."},{name:"highlightRect",parameters:[{name:"x",type:"integer",description:"X coordinate"},{name:"y",type:"integer",description:"Y coordinate"},{name:"width",type:"integer",description:"Rectangle width"},{name:"height",type:"integer",description:"Rectangle height"},{name:"color",$ref:"RGBA",optional:!0,description:"The highlight fill color (default: transparent)."},{name:"outlineColor",$ref:"RGBA",optional:!0,description:"The highlight outline color (default: transparent)."}],description:"Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport."},{name:"highlightQuad",parameters:[{name:"quad",$ref:"Quad",description:"Quad to highlight"},{name:"color",$ref:"RGBA",optional:!0,description:"The highlight fill color (default: transparent)."},{name:"outlineColor",$ref:"RGBA",optional:!0,description:"The highlight outline color (default: transparent)."}],description:"Highlights given quad. Coordinates are absolute with respect to the main frame viewport.",experimental:!0},{name:"highlightNode",parameters:[{name:"highlightConfig",$ref:"HighlightConfig",description:"A descriptor for the highlight appearance."},{name:"nodeId",$ref:"NodeId",optional:!0,description:"Identifier of the node to highlight."},{name:"backendNodeId",$ref:"BackendNodeId",optional:!0,description:"Identifier of the backend node to highlight."},{name:"objectId",$ref:"Runtime.RemoteObjectId",optional:!0,description:"JavaScript object id of the node to be highlighted.",experimental:!0}],description:"Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or objectId must be specified."},{name:"hideHighlight",description:"Hides DOM node highlight."},{name:"highlightFrame",parameters:[{name:"frameId",$ref:"Page.FrameId",description:"Identifier of the frame to highlight."},{name:"contentColor",$ref:"RGBA",optional:!0,description:"The content box highlight fill color (default: transparent)."},{name:"contentOutlineColor",$ref:"RGBA",optional:!0,description:"The content box highlight outline color (default: transparent)."}],description:"Highlights owner element of the frame with given id.",experimental:!0},{name:"pushNodeByPathToFrontend",parameters:[{name:"path",type:"string",description:"Path to node in the proprietary format."}],returns:[{name:"nodeId",$ref:"NodeId",description:"Id of the node for given path."}],description:"Requests that the node is sent to the caller given its path. // FIXME, use XPath",experimental:!0},{name:"pushNodesByBackendIdsToFrontend",parameters:[{name:"backendNodeIds",type:"array",items:{$ref:"BackendNodeId"},description:"The array of backend node ids."}],returns:[{name:"nodeIds",type:"array",items:{$ref:"NodeId"},description:"The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds."}],description:"Requests that a batch of nodes is sent to the caller given their backend node ids.",experimental:!0},{name:"setInspectedNode",parameters:[{name:"nodeId",$ref:"NodeId",description:"DOM node id to be accessible by means of $x command line API."}],description:"Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).",experimental:!0},{name:"resolveNode",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to resolve."},{name:"objectGroup",type:"string",optional:!0,description:"Symbolic group name that can be used to release multiple objects."}],returns:[{name:"object",$ref:"Runtime.RemoteObject",description:"JavaScript object wrapper for given node."}],description:"Resolves JavaScript node object for given node id."},{name:"getAttributes",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to retrieve attibutes for."}],returns:[{name:"attributes",type:"array",items:{type:"string"},description:"An interleaved array of node attribute names and values."}],description:"Returns attributes for the specified node."},{name:"copyTo",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to copy."},{name:"targetNodeId",$ref:"NodeId",description:"Id of the element to drop the copy into."},{name:"insertBeforeNodeId",$ref:"NodeId",optional:!0,description:"Drop the copy before this node (if absent, the copy becomes the last child of <code>targetNodeId</code>)."}],returns:[{name:"nodeId",$ref:"NodeId",description:"Id of the node clone."}],description:"Creates a deep copy of the specified node and places it into the target container before the given anchor.",experimental:!0},{name:"moveTo",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to move."},{name:"targetNodeId",$ref:"NodeId",description:"Id of the element to drop the moved node into."},{name:"insertBeforeNodeId",$ref:"NodeId",optional:!0,description:"Drop node before this one (if absent, the moved node becomes the last child of <code>targetNodeId</code>)."}],returns:[{name:"nodeId",$ref:"NodeId",description:"New id of the moved node."}],description:"Moves node into the new container, places it before the given anchor."},{name:"undo",description:"Undoes the last performed action.",experimental:!0},{name:"redo",description:"Re-does the last undone action.",experimental:!0},{name:"markUndoableState",description:"Marks last undoable state.",experimental:!0},{name:"focus",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to focus."}],description:"Focuses the given element.",experimental:!0},{name:"setFileInputFiles",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the file input node to set files for."},{name:"files",type:"array",items:{type:"string"},description:"Array of file paths to set."}],description:"Sets files for the given file input element.",experimental:!0},{name:"getBoxModel",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to get box model for."}],returns:[{name:"model",$ref:"BoxModel",description:"Box model for the node."}],description:"Returns boxes for the currently selected nodes.",experimental:!0},{name:"getNodeForLocation",parameters:[{name:"x",type:"integer",description:"X coordinate."},{name:"y",type:"integer",description:"Y coordinate."}],returns:[{name:"nodeId",$ref:"NodeId",description:"Id of the node at given coordinates."}],description:"Returns node id at given location.",experimental:!0},{name:"getRelayoutBoundary",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node."}],returns:[{name:"nodeId",$ref:"NodeId",description:"Relayout boundary node id for the given node."}],description:"Returns the id of the nearest ancestor that is a relayout boundary.",experimental:!0},{name:"getHighlightObjectForTest",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node to get highlight object for."}],returns:[{name:"highlight",type:"object",description:"Highlight data for the node."}],description:"For testing.",experimental:!0}],events:[{name:"documentUpdated",description:"Fired when <code>Document</code> has been totally updated. Node ids are no longer valid."},{name:"inspectNodeRequested",parameters:[{name:"backendNodeId",$ref:"BackendNodeId",description:"Id of the node to inspect."}],description:"Fired when the node should be inspected. This happens after call to <code>setInspectMode</code>.",experimental:!0},{name:"setChildNodes",parameters:[{name:"parentId",$ref:"NodeId",description:"Parent node id to populate with children."},{name:"nodes",type:"array",items:{$ref:"Node"},description:"Child nodes array."}],description:"Fired when backend wants to provide client with the missing DOM structure. This happens upon most of the calls requesting node ids."},{name:"attributeModified",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node that has changed."},{name:"name",type:"string",description:"Attribute name."},{name:"value",type:"string",description:"Attribute value."}],description:"Fired when <code>Element</code>'s attribute is modified."},{name:"attributeRemoved",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node that has changed."},{name:"name",type:"string",description:"A ttribute name."}],description:"Fired when <code>Element</code>'s attribute is removed."},{name:"inlineStyleInvalidated",parameters:[{name:"nodeIds",type:"array",items:{$ref:"NodeId"},description:"Ids of the nodes for which the inline styles have been invalidated."}],description:"Fired when <code>Element</code>'s inline style is modified via a CSS property modification.",experimental:!0},{name:"characterDataModified",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node that has changed."},{name:"characterData",type:"string",description:"New text value."}],description:"Mirrors <code>DOMCharacterDataModified</code> event."},{name:"childNodeCountUpdated",parameters:[{name:"nodeId",$ref:"NodeId",description:"Id of the node that has changed."},{name:"childNodeCount",type:"integer",description:"New node count."}],description:"Fired when <code>Container</code>'s child node count has changed."},{name:"childNodeInserted",parameters:[{name:"parentNodeId",$ref:"NodeId",description:"Id of the node that has changed."},{name:"previousNodeId",$ref:"NodeId",description:"If of the previous siblint."},{name:"node",$ref:"Node",description:"Inserted node data."}],description:"Mirrors <code>DOMNodeInserted</code> event."},{name:"childNodeRemoved",parameters:[{name:"parentNodeId",$ref:"NodeId",description:"Parent id."},{name:"nodeId",$ref:"NodeId",description:"Id of the node that has been removed."}],description:"Mirrors <code>DOMNodeRemoved</code> event."},{name:"shadowRootPushed",parameters:[{name:"hostId",$ref:"NodeId",description:"Host element id."},{name:"root",$ref:"Node",description:"Shadow root."}],description:"Called when shadow root is pushed into the element.",experimental:!0},{name:"shadowRootPopped",parameters:[{name:"hostId",$ref:"NodeId",description:"Host element id."},{name:"rootId",$ref:"NodeId",description:"Shadow root id."}],description:"Called when shadow root is popped from the element.",experimental:!0},{name:"pseudoElementAdded",parameters:[{name:"parentId",$ref:"NodeId",description:"Pseudo element's parent element id."},{name:"pseudoElement",$ref:"Node",description:"The added pseudo element."}],description:"Called when a pseudo element is added to an element.",experimental:!0},{name:"pseudoElementRemoved",parameters:[{name:"parentId",$ref:"NodeId",description:"Pseudo element's parent element id."},{name:"pseudoElementId",$ref:"NodeId",description:"The removed pseudo element id."}],description:"Called when a pseudo element is removed from an element.",experimental:!0},{name:"distributedNodesUpdated",parameters:[{name:"insertionPointId",$ref:"NodeId",description:"Insertion point where distrubuted nodes were updated."},{name:"distributedNodes",type:"array",items:{$ref:"BackendNode"},description:"Distributed nodes for given insertion point."}],description:"Called when distrubution is changed.",experimental:!0},{name:"nodeHighlightRequested",parameters:[{name:"nodeId",$ref:"NodeId"}],experimental:!0}]},{domain:"CSS",experimental:!0,description:"This domain exposes CSS read/write operations. All CSS objects (stylesheets, rules, and styles) have an associated <code>id</code> used in subsequent operations on the related object. Each object type has a specific <code>id</code> structure, and those are not interchangeable between objects of different kinds. CSS objects can be loaded using the <code>get*ForNode()</code> calls (which accept a DOM node id). A client can also discover all the existing stylesheets with the <code>getAllStyleSheets()</code> method (or keeping track of the <code>styleSheetAdded</code>/<code>styleSheetRemoved</code> events) and subsequently load the required stylesheet contents using the <code>getStyleSheet[Text]()</code> methods.",dependencies:["DOM"],types:[{id:"StyleSheetId",type:"string"},{id:"StyleSheetOrigin",type:"string",enum:["injected","user-agent","inspector","regular"],description:'Stylesheet type: "injected" for stylesheets injected via extension, "user-agent" for user-agent stylesheets, "inspector" for stylesheets created by the inspector (i.e. those holding the "via inspector" rules), "regular" for regular stylesheets.'},{id:"PseudoElementMatches",type:"object",properties:[{name:"pseudoType",$ref:"DOM.PseudoType",description:"Pseudo element type."},{name:"matches",type:"array",items:{$ref:"RuleMatch"},description:"Matches of CSS rules applicable to the pseudo style."}],description:"CSS rule collection for a single pseudo style."},{id:"InheritedStyleEntry",type:"object",properties:[{name:"inlineStyle",$ref:"CSSStyle",optional:!0,description:"The ancestor node's inline style, if any, in the style inheritance chain."},{name:"matchedCSSRules",type:"array",items:{$ref:"RuleMatch"},description:"Matches of CSS rules matching the ancestor node in the style inheritance chain."}],description:"Inherited CSS rule collection from ancestor node."},{id:"RuleMatch",type:"object",properties:[{name:"rule",$ref:"CSSRule",description:"CSS rule in the match."},{name:"matchingSelectors",type:"array",items:{type:"integer"},description:"Matching selector indices in the rule's selectorList selectors (0-based)."}],description:"Match data for a CSS rule."},{id:"Value",type:"object",properties:[{name:"text",type:"string",description:"Value text."},{name:"range",$ref:"SourceRange",optional:!0,description:"Value range in the underlying resource (if available)."}],description:"Data for a simple selector (these are delimited by commas in a selector list)."},{id:"SelectorList",type:"object",properties:[{name:"selectors",type:"array",items:{$ref:"Value"},description:"Selectors in the list."},{name:"text",type:"string",description:"Rule selector text."}],description:"Selector list data."},{id:"CSSStyleSheetHeader",type:"object",properties:[{name:"styleSheetId",$ref:"StyleSheetId",description:"The stylesheet identifier."},{name:"frameId",$ref:"Page.FrameId",description:"Owner frame identifier."},{name:"sourceURL",type:"string",description:"Stylesheet resource URL."},{name:"sourceMapURL",type:"string",optional:!0,description:"URL of source map associated with the stylesheet (if any)."},{name:"origin",$ref:"StyleSheetOrigin",description:"Stylesheet origin."},{name:"title",type:"string",description:"Stylesheet title."},{name:"ownerNode",$ref:"DOM.BackendNodeId",optional:!0,description:"The backend id for the owner node of the stylesheet."},{name:"disabled",type:"boolean",description:"Denotes whether the stylesheet is disabled."},{name:"hasSourceURL",type:"boolean",optional:!0,description:"Whether the sourceURL field value comes from the sourceURL comment."},{name:"isInline",type:"boolean",description:"Whether this stylesheet is created for STYLE tag by parser. This flag is not set for document.written STYLE tags."},{name:"startLine",type:"number",description:"Line offset of the stylesheet within the resource (zero based)."},{name:"startColumn",type:"number",description:"Column offset of the stylesheet within the resource (zero based)."}],description:"CSS stylesheet metainformation."},{id:"CSSRule",type:"object",properties:[{name:"styleSheetId",$ref:"StyleSheetId",optional:!0,description:"The css style sheet identifier (absent for user agent stylesheet and user-specified stylesheet rules) this rule came from."},{name:"selectorList",$ref:"SelectorList",description:"Rule selector data."},{name:"origin",$ref:"StyleSheetOrigin",description:"Parent stylesheet's origin."},{name:"style",$ref:"CSSStyle",description:"Associated style declaration."},{name:"media",type:"array",items:{$ref:"CSSMedia"},optional:!0,description:"Media list array (for rules involving media queries). The array enumerates media queries starting with the innermost one, going outwards."}],description:"CSS rule representation."},{id:"RuleUsage",type:"object",properties:[{name:"styleSheetId",$ref:"StyleSheetId",description:"The css style sheet identifier (absent for user agent stylesheet and user-specified stylesheet rules) this rule came from."},{name:"range",$ref:"SourceRange",description:"Style declaration range in the enclosing stylesheet (if available)."},{name:"used",type:"boolean",description:"Indicates whether the rule was actually used by some element in the page."}],description:"CSS rule usage information.",experimental:!0},{id:"SourceRange",type:"object",properties:[{name:"startLine",type:"integer",description:"Start line of range."},{name:"startColumn",type:"integer",description:"Start column of range (inclusive)."},{name:"endLine",type:"integer",description:"End line of range"},{name:"endColumn",type:"integer",description:"End column of range (exclusive)."}],description:"Text range within a resource. All numbers are zero-based."},{id:"ShorthandEntry",type:"object",properties:[{name:"name",type:"string",description:"Shorthand name."},{name:"value",type:"string",description:"Shorthand value."},{name:"important",type:"boolean",optional:!0,description:'Whether the property has "!important" annotation (implies <code>false</code> if absent).'}]},{id:"CSSComputedStyleProperty",type:"object",properties:[{name:"name",type:"string",description:"Computed style property name."},{name:"value",type:"string",description:"Computed style property value."}]},{id:"CSSStyle",type:"object",properties:[{name:"styleSheetId",$ref:"StyleSheetId",optional:!0,description:"The css style sheet identifier (absent for user agent stylesheet and user-specified stylesheet rules) this rule came from."},{name:"cssProperties",type:"array",items:{$ref:"CSSProperty"},description:"CSS properties in the style."},{name:"shorthandEntries",type:"array",items:{$ref:"ShorthandEntry"},description:"Computed values for all shorthands found in the style."},{name:"cssText",type:"string",optional:!0,description:"Style declaration text (if available)."},{name:"range",$ref:"SourceRange",optional:!0,description:"Style declaration range in the enclosing stylesheet (if available)."}],description:"CSS style representation."},{id:"CSSProperty",type:"object",properties:[{name:"name",type:"string",description:"The property name."},{name:"value",type:"string",description:"The property value."},{name:"important",type:"boolean",optional:!0,description:'Whether the property has "!important" annotation (implies <code>false</code> if absent).'},{name:"implicit",type:"boolean",optional:!0,description:"Whether the property is implicit (implies <code>false</code> if absent)."},{name:"text",type:"string",optional:!0,description:"The full property text as specified in the style."},{name:"parsedOk",type:"boolean",optional:!0,description:"Whether the property is understood by the browser (implies <code>true</code> if absent)."},{name:"disabled",type:"boolean",optional:!0,description:"Whether the property is disabled by the user (present for source-based properties only)."},{name:"range",$ref:"SourceRange",optional:!0,description:"The entire property range in the enclosing style declaration (if available)."}],description:"CSS property declaration data."},{id:"CSSMedia",type:"object",properties:[{name:"text",type:"string",description:"Media query text."},{name:"source",type:"string",enum:["mediaRule","importRule","linkedSheet","inlineSheet"],description:'Source of the media query: "mediaRule" if specified by a @media rule, "importRule" if specified by an @import rule, "linkedSheet" if specified by a "media" attribute in a linked stylesheet\'s LINK tag, "inlineSheet" if specified by a "media" attribute in an inline stylesheet\'s STYLE tag.'},{name:"sourceURL",type:"string",optional:!0,description:"URL of the document containing the media query description."},{name:"range",$ref:"SourceRange",optional:!0,description:"The associated rule (@media or @import) header range in the enclosing stylesheet (if available)."},{name:"styleSheetId",$ref:"StyleSheetId",optional:!0,description:"Identifier of the stylesheet containing this object (if exists)."},{name:"mediaList",type:"array",items:{$ref:"MediaQuery"},optional:!0,experimental:!0,description:"Array of media queries."}],description:"CSS media rule descriptor."},{id:"MediaQuery",type:"object",properties:[{name:"expressions",type:"array",items:{$ref:"MediaQueryExpression"},description:"Array of media query expressions."},{name:"active",type:"boolean",description:"Whether the media query condition is satisfied."}],description:"Media query descriptor.",experimental:!0},{id:"MediaQueryExpression",type:"object",properties:[{name:"value",type:"number",description:"Media query expression value."},{name:"unit",type:"string",description:"Media query expression units."},{name:"feature",type:"string",description:"Media query expression feature."},{name:"valueRange",$ref:"SourceRange",optional:!0,description:"The associated range of the value text in the enclosing stylesheet (if available)."},{name:"computedLength",type:"number",optional:!0,description:"Computed length of media query expression (if applicable)."}],description:"Media query expression descriptor.",experimental:!0},{id:"PlatformFontUsage",type:"object",properties:[{name:"familyName",type:"string",description:"Font's family name reported by platform."},{name:"isCustomFont",type:"boolean",description:"Indicates if the font was downloaded or resolved locally."},{name:"glyphCount",type:"number",description:"Amount of glyphs that were rendered with this font."}],description:"Information about amount of glyphs that were rendered with given font.",experimental:!0},{id:"CSSKeyframesRule",type:"object",properties:[{name:"animationName",$ref:"Value",description:"Animation name."},{name:"keyframes",type:"array",items:{$ref:"CSSKeyframeRule"},description:"List of keyframes."}],description:"CSS keyframes rule representation."},{id:"CSSKeyframeRule",type:"object",properties:[{name:"styleSheetId",$ref:"StyleSheetId",optional:!0,description:"The css style sheet identifier (absent for user agent stylesheet and user-specified stylesheet rules) this rule came from."},{name:"origin",$ref:"StyleSheetOrigin",description:"Parent stylesheet's origin."},{name:"keyText",$ref:"Value",description:"Associated key text."},{name:"style",$ref:"CSSStyle",description:"Associated style declaration."}],description:"CSS keyframe rule representation."},{id:"StyleDeclarationEdit",type:"object",properties:[{name:"styleSheetId",$ref:"StyleSheetId",description:"The css style sheet identifier."},{name:"range",$ref:"SourceRange",description:"The range of the style text in the enclosing stylesheet."},{name:"text",type:"string",description:"New style text."}],description:"A descriptor of operation to mutate style declaration text."},{id:"InlineTextBox",type:"object",properties:[{name:"boundingBox",$ref:"DOM.Rect",description:"The absolute position bounding box."},{name:"startCharacterIndex",type:"integer",description:"The starting index in characters, for this post layout textbox substring."},{name:"numCharacters",type:"integer",description:"The number of characters in this post layout textbox substring."}],description:"Details of post layout rendered text positions. The exact layout should not be regarded as stable and may change between versions.",experimental:!0},{id:"LayoutTreeNode",type:"object",properties:[{name:"nodeId",$ref:"DOM.NodeId",description:"The id of the related DOM node matching one from DOM.GetDocument."},{name:"boundingBox",$ref:"DOM.Rect",description:"The absolute position bounding box."},{name:"layoutText",type:"string",optional:!0,description:"Contents of the LayoutText if any"},{name:"inlineTextNodes",type:"array",optional:!0,items:{$ref:"InlineTextBox"},description:"The post layout inline text nodes, if any."},{name:"styleIndex",type:"integer",optional:!0,description:"Index into the computedStyles array returned by getLayoutTreeAndStyles."}],description:"Details of an element in the DOM tree with a LayoutObject.",experimental:!0},{id:"ComputedStyle",type:"object",properties:[{name:"properties",type:"array",items:{$ref:"CSSComputedStyleProperty"}}],description:"A subset of the full ComputedStyle as defined by the request whitelist.",experimental:!0}],commands:[{name:"enable",description:"Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been enabled until the result of this command is received."},{name:"disable",description:"Disables the CSS agent for the given page."},{name:"getMatchedStylesForNode",parameters:[{name:"nodeId",$ref:"DOM.NodeId"}],returns:[{name:"inlineStyle",$ref:"CSSStyle",optional:!0,description:"Inline style for the specified DOM node."},{name:"attributesStyle",$ref:"CSSStyle",optional:!0,description:'Attribute-defined element style (e.g. resulting from "width=20 height=100%").'},{name:"matchedCSSRules",type:"array",items:{$ref:"RuleMatch"},optional:!0,description:"CSS rules matching this node, from all applicable stylesheets."},{name:"pseudoElements",type:"array",items:{$ref:"PseudoElementMatches"},optional:!0,description:"Pseudo style matches for this node."},{name:"inherited",type:"array",items:{$ref:"InheritedStyleEntry"},optional:!0,description:"A chain of inherited styles (from the immediate node parent up to the DOM tree root)."},{name:"cssKeyframesRules",type:"array",items:{$ref:"CSSKeyframesRule"},optional:!0,description:"A list of CSS keyframed animations matching this node."}],description:"Returns requested styles for a DOM node identified by <code>nodeId</code>."},{name:"getInlineStylesForNode",parameters:[{name:"nodeId",$ref:"DOM.NodeId"}],returns:[{name:"inlineStyle",$ref:"CSSStyle",optional:!0,description:"Inline style for the specified DOM node."},{name:"attributesStyle",$ref:"CSSStyle",optional:!0,description:'Attribute-defined element style (e.g. resulting from "width=20 height=100%").'}],description:'Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM attributes) for a DOM node identified by <code>nodeId</code>.'},{name:"getComputedStyleForNode",parameters:[{name:"nodeId",$ref:"DOM.NodeId"}],returns:[{name:"computedStyle",type:"array",items:{$ref:"CSSComputedStyleProperty"},description:"Computed style for the specified DOM node."}],description:"Returns the computed style for a DOM node identified by <code>nodeId</code>."},{name:"getPlatformFontsForNode",parameters:[{name:"nodeId",$ref:"DOM.NodeId"}],returns:[{name:"fonts",type:"array",items:{$ref:"PlatformFontUsage"},description:"Usage statistics for every employed platform font."}],description:"Requests information about platform fonts which we used to render child TextNodes in the given node.",experimental:!0},{name:"getStyleSheetText",parameters:[{name:"styleSheetId",$ref:"StyleSheetId"}],returns:[{name:"text",type:"string",description:"The stylesheet text."}],description:"Returns the current textual content and the URL for a stylesheet."},{name:"collectClassNames",parameters:[{name:"styleSheetId",$ref:"StyleSheetId"}],returns:[{name:"classNames",type:"array",items:{type:"string"},description:"Class name list."}],description:"Returns all class names from specified stylesheet.",experimental:!0},{name:"setStyleSheetText",parameters:[{name:"styleSheetId",$ref:"StyleSheetId"},{name:"text",type:"string"}],returns:[{name:"sourceMapURL",type:"string",optional:!0,description:"URL of source map associated with script (if any)."}],description:"Sets the new stylesheet text."},{name:"setRuleSelector",parameters:[{name:"styleSheetId",$ref:"StyleSheetId"},{name:"range",$ref:"SourceRange"},{name:"selector",type:"string"}],returns:[{name:"selectorList",$ref:"SelectorList",description:"The resulting selector list after modification."}],description:"Modifies the rule selector."},{name:"setKeyframeKey",parameters:[{name:"styleSheetId",$ref:"StyleSheetId"},{name:"range",$ref:"SourceRange"},{name:"keyText",type:"string"}],returns:[{name:"keyText",$ref:"Value",description:"The resulting key text after modification."}],description:"Modifies the keyframe rule key text."},{name:"setStyleTexts",parameters:[{name:"edits",type:"array",items:{$ref:"StyleDeclarationEdit"}}],returns:[{name:"styles",type:"array",items:{$ref:"CSSStyle"},description:"The resulting styles after modification."}],description:"Applies specified style edits one after another in the given order."},{name:"setMediaText",parameters:[{name:"styleSheetId",$ref:"StyleSheetId"},{name:"range",$ref:"SourceRange"},{name:"text",type:"string"}],returns:[{name:"media",$ref:"CSSMedia",description:"The resulting CSS media rule after modification."}],description:"Modifies the rule selector."},{name:"createStyleSheet",parameters:[{name:"frameId",$ref:"Page.FrameId",description:'Identifier of the frame where "via-inspector" stylesheet should be created.'}],returns:[{name:"styleSheetId",$ref:"StyleSheetId",description:'Identifier of the created "via-inspector" stylesheet.'}],description:'Creates a new special "via-inspector" stylesheet in the frame with given <code>frameId</code>.'},{name:"addRule",parameters:[{name:"styleSheetId",$ref:"StyleSheetId",description:"The css style sheet identifier where a new rule should be inserted."},{name:"ruleText",type:"string",description:"The text of a new rule."},{name:"location",$ref:"SourceRange",description:"Text position of a new rule in the target style sheet."}],returns:[{name:"rule",$ref:"CSSRule",description:"The newly created rule."}],description:"Inserts a new rule with the given <code>ruleText</code> in a stylesheet with given <code>styleSheetId</code>, at the position specified by <code>location</code>."},{name:"forcePseudoState",parameters:[{name:"nodeId",$ref:"DOM.NodeId",description:"The element id for which to force the pseudo state."},{name:"forcedPseudoClasses",type:"array",items:{type:"string",enum:["active","focus","hover","visited"]},description:"Element pseudo classes to force when computing the element's style."}],description:"Ensures that the given node will have specified pseudo-classes whenever its style is computed by the browser."},{name:"getMediaQueries",returns:[{name:"medias",type:"array",items:{$ref:"CSSMedia"}}],description:"Returns all media queries parsed by the rendering engine.",experimental:!0},{name:"setEffectivePropertyValueForNode",parameters:[{name:"nodeId",$ref:"DOM.NodeId",description:"The element id for which to set property."},{name:"propertyName",type:"string"},{name:"value",type:"string"}],description:"Find a rule with the given active property for the given node and set the new value for this property",experimental:!0},{name:"getBackgroundColors",parameters:[{name:"nodeId",$ref:"DOM.NodeId",description:"Id of the node to get background colors for."}],returns:[{name:"backgroundColors",type:"array",items:{type:"string"},description:"The range of background colors behind this element, if it contains any visible text. If no visible text is present, this will be undefined. In the case of a flat background color, this will consist of simply that color. In the case of a gradient, this will consist of each of the color stops. For anything more complicated, this will be an empty array. Images will be ignored (as if the image had failed to load).",
	optional:!0}],experimental:!0},{name:"getLayoutTreeAndStyles",parameters:[{name:"computedStyleWhitelist",type:"array",items:{type:"string"},description:"Whitelist of computed styles to return."}],returns:[{name:"layoutTreeNodes",type:"array",items:{$ref:"LayoutTreeNode"}},{name:"computedStyles",type:"array",items:{$ref:"ComputedStyle"}}],description:"For the main document and any content documents, return the LayoutTreeNodes and a whitelisted subset of the computed style. It only returns pushed nodes, on way to pull all nodes is to call DOM.getDocument with a depth of -1.",experimental:!0},{name:"startRuleUsageTracking",description:"Enables the selector recording.",experimental:!0},{name:"stopRuleUsageTracking",returns:[{name:"ruleUsage",type:"array",items:{$ref:"RuleUsage"}}],description:"The list of rules with an indication of whether these were used",experimental:!0}],events:[{name:"mediaQueryResultChanged",description:"Fires whenever a MediaQuery result changes (for example, after a browser window has been resized.) The current implementation considers only viewport-dependent media features."},{name:"fontsUpdated",description:"Fires whenever a web font gets loaded."},{name:"styleSheetChanged",parameters:[{name:"styleSheetId",$ref:"StyleSheetId"}],description:"Fired whenever a stylesheet is changed as a result of the client operation."},{name:"styleSheetAdded",parameters:[{name:"header",$ref:"CSSStyleSheetHeader",description:"Added stylesheet metainfo."}],description:"Fired whenever an active document stylesheet is added."},{name:"styleSheetRemoved",parameters:[{name:"styleSheetId",$ref:"StyleSheetId",description:"Identifier of the removed stylesheet."}],description:"Fired whenever an active document stylesheet is removed."}]},{domain:"IO",description:"Input/Output operations for streams produced by DevTools.",experimental:!0,types:[{id:"StreamHandle",type:"string"}],commands:[{name:"read",description:"Read a chunk of the stream",parameters:[{name:"handle",$ref:"StreamHandle",description:"Handle of the stream to read."},{name:"offset",type:"integer",optional:!0,description:"Seek to the specified offset before reading (if not specificed, proceed with offset following the last read)."},{name:"size",type:"integer",optional:!0,description:"Maximum number of bytes to read (left upon the agent discretion if not specified)."}],returns:[{name:"data",type:"string",description:"Data that were read."},{name:"eof",type:"boolean",description:"Set if the end-of-file condition occured while reading."}]},{name:"close",description:"Close the stream, discard any temporary backing storage.",parameters:[{name:"handle",$ref:"StreamHandle",description:"Handle of the stream to close."}]}]},{domain:"DOMDebugger",description:"DOM debugging allows setting breakpoints on particular DOM operations and events. JavaScript execution will stop on these operations as if there was a regular breakpoint set.",dependencies:["DOM","Debugger"],types:[{id:"DOMBreakpointType",type:"string",enum:["subtree-modified","attribute-modified","node-removed"],description:"DOM breakpoint type."},{id:"EventListener",type:"object",description:"Object event listener.",properties:[{name:"type",type:"string",description:"<code>EventListener</code>'s type."},{name:"useCapture",type:"boolean",description:"<code>EventListener</code>'s useCapture."},{name:"passive",type:"boolean",description:"<code>EventListener</code>'s passive flag."},{name:"once",type:"boolean",description:"<code>EventListener</code>'s once flag."},{name:"scriptId",$ref:"Runtime.ScriptId",description:"Script id of the handler code."},{name:"lineNumber",type:"integer",description:"Line number in the script (0-based)."},{name:"columnNumber",type:"integer",description:"Column number in the script (0-based)."},{name:"handler",$ref:"Runtime.RemoteObject",optional:!0,description:"Event handler function value."},{name:"originalHandler",$ref:"Runtime.RemoteObject",optional:!0,description:"Event original handler function value."},{name:"removeFunction",$ref:"Runtime.RemoteObject",optional:!0,description:"Event listener remove function."}],experimental:!0}],commands:[{name:"setDOMBreakpoint",parameters:[{name:"nodeId",$ref:"DOM.NodeId",description:"Identifier of the node to set breakpoint on."},{name:"type",$ref:"DOMBreakpointType",description:"Type of the operation to stop upon."}],description:"Sets breakpoint on particular operation with DOM."},{name:"removeDOMBreakpoint",parameters:[{name:"nodeId",$ref:"DOM.NodeId",description:"Identifier of the node to remove breakpoint from."},{name:"type",$ref:"DOMBreakpointType",description:"Type of the breakpoint to remove."}],description:"Removes DOM breakpoint that was set using <code>setDOMBreakpoint</code>."},{name:"setEventListenerBreakpoint",parameters:[{name:"eventName",type:"string",description:"DOM Event name to stop on (any DOM event will do)."},{name:"targetName",type:"string",optional:!0,description:'EventTarget interface name to stop on. If equal to <code>"*"</code> or not provided, will stop on any EventTarget.',experimental:!0}],description:"Sets breakpoint on particular DOM event."},{name:"removeEventListenerBreakpoint",parameters:[{name:"eventName",type:"string",description:"Event name."},{name:"targetName",type:"string",optional:!0,description:"EventTarget interface name.",experimental:!0}],description:"Removes breakpoint on particular DOM event."},{name:"setInstrumentationBreakpoint",parameters:[{name:"eventName",type:"string",description:"Instrumentation name to stop on."}],description:"Sets breakpoint on particular native event.",experimental:!0},{name:"removeInstrumentationBreakpoint",parameters:[{name:"eventName",type:"string",description:"Instrumentation name to stop on."}],description:"Removes breakpoint on particular native event.",experimental:!0},{name:"setXHRBreakpoint",parameters:[{name:"url",type:"string",description:"Resource URL substring. All XHRs having this substring in the URL will get stopped upon."}],description:"Sets breakpoint on XMLHttpRequest."},{name:"removeXHRBreakpoint",parameters:[{name:"url",type:"string",description:"Resource URL substring."}],description:"Removes breakpoint from XMLHttpRequest."},{name:"getEventListeners",experimental:!0,parameters:[{name:"objectId",$ref:"Runtime.RemoteObjectId",description:"Identifier of the object to return listeners for."}],returns:[{name:"listeners",type:"array",items:{$ref:"EventListener"},description:"Array of relevant listeners."}],description:"Returns event listeners of the given object."}]},{domain:"Target",description:"Supports additional targets discovery and allows to attach to them.",experimental:!0,types:[{id:"TargetID",type:"string"},{id:"BrowserContextID",type:"string"},{id:"TargetInfo",type:"object",properties:[{name:"targetId",$ref:"TargetID"},{name:"type",type:"string"},{name:"title",type:"string"},{name:"url",type:"string"}]},{id:"RemoteLocation",type:"object",properties:[{name:"host",type:"string"},{name:"port",type:"integer"}]}],commands:[{name:"setDiscoverTargets",description:"Controls whether to discover available targets and notify via <code>targetCreated/targetDestroyed</code> events.",parameters:[{name:"discover",type:"boolean",description:"Whether to discover available targets."}]},{name:"setAutoAttach",description:"Controls whether to automatically attach to new targets which are considered to be related to this one. When turned on, attaches to all existing related targets as well. When turned off, automatically detaches from all currently attached targets.",parameters:[{name:"autoAttach",type:"boolean",description:"Whether to auto-attach to related targets."},{name:"waitForDebuggerOnStart",type:"boolean",description:"Whether to pause new targets when attaching to them. Use <code>Runtime.runIfWaitingForDebugger</code> to run paused targets."}]},{name:"setAttachToFrames",parameters:[{name:"value",type:"boolean",description:"Whether to attach to frames."}]},{name:"setRemoteLocations",description:"Enables target discovery for the specified locations, when <code>setDiscoverTargets</code> was set to <code>true</code>.",parameters:[{name:"locations",type:"array",items:{$ref:"RemoteLocation"},description:"List of remote locations."}]},{name:"sendMessageToTarget",description:"Sends protocol message to the target with given id.",parameters:[{name:"targetId",type:"string"},{name:"message",type:"string"}]},{name:"getTargetInfo",description:"Returns information about a target.",parameters:[{name:"targetId",$ref:"TargetID"}],returns:[{name:"targetInfo",$ref:"TargetInfo"}]},{name:"activateTarget",description:"Activates (focuses) the target.",parameters:[{name:"targetId",$ref:"TargetID"}]},{name:"closeTarget",description:"Closes the target. If the target is a page that gets closed too.",parameters:[{name:"targetId",$ref:"TargetID"}],returns:[{name:"success",type:"boolean"}]},{name:"attachToTarget",description:"Attaches to the target with given id.",parameters:[{name:"targetId",$ref:"TargetID"}],returns:[{name:"success",type:"boolean",description:"Whether attach succeeded."}]},{name:"detachFromTarget",description:"Detaches from the target with given id.",parameters:[{name:"targetId",$ref:"TargetID"}]},{name:"createBrowserContext",description:"Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than one.",returns:[{name:"browserContextId",$ref:"BrowserContextID",description:"The id of the context created."}]},{name:"disposeBrowserContext",description:"Deletes a BrowserContext, will fail of any open page uses it.",parameters:[{name:"browserContextId",$ref:"BrowserContextID"}],returns:[{name:"success",type:"boolean"}]},{name:"createTarget",description:"Creates a new page.",parameters:[{name:"url",type:"string",description:"The initial URL the page will be navigated to."},{name:"width",type:"integer",description:"Frame width in DIP (headless chrome only).",optional:!0},{name:"height",type:"integer",description:"Frame height in DIP (headless chrome only).",optional:!0},{name:"browserContextId",$ref:"BrowserContextID",description:"The browser context to create the page in (headless chrome only).",optional:!0}],returns:[{name:"targetId",$ref:"TargetID",description:"The id of the page opened."}]},{name:"getTargets",description:"Retrieves a list of available targets.",returns:[{name:"targetInfos",type:"array",items:{$ref:"TargetInfo"},description:"The list of targets."}]}],events:[{name:"targetCreated",description:"Issued when a possible inspection target is created.",parameters:[{name:"targetInfo",$ref:"TargetInfo"}]},{name:"targetDestroyed",description:"Issued when a target is destroyed.",parameters:[{name:"targetId",$ref:"TargetID"}]},{name:"attachedToTarget",description:"Issued when attached to target because of auto-attach or <code>attachToTarget</code> command.",parameters:[{name:"targetInfo",$ref:"TargetInfo"},{name:"waitingForDebugger",type:"boolean"}]},{name:"detachedFromTarget",description:"Issued when detached from target for any reason (including <code>detachFromTarget</code> command).",parameters:[{name:"targetId",$ref:"TargetID"}]},{name:"receivedMessageFromTarget",description:"Notifies about new protocol message from attached target.",parameters:[{name:"targetId",$ref:"TargetID"},{name:"message",type:"string"}]}]},{domain:"ServiceWorker",experimental:!0,types:[{id:"ServiceWorkerRegistration",type:"object",description:"ServiceWorker registration.",properties:[{name:"registrationId",type:"string"},{name:"scopeURL",type:"string"},{name:"isDeleted",type:"boolean"}]},{id:"ServiceWorkerVersionRunningStatus",type:"string",enum:["stopped","starting","running","stopping"]},{id:"ServiceWorkerVersionStatus",type:"string",enum:["new","installing","installed","activating","activated","redundant"]},{id:"ServiceWorkerVersion",type:"object",description:"ServiceWorker version.",properties:[{name:"versionId",type:"string"},{name:"registrationId",type:"string"},{name:"scriptURL",type:"string"},{name:"runningStatus",$ref:"ServiceWorkerVersionRunningStatus"},{name:"status",$ref:"ServiceWorkerVersionStatus"},{name:"scriptLastModified",type:"number",optional:!0,description:"The Last-Modified header value of the main script."},{name:"scriptResponseTime",type:"number",optional:!0,description:"The time at which the response headers of the main script were received from the server.  For cached script it is the last time the cache entry was validated."},{name:"controlledClients",type:"array",optional:!0,items:{$ref:"Target.TargetID"}},{name:"targetId",$ref:"Target.TargetID",optional:!0}]},{id:"ServiceWorkerErrorMessage",type:"object",description:"ServiceWorker error message.",properties:[{name:"errorMessage",type:"string"},{name:"registrationId",type:"string"},{name:"versionId",type:"string"},{name:"sourceURL",type:"string"},{name:"lineNumber",type:"integer"},{name:"columnNumber",type:"integer"}]}],commands:[{name:"enable"},{name:"disable"},{name:"unregister",parameters:[{name:"scopeURL",type:"string"}]},{name:"updateRegistration",parameters:[{name:"scopeURL",type:"string"}]},{name:"startWorker",parameters:[{name:"scopeURL",type:"string"}]},{name:"skipWaiting",parameters:[{name:"scopeURL",type:"string"}]},{name:"stopWorker",parameters:[{name:"versionId",type:"string"}]},{name:"inspectWorker",parameters:[{name:"versionId",type:"string"}]},{name:"setForceUpdateOnPageLoad",parameters:[{name:"forceUpdateOnPageLoad",type:"boolean"}]},{name:"deliverPushMessage",parameters:[{name:"origin",type:"string"},{name:"registrationId",type:"string"},{name:"data",type:"string"}]},{name:"dispatchSyncEvent",parameters:[{name:"origin",type:"string"},{name:"registrationId",type:"string"},{name:"tag",type:"string"},{name:"lastChance",type:"boolean"}]}],events:[{name:"workerRegistrationUpdated",parameters:[{name:"registrations",type:"array",items:{$ref:"ServiceWorkerRegistration"}}]},{name:"workerVersionUpdated",parameters:[{name:"versions",type:"array",items:{$ref:"ServiceWorkerVersion"}}]},{name:"workerErrorReported",parameters:[{name:"errorMessage",$ref:"ServiceWorkerErrorMessage"}]}]},{domain:"Input",types:[{id:"TouchPoint",type:"object",experimental:!0,properties:[{name:"state",type:"string",enum:["touchPressed","touchReleased","touchMoved","touchStationary","touchCancelled"],description:"State of the touch point."},{name:"x",type:"integer",description:"X coordinate of the event relative to the main frame's viewport."},{name:"y",type:"integer",description:"Y coordinate of the event relative to the main frame's viewport. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport."},{name:"radiusX",type:"integer",optional:!0,description:"X radius of the touch area (default: 1)."},{name:"radiusY",type:"integer",optional:!0,description:"Y radius of the touch area (default: 1)."},{name:"rotationAngle",type:"number",optional:!0,description:"Rotation angle (default: 0.0)."},{name:"force",type:"number",optional:!0,description:"Force (default: 1.0)."},{name:"id",type:"number",optional:!0,description:"Identifier used to track touch sources between events, must be unique within an event."}]},{id:"GestureSourceType",type:"string",experimental:!0,enum:["default","touch","mouse"]}],commands:[{name:"dispatchKeyEvent",parameters:[{name:"type",type:"string",enum:["keyDown","keyUp","rawKeyDown","char"],description:"Type of the key event."},{name:"modifiers",type:"integer",optional:!0,description:"Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0)."},{name:"timestamp",type:"number",optional:!0,description:"Time at which the event occurred. Measured in UTC time in seconds since January 1, 1970 (default: current time)."},{name:"text",type:"string",optional:!0,description:'Text as generated by processing a virtual key code with a keyboard layout. Not needed for for <code>keyUp</code> and <code>rawKeyDown</code> events (default: "")'},{name:"unmodifiedText",type:"string",optional:!0,description:'Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").'},{name:"keyIdentifier",type:"string",optional:!0,description:"Unique key identifier (e.g., 'U+0041') (default: \"\")."},{name:"code",type:"string",optional:!0,description:"Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: \"\")."},{name:"key",type:"string",optional:!0,description:"Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: \"\")."},{name:"windowsVirtualKeyCode",type:"integer",optional:!0,description:"Windows virtual key code (default: 0)."},{name:"nativeVirtualKeyCode",type:"integer",optional:!0,description:"Native virtual key code (default: 0)."},{name:"autoRepeat",type:"boolean",optional:!0,description:"Whether the event was generated from auto repeat (default: false)."},{name:"isKeypad",type:"boolean",optional:!0,description:"Whether the event was generated from the keypad (default: false)."},{name:"isSystemKey",type:"boolean",optional:!0,description:"Whether the event was a system key event (default: false)."}],description:"Dispatches a key event to the page."},{name:"dispatchMouseEvent",parameters:[{name:"type",type:"string",enum:["mousePressed","mouseReleased","mouseMoved"],description:"Type of the mouse event."},{name:"x",type:"integer",description:"X coordinate of the event relative to the main frame's viewport."},{name:"y",type:"integer",description:"Y coordinate of the event relative to the main frame's viewport. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport."},{name:"modifiers",type:"integer",optional:!0,description:"Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0)."},{name:"timestamp",type:"number",optional:!0,description:"Time at which the event occurred. Measured in UTC time in seconds since January 1, 1970 (default: current time)."},{name:"button",type:"string",enum:["none","left","middle","right"],optional:!0,description:'Mouse button (default: "none").'},{name:"clickCount",type:"integer",optional:!0,description:"Number of times the mouse button was clicked (default: 0)."}],description:"Dispatches a mouse event to the page."},{name:"dispatchTouchEvent",experimental:!0,parameters:[{name:"type",type:"string",enum:["touchStart","touchEnd","touchMove"],description:"Type of the touch event."},{name:"touchPoints",type:"array",items:{$ref:"TouchPoint"},description:"Touch points."},{name:"modifiers",type:"integer",optional:!0,description:"Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0)."},{name:"timestamp",type:"number",optional:!0,description:"Time at which the event occurred. Measured in UTC time in seconds since January 1, 1970 (default: current time)."}],description:"Dispatches a touch event to the page."},{name:"emulateTouchFromMouseEvent",experimental:!0,parameters:[{name:"type",type:"string",enum:["mousePressed","mouseReleased","mouseMoved","mouseWheel"],description:"Type of the mouse event."},{name:"x",type:"integer",description:"X coordinate of the mouse pointer in DIP."},{name:"y",type:"integer",description:"Y coordinate of the mouse pointer in DIP."},{name:"timestamp",type:"number",description:"Time at which the event occurred. Measured in UTC time in seconds since January 1, 1970."},{name:"button",type:"string",enum:["none","left","middle","right"],description:"Mouse button."},{name:"deltaX",type:"number",optional:!0,description:"X delta in DIP for mouse wheel event (default: 0)."},{name:"deltaY",type:"number",optional:!0,description:"Y delta in DIP for mouse wheel event (default: 0)."},{name:"modifiers",type:"integer",optional:!0,description:"Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0)."},{name:"clickCount",type:"integer",optional:!0,description:"Number of times the mouse button was clicked (default: 0)."}],description:"Emulates touch event from the mouse event parameters."},{name:"synthesizePinchGesture",parameters:[{name:"x",type:"integer",description:"X coordinate of the start of the gesture in CSS pixels."},{name:"y",type:"integer",description:"Y coordinate of the start of the gesture in CSS pixels."},{name:"scaleFactor",type:"number",description:"Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out)."},{name:"relativeSpeed",type:"integer",optional:!0,description:"Relative pointer speed in pixels per second (default: 800)."},{name:"gestureSourceType",$ref:"GestureSourceType",optional:!0,description:"Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type)."}],description:"Synthesizes a pinch gesture over a time period by issuing appropriate touch events.",experimental:!0},{name:"synthesizeScrollGesture",parameters:[{name:"x",type:"integer",description:"X coordinate of the start of the gesture in CSS pixels."},{name:"y",type:"integer",description:"Y coordinate of the start of the gesture in CSS pixels."},{name:"xDistance",type:"integer",optional:!0,description:"The distance to scroll along the X axis (positive to scroll left)."},{name:"yDistance",type:"integer",optional:!0,description:"The distance to scroll along the Y axis (positive to scroll up)."},{name:"xOverscroll",type:"integer",optional:!0,description:"The number of additional pixels to scroll back along the X axis, in addition to the given distance."},{name:"yOverscroll",type:"integer",optional:!0,description:"The number of additional pixels to scroll back along the Y axis, in addition to the given distance."},{name:"preventFling",type:"boolean",optional:!0,description:"Prevent fling (default: true)."},{name:"speed",type:"integer",optional:!0,description:"Swipe speed in pixels per second (default: 800)."},{name:"gestureSourceType",$ref:"GestureSourceType",optional:!0,description:"Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type)."},{name:"repeatCount",type:"integer",optional:!0,description:"The number of times to repeat the gesture (default: 0)."},{name:"repeatDelayMs",type:"integer",optional:!0,description:"The number of milliseconds delay between each repeat. (default: 250)."},{name:"interactionMarkerName",type:"string",optional:!0,description:'The name of the interaction markers to generate, if not empty (default: "").'}],description:"Synthesizes a scroll gesture over a time period by issuing appropriate touch events.",experimental:!0},{name:"synthesizeTapGesture",parameters:[{name:"x",type:"integer",description:"X coordinate of the start of the gesture in CSS pixels."},{name:"y",type:"integer",description:"Y coordinate of the start of the gesture in CSS pixels."},{name:"duration",type:"integer",optional:!0,description:"Duration between touchdown and touchup events in ms (default: 50)."},{name:"tapCount",type:"integer",optional:!0,description:"Number of times to perform the tap (e.g. 2 for double tap, default: 1)."},{name:"gestureSourceType",$ref:"GestureSourceType",optional:!0,description:"Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type)."}],description:"Synthesizes a tap gesture over a time period by issuing appropriate touch events.",experimental:!0}],events:[]},{domain:"LayerTree",experimental:!0,dependencies:["DOM"],types:[{id:"LayerId",type:"string",description:"Unique Layer identifier."},{id:"SnapshotId",type:"string",description:"Unique snapshot identifier."},{id:"ScrollRect",type:"object",description:"Rectangle where scrolling happens on the main thread.",properties:[{name:"rect",$ref:"DOM.Rect",description:"Rectangle itself."},{name:"type",type:"string",enum:["RepaintsOnScroll","TouchEventHandler","WheelEventHandler"],description:"Reason for rectangle to force scrolling on the main thread"}]},{id:"PictureTile",type:"object",description:"Serialized fragment of layer picture along with its offset within the layer.",properties:[{name:"x",type:"number",description:"Offset from owning layer left boundary"},{name:"y",type:"number",description:"Offset from owning layer top boundary"},{name:"picture",type:"string",description:"Base64-encoded snapshot data."}]},{id:"Layer",type:"object",description:"Information about a compositing layer.",properties:[{name:"layerId",$ref:"LayerId",description:"The unique id for this layer."},{name:"parentLayerId",$ref:"LayerId",optional:!0,description:"The id of parent (not present for root)."},{name:"backendNodeId",$ref:"DOM.BackendNodeId",optional:!0,description:"The backend id for the node associated with this layer."},{name:"offsetX",type:"number",description:"Offset from parent layer, X coordinate."},{name:"offsetY",type:"number",description:"Offset from parent layer, Y coordinate."},{name:"width",type:"number",description:"Layer width."},{name:"height",type:"number",description:"Layer height."},{name:"transform",type:"array",items:{type:"number"},minItems:16,maxItems:16,optional:!0,description:"Transformation matrix for layer, default is identity matrix"},{name:"anchorX",type:"number",optional:!0,description:"Transform anchor point X, absent if no transform specified"},{name:"anchorY",type:"number",optional:!0,description:"Transform anchor point Y, absent if no transform specified"},{name:"anchorZ",type:"number",optional:!0,description:"Transform anchor point Z, absent if no transform specified"},{name:"paintCount",type:"integer",description:"Indicates how many time this layer has painted."},{name:"drawsContent",type:"boolean",description:"Indicates whether this layer hosts any content, rather than being used for transform/scrolling purposes only."},{name:"invisible",type:"boolean",optional:!0,description:"Set if layer is not visible."},{name:"scrollRects",type:"array",items:{$ref:"ScrollRect"},optional:!0,description:"Rectangles scrolling on main thread only."}]},{id:"PaintProfile",type:"array",description:"Array of timings, one per paint step.",items:{type:"number",description:"A time in seconds since the end of previous step (for the first step, time since painting started)"}}],commands:[{name:"enable",description:"Enables compositing tree inspection."},{name:"disable",description:"Disables compositing tree inspection."},{name:"compositingReasons",parameters:[{name:"layerId",$ref:"LayerId",description:"The id of the layer for which we want to get the reasons it was composited."}],description:"Provides the reasons why the given layer was composited.",returns:[{name:"compositingReasons",type:"array",items:{type:"string"},description:"A list of strings specifying reasons for the given layer to become composited."}]},{name:"makeSnapshot",parameters:[{name:"layerId",$ref:"LayerId",description:"The id of the layer."}],description:"Returns the layer snapshot identifier.",returns:[{name:"snapshotId",$ref:"SnapshotId",description:"The id of the layer snapshot."}]},{name:"loadSnapshot",parameters:[{name:"tiles",type:"array",items:{$ref:"PictureTile"},minItems:1,description:"An array of tiles composing the snapshot."}],description:"Returns the snapshot identifier.",returns:[{name:"snapshotId",$ref:"SnapshotId",description:"The id of the snapshot."}]},{name:"releaseSnapshot",parameters:[{name:"snapshotId",$ref:"SnapshotId",description:"The id of the layer snapshot."}],description:"Releases layer snapshot captured by the back-end."},{name:"profileSnapshot",parameters:[{name:"snapshotId",$ref:"SnapshotId",description:"The id of the layer snapshot."},{name:"minRepeatCount",type:"integer",optional:!0,description:"The maximum number of times to replay the snapshot (1, if not specified)."},{name:"minDuration",type:"number",optional:!0,description:"The minimum duration (in seconds) to replay the snapshot."},{name:"clipRect",$ref:"DOM.Rect",optional:!0,description:"The clip rectangle to apply when replaying the snapshot."}],returns:[{name:"timings",type:"array",items:{$ref:"PaintProfile"},description:"The array of paint profiles, one per run."}]},{name:"replaySnapshot",parameters:[{name:"snapshotId",$ref:"SnapshotId",description:"The id of the layer snapshot."},{name:"fromStep",type:"integer",optional:!0,description:"The first step to replay from (replay from the very start if not specified)."},{name:"toStep",type:"integer",optional:!0,description:"The last step to replay to (replay till the end if not specified)."},{name:"scale",type:"number",optional:!0,description:"The scale to apply while replaying (defaults to 1)."}],description:"Replays the layer snapshot and returns the resulting bitmap.",returns:[{name:"dataURL",type:"string",description:"A data: URL for resulting image."}]},{name:"snapshotCommandLog",parameters:[{name:"snapshotId",$ref:"SnapshotId",description:"The id of the layer snapshot."}],description:"Replays the layer snapshot and returns canvas log.",returns:[{name:"commandLog",type:"array",items:{type:"object"},description:"The array of canvas function calls."}]}],events:[{name:"layerTreeDidChange",parameters:[{name:"layers",type:"array",items:{$ref:"Layer"},optional:!0,description:"Layer tree, absent if not in the comspositing mode."}]},{name:"layerPainted",parameters:[{name:"layerId",$ref:"LayerId",description:"The id of the painted layer."},{name:"clip",$ref:"DOM.Rect",description:"Clip rectangle."}]}]},{domain:"DeviceOrientation",experimental:!0,commands:[{name:"setDeviceOrientationOverride",description:"Overrides the Device Orientation.",parameters:[{name:"alpha",type:"number",description:"Mock alpha"},{name:"beta",type:"number",description:"Mock beta"},{name:"gamma",type:"number",description:"Mock gamma"}]},{name:"clearDeviceOrientationOverride",description:"Clears the overridden Device Orientation."}]},{domain:"Tracing",dependencies:["IO"],experimental:!0,types:[{id:"MemoryDumpConfig",type:"object",description:'Configuration for memory dump. Used only when "memory-infra" category is enabled.'},{id:"TraceConfig",type:"object",properties:[{name:"recordMode",type:"string",optional:!0,enum:["recordUntilFull","recordContinuously","recordAsMuchAsPossible","echoToConsole"],description:"Controls how the trace buffer stores data."},{name:"enableSampling",type:"boolean",optional:!0,description:"Turns on JavaScript stack sampling."},{name:"enableSystrace",type:"boolean",optional:!0,description:"Turns on system tracing."},{name:"enableArgumentFilter",type:"boolean",optional:!0,description:"Turns on argument filter."},{name:"includedCategories",type:"array",items:{type:"string"},optional:!0,description:"Included category filters."},{name:"excludedCategories",type:"array",items:{type:"string"},optional:!0,description:"Excluded category filters."},{name:"syntheticDelays",type:"array",items:{type:"string"},optional:!0,description:"Configuration to synthesize the delays in tracing."},{name:"memoryDumpConfig",$ref:"MemoryDumpConfig",optional:!0,description:'Configuration for memory dump triggers. Used only when "memory-infra" category is enabled.'}]}],commands:[{name:"start",description:"Start trace events collection.",parameters:[{name:"categories",type:"string",optional:!0,deprecated:!0,description:"Category/tag filter"},{name:"options",type:"string",optional:!0,deprecated:!0,description:"Tracing options"},{name:"bufferUsageReportingInterval",type:"number",optional:!0,description:"If set, the agent will issue bufferUsage events at this interval, specified in milliseconds"},{name:"transferMode",type:"string",enum:["ReportEvents","ReturnAsStream"],optional:!0,description:"Whether to report trace events as series of dataCollected events or to save trace to a stream (defaults to <code>ReportEvents</code>)."},{name:"traceConfig",$ref:"TraceConfig",optional:!0,description:""}]},{name:"end",description:"Stop trace events collection."},{name:"getCategories",description:"Gets supported tracing categories.",
	returns:[{name:"categories",type:"array",items:{type:"string"},description:"A list of supported tracing categories."}]},{name:"requestMemoryDump",description:"Request a global memory dump.",returns:[{name:"dumpGuid",type:"string",description:"GUID of the resulting global memory dump."},{name:"success",type:"boolean",description:"True iff the global memory dump succeeded."}]},{name:"recordClockSyncMarker",description:"Record a clock sync marker in the trace.",parameters:[{name:"syncId",type:"string",description:"The ID of this clock sync marker"}]}],events:[{name:"dataCollected",parameters:[{name:"value",type:"array",items:{type:"object"}}],description:"Contains an bucket of collected trace events. When tracing is stopped collected events will be send as a sequence of dataCollected events followed by tracingComplete event."},{name:"tracingComplete",description:"Signals that tracing is stopped and there is no trace buffers pending flush, all data were delivered via dataCollected events.",parameters:[{name:"stream",$ref:"IO.StreamHandle",optional:!0,description:"A handle of the stream that holds resulting trace data."}]},{name:"bufferUsage",parameters:[{name:"percentFull",type:"number",optional:!0,description:"A number in range [0..1] that indicates the used size of event buffer as a fraction of its total size."},{name:"eventCount",type:"number",optional:!0,description:"An approximate number of events in the trace log."},{name:"value",type:"number",optional:!0,description:"A number in range [0..1] that indicates the used size of event buffer as a fraction of its total size."}]}]},{domain:"Animation",experimental:!0,dependencies:["Runtime","DOM"],types:[{id:"Animation",type:"object",experimental:!0,properties:[{name:"id",type:"string",description:"<code>Animation</code>'s id."},{name:"name",type:"string",description:"<code>Animation</code>'s name."},{name:"pausedState",type:"boolean",experimental:!0,description:"<code>Animation</code>'s internal paused state."},{name:"playState",type:"string",description:"<code>Animation</code>'s play state."},{name:"playbackRate",type:"number",description:"<code>Animation</code>'s playback rate."},{name:"startTime",type:"number",description:"<code>Animation</code>'s start time."},{name:"currentTime",type:"number",description:"<code>Animation</code>'s current time."},{name:"source",$ref:"AnimationEffect",description:"<code>Animation</code>'s source animation node."},{name:"type",type:"string",enum:["CSSTransition","CSSAnimation","WebAnimation"],description:"Animation type of <code>Animation</code>."},{name:"cssId",type:"string",optional:!0,description:"A unique ID for <code>Animation</code> representing the sources that triggered this CSS animation/transition."}],description:"Animation instance."},{id:"AnimationEffect",type:"object",experimental:!0,properties:[{name:"delay",type:"number",description:"<code>AnimationEffect</code>'s delay."},{name:"endDelay",type:"number",description:"<code>AnimationEffect</code>'s end delay."},{name:"iterationStart",type:"number",description:"<code>AnimationEffect</code>'s iteration start."},{name:"iterations",type:"number",description:"<code>AnimationEffect</code>'s iterations."},{name:"duration",type:"number",description:"<code>AnimationEffect</code>'s iteration duration."},{name:"direction",type:"string",description:"<code>AnimationEffect</code>'s playback direction."},{name:"fill",type:"string",description:"<code>AnimationEffect</code>'s fill mode."},{name:"backendNodeId",$ref:"DOM.BackendNodeId",description:"<code>AnimationEffect</code>'s target node."},{name:"keyframesRule",$ref:"KeyframesRule",optional:!0,description:"<code>AnimationEffect</code>'s keyframes."},{name:"easing",type:"string",description:"<code>AnimationEffect</code>'s timing function."}],description:"AnimationEffect instance"},{id:"KeyframesRule",type:"object",properties:[{name:"name",type:"string",optional:!0,description:"CSS keyframed animation's name."},{name:"keyframes",type:"array",items:{$ref:"KeyframeStyle"},description:"List of animation keyframes."}],description:"Keyframes Rule"},{id:"KeyframeStyle",type:"object",properties:[{name:"offset",type:"string",description:"Keyframe's time offset."},{name:"easing",type:"string",description:"<code>AnimationEffect</code>'s timing function."}],description:"Keyframe Style"}],commands:[{name:"enable",description:"Enables animation domain notifications."},{name:"disable",description:"Disables animation domain notifications."},{name:"getPlaybackRate",returns:[{name:"playbackRate",type:"number",description:"Playback rate for animations on page."}],description:"Gets the playback rate of the document timeline."},{name:"setPlaybackRate",parameters:[{name:"playbackRate",type:"number",description:"Playback rate for animations on page"}],description:"Sets the playback rate of the document timeline."},{name:"getCurrentTime",parameters:[{name:"id",type:"string",description:"Id of animation."}],returns:[{name:"currentTime",type:"number",description:"Current time of the page."}],description:"Returns the current time of the an animation."},{name:"setPaused",parameters:[{name:"animations",type:"array",items:{type:"string"},description:"Animations to set the pause state of."},{name:"paused",type:"boolean",description:"Paused state to set to."}],description:"Sets the paused state of a set of animations."},{name:"setTiming",parameters:[{name:"animationId",type:"string",description:"Animation id."},{name:"duration",type:"number",description:"Duration of the animation."},{name:"delay",type:"number",description:"Delay of the animation."}],description:"Sets the timing of an animation node."},{name:"seekAnimations",parameters:[{name:"animations",type:"array",items:{type:"string"},description:"List of animation ids to seek."},{name:"currentTime",type:"number",description:"Set the current time of each animation."}],description:"Seek a set of animations to a particular time within each animation."},{name:"releaseAnimations",parameters:[{name:"animations",type:"array",items:{type:"string"},description:"List of animation ids to seek."}],description:"Releases a set of animations to no longer be manipulated."},{name:"resolveAnimation",parameters:[{name:"animationId",type:"string",description:"Animation id."}],returns:[{name:"remoteObject",$ref:"Runtime.RemoteObject",description:"Corresponding remote object."}],description:"Gets the remote object of the Animation."}],events:[{name:"animationCreated",parameters:[{name:"id",type:"string",description:"Id of the animation that was created."}],description:"Event for each animation that has been created."},{name:"animationStarted",parameters:[{name:"animation",$ref:"Animation",description:"Animation that was started."}],description:"Event for animation that has been started."},{name:"animationCanceled",parameters:[{name:"id",type:"string",description:"Id of the animation that was cancelled."}],description:"Event for when an animation has been cancelled."}]},{domain:"Accessibility",experimental:!0,dependencies:["DOM"],types:[{id:"AXNodeId",type:"string",description:"Unique accessibility node identifier."},{id:"AXValueType",type:"string",enum:["boolean","tristate","booleanOrUndefined","idref","idrefList","integer","node","nodeList","number","string","computedString","token","tokenList","domRelation","role","internalRole","valueUndefined"],description:"Enum of possible property types."},{id:"AXValueSourceType",type:"string",enum:["attribute","implicit","style","contents","placeholder","relatedElement"],description:"Enum of possible property sources."},{id:"AXValueNativeSourceType",type:"string",enum:["figcaption","label","labelfor","labelwrapped","legend","tablecaption","title","other"],description:"Enum of possible native property sources (as a subtype of a particular AXValueSourceType)."},{id:"AXValueSource",type:"object",properties:[{name:"type",$ref:"AXValueSourceType",description:"What type of source this is."},{name:"value",$ref:"AXValue",description:"The value of this property source.",optional:!0},{name:"attribute",type:"string",description:"The name of the relevant attribute, if any.",optional:!0},{name:"attributeValue",$ref:"AXValue",description:"The value of the relevant attribute, if any.",optional:!0},{name:"superseded",type:"boolean",description:"Whether this source is superseded by a higher priority source.",optional:!0},{name:"nativeSource",$ref:"AXValueNativeSourceType",description:"The native markup source for this value, e.g. a <label> element.",optional:!0},{name:"nativeSourceValue",$ref:"AXValue",description:"The value, such as a node or node list, of the native source.",optional:!0},{name:"invalid",type:"boolean",description:"Whether the value for this property is invalid.",optional:!0},{name:"invalidReason",type:"string",description:"Reason for the value being invalid, if it is.",optional:!0}],description:"A single source for a computed AX property."},{id:"AXRelatedNode",type:"object",properties:[{name:"backendDOMNodeId",$ref:"DOM.BackendNodeId",description:"The BackendNodeId of the related DOM node."},{name:"idref",type:"string",description:"The IDRef value provided, if any.",optional:!0},{name:"text",type:"string",description:"The text alternative of this node in the current context.",optional:!0}]},{id:"AXProperty",type:"object",properties:[{name:"name",type:"string",description:"The name of this property."},{name:"value",$ref:"AXValue",description:"The value of this property."}]},{id:"AXValue",type:"object",properties:[{name:"type",$ref:"AXValueType",description:"The type of this value."},{name:"value",type:"any",description:"The computed value of this property.",optional:!0},{name:"relatedNodes",type:"array",items:{$ref:"AXRelatedNode"},description:"One or more related nodes, if applicable.",optional:!0},{name:"sources",type:"array",items:{$ref:"AXValueSource"},description:"The sources which contributed to the computation of this property.",optional:!0}],description:"A single computed AX property."},{id:"AXGlobalStates",type:"string",enum:["disabled","hidden","hiddenRoot","invalid"],description:"States which apply to every AX node."},{id:"AXLiveRegionAttributes",type:"string",enum:["live","atomic","relevant","busy","root"],description:"Attributes which apply to nodes in live regions."},{id:"AXWidgetAttributes",type:"string",enum:["autocomplete","haspopup","level","multiselectable","orientation","multiline","readonly","required","valuemin","valuemax","valuetext"],description:"Attributes which apply to widgets."},{id:"AXWidgetStates",type:"string",enum:["checked","expanded","pressed","selected"],description:"States which apply to widgets."},{id:"AXRelationshipAttributes",type:"string",enum:["activedescendant","flowto","controls","describedby","labelledby","owns"],description:"Relationships between elements other than parent/child/sibling."},{id:"AXNode",type:"object",properties:[{name:"nodeId",$ref:"AXNodeId",description:"Unique identifier for this node."},{name:"ignored",type:"boolean",description:"Whether this node is ignored for accessibility"},{name:"ignoredReasons",type:"array",items:{$ref:"AXProperty"},description:"Collection of reasons why this node is hidden.",optional:!0},{name:"role",$ref:"AXValue",description:"This <code>Node</code>'s role, whether explicit or implicit.",optional:!0},{name:"name",$ref:"AXValue",description:"The accessible name for this <code>Node</code>.",optional:!0},{name:"description",$ref:"AXValue",description:"The accessible description for this <code>Node</code>.",optional:!0},{name:"value",$ref:"AXValue",description:"The value for this <code>Node</code>.",optional:!0},{name:"properties",type:"array",items:{$ref:"AXProperty"},description:"All other properties",optional:!0},{name:"childIds",type:"array",items:{$ref:"AXNodeId"},description:"IDs for each of this node's child nodes.",optional:!0},{name:"backendDOMNodeId",$ref:"DOM.BackendNodeId",description:"The backend ID for the associated DOM node, if any.",optional:!0}],description:"A node in the accessibility tree."}],commands:[{name:"getPartialAXTree",parameters:[{name:"nodeId",$ref:"DOM.NodeId",description:"ID of node to get the partial accessibility tree for."},{name:"fetchRelatives",type:"boolean",description:"Whether to fetch this nodes ancestors, siblings and children. Defaults to true.",optional:!0}],returns:[{name:"nodes",type:"array",items:{$ref:"AXNode"},description:"The <code>Accessibility.AXNode</code> for this DOM node, if it exists, plus its ancestors, siblings and children, if requested."}],description:"Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.",experimental:!0}]},{domain:"Storage",experimental:!0,types:[{id:"StorageType",type:"string",enum:["appcache","cookies","file_systems","indexeddb","local_storage","shader_cache","websql","service_workers","cache_storage","all"],description:"Enum of possible storage types."}],commands:[{name:"clearDataForOrigin",parameters:[{name:"origin",type:"string",description:"Security origin."},{name:"storageTypes",type:"string",description:"Comma separated origin names."}],description:"Clears storage for origin."}]},{domain:"Log",description:"Provides access to log entries.",dependencies:["Runtime","Network"],experimental:!0,types:[{id:"LogEntry",type:"object",description:"Log entry.",properties:[{name:"source",type:"string",enum:["xml","javascript","network","storage","appcache","rendering","security","deprecation","worker","violation","other"],description:"Log entry source."},{name:"level",type:"string",enum:["log","warning","error","debug","info"],description:"Log entry severity."},{name:"text",type:"string",description:"Logged text."},{name:"timestamp",$ref:"Runtime.Timestamp",description:"Timestamp when this entry was added."},{name:"url",type:"string",optional:!0,description:"URL of the resource if known."},{name:"lineNumber",type:"integer",optional:!0,description:"Line number in the resource."},{name:"stackTrace",$ref:"Runtime.StackTrace",optional:!0,description:"JavaScript stack trace."},{name:"networkRequestId",$ref:"Network.RequestId",optional:!0,description:"Identifier of the network request associated with this entry."},{name:"workerId",type:"string",optional:!0,description:"Identifier of the worker associated with this entry."}]},{id:"ViolationSetting",type:"object",description:"Violation configuration setting.",properties:[{name:"name",type:"string",enum:["longTask","longLayout","blockedEvent","blockedParser","handler","recurringHandler"],description:"Violation type."},{name:"threshold",type:"number",description:"Time threshold to trigger upon."}]}],commands:[{name:"enable",description:"Enables log domain, sends the entries collected so far to the client by means of the <code>entryAdded</code> notification."},{name:"disable",description:"Disables log domain, prevents further log entries from being reported to the client."},{name:"clear",description:"Clears the log."},{name:"startViolationsReport",parameters:[{name:"config",type:"array",items:{$ref:"ViolationSetting"},description:"Configuration for violations."}],description:"start violation reporting."},{name:"stopViolationsReport",description:"Stop violation reporting."}],events:[{name:"entryAdded",parameters:[{name:"entry",$ref:"LogEntry",description:"The entry."}],description:"Issued when new message was logged."}]},{domain:"SystemInfo",description:"The SystemInfo domain defines methods and events for querying low-level system information.",experimental:!0,types:[{id:"GPUDevice",type:"object",properties:[{name:"vendorId",type:"number",description:"PCI ID of the GPU vendor, if available; 0 otherwise."},{name:"deviceId",type:"number",description:"PCI ID of the GPU device, if available; 0 otherwise."},{name:"vendorString",type:"string",description:"String description of the GPU vendor, if the PCI ID is not available."},{name:"deviceString",type:"string",description:"String description of the GPU device, if the PCI ID is not available."}],description:"Describes a single graphics processor (GPU)."},{id:"GPUInfo",type:"object",properties:[{name:"devices",type:"array",items:{$ref:"GPUDevice"},description:"The graphics devices on the system. Element 0 is the primary GPU."},{name:"auxAttributes",type:"object",optional:!0,description:"An optional dictionary of additional GPU related attributes."},{name:"featureStatus",type:"object",optional:!0,description:"An optional dictionary of graphics features and their status."},{name:"driverBugWorkarounds",type:"array",items:{type:"string"},description:"An optional array of GPU driver bug workarounds."}],description:"Provides information about the GPU(s) on the system."}],commands:[{name:"getInfo",description:"Returns information about the system.",returns:[{name:"gpu",$ref:"GPUInfo",description:"Information about the GPUs on the system."},{name:"modelName",type:"string",description:"A platform-dependent description of the model of the machine. On Mac OS, this is, for example, 'MacBookPro'. Will be the empty string if not supported."},{name:"modelVersion",type:"string",description:"A platform-dependent description of the version of the machine. On Mac OS, this is, for example, '10.1'. Will be the empty string if not supported."}]}]},{domain:"Tethering",description:"The Tethering domain defines methods and events for browser port binding.",experimental:!0,commands:[{name:"bind",description:"Request browser port binding.",parameters:[{name:"port",type:"integer",description:"Port number to bind."}]},{name:"unbind",description:"Request browser port unbinding.",parameters:[{name:"port",type:"integer",description:"Port number to unbind."}]}],events:[{name:"accepted",description:"Informs that port was successfully bound and got a specified connection id.",parameters:[{name:"port",type:"integer",description:"Port number that was successfully bound."},{name:"connectionId",type:"string",description:"Connection id to be used."}]}]},{domain:"Schema",description:"Provides information about the protocol schema.",types:[{id:"Domain",type:"object",description:"Description of the protocol domain.",exported:!0,properties:[{name:"name",type:"string",description:"Domain name."},{name:"version",type:"string",description:"Domain version."}]}],commands:[{name:"getDomains",description:"Returns supported domains.",handlers:["browser","renderer"],returns:[{name:"domains",type:"array",items:{$ref:"Domain"},description:"List of supported domains."}]}]},{domain:"Runtime",description:"Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects. Evaluation results are returned as mirror object that expose object type, string representation and unique identifier that can be used for further object reference. Original objects are maintained in memory unless they are either explicitly released or are released along with the other objects in their object group.",types:[{id:"ScriptId",type:"string",description:"Unique script identifier."},{id:"RemoteObjectId",type:"string",description:"Unique object identifier."},{id:"UnserializableValue",type:"string",enum:["Infinity","NaN","-Infinity","-0"],description:"Primitive value which cannot be JSON-stringified."},{id:"RemoteObject",type:"object",description:"Mirror object referencing original JavaScript object.",exported:!0,properties:[{name:"type",type:"string",enum:["object","function","undefined","string","number","boolean","symbol"],description:"Object type."},{name:"subtype",type:"string",optional:!0,enum:["array","null","node","regexp","date","map","set","iterator","generator","error","proxy","promise","typedarray"],description:"Object subtype hint. Specified for <code>object</code> type values only."},{name:"className",type:"string",optional:!0,description:"Object class (constructor) name. Specified for <code>object</code> type values only."},{name:"value",type:"any",optional:!0,description:"Remote object value in case of primitive values or JSON values (if it was requested)."},{name:"unserializableValue",$ref:"UnserializableValue",optional:!0,description:"Primitive value which can not be JSON-stringified does not have <code>value</code>, but gets this property."},{name:"description",type:"string",optional:!0,description:"String representation of the object."},{name:"objectId",$ref:"RemoteObjectId",optional:!0,description:"Unique object identifier (for non-primitive values)."},{name:"preview",$ref:"ObjectPreview",optional:!0,description:"Preview containing abbreviated property values. Specified for <code>object</code> type values only.",experimental:!0},{name:"customPreview",$ref:"CustomPreview",optional:!0,experimental:!0}]},{id:"CustomPreview",type:"object",experimental:!0,properties:[{name:"header",type:"string"},{name:"hasBody",type:"boolean"},{name:"formatterObjectId",$ref:"RemoteObjectId"},{name:"bindRemoteObjectFunctionId",$ref:"RemoteObjectId"},{name:"configObjectId",$ref:"RemoteObjectId",optional:!0}]},{id:"ObjectPreview",type:"object",experimental:!0,description:"Object containing abbreviated remote object value.",properties:[{name:"type",type:"string",enum:["object","function","undefined","string","number","boolean","symbol"],description:"Object type."},{name:"subtype",type:"string",optional:!0,enum:["array","null","node","regexp","date","map","set","iterator","generator","error"],description:"Object subtype hint. Specified for <code>object</code> type values only."},{name:"description",type:"string",optional:!0,description:"String representation of the object."},{name:"overflow",type:"boolean",description:"True iff some of the properties or entries of the original object did not fit."},{name:"properties",type:"array",items:{$ref:"PropertyPreview"},description:"List of the properties."},{name:"entries",type:"array",items:{$ref:"EntryPreview"},optional:!0,description:"List of the entries. Specified for <code>map</code> and <code>set</code> subtype values only."}]},{id:"PropertyPreview",type:"object",experimental:!0,properties:[{name:"name",type:"string",description:"Property name."},{name:"type",type:"string",enum:["object","function","undefined","string","number","boolean","symbol","accessor"],description:"Object type. Accessor means that the property itself is an accessor property."},{name:"value",type:"string",optional:!0,description:"User-friendly property value string."},{name:"valuePreview",$ref:"ObjectPreview",optional:!0,description:"Nested value preview."},{name:"subtype",type:"string",optional:!0,enum:["array","null","node","regexp","date","map","set","iterator","generator","error"],description:"Object subtype hint. Specified for <code>object</code> type values only."}]},{id:"EntryPreview",type:"object",experimental:!0,properties:[{name:"key",$ref:"ObjectPreview",optional:!0,description:"Preview of the key. Specified for map-like collection entries."},{name:"value",$ref:"ObjectPreview",description:"Preview of the value."}]},{id:"PropertyDescriptor",type:"object",description:"Object property descriptor.",properties:[{name:"name",type:"string",description:"Property name or symbol description."},{name:"value",$ref:"RemoteObject",optional:!0,description:"The value associated with the property."},{name:"writable",type:"boolean",optional:!0,description:"True if the value associated with the property may be changed (data descriptors only)."},{name:"get",$ref:"RemoteObject",optional:!0,description:"A function which serves as a getter for the property, or <code>undefined</code> if there is no getter (accessor descriptors only)."},{name:"set",$ref:"RemoteObject",optional:!0,description:"A function which serves as a setter for the property, or <code>undefined</code> if there is no setter (accessor descriptors only)."},{name:"configurable",type:"boolean",description:"True if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object."},{name:"enumerable",type:"boolean",description:"True if this property shows up during enumeration of the properties on the corresponding object."},{name:"wasThrown",type:"boolean",optional:!0,description:"True if the result was thrown during the evaluation."},{name:"isOwn",optional:!0,type:"boolean",description:"True if the property is owned for the object."},{name:"symbol",$ref:"RemoteObject",optional:!0,description:"Property symbol object, if the property is of the <code>symbol</code> type."}]},{id:"InternalPropertyDescriptor",type:"object",description:"Object internal property descriptor. This property isn't normally visible in JavaScript code.",properties:[{name:"name",type:"string",description:"Conventional property name."},{name:"value",$ref:"RemoteObject",optional:!0,description:"The value associated with the property."}]},{id:"CallArgument",type:"object",description:"Represents function call argument. Either remote object id <code>objectId</code>, primitive <code>value</code>, unserializable primitive value or neither of (for undefined) them should be specified.",properties:[{name:"value",type:"any",optional:!0,description:"Primitive value."},{name:"unserializableValue",$ref:"UnserializableValue",optional:!0,description:"Primitive value which can not be JSON-stringified."},{name:"objectId",$ref:"RemoteObjectId",optional:!0,description:"Remote object handle."}]},{id:"ExecutionContextId",type:"integer",description:"Id of an execution context."},{id:"ExecutionContextDescription",type:"object",description:"Description of an isolated world.",properties:[{name:"id",$ref:"ExecutionContextId",description:"Unique id of the execution context. It can be used to specify in which execution context script evaluation should be performed."},{name:"origin",type:"string",description:"Execution context origin."},{name:"name",type:"string",description:"Human readable name describing given context."},{name:"auxData",type:"object",optional:!0,description:"Embedder-specific auxiliary data."}]},{id:"ExceptionDetails",type:"object",description:"Detailed information about exception (or error) that was thrown during script compilation or execution.",properties:[{name:"exceptionId",type:"integer",description:"Exception id."},{name:"text",type:"string",description:"Exception text, which should be used together with exception object when available."},{name:"lineNumber",type:"integer",description:"Line number of the exception location (0-based)."},{name:"columnNumber",type:"integer",description:"Column number of the exception location (0-based)."},{name:"scriptId",$ref:"ScriptId",optional:!0,description:"Script ID of the exception location."},{name:"url",type:"string",optional:!0,description:"URL of the exception location, to be used when the script was not reported."},{name:"stackTrace",$ref:"StackTrace",optional:!0,description:"JavaScript stack trace if available."},{name:"exception",$ref:"RemoteObject",optional:!0,description:"Exception object if available."},{name:"executionContextId",$ref:"ExecutionContextId",optional:!0,description:"Identifier of the context where exception happened."}]},{id:"Timestamp",type:"number",description:"Number of milliseconds since epoch."},{id:"CallFrame",type:"object",description:"Stack entry for runtime errors and assertions.",properties:[{name:"functionName",type:"string",description:"JavaScript function name."},{name:"scriptId",$ref:"ScriptId",description:"JavaScript script id."},{name:"url",type:"string",description:"JavaScript script name or url."},{name:"lineNumber",type:"integer",description:"JavaScript script line number (0-based)."},{name:"columnNumber",type:"integer",description:"JavaScript script column number (0-based)."}]},{id:"StackTrace",type:"object",description:"Call frames for assertions or error messages.",exported:!0,properties:[{name:"description",type:"string",optional:!0,description:"String label of this stack trace. For async traces this may be a name of the function that initiated the async call."},{name:"callFrames",type:"array",items:{$ref:"CallFrame"},description:"JavaScript function name."},{name:"parent",$ref:"StackTrace",optional:!0,description:"Asynchronous JavaScript stack trace that preceded this stack, if available."}]}],commands:[{name:"evaluate",parameters:[{name:"expression",type:"string",description:"Expression to evaluate."},{name:"objectGroup",type:"string",optional:!0,description:"Symbolic group name that can be used to release multiple objects."},{name:"includeCommandLineAPI",type:"boolean",optional:!0,description:"Determines whether Command Line API should be available during the evaluation."},{name:"silent",type:"boolean",optional:!0,description:"In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state."},{name:"contextId",$ref:"ExecutionContextId",optional:!0,description:"Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page."},{name:"returnByValue",type:"boolean",optional:!0,description:"Whether the result is expected to be a JSON object that should be sent by value."},{name:"generatePreview",type:"boolean",optional:!0,experimental:!0,description:"Whether preview should be generated for the result."},{name:"userGesture",type:"boolean",optional:!0,experimental:!0,description:"Whether execution should be treated as initiated by user in the UI."},{name:"awaitPromise",type:"boolean",optional:!0,description:"Whether execution should wait for promise to be resolved. If the result of evaluation is not a Promise, it's considered to be an error."}],returns:[{name:"result",$ref:"RemoteObject",description:"Evaluation result."},{name:"exceptionDetails",$ref:"ExceptionDetails",optional:!0,description:"Exception details."}],description:"Evaluates expression on global object."},{name:"awaitPromise",parameters:[{name:"promiseObjectId",$ref:"RemoteObjectId",description:"Identifier of the promise."},{name:"returnByValue",type:"boolean",optional:!0,description:"Whether the result is expected to be a JSON object that should be sent by value."},{name:"generatePreview",type:"boolean",optional:!0,description:"Whether preview should be generated for the result."}],returns:[{name:"result",$ref:"RemoteObject",description:"Promise result. Will contain rejected value if promise was rejected."},{name:"exceptionDetails",$ref:"ExceptionDetails",optional:!0,description:"Exception details if stack strace is available."}],description:"Add handler to promise with given promise object id."},{name:"callFunctionOn",parameters:[{name:"objectId",$ref:"RemoteObjectId",description:"Identifier of the object to call function on."},{name:"functionDeclaration",type:"string",description:"Declaration of the function to call."},{name:"arguments",type:"array",items:{$ref:"CallArgument",description:"Call argument."},optional:!0,description:"Call arguments. All call arguments must belong to the same JavaScript world as the target object."},{name:"silent",type:"boolean",optional:!0,description:"In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state."},{name:"returnByValue",type:"boolean",optional:!0,description:"Whether the result is expected to be a JSON object which should be sent by value."},{name:"generatePreview",type:"boolean",optional:!0,experimental:!0,description:"Whether preview should be generated for the result."},{name:"userGesture",type:"boolean",optional:!0,experimental:!0,description:"Whether execution should be treated as initiated by user in the UI."},{name:"awaitPromise",type:"boolean",optional:!0,description:"Whether execution should wait for promise to be resolved. If the result of evaluation is not a Promise, it's considered to be an error."}],returns:[{name:"result",$ref:"RemoteObject",description:"Call result."},{name:"exceptionDetails",$ref:"ExceptionDetails",optional:!0,description:"Exception details."}],description:"Calls function with given declaration on the given object. Object group of the result is inherited from the target object."
	},{name:"getProperties",parameters:[{name:"objectId",$ref:"RemoteObjectId",description:"Identifier of the object to return properties for."},{name:"ownProperties",optional:!0,type:"boolean",description:"If true, returns properties belonging only to the element itself, not to its prototype chain."},{name:"accessorPropertiesOnly",optional:!0,type:"boolean",description:"If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.",experimental:!0},{name:"generatePreview",type:"boolean",optional:!0,experimental:!0,description:"Whether preview should be generated for the results."}],returns:[{name:"result",type:"array",items:{$ref:"PropertyDescriptor"},description:"Object properties."},{name:"internalProperties",optional:!0,type:"array",items:{$ref:"InternalPropertyDescriptor"},description:"Internal object properties (only of the element itself)."},{name:"exceptionDetails",$ref:"ExceptionDetails",optional:!0,description:"Exception details."}],description:"Returns properties of a given object. Object group of the result is inherited from the target object."},{name:"releaseObject",parameters:[{name:"objectId",$ref:"RemoteObjectId",description:"Identifier of the object to release."}],description:"Releases remote object with given id."},{name:"releaseObjectGroup",parameters:[{name:"objectGroup",type:"string",description:"Symbolic object group name."}],description:"Releases all remote objects that belong to a given group."},{name:"runIfWaitingForDebugger",description:"Tells inspected instance to run if it was waiting for debugger to attach."},{name:"enable",description:"Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context."},{name:"disable",description:"Disables reporting of execution contexts creation."},{name:"discardConsoleEntries",description:"Discards collected exceptions and console API calls."},{name:"setCustomObjectFormatterEnabled",parameters:[{name:"enabled",type:"boolean"}],experimental:!0},{name:"compileScript",parameters:[{name:"expression",type:"string",description:"Expression to compile."},{name:"sourceURL",type:"string",description:"Source url to be set for the script."},{name:"persistScript",type:"boolean",description:"Specifies whether the compiled script should be persisted."},{name:"executionContextId",$ref:"ExecutionContextId",optional:!0,description:"Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page."}],returns:[{name:"scriptId",$ref:"ScriptId",optional:!0,description:"Id of the script."},{name:"exceptionDetails",$ref:"ExceptionDetails",optional:!0,description:"Exception details."}],description:"Compiles expression."},{name:"runScript",parameters:[{name:"scriptId",$ref:"ScriptId",description:"Id of the script to run."},{name:"executionContextId",$ref:"ExecutionContextId",optional:!0,description:"Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page."},{name:"objectGroup",type:"string",optional:!0,description:"Symbolic group name that can be used to release multiple objects."},{name:"silent",type:"boolean",optional:!0,description:"In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state."},{name:"includeCommandLineAPI",type:"boolean",optional:!0,description:"Determines whether Command Line API should be available during the evaluation."},{name:"returnByValue",type:"boolean",optional:!0,description:"Whether the result is expected to be a JSON object which should be sent by value."},{name:"generatePreview",type:"boolean",optional:!0,description:"Whether preview should be generated for the result."},{name:"awaitPromise",type:"boolean",optional:!0,description:"Whether execution should wait for promise to be resolved. If the result of evaluation is not a Promise, it's considered to be an error."}],returns:[{name:"result",$ref:"RemoteObject",description:"Run result."},{name:"exceptionDetails",$ref:"ExceptionDetails",optional:!0,description:"Exception details."}],description:"Runs script with given id in a given context."}],events:[{name:"executionContextCreated",parameters:[{name:"context",$ref:"ExecutionContextDescription",description:"A newly created execution contex."}],description:"Issued when new execution context is created."},{name:"executionContextDestroyed",parameters:[{name:"executionContextId",$ref:"ExecutionContextId",description:"Id of the destroyed context"}],description:"Issued when execution context is destroyed."},{name:"executionContextsCleared",description:"Issued when all executionContexts were cleared in browser"},{name:"exceptionThrown",description:"Issued when exception was thrown and unhandled.",parameters:[{name:"timestamp",$ref:"Timestamp",description:"Timestamp of the exception."},{name:"exceptionDetails",$ref:"ExceptionDetails"}]},{name:"exceptionRevoked",description:"Issued when unhandled exception was revoked.",parameters:[{name:"reason",type:"string",description:"Reason describing why exception was revoked."},{name:"exceptionId",type:"integer",description:"The id of revoked exception, as reported in <code>exceptionUnhandled</code>."}]},{name:"consoleAPICalled",description:"Issued when console API was called.",parameters:[{name:"type",type:"string",enum:["log","debug","info","error","warning","dir","dirxml","table","trace","clear","startGroup","startGroupCollapsed","endGroup","assert","profile","profileEnd"],description:"Type of the call."},{name:"args",type:"array",items:{$ref:"RemoteObject"},description:"Call arguments."},{name:"executionContextId",$ref:"ExecutionContextId",description:"Identifier of the context where the call was made."},{name:"timestamp",$ref:"Timestamp",description:"Call timestamp."},{name:"stackTrace",$ref:"StackTrace",optional:!0,description:"Stack trace captured when the call was made."}]},{name:"inspectRequested",description:"Issued when object should be inspected (for example, as a result of inspect() command line API call).",parameters:[{name:"object",$ref:"RemoteObject"},{name:"hints",type:"object"}]}]},{domain:"Debugger",description:"Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing breakpoints, stepping through execution, exploring stack traces, etc.",dependencies:["Runtime"],types:[{id:"BreakpointId",type:"string",description:"Breakpoint identifier."},{id:"CallFrameId",type:"string",description:"Call frame identifier."},{id:"Location",type:"object",properties:[{name:"scriptId",$ref:"Runtime.ScriptId",description:"Script identifier as reported in the <code>Debugger.scriptParsed</code>."},{name:"lineNumber",type:"integer",description:"Line number in the script (0-based)."},{name:"columnNumber",type:"integer",optional:!0,description:"Column number in the script (0-based)."}],description:"Location in the source code."},{id:"ScriptPosition",experimental:!0,type:"object",properties:[{name:"lineNumber",type:"integer"},{name:"columnNumber",type:"integer"}],description:"Location in the source code."},{id:"CallFrame",type:"object",properties:[{name:"callFrameId",$ref:"CallFrameId",description:"Call frame identifier. This identifier is only valid while the virtual machine is paused."},{name:"functionName",type:"string",description:"Name of the JavaScript function called on this call frame."},{name:"functionLocation",$ref:"Location",optional:!0,experimental:!0,description:"Location in the source code."},{name:"location",$ref:"Location",description:"Location in the source code."},{name:"scopeChain",type:"array",items:{$ref:"Scope"},description:"Scope chain for this call frame."},{name:"this",$ref:"Runtime.RemoteObject",description:"<code>this</code> object for this call frame."},{name:"returnValue",$ref:"Runtime.RemoteObject",optional:!0,description:"The value being returned, if the function is at return point."}],description:"JavaScript call frame. Array of call frames form the call stack."},{id:"Scope",type:"object",properties:[{name:"type",type:"string",enum:["global","local","with","closure","catch","block","script","eval"],description:"Scope type."},{name:"object",$ref:"Runtime.RemoteObject",description:"Object representing the scope. For <code>global</code> and <code>with</code> scopes it represents the actual object; for the rest of the scopes, it is artificial transient object enumerating scope variables as its properties."},{name:"name",type:"string",optional:!0},{name:"startLocation",$ref:"Location",optional:!0,description:"Location in the source code where scope starts"},{name:"endLocation",$ref:"Location",optional:!0,description:"Location in the source code where scope ends"}],description:"Scope description."},{id:"SearchMatch",type:"object",description:"Search match for resource.",exported:!0,properties:[{name:"lineNumber",type:"number",description:"Line number in resource content."},{name:"lineContent",type:"string",description:"Line with match content."}],experimental:!0}],commands:[{name:"enable",description:"Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received."},{name:"disable",description:"Disables debugger for given page."},{name:"setBreakpointsActive",parameters:[{name:"active",type:"boolean",description:"New value for breakpoints active state."}],description:"Activates / deactivates all breakpoints on the page."},{name:"setSkipAllPauses",parameters:[{name:"skip",type:"boolean",description:"New value for skip pauses state."}],description:"Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc)."},{name:"setBreakpointByUrl",parameters:[{name:"lineNumber",type:"integer",description:"Line number to set breakpoint at."},{name:"url",type:"string",optional:!0,description:"URL of the resources to set breakpoint on."},{name:"urlRegex",type:"string",optional:!0,description:"Regex pattern for the URLs of the resources to set breakpoints on. Either <code>url</code> or <code>urlRegex</code> must be specified."},{name:"columnNumber",type:"integer",optional:!0,description:"Offset in the line to set breakpoint at."},{name:"condition",type:"string",optional:!0,description:"Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true."}],returns:[{name:"breakpointId",$ref:"BreakpointId",description:"Id of the created breakpoint for further reference."},{name:"locations",type:"array",items:{$ref:"Location"},description:"List of the locations this breakpoint resolved into upon addition."}],description:"Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads."},{name:"setBreakpoint",parameters:[{name:"location",$ref:"Location",description:"Location to set breakpoint in."},{name:"condition",type:"string",optional:!0,description:"Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true."}],returns:[{name:"breakpointId",$ref:"BreakpointId",description:"Id of the created breakpoint for further reference."},{name:"actualLocation",$ref:"Location",description:"Location this breakpoint resolved into."}],description:"Sets JavaScript breakpoint at a given location."},{name:"removeBreakpoint",parameters:[{name:"breakpointId",$ref:"BreakpointId"}],description:"Removes JavaScript breakpoint."},{name:"getPossibleBreakpoints",parameters:[{name:"start",$ref:"Location",description:"Start of range to search possible breakpoint locations in."},{name:"end",$ref:"Location",optional:!0,description:"End of range to search possible breakpoint locations in (excluding). When not specifed, end of scripts is used as end of range."}],returns:[{name:"locations",type:"array",items:{$ref:"Location"},description:"List of the possible breakpoint locations."}],description:"Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.",experimental:!0},{name:"continueToLocation",parameters:[{name:"location",$ref:"Location",description:"Location to continue to."}],description:"Continues execution until specific location is reached."},{name:"stepOver",description:"Steps over the statement."},{name:"stepInto",description:"Steps into the function call."},{name:"stepOut",description:"Steps out of the function call."},{name:"pause",description:"Stops on the next JavaScript statement."},{name:"resume",description:"Resumes JavaScript execution."},{name:"searchInContent",parameters:[{name:"scriptId",$ref:"Runtime.ScriptId",description:"Id of the script to search in."},{name:"query",type:"string",description:"String to search for."},{name:"caseSensitive",type:"boolean",optional:!0,description:"If true, search is case sensitive."},{name:"isRegex",type:"boolean",optional:!0,description:"If true, treats string parameter as regex."}],returns:[{name:"result",type:"array",items:{$ref:"SearchMatch"},description:"List of search matches."}],experimental:!0,description:"Searches for given string in script content."},{name:"setScriptSource",parameters:[{name:"scriptId",$ref:"Runtime.ScriptId",description:"Id of the script to edit."},{name:"scriptSource",type:"string",description:"New content of the script."},{name:"dryRun",type:"boolean",optional:!0,description:" If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code."}],returns:[{name:"callFrames",type:"array",optional:!0,items:{$ref:"CallFrame"},description:"New stack trace in case editing has happened while VM was stopped."},{name:"stackChanged",type:"boolean",optional:!0,description:"Whether current call stack  was modified after applying the changes."},{name:"asyncStackTrace",$ref:"Runtime.StackTrace",optional:!0,description:"Async stack trace, if any."},{name:"exceptionDetails",optional:!0,$ref:"Runtime.ExceptionDetails",description:"Exception details if any."}],description:"Edits JavaScript source live."},{name:"restartFrame",parameters:[{name:"callFrameId",$ref:"CallFrameId",description:"Call frame identifier to evaluate on."}],returns:[{name:"callFrames",type:"array",items:{$ref:"CallFrame"},description:"New stack trace."},{name:"asyncStackTrace",$ref:"Runtime.StackTrace",optional:!0,description:"Async stack trace, if any."}],description:"Restarts particular call frame from the beginning."},{name:"getScriptSource",parameters:[{name:"scriptId",$ref:"Runtime.ScriptId",description:"Id of the script to get source for."}],returns:[{name:"scriptSource",type:"string",description:"Script source."}],description:"Returns source for the script with given id."},{name:"setPauseOnExceptions",parameters:[{name:"state",type:"string",enum:["none","uncaught","all"],description:"Pause on exceptions mode."}],description:"Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>."},{name:"evaluateOnCallFrame",parameters:[{name:"callFrameId",$ref:"CallFrameId",description:"Call frame identifier to evaluate on."},{name:"expression",type:"string",description:"Expression to evaluate."},{name:"objectGroup",type:"string",optional:!0,description:"String object group name to put result into (allows rapid releasing resulting object handles using <code>releaseObjectGroup</code>)."},{name:"includeCommandLineAPI",type:"boolean",optional:!0,description:"Specifies whether command line API should be available to the evaluated expression, defaults to false."},{name:"silent",type:"boolean",optional:!0,description:"In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state."},{name:"returnByValue",type:"boolean",optional:!0,description:"Whether the result is expected to be a JSON object that should be sent by value."},{name:"generatePreview",type:"boolean",optional:!0,experimental:!0,description:"Whether preview should be generated for the result."}],returns:[{name:"result",$ref:"Runtime.RemoteObject",description:"Object wrapper for the evaluation result."},{name:"exceptionDetails",$ref:"Runtime.ExceptionDetails",optional:!0,description:"Exception details."}],description:"Evaluates expression on a given call frame."},{name:"setVariableValue",parameters:[{name:"scopeNumber",type:"integer",description:"0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually."},{name:"variableName",type:"string",description:"Variable name."},{name:"newValue",$ref:"Runtime.CallArgument",description:"New variable value."},{name:"callFrameId",$ref:"CallFrameId",description:"Id of callframe that holds variable."}],description:"Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually."},{name:"setAsyncCallStackDepth",parameters:[{name:"maxDepth",type:"integer",description:"Maximum depth of async call stacks. Setting to <code>0</code> will effectively disable collecting async call stacks (default)."}],description:"Enables or disables async call stacks tracking."},{name:"setBlackboxPatterns",parameters:[{name:"patterns",type:"array",items:{type:"string"},description:"Array of regexps that will be used to check script url for blackbox state."}],experimental:!0,description:"Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful."},{name:"setBlackboxedRanges",parameters:[{name:"scriptId",$ref:"Runtime.ScriptId",description:"Id of the script."},{name:"positions",type:"array",items:{$ref:"ScriptPosition"}}],experimental:!0,description:"Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted."}],events:[{name:"scriptParsed",parameters:[{name:"scriptId",$ref:"Runtime.ScriptId",description:"Identifier of the script parsed."},{name:"url",type:"string",description:"URL or name of the script parsed (if any)."},{name:"startLine",type:"integer",description:"Line offset of the script within the resource with given URL (for script tags)."},{name:"startColumn",type:"integer",description:"Column offset of the script within the resource with given URL."},{name:"endLine",type:"integer",description:"Last line of the script."},{name:"endColumn",type:"integer",description:"Length of the last line of the script."},{name:"executionContextId",$ref:"Runtime.ExecutionContextId",description:"Specifies script creation context."},{name:"hash",type:"string",description:"Content hash of the script."},{name:"executionContextAuxData",type:"object",optional:!0,description:"Embedder-specific auxiliary data."},{name:"isLiveEdit",type:"boolean",optional:!0,description:"True, if this script is generated as a result of the live edit operation.",experimental:!0},{name:"sourceMapURL",type:"string",optional:!0,description:"URL of source map associated with script (if any)."},{name:"hasSourceURL",type:"boolean",optional:!0,description:"True, if this script has sourceURL.",experimental:!0}],description:"Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger."},{name:"scriptFailedToParse",parameters:[{name:"scriptId",$ref:"Runtime.ScriptId",description:"Identifier of the script parsed."},{name:"url",type:"string",description:"URL or name of the script parsed (if any)."},{name:"startLine",type:"integer",description:"Line offset of the script within the resource with given URL (for script tags)."},{name:"startColumn",type:"integer",description:"Column offset of the script within the resource with given URL."},{name:"endLine",type:"integer",description:"Last line of the script."},{name:"endColumn",type:"integer",description:"Length of the last line of the script."},{name:"executionContextId",$ref:"Runtime.ExecutionContextId",description:"Specifies script creation context."},{name:"hash",type:"string",description:"Content hash of the script."},{name:"executionContextAuxData",type:"object",optional:!0,description:"Embedder-specific auxiliary data."},{name:"sourceMapURL",type:"string",optional:!0,description:"URL of source map associated with script (if any)."},{name:"hasSourceURL",type:"boolean",optional:!0,description:"True, if this script has sourceURL.",experimental:!0}],description:"Fired when virtual machine fails to parse the script."},{name:"breakpointResolved",parameters:[{name:"breakpointId",$ref:"BreakpointId",description:"Breakpoint unique identifier."},{name:"location",$ref:"Location",description:"Actual breakpoint location."}],description:"Fired when breakpoint is resolved to an actual script and location."},{name:"paused",parameters:[{name:"callFrames",type:"array",items:{$ref:"CallFrame"},description:"Call stack the virtual machine stopped on."},{name:"reason",type:"string",enum:["XHR","DOM","EventListener","exception","assert","debugCommand","promiseRejection","other"],description:"Pause reason.",exported:!0},{name:"data",type:"object",optional:!0,description:"Object containing break-specific auxiliary properties."},{name:"hitBreakpoints",type:"array",optional:!0,items:{type:"string"},description:"Hit breakpoints IDs"},{name:"asyncStackTrace",$ref:"Runtime.StackTrace",optional:!0,description:"Async stack trace, if any."}],description:"Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria."},{name:"resumed",description:"Fired when the virtual machine resumed execution."}]},{domain:"Console",description:"This domain is deprecated - use Runtime or Log instead.",dependencies:["Runtime"],deprecated:!0,types:[{id:"ConsoleMessage",type:"object",description:"Console message.",properties:[{name:"source",type:"string",enum:["xml","javascript","network","console-api","storage","appcache","rendering","security","other","deprecation","worker"],description:"Message source."},{name:"level",type:"string",enum:["log","warning","error","debug","info"],description:"Message severity."},{name:"text",type:"string",description:"Message text."},{name:"url",type:"string",optional:!0,description:"URL of the message origin."},{name:"line",type:"integer",optional:!0,description:"Line number in the resource that generated this message (1-based)."},{name:"column",type:"integer",optional:!0,description:"Column number in the resource that generated this message (1-based)."}]}],commands:[{name:"enable",description:"Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification."},{name:"disable",description:"Disables console domain, prevents further console messages from being reported to the client."},{name:"clearMessages",description:"Does nothing."}],events:[{name:"messageAdded",parameters:[{name:"message",$ref:"ConsoleMessage",description:"Console message that has been added."}],description:"Issued when new console message is added."}]},{domain:"Profiler",dependencies:["Runtime","Debugger"],types:[{id:"ProfileNode",type:"object",description:"Profile node. Holds callsite information, execution statistics and child nodes.",properties:[{name:"id",type:"integer",description:"Unique id of the node."},{name:"callFrame",$ref:"Runtime.CallFrame",description:"Function location."},{name:"hitCount",type:"integer",optional:!0,experimental:!0,description:"Number of samples where this node was on top of the call stack."},{name:"children",type:"array",items:{type:"integer"},optional:!0,description:"Child node ids."},{name:"deoptReason",type:"string",optional:!0,description:"The reason of being not optimized. The function may be deoptimized or marked as don't optimize."},{name:"positionTicks",type:"array",items:{$ref:"PositionTickInfo"},optional:!0,experimental:!0,description:"An array of source position ticks."}]},{id:"Profile",type:"object",description:"Profile.",properties:[{name:"nodes",type:"array",items:{$ref:"ProfileNode"},description:"The list of profile nodes. First item is the root node."},{name:"startTime",type:"number",description:"Profiling start timestamp in microseconds."},{name:"endTime",type:"number",description:"Profiling end timestamp in microseconds."},{name:"samples",optional:!0,type:"array",items:{type:"integer"},description:"Ids of samples top nodes."},{name:"timeDeltas",optional:!0,type:"array",items:{type:"integer"},description:"Time intervals between adjacent samples in microseconds. The first delta is relative to the profile startTime."}]},{id:"PositionTickInfo",type:"object",experimental:!0,description:"Specifies a number of samples attributed to a certain source position.",properties:[{name:"line",type:"integer",description:"Source line number (1-based)."},{name:"ticks",type:"integer",description:"Number of samples attributed to the source line."}]}],commands:[{name:"enable"},{name:"disable"},{name:"setSamplingInterval",parameters:[{name:"interval",type:"integer",description:"New sampling interval in microseconds."}],description:"Changes CPU profiler sampling interval. Must be called before CPU profiles recording started."},{name:"start"},{name:"stop",returns:[{name:"profile",$ref:"Profile",description:"Recorded profile."}]}],events:[{name:"consoleProfileStarted",parameters:[{name:"id",type:"string"},{name:"location",$ref:"Debugger.Location",description:"Location of console.profile()."},{name:"title",type:"string",optional:!0,description:"Profile title passed as an argument to console.profile()."}],description:"Sent when new profile recodring is started using console.profile() call."},{name:"consoleProfileFinished",parameters:[{name:"id",type:"string"},{name:"location",$ref:"Debugger.Location",description:"Location of console.profileEnd()."},{name:"profile",$ref:"Profile"},{name:"title",type:"string",optional:!0,description:"Profile title passed as an argument to console.profile()."}]}]},{domain:"HeapProfiler",dependencies:["Runtime"],experimental:!0,types:[{id:"HeapSnapshotObjectId",type:"string",description:"Heap snapshot object id."},{id:"SamplingHeapProfileNode",type:"object",description:"Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes.",properties:[{name:"callFrame",$ref:"Runtime.CallFrame",description:"Function location."},{name:"selfSize",type:"number",description:"Allocations size in bytes for the node excluding children."},{name:"children",type:"array",items:{$ref:"SamplingHeapProfileNode"},description:"Child nodes."}]},{id:"SamplingHeapProfile",type:"object",description:"Profile.",properties:[{name:"head",$ref:"SamplingHeapProfileNode"}]}],commands:[{name:"enable"},{name:"disable"},{name:"startTrackingHeapObjects",parameters:[{name:"trackAllocations",type:"boolean",optional:!0}]},{name:"stopTrackingHeapObjects",parameters:[{name:"reportProgress",type:"boolean",optional:!0,description:"If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken when the tracking is stopped."}]},{name:"takeHeapSnapshot",parameters:[{name:"reportProgress",type:"boolean",optional:!0,description:"If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken."}]},{name:"collectGarbage"},{name:"getObjectByHeapObjectId",parameters:[{name:"objectId",$ref:"HeapSnapshotObjectId"},{name:"objectGroup",type:"string",optional:!0,description:"Symbolic group name that can be used to release multiple objects."}],returns:[{name:"result",$ref:"Runtime.RemoteObject",description:"Evaluation result."}]},{name:"addInspectedHeapObject",parameters:[{name:"heapObjectId",$ref:"HeapSnapshotObjectId",description:"Heap snapshot object id to be accessible by means of $x command line API."}],description:"Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions)."},{name:"getHeapObjectId",parameters:[{name:"objectId",$ref:"Runtime.RemoteObjectId",description:"Identifier of the object to get heap object id for."}],returns:[{name:"heapSnapshotObjectId",$ref:"HeapSnapshotObjectId",description:"Id of the heap snapshot object corresponding to the passed remote object id."}]},{name:"startSampling",parameters:[{name:"samplingInterval",type:"number",optional:!0,description:"Average sample interval in bytes. Poisson distribution is used for the intervals. The default value is 32768 bytes."}]},{name:"stopSampling",returns:[{name:"profile",$ref:"SamplingHeapProfile",description:"Recorded sampling heap profile."}]}],events:[{name:"addHeapSnapshotChunk",parameters:[{name:"chunk",type:"string"}]},{name:"resetProfiles"},{name:"reportHeapSnapshotProgress",parameters:[{name:"done",type:"integer"},{name:"total",type:"integer"},{name:"finished",type:"boolean",optional:!0}]},{name:"lastSeenObjectId",description:"If heap objects tracking has been started then backend regulary sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.",parameters:[{name:"lastSeenObjectId",type:"integer"},{name:"timestamp",type:"number"}]},{name:"heapStatsUpdate",description:"If heap objects tracking has been started then backend may send update for one or more fragments",parameters:[{name:"statsUpdate",type:"array",items:{type:"integer"},description:"An array of triplets. Each triplet describes a fragment. The first integer is the fragment index, the second integer is a total count of objects for the fragment, the third integer is a total size of the objects for the fragment."}]}]}]}},function(e,t,n){(function(t){"use strict";function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function o(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}function a(e,t,n){var i=this,r=i._nextCommandId++,o={id:r,method:e,params:t};i._ws.send(JSON.stringify(o)),i._callbacks[r]=n}function s(){var e=this,n={host:e.host,port:e.port};Promise.all([p.call(e,n).then(y.prepare.bind(e)),c.call(e,n)]).then(function(t){var n=t[1];return d.call(e,n)}).then(function(){t.nextTick(function(){e._notifier.emit("connect",e)})}).catch(function(t){e._notifier.emit("error",t)})}function p(e){var t=this;return new Promise(function(n,i){t.protocol?n(t.protocol):(e.remote=t.remote,b.Protocol(e).then(function(e){n(e.descriptor)}).catch(i))})}function c(e){var t=this;return new Promise(function(n,i){var r=new Error("Tab does not support inspection"),o=void 0;switch(m(t.tab)){case"string":n(t.tab);break;case"object":o=t.tab.webSocketDebuggerUrl,o?n(o):i(r);break;case"function":b.List(e).then(function(e){
	var a=e[t.tab(e)];a?(o=a.webSocketDebuggerUrl,o?n(o):i(r)):i(new Error("Invalid tab index"))}).catch(i);break;default:i(new Error("Invalid requested tab"))}})}function d(e){var t=this;return new Promise(function(n,i){try{t._ws=new f(e,{perMessageDeflate:!1})}catch(e){return void i(e)}t._ws.on("open",function(){n()}),t._ws.on("message",function(e){var n=JSON.parse(e);l.call(t,n)}),t._ws.on("close",function(){t._notifier.emit("disconnect")}),t._ws.on("error",function(e){i(e)})})}function l(e){var t=this;if(e.id){var n=t._callbacks[e.id];if(!n)return;e.error?n(!0,e.error):n(!1,e.result||{}),delete t._callbacks[e.id],0===Object.keys(t._callbacks).length&&t.emit("ready")}else e.method&&(t.emit("event",e),t.emit(e.method,e.params))}var m="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},u=n(2),h=n(27),f=n(42),y=n(43),g=n(38),b=n(3),v=function(e){function t(e,n){i(this,t);var o=r(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return e=e||{},o.host=e.host||g.HOST,o.port=e.port||g.PORT,o.protocol=e.protocol,o.remote=!!e.remote,o.tab=e.tab||e.chooseTab||function(){return 0},u.call(o),o._notifier=n,o._callbacks={},o._nextCommandId=1,s.call(o),o}return o(t,e),t}(u);v.prototype.inspect=function(e,t){return t.customInspect=!1,h.inspect(this,t)},v.prototype.send=function(e,t,n){var i=this;return"function"==typeof t&&(n=t,t=void 0),"function"!=typeof n?new Promise(function(n,r){a.call(i,e,t,function(e,t){e?r(t):n(t)})}):void a.call(i,e,t,n)},v.prototype.close=function(e){function t(e){n._ws.removeAllListeners("close"),n._ws.close(),n._ws.once("close",function(){n._ws.removeAllListeners(),e()})}var n=this;return"function"!=typeof e?new Promise(function(e,n){t(e)}):void t(e)},e.exports=v}).call(t,n(1))},function(e,t,n){"use strict";function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function o(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(t,n,i){return n&&e(t.prototype,n),i&&e(t,i),t}}(),s=n(2),p=function(e){function t(e){i(this,t);var n=r(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return n._ws=new WebSocket(e),n._ws.onopen=function(){n.emit("open")},n._ws.onclose=function(){n.emit("close")},n._ws.onmessage=function(e){n.emit("message",e.data)},n._ws.onerror=function(){n.emit("error",new Error("WebSocket error"))},n}return o(t,e),a(t,[{key:"close",value:function(){this._ws.close()}},{key:"send",value:function(e){this._ws.send(e)}}]),t}(s);e.exports=p},function(e,t){"use strict";function n(e){var t={};return e.forEach(function(e){var n=e.name;delete e.name,t[n]=e}),t}function i(e,t,i){e.category=t,Object.keys(i).forEach(function(r){"name"!==r&&("type"===t&&"properties"===r||"parameters"===r?e[r]=n(i[r]):e[r]=i[r])})}function r(e,t,n){var r=function(i,r){return e.send(t+"."+n.name,i,r)};i(r,"command",n),e[t][n.name]=r}function o(e,t,n){var r=function(i){e.on(t+"."+n.name,i)};i(r,"event",n),e[t][n.name]=r}function a(e,t,n){var r={};i(r,"type",n),e[t][n.id]=r}function s(e){var t=this;return new Promise(function(n,i){t.protocol=e,e.domains.forEach(function(e){var n=e.domain;t[n]={},(e.commands||[]).forEach(function(e){r(t,n,e)}),(e.events||[]).forEach(function(e){o(t,n,e)}),(e.types||[]).forEach(function(e){a(t,n,e)})}),n()})}e.exports.prepare=s}]);

/***/ },
/* 125 */
/***/ function(module, exports) {

	function networkRequest(url, opts) {
	  return new Promise((resolve, reject) => {
	    const req = new XMLHttpRequest();
	
	    req.addEventListener("readystatechange", () => {
	      if (req.readyState === XMLHttpRequest.DONE) {
	        if (req.status === 200) {
	          resolve({ content: req.responseText });
	        } else {
	          resolve(req.statusText);
	        }
	      }
	    });
	
	    // Not working yet.
	    // if (!opts.loadFromCache) {
	    //   req.channel.loadFlags = (
	    //     Components.interfaces.nsIRequest.LOAD_BYPASS_CACHE |
	    //       Components.interfaces.nsIRequest.INHIBIT_CACHING |
	    //       Components.interfaces.nsIRequest.LOAD_ANONYMOUS
	    //   );
	    // }
	
	    req.open("GET", url);
	    req.send();
	  });
	}
	
	module.exports = networkRequest;


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	let setBreakpoint = (() => {
	  var _ref = _asyncToGenerator(function* (location, condition) {
	    let {
	      breakpointId,
	      serverLocation
	    } = yield debuggerAgent.setBreakpoint({
	      location: toServerLocation(location),
	      columnNumber: location.column
	    });
	
	    const actualLocation = fromServerLocation(serverLocation) || location;
	
	    return {
	      id: breakpointId,
	      actualLocation: actualLocation
	    };
	  });
	
	  return function setBreakpoint(_x, _x2) {
	    return _ref.apply(this, arguments);
	  };
	})();
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	const { toServerLocation, fromServerLocation } = __webpack_require__(127);
	
	let debuggerAgent;
	let runtimeAgent;
	let pageAgent;
	
	function setupCommands({ Debugger, Runtime, Page }) {
	  debuggerAgent = Debugger;
	  runtimeAgent = Runtime;
	  pageAgent = Page;
	}
	
	function resume() {
	  return debuggerAgent.resume();
	}
	
	function stepIn() {
	  return debuggerAgent.stepInto();
	}
	
	function stepOver() {
	  return debuggerAgent.stepOver();
	}
	
	function stepOut() {
	  return debuggerAgent.stepOut();
	}
	
	function pauseOnExceptions(toggle) {
	  const state = toggle ? "uncaught" : "none";
	  return debuggerAgent.setPauseOnExceptions(state);
	}
	
	function breakOnNext() {
	  return debuggerAgent.pause();
	}
	
	function sourceContents(sourceId) {
	  return debuggerAgent.getScriptSource({ scriptId: sourceId }).then(({ scriptSource }) => ({
	    source: scriptSource,
	    contentType: null
	  }));
	}
	
	function removeBreakpoint(breakpointId) {
	  return debuggerAgent.removeBreakpoint({ breakpointId });
	}
	
	function evaluate(script) {
	  return runtimeAgent.evaluate({ expression: script });
	}
	
	function debuggeeCommand(script) {
	  evaluate(script);
	  return Promise.resolve();
	}
	
	function navigate(url) {
	  return pageAgent.navigate({ url });
	}
	
	const clientCommands = {
	  resume,
	  stepIn,
	  stepOut,
	  stepOver,
	  pauseOnExceptions,
	  breakOnNext,
	  sourceContents,
	  setBreakpoint,
	  removeBreakpoint,
	  evaluate,
	  debuggeeCommand,
	  navigate
	};
	
	module.exports = {
	  setupCommands,
	  clientCommands
	};

/***/ },
/* 127 */
/***/ function(module, exports) {

	function fromServerLocation(serverLocation) {
	  if (serverLocation) {
	    return {
	      sourceId: serverLocation.scriptId,
	      line: serverLocation.lineNumber + 1,
	      column: serverLocation.columnNumber
	    };
	  }
	}
	
	function toServerLocation(location) {
	  return {
	    scriptId: location.sourceId,
	    lineNumber: location.line - 1
	  };
	}
	
	function createFrame(frame) {
	  return {
	    id: frame.callFrameId,
	    displayName: frame.functionName,
	    scopeChain: frame.scopeChain,
	    location: fromServerLocation(frame.location)
	  };
	}
	
	module.exports = {
	  fromServerLocation,
	  toServerLocation,
	  createFrame
	};

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	let paused = (() => {
	  var _ref = _asyncToGenerator(function* ({ callFrames, reason, data,
	    hitBreakpoints, asyncStackTrace }) {
	    const frames = callFrames.map(createFrame);
	    const frame = frames[0];
	    const why = Object.assign({}, {
	      type: reason
	    }, data);
	
	    if (clientType == "chrome") {
	      pageAgent.configureOverlay({ message: "Paused in debugger.html" });
	    }
	
	    yield actions.paused({ frame, why, frames });
	  });
	
	  return function paused(_x) {
	    return _ref.apply(this, arguments);
	  };
	})();
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	const { createFrame } = __webpack_require__(127);
	
	let actions;
	let pageAgent;
	let clientType;
	
	function setupEvents(dependencies) {
	  actions = dependencies.actions;
	  pageAgent = dependencies.Page;
	  clientType = dependencies.clientType;
	}
	
	// Debugger Events
	function scriptParsed({ scriptId, url, startLine, startColumn,
	  endLine, endColumn, executionContextId, hash,
	  isContentScript, isInternalScript, isLiveEdit,
	  sourceMapURL, hasSourceURL, deprecatedCommentWasUsed }) {
	  if (isContentScript) {
	    return;
	  }
	
	  if (clientType == "node") {
	    sourceMapURL = undefined;
	  }
	
	  actions.newSource({
	    id: scriptId,
	    url,
	    sourceMapURL,
	    isPrettyPrinted: false
	  });
	}
	
	function scriptFailedToParse() {}
	
	function resumed() {
	  if (clientType == "chrome") {
	    pageAgent.configureOverlay({ suspended: false });
	  }
	
	  actions.resumed();
	}
	
	function globalObjectCleared() {}
	
	// Page Events
	function frameNavigated(frame) {
	  actions.navigate();
	}
	
	function frameStartedLoading() {
	  actions.willNavigate();
	}
	
	function domContentEventFired() {}
	
	function loadEventFired() {}
	
	function frameStoppedLoading() {}
	
	const clientEvents = {
	  scriptParsed,
	  scriptFailedToParse,
	  paused,
	  resumed,
	  globalObjectCleared
	};
	
	const pageEvents = {
	  frameNavigated,
	  frameStartedLoading,
	  domContentEventFired,
	  loadEventFired,
	  frameStoppedLoading
	};
	
	module.exports = {
	  setupEvents,
	  pageEvents,
	  clientEvents
	};

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/* global window, document, DebuggerConfig */
	
	const { bindActionCreators, combineReducers } = __webpack_require__(130);
	const { Provider } = __webpack_require__(149);
	
	const { DevToolsUtils, AppConstants } = __webpack_require__(26);
	const { debugGlobal } = __webpack_require__(158);
	const { setConfig, isEnabled, getValue, isDevelopment } = __webpack_require__(65);
	const L10N = __webpack_require__(159);
	
	setConfig(({"environment":"firefox-panel","baseWorkerURL":"resource://devtools/client/debugger/new/","logging":false,"clientLogging":false,"firefox":{"mcPath":"./firefox"},"features":{"watchExpressions":false,"chromeScopes":false,"eventListeners":false,"codeCoverage":false}}));
	
	// Set various flags before requiring app code.
	if (isEnabled("logging.client")) {
	  DevToolsUtils.dumpn.wantLogging = true;
	}
	
	const { getClient, firefox, chrome, startDebugging } = __webpack_require__(23);
	const Root = __webpack_require__(160);
	
	// Using this static variable allows webpack to know at compile-time
	// to avoid this require and not include it at all in the output.
	if (false) {
	  const theme = getValue("theme");
	  switch (theme) {
	    case "dark":
	      require("./lib/themes/dark-theme.css");break;
	    case "light":
	      require("./lib/themes/light-theme.css");break;
	    case "firebug":
	      require("./lib/themes/firebug-theme.css");break;
	  }
	  document.body.parentNode.classList.add(`theme-${ theme }`);
	}
	
	function initApp() {
	  const configureStore = __webpack_require__(166);
	  const reducers = __webpack_require__(177);
	  const LaunchpadApp = __webpack_require__(182);
	
	  const createStore = configureStore({
	    log: getValue("logging.actions"),
	    makeThunkArgs: (args, state) => {
	      return Object.assign({}, args, { client: getClient(state) });
	    }
	  });
	
	  const store = createStore(combineReducers(reducers));
	  const actions = bindActionCreators(__webpack_require__(195), store.dispatch);
	
	  debugGlobal("launchpadStore", store);
	
	  if (isDevelopment()) {
	    AppConstants.DEBUG_JS_MODULES = true;
	  }
	
	  return { store, actions, LaunchpadApp };
	}
	
	function renderRoot(_React, _ReactDOM, component, _store) {
	  const { createElement } = _React;
	  const mount = document.querySelector("#mount");
	
	  // bail in test environments that do not have a mount
	  if (!mount) {
	    return;
	  }
	
	  const root = Root("launchpad-root");
	  mount.appendChild(root);
	
	  if (component.props || component.propTypes) {
	    _ReactDOM.render(createElement(Provider, { store: _store }, createElement(component)), root);
	  } else {
	    root.appendChild(component);
	  }
	}
	
	function unmountRoot(_ReactDOM) {
	  const mount = document.querySelector("#mount .launchpad-root");
	  _ReactDOM.unmountComponentAtNode(mount);
	}
	
	function getTargetFromQuery() {
	  const href = window.location.href;
	  const nodeMatch = href.match(/node-tab=([^&#]*)/);
	  const firefoxMatch = href.match(/firefox-tab=([^&#]*)/);
	  const chromeMatch = href.match(/chrome-tab=([^&#]*)/);
	
	  if (nodeMatch) {
	    return { type: "node", param: nodeMatch[1] };
	  } else if (firefoxMatch) {
	    return { type: "firefox", param: firefoxMatch[1] };
	  } else if (chromeMatch) {
	    return { type: "chrome", param: chromeMatch[1] };
	  }
	
	  return null;
	}
	
	function bootstrap(React, ReactDOM, App, appActions, appStore) {
	  const connTarget = getTargetFromQuery();
	  if (connTarget) {
	    return startDebugging(connTarget, appActions).then(({ tab, client }) => {
	      debugGlobal("client", client.clientCommands);
	      renderRoot(React, ReactDOM, App, appStore);
	      return { tab, connTarget, client };
	    });
	  }
	
	  const { store, actions, LaunchpadApp } = initApp();
	  renderRoot(React, ReactDOM, LaunchpadApp, store);
	  chrome.connectClient().then(tabs => {
	    actions.newTabs(tabs);
	  }).catch(e => {
	    console.log("Connect to chrome:");
	    console.log("https://github.com/devtools-html/debugger.html/blob/master/CONTRIBUTING.md#chrome");
	  });
	
	  chrome.connectNodeClient().then(tabs => {
	    actions.newTabs(tabs);
	  });
	
	  return firefox.connectClient().then(tabs => {
	    actions.newTabs(tabs);
	  });
	}
	
	module.exports = {
	  bootstrap,
	  renderRoot,
	  unmountRoot,
	  debugGlobal,
	  L10N
	};

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;
	
	var _createStore = __webpack_require__(131);
	
	var _createStore2 = _interopRequireDefault(_createStore);
	
	var _combineReducers = __webpack_require__(144);
	
	var _combineReducers2 = _interopRequireDefault(_combineReducers);
	
	var _bindActionCreators = __webpack_require__(146);
	
	var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);
	
	var _applyMiddleware = __webpack_require__(147);
	
	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);
	
	var _compose = __webpack_require__(148);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	var _warning = __webpack_require__(145);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/*
	* This is a dummy function to check if the function name has been altered by minification.
	* If the function has been minified and NODE_ENV !== 'production', warn the user.
	*/
	function isCrushed() {}
	
	if (false) {
	  (0, _warning2["default"])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
	}
	
	exports.createStore = _createStore2["default"];
	exports.combineReducers = _combineReducers2["default"];
	exports.bindActionCreators = _bindActionCreators2["default"];
	exports.applyMiddleware = _applyMiddleware2["default"];
	exports.compose = _compose2["default"];

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.ActionTypes = undefined;
	exports["default"] = createStore;
	
	var _isPlainObject = __webpack_require__(132);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _symbolObservable = __webpack_require__(142);
	
	var _symbolObservable2 = _interopRequireDefault(_symbolObservable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = exports.ActionTypes = {
	  INIT: '@@redux/INIT'
	};
	
	/**
	 * Creates a Redux store that holds the state tree.
	 * The only way to change the data in the store is to call `dispatch()` on it.
	 *
	 * There should only be a single store in your app. To specify how different
	 * parts of the state tree respond to actions, you may combine several reducers
	 * into a single reducer function by using `combineReducers`.
	 *
	 * @param {Function} reducer A function that returns the next state tree, given
	 * the current state tree and the action to handle.
	 *
	 * @param {any} [initialState] The initial state. You may optionally specify it
	 * to hydrate the state from the server in universal apps, or to restore a
	 * previously serialized user session.
	 * If you use `combineReducers` to produce the root reducer function, this must be
	 * an object with the same shape as `combineReducers` keys.
	 *
	 * @param {Function} enhancer The store enhancer. You may optionally specify it
	 * to enhance the store with third-party capabilities such as middleware,
	 * time travel, persistence, etc. The only store enhancer that ships with Redux
	 * is `applyMiddleware()`.
	 *
	 * @returns {Store} A Redux store that lets you read the state, dispatch actions
	 * and subscribe to changes.
	 */
	function createStore(reducer, initialState, enhancer) {
	  var _ref2;
	
	  if (typeof initialState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = initialState;
	    initialState = undefined;
	  }
	
	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }
	
	    return enhancer(createStore)(reducer, initialState);
	  }
	
	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }
	
	  var currentReducer = reducer;
	  var currentState = initialState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;
	
	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }
	
	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }
	
	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected listener to be a function.');
	    }
	
	    var isSubscribed = true;
	
	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);
	
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }
	
	      isSubscribed = false;
	
	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }
	
	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing “what changed”. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!(0, _isPlainObject2["default"])(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }
	
	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }
	
	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }
	
	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }
	
	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i]();
	    }
	
	    return action;
	  }
	
	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }
	
	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }
	
	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/zenparsing/es-observable
	   */
	  function observable() {
	    var _ref;
	
	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	
	      subscribe: function subscribe(observer) {
	        if (typeof observer !== 'object') {
	          throw new TypeError('Expected the observer to be an object.');
	        }
	
	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }
	
	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return { unsubscribe: unsubscribe };
	      }
	    }, _ref[_symbolObservable2["default"]] = function () {
	      return this;
	    }, _ref;
	  }
	
	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });
	
	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[_symbolObservable2["default"]] = observable, _ref2;
	}

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(133),
	    getPrototype = __webpack_require__(139),
	    isObjectLike = __webpack_require__(141);
	
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';
	
	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);
	
	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString.call(Ctor) == objectCtorString;
	}
	
	module.exports = isPlainObject;


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(134),
	    getRawTag = __webpack_require__(137),
	    objectToString = __webpack_require__(138);
	
	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';
	
	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
	
	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}
	
	module.exports = baseGetTag;


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(135);
	
	/** Built-in value references. */
	var Symbol = root.Symbol;
	
	module.exports = Symbol;


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	var freeGlobal = __webpack_require__(136);
	
	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();
	
	module.exports = root;


/***/ },
/* 136 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
	
	module.exports = freeGlobal;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(134);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;
	
	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
	
	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];
	
	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}
	
	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}
	
	module.exports = getRawTag;


/***/ },
/* 138 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;
	
	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}
	
	module.exports = objectToString;


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(140);
	
	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);
	
	module.exports = getPrototype;


/***/ },
/* 140 */
/***/ function(module, exports) {

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}
	
	module.exports = overArg;


/***/ },
/* 141 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}
	
	module.exports = isObjectLike;


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global window */
	'use strict';
	
	module.exports = __webpack_require__(143)(global || window || this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 143 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function symbolObservablePonyfill(root) {
		var result;
		var Symbol = root.Symbol;
	
		if (typeof Symbol === 'function') {
			if (Symbol.observable) {
				result = Symbol.observable;
			} else {
				result = Symbol('observable');
				Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}
	
		return result;
	};


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = combineReducers;
	
	var _createStore = __webpack_require__(131);
	
	var _isPlainObject = __webpack_require__(132);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _warning = __webpack_require__(145);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function getUndefinedStateErrorMessage(key, action) {
	  var actionType = action && action.type;
	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';
	
	  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
	}
	
	function getUnexpectedStateShapeWarningMessage(inputState, reducers, action) {
	  var reducerKeys = Object.keys(reducers);
	  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';
	
	  if (reducerKeys.length === 0) {
	    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
	  }
	
	  if (!(0, _isPlainObject2["default"])(inputState)) {
	    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
	  }
	
	  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
	    return !reducers.hasOwnProperty(key);
	  });
	
	  if (unexpectedKeys.length > 0) {
	    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
	  }
	}
	
	function assertReducerSanity(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });
	
	    if (typeof initialState === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
	    }
	
	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
	    if (typeof reducer(undefined, { type: type }) === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
	    }
	  });
	}
	
	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */
	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};
	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];
	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  var finalReducerKeys = Object.keys(finalReducers);
	
	  var sanityError;
	  try {
	    assertReducerSanity(finalReducers);
	  } catch (e) {
	    sanityError = e;
	  }
	
	  return function combination() {
	    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    var action = arguments[1];
	
	    if (sanityError) {
	      throw sanityError;
	    }
	
	    if (false) {
	      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action);
	      if (warningMessage) {
	        (0, _warning2["default"])(warningMessage);
	      }
	    }
	
	    var hasChanged = false;
	    var nextState = {};
	    for (var i = 0; i < finalReducerKeys.length; i++) {
	      var key = finalReducerKeys[i];
	      var reducer = finalReducers[key];
	      var previousStateForKey = state[key];
	      var nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === 'undefined') {
	        var errorMessage = getUndefinedStateErrorMessage(key, action);
	        throw new Error(errorMessage);
	      }
	      nextState[key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    return hasChanged ? nextState : state;
	  };
	}

/***/ },
/* 145 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that if you enable
	    // "break on all exceptions" in your console,
	    // it would pause the execution at this line.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 146 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = bindActionCreators;
	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(undefined, arguments));
	  };
	}
	
	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass a single function as the first argument,
	 * and get a function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */
	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }
	
	  if (typeof actionCreators !== 'object' || actionCreators === null) {
	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
	  }
	
	  var keys = Object.keys(actionCreators);
	  var boundActionCreators = {};
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var actionCreator = actionCreators[key];
	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }
	  return boundActionCreators;
	}

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports["default"] = applyMiddleware;
	
	var _compose = __webpack_require__(148);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  return function (createStore) {
	    return function (reducer, initialState, enhancer) {
	      var store = createStore(reducer, initialState, enhancer);
	      var _dispatch = store.dispatch;
	      var chain = [];
	
	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        }
	      };
	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = _compose2["default"].apply(undefined, chain)(store.dispatch);
	
	      return _extends({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

/***/ },
/* 148 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = compose;
	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */
	
	function compose() {
	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }
	
	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  } else {
	    var _ret = function () {
	      var last = funcs[funcs.length - 1];
	      var rest = funcs.slice(0, -1);
	      return {
	        v: function v() {
	          return rest.reduceRight(function (composed, f) {
	            return f(composed);
	          }, last.apply(undefined, arguments));
	        }
	      };
	    }();
	
	    if (typeof _ret === "object") return _ret.v;
	  }
	}

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.connect = exports.Provider = undefined;
	
	var _Provider = __webpack_require__(150);
	
	var _Provider2 = _interopRequireDefault(_Provider);
	
	var _connect = __webpack_require__(153);
	
	var _connect2 = _interopRequireDefault(_connect);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	exports.Provider = _Provider2["default"];
	exports.connect = _connect2["default"];

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = undefined;
	
	var _react = __webpack_require__(2);
	
	var _storeShape = __webpack_require__(151);
	
	var _storeShape2 = _interopRequireDefault(_storeShape);
	
	var _warning = __webpack_require__(152);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var didWarnAboutReceivingStore = false;
	function warnAboutReceivingStore() {
	  if (didWarnAboutReceivingStore) {
	    return;
	  }
	  didWarnAboutReceivingStore = true;
	
	  (0, _warning2["default"])('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
	}
	
	var Provider = function (_Component) {
	  _inherits(Provider, _Component);
	
	  Provider.prototype.getChildContext = function getChildContext() {
	    return { store: this.store };
	  };
	
	  function Provider(props, context) {
	    _classCallCheck(this, Provider);
	
	    var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));
	
	    _this.store = props.store;
	    return _this;
	  }
	
	  Provider.prototype.render = function render() {
	    var children = this.props.children;
	
	    return _react.Children.only(children);
	  };
	
	  return Provider;
	}(_react.Component);
	
	exports["default"] = Provider;
	
	if (false) {
	  Provider.prototype.componentWillReceiveProps = function (nextProps) {
	    var store = this.store;
	    var nextStore = nextProps.store;
	
	    if (store !== nextStore) {
	      warnAboutReceivingStore();
	    }
	  };
	}
	
	Provider.propTypes = {
	  store: _storeShape2["default"].isRequired,
	  children: _react.PropTypes.element.isRequired
	};
	Provider.childContextTypes = {
	  store: _storeShape2["default"].isRequired
	};

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(2);
	
	exports["default"] = _react.PropTypes.shape({
	  subscribe: _react.PropTypes.func.isRequired,
	  dispatch: _react.PropTypes.func.isRequired,
	  getState: _react.PropTypes.func.isRequired
	});

/***/ },
/* 152 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that you can use this stack
	    // to find the callsite that caused this warning to fire.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.__esModule = true;
	exports["default"] = connect;
	
	var _react = __webpack_require__(2);
	
	var _storeShape = __webpack_require__(151);
	
	var _storeShape2 = _interopRequireDefault(_storeShape);
	
	var _shallowEqual = __webpack_require__(154);
	
	var _shallowEqual2 = _interopRequireDefault(_shallowEqual);
	
	var _wrapActionCreators = __webpack_require__(155);
	
	var _wrapActionCreators2 = _interopRequireDefault(_wrapActionCreators);
	
	var _warning = __webpack_require__(152);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _isPlainObject = __webpack_require__(132);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _hoistNonReactStatics = __webpack_require__(156);
	
	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);
	
	var _invariant = __webpack_require__(157);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var defaultMapStateToProps = function defaultMapStateToProps(state) {
	  return {};
	}; // eslint-disable-line no-unused-vars
	var defaultMapDispatchToProps = function defaultMapDispatchToProps(dispatch) {
	  return { dispatch: dispatch };
	};
	var defaultMergeProps = function defaultMergeProps(stateProps, dispatchProps, parentProps) {
	  return _extends({}, parentProps, stateProps, dispatchProps);
	};
	
	function getDisplayName(WrappedComponent) {
	  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
	}
	
	var errorObject = { value: null };
	function tryCatch(fn, ctx) {
	  try {
	    return fn.apply(ctx);
	  } catch (e) {
	    errorObject.value = e;
	    return errorObject;
	  }
	}
	
	// Helps track hot reloading.
	var nextVersion = 0;
	
	function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
	  var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
	
	  var shouldSubscribe = Boolean(mapStateToProps);
	  var mapState = mapStateToProps || defaultMapStateToProps;
	
	  var mapDispatch = undefined;
	  if (typeof mapDispatchToProps === 'function') {
	    mapDispatch = mapDispatchToProps;
	  } else if (!mapDispatchToProps) {
	    mapDispatch = defaultMapDispatchToProps;
	  } else {
	    mapDispatch = (0, _wrapActionCreators2["default"])(mapDispatchToProps);
	  }
	
	  var finalMergeProps = mergeProps || defaultMergeProps;
	  var _options$pure = options.pure;
	  var pure = _options$pure === undefined ? true : _options$pure;
	  var _options$withRef = options.withRef;
	  var withRef = _options$withRef === undefined ? false : _options$withRef;
	
	  var checkMergedEquals = pure && finalMergeProps !== defaultMergeProps;
	
	  // Helps track hot reloading.
	  var version = nextVersion++;
	
	  return function wrapWithConnect(WrappedComponent) {
	    var connectDisplayName = 'Connect(' + getDisplayName(WrappedComponent) + ')';
	
	    function checkStateShape(props, methodName) {
	      if (!(0, _isPlainObject2["default"])(props)) {
	        (0, _warning2["default"])(methodName + '() in ' + connectDisplayName + ' must return a plain object. ' + ('Instead received ' + props + '.'));
	      }
	    }
	
	    function computeMergedProps(stateProps, dispatchProps, parentProps) {
	      var mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps);
	      if (false) {
	        checkStateShape(mergedProps, 'mergeProps');
	      }
	      return mergedProps;
	    }
	
	    var Connect = function (_Component) {
	      _inherits(Connect, _Component);
	
	      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
	        return !pure || this.haveOwnPropsChanged || this.hasStoreStateChanged;
	      };
	
	      function Connect(props, context) {
	        _classCallCheck(this, Connect);
	
	        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));
	
	        _this.version = version;
	        _this.store = props.store || context.store;
	
	        (0, _invariant2["default"])(_this.store, 'Could not find "store" in either the context or ' + ('props of "' + connectDisplayName + '". ') + 'Either wrap the root component in a <Provider>, ' + ('or explicitly pass "store" as a prop to "' + connectDisplayName + '".'));
	
	        var storeState = _this.store.getState();
	        _this.state = { storeState: storeState };
	        _this.clearCache();
	        return _this;
	      }
	
	      Connect.prototype.computeStateProps = function computeStateProps(store, props) {
	        if (!this.finalMapStateToProps) {
	          return this.configureFinalMapState(store, props);
	        }
	
	        var state = store.getState();
	        var stateProps = this.doStatePropsDependOnOwnProps ? this.finalMapStateToProps(state, props) : this.finalMapStateToProps(state);
	
	        if (false) {
	          checkStateShape(stateProps, 'mapStateToProps');
	        }
	        return stateProps;
	      };
	
	      Connect.prototype.configureFinalMapState = function configureFinalMapState(store, props) {
	        var mappedState = mapState(store.getState(), props);
	        var isFactory = typeof mappedState === 'function';
	
	        this.finalMapStateToProps = isFactory ? mappedState : mapState;
	        this.doStatePropsDependOnOwnProps = this.finalMapStateToProps.length !== 1;
	
	        if (isFactory) {
	          return this.computeStateProps(store, props);
	        }
	
	        if (false) {
	          checkStateShape(mappedState, 'mapStateToProps');
	        }
	        return mappedState;
	      };
	
	      Connect.prototype.computeDispatchProps = function computeDispatchProps(store, props) {
	        if (!this.finalMapDispatchToProps) {
	          return this.configureFinalMapDispatch(store, props);
	        }
	
	        var dispatch = store.dispatch;
	
	        var dispatchProps = this.doDispatchPropsDependOnOwnProps ? this.finalMapDispatchToProps(dispatch, props) : this.finalMapDispatchToProps(dispatch);
	
	        if (false) {
	          checkStateShape(dispatchProps, 'mapDispatchToProps');
	        }
	        return dispatchProps;
	      };
	
	      Connect.prototype.configureFinalMapDispatch = function configureFinalMapDispatch(store, props) {
	        var mappedDispatch = mapDispatch(store.dispatch, props);
	        var isFactory = typeof mappedDispatch === 'function';
	
	        this.finalMapDispatchToProps = isFactory ? mappedDispatch : mapDispatch;
	        this.doDispatchPropsDependOnOwnProps = this.finalMapDispatchToProps.length !== 1;
	
	        if (isFactory) {
	          return this.computeDispatchProps(store, props);
	        }
	
	        if (false) {
	          checkStateShape(mappedDispatch, 'mapDispatchToProps');
	        }
	        return mappedDispatch;
	      };
	
	      Connect.prototype.updateStatePropsIfNeeded = function updateStatePropsIfNeeded() {
	        var nextStateProps = this.computeStateProps(this.store, this.props);
	        if (this.stateProps && (0, _shallowEqual2["default"])(nextStateProps, this.stateProps)) {
	          return false;
	        }
	
	        this.stateProps = nextStateProps;
	        return true;
	      };
	
	      Connect.prototype.updateDispatchPropsIfNeeded = function updateDispatchPropsIfNeeded() {
	        var nextDispatchProps = this.computeDispatchProps(this.store, this.props);
	        if (this.dispatchProps && (0, _shallowEqual2["default"])(nextDispatchProps, this.dispatchProps)) {
	          return false;
	        }
	
	        this.dispatchProps = nextDispatchProps;
	        return true;
	      };
	
	      Connect.prototype.updateMergedPropsIfNeeded = function updateMergedPropsIfNeeded() {
	        var nextMergedProps = computeMergedProps(this.stateProps, this.dispatchProps, this.props);
	        if (this.mergedProps && checkMergedEquals && (0, _shallowEqual2["default"])(nextMergedProps, this.mergedProps)) {
	          return false;
	        }
	
	        this.mergedProps = nextMergedProps;
	        return true;
	      };
	
	      Connect.prototype.isSubscribed = function isSubscribed() {
	        return typeof this.unsubscribe === 'function';
	      };
	
	      Connect.prototype.trySubscribe = function trySubscribe() {
	        if (shouldSubscribe && !this.unsubscribe) {
	          this.unsubscribe = this.store.subscribe(this.handleChange.bind(this));
	          this.handleChange();
	        }
	      };
	
	      Connect.prototype.tryUnsubscribe = function tryUnsubscribe() {
	        if (this.unsubscribe) {
	          this.unsubscribe();
	          this.unsubscribe = null;
	        }
	      };
	
	      Connect.prototype.componentDidMount = function componentDidMount() {
	        this.trySubscribe();
	      };
	
	      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        if (!pure || !(0, _shallowEqual2["default"])(nextProps, this.props)) {
	          this.haveOwnPropsChanged = true;
	        }
	      };
	
	      Connect.prototype.componentWillUnmount = function componentWillUnmount() {
	        this.tryUnsubscribe();
	        this.clearCache();
	      };
	
	      Connect.prototype.clearCache = function clearCache() {
	        this.dispatchProps = null;
	        this.stateProps = null;
	        this.mergedProps = null;
	        this.haveOwnPropsChanged = true;
	        this.hasStoreStateChanged = true;
	        this.haveStatePropsBeenPrecalculated = false;
	        this.statePropsPrecalculationError = null;
	        this.renderedElement = null;
	        this.finalMapDispatchToProps = null;
	        this.finalMapStateToProps = null;
	      };
	
	      Connect.prototype.handleChange = function handleChange() {
	        if (!this.unsubscribe) {
	          return;
	        }
	
	        var storeState = this.store.getState();
	        var prevStoreState = this.state.storeState;
	        if (pure && prevStoreState === storeState) {
	          return;
	        }
	
	        if (pure && !this.doStatePropsDependOnOwnProps) {
	          var haveStatePropsChanged = tryCatch(this.updateStatePropsIfNeeded, this);
	          if (!haveStatePropsChanged) {
	            return;
	          }
	          if (haveStatePropsChanged === errorObject) {
	            this.statePropsPrecalculationError = errorObject.value;
	          }
	          this.haveStatePropsBeenPrecalculated = true;
	        }
	
	        this.hasStoreStateChanged = true;
	        this.setState({ storeState: storeState });
	      };
	
	      Connect.prototype.getWrappedInstance = function getWrappedInstance() {
	        (0, _invariant2["default"])(withRef, 'To access the wrapped instance, you need to specify ' + '{ withRef: true } as the fourth argument of the connect() call.');
	
	        return this.refs.wrappedInstance;
	      };
	
	      Connect.prototype.render = function render() {
	        var haveOwnPropsChanged = this.haveOwnPropsChanged;
	        var hasStoreStateChanged = this.hasStoreStateChanged;
	        var haveStatePropsBeenPrecalculated = this.haveStatePropsBeenPrecalculated;
	        var statePropsPrecalculationError = this.statePropsPrecalculationError;
	        var renderedElement = this.renderedElement;
	
	        this.haveOwnPropsChanged = false;
	        this.hasStoreStateChanged = false;
	        this.haveStatePropsBeenPrecalculated = false;
	        this.statePropsPrecalculationError = null;
	
	        if (statePropsPrecalculationError) {
	          throw statePropsPrecalculationError;
	        }
	
	        var shouldUpdateStateProps = true;
	        var shouldUpdateDispatchProps = true;
	        if (pure && renderedElement) {
	          shouldUpdateStateProps = hasStoreStateChanged || haveOwnPropsChanged && this.doStatePropsDependOnOwnProps;
	          shouldUpdateDispatchProps = haveOwnPropsChanged && this.doDispatchPropsDependOnOwnProps;
	        }
	
	        var haveStatePropsChanged = false;
	        var haveDispatchPropsChanged = false;
	        if (haveStatePropsBeenPrecalculated) {
	          haveStatePropsChanged = true;
	        } else if (shouldUpdateStateProps) {
	          haveStatePropsChanged = this.updateStatePropsIfNeeded();
	        }
	        if (shouldUpdateDispatchProps) {
	          haveDispatchPropsChanged = this.updateDispatchPropsIfNeeded();
	        }
	
	        var haveMergedPropsChanged = true;
	        if (haveStatePropsChanged || haveDispatchPropsChanged || haveOwnPropsChanged) {
	          haveMergedPropsChanged = this.updateMergedPropsIfNeeded();
	        } else {
	          haveMergedPropsChanged = false;
	        }
	
	        if (!haveMergedPropsChanged && renderedElement) {
	          return renderedElement;
	        }
	
	        if (withRef) {
	          this.renderedElement = (0, _react.createElement)(WrappedComponent, _extends({}, this.mergedProps, {
	            ref: 'wrappedInstance'
	          }));
	        } else {
	          this.renderedElement = (0, _react.createElement)(WrappedComponent, this.mergedProps);
	        }
	
	        return this.renderedElement;
	      };
	
	      return Connect;
	    }(_react.Component);
	
	    Connect.displayName = connectDisplayName;
	    Connect.WrappedComponent = WrappedComponent;
	    Connect.contextTypes = {
	      store: _storeShape2["default"]
	    };
	    Connect.propTypes = {
	      store: _storeShape2["default"]
	    };
	
	    if (false) {
	      Connect.prototype.componentWillUpdate = function componentWillUpdate() {
	        if (this.version === version) {
	          return;
	        }
	
	        // We are hot reloading!
	        this.version = version;
	        this.trySubscribe();
	        this.clearCache();
	      };
	    }
	
	    return (0, _hoistNonReactStatics2["default"])(Connect, WrappedComponent);
	  };
	}

/***/ },
/* 154 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = shallowEqual;
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  var hasOwn = Object.prototype.hasOwnProperty;
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
	      return false;
	    }
	  }
	
	  return true;
	}

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = wrapActionCreators;
	
	var _redux = __webpack_require__(130);
	
	function wrapActionCreators(actionCreators) {
	  return function (dispatch) {
	    return (0, _redux.bindActionCreators)(actionCreators, dispatch);
	  };
	}

/***/ },
/* 156 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	'use strict';
	
	var REACT_STATICS = {
	    childContextTypes: true,
	    contextTypes: true,
	    defaultProps: true,
	    displayName: true,
	    getDefaultProps: true,
	    mixins: true,
	    propTypes: true,
	    type: true
	};
	
	var KNOWN_STATICS = {
	    name: true,
	    length: true,
	    prototype: true,
	    caller: true,
	    arguments: true,
	    arity: true
	};
	
	var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';
	
	module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
	    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components
	        var keys = Object.getOwnPropertyNames(sourceComponent);
	
	        /* istanbul ignore else */
	        if (isGetOwnPropertySymbolsAvailable) {
	            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
	        }
	
	        for (var i = 0; i < keys.length; ++i) {
	            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
	                try {
	                    targetComponent[keys[i]] = sourceComponent[keys[i]];
	                } catch (error) {
	
	                }
	            }
	        }
	    }
	
	    return targetComponent;
	};


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var invariant = function(condition, format, a, b, c, d, e, f) {
	  if (false) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};
	
	module.exports = invariant;


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	const { isDevelopment, isTesting } = __webpack_require__(65);
	
	function debugGlobal(field, value) {
	  if (isDevelopment() || isTesting()) {
	    window[field] = value;
	  }
	}
	
	module.exports = {
	  debugGlobal
	};

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	const { sprintf } = __webpack_require__(28);
	let strings = {};
	
	function setBundle(bundle) {
	  strings = bundle;
	}
	
	function getStr(key) {
	  if (!strings[key]) {
	    throw new Error(`L10N key ${ key } cannot be found.`);
	  }
	  return strings[key];
	}
	
	function getFormatStr(name, ...args) {
	  return sprintf(getStr(name), ...args);
	}
	
	module.exports = {
	  getStr,
	  getFormatStr,
	  setBundle
	};

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	const classnames = __webpack_require__(161);
	const { getValue, isDevelopment } = __webpack_require__(65);
	
	__webpack_require__(162);
	
	function themeClass() {
	  const theme = getValue("theme");
	  return `theme-${ theme }`;
	}
	
	const rootClass = classnames("theme-body", { [themeClass()]: isDevelopment() });
	
	module.exports = function (className) {
	  const root = document.createElement("div");
	  root.className = classnames(rootClass, className);
	  root.style.setProperty("flex", 1);
	  return root;
	};

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2016 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */
	
	(function () {
		'use strict';
	
		var hasOwn = {}.hasOwnProperty;
	
		function classNames () {
			var classes = [];
	
			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;
	
				var argType = typeof arg;
	
				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					classes.push(classNames.apply(null, arg));
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}
	
			return classes.join(' ');
		}
	
		if (typeof module !== 'undefined' && module.exports) {
			module.exports = classNames;
		} else if (true) {
			// register as 'classnames', consistent with npm package name
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			window.classNames = classNames;
		}
	}());


/***/ },
/* 162 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	
	
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	/* global window */
	
	const { createStore, applyMiddleware } = __webpack_require__(130);
	const { waitUntilService } = __webpack_require__(167);
	const { log } = __webpack_require__(168);
	const { history } = __webpack_require__(169);
	const { promise } = __webpack_require__(170);
	const { thunk } = __webpack_require__(176);
	
	/**
	 * This creates a dispatcher with all the standard middleware in place
	 * that all code requires. It can also be optionally configured in
	 * various ways, such as logging and recording.
	 *
	 * @param {object} opts:
	 *        - log: log all dispatched actions to console
	 *        - history: an array to store every action in. Should only be
	 *                   used in tests.
	 *        - middleware: array of middleware to be included in the redux store
	 */
	const configureStore = (opts = {}) => {
	  const middleware = [thunk(opts.makeThunkArgs), promise,
	
	  // Order is important: services must go last as they always
	  // operate on "already transformed" actions. Actions going through
	  // them shouldn't have any special fields like promises, they
	  // should just be normal JSON objects.
	  waitUntilService];
	
	  if (opts.history) {
	    middleware.push(history(opts.history));
	  }
	
	  if (opts.middleware) {
	    opts.middleware.forEach(fn => middleware.push(fn));
	  }
	
	  if (opts.log) {
	    middleware.push(log);
	  }
	
	  // Hook in the redux devtools browser extension if it exists
	  const devtoolsExt = typeof window === "object" && window.devToolsExtension ? window.devToolsExtension() : f => f;
	
	  return applyMiddleware(...middleware)(devtoolsExt(createStore));
	};
	
	module.exports = configureStore;

/***/ },
/* 167 */
/***/ function(module, exports) {

	/**
	 * A middleware which acts like a service, because it is stateful
	 * and "long-running" in the background. It provides the ability
	 * for actions to install a function to be run once when a specific
	 * condition is met by an action coming through the system. Think of
	 * it as a thunk that blocks until the condition is met. Example:
	 *
	 * ```js
	 * const services = { WAIT_UNTIL: require('wait-service').NAME };
	 *
	 * { type: services.WAIT_UNTIL,
	 *   predicate: action => action.type === constants.ADD_ITEM,
	 *   run: (dispatch, getState, action) => {
	 *     // Do anything here. You only need to accept the arguments
	 *     // if you need them. `action` is the action that satisfied
	 *     // the predicate.
	 *   }
	 * }
	 * ```
	 */
	const NAME = exports.NAME = "@@service/waitUntil";
	
	function waitUntilService({ dispatch, getState }) {
	  let pending = [];
	
	  function checkPending(action) {
	    let readyRequests = [];
	    let stillPending = [];
	
	    // Find the pending requests whose predicates are satisfied with
	    // this action. Wait to run the requests until after we update the
	    // pending queue because the request handler may synchronously
	    // dispatch again and run this service (that use case is
	    // completely valid).
	    for (let request of pending) {
	      if (request.predicate(action)) {
	        readyRequests.push(request);
	      } else {
	        stillPending.push(request);
	      }
	    }
	
	    pending = stillPending;
	    for (let request of readyRequests) {
	      request.run(dispatch, getState, action);
	    }
	  }
	
	  return next => action => {
	    if (action.type === NAME) {
	      pending.push(action);
	      return null;
	    }
	    let result = next(action);
	    checkPending(action);
	    return result;
	  };
	}
	exports.waitUntilService = waitUntilService;

/***/ },
/* 168 */
/***/ function(module, exports) {

	/**
	 * A middleware that logs all actions coming through the system
	 * to the console.
	 */
	function log({ dispatch, getState }) {
	  return next => action => {
	    const actionText = JSON.stringify(action, null, 2);
	    const truncatedActionText = `${ actionText.slice(0, 1000) }...`;
	    console.log(`[DISPATCH ${ action.type }]`, action, truncatedActionText);
	    next(action);
	  };
	}
	
	exports.log = log;

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	const { isDevelopment } = __webpack_require__(65);
	
	/**
	 * A middleware that stores every action coming through the store in the passed
	 * in logging object. Should only be used for tests, as it collects all
	 * action information, which will cause memory bloat.
	 */
	exports.history = (log = []) => ({ dispatch, getState }) => {
	  if (isDevelopment()) {
	    console.warn("Using history middleware stores all actions in state for " + "testing and devtools is not currently running in test " + "mode. Be sure this is intentional.");
	  }
	  return next => action => {
	    log.push(action);
	    next(action);
	  };
	};

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	const defer = __webpack_require__(171);
	const { entries, toObject } = __webpack_require__(172);
	const { executeSoon } = __webpack_require__(174);
	
	const PROMISE = exports.PROMISE = "@@dispatch/promise";
	let seqIdVal = 1;
	
	function seqIdGen() {
	  return seqIdVal++;
	}
	
	function promiseMiddleware({ dispatch, getState }) {
	  return next => action => {
	    if (!(PROMISE in action)) {
	      return next(action);
	    }
	
	    const promiseInst = action[PROMISE];
	    const seqId = seqIdGen().toString();
	
	    // Create a new action that doesn't have the promise field and has
	    // the `seqId` field that represents the sequence id
	    action = Object.assign(toObject(entries(action).filter(pair => pair[0] !== PROMISE)), { seqId });
	
	    dispatch(Object.assign({}, action, { status: "start" }));
	
	    // Return the promise so action creators can still compose if they
	    // want to.
	    const deferred = defer();
	    promiseInst.then(value => {
	      executeSoon(() => {
	        dispatch(Object.assign({}, action, {
	          status: "done",
	          value: value
	        }));
	        deferred.resolve(value);
	      });
	    }, error => {
	      executeSoon(() => {
	        dispatch(Object.assign({}, action, {
	          status: "error",
	          error: error.message || error
	        }));
	        deferred.reject(error);
	      });
	    });
	    return deferred.promise;
	  };
	}
	
	exports.promise = promiseMiddleware;

/***/ },
/* 171 */
/***/ function(module, exports) {

	module.exports = function defer() {
	  let resolve, reject;
	  let promise = new Promise(function () {
	    resolve = arguments[0];
	    reject = arguments[1];
	  });
	  return {
	    resolve: resolve,
	    reject: reject,
	    promise: promise
	  };
	};

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	
	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	const co = __webpack_require__(173);
	
	function asPaused(client, func) {
	  if (client.state != "paused") {
	    return co(function* () {
	      yield client.interrupt();
	      let result;
	
	      try {
	        result = yield func();
	      } catch (e) {
	        // Try to put the debugger back in a working state by resuming
	        // it
	        yield client.resume();
	        throw e;
	      }
	
	      yield client.resume();
	      return result;
	    });
	  }
	  return func();
	}
	
	function handleError(err) {
	  console.log("ERROR: ", err);
	}
	
	function promisify(context, method, ...args) {
	  return new Promise((resolve, reject) => {
	    args.push(response => {
	      if (response.error) {
	        reject(response);
	      } else {
	        resolve(response);
	      }
	    });
	    method.apply(context, args);
	  });
	}
	
	function truncateStr(str, size) {
	  if (str.length > size) {
	    return `${ str.slice(0, size) }...`;
	  }
	  return str;
	}
	
	function endTruncateStr(str, size) {
	  if (str.length > size) {
	    return `...${ str.slice(str.length - size) }`;
	  }
	  return str;
	}
	
	let msgId = 1;
	function workerTask(worker, method) {
	  return function (...args) {
	    return new Promise((resolve, reject) => {
	      const id = msgId++;
	      worker.postMessage({ id, method, args });
	
	      const listener = ({ data: result }) => {
	        if (result.id !== id) {
	          return;
	        }
	
	        worker.removeEventListener("message", listener);
	        if (result.error) {
	          reject(result.error);
	        } else {
	          resolve(result.response);
	        }
	      };
	
	      worker.addEventListener("message", listener);
	    });
	  };
	}
	
	/**
	 * Interleaves two arrays element by element, returning the combined array, like
	 * a zip. In the case of arrays with different sizes, undefined values will be
	 * interleaved at the end along with the extra values of the larger array.
	 *
	 * @param Array a
	 * @param Array b
	 * @returns Array
	 *          The combined array, in the form [a1, b1, a2, b2, ...]
	 */
	function zip(a, b) {
	  if (!b) {
	    return a;
	  }
	  if (!a) {
	    return b;
	  }
	  const pairs = [];
	  for (let i = 0, aLength = a.length, bLength = b.length; i < aLength || i < bLength; i++) {
	    pairs.push([a[i], b[i]]);
	  }
	  return pairs;
	}
	
	/**
	 * Converts an object into an array with 2-element arrays as key/value
	 * pairs of the object. `{ foo: 1, bar: 2}` would become
	 * `[[foo, 1], [bar 2]]` (order not guaranteed);
	 *
	 * @param object obj
	 * @returns array
	 */
	function entries(obj) {
	  return Object.keys(obj).map(k => [k, obj[k]]);
	}
	
	function mapObject(obj, iteratee) {
	  return toObject(entries(obj).map(([key, value]) => {
	    return [key, iteratee(key, value)];
	  }));
	}
	
	/**
	 * Takes an array of 2-element arrays as key/values pairs and
	 * constructs an object using them.
	 */
	function toObject(arr) {
	  const obj = {};
	  for (let pair of arr) {
	    obj[pair[0]] = pair[1];
	  }
	  return obj;
	}
	
	/**
	 * Composes the given functions into a single function, which will
	 * apply the results of each function right-to-left, starting with
	 * applying the given arguments to the right-most function.
	 * `compose(foo, bar, baz)` === `args => foo(bar(baz(args)`
	 *
	 * @param ...function funcs
	 * @returns function
	 */
	function compose(...funcs) {
	  return (...args) => {
	    const initialValue = funcs[funcs.length - 1].apply(null, args);
	    const leftFuncs = funcs.slice(0, -1);
	    return leftFuncs.reduceRight((composed, f) => f(composed), initialValue);
	  };
	}
	
	function updateObj(obj, fields) {
	  return Object.assign({}, obj, fields);
	}
	
	function throttle(func, ms) {
	  let timeout, _this;
	  return function (...args) {
	    _this = this;
	    if (!timeout) {
	      timeout = setTimeout(() => {
	        func.apply(_this, ...args);
	        timeout = null;
	      }, ms);
	    }
	  };
	}
	
	module.exports = {
	  asPaused,
	  handleError,
	  promisify,
	  truncateStr,
	  endTruncateStr,
	  workerTask,
	  zip,
	  entries,
	  toObject,
	  mapObject,
	  compose,
	  updateObj,
	  throttle
	};

/***/ },
/* 173 */
/***/ function(module, exports) {

	
	/**
	 * slice() reference.
	 */
	
	var slice = Array.prototype.slice;
	
	/**
	 * Expose `co`.
	 */
	
	module.exports = co['default'] = co.co = co;
	
	/**
	 * Wrap the given generator `fn` into a
	 * function that returns a promise.
	 * This is a separate function so that
	 * every `co()` call doesn't create a new,
	 * unnecessary closure.
	 *
	 * @param {GeneratorFunction} fn
	 * @return {Function}
	 * @api public
	 */
	
	co.wrap = function (fn) {
	  createPromise.__generatorFunction__ = fn;
	  return createPromise;
	  function createPromise() {
	    return co.call(this, fn.apply(this, arguments));
	  }
	};
	
	/**
	 * Execute the generator function or a generator
	 * and return a promise.
	 *
	 * @param {Function} fn
	 * @return {Promise}
	 * @api public
	 */
	
	function co(gen) {
	  var ctx = this;
	  var args = slice.call(arguments, 1)
	
	  // we wrap everything in a promise to avoid promise chaining,
	  // which leads to memory leak errors.
	  // see https://github.com/tj/co/issues/180
	  return new Promise(function(resolve, reject) {
	    if (typeof gen === 'function') gen = gen.apply(ctx, args);
	    if (!gen || typeof gen.next !== 'function') return resolve(gen);
	
	    onFulfilled();
	
	    /**
	     * @param {Mixed} res
	     * @return {Promise}
	     * @api private
	     */
	
	    function onFulfilled(res) {
	      var ret;
	      try {
	        ret = gen.next(res);
	      } catch (e) {
	        return reject(e);
	      }
	      next(ret);
	    }
	
	    /**
	     * @param {Error} err
	     * @return {Promise}
	     * @api private
	     */
	
	    function onRejected(err) {
	      var ret;
	      try {
	        ret = gen.throw(err);
	      } catch (e) {
	        return reject(e);
	      }
	      next(ret);
	    }
	
	    /**
	     * Get the next value in the generator,
	     * return a promise.
	     *
	     * @param {Object} ret
	     * @return {Promise}
	     * @api private
	     */
	
	    function next(ret) {
	      if (ret.done) return resolve(ret.value);
	      var value = toPromise.call(ctx, ret.value);
	      if (value && isPromise(value)) return value.then(onFulfilled, onRejected);
	      return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, '
	        + 'but the following object was passed: "' + String(ret.value) + '"'));
	    }
	  });
	}
	
	/**
	 * Convert a `yield`ed value into a promise.
	 *
	 * @param {Mixed} obj
	 * @return {Promise}
	 * @api private
	 */
	
	function toPromise(obj) {
	  if (!obj) return obj;
	  if (isPromise(obj)) return obj;
	  if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);
	  if ('function' == typeof obj) return thunkToPromise.call(this, obj);
	  if (Array.isArray(obj)) return arrayToPromise.call(this, obj);
	  if (isObject(obj)) return objectToPromise.call(this, obj);
	  return obj;
	}
	
	/**
	 * Convert a thunk to a promise.
	 *
	 * @param {Function}
	 * @return {Promise}
	 * @api private
	 */
	
	function thunkToPromise(fn) {
	  var ctx = this;
	  return new Promise(function (resolve, reject) {
	    fn.call(ctx, function (err, res) {
	      if (err) return reject(err);
	      if (arguments.length > 2) res = slice.call(arguments, 1);
	      resolve(res);
	    });
	  });
	}
	
	/**
	 * Convert an array of "yieldables" to a promise.
	 * Uses `Promise.all()` internally.
	 *
	 * @param {Array} obj
	 * @return {Promise}
	 * @api private
	 */
	
	function arrayToPromise(obj) {
	  return Promise.all(obj.map(toPromise, this));
	}
	
	/**
	 * Convert an object of "yieldables" to a promise.
	 * Uses `Promise.all()` internally.
	 *
	 * @param {Object} obj
	 * @return {Promise}
	 * @api private
	 */
	
	function objectToPromise(obj){
	  var results = new obj.constructor();
	  var keys = Object.keys(obj);
	  var promises = [];
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var promise = toPromise.call(this, obj[key]);
	    if (promise && isPromise(promise)) defer(promise, key);
	    else results[key] = obj[key];
	  }
	  return Promise.all(promises).then(function () {
	    return results;
	  });
	
	  function defer(promise, key) {
	    // predefine the key in the result
	    results[key] = undefined;
	    promises.push(promise.then(function (res) {
	      results[key] = res;
	    }));
	  }
	}
	
	/**
	 * Check if `obj` is a promise.
	 *
	 * @param {Object} obj
	 * @return {Boolean}
	 * @api private
	 */
	
	function isPromise(obj) {
	  return 'function' == typeof obj.then;
	}
	
	/**
	 * Check if `obj` is a generator.
	 *
	 * @param {Mixed} obj
	 * @return {Boolean}
	 * @api private
	 */
	
	function isGenerator(obj) {
	  return 'function' == typeof obj.next && 'function' == typeof obj.throw;
	}
	
	/**
	 * Check if `obj` is a generator function.
	 *
	 * @param {Mixed} obj
	 * @return {Boolean}
	 * @api private
	 */
	function isGeneratorFunction(obj) {
	  var constructor = obj.constructor;
	  if (!constructor) return false;
	  if ('GeneratorFunction' === constructor.name || 'GeneratorFunction' === constructor.displayName) return true;
	  return isGenerator(constructor.prototype);
	}
	
	/**
	 * Check for plain object.
	 *
	 * @param {Mixed} val
	 * @return {Boolean}
	 * @api private
	 */
	
	function isObject(val) {
	  return Object == val.constructor;
	}


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	const assert = __webpack_require__(175);
	
	function reportException(who, exception) {
	  let msg = `${ who } threw an exception: `;
	  console.error(msg, exception);
	}
	
	function executeSoon(fn) {
	  setTimeout(fn, 0);
	}
	
	module.exports = {
	  reportException,
	  executeSoon,
	  assert
	};

/***/ },
/* 175 */
/***/ function(module, exports) {

	function assert(condition, message) {
	  if (!condition) {
	    throw new Error(`Assertion failure: ${ message }`);
	  }
	}
	
	module.exports = assert;

/***/ },
/* 176 */
/***/ function(module, exports) {

	
	/**
	 * A middleware that allows thunks (functions) to be dispatched. If
	 * it's a thunk, it is called with an argument that contains
	 * `dispatch`, `getState`, and any additional args passed in via the
	 * middleware constructure. This allows the action to create multiple
	 * actions (most likely asynchronously).
	 */
	function thunk(makeArgs) {
	  return ({ dispatch, getState }) => {
	    const args = { dispatch, getState };
	
	    return next => action => {
	      return typeof action === "function" ? action(makeArgs ? makeArgs(args, getState()) : args) : next(action);
	    };
	  };
	}
	exports.thunk = thunk;

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	const tabs = __webpack_require__(178);
	
	module.exports = {
	  tabs
	};

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	const constants = __webpack_require__(179);
	const Immutable = __webpack_require__(180);
	const fromJS = __webpack_require__(181);
	
	const initialState = fromJS({
	  tabs: {},
	  selectedTab: null,
	  filterString: ""
	});
	
	function update(state = initialState, action) {
	  switch (action.type) {
	    case constants.ADD_TABS:
	      const tabs = action.value;
	      if (!tabs) {
	        return state;
	      }
	
	      return state.mergeIn(["tabs"], Immutable.Map(tabs.map(tab => {
	        tab = Object.assign({}, tab, { id: getTabId(tab) });
	        return [tab.id, Immutable.Map(tab)];
	      })));
	
	    case constants.SELECT_TAB:
	      const tabToSelect = state.getIn(["tabs", action.id]);
	      return state.setIn(["selectedTab"], tabToSelect);
	
	    case constants.FILTER_TABS:
	      return state.setIn(["filterString"], action.value);
	  }
	
	  return state;
	}
	
	function getTabId(tab) {
	  let id = tab.id;
	  const isFirefox = tab.clientType == "firefox";
	
	  // NOTE: we're getting the last part of the actor because
	  // we want to ignore the connection id
	  if (isFirefox) {
	    id = tab.id.split(".").pop();
	  }
	
	  return id;
	}
	
	module.exports = update;

/***/ },
/* 179 */
/***/ function(module, exports) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	module.exports = {
	  ADD_TABS: "ADD_TABS",
	  SELECT_TAB: "SELECT_TAB",
	  FILTER_TABS: "FILTER_TABS"
	};

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 *  Copyright (c) 2014-2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  (global.Immutable = factory());
	}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;
	
	  function createClass(ctor, superClass) {
	    if (superClass) {
	      ctor.prototype = Object.create(superClass.prototype);
	    }
	    ctor.prototype.constructor = ctor;
	  }
	
	  function Iterable(value) {
	      return isIterable(value) ? value : Seq(value);
	    }
	
	
	  createClass(KeyedIterable, Iterable);
	    function KeyedIterable(value) {
	      return isKeyed(value) ? value : KeyedSeq(value);
	    }
	
	
	  createClass(IndexedIterable, Iterable);
	    function IndexedIterable(value) {
	      return isIndexed(value) ? value : IndexedSeq(value);
	    }
	
	
	  createClass(SetIterable, Iterable);
	    function SetIterable(value) {
	      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
	    }
	
	
	
	  function isIterable(maybeIterable) {
	    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
	  }
	
	  function isKeyed(maybeKeyed) {
	    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
	  }
	
	  function isIndexed(maybeIndexed) {
	    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
	  }
	
	  function isAssociative(maybeAssociative) {
	    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
	  }
	
	  function isOrdered(maybeOrdered) {
	    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
	  }
	
	  Iterable.isIterable = isIterable;
	  Iterable.isKeyed = isKeyed;
	  Iterable.isIndexed = isIndexed;
	  Iterable.isAssociative = isAssociative;
	  Iterable.isOrdered = isOrdered;
	
	  Iterable.Keyed = KeyedIterable;
	  Iterable.Indexed = IndexedIterable;
	  Iterable.Set = SetIterable;
	
	
	  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
	
	  // Used for setting prototype methods that IE8 chokes on.
	  var DELETE = 'delete';
	
	  // Constants describing the size of trie nodes.
	  var SHIFT = 5; // Resulted in best performance after ______?
	  var SIZE = 1 << SHIFT;
	  var MASK = SIZE - 1;
	
	  // A consistent shared value representing "not set" which equals nothing other
	  // than itself, and nothing that could be provided externally.
	  var NOT_SET = {};
	
	  // Boolean references, Rough equivalent of `bool &`.
	  var CHANGE_LENGTH = { value: false };
	  var DID_ALTER = { value: false };
	
	  function MakeRef(ref) {
	    ref.value = false;
	    return ref;
	  }
	
	  function SetRef(ref) {
	    ref && (ref.value = true);
	  }
	
	  // A function which returns a value representing an "owner" for transient writes
	  // to tries. The return value will only ever equal itself, and will not equal
	  // the return of any subsequent call of this function.
	  function OwnerID() {}
	
	  // http://jsperf.com/copy-array-inline
	  function arrCopy(arr, offset) {
	    offset = offset || 0;
	    var len = Math.max(0, arr.length - offset);
	    var newArr = new Array(len);
	    for (var ii = 0; ii < len; ii++) {
	      newArr[ii] = arr[ii + offset];
	    }
	    return newArr;
	  }
	
	  function ensureSize(iter) {
	    if (iter.size === undefined) {
	      iter.size = iter.__iterate(returnTrue);
	    }
	    return iter.size;
	  }
	
	  function wrapIndex(iter, index) {
	    // This implements "is array index" which the ECMAString spec defines as:
	    //
	    //     A String property name P is an array index if and only if
	    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
	    //     to 2^32−1.
	    //
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
	    if (typeof index !== 'number') {
	      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
	      if ('' + uint32Index !== index || uint32Index === 4294967295) {
	        return NaN;
	      }
	      index = uint32Index;
	    }
	    return index < 0 ? ensureSize(iter) + index : index;
	  }
	
	  function returnTrue() {
	    return true;
	  }
	
	  function wholeSlice(begin, end, size) {
	    return (begin === 0 || (size !== undefined && begin <= -size)) &&
	      (end === undefined || (size !== undefined && end >= size));
	  }
	
	  function resolveBegin(begin, size) {
	    return resolveIndex(begin, size, 0);
	  }
	
	  function resolveEnd(end, size) {
	    return resolveIndex(end, size, size);
	  }
	
	  function resolveIndex(index, size, defaultIndex) {
	    return index === undefined ?
	      defaultIndex :
	      index < 0 ?
	        Math.max(0, size + index) :
	        size === undefined ?
	          index :
	          Math.min(size, index);
	  }
	
	  /* global Symbol */
	
	  var ITERATE_KEYS = 0;
	  var ITERATE_VALUES = 1;
	  var ITERATE_ENTRIES = 2;
	
	  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator';
	
	  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
	
	
	  function Iterator(next) {
	      this.next = next;
	    }
	
	    Iterator.prototype.toString = function() {
	      return '[Iterator]';
	    };
	
	
	  Iterator.KEYS = ITERATE_KEYS;
	  Iterator.VALUES = ITERATE_VALUES;
	  Iterator.ENTRIES = ITERATE_ENTRIES;
	
	  Iterator.prototype.inspect =
	  Iterator.prototype.toSource = function () { return this.toString(); }
	  Iterator.prototype[ITERATOR_SYMBOL] = function () {
	    return this;
	  };
	
	
	  function iteratorValue(type, k, v, iteratorResult) {
	    var value = type === 0 ? k : type === 1 ? v : [k, v];
	    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
	      value: value, done: false
	    });
	    return iteratorResult;
	  }
	
	  function iteratorDone() {
	    return { value: undefined, done: true };
	  }
	
	  function hasIterator(maybeIterable) {
	    return !!getIteratorFn(maybeIterable);
	  }
	
	  function isIterator(maybeIterator) {
	    return maybeIterator && typeof maybeIterator.next === 'function';
	  }
	
	  function getIterator(iterable) {
	    var iteratorFn = getIteratorFn(iterable);
	    return iteratorFn && iteratorFn.call(iterable);
	  }
	
	  function getIteratorFn(iterable) {
	    var iteratorFn = iterable && (
	      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
	      iterable[FAUX_ITERATOR_SYMBOL]
	    );
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }
	
	  function isArrayLike(value) {
	    return value && typeof value.length === 'number';
	  }
	
	  createClass(Seq, Iterable);
	    function Seq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        isIterable(value) ? value.toSeq() : seqFromValue(value);
	    }
	
	    Seq.of = function(/*...values*/) {
	      return Seq(arguments);
	    };
	
	    Seq.prototype.toSeq = function() {
	      return this;
	    };
	
	    Seq.prototype.toString = function() {
	      return this.__toString('Seq {', '}');
	    };
	
	    Seq.prototype.cacheResult = function() {
	      if (!this._cache && this.__iterateUncached) {
	        this._cache = this.entrySeq().toArray();
	        this.size = this._cache.length;
	      }
	      return this;
	    };
	
	    // abstract __iterateUncached(fn, reverse)
	
	    Seq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, true);
	    };
	
	    // abstract __iteratorUncached(type, reverse)
	
	    Seq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, true);
	    };
	
	
	
	  createClass(KeyedSeq, Seq);
	    function KeyedSeq(value) {
	      return value === null || value === undefined ?
	        emptySequence().toKeyedSeq() :
	        isIterable(value) ?
	          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
	          keyedSeqFromValue(value);
	    }
	
	    KeyedSeq.prototype.toKeyedSeq = function() {
	      return this;
	    };
	
	
	
	  createClass(IndexedSeq, Seq);
	    function IndexedSeq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
	    }
	
	    IndexedSeq.of = function(/*...values*/) {
	      return IndexedSeq(arguments);
	    };
	
	    IndexedSeq.prototype.toIndexedSeq = function() {
	      return this;
	    };
	
	    IndexedSeq.prototype.toString = function() {
	      return this.__toString('Seq [', ']');
	    };
	
	    IndexedSeq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, false);
	    };
	
	    IndexedSeq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, false);
	    };
	
	
	
	  createClass(SetSeq, Seq);
	    function SetSeq(value) {
	      return (
	        value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value
	      ).toSetSeq();
	    }
	
	    SetSeq.of = function(/*...values*/) {
	      return SetSeq(arguments);
	    };
	
	    SetSeq.prototype.toSetSeq = function() {
	      return this;
	    };
	
	
	
	  Seq.isSeq = isSeq;
	  Seq.Keyed = KeyedSeq;
	  Seq.Set = SetSeq;
	  Seq.Indexed = IndexedSeq;
	
	  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';
	
	  Seq.prototype[IS_SEQ_SENTINEL] = true;
	
	
	
	  createClass(ArraySeq, IndexedSeq);
	    function ArraySeq(array) {
	      this._array = array;
	      this.size = array.length;
	    }
	
	    ArraySeq.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
	    };
	
	    ArraySeq.prototype.__iterate = function(fn, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };
	
	    ArraySeq.prototype.__iterator = function(type, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
	      );
	    };
	
	
	
	  createClass(ObjectSeq, KeyedSeq);
	    function ObjectSeq(object) {
	      var keys = Object.keys(object);
	      this._object = object;
	      this._keys = keys;
	      this.size = keys.length;
	    }
	
	    ObjectSeq.prototype.get = function(key, notSetValue) {
	      if (notSetValue !== undefined && !this.has(key)) {
	        return notSetValue;
	      }
	      return this._object[key];
	    };
	
	    ObjectSeq.prototype.has = function(key) {
	      return this._object.hasOwnProperty(key);
	    };
	
	    ObjectSeq.prototype.__iterate = function(fn, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        if (fn(object[key], key, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };
	
	    ObjectSeq.prototype.__iterator = function(type, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, key, object[key]);
	      });
	    };
	
	  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;
	
	
	  createClass(IterableSeq, IndexedSeq);
	    function IterableSeq(iterable) {
	      this._iterable = iterable;
	      this.size = iterable.length || iterable.size;
	    }
	
	    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      var iterations = 0;
	      if (isIterator(iterator)) {
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (fn(step.value, iterations++, this) === false) {
	            break;
	          }
	        }
	      }
	      return iterations;
	    };
	
	    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      if (!isIterator(iterator)) {
	        return new Iterator(iteratorDone);
	      }
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, iterations++, step.value);
	      });
	    };
	
	
	
	  createClass(IteratorSeq, IndexedSeq);
	    function IteratorSeq(iterator) {
	      this._iterator = iterator;
	      this._iteratorCache = [];
	    }
	
	    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      while (iterations < cache.length) {
	        if (fn(cache[iterations], iterations++, this) === false) {
	          return iterations;
	        }
	      }
	      var step;
	      while (!(step = iterator.next()).done) {
	        var val = step.value;
	        cache[iterations] = val;
	        if (fn(val, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	
	    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      return new Iterator(function()  {
	        if (iterations >= cache.length) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          cache[iterations] = step.value;
	        }
	        return iteratorValue(type, iterations, cache[iterations++]);
	      });
	    };
	
	
	
	
	  // # pragma Helper functions
	
	  function isSeq(maybeSeq) {
	    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
	  }
	
	  var EMPTY_SEQ;
	
	  function emptySequence() {
	    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
	  }
	
	  function keyedSeqFromValue(value) {
	    var seq =
	      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
	      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
	      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
	      typeof value === 'object' ? new ObjectSeq(value) :
	      undefined;
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of [k, v] entries, '+
	        'or keyed object: ' + value
	      );
	    }
	    return seq;
	  }
	
	  function indexedSeqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value);
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values: ' + value
	      );
	    }
	    return seq;
	  }
	
	  function seqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value) ||
	      (typeof value === 'object' && new ObjectSeq(value));
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values, or keyed object: ' + value
	      );
	    }
	    return seq;
	  }
	
	  function maybeIndexedSeqFromValue(value) {
	    return (
	      isArrayLike(value) ? new ArraySeq(value) :
	      isIterator(value) ? new IteratorSeq(value) :
	      hasIterator(value) ? new IterableSeq(value) :
	      undefined
	    );
	  }
	
	  function seqIterate(seq, fn, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    }
	    return seq.__iterateUncached(fn, reverse);
	  }
	
	  function seqIterator(seq, type, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
	      });
	    }
	    return seq.__iteratorUncached(type, reverse);
	  }
	
	  function fromJS(json, converter) {
	    return converter ?
	      fromJSWith(converter, json, '', {'': json}) :
	      fromJSDefault(json);
	  }
	
	  function fromJSWith(converter, json, key, parentJSON) {
	    if (Array.isArray(json)) {
	      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    if (isPlainObj(json)) {
	      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    return json;
	  }
	
	  function fromJSDefault(json) {
	    if (Array.isArray(json)) {
	      return IndexedSeq(json).map(fromJSDefault).toList();
	    }
	    if (isPlainObj(json)) {
	      return KeyedSeq(json).map(fromJSDefault).toMap();
	    }
	    return json;
	  }
	
	  function isPlainObj(value) {
	    return value && (value.constructor === Object || value.constructor === undefined);
	  }
	
	  /**
	   * An extension of the "same-value" algorithm as [described for use by ES6 Map
	   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
	   *
	   * NaN is considered the same as NaN, however -0 and 0 are considered the same
	   * value, which is different from the algorithm described by
	   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
	   *
	   * This is extended further to allow Objects to describe the values they
	   * represent, by way of `valueOf` or `equals` (and `hashCode`).
	   *
	   * Note: because of this extension, the key equality of Immutable.Map and the
	   * value equality of Immutable.Set will differ from ES6 Map and Set.
	   *
	   * ### Defining custom values
	   *
	   * The easiest way to describe the value an object represents is by implementing
	   * `valueOf`. For example, `Date` represents a value by returning a unix
	   * timestamp for `valueOf`:
	   *
	   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
	   *     var date2 = new Date(1234567890000);
	   *     date1.valueOf(); // 1234567890000
	   *     assert( date1 !== date2 );
	   *     assert( Immutable.is( date1, date2 ) );
	   *
	   * Note: overriding `valueOf` may have other implications if you use this object
	   * where JavaScript expects a primitive, such as implicit string coercion.
	   *
	   * For more complex types, especially collections, implementing `valueOf` may
	   * not be performant. An alternative is to implement `equals` and `hashCode`.
	   *
	   * `equals` takes another object, presumably of similar type, and returns true
	   * if the it is equal. Equality is symmetrical, so the same result should be
	   * returned if this and the argument are flipped.
	   *
	   *     assert( a.equals(b) === b.equals(a) );
	   *
	   * `hashCode` returns a 32bit integer number representing the object which will
	   * be used to determine how to store the value object in a Map or Set. You must
	   * provide both or neither methods, one must not exist without the other.
	   *
	   * Also, an important relationship between these methods must be upheld: if two
	   * values are equal, they *must* return the same hashCode. If the values are not
	   * equal, they might have the same hashCode; this is called a hash collision,
	   * and while undesirable for performance reasons, it is acceptable.
	   *
	   *     if (a.equals(b)) {
	   *       assert( a.hashCode() === b.hashCode() );
	   *     }
	   *
	   * All Immutable collections implement `equals` and `hashCode`.
	   *
	   */
	  function is(valueA, valueB) {
	    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	      return true;
	    }
	    if (!valueA || !valueB) {
	      return false;
	    }
	    if (typeof valueA.valueOf === 'function' &&
	        typeof valueB.valueOf === 'function') {
	      valueA = valueA.valueOf();
	      valueB = valueB.valueOf();
	      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	        return true;
	      }
	      if (!valueA || !valueB) {
	        return false;
	      }
	    }
	    if (typeof valueA.equals === 'function' &&
	        typeof valueB.equals === 'function' &&
	        valueA.equals(valueB)) {
	      return true;
	    }
	    return false;
	  }
	
	  function deepEqual(a, b) {
	    if (a === b) {
	      return true;
	    }
	
	    if (
	      !isIterable(b) ||
	      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
	      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
	      isKeyed(a) !== isKeyed(b) ||
	      isIndexed(a) !== isIndexed(b) ||
	      isOrdered(a) !== isOrdered(b)
	    ) {
	      return false;
	    }
	
	    if (a.size === 0 && b.size === 0) {
	      return true;
	    }
	
	    var notAssociative = !isAssociative(a);
	
	    if (isOrdered(a)) {
	      var entries = a.entries();
	      return b.every(function(v, k)  {
	        var entry = entries.next().value;
	        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
	      }) && entries.next().done;
	    }
	
	    var flipped = false;
	
	    if (a.size === undefined) {
	      if (b.size === undefined) {
	        if (typeof a.cacheResult === 'function') {
	          a.cacheResult();
	        }
	      } else {
	        flipped = true;
	        var _ = a;
	        a = b;
	        b = _;
	      }
	    }
	
	    var allEqual = true;
	    var bSize = b.__iterate(function(v, k)  {
	      if (notAssociative ? !a.has(v) :
	          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
	        allEqual = false;
	        return false;
	      }
	    });
	
	    return allEqual && a.size === bSize;
	  }
	
	  createClass(Repeat, IndexedSeq);
	
	    function Repeat(value, times) {
	      if (!(this instanceof Repeat)) {
	        return new Repeat(value, times);
	      }
	      this._value = value;
	      this.size = times === undefined ? Infinity : Math.max(0, times);
	      if (this.size === 0) {
	        if (EMPTY_REPEAT) {
	          return EMPTY_REPEAT;
	        }
	        EMPTY_REPEAT = this;
	      }
	    }
	
	    Repeat.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Repeat []';
	      }
	      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
	    };
	
	    Repeat.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._value : notSetValue;
	    };
	
	    Repeat.prototype.includes = function(searchValue) {
	      return is(this._value, searchValue);
	    };
	
	    Repeat.prototype.slice = function(begin, end) {
	      var size = this.size;
	      return wholeSlice(begin, end, size) ? this :
	        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
	    };
	
	    Repeat.prototype.reverse = function() {
	      return this;
	    };
	
	    Repeat.prototype.indexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return 0;
	      }
	      return -1;
	    };
	
	    Repeat.prototype.lastIndexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return this.size;
	      }
	      return -1;
	    };
	
	    Repeat.prototype.__iterate = function(fn, reverse) {
	      for (var ii = 0; ii < this.size; ii++) {
	        if (fn(this._value, ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };
	
	    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
	      );
	    };
	
	    Repeat.prototype.equals = function(other) {
	      return other instanceof Repeat ?
	        is(this._value, other._value) :
	        deepEqual(other);
	    };
	
	
	  var EMPTY_REPEAT;
	
	  function invariant(condition, error) {
	    if (!condition) throw new Error(error);
	  }
	
	  createClass(Range, IndexedSeq);
	
	    function Range(start, end, step) {
	      if (!(this instanceof Range)) {
	        return new Range(start, end, step);
	      }
	      invariant(step !== 0, 'Cannot step a Range by 0');
	      start = start || 0;
	      if (end === undefined) {
	        end = Infinity;
	      }
	      step = step === undefined ? 1 : Math.abs(step);
	      if (end < start) {
	        step = -step;
	      }
	      this._start = start;
	      this._end = end;
	      this._step = step;
	      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
	      if (this.size === 0) {
	        if (EMPTY_RANGE) {
	          return EMPTY_RANGE;
	        }
	        EMPTY_RANGE = this;
	      }
	    }
	
	    Range.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Range []';
	      }
	      return 'Range [ ' +
	        this._start + '...' + this._end +
	        (this._step !== 1 ? ' by ' + this._step : '') +
	      ' ]';
	    };
	
	    Range.prototype.get = function(index, notSetValue) {
	      return this.has(index) ?
	        this._start + wrapIndex(this, index) * this._step :
	        notSetValue;
	    };
	
	    Range.prototype.includes = function(searchValue) {
	      var possibleIndex = (searchValue - this._start) / this._step;
	      return possibleIndex >= 0 &&
	        possibleIndex < this.size &&
	        possibleIndex === Math.floor(possibleIndex);
	    };
	
	    Range.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      begin = resolveBegin(begin, this.size);
	      end = resolveEnd(end, this.size);
	      if (end <= begin) {
	        return new Range(0, 0);
	      }
	      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
	    };
	
	    Range.prototype.indexOf = function(searchValue) {
	      var offsetValue = searchValue - this._start;
	      if (offsetValue % this._step === 0) {
	        var index = offsetValue / this._step;
	        if (index >= 0 && index < this.size) {
	          return index
	        }
	      }
	      return -1;
	    };
	
	    Range.prototype.lastIndexOf = function(searchValue) {
	      return this.indexOf(searchValue);
	    };
	
	    Range.prototype.__iterate = function(fn, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(value, ii, this) === false) {
	          return ii + 1;
	        }
	        value += reverse ? -step : step;
	      }
	      return ii;
	    };
	
	    Range.prototype.__iterator = function(type, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      var ii = 0;
	      return new Iterator(function()  {
	        var v = value;
	        value += reverse ? -step : step;
	        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
	      });
	    };
	
	    Range.prototype.equals = function(other) {
	      return other instanceof Range ?
	        this._start === other._start &&
	        this._end === other._end &&
	        this._step === other._step :
	        deepEqual(this, other);
	    };
	
	
	  var EMPTY_RANGE;
	
	  createClass(Collection, Iterable);
	    function Collection() {
	      throw TypeError('Abstract');
	    }
	
	
	  createClass(KeyedCollection, Collection);function KeyedCollection() {}
	
	  createClass(IndexedCollection, Collection);function IndexedCollection() {}
	
	  createClass(SetCollection, Collection);function SetCollection() {}
	
	
	  Collection.Keyed = KeyedCollection;
	  Collection.Indexed = IndexedCollection;
	  Collection.Set = SetCollection;
	
	  var imul =
	    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
	    Math.imul :
	    function imul(a, b) {
	      a = a | 0; // int
	      b = b | 0; // int
	      var c = a & 0xffff;
	      var d = b & 0xffff;
	      // Shift by 0 fixes the sign on the high part.
	      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
	    };
	
	  // v8 has an optimization for storing 31-bit signed numbers.
	  // Values which have either 00 or 11 as the high order bits qualify.
	  // This function drops the highest order bit in a signed number, maintaining
	  // the sign bit.
	  function smi(i32) {
	    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
	  }
	
	  function hash(o) {
	    if (o === false || o === null || o === undefined) {
	      return 0;
	    }
	    if (typeof o.valueOf === 'function') {
	      o = o.valueOf();
	      if (o === false || o === null || o === undefined) {
	        return 0;
	      }
	    }
	    if (o === true) {
	      return 1;
	    }
	    var type = typeof o;
	    if (type === 'number') {
	      if (o !== o || o === Infinity) {
	        return 0;
	      }
	      var h = o | 0;
	      if (h !== o) {
	        h ^= o * 0xFFFFFFFF;
	      }
	      while (o > 0xFFFFFFFF) {
	        o /= 0xFFFFFFFF;
	        h ^= o;
	      }
	      return smi(h);
	    }
	    if (type === 'string') {
	      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
	    }
	    if (typeof o.hashCode === 'function') {
	      return o.hashCode();
	    }
	    if (type === 'object') {
	      return hashJSObj(o);
	    }
	    if (typeof o.toString === 'function') {
	      return hashString(o.toString());
	    }
	    throw new Error('Value type ' + type + ' cannot be hashed.');
	  }
	
	  function cachedHashString(string) {
	    var hash = stringHashCache[string];
	    if (hash === undefined) {
	      hash = hashString(string);
	      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
	        STRING_HASH_CACHE_SIZE = 0;
	        stringHashCache = {};
	      }
	      STRING_HASH_CACHE_SIZE++;
	      stringHashCache[string] = hash;
	    }
	    return hash;
	  }
	
	  // http://jsperf.com/hashing-strings
	  function hashString(string) {
	    // This is the hash from JVM
	    // The hash code for a string is computed as
	    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
	    // where s[i] is the ith character of the string and n is the length of
	    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
	    // (exclusive) by dropping high bits.
	    var hash = 0;
	    for (var ii = 0; ii < string.length; ii++) {
	      hash = 31 * hash + string.charCodeAt(ii) | 0;
	    }
	    return smi(hash);
	  }
	
	  function hashJSObj(obj) {
	    var hash;
	    if (usingWeakMap) {
	      hash = weakMap.get(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }
	
	    hash = obj[UID_HASH_KEY];
	    if (hash !== undefined) {
	      return hash;
	    }
	
	    if (!canDefineProperty) {
	      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
	      if (hash !== undefined) {
	        return hash;
	      }
	
	      hash = getIENodeHash(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }
	
	    hash = ++objHashUID;
	    if (objHashUID & 0x40000000) {
	      objHashUID = 0;
	    }
	
	    if (usingWeakMap) {
	      weakMap.set(obj, hash);
	    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
	      throw new Error('Non-extensible objects are not allowed as keys.');
	    } else if (canDefineProperty) {
	      Object.defineProperty(obj, UID_HASH_KEY, {
	        'enumerable': false,
	        'configurable': false,
	        'writable': false,
	        'value': hash
	      });
	    } else if (obj.propertyIsEnumerable !== undefined &&
	               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
	      // Since we can't define a non-enumerable property on the object
	      // we'll hijack one of the less-used non-enumerable properties to
	      // save our hash on it. Since this is a function it will not show up in
	      // `JSON.stringify` which is what we want.
	      obj.propertyIsEnumerable = function() {
	        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
	      };
	      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
	    } else if (obj.nodeType !== undefined) {
	      // At this point we couldn't get the IE `uniqueID` to use as a hash
	      // and we couldn't use a non-enumerable property to exploit the
	      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
	      // itself.
	      obj[UID_HASH_KEY] = hash;
	    } else {
	      throw new Error('Unable to set a non-enumerable property on object.');
	    }
	
	    return hash;
	  }
	
	  // Get references to ES5 object methods.
	  var isExtensible = Object.isExtensible;
	
	  // True if Object.defineProperty works as expected. IE8 fails this test.
	  var canDefineProperty = (function() {
	    try {
	      Object.defineProperty({}, '@', {});
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }());
	
	  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
	  // and avoid memory leaks from the IE cloneNode bug.
	  function getIENodeHash(node) {
	    if (node && node.nodeType > 0) {
	      switch (node.nodeType) {
	        case 1: // Element
	          return node.uniqueID;
	        case 9: // Document
	          return node.documentElement && node.documentElement.uniqueID;
	      }
	    }
	  }
	
	  // If possible, use a WeakMap.
	  var usingWeakMap = typeof WeakMap === 'function';
	  var weakMap;
	  if (usingWeakMap) {
	    weakMap = new WeakMap();
	  }
	
	  var objHashUID = 0;
	
	  var UID_HASH_KEY = '__immutablehash__';
	  if (typeof Symbol === 'function') {
	    UID_HASH_KEY = Symbol(UID_HASH_KEY);
	  }
	
	  var STRING_HASH_CACHE_MIN_STRLEN = 16;
	  var STRING_HASH_CACHE_MAX_SIZE = 255;
	  var STRING_HASH_CACHE_SIZE = 0;
	  var stringHashCache = {};
	
	  function assertNotInfinite(size) {
	    invariant(
	      size !== Infinity,
	      'Cannot perform this action with an infinite size.'
	    );
	  }
	
	  createClass(Map, KeyedCollection);
	
	    // @pragma Construction
	
	    function Map(value) {
	      return value === null || value === undefined ? emptyMap() :
	        isMap(value) && !isOrdered(value) ? value :
	        emptyMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }
	
	    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);
	      return emptyMap().withMutations(function(map ) {
	        for (var i = 0; i < keyValues.length; i += 2) {
	          if (i + 1 >= keyValues.length) {
	            throw new Error('Missing value for key: ' + keyValues[i]);
	          }
	          map.set(keyValues[i], keyValues[i + 1]);
	        }
	      });
	    };
	
	    Map.prototype.toString = function() {
	      return this.__toString('Map {', '}');
	    };
	
	    // @pragma Access
	
	    Map.prototype.get = function(k, notSetValue) {
	      return this._root ?
	        this._root.get(0, undefined, k, notSetValue) :
	        notSetValue;
	    };
	
	    // @pragma Modification
	
	    Map.prototype.set = function(k, v) {
	      return updateMap(this, k, v);
	    };
	
	    Map.prototype.setIn = function(keyPath, v) {
	      return this.updateIn(keyPath, NOT_SET, function()  {return v});
	    };
	
	    Map.prototype.remove = function(k) {
	      return updateMap(this, k, NOT_SET);
	    };
	
	    Map.prototype.deleteIn = function(keyPath) {
	      return this.updateIn(keyPath, function()  {return NOT_SET});
	    };
	
	    Map.prototype.update = function(k, notSetValue, updater) {
	      return arguments.length === 1 ?
	        k(this) :
	        this.updateIn([k], notSetValue, updater);
	    };
	
	    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
	      if (!updater) {
	        updater = notSetValue;
	        notSetValue = undefined;
	      }
	      var updatedValue = updateInDeepMap(
	        this,
	        forceIterator(keyPath),
	        notSetValue,
	        updater
	      );
	      return updatedValue === NOT_SET ? undefined : updatedValue;
	    };
	
	    Map.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._root = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyMap();
	    };
	
	    // @pragma Composition
	
	    Map.prototype.merge = function(/*...iters*/) {
	      return mergeIntoMapWith(this, undefined, arguments);
	    };
	
	    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, merger, iters);
	    };
	
	    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.merge === 'function' ?
	          m.merge.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };
	
	    Map.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoMapWith(this, deepMerger, arguments);
	    };
	
	    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
	    };
	
	    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.mergeDeep === 'function' ?
	          m.mergeDeep.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };
	
	    Map.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator));
	    };
	
	    Map.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator, mapper));
	    };
	
	    // @pragma Mutability
	
	    Map.prototype.withMutations = function(fn) {
	      var mutable = this.asMutable();
	      fn(mutable);
	      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
	    };
	
	    Map.prototype.asMutable = function() {
	      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
	    };
	
	    Map.prototype.asImmutable = function() {
	      return this.__ensureOwner();
	    };
	
	    Map.prototype.wasAltered = function() {
	      return this.__altered;
	    };
	
	    Map.prototype.__iterator = function(type, reverse) {
	      return new MapIterator(this, type, reverse);
	    };
	
	    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      this._root && this._root.iterate(function(entry ) {
	        iterations++;
	        return fn(entry[1], entry[0], this$0);
	      }, reverse);
	      return iterations;
	    };
	
	    Map.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeMap(this.size, this._root, ownerID, this.__hash);
	    };
	
	
	  function isMap(maybeMap) {
	    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
	  }
	
	  Map.isMap = isMap;
	
	  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';
	
	  var MapPrototype = Map.prototype;
	  MapPrototype[IS_MAP_SENTINEL] = true;
	  MapPrototype[DELETE] = MapPrototype.remove;
	  MapPrototype.removeIn = MapPrototype.deleteIn;
	
	
	  // #pragma Trie Nodes
	
	
	
	    function ArrayMapNode(ownerID, entries) {
	      this.ownerID = ownerID;
	      this.entries = entries;
	    }
	
	    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };
	
	    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	
	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;
	
	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }
	
	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);
	
	      if (removed && entries.length === 1) {
	        return; // undefined
	      }
	
	      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
	        return createNodes(ownerID, entries, key, value);
	      }
	
	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);
	
	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }
	
	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }
	
	      return new ArrayMapNode(ownerID, newEntries);
	    };
	
	
	
	
	    function BitmapIndexedNode(ownerID, bitmap, nodes) {
	      this.ownerID = ownerID;
	      this.bitmap = bitmap;
	      this.nodes = nodes;
	    }
	
	    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
	      var bitmap = this.bitmap;
	      return (bitmap & bit) === 0 ? notSetValue :
	        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
	    };
	
	    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var bit = 1 << keyHashFrag;
	      var bitmap = this.bitmap;
	      var exists = (bitmap & bit) !== 0;
	
	      if (!exists && value === NOT_SET) {
	        return this;
	      }
	
	      var idx = popCount(bitmap & (bit - 1));
	      var nodes = this.nodes;
	      var node = exists ? nodes[idx] : undefined;
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	
	      if (newNode === node) {
	        return this;
	      }
	
	      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
	        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
	      }
	
	      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
	        return nodes[idx ^ 1];
	      }
	
	      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
	        return newNode;
	      }
	
	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
	      var newNodes = exists ? newNode ?
	        setIn(nodes, idx, newNode, isEditable) :
	        spliceOut(nodes, idx, isEditable) :
	        spliceIn(nodes, idx, newNode, isEditable);
	
	      if (isEditable) {
	        this.bitmap = newBitmap;
	        this.nodes = newNodes;
	        return this;
	      }
	
	      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
	    };
	
	
	
	
	    function HashArrayMapNode(ownerID, count, nodes) {
	      this.ownerID = ownerID;
	      this.count = count;
	      this.nodes = nodes;
	    }
	
	    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var node = this.nodes[idx];
	      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
	    };
	
	    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var removed = value === NOT_SET;
	      var nodes = this.nodes;
	      var node = nodes[idx];
	
	      if (removed && !node) {
	        return this;
	      }
	
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	      if (newNode === node) {
	        return this;
	      }
	
	      var newCount = this.count;
	      if (!node) {
	        newCount++;
	      } else if (!newNode) {
	        newCount--;
	        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
	          return packNodes(ownerID, nodes, newCount, idx);
	        }
	      }
	
	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newNodes = setIn(nodes, idx, newNode, isEditable);
	
	      if (isEditable) {
	        this.count = newCount;
	        this.nodes = newNodes;
	        return this;
	      }
	
	      return new HashArrayMapNode(ownerID, newCount, newNodes);
	    };
	
	
	
	
	    function HashCollisionNode(ownerID, keyHash, entries) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entries = entries;
	    }
	
	    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };
	
	    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	
	      var removed = value === NOT_SET;
	
	      if (keyHash !== this.keyHash) {
	        if (removed) {
	          return this;
	        }
	        SetRef(didAlter);
	        SetRef(didChangeSize);
	        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
	      }
	
	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;
	
	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }
	
	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);
	
	      if (removed && len === 2) {
	        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
	      }
	
	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);
	
	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }
	
	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }
	
	      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
	    };
	
	
	
	
	    function ValueNode(ownerID, keyHash, entry) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entry = entry;
	    }
	
	    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
	    };
	
	    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	      var keyMatch = is(key, this.entry[0]);
	      if (keyMatch ? value === this.entry[1] : removed) {
	        return this;
	      }
	
	      SetRef(didAlter);
	
	      if (removed) {
	        SetRef(didChangeSize);
	        return; // undefined
	      }
	
	      if (keyMatch) {
	        if (ownerID && ownerID === this.ownerID) {
	          this.entry[1] = value;
	          return this;
	        }
	        return new ValueNode(ownerID, this.keyHash, [key, value]);
	      }
	
	      SetRef(didChangeSize);
	      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
	    };
	
	
	
	  // #pragma Iterators
	
	  ArrayMapNode.prototype.iterate =
	  HashCollisionNode.prototype.iterate = function (fn, reverse) {
	    var entries = this.entries;
	    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
	      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
	        return false;
	      }
	    }
	  }
	
	  BitmapIndexedNode.prototype.iterate =
	  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
	    var nodes = this.nodes;
	    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
	      var node = nodes[reverse ? maxIndex - ii : ii];
	      if (node && node.iterate(fn, reverse) === false) {
	        return false;
	      }
	    }
	  }
	
	  ValueNode.prototype.iterate = function (fn, reverse) {
	    return fn(this.entry);
	  }
	
	  createClass(MapIterator, Iterator);
	
	    function MapIterator(map, type, reverse) {
	      this._type = type;
	      this._reverse = reverse;
	      this._stack = map._root && mapIteratorFrame(map._root);
	    }
	
	    MapIterator.prototype.next = function() {
	      var type = this._type;
	      var stack = this._stack;
	      while (stack) {
	        var node = stack.node;
	        var index = stack.index++;
	        var maxIndex;
	        if (node.entry) {
	          if (index === 0) {
	            return mapIteratorValue(type, node.entry);
	          }
	        } else if (node.entries) {
	          maxIndex = node.entries.length - 1;
	          if (index <= maxIndex) {
	            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
	          }
	        } else {
	          maxIndex = node.nodes.length - 1;
	          if (index <= maxIndex) {
	            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
	            if (subNode) {
	              if (subNode.entry) {
	                return mapIteratorValue(type, subNode.entry);
	              }
	              stack = this._stack = mapIteratorFrame(subNode, stack);
	            }
	            continue;
	          }
	        }
	        stack = this._stack = this._stack.__prev;
	      }
	      return iteratorDone();
	    };
	
	
	  function mapIteratorValue(type, entry) {
	    return iteratorValue(type, entry[0], entry[1]);
	  }
	
	  function mapIteratorFrame(node, prev) {
	    return {
	      node: node,
	      index: 0,
	      __prev: prev
	    };
	  }
	
	  function makeMap(size, root, ownerID, hash) {
	    var map = Object.create(MapPrototype);
	    map.size = size;
	    map._root = root;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }
	
	  var EMPTY_MAP;
	  function emptyMap() {
	    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
	  }
	
	  function updateMap(map, k, v) {
	    var newRoot;
	    var newSize;
	    if (!map._root) {
	      if (v === NOT_SET) {
	        return map;
	      }
	      newSize = 1;
	      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
	    } else {
	      var didChangeSize = MakeRef(CHANGE_LENGTH);
	      var didAlter = MakeRef(DID_ALTER);
	      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
	      if (!didAlter.value) {
	        return map;
	      }
	      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
	    }
	    if (map.__ownerID) {
	      map.size = newSize;
	      map._root = newRoot;
	      map.__hash = undefined;
	      map.__altered = true;
	      return map;
	    }
	    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
	  }
	
	  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (!node) {
	      if (value === NOT_SET) {
	        return node;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return new ValueNode(ownerID, keyHash, [key, value]);
	    }
	    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
	  }
	
	  function isLeafNode(node) {
	    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
	  }
	
	  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
	    if (node.keyHash === keyHash) {
	      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
	    }
	
	    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
	    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	
	    var newNode;
	    var nodes = idx1 === idx2 ?
	      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
	      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);
	
	    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
	  }
	
	  function createNodes(ownerID, entries, key, value) {
	    if (!ownerID) {
	      ownerID = new OwnerID();
	    }
	    var node = new ValueNode(ownerID, hash(key), [key, value]);
	    for (var ii = 0; ii < entries.length; ii++) {
	      var entry = entries[ii];
	      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
	    }
	    return node;
	  }
	
	  function packNodes(ownerID, nodes, count, excluding) {
	    var bitmap = 0;
	    var packedII = 0;
	    var packedNodes = new Array(count);
	    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
	      var node = nodes[ii];
	      if (node !== undefined && ii !== excluding) {
	        bitmap |= bit;
	        packedNodes[packedII++] = node;
	      }
	    }
	    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
	  }
	
	  function expandNodes(ownerID, nodes, bitmap, including, node) {
	    var count = 0;
	    var expandedNodes = new Array(SIZE);
	    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
	      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
	    }
	    expandedNodes[including] = node;
	    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
	  }
	
	  function mergeIntoMapWith(map, merger, iterables) {
	    var iters = [];
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = KeyedIterable(value);
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    return mergeIntoCollectionWith(map, merger, iters);
	  }
	
	  function deepMerger(existing, value, key) {
	    return existing && existing.mergeDeep && isIterable(value) ?
	      existing.mergeDeep(value) :
	      is(existing, value) ? existing : value;
	  }
	
	  function deepMergerWith(merger) {
	    return function(existing, value, key)  {
	      if (existing && existing.mergeDeepWith && isIterable(value)) {
	        return existing.mergeDeepWith(merger, value);
	      }
	      var nextValue = merger(existing, value, key);
	      return is(existing, nextValue) ? existing : nextValue;
	    };
	  }
	
	  function mergeIntoCollectionWith(collection, merger, iters) {
	    iters = iters.filter(function(x ) {return x.size !== 0});
	    if (iters.length === 0) {
	      return collection;
	    }
	    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
	      return collection.constructor(iters[0]);
	    }
	    return collection.withMutations(function(collection ) {
	      var mergeIntoMap = merger ?
	        function(value, key)  {
	          collection.update(key, NOT_SET, function(existing )
	            {return existing === NOT_SET ? value : merger(existing, value, key)}
	          );
	        } :
	        function(value, key)  {
	          collection.set(key, value);
	        }
	      for (var ii = 0; ii < iters.length; ii++) {
	        iters[ii].forEach(mergeIntoMap);
	      }
	    });
	  }
	
	  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
	    var isNotSet = existing === NOT_SET;
	    var step = keyPathIter.next();
	    if (step.done) {
	      var existingValue = isNotSet ? notSetValue : existing;
	      var newValue = updater(existingValue);
	      return newValue === existingValue ? existing : newValue;
	    }
	    invariant(
	      isNotSet || (existing && existing.set),
	      'invalid keyPath'
	    );
	    var key = step.value;
	    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
	    var nextUpdated = updateInDeepMap(
	      nextExisting,
	      keyPathIter,
	      notSetValue,
	      updater
	    );
	    return nextUpdated === nextExisting ? existing :
	      nextUpdated === NOT_SET ? existing.remove(key) :
	      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
	  }
	
	  function popCount(x) {
	    x = x - ((x >> 1) & 0x55555555);
	    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
	    x = (x + (x >> 4)) & 0x0f0f0f0f;
	    x = x + (x >> 8);
	    x = x + (x >> 16);
	    return x & 0x7f;
	  }
	
	  function setIn(array, idx, val, canEdit) {
	    var newArray = canEdit ? array : arrCopy(array);
	    newArray[idx] = val;
	    return newArray;
	  }
	
	  function spliceIn(array, idx, val, canEdit) {
	    var newLen = array.length + 1;
	    if (canEdit && idx + 1 === newLen) {
	      array[idx] = val;
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        newArray[ii] = val;
	        after = -1;
	      } else {
	        newArray[ii] = array[ii + after];
	      }
	    }
	    return newArray;
	  }
	
	  function spliceOut(array, idx, canEdit) {
	    var newLen = array.length - 1;
	    if (canEdit && idx === newLen) {
	      array.pop();
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        after = 1;
	      }
	      newArray[ii] = array[ii + after];
	    }
	    return newArray;
	  }
	
	  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
	  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
	  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
	
	  createClass(List, IndexedCollection);
	
	    // @pragma Construction
	
	    function List(value) {
	      var empty = emptyList();
	      if (value === null || value === undefined) {
	        return empty;
	      }
	      if (isList(value)) {
	        return value;
	      }
	      var iter = IndexedIterable(value);
	      var size = iter.size;
	      if (size === 0) {
	        return empty;
	      }
	      assertNotInfinite(size);
	      if (size > 0 && size < SIZE) {
	        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
	      }
	      return empty.withMutations(function(list ) {
	        list.setSize(size);
	        iter.forEach(function(v, i)  {return list.set(i, v)});
	      });
	    }
	
	    List.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    List.prototype.toString = function() {
	      return this.__toString('List [', ']');
	    };
	
	    // @pragma Access
	
	    List.prototype.get = function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      if (index >= 0 && index < this.size) {
	        index += this._origin;
	        var node = listNodeFor(this, index);
	        return node && node.array[index & MASK];
	      }
	      return notSetValue;
	    };
	
	    // @pragma Modification
	
	    List.prototype.set = function(index, value) {
	      return updateList(this, index, value);
	    };
	
	    List.prototype.remove = function(index) {
	      return !this.has(index) ? this :
	        index === 0 ? this.shift() :
	        index === this.size - 1 ? this.pop() :
	        this.splice(index, 1);
	    };
	
	    List.prototype.insert = function(index, value) {
	      return this.splice(index, 0, value);
	    };
	
	    List.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = this._origin = this._capacity = 0;
	        this._level = SHIFT;
	        this._root = this._tail = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyList();
	    };
	
	    List.prototype.push = function(/*...values*/) {
	      var values = arguments;
	      var oldSize = this.size;
	      return this.withMutations(function(list ) {
	        setListBounds(list, 0, oldSize + values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(oldSize + ii, values[ii]);
	        }
	      });
	    };
	
	    List.prototype.pop = function() {
	      return setListBounds(this, 0, -1);
	    };
	
	    List.prototype.unshift = function(/*...values*/) {
	      var values = arguments;
	      return this.withMutations(function(list ) {
	        setListBounds(list, -values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(ii, values[ii]);
	        }
	      });
	    };
	
	    List.prototype.shift = function() {
	      return setListBounds(this, 1);
	    };
	
	    // @pragma Composition
	
	    List.prototype.merge = function(/*...iters*/) {
	      return mergeIntoListWith(this, undefined, arguments);
	    };
	
	    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, merger, iters);
	    };
	
	    List.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoListWith(this, deepMerger, arguments);
	    };
	
	    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, deepMergerWith(merger), iters);
	    };
	
	    List.prototype.setSize = function(size) {
	      return setListBounds(this, 0, size);
	    };
	
	    // @pragma Iteration
	
	    List.prototype.slice = function(begin, end) {
	      var size = this.size;
	      if (wholeSlice(begin, end, size)) {
	        return this;
	      }
	      return setListBounds(
	        this,
	        resolveBegin(begin, size),
	        resolveEnd(end, size)
	      );
	    };
	
	    List.prototype.__iterator = function(type, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      return new Iterator(function()  {
	        var value = values();
	        return value === DONE ?
	          iteratorDone() :
	          iteratorValue(type, index++, value);
	      });
	    };
	
	    List.prototype.__iterate = function(fn, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      var value;
	      while ((value = values()) !== DONE) {
	        if (fn(value, index++, this) === false) {
	          break;
	        }
	      }
	      return index;
	    };
	
	    List.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        return this;
	      }
	      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
	    };
	
	
	  function isList(maybeList) {
	    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
	  }
	
	  List.isList = isList;
	
	  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';
	
	  var ListPrototype = List.prototype;
	  ListPrototype[IS_LIST_SENTINEL] = true;
	  ListPrototype[DELETE] = ListPrototype.remove;
	  ListPrototype.setIn = MapPrototype.setIn;
	  ListPrototype.deleteIn =
	  ListPrototype.removeIn = MapPrototype.removeIn;
	  ListPrototype.update = MapPrototype.update;
	  ListPrototype.updateIn = MapPrototype.updateIn;
	  ListPrototype.mergeIn = MapPrototype.mergeIn;
	  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  ListPrototype.withMutations = MapPrototype.withMutations;
	  ListPrototype.asMutable = MapPrototype.asMutable;
	  ListPrototype.asImmutable = MapPrototype.asImmutable;
	  ListPrototype.wasAltered = MapPrototype.wasAltered;
	
	
	
	    function VNode(array, ownerID) {
	      this.array = array;
	      this.ownerID = ownerID;
	    }
	
	    // TODO: seems like these methods are very similar
	
	    VNode.prototype.removeBefore = function(ownerID, level, index) {
	      if (index === level ? 1 << level : 0 || this.array.length === 0) {
	        return this;
	      }
	      var originIndex = (index >>> level) & MASK;
	      if (originIndex >= this.array.length) {
	        return new VNode([], ownerID);
	      }
	      var removingFirst = originIndex === 0;
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[originIndex];
	        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && removingFirst) {
	          return this;
	        }
	      }
	      if (removingFirst && !newChild) {
	        return this;
	      }
	      var editable = editableVNode(this, ownerID);
	      if (!removingFirst) {
	        for (var ii = 0; ii < originIndex; ii++) {
	          editable.array[ii] = undefined;
	        }
	      }
	      if (newChild) {
	        editable.array[originIndex] = newChild;
	      }
	      return editable;
	    };
	
	    VNode.prototype.removeAfter = function(ownerID, level, index) {
	      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
	        return this;
	      }
	      var sizeIndex = ((index - 1) >>> level) & MASK;
	      if (sizeIndex >= this.array.length) {
	        return this;
	      }
	
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[sizeIndex];
	        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
	          return this;
	        }
	      }
	
	      var editable = editableVNode(this, ownerID);
	      editable.array.splice(sizeIndex + 1);
	      if (newChild) {
	        editable.array[sizeIndex] = newChild;
	      }
	      return editable;
	    };
	
	
	
	  var DONE = {};
	
	  function iterateList(list, reverse) {
	    var left = list._origin;
	    var right = list._capacity;
	    var tailPos = getTailOffset(right);
	    var tail = list._tail;
	
	    return iterateNodeOrLeaf(list._root, list._level, 0);
	
	    function iterateNodeOrLeaf(node, level, offset) {
	      return level === 0 ?
	        iterateLeaf(node, offset) :
	        iterateNode(node, level, offset);
	    }
	
	    function iterateLeaf(node, offset) {
	      var array = offset === tailPos ? tail && tail.array : node && node.array;
	      var from = offset > left ? 0 : left - offset;
	      var to = right - offset;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        if (from === to) {
	          return DONE;
	        }
	        var idx = reverse ? --to : from++;
	        return array && array[idx];
	      };
	    }
	
	    function iterateNode(node, level, offset) {
	      var values;
	      var array = node && node.array;
	      var from = offset > left ? 0 : (left - offset) >> level;
	      var to = ((right - offset) >> level) + 1;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        do {
	          if (values) {
	            var value = values();
	            if (value !== DONE) {
	              return value;
	            }
	            values = null;
	          }
	          if (from === to) {
	            return DONE;
	          }
	          var idx = reverse ? --to : from++;
	          values = iterateNodeOrLeaf(
	            array && array[idx], level - SHIFT, offset + (idx << level)
	          );
	        } while (true);
	      };
	    }
	  }
	
	  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
	    var list = Object.create(ListPrototype);
	    list.size = capacity - origin;
	    list._origin = origin;
	    list._capacity = capacity;
	    list._level = level;
	    list._root = root;
	    list._tail = tail;
	    list.__ownerID = ownerID;
	    list.__hash = hash;
	    list.__altered = false;
	    return list;
	  }
	
	  var EMPTY_LIST;
	  function emptyList() {
	    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
	  }
	
	  function updateList(list, index, value) {
	    index = wrapIndex(list, index);
	
	    if (index !== index) {
	      return list;
	    }
	
	    if (index >= list.size || index < 0) {
	      return list.withMutations(function(list ) {
	        index < 0 ?
	          setListBounds(list, index).set(0, value) :
	          setListBounds(list, 0, index + 1).set(index, value)
	      });
	    }
	
	    index += list._origin;
	
	    var newTail = list._tail;
	    var newRoot = list._root;
	    var didAlter = MakeRef(DID_ALTER);
	    if (index >= getTailOffset(list._capacity)) {
	      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
	    } else {
	      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
	    }
	
	    if (!didAlter.value) {
	      return list;
	    }
	
	    if (list.__ownerID) {
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
	  }
	
	  function updateVNode(node, ownerID, level, index, value, didAlter) {
	    var idx = (index >>> level) & MASK;
	    var nodeHas = node && idx < node.array.length;
	    if (!nodeHas && value === undefined) {
	      return node;
	    }
	
	    var newNode;
	
	    if (level > 0) {
	      var lowerNode = node && node.array[idx];
	      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
	      if (newLowerNode === lowerNode) {
	        return node;
	      }
	      newNode = editableVNode(node, ownerID);
	      newNode.array[idx] = newLowerNode;
	      return newNode;
	    }
	
	    if (nodeHas && node.array[idx] === value) {
	      return node;
	    }
	
	    SetRef(didAlter);
	
	    newNode = editableVNode(node, ownerID);
	    if (value === undefined && idx === newNode.array.length - 1) {
	      newNode.array.pop();
	    } else {
	      newNode.array[idx] = value;
	    }
	    return newNode;
	  }
	
	  function editableVNode(node, ownerID) {
	    if (ownerID && node && ownerID === node.ownerID) {
	      return node;
	    }
	    return new VNode(node ? node.array.slice() : [], ownerID);
	  }
	
	  function listNodeFor(list, rawIndex) {
	    if (rawIndex >= getTailOffset(list._capacity)) {
	      return list._tail;
	    }
	    if (rawIndex < 1 << (list._level + SHIFT)) {
	      var node = list._root;
	      var level = list._level;
	      while (node && level > 0) {
	        node = node.array[(rawIndex >>> level) & MASK];
	        level -= SHIFT;
	      }
	      return node;
	    }
	  }
	
	  function setListBounds(list, begin, end) {
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      end = end | 0;
	    }
	    var owner = list.__ownerID || new OwnerID();
	    var oldOrigin = list._origin;
	    var oldCapacity = list._capacity;
	    var newOrigin = oldOrigin + begin;
	    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
	    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
	      return list;
	    }
	
	    // If it's going to end after it starts, it's empty.
	    if (newOrigin >= newCapacity) {
	      return list.clear();
	    }
	
	    var newLevel = list._level;
	    var newRoot = list._root;
	
	    // New origin might need creating a higher root.
	    var offsetShift = 0;
	    while (newOrigin + offsetShift < 0) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
	      newLevel += SHIFT;
	      offsetShift += 1 << newLevel;
	    }
	    if (offsetShift) {
	      newOrigin += offsetShift;
	      oldOrigin += offsetShift;
	      newCapacity += offsetShift;
	      oldCapacity += offsetShift;
	    }
	
	    var oldTailOffset = getTailOffset(oldCapacity);
	    var newTailOffset = getTailOffset(newCapacity);
	
	    // New size might need creating a higher root.
	    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
	      newLevel += SHIFT;
	    }
	
	    // Locate or create the new tail.
	    var oldTail = list._tail;
	    var newTail = newTailOffset < oldTailOffset ?
	      listNodeFor(list, newCapacity - 1) :
	      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
	
	    // Merge Tail into tree.
	    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
	      newRoot = editableVNode(newRoot, owner);
	      var node = newRoot;
	      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
	        var idx = (oldTailOffset >>> level) & MASK;
	        node = node.array[idx] = editableVNode(node.array[idx], owner);
	      }
	      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
	    }
	
	    // If the size has been reduced, there's a chance the tail needs to be trimmed.
	    if (newCapacity < oldCapacity) {
	      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
	    }
	
	    // If the new origin is within the tail, then we do not need a root.
	    if (newOrigin >= newTailOffset) {
	      newOrigin -= newTailOffset;
	      newCapacity -= newTailOffset;
	      newLevel = SHIFT;
	      newRoot = null;
	      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
	
	    // Otherwise, if the root has been trimmed, garbage collect.
	    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
	      offsetShift = 0;
	
	      // Identify the new top root node of the subtree of the old root.
	      while (newRoot) {
	        var beginIndex = (newOrigin >>> newLevel) & MASK;
	        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
	          break;
	        }
	        if (beginIndex) {
	          offsetShift += (1 << newLevel) * beginIndex;
	        }
	        newLevel -= SHIFT;
	        newRoot = newRoot.array[beginIndex];
	      }
	
	      // Trim the new sides of the new root.
	      if (newRoot && newOrigin > oldOrigin) {
	        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
	      }
	      if (newRoot && newTailOffset < oldTailOffset) {
	        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
	      }
	      if (offsetShift) {
	        newOrigin -= offsetShift;
	        newCapacity -= offsetShift;
	      }
	    }
	
	    if (list.__ownerID) {
	      list.size = newCapacity - newOrigin;
	      list._origin = newOrigin;
	      list._capacity = newCapacity;
	      list._level = newLevel;
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
	  }
	
	  function mergeIntoListWith(list, merger, iterables) {
	    var iters = [];
	    var maxSize = 0;
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = IndexedIterable(value);
	      if (iter.size > maxSize) {
	        maxSize = iter.size;
	      }
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    if (maxSize > list.size) {
	      list = list.setSize(maxSize);
	    }
	    return mergeIntoCollectionWith(list, merger, iters);
	  }
	
	  function getTailOffset(size) {
	    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
	  }
	
	  createClass(OrderedMap, Map);
	
	    // @pragma Construction
	
	    function OrderedMap(value) {
	      return value === null || value === undefined ? emptyOrderedMap() :
	        isOrderedMap(value) ? value :
	        emptyOrderedMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }
	
	    OrderedMap.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    OrderedMap.prototype.toString = function() {
	      return this.__toString('OrderedMap {', '}');
	    };
	
	    // @pragma Access
	
	    OrderedMap.prototype.get = function(k, notSetValue) {
	      var index = this._map.get(k);
	      return index !== undefined ? this._list.get(index)[1] : notSetValue;
	    };
	
	    // @pragma Modification
	
	    OrderedMap.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._map.clear();
	        this._list.clear();
	        return this;
	      }
	      return emptyOrderedMap();
	    };
	
	    OrderedMap.prototype.set = function(k, v) {
	      return updateOrderedMap(this, k, v);
	    };
	
	    OrderedMap.prototype.remove = function(k) {
	      return updateOrderedMap(this, k, NOT_SET);
	    };
	
	    OrderedMap.prototype.wasAltered = function() {
	      return this._map.wasAltered() || this._list.wasAltered();
	    };
	
	    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._list.__iterate(
	        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
	        reverse
	      );
	    };
	
	    OrderedMap.prototype.__iterator = function(type, reverse) {
	      return this._list.fromEntrySeq().__iterator(type, reverse);
	    };
	
	    OrderedMap.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      var newList = this._list.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        this._list = newList;
	        return this;
	      }
	      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
	    };
	
	
	  function isOrderedMap(maybeOrderedMap) {
	    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
	  }
	
	  OrderedMap.isOrderedMap = isOrderedMap;
	
	  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
	  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
	
	
	
	  function makeOrderedMap(map, list, ownerID, hash) {
	    var omap = Object.create(OrderedMap.prototype);
	    omap.size = map ? map.size : 0;
	    omap._map = map;
	    omap._list = list;
	    omap.__ownerID = ownerID;
	    omap.__hash = hash;
	    return omap;
	  }
	
	  var EMPTY_ORDERED_MAP;
	  function emptyOrderedMap() {
	    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
	  }
	
	  function updateOrderedMap(omap, k, v) {
	    var map = omap._map;
	    var list = omap._list;
	    var i = map.get(k);
	    var has = i !== undefined;
	    var newMap;
	    var newList;
	    if (v === NOT_SET) { // removed
	      if (!has) {
	        return omap;
	      }
	      if (list.size >= SIZE && list.size >= map.size * 2) {
	        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
	        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
	        if (omap.__ownerID) {
	          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
	        }
	      } else {
	        newMap = map.remove(k);
	        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
	      }
	    } else {
	      if (has) {
	        if (v === list.get(i)[1]) {
	          return omap;
	        }
	        newMap = map;
	        newList = list.set(i, [k, v]);
	      } else {
	        newMap = map.set(k, list.size);
	        newList = list.set(list.size, [k, v]);
	      }
	    }
	    if (omap.__ownerID) {
	      omap.size = newMap.size;
	      omap._map = newMap;
	      omap._list = newList;
	      omap.__hash = undefined;
	      return omap;
	    }
	    return makeOrderedMap(newMap, newList);
	  }
	
	  createClass(ToKeyedSequence, KeyedSeq);
	    function ToKeyedSequence(indexed, useKeys) {
	      this._iter = indexed;
	      this._useKeys = useKeys;
	      this.size = indexed.size;
	    }
	
	    ToKeyedSequence.prototype.get = function(key, notSetValue) {
	      return this._iter.get(key, notSetValue);
	    };
	
	    ToKeyedSequence.prototype.has = function(key) {
	      return this._iter.has(key);
	    };
	
	    ToKeyedSequence.prototype.valueSeq = function() {
	      return this._iter.valueSeq();
	    };
	
	    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
	      var reversedSequence = reverseFactory(this, true);
	      if (!this._useKeys) {
	        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
	      }
	      return reversedSequence;
	    };
	
	    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
	      var mappedSequence = mapFactory(this, mapper, context);
	      if (!this._useKeys) {
	        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
	      }
	      return mappedSequence;
	    };
	
	    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var ii;
	      return this._iter.__iterate(
	        this._useKeys ?
	          function(v, k)  {return fn(v, k, this$0)} :
	          ((ii = reverse ? resolveSize(this) : 0),
	            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
	        reverse
	      );
	    };
	
	    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
	      if (this._useKeys) {
	        return this._iter.__iterator(type, reverse);
	      }
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var ii = reverse ? resolveSize(this) : 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
	      });
	    };
	
	  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;
	
	
	  createClass(ToIndexedSequence, IndexedSeq);
	    function ToIndexedSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }
	
	    ToIndexedSequence.prototype.includes = function(value) {
	      return this._iter.includes(value);
	    };
	
	    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
	    };
	
	    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, iterations++, step.value, step)
	      });
	    };
	
	
	
	  createClass(ToSetSequence, SetSeq);
	    function ToSetSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }
	
	    ToSetSequence.prototype.has = function(key) {
	      return this._iter.includes(key);
	    };
	
	    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
	    };
	
	    ToSetSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, step.value, step.value, step);
	      });
	    };
	
	
	
	  createClass(FromEntriesSequence, KeyedSeq);
	    function FromEntriesSequence(entries) {
	      this._iter = entries;
	      this.size = entries.size;
	    }
	
	    FromEntriesSequence.prototype.entrySeq = function() {
	      return this._iter.toSeq();
	    };
	
	    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(entry ) {
	        // Check if entry exists first so array access doesn't throw for holes
	        // in the parent iteration.
	        if (entry) {
	          validateEntry(entry);
	          var indexedIterable = isIterable(entry);
	          return fn(
	            indexedIterable ? entry.get(1) : entry[1],
	            indexedIterable ? entry.get(0) : entry[0],
	            this$0
	          );
	        }
	      }, reverse);
	    };
	
	    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          // Check if entry exists first so array access doesn't throw for holes
	          // in the parent iteration.
	          if (entry) {
	            validateEntry(entry);
	            var indexedIterable = isIterable(entry);
	            return iteratorValue(
	              type,
	              indexedIterable ? entry.get(0) : entry[0],
	              indexedIterable ? entry.get(1) : entry[1],
	              step
	            );
	          }
	        }
	      });
	    };
	
	
	  ToIndexedSequence.prototype.cacheResult =
	  ToKeyedSequence.prototype.cacheResult =
	  ToSetSequence.prototype.cacheResult =
	  FromEntriesSequence.prototype.cacheResult =
	    cacheResultThrough;
	
	
	  function flipFactory(iterable) {
	    var flipSequence = makeSequence(iterable);
	    flipSequence._iter = iterable;
	    flipSequence.size = iterable.size;
	    flipSequence.flip = function()  {return iterable};
	    flipSequence.reverse = function () {
	      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
	      reversedSequence.flip = function()  {return iterable.reverse()};
	      return reversedSequence;
	    };
	    flipSequence.has = function(key ) {return iterable.includes(key)};
	    flipSequence.includes = function(key ) {return iterable.has(key)};
	    flipSequence.cacheResult = cacheResultThrough;
	    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
	    }
	    flipSequence.__iteratorUncached = function(type, reverse) {
	      if (type === ITERATE_ENTRIES) {
	        var iterator = iterable.__iterator(type, reverse);
	        return new Iterator(function()  {
	          var step = iterator.next();
	          if (!step.done) {
	            var k = step.value[0];
	            step.value[0] = step.value[1];
	            step.value[1] = k;
	          }
	          return step;
	        });
	      }
	      return iterable.__iterator(
	        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
	        reverse
	      );
	    }
	    return flipSequence;
	  }
	
	
	  function mapFactory(iterable, mapper, context) {
	    var mappedSequence = makeSequence(iterable);
	    mappedSequence.size = iterable.size;
	    mappedSequence.has = function(key ) {return iterable.has(key)};
	    mappedSequence.get = function(key, notSetValue)  {
	      var v = iterable.get(key, NOT_SET);
	      return v === NOT_SET ?
	        notSetValue :
	        mapper.call(context, v, key, iterable);
	    };
	    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(
	        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
	        reverse
	      );
	    }
	    mappedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var key = entry[0];
	        return iteratorValue(
	          type,
	          key,
	          mapper.call(context, entry[1], key, iterable),
	          step
	        );
	      });
	    }
	    return mappedSequence;
	  }
	
	
	  function reverseFactory(iterable, useKeys) {
	    var reversedSequence = makeSequence(iterable);
	    reversedSequence._iter = iterable;
	    reversedSequence.size = iterable.size;
	    reversedSequence.reverse = function()  {return iterable};
	    if (iterable.flip) {
	      reversedSequence.flip = function () {
	        var flipSequence = flipFactory(iterable);
	        flipSequence.reverse = function()  {return iterable.flip()};
	        return flipSequence;
	      };
	    }
	    reversedSequence.get = function(key, notSetValue) 
	      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
	    reversedSequence.has = function(key )
	      {return iterable.has(useKeys ? key : -1 - key)};
	    reversedSequence.includes = function(value ) {return iterable.includes(value)};
	    reversedSequence.cacheResult = cacheResultThrough;
	    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
	    };
	    reversedSequence.__iterator =
	      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
	    return reversedSequence;
	  }
	
	
	  function filterFactory(iterable, predicate, context, useKeys) {
	    var filterSequence = makeSequence(iterable);
	    if (useKeys) {
	      filterSequence.has = function(key ) {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
	      };
	      filterSequence.get = function(key, notSetValue)  {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
	          v : notSetValue;
	      };
	    }
	    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      }, reverse);
	      return iterations;
	    };
	    filterSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          var key = entry[0];
	          var value = entry[1];
	          if (predicate.call(context, value, key, iterable)) {
	            return iteratorValue(type, useKeys ? key : iterations++, value, step);
	          }
	        }
	      });
	    }
	    return filterSequence;
	  }
	
	
	  function countByFactory(iterable, grouper, context) {
	    var groups = Map().asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        0,
	        function(a ) {return a + 1}
	      );
	    });
	    return groups.asImmutable();
	  }
	
	
	  function groupByFactory(iterable, grouper, context) {
	    var isKeyedIter = isKeyed(iterable);
	    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
	      );
	    });
	    var coerce = iterableClass(iterable);
	    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
	  }
	
	
	  function sliceFactory(iterable, begin, end, useKeys) {
	    var originalSize = iterable.size;
	
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      if (end === Infinity) {
	        end = originalSize;
	      } else {
	        end = end | 0;
	      }
	    }
	
	    if (wholeSlice(begin, end, originalSize)) {
	      return iterable;
	    }
	
	    var resolvedBegin = resolveBegin(begin, originalSize);
	    var resolvedEnd = resolveEnd(end, originalSize);
	
	    // begin or end will be NaN if they were provided as negative numbers and
	    // this iterable's size is unknown. In that case, cache first so there is
	    // a known size and these do not resolve to NaN.
	    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
	      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
	    }
	
	    // Note: resolvedEnd is undefined when the original sequence's length is
	    // unknown and this slice did not supply an end and should contain all
	    // elements after resolvedBegin.
	    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
	    var resolvedSize = resolvedEnd - resolvedBegin;
	    var sliceSize;
	    if (resolvedSize === resolvedSize) {
	      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
	    }
	
	    var sliceSeq = makeSequence(iterable);
	
	    // If iterable.size is undefined, the size of the realized sliceSeq is
	    // unknown at this point unless the number of items to slice is 0
	    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;
	
	    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
	      sliceSeq.get = function (index, notSetValue) {
	        index = wrapIndex(this, index);
	        return index >= 0 && index < sliceSize ?
	          iterable.get(index + resolvedBegin, notSetValue) :
	          notSetValue;
	      }
	    }
	
	    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (sliceSize === 0) {
	        return 0;
	      }
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var skipped = 0;
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k)  {
	        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
	                 iterations !== sliceSize;
	        }
	      });
	      return iterations;
	    };
	
	    sliceSeq.__iteratorUncached = function(type, reverse) {
	      if (sliceSize !== 0 && reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      // Don't bother instantiating parent iterator if taking 0.
	      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
	      var skipped = 0;
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (skipped++ < resolvedBegin) {
	          iterator.next();
	        }
	        if (++iterations > sliceSize) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (useKeys || type === ITERATE_VALUES) {
	          return step;
	        } else if (type === ITERATE_KEYS) {
	          return iteratorValue(type, iterations - 1, undefined, step);
	        } else {
	          return iteratorValue(type, iterations - 1, step.value[1], step);
	        }
	      });
	    }
	
	    return sliceSeq;
	  }
	
	
	  function takeWhileFactory(iterable, predicate, context) {
	    var takeSequence = makeSequence(iterable);
	    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c) 
	        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
	      );
	      return iterations;
	    };
	    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterating = true;
	      return new Iterator(function()  {
	        if (!iterating) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var k = entry[0];
	        var v = entry[1];
	        if (!predicate.call(context, v, k, this$0)) {
	          iterating = false;
	          return iteratorDone();
	        }
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return takeSequence;
	  }
	
	
	  function skipWhileFactory(iterable, predicate, context, useKeys) {
	    var skipSequence = makeSequence(iterable);
	    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      });
	      return iterations;
	    };
	    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var skipping = true;
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step, k, v;
	        do {
	          step = iterator.next();
	          if (step.done) {
	            if (useKeys || type === ITERATE_VALUES) {
	              return step;
	            } else if (type === ITERATE_KEYS) {
	              return iteratorValue(type, iterations++, undefined, step);
	            } else {
	              return iteratorValue(type, iterations++, step.value[1], step);
	            }
	          }
	          var entry = step.value;
	          k = entry[0];
	          v = entry[1];
	          skipping && (skipping = predicate.call(context, v, k, this$0));
	        } while (skipping);
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return skipSequence;
	  }
	
	
	  function concatFactory(iterable, values) {
	    var isKeyedIterable = isKeyed(iterable);
	    var iters = [iterable].concat(values).map(function(v ) {
	      if (!isIterable(v)) {
	        v = isKeyedIterable ?
	          keyedSeqFromValue(v) :
	          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
	      } else if (isKeyedIterable) {
	        v = KeyedIterable(v);
	      }
	      return v;
	    }).filter(function(v ) {return v.size !== 0});
	
	    if (iters.length === 0) {
	      return iterable;
	    }
	
	    if (iters.length === 1) {
	      var singleton = iters[0];
	      if (singleton === iterable ||
	          isKeyedIterable && isKeyed(singleton) ||
	          isIndexed(iterable) && isIndexed(singleton)) {
	        return singleton;
	      }
	    }
	
	    var concatSeq = new ArraySeq(iters);
	    if (isKeyedIterable) {
	      concatSeq = concatSeq.toKeyedSeq();
	    } else if (!isIndexed(iterable)) {
	      concatSeq = concatSeq.toSetSeq();
	    }
	    concatSeq = concatSeq.flatten(true);
	    concatSeq.size = iters.reduce(
	      function(sum, seq)  {
	        if (sum !== undefined) {
	          var size = seq.size;
	          if (size !== undefined) {
	            return sum + size;
	          }
	        }
	      },
	      0
	    );
	    return concatSeq;
	  }
	
	
	  function flattenFactory(iterable, depth, useKeys) {
	    var flatSequence = makeSequence(iterable);
	    flatSequence.__iterateUncached = function(fn, reverse) {
	      var iterations = 0;
	      var stopped = false;
	      function flatDeep(iter, currentDepth) {var this$0 = this;
	        iter.__iterate(function(v, k)  {
	          if ((!depth || currentDepth < depth) && isIterable(v)) {
	            flatDeep(v, currentDepth + 1);
	          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
	            stopped = true;
	          }
	          return !stopped;
	        }, reverse);
	      }
	      flatDeep(iterable, 0);
	      return iterations;
	    }
	    flatSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(type, reverse);
	      var stack = [];
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (iterator) {
	          var step = iterator.next();
	          if (step.done !== false) {
	            iterator = stack.pop();
	            continue;
	          }
	          var v = step.value;
	          if (type === ITERATE_ENTRIES) {
	            v = v[1];
	          }
	          if ((!depth || stack.length < depth) && isIterable(v)) {
	            stack.push(iterator);
	            iterator = v.__iterator(type, reverse);
	          } else {
	            return useKeys ? step : iteratorValue(type, iterations++, v, step);
	          }
	        }
	        return iteratorDone();
	      });
	    }
	    return flatSequence;
	  }
	
	
	  function flatMapFactory(iterable, mapper, context) {
	    var coerce = iterableClass(iterable);
	    return iterable.toSeq().map(
	      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
	    ).flatten(true);
	  }
	
	
	  function interposeFactory(iterable, separator) {
	    var interposedSequence = makeSequence(iterable);
	    interposedSequence.size = iterable.size && iterable.size * 2 -1;
	    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k) 
	        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
	        fn(v, iterations++, this$0) !== false},
	        reverse
	      );
	      return iterations;
	    };
	    interposedSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      var step;
	      return new Iterator(function()  {
	        if (!step || iterations % 2) {
	          step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	        }
	        return iterations % 2 ?
	          iteratorValue(type, iterations++, separator) :
	          iteratorValue(type, iterations++, step.value, step);
	      });
	    };
	    return interposedSequence;
	  }
	
	
	  function sortFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    var isKeyedIterable = isKeyed(iterable);
	    var index = 0;
	    var entries = iterable.toSeq().map(
	      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
	    ).toArray();
	    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
	      isKeyedIterable ?
	      function(v, i)  { entries[i].length = 2; } :
	      function(v, i)  { entries[i] = v[1]; }
	    );
	    return isKeyedIterable ? KeyedSeq(entries) :
	      isIndexed(iterable) ? IndexedSeq(entries) :
	      SetSeq(entries);
	  }
	
	
	  function maxFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    if (mapper) {
	      var entry = iterable.toSeq()
	        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
	        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
	      return entry && entry[0];
	    } else {
	      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
	    }
	  }
	
	  function maxCompare(comparator, a, b) {
	    var comp = comparator(b, a);
	    // b is considered the new max if the comparator declares them equal, but
	    // they are not equal and b is in fact a nullish value.
	    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
	  }
	
	
	  function zipWithFactory(keyIter, zipper, iters) {
	    var zipSequence = makeSequence(keyIter);
	    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
	    // Note: this a generic base implementation of __iterate in terms of
	    // __iterator which may be more generically useful in the future.
	    zipSequence.__iterate = function(fn, reverse) {
	      /* generic:
	      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        iterations++;
	        if (fn(step.value[1], step.value[0], this) === false) {
	          break;
	        }
	      }
	      return iterations;
	      */
	      // indexed:
	      var iterator = this.__iterator(ITERATE_VALUES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        if (fn(step.value, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	    zipSequence.__iteratorUncached = function(type, reverse) {
	      var iterators = iters.map(function(i )
	        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
	      );
	      var iterations = 0;
	      var isDone = false;
	      return new Iterator(function()  {
	        var steps;
	        if (!isDone) {
	          steps = iterators.map(function(i ) {return i.next()});
	          isDone = steps.some(function(s ) {return s.done});
	        }
	        if (isDone) {
	          return iteratorDone();
	        }
	        return iteratorValue(
	          type,
	          iterations++,
	          zipper.apply(null, steps.map(function(s ) {return s.value}))
	        );
	      });
	    };
	    return zipSequence
	  }
	
	
	  // #pragma Helper Functions
	
	  function reify(iter, seq) {
	    return isSeq(iter) ? seq : iter.constructor(seq);
	  }
	
	  function validateEntry(entry) {
	    if (entry !== Object(entry)) {
	      throw new TypeError('Expected [K, V] tuple: ' + entry);
	    }
	  }
	
	  function resolveSize(iter) {
	    assertNotInfinite(iter.size);
	    return ensureSize(iter);
	  }
	
	  function iterableClass(iterable) {
	    return isKeyed(iterable) ? KeyedIterable :
	      isIndexed(iterable) ? IndexedIterable :
	      SetIterable;
	  }
	
	  function makeSequence(iterable) {
	    return Object.create(
	      (
	        isKeyed(iterable) ? KeyedSeq :
	        isIndexed(iterable) ? IndexedSeq :
	        SetSeq
	      ).prototype
	    );
	  }
	
	  function cacheResultThrough() {
	    if (this._iter.cacheResult) {
	      this._iter.cacheResult();
	      this.size = this._iter.size;
	      return this;
	    } else {
	      return Seq.prototype.cacheResult.call(this);
	    }
	  }
	
	  function defaultComparator(a, b) {
	    return a > b ? 1 : a < b ? -1 : 0;
	  }
	
	  function forceIterator(keyPath) {
	    var iter = getIterator(keyPath);
	    if (!iter) {
	      // Array might not be iterable in this environment, so we need a fallback
	      // to our wrapped type.
	      if (!isArrayLike(keyPath)) {
	        throw new TypeError('Expected iterable or array-like: ' + keyPath);
	      }
	      iter = getIterator(Iterable(keyPath));
	    }
	    return iter;
	  }
	
	  createClass(Record, KeyedCollection);
	
	    function Record(defaultValues, name) {
	      var hasInitialized;
	
	      var RecordType = function Record(values) {
	        if (values instanceof RecordType) {
	          return values;
	        }
	        if (!(this instanceof RecordType)) {
	          return new RecordType(values);
	        }
	        if (!hasInitialized) {
	          hasInitialized = true;
	          var keys = Object.keys(defaultValues);
	          setProps(RecordTypePrototype, keys);
	          RecordTypePrototype.size = keys.length;
	          RecordTypePrototype._name = name;
	          RecordTypePrototype._keys = keys;
	          RecordTypePrototype._defaultValues = defaultValues;
	        }
	        this._map = Map(values);
	      };
	
	      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
	      RecordTypePrototype.constructor = RecordType;
	
	      return RecordType;
	    }
	
	    Record.prototype.toString = function() {
	      return this.__toString(recordName(this) + ' {', '}');
	    };
	
	    // @pragma Access
	
	    Record.prototype.has = function(k) {
	      return this._defaultValues.hasOwnProperty(k);
	    };
	
	    Record.prototype.get = function(k, notSetValue) {
	      if (!this.has(k)) {
	        return notSetValue;
	      }
	      var defaultVal = this._defaultValues[k];
	      return this._map ? this._map.get(k, defaultVal) : defaultVal;
	    };
	
	    // @pragma Modification
	
	    Record.prototype.clear = function() {
	      if (this.__ownerID) {
	        this._map && this._map.clear();
	        return this;
	      }
	      var RecordType = this.constructor;
	      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
	    };
	
	    Record.prototype.set = function(k, v) {
	      if (!this.has(k)) {
	        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
	      }
	      if (this._map && !this._map.has(k)) {
	        var defaultVal = this._defaultValues[k];
	        if (v === defaultVal) {
	          return this;
	        }
	      }
	      var newMap = this._map && this._map.set(k, v);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };
	
	    Record.prototype.remove = function(k) {
	      if (!this.has(k)) {
	        return this;
	      }
	      var newMap = this._map && this._map.remove(k);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };
	
	    Record.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };
	
	    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
	    };
	
	    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
	    };
	
	    Record.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map && this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return makeRecord(this, newMap, ownerID);
	    };
	
	
	  var RecordPrototype = Record.prototype;
	  RecordPrototype[DELETE] = RecordPrototype.remove;
	  RecordPrototype.deleteIn =
	  RecordPrototype.removeIn = MapPrototype.removeIn;
	  RecordPrototype.merge = MapPrototype.merge;
	  RecordPrototype.mergeWith = MapPrototype.mergeWith;
	  RecordPrototype.mergeIn = MapPrototype.mergeIn;
	  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
	  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
	  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  RecordPrototype.setIn = MapPrototype.setIn;
	  RecordPrototype.update = MapPrototype.update;
	  RecordPrototype.updateIn = MapPrototype.updateIn;
	  RecordPrototype.withMutations = MapPrototype.withMutations;
	  RecordPrototype.asMutable = MapPrototype.asMutable;
	  RecordPrototype.asImmutable = MapPrototype.asImmutable;
	
	
	  function makeRecord(likeRecord, map, ownerID) {
	    var record = Object.create(Object.getPrototypeOf(likeRecord));
	    record._map = map;
	    record.__ownerID = ownerID;
	    return record;
	  }
	
	  function recordName(record) {
	    return record._name || record.constructor.name || 'Record';
	  }
	
	  function setProps(prototype, names) {
	    try {
	      names.forEach(setProp.bind(undefined, prototype));
	    } catch (error) {
	      // Object.defineProperty failed. Probably IE8.
	    }
	  }
	
	  function setProp(prototype, name) {
	    Object.defineProperty(prototype, name, {
	      get: function() {
	        return this.get(name);
	      },
	      set: function(value) {
	        invariant(this.__ownerID, 'Cannot set on an immutable record.');
	        this.set(name, value);
	      }
	    });
	  }
	
	  createClass(Set, SetCollection);
	
	    // @pragma Construction
	
	    function Set(value) {
	      return value === null || value === undefined ? emptySet() :
	        isSet(value) && !isOrdered(value) ? value :
	        emptySet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }
	
	    Set.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    Set.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };
	
	    Set.prototype.toString = function() {
	      return this.__toString('Set {', '}');
	    };
	
	    // @pragma Access
	
	    Set.prototype.has = function(value) {
	      return this._map.has(value);
	    };
	
	    // @pragma Modification
	
	    Set.prototype.add = function(value) {
	      return updateSet(this, this._map.set(value, true));
	    };
	
	    Set.prototype.remove = function(value) {
	      return updateSet(this, this._map.remove(value));
	    };
	
	    Set.prototype.clear = function() {
	      return updateSet(this, this._map.clear());
	    };
	
	    // @pragma Composition
	
	    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
	      iters = iters.filter(function(x ) {return x.size !== 0});
	      if (iters.length === 0) {
	        return this;
	      }
	      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
	        return this.constructor(iters[0]);
	      }
	      return this.withMutations(function(set ) {
	        for (var ii = 0; ii < iters.length; ii++) {
	          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
	        }
	      });
	    };
	
	    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (!iters.every(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };
	
	    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (iters.some(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };
	
	    Set.prototype.merge = function() {
	      return this.union.apply(this, arguments);
	    };
	
	    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return this.union.apply(this, iters);
	    };
	
	    Set.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator));
	    };
	
	    Set.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator, mapper));
	    };
	
	    Set.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };
	
	    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
	    };
	
	    Set.prototype.__iterator = function(type, reverse) {
	      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
	    };
	
	    Set.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return this.__make(newMap, ownerID);
	    };
	
	
	  function isSet(maybeSet) {
	    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
	  }
	
	  Set.isSet = isSet;
	
	  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';
	
	  var SetPrototype = Set.prototype;
	  SetPrototype[IS_SET_SENTINEL] = true;
	  SetPrototype[DELETE] = SetPrototype.remove;
	  SetPrototype.mergeDeep = SetPrototype.merge;
	  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
	  SetPrototype.withMutations = MapPrototype.withMutations;
	  SetPrototype.asMutable = MapPrototype.asMutable;
	  SetPrototype.asImmutable = MapPrototype.asImmutable;
	
	  SetPrototype.__empty = emptySet;
	  SetPrototype.__make = makeSet;
	
	  function updateSet(set, newMap) {
	    if (set.__ownerID) {
	      set.size = newMap.size;
	      set._map = newMap;
	      return set;
	    }
	    return newMap === set._map ? set :
	      newMap.size === 0 ? set.__empty() :
	      set.__make(newMap);
	  }
	
	  function makeSet(map, ownerID) {
	    var set = Object.create(SetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }
	
	  var EMPTY_SET;
	  function emptySet() {
	    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
	  }
	
	  createClass(OrderedSet, Set);
	
	    // @pragma Construction
	
	    function OrderedSet(value) {
	      return value === null || value === undefined ? emptyOrderedSet() :
	        isOrderedSet(value) ? value :
	        emptyOrderedSet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }
	
	    OrderedSet.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    OrderedSet.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };
	
	    OrderedSet.prototype.toString = function() {
	      return this.__toString('OrderedSet {', '}');
	    };
	
	
	  function isOrderedSet(maybeOrderedSet) {
	    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
	  }
	
	  OrderedSet.isOrderedSet = isOrderedSet;
	
	  var OrderedSetPrototype = OrderedSet.prototype;
	  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;
	
	  OrderedSetPrototype.__empty = emptyOrderedSet;
	  OrderedSetPrototype.__make = makeOrderedSet;
	
	  function makeOrderedSet(map, ownerID) {
	    var set = Object.create(OrderedSetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }
	
	  var EMPTY_ORDERED_SET;
	  function emptyOrderedSet() {
	    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
	  }
	
	  createClass(Stack, IndexedCollection);
	
	    // @pragma Construction
	
	    function Stack(value) {
	      return value === null || value === undefined ? emptyStack() :
	        isStack(value) ? value :
	        emptyStack().unshiftAll(value);
	    }
	
	    Stack.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    Stack.prototype.toString = function() {
	      return this.__toString('Stack [', ']');
	    };
	
	    // @pragma Access
	
	    Stack.prototype.get = function(index, notSetValue) {
	      var head = this._head;
	      index = wrapIndex(this, index);
	      while (head && index--) {
	        head = head.next;
	      }
	      return head ? head.value : notSetValue;
	    };
	
	    Stack.prototype.peek = function() {
	      return this._head && this._head.value;
	    };
	
	    // @pragma Modification
	
	    Stack.prototype.push = function(/*...values*/) {
	      if (arguments.length === 0) {
	        return this;
	      }
	      var newSize = this.size + arguments.length;
	      var head = this._head;
	      for (var ii = arguments.length - 1; ii >= 0; ii--) {
	        head = {
	          value: arguments[ii],
	          next: head
	        };
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };
	
	    Stack.prototype.pushAll = function(iter) {
	      iter = IndexedIterable(iter);
	      if (iter.size === 0) {
	        return this;
	      }
	      assertNotInfinite(iter.size);
	      var newSize = this.size;
	      var head = this._head;
	      iter.reverse().forEach(function(value ) {
	        newSize++;
	        head = {
	          value: value,
	          next: head
	        };
	      });
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };
	
	    Stack.prototype.pop = function() {
	      return this.slice(1);
	    };
	
	    Stack.prototype.unshift = function(/*...values*/) {
	      return this.push.apply(this, arguments);
	    };
	
	    Stack.prototype.unshiftAll = function(iter) {
	      return this.pushAll(iter);
	    };
	
	    Stack.prototype.shift = function() {
	      return this.pop.apply(this, arguments);
	    };
	
	    Stack.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._head = undefined;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyStack();
	    };
	
	    Stack.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      var resolvedBegin = resolveBegin(begin, this.size);
	      var resolvedEnd = resolveEnd(end, this.size);
	      if (resolvedEnd !== this.size) {
	        // super.slice(begin, end);
	        return IndexedCollection.prototype.slice.call(this, begin, end);
	      }
	      var newSize = this.size - resolvedBegin;
	      var head = this._head;
	      while (resolvedBegin--) {
	        head = head.next;
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };
	
	    // @pragma Mutability
	
	    Stack.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeStack(this.size, this._head, ownerID, this.__hash);
	    };
	
	    // @pragma Iteration
	
	    Stack.prototype.__iterate = function(fn, reverse) {
	      if (reverse) {
	        return this.reverse().__iterate(fn);
	      }
	      var iterations = 0;
	      var node = this._head;
	      while (node) {
	        if (fn(node.value, iterations++, this) === false) {
	          break;
	        }
	        node = node.next;
	      }
	      return iterations;
	    };
	
	    Stack.prototype.__iterator = function(type, reverse) {
	      if (reverse) {
	        return this.reverse().__iterator(type);
	      }
	      var iterations = 0;
	      var node = this._head;
	      return new Iterator(function()  {
	        if (node) {
	          var value = node.value;
	          node = node.next;
	          return iteratorValue(type, iterations++, value);
	        }
	        return iteratorDone();
	      });
	    };
	
	
	  function isStack(maybeStack) {
	    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
	  }
	
	  Stack.isStack = isStack;
	
	  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';
	
	  var StackPrototype = Stack.prototype;
	  StackPrototype[IS_STACK_SENTINEL] = true;
	  StackPrototype.withMutations = MapPrototype.withMutations;
	  StackPrototype.asMutable = MapPrototype.asMutable;
	  StackPrototype.asImmutable = MapPrototype.asImmutable;
	  StackPrototype.wasAltered = MapPrototype.wasAltered;
	
	
	  function makeStack(size, head, ownerID, hash) {
	    var map = Object.create(StackPrototype);
	    map.size = size;
	    map._head = head;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }
	
	  var EMPTY_STACK;
	  function emptyStack() {
	    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
	  }
	
	  /**
	   * Contributes additional methods to a constructor
	   */
	  function mixin(ctor, methods) {
	    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
	    Object.keys(methods).forEach(keyCopier);
	    Object.getOwnPropertySymbols &&
	      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
	    return ctor;
	  }
	
	  Iterable.Iterator = Iterator;
	
	  mixin(Iterable, {
	
	    // ### Conversion to other types
	
	    toArray: function() {
	      assertNotInfinite(this.size);
	      var array = new Array(this.size || 0);
	      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
	      return array;
	    },
	
	    toIndexedSeq: function() {
	      return new ToIndexedSequence(this);
	    },
	
	    toJS: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
	      ).__toJS();
	    },
	
	    toJSON: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
	      ).__toJS();
	    },
	
	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, true);
	    },
	
	    toMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Map(this.toKeyedSeq());
	    },
	
	    toObject: function() {
	      assertNotInfinite(this.size);
	      var object = {};
	      this.__iterate(function(v, k)  { object[k] = v; });
	      return object;
	    },
	
	    toOrderedMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedMap(this.toKeyedSeq());
	    },
	
	    toOrderedSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	    toSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Set(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	    toSetSeq: function() {
	      return new ToSetSequence(this);
	    },
	
	    toSeq: function() {
	      return isIndexed(this) ? this.toIndexedSeq() :
	        isKeyed(this) ? this.toKeyedSeq() :
	        this.toSetSeq();
	    },
	
	    toStack: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Stack(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	    toList: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return List(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	
	    // ### Common JavaScript methods and properties
	
	    toString: function() {
	      return '[Iterable]';
	    },
	
	    __toString: function(head, tail) {
	      if (this.size === 0) {
	        return head + tail;
	      }
	      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
	    },
	
	
	    // ### ES6 Collection methods (ES6 Array and Map)
	
	    concat: function() {var values = SLICE$0.call(arguments, 0);
	      return reify(this, concatFactory(this, values));
	    },
	
	    includes: function(searchValue) {
	      return this.some(function(value ) {return is(value, searchValue)});
	    },
	
	    entries: function() {
	      return this.__iterator(ITERATE_ENTRIES);
	    },
	
	    every: function(predicate, context) {
	      assertNotInfinite(this.size);
	      var returnValue = true;
	      this.__iterate(function(v, k, c)  {
	        if (!predicate.call(context, v, k, c)) {
	          returnValue = false;
	          return false;
	        }
	      });
	      return returnValue;
	    },
	
	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, true));
	    },
	
	    find: function(predicate, context, notSetValue) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[1] : notSetValue;
	    },
	
	    forEach: function(sideEffect, context) {
	      assertNotInfinite(this.size);
	      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
	    },
	
	    join: function(separator) {
	      assertNotInfinite(this.size);
	      separator = separator !== undefined ? '' + separator : ',';
	      var joined = '';
	      var isFirst = true;
	      this.__iterate(function(v ) {
	        isFirst ? (isFirst = false) : (joined += separator);
	        joined += v !== null && v !== undefined ? v.toString() : '';
	      });
	      return joined;
	    },
	
	    keys: function() {
	      return this.__iterator(ITERATE_KEYS);
	    },
	
	    map: function(mapper, context) {
	      return reify(this, mapFactory(this, mapper, context));
	    },
	
	    reduce: function(reducer, initialReduction, context) {
	      assertNotInfinite(this.size);
	      var reduction;
	      var useFirst;
	      if (arguments.length < 2) {
	        useFirst = true;
	      } else {
	        reduction = initialReduction;
	      }
	      this.__iterate(function(v, k, c)  {
	        if (useFirst) {
	          useFirst = false;
	          reduction = v;
	        } else {
	          reduction = reducer.call(context, reduction, v, k, c);
	        }
	      });
	      return reduction;
	    },
	
	    reduceRight: function(reducer, initialReduction, context) {
	      var reversed = this.toKeyedSeq().reverse();
	      return reversed.reduce.apply(reversed, arguments);
	    },
	
	    reverse: function() {
	      return reify(this, reverseFactory(this, true));
	    },
	
	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, true));
	    },
	
	    some: function(predicate, context) {
	      return !this.every(not(predicate), context);
	    },
	
	    sort: function(comparator) {
	      return reify(this, sortFactory(this, comparator));
	    },
	
	    values: function() {
	      return this.__iterator(ITERATE_VALUES);
	    },
	
	
	    // ### More sequential methods
	
	    butLast: function() {
	      return this.slice(0, -1);
	    },
	
	    isEmpty: function() {
	      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
	    },
	
	    count: function(predicate, context) {
	      return ensureSize(
	        predicate ? this.toSeq().filter(predicate, context) : this
	      );
	    },
	
	    countBy: function(grouper, context) {
	      return countByFactory(this, grouper, context);
	    },
	
	    equals: function(other) {
	      return deepEqual(this, other);
	    },
	
	    entrySeq: function() {
	      var iterable = this;
	      if (iterable._cache) {
	        // We cache as an entries array, so we can just return the cache!
	        return new ArraySeq(iterable._cache);
	      }
	      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
	      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
	      return entriesSequence;
	    },
	
	    filterNot: function(predicate, context) {
	      return this.filter(not(predicate), context);
	    },
	
	    findEntry: function(predicate, context, notSetValue) {
	      var found = notSetValue;
	      this.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          found = [k, v];
	          return false;
	        }
	      });
	      return found;
	    },
	
	    findKey: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry && entry[0];
	    },
	
	    findLast: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
	    },
	
	    findLastEntry: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
	    },
	
	    findLastKey: function(predicate, context) {
	      return this.toKeyedSeq().reverse().findKey(predicate, context);
	    },
	
	    first: function() {
	      return this.find(returnTrue);
	    },
	
	    flatMap: function(mapper, context) {
	      return reify(this, flatMapFactory(this, mapper, context));
	    },
	
	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, true));
	    },
	
	    fromEntrySeq: function() {
	      return new FromEntriesSequence(this);
	    },
	
	    get: function(searchKey, notSetValue) {
	      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
	    },
	
	    getIn: function(searchKeyPath, notSetValue) {
	      var nested = this;
	      // Note: in an ES6 environment, we would prefer:
	      // for (var key of searchKeyPath) {
	      var iter = forceIterator(searchKeyPath);
	      var step;
	      while (!(step = iter.next()).done) {
	        var key = step.value;
	        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
	        if (nested === NOT_SET) {
	          return notSetValue;
	        }
	      }
	      return nested;
	    },
	
	    groupBy: function(grouper, context) {
	      return groupByFactory(this, grouper, context);
	    },
	
	    has: function(searchKey) {
	      return this.get(searchKey, NOT_SET) !== NOT_SET;
	    },
	
	    hasIn: function(searchKeyPath) {
	      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
	    },
	
	    isSubset: function(iter) {
	      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
	      return this.every(function(value ) {return iter.includes(value)});
	    },
	
	    isSuperset: function(iter) {
	      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
	      return iter.isSubset(this);
	    },
	
	    keyOf: function(searchValue) {
	      return this.findKey(function(value ) {return is(value, searchValue)});
	    },
	
	    keySeq: function() {
	      return this.toSeq().map(keyMapper).toIndexedSeq();
	    },
	
	    last: function() {
	      return this.toSeq().reverse().first();
	    },
	
	    lastKeyOf: function(searchValue) {
	      return this.toKeyedSeq().reverse().keyOf(searchValue);
	    },
	
	    max: function(comparator) {
	      return maxFactory(this, comparator);
	    },
	
	    maxBy: function(mapper, comparator) {
	      return maxFactory(this, comparator, mapper);
	    },
	
	    min: function(comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
	    },
	
	    minBy: function(mapper, comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
	    },
	
	    rest: function() {
	      return this.slice(1);
	    },
	
	    skip: function(amount) {
	      return this.slice(Math.max(0, amount));
	    },
	
	    skipLast: function(amount) {
	      return reify(this, this.toSeq().reverse().skip(amount).reverse());
	    },
	
	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, true));
	    },
	
	    skipUntil: function(predicate, context) {
	      return this.skipWhile(not(predicate), context);
	    },
	
	    sortBy: function(mapper, comparator) {
	      return reify(this, sortFactory(this, comparator, mapper));
	    },
	
	    take: function(amount) {
	      return this.slice(0, Math.max(0, amount));
	    },
	
	    takeLast: function(amount) {
	      return reify(this, this.toSeq().reverse().take(amount).reverse());
	    },
	
	    takeWhile: function(predicate, context) {
	      return reify(this, takeWhileFactory(this, predicate, context));
	    },
	
	    takeUntil: function(predicate, context) {
	      return this.takeWhile(not(predicate), context);
	    },
	
	    valueSeq: function() {
	      return this.toIndexedSeq();
	    },
	
	
	    // ### Hashable Object
	
	    hashCode: function() {
	      return this.__hash || (this.__hash = hashIterable(this));
	    }
	
	
	    // ### Internal
	
	    // abstract __iterate(fn, reverse)
	
	    // abstract __iterator(type, reverse)
	  });
	
	  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
	
	  var IterablePrototype = Iterable.prototype;
	  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
	  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
	  IterablePrototype.__toJS = IterablePrototype.toArray;
	  IterablePrototype.__toStringMapper = quoteString;
	  IterablePrototype.inspect =
	  IterablePrototype.toSource = function() { return this.toString(); };
	  IterablePrototype.chain = IterablePrototype.flatMap;
	  IterablePrototype.contains = IterablePrototype.includes;
	
	  mixin(KeyedIterable, {
	
	    // ### More sequential methods
	
	    flip: function() {
	      return reify(this, flipFactory(this));
	    },
	
	    mapEntries: function(mapper, context) {var this$0 = this;
	      var iterations = 0;
	      return reify(this,
	        this.toSeq().map(
	          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
	        ).fromEntrySeq()
	      );
	    },
	
	    mapKeys: function(mapper, context) {var this$0 = this;
	      return reify(this,
	        this.toSeq().flip().map(
	          function(k, v)  {return mapper.call(context, k, v, this$0)}
	        ).flip()
	      );
	    }
	
	  });
	
	  var KeyedIterablePrototype = KeyedIterable.prototype;
	  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
	  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
	  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
	  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};
	
	
	
	  mixin(IndexedIterable, {
	
	    // ### Conversion to other types
	
	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, false);
	    },
	
	
	    // ### ES6 Collection methods (ES6 Array and Map)
	
	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, false));
	    },
	
	    findIndex: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },
	
	    indexOf: function(searchValue) {
	      var key = this.keyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },
	
	    lastIndexOf: function(searchValue) {
	      var key = this.lastKeyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },
	
	    reverse: function() {
	      return reify(this, reverseFactory(this, false));
	    },
	
	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, false));
	    },
	
	    splice: function(index, removeNum /*, ...values*/) {
	      var numArgs = arguments.length;
	      removeNum = Math.max(removeNum | 0, 0);
	      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
	        return this;
	      }
	      // If index is negative, it should resolve relative to the size of the
	      // collection. However size may be expensive to compute if not cached, so
	      // only call count() if the number is in fact negative.
	      index = resolveBegin(index, index < 0 ? this.count() : this.size);
	      var spliced = this.slice(0, index);
	      return reify(
	        this,
	        numArgs === 1 ?
	          spliced :
	          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
	      );
	    },
	
	
	    // ### More collection methods
	
	    findLastIndex: function(predicate, context) {
	      var entry = this.findLastEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },
	
	    first: function() {
	      return this.get(0);
	    },
	
	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, false));
	    },
	
	    get: function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      return (index < 0 || (this.size === Infinity ||
	          (this.size !== undefined && index > this.size))) ?
	        notSetValue :
	        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
	    },
	
	    has: function(index) {
	      index = wrapIndex(this, index);
	      return index >= 0 && (this.size !== undefined ?
	        this.size === Infinity || index < this.size :
	        this.indexOf(index) !== -1
	      );
	    },
	
	    interpose: function(separator) {
	      return reify(this, interposeFactory(this, separator));
	    },
	
	    interleave: function(/*...iterables*/) {
	      var iterables = [this].concat(arrCopy(arguments));
	      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
	      var interleaved = zipped.flatten(true);
	      if (zipped.size) {
	        interleaved.size = zipped.size * iterables.length;
	      }
	      return reify(this, interleaved);
	    },
	
	    keySeq: function() {
	      return Range(0, this.size);
	    },
	
	    last: function() {
	      return this.get(-1);
	    },
	
	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, false));
	    },
	
	    zip: function(/*, ...iterables */) {
	      var iterables = [this].concat(arrCopy(arguments));
	      return reify(this, zipWithFactory(this, defaultZipper, iterables));
	    },
	
	    zipWith: function(zipper/*, ...iterables */) {
	      var iterables = arrCopy(arguments);
	      iterables[0] = this;
	      return reify(this, zipWithFactory(this, zipper, iterables));
	    }
	
	  });
	
	  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
	  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;
	
	
	
	  mixin(SetIterable, {
	
	    // ### ES6 Collection methods (ES6 Array and Map)
	
	    get: function(value, notSetValue) {
	      return this.has(value) ? value : notSetValue;
	    },
	
	    includes: function(value) {
	      return this.has(value);
	    },
	
	
	    // ### More sequential methods
	
	    keySeq: function() {
	      return this.valueSeq();
	    }
	
	  });
	
	  SetIterable.prototype.has = IterablePrototype.includes;
	  SetIterable.prototype.contains = SetIterable.prototype.includes;
	
	
	  // Mixin subclasses
	
	  mixin(KeyedSeq, KeyedIterable.prototype);
	  mixin(IndexedSeq, IndexedIterable.prototype);
	  mixin(SetSeq, SetIterable.prototype);
	
	  mixin(KeyedCollection, KeyedIterable.prototype);
	  mixin(IndexedCollection, IndexedIterable.prototype);
	  mixin(SetCollection, SetIterable.prototype);
	
	
	  // #pragma Helper functions
	
	  function keyMapper(v, k) {
	    return k;
	  }
	
	  function entryMapper(v, k) {
	    return [k, v];
	  }
	
	  function not(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    }
	  }
	
	  function neg(predicate) {
	    return function() {
	      return -predicate.apply(this, arguments);
	    }
	  }
	
	  function quoteString(value) {
	    return typeof value === 'string' ? JSON.stringify(value) : String(value);
	  }
	
	  function defaultZipper() {
	    return arrCopy(arguments);
	  }
	
	  function defaultNegComparator(a, b) {
	    return a < b ? 1 : a > b ? -1 : 0;
	  }
	
	  function hashIterable(iterable) {
	    if (iterable.size === Infinity) {
	      return 0;
	    }
	    var ordered = isOrdered(iterable);
	    var keyed = isKeyed(iterable);
	    var h = ordered ? 1 : 0;
	    var size = iterable.__iterate(
	      keyed ?
	        ordered ?
	          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
	          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
	        ordered ?
	          function(v ) { h = 31 * h + hash(v) | 0; } :
	          function(v ) { h = h + hash(v) | 0; }
	    );
	    return murmurHashOfSize(size, h);
	  }
	
	  function murmurHashOfSize(size, h) {
	    h = imul(h, 0xCC9E2D51);
	    h = imul(h << 15 | h >>> -15, 0x1B873593);
	    h = imul(h << 13 | h >>> -13, 5);
	    h = (h + 0xE6546B64 | 0) ^ size;
	    h = imul(h ^ h >>> 16, 0x85EBCA6B);
	    h = imul(h ^ h >>> 13, 0xC2B2AE35);
	    h = smi(h ^ h >>> 16);
	    return h;
	  }
	
	  function hashMerge(a, b) {
	    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
	  }
	
	  var Immutable = {
	
	    Iterable: Iterable,
	
	    Seq: Seq,
	    Collection: Collection,
	    Map: Map,
	    OrderedMap: OrderedMap,
	    List: List,
	    Stack: Stack,
	    Set: Set,
	    OrderedSet: OrderedSet,
	
	    Record: Record,
	    Range: Range,
	    Repeat: Repeat,
	
	    is: is,
	    fromJS: fromJS
	
	  };
	
	  return Immutable;
	
	}));

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	const Immutable = __webpack_require__(180);
	
	// When our app state is fully types, we should be able to get rid of
	// this function. This is only temporarily necessary to support
	// converting typed objects to immutable.js, which usually happens in
	// reducers.
	function fromJS(value) {
	  if (Array.isArray(value)) {
	    return Immutable.Seq(value).map(fromJS).toList();
	  }
	  if (value && value.constructor.meta) {
	    // This adds support for tcomb objects which are native JS objects
	    // but are not "plain", so the above checks fail. Since they
	    // behave the same we can use the same constructors, but we need
	    // special checks for them.
	    const kind = value.constructor.meta.kind;
	    if (kind === "struct") {
	      return Immutable.Seq(value).map(fromJS).toMap();
	    } else if (kind === "list") {
	      return Immutable.Seq(value).map(fromJS).toList();
	    }
	  }
	
	  // If it's a primitive type, just return the value. Note `==` check
	  // for null, which is intentionally used to match either `null` or
	  // `undefined`.
	  if (value == null || typeof value !== "object") {
	    return value;
	  }
	
	  // Otherwise, treat it like an object. We can't reliably detect if
	  // it's a plain object because we might be objects from other JS
	  // contexts so `Object !== Object`.
	  return Immutable.Seq(value).map(fromJS).toMap();
	}
	
	module.exports = fromJS;

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	const { PropTypes } = React;
	const ImPropTypes = __webpack_require__(183);
	const { connect } = __webpack_require__(149);
	const { bindActionCreators } = __webpack_require__(130);
	const { getTabs, getFilterString } = __webpack_require__(184);
	const { getValue } = __webpack_require__(65);
	const LandingPage = React.createFactory(__webpack_require__(192));
	
	const LaunchpadApp = React.createClass({
	  propTypes: {
	    tabs: ImPropTypes.map.isRequired,
	    filterString: PropTypes.string,
	    actions: PropTypes.object
	  },
	
	  displayName: "LaunchpadApp",
	
	  render() {
	    return LandingPage({
	      tabs: this.props.tabs,
	      supportsFirefox: !!getValue("firefox"),
	      supportsChrome: !!getValue("chrome"),
	      title: getValue("title"),
	      filterString: this.props.filterString,
	      onFilterChange: this.props.actions.filterTabs,
	      onTabClick: url => {
	        window.location = url;
	      }
	    });
	  }
	});
	
	function mapStateToProps(state) {
	  return {
	    tabs: getTabs(state),
	    filterString: getFilterString(state)
	  };
	}
	
	function mapDispatchToProps(dispatch) {
	  return {
	    actions: bindActionCreators(__webpack_require__(195), dispatch)
	  };
	}
	
	module.exports = connect(mapStateToProps, mapDispatchToProps)(LaunchpadApp);

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * This is a straight rip-off of the React.js ReactPropTypes.js proptype validators,
	 * modified to make it possible to validate Immutable.js data.
	 *     ImmutableTypes.listOf is patterned after React.PropTypes.arrayOf, but for Immutable.List
	 *     ImmutableTypes.shape  is based on React.PropTypes.shape, but for any Immutable.Iterable
	 */
	"use strict";
	
	var Immutable = __webpack_require__(180);
	
	var ANONYMOUS = "<<anonymous>>";
	
	var ImmutablePropTypes = {
	  listOf: createListOfTypeChecker,
	  mapOf: createMapOfTypeChecker,
	  orderedMapOf: createOrderedMapOfTypeChecker,
	  setOf: createSetOfTypeChecker,
	  orderedSetOf: createOrderedSetOfTypeChecker,
	  stackOf: createStackOfTypeChecker,
	  iterableOf: createIterableOfTypeChecker,
	  recordOf: createRecordOfTypeChecker,
	  shape: createShapeChecker,
	  contains: createShapeChecker,
	  mapContains: createMapContainsChecker,
	  // Primitive Types
	  list: createImmutableTypeChecker("List", Immutable.List.isList),
	  map: createImmutableTypeChecker("Map", Immutable.Map.isMap),
	  orderedMap: createImmutableTypeChecker("OrderedMap", Immutable.OrderedMap.isOrderedMap),
	  set: createImmutableTypeChecker("Set", Immutable.Set.isSet),
	  orderedSet: createImmutableTypeChecker("OrderedSet", Immutable.OrderedSet.isOrderedSet),
	  stack: createImmutableTypeChecker("Stack", Immutable.Stack.isStack),
	  seq: createImmutableTypeChecker("Seq", Immutable.Seq.isSeq),
	  record: createImmutableTypeChecker("Record", function (isRecord) {
	    return isRecord instanceof Immutable.Record;
	  }),
	  iterable: createImmutableTypeChecker("Iterable", Immutable.Iterable.isIterable)
	};
	
	function getPropType(propValue) {
	  var propType = typeof propValue;
	  if (Array.isArray(propValue)) {
	    return "array";
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return "object";
	  }
	  if (propValue instanceof Immutable.Iterable) {
	    return "Immutable." + propValue.toSource().split(" ")[0];
	  }
	  return propType;
	}
	
	function createChainableTypeChecker(validate) {
	  function checkType(isRequired, props, propName, componentName, location, propFullName) {
	    propFullName = propFullName || propName;
	    componentName = componentName || ANONYMOUS;
	    if (props[propName] == null) {
	      var locationName = location;
	      if (isRequired) {
	        return new Error("Required " + locationName + " `" + propFullName + "` was not specified in " + ("`" + componentName + "`."));
	      }
	    } else {
	      return validate(props, propName, componentName, location, propFullName);
	    }
	  }
	
	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);
	
	  return chainedCheckType;
	}
	
	function createImmutableTypeChecker(immutableClassName, immutableClassTypeValidator) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!immutableClassTypeValidator(propValue)) {
	      var propType = getPropType(propValue);
	      return new Error("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `" + immutableClassName + "`."));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createIterableTypeChecker(typeChecker, immutableClassName, immutableClassTypeValidator) {
	
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!immutableClassTypeValidator(propValue)) {
	      var locationName = location;
	      var propType = getPropType(propValue);
	      return new Error("Invalid " + locationName + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an Immutable.js " + immutableClassName + "."));
	    }
	
	    if (typeof typeChecker !== "function") {
	      return new Error("Invalid typeChecker supplied to `" + componentName + "` " + ("for propType `" + propFullName + "`, expected a function."));
	    }
	
	    var propValues = propValue.toArray();
	    for (var i = 0, len = propValues.length; i < len; i++) {
	      var error = typeChecker(propValues, i, componentName, location, "" + propFullName + "[" + i + "]");
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createListOfTypeChecker(typeChecker) {
	  return createIterableTypeChecker(typeChecker, "List", Immutable.List.isList);
	}
	
	function createMapOfTypeChecker(typeChecker) {
	  return createIterableTypeChecker(typeChecker, "Map", Immutable.Map.isMap);
	}
	
	function createOrderedMapOfTypeChecker(typeChecker) {
	  return createIterableTypeChecker(typeChecker, "OrderedMap", Immutable.OrderedMap.isOrderedMap);
	}
	
	function createSetOfTypeChecker(typeChecker) {
	  return createIterableTypeChecker(typeChecker, "Set", Immutable.Set.isSet);
	}
	
	function createOrderedSetOfTypeChecker(typeChecker) {
	  return createIterableTypeChecker(typeChecker, "OrderedSet", Immutable.OrderedSet.isOrderedSet);
	}
	
	function createStackOfTypeChecker(typeChecker) {
	  return createIterableTypeChecker(typeChecker, "Stack", Immutable.Stack.isStack);
	}
	
	function createIterableOfTypeChecker(typeChecker) {
	  return createIterableTypeChecker(typeChecker, "Iterable", Immutable.Iterable.isIterable);
	}
	
	function createRecordOfTypeChecker(recordKeys) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!(propValue instanceof Immutable.Record)) {
	      var propType = getPropType(propValue);
	      var locationName = location;
	      return new Error("Invalid " + locationName + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected an Immutable.js Record."));
	    }
	    for (var key in recordKeys) {
	      var checker = recordKeys[key];
	      if (!checker) {
	        continue;
	      }
	      var mutablePropValue = propValue.toObject();
	      var error = checker(mutablePropValue, key, componentName, location, "" + propFullName + "." + key);
	      if (error) {
	        return error;
	      }
	    }
	  }
	  return createChainableTypeChecker(validate);
	}
	
	// there is some irony in the fact that shapeTypes is a standard hash and not an immutable collection
	function createShapeTypeChecker(shapeTypes) {
	  var immutableClassName = arguments[1] === undefined ? "Iterable" : arguments[1];
	  var immutableClassTypeValidator = arguments[2] === undefined ? Immutable.Iterable.isIterable : arguments[2];
	
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!immutableClassTypeValidator(propValue)) {
	      var propType = getPropType(propValue);
	      var locationName = location;
	      return new Error("Invalid " + locationName + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected an Immutable.js " + immutableClassName + "."));
	    }
	    var mutablePropValue = propValue.toObject();
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(mutablePropValue, key, componentName, location, "" + propFullName + "." + key);
	      if (error) {
	        return error;
	      }
	    }
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createShapeChecker(shapeTypes) {
	  return createShapeTypeChecker(shapeTypes);
	}
	
	function createMapContainsChecker(shapeTypes) {
	  return createShapeTypeChecker(shapeTypes, "Map", Immutable.Map.isMap);
	}
	
	module.exports = ImmutablePropTypes;

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	const { score } = __webpack_require__(185);
	
	function getTabs(state) {
	  let tabs = state.tabs.get("tabs");
	  let filterString = getFilterString(state);
	
	  if (filterString === "") {
	    return tabs;
	  }
	
	  return tabs.filter(tab => score(tab.get("title"), filterString) + score(tab.get("url"), filterString) > 0);
	}
	
	function getSelectedTab(state) {
	  return state.tabs.get("selectedTab");
	}
	
	function getFilterString(state) {
	  return state.tabs.get("filterString");
	}
	
	module.exports = {
	  getTabs,
	  getSelectedTab,
	  getFilterString
	};

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {(function() {
	  var Query, defaultPathSeparator, filter, matcher, parseOptions, pathScorer, preparedQueryCache, scorer;
	
	  filter = __webpack_require__(187);
	
	  matcher = __webpack_require__(191);
	
	  scorer = __webpack_require__(188);
	
	  pathScorer = __webpack_require__(189);
	
	  Query = __webpack_require__(190);
	
	  preparedQueryCache = null;
	
	  defaultPathSeparator = (typeof process !== "undefined" && process !== null ? process.platform : void 0) === "win32" ? '\\' : '/';
	
	  module.exports = {
	    filter: function(candidates, query, options) {
	      if (options == null) {
	        options = {};
	      }
	      if (!((query != null ? query.length : void 0) && (candidates != null ? candidates.length : void 0))) {
	        return [];
	      }
	      options = parseOptions(options, query);
	      return filter(candidates, query, options);
	    },
	    score: function(string, query, options) {
	      if (options == null) {
	        options = {};
	      }
	      if (!((string != null ? string.length : void 0) && (query != null ? query.length : void 0))) {
	        return 0;
	      }
	      options = parseOptions(options, query);
	      if (options.usePathScoring) {
	        return pathScorer.score(string, query, options);
	      } else {
	        return scorer.score(string, query, options);
	      }
	    },
	    match: function(string, query, options) {
	      var _i, _ref, _results;
	      if (options == null) {
	        options = {};
	      }
	      if (!string) {
	        return [];
	      }
	      if (!query) {
	        return [];
	      }
	      if (string === query) {
	        return (function() {
	          _results = [];
	          for (var _i = 0, _ref = string.length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
	          return _results;
	        }).apply(this);
	      }
	      options = parseOptions(options, query);
	      return matcher.match(string, query, options);
	    },
	    wrap: function(string, query, options) {
	      if (options == null) {
	        options = {};
	      }
	      if (!string) {
	        return [];
	      }
	      if (!query) {
	        return [];
	      }
	      options = parseOptions(options, query);
	      return matcher.wrap(string, query, options);
	    },
	    prepareQuery: function(query, options) {
	      if (options == null) {
	        options = {};
	      }
	      options = parseOptions(options, query);
	      return options.preparedQuery;
	    }
	  };
	
	  parseOptions = function(options, query) {
	    if (options.allowErrors == null) {
	      options.allowErrors = false;
	    }
	    if (options.usePathScoring == null) {
	      options.usePathScoring = true;
	    }
	    if (options.useExtensionBonus == null) {
	      options.useExtensionBonus = false;
	    }
	    if (options.pathSeparator == null) {
	      options.pathSeparator = defaultPathSeparator;
	    }
	    if (options.optCharRegEx == null) {
	      options.optCharRegEx = null;
	    }
	    if (options.wrap == null) {
	      options.wrap = null;
	    }
	    if (options.preparedQuery == null) {
	      options.preparedQuery = preparedQueryCache && preparedQueryCache.query === query ? preparedQueryCache : (preparedQueryCache = new Query(query, options));
	    }
	    return options;
	  };
	
	}).call(this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(186)))

/***/ },
/* 186 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	  var Query, pathScorer, pluckCandidates, scorer, sortCandidates;
	
	  scorer = __webpack_require__(188);
	
	  pathScorer = __webpack_require__(189);
	
	  Query = __webpack_require__(190);
	
	  pluckCandidates = function(a) {
	    return a.candidate;
	  };
	
	  sortCandidates = function(a, b) {
	    return b.score - a.score;
	  };
	
	  module.exports = function(candidates, query, options) {
	    var bKey, candidate, key, maxInners, maxResults, score, scoreProvider, scoredCandidates, spotLeft, string, usePathScoring, _i, _len;
	    scoredCandidates = [];
	    key = options.key, maxResults = options.maxResults, maxInners = options.maxInners, usePathScoring = options.usePathScoring;
	    spotLeft = (maxInners != null) && maxInners > 0 ? maxInners : candidates.length + 1;
	    bKey = key != null;
	    scoreProvider = usePathScoring ? pathScorer : scorer;
	    for (_i = 0, _len = candidates.length; _i < _len; _i++) {
	      candidate = candidates[_i];
	      string = bKey ? candidate[key] : candidate;
	      if (!string) {
	        continue;
	      }
	      score = scoreProvider.score(string, query, options);
	      if (score > 0) {
	        scoredCandidates.push({
	          candidate: candidate,
	          score: score
	        });
	        if (!--spotLeft) {
	          break;
	        }
	      }
	    }
	    scoredCandidates.sort(sortCandidates);
	    candidates = scoredCandidates.map(pluckCandidates);
	    if (maxResults != null) {
	      candidates = candidates.slice(0, maxResults);
	    }
	    return candidates;
	  };
	
	}).call(this);


/***/ },
/* 188 */
/***/ function(module, exports) {

	(function() {
	  var AcronymResult, computeScore, emptyAcronymResult, isAcronymFullWord, isMatch, isSeparator, isWordEnd, isWordStart, miss_coeff, pos_bonus, scoreAcronyms, scoreCharacter, scoreConsecutives, scoreExact, scoreExactMatch, scorePattern, scorePosition, scoreSize, tau_size, wm;
	
	  wm = 150;
	
	  pos_bonus = 20;
	
	  tau_size = 85;
	
	  miss_coeff = 0.75;
	
	  exports.score = function(string, query, options) {
	    var allowErrors, preparedQuery, score, string_lw;
	    preparedQuery = options.preparedQuery, allowErrors = options.allowErrors;
	    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {
	      return 0;
	    }
	    string_lw = string.toLowerCase();
	    score = computeScore(string, string_lw, preparedQuery);
	    return Math.ceil(score);
	  };
	
	  exports.isMatch = isMatch = function(subject, query_lw, query_up) {
	    var i, j, m, n, qj_lw, qj_up, si;
	    m = subject.length;
	    n = query_lw.length;
	    if (!m || n > m) {
	      return false;
	    }
	    i = -1;
	    j = -1;
	    while (++j < n) {
	      qj_lw = query_lw.charCodeAt(j);
	      qj_up = query_up.charCodeAt(j);
	      while (++i < m) {
	        si = subject.charCodeAt(i);
	        if (si === qj_lw || si === qj_up) {
	          break;
	        }
	      }
	      if (i === m) {
	        return false;
	      }
	    }
	    return true;
	  };
	
	  exports.computeScore = computeScore = function(subject, subject_lw, preparedQuery) {
	    var acro, acro_score, align, csc_diag, csc_invalid, csc_row, csc_score, i, j, m, miss_budget, miss_left, mm, n, pos, query, query_lw, record_miss, score, score_diag, score_row, score_up, si_lw, start, sz;
	    query = preparedQuery.query;
	    query_lw = preparedQuery.query_lw;
	    m = subject.length;
	    n = query.length;
	    acro = scoreAcronyms(subject, subject_lw, query, query_lw);
	    acro_score = acro.score;
	    if (acro.count === n) {
	      return scoreExact(n, m, acro_score, acro.pos);
	    }
	    pos = subject_lw.indexOf(query_lw);
	    if (pos > -1) {
	      return scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m);
	    }
	    score_row = new Array(n);
	    csc_row = new Array(n);
	    sz = scoreSize(n, m);
	    miss_budget = Math.ceil(miss_coeff * n) + 5;
	    miss_left = miss_budget;
	    j = -1;
	    while (++j < n) {
	      score_row[j] = 0;
	      csc_row[j] = 0;
	    }
	    i = subject_lw.indexOf(query_lw[0]);
	    if (i > -1) {
	      i--;
	    }
	    mm = subject_lw.lastIndexOf(query_lw[n - 1], m);
	    if (mm > i) {
	      m = mm + 1;
	    }
	    csc_invalid = true;
	    while (++i < m) {
	      si_lw = subject_lw[i];
	      if (preparedQuery.charCodes[si_lw.charCodeAt(0)] == null) {
	        if (csc_invalid !== true) {
	          j = -1;
	          while (++j < n) {
	            csc_row[j] = 0;
	          }
	          csc_invalid = true;
	        }
	        continue;
	      }
	      score = 0;
	      score_diag = 0;
	      csc_diag = 0;
	      record_miss = true;
	      csc_invalid = false;
	      j = -1;
	      while (++j < n) {
	        score_up = score_row[j];
	        if (score_up > score) {
	          score = score_up;
	        }
	        csc_score = 0;
	        if (query_lw[j] === si_lw) {
	          start = isWordStart(i, subject, subject_lw);
	          csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);
	          align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);
	          if (align > score) {
	            score = align;
	            miss_left = miss_budget;
	          } else {
	            if (record_miss && --miss_left <= 0) {
	              return score_row[n - 1] * sz;
	            }
	            record_miss = false;
	          }
	        }
	        score_diag = score_up;
	        csc_diag = csc_row[j];
	        csc_row[j] = csc_score;
	        score_row[j] = score;
	      }
	    }
	    score = score_row[n - 1];
	    return score * sz;
	  };
	
	  exports.isWordStart = isWordStart = function(pos, subject, subject_lw) {
	    var curr_s, prev_s;
	    if (pos === 0) {
	      return true;
	    }
	    curr_s = subject[pos];
	    prev_s = subject[pos - 1];
	    return isSeparator(prev_s) || (curr_s !== subject_lw[pos] && prev_s === subject_lw[pos - 1]);
	  };
	
	  exports.isWordEnd = isWordEnd = function(pos, subject, subject_lw, len) {
	    var curr_s, next_s;
	    if (pos === len - 1) {
	      return true;
	    }
	    curr_s = subject[pos];
	    next_s = subject[pos + 1];
	    return isSeparator(next_s) || (curr_s === subject_lw[pos] && next_s !== subject_lw[pos + 1]);
	  };
	
	  isSeparator = function(c) {
	    return c === ' ' || c === '.' || c === '-' || c === '_' || c === '/' || c === '\\';
	  };
	
	  scorePosition = function(pos) {
	    var sc;
	    if (pos < pos_bonus) {
	      sc = pos_bonus - pos;
	      return 100 + sc * sc;
	    } else {
	      return Math.max(100 + pos_bonus - pos, 0);
	    }
	  };
	
	  exports.scoreSize = scoreSize = function(n, m) {
	    return tau_size / (tau_size + Math.abs(m - n));
	  };
	
	  scoreExact = function(n, m, quality, pos) {
	    return 2 * n * (wm * quality + scorePosition(pos)) * scoreSize(n, m);
	  };
	
	  exports.scorePattern = scorePattern = function(count, len, sameCase, start, end) {
	    var bonus, sz;
	    sz = count;
	    bonus = 6;
	    if (sameCase === count) {
	      bonus += 2;
	    }
	    if (start) {
	      bonus += 3;
	    }
	    if (end) {
	      bonus += 1;
	    }
	    if (count === len) {
	      if (start) {
	        if (sameCase === len) {
	          sz += 2;
	        } else {
	          sz += 1;
	        }
	      }
	      if (end) {
	        bonus += 1;
	      }
	    }
	    return sameCase + sz * (sz + bonus);
	  };
	
	  exports.scoreCharacter = scoreCharacter = function(i, j, start, acro_score, csc_score) {
	    var posBonus;
	    posBonus = scorePosition(i);
	    if (start) {
	      return posBonus + wm * ((acro_score > csc_score ? acro_score : csc_score) + 10);
	    }
	    return posBonus + wm * csc_score;
	  };
	
	  exports.scoreConsecutives = scoreConsecutives = function(subject, subject_lw, query, query_lw, i, j, startOfWord) {
	    var k, m, mi, n, nj, sameCase, sz;
	    m = subject.length;
	    n = query.length;
	    mi = m - i;
	    nj = n - j;
	    k = mi < nj ? mi : nj;
	    sameCase = 0;
	    sz = 0;
	    if (query[j] === subject[i]) {
	      sameCase++;
	    }
	    while (++sz < k && query_lw[++j] === subject_lw[++i]) {
	      if (query[j] === subject[i]) {
	        sameCase++;
	      }
	    }
	    if (sz === 1) {
	      return 1 + 2 * sameCase;
	    }
	    return scorePattern(sz, n, sameCase, startOfWord, isWordEnd(i, subject, subject_lw, m));
	  };
	
	  exports.scoreExactMatch = scoreExactMatch = function(subject, subject_lw, query, query_lw, pos, n, m) {
	    var end, i, pos2, sameCase, start;
	    start = isWordStart(pos, subject, subject_lw);
	    if (!start) {
	      pos2 = subject_lw.indexOf(query_lw, pos + 1);
	      if (pos2 > -1) {
	        start = isWordStart(pos2, subject, subject_lw);
	        if (start) {
	          pos = pos2;
	        }
	      }
	    }
	    i = -1;
	    sameCase = 0;
	    while (++i < n) {
	      if (query[pos + i] === subject[i]) {
	        sameCase++;
	      }
	    }
	    end = isWordEnd(pos + n - 1, subject, subject_lw, m);
	    return scoreExact(n, m, scorePattern(n, n, sameCase, start, end), pos);
	  };
	
	  AcronymResult = (function() {
	    function AcronymResult(score, pos, count) {
	      this.score = score;
	      this.pos = pos;
	      this.count = count;
	    }
	
	    return AcronymResult;
	
	  })();
	
	  emptyAcronymResult = new AcronymResult(0, 0.1, 0);
	
	  exports.scoreAcronyms = scoreAcronyms = function(subject, subject_lw, query, query_lw) {
	    var count, fullWord, i, j, m, n, qj_lw, sameCase, score, sepCount, sumPos;
	    m = subject.length;
	    n = query.length;
	    if (!(m > 1 && n > 1)) {
	      return emptyAcronymResult;
	    }
	    count = 0;
	    sepCount = 0;
	    sumPos = 0;
	    sameCase = 0;
	    i = -1;
	    j = -1;
	    while (++j < n) {
	      qj_lw = query_lw[j];
	      if (isSeparator(qj_lw)) {
	        i = subject_lw.indexOf(qj_lw, i + 1);
	        if (i > -1) {
	          sepCount++;
	          continue;
	        } else {
	          break;
	        }
	      }
	      while (++i < m) {
	        if (qj_lw === subject_lw[i] && isWordStart(i, subject, subject_lw)) {
	          if (query[j] === subject[i]) {
	            sameCase++;
	          }
	          sumPos += i;
	          count++;
	          break;
	        }
	      }
	      if (i === m) {
	        break;
	      }
	    }
	    if (count < 2) {
	      return emptyAcronymResult;
	    }
	    fullWord = count === n ? isAcronymFullWord(subject, subject_lw, query, count) : false;
	    score = scorePattern(count, n, sameCase, true, fullWord);
	    return new AcronymResult(score, sumPos / count, count + sepCount);
	  };
	
	  isAcronymFullWord = function(subject, subject_lw, query, nbAcronymInQuery) {
	    var count, i, m, n;
	    m = subject.length;
	    n = query.length;
	    count = 0;
	    if (m > 12 * n) {
	      return false;
	    }
	    i = -1;
	    while (++i < m) {
	      if (isWordStart(i, subject, subject_lw) && ++count > nbAcronymInQuery) {
	        return false;
	      }
	    }
	    return true;
	  };
	
	}).call(this);


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	  var computeScore, countDir, file_coeff, getExtension, getExtensionScore, isMatch, scorePath, scoreSize, tau_depth, _ref;
	
	  _ref = __webpack_require__(188), isMatch = _ref.isMatch, computeScore = _ref.computeScore, scoreSize = _ref.scoreSize;
	
	  tau_depth = 13;
	
	  file_coeff = 1.2;
	
	  exports.score = function(string, query, options) {
	    var allowErrors, preparedQuery, score, string_lw;
	    preparedQuery = options.preparedQuery, allowErrors = options.allowErrors;
	    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {
	      return 0;
	    }
	    string_lw = string.toLowerCase();
	    score = computeScore(string, string_lw, preparedQuery);
	    score = scorePath(string, string_lw, score, options);
	    return Math.ceil(score);
	  };
	
	  scorePath = function(subject, subject_lw, fullPathScore, options) {
	    var alpha, basePathScore, basePos, depth, end, extAdjust, fileLength, pathSeparator, preparedQuery, useExtensionBonus;
	    if (fullPathScore === 0) {
	      return 0;
	    }
	    preparedQuery = options.preparedQuery, useExtensionBonus = options.useExtensionBonus, pathSeparator = options.pathSeparator;
	    end = subject.length - 1;
	    while (subject[end] === pathSeparator) {
	      end--;
	    }
	    basePos = subject.lastIndexOf(pathSeparator, end);
	    fileLength = end - basePos;
	    extAdjust = 1.0;
	    if (useExtensionBonus) {
	      extAdjust += getExtensionScore(subject_lw, preparedQuery.ext, basePos, end, 2);
	      fullPathScore *= extAdjust;
	    }
	    if (basePos === -1) {
	      return fullPathScore;
	    }
	    depth = preparedQuery.depth;
	    while (basePos > -1 && depth-- > 0) {
	      basePos = subject.lastIndexOf(pathSeparator, basePos - 1);
	    }
	    basePathScore = basePos === -1 ? fullPathScore : extAdjust * computeScore(subject.slice(basePos + 1, end + 1), subject_lw.slice(basePos + 1, end + 1), preparedQuery);
	    alpha = 0.5 * tau_depth / (tau_depth + countDir(subject, end + 1, pathSeparator));
	    return alpha * basePathScore + (1 - alpha) * fullPathScore * scoreSize(0, file_coeff * fileLength);
	  };
	
	  exports.countDir = countDir = function(path, end, pathSeparator) {
	    var count, i;
	    if (end < 1) {
	      return 0;
	    }
	    count = 0;
	    i = -1;
	    while (++i < end && path[i] === pathSeparator) {
	      continue;
	    }
	    while (++i < end) {
	      if (path[i] === pathSeparator) {
	        count++;
	        while (++i < end && path[i] === pathSeparator) {
	          continue;
	        }
	      }
	    }
	    return count;
	  };
	
	  exports.getExtension = getExtension = function(str) {
	    var pos;
	    pos = str.lastIndexOf(".");
	    if (pos < 0) {
	      return "";
	    } else {
	      return str.substr(pos + 1);
	    }
	  };
	
	  getExtensionScore = function(candidate, ext, startPos, endPos, maxDepth) {
	    var m, matched, n, pos;
	    if (!ext.length) {
	      return 0;
	    }
	    pos = candidate.lastIndexOf(".", endPos);
	    if (!(pos > startPos)) {
	      return 0;
	    }
	    n = ext.length;
	    m = endPos - pos;
	    if (m < n) {
	      n = m;
	      m = ext.length;
	    }
	    pos++;
	    matched = -1;
	    while (++matched < n) {
	      if (candidate[pos + matched] !== ext[matched]) {
	        break;
	      }
	    }
	    if (matched === 0 && maxDepth > 0) {
	      return 0.9 * getExtensionScore(candidate, ext, startPos, pos - 2, maxDepth - 1);
	    }
	    return matched / m;
	  };
	
	}).call(this);


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	  var Query, coreChars, countDir, getCharCodes, getExtension, opt_char_re, truncatedUpperCase, _ref;
	
	  _ref = __webpack_require__(189), countDir = _ref.countDir, getExtension = _ref.getExtension;
	
	  module.exports = Query = (function() {
	    function Query(query, _arg) {
	      var optCharRegEx, pathSeparator, _ref1;
	      _ref1 = _arg != null ? _arg : {}, optCharRegEx = _ref1.optCharRegEx, pathSeparator = _ref1.pathSeparator;
	      if (!(query && query.length)) {
	        return null;
	      }
	      this.query = query;
	      this.query_lw = query.toLowerCase();
	      this.core = coreChars(query, optCharRegEx);
	      this.core_lw = this.core.toLowerCase();
	      this.core_up = truncatedUpperCase(this.core);
	      this.depth = countDir(query, query.length, pathSeparator);
	      this.ext = getExtension(this.query_lw);
	      this.charCodes = getCharCodes(this.query_lw);
	    }
	
	    return Query;
	
	  })();
	
	  opt_char_re = /[ _\-:\/\\]/g;
	
	  coreChars = function(query, optCharRegEx) {
	    if (optCharRegEx == null) {
	      optCharRegEx = opt_char_re;
	    }
	    return query.replace(optCharRegEx, '');
	  };
	
	  truncatedUpperCase = function(str) {
	    var char, upper, _i, _len;
	    upper = "";
	    for (_i = 0, _len = str.length; _i < _len; _i++) {
	      char = str[_i];
	      upper += char.toUpperCase()[0];
	    }
	    return upper;
	  };
	
	  getCharCodes = function(str) {
	    var charCodes, i, len;
	    len = str.length;
	    i = -1;
	    charCodes = [];
	    while (++i < len) {
	      charCodes[str.charCodeAt(i)] = true;
	    }
	    return charCodes;
	  };
	
	}).call(this);


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	  var basenameMatch, computeMatch, isMatch, isWordStart, match, mergeMatches, scoreAcronyms, scoreCharacter, scoreConsecutives, _ref;
	
	  _ref = __webpack_require__(188), isMatch = _ref.isMatch, isWordStart = _ref.isWordStart, scoreConsecutives = _ref.scoreConsecutives, scoreCharacter = _ref.scoreCharacter, scoreAcronyms = _ref.scoreAcronyms;
	
	  exports.match = match = function(string, query, options) {
	    var allowErrors, baseMatches, matches, pathSeparator, preparedQuery, string_lw;
	    allowErrors = options.allowErrors, preparedQuery = options.preparedQuery, pathSeparator = options.pathSeparator;
	    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {
	      return [];
	    }
	    string_lw = string.toLowerCase();
	    matches = computeMatch(string, string_lw, preparedQuery);
	    if (matches.length === 0) {
	      return matches;
	    }
	    if (string.indexOf(pathSeparator) > -1) {
	      baseMatches = basenameMatch(string, string_lw, preparedQuery, pathSeparator);
	      matches = mergeMatches(matches, baseMatches);
	    }
	    return matches;
	  };
	
	  exports.wrap = function(string, query, options) {
	    var matchIndex, matchPos, matchPositions, output, strPos, tagClass, tagClose, tagOpen, _ref1;
	    if ((options.wrap != null)) {
	      _ref1 = options.wrap, tagClass = _ref1.tagClass, tagOpen = _ref1.tagOpen, tagClose = _ref1.tagClose;
	    }
	    if (tagClass == null) {
	      tagClass = 'highlight';
	    }
	    if (tagOpen == null) {
	      tagOpen = '<strong class="' + tagClass + '">';
	    }
	    if (tagClose == null) {
	      tagClose = '</strong>';
	    }
	    if (string === query) {
	      return tagOpen + string + tagClose;
	    }
	    matchPositions = match(string, query, options);
	    if (matchPositions.length === 0) {
	      return string;
	    }
	    output = '';
	    matchIndex = -1;
	    strPos = 0;
	    while (++matchIndex < matchPositions.length) {
	      matchPos = matchPositions[matchIndex];
	      if (matchPos > strPos) {
	        output += string.substring(strPos, matchPos);
	        strPos = matchPos;
	      }
	      while (++matchIndex < matchPositions.length) {
	        if (matchPositions[matchIndex] === matchPos + 1) {
	          matchPos++;
	        } else {
	          matchIndex--;
	          break;
	        }
	      }
	      matchPos++;
	      if (matchPos > strPos) {
	        output += tagOpen;
	        output += string.substring(strPos, matchPos);
	        output += tagClose;
	        strPos = matchPos;
	      }
	    }
	    if (strPos < string.length - 1) {
	      output += string.substring(strPos);
	    }
	    return output;
	  };
	
	  basenameMatch = function(subject, subject_lw, preparedQuery, pathSeparator) {
	    var basePos, depth, end;
	    end = subject.length - 1;
	    while (subject[end] === pathSeparator) {
	      end--;
	    }
	    basePos = subject.lastIndexOf(pathSeparator, end);
	    if (basePos === -1) {
	      return [];
	    }
	    depth = preparedQuery.depth;
	    while (depth-- > 0) {
	      basePos = subject.lastIndexOf(pathSeparator, basePos - 1);
	      if (basePos === -1) {
	        return [];
	      }
	    }
	    basePos++;
	    end++;
	    return computeMatch(subject.slice(basePos, end), subject_lw.slice(basePos, end), preparedQuery, basePos);
	  };
	
	  mergeMatches = function(a, b) {
	    var ai, bj, i, j, m, n, out;
	    m = a.length;
	    n = b.length;
	    if (n === 0) {
	      return a.slice();
	    }
	    if (m === 0) {
	      return b.slice();
	    }
	    i = -1;
	    j = 0;
	    bj = b[j];
	    out = [];
	    while (++i < m) {
	      ai = a[i];
	      while (bj <= ai && ++j < n) {
	        if (bj < ai) {
	          out.push(bj);
	        }
	        bj = b[j];
	      }
	      out.push(ai);
	    }
	    while (j < n) {
	      out.push(b[j++]);
	    }
	    return out;
	  };
	
	  computeMatch = function(subject, subject_lw, preparedQuery, offset) {
	    var DIAGONAL, LEFT, STOP, UP, acro_score, align, backtrack, csc_diag, csc_row, csc_score, i, j, m, matches, move, n, pos, query, query_lw, score, score_diag, score_row, score_up, si_lw, start, trace;
	    if (offset == null) {
	      offset = 0;
	    }
	    query = preparedQuery.query;
	    query_lw = preparedQuery.query_lw;
	    m = subject.length;
	    n = query.length;
	    acro_score = scoreAcronyms(subject, subject_lw, query, query_lw).score;
	    score_row = new Array(n);
	    csc_row = new Array(n);
	    STOP = 0;
	    UP = 1;
	    LEFT = 2;
	    DIAGONAL = 3;
	    trace = new Array(m * n);
	    pos = -1;
	    j = -1;
	    while (++j < n) {
	      score_row[j] = 0;
	      csc_row[j] = 0;
	    }
	    i = -1;
	    while (++i < m) {
	      score = 0;
	      score_up = 0;
	      csc_diag = 0;
	      si_lw = subject_lw[i];
	      j = -1;
	      while (++j < n) {
	        csc_score = 0;
	        align = 0;
	        score_diag = score_up;
	        if (query_lw[j] === si_lw) {
	          start = isWordStart(i, subject, subject_lw);
	          csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);
	          align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);
	        }
	        score_up = score_row[j];
	        csc_diag = csc_row[j];
	        if (score > score_up) {
	          move = LEFT;
	        } else {
	          score = score_up;
	          move = UP;
	        }
	        if (align > score) {
	          score = align;
	          move = DIAGONAL;
	        } else {
	          csc_score = 0;
	        }
	        score_row[j] = score;
	        csc_row[j] = csc_score;
	        trace[++pos] = score > 0 ? move : STOP;
	      }
	    }
	    i = m - 1;
	    j = n - 1;
	    pos = i * n + j;
	    backtrack = true;
	    matches = [];
	    while (backtrack && i >= 0 && j >= 0) {
	      switch (trace[pos]) {
	        case UP:
	          i--;
	          pos -= n;
	          break;
	        case LEFT:
	          j--;
	          pos--;
	          break;
	        case DIAGONAL:
	          matches.push(i + offset);
	          j--;
	          i--;
	          pos -= n + 1;
	          break;
	        default:
	          backtrack = false;
	      }
	    }
	    matches.reverse();
	    return matches;
	  };
	
	}).call(this);


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	const classnames = __webpack_require__(161);
	
	__webpack_require__(193);
	const { DOM: dom } = React;
	const ImPropTypes = __webpack_require__(183);
	
	const githubUrl = "https://github.com/devtools-html/debugger.html/blob/master";
	
	function getTabsByClientType(tabs, clientType) {
	  return tabs.valueSeq().filter(tab => tab.get("clientType") == clientType);
	}
	
	function firstTimeMessage(title, urlPart) {
	  return dom.div({ className: "footer-note" }, `First time connecting to ${ title }? Checkout out the `, dom.a({
	    href: `${ githubUrl }/docs/getting-setup.md#starting-${ urlPart }`
	  }, "docs"), ".");
	}
	
	function getTabURL(tab, paramName) {
	  const tabID = tab.get("id");
	  return `/?${ paramName }=${ tabID }`;
	}
	
	const LandingPage = React.createClass({
	  propTypes: {
	    tabs: ImPropTypes.map.isRequired,
	    supportsFirefox: React.PropTypes.bool.isRequired,
	    supportsChrome: React.PropTypes.bool.isRequired,
	    title: React.PropTypes.string.isRequired,
	    filterString: React.PropTypes.string,
	    onFilterChange: React.PropTypes.func.isRequired,
	    onTabClick: React.PropTypes.func.isRequired
	  },
	
	  displayName: "LandingPage",
	
	  getInitialState() {
	    return {
	      selectedPane: "Firefox"
	    };
	  },
	
	  componentDidUpdate() {
	    this.refs.filterInput.focus();
	  },
	
	  onFilterChange(newFilterString) {
	    this.props.onFilterChange(newFilterString);
	  },
	
	  onSideBarItemClick(itemTitle) {
	    if (itemTitle !== this.state.selectedPane) {
	      this.setState({ selectedPane: itemTitle });
	      this.onFilterChange("");
	    }
	  },
	
	  onTabClick(tab, paramName) {
	    this.props.onTabClick(getTabURL(tab, paramName));
	  },
	
	  renderTabs(tabs, paramName) {
	    if (!tabs || tabs.count() == 0) {
	      return dom.div({}, "");
	    }
	
	    let tabClassNames = ["tab"];
	    if (tabs.size === 1) {
	      tabClassNames.push("active");
	    }
	
	    return dom.div({ className: "tab-group" }, dom.ul({ className: "tab-list" }, tabs.valueSeq().map(tab => dom.li({
	      className: classnames("tab", {
	        active: tabs.size === 1
	      }),
	      key: tab.get("id"),
	      tabIndex: 0,
	      role: "link",
	      onClick: () => this.onTabClick(tab, paramName),
	      onKeyDown: e => {
	        if (e.keyCode === 13) {
	          this.onTabClick(tab, paramName);
	        }
	      }
	    }, dom.div({ className: "tab-title" }, tab.get("title")), dom.div({ className: "tab-url" }, tab.get("url"))))));
	  },
	
	  renderPanel() {
	    const configMap = {
	      Firefox: {
	        name: "Firefox",
	        clientType: "firefox",
	        paramName: "firefox-tab",
	        docsUrlPart: "firefox"
	      },
	      Chrome: {
	        name: "Chrome",
	        clientType: "chrome",
	        paramName: "chrome-tab",
	        docsUrlPart: "chrome"
	      },
	      Node: {
	        name: "Node",
	        clientType: "node",
	        paramName: "node-tab",
	        docsUrlPart: "node"
	      }
	    };
	
	    let {
	      name,
	      clientType,
	      paramName,
	      docsUrlPart
	    } = configMap[this.state.selectedPane];
	
	    let {
	      tabs,
	      filterString = ""
	    } = this.props;
	
	    const targets = getTabsByClientType(tabs, clientType);
	
	    return dom.main({ className: "panel" }, dom.header({}, dom.input({
	      ref: "filterInput",
	      placeholder: "Filter tabs",
	      value: filterString,
	      autoFocus: true,
	      type: "search",
	      onChange: e => this.onFilterChange(e.target.value),
	      onKeyDown: e => {
	        if (targets.size === 1 && e.keyCode === 13) {
	          this.onTabClick(targets.first(), paramName);
	        }
	      }
	    })), this.renderTabs(targets, paramName), firstTimeMessage(name, docsUrlPart));
	  },
	
	  renderSidebar() {
	    let connections = [];
	
	    if (this.props.supportsFirefox) {
	      connections.push("Firefox");
	    }
	
	    if (this.props.supportsChrome) {
	      connections.push("Chrome", "Node");
	    }
	
	    return dom.aside({
	      className: "sidebar"
	    }, dom.h1({}, this.props.title), dom.ul({}, connections.map(title => dom.li({
	      className: classnames({
	        selected: title == this.state.selectedPane
	      }),
	      key: title,
	      tabIndex: 0,
	      role: "button",
	      onClick: () => this.onSideBarItemClick(title),
	      onKeyDown: e => {
	        if (e.keyCode === 13) {
	          this.onSideBarItemClick(title);
	        }
	      }
	    }, dom.a({}, title)))));
	  },
	
	  render() {
	    return dom.div({
	      className: "landing-page"
	    }, this.renderSidebar(), this.renderPanel());
	  }
	});
	
	module.exports = LandingPage;

/***/ },
/* 193 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 194 */,
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	
	const tabs = __webpack_require__(196);
	
	module.exports = Object.assign({}, tabs);

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	/* global window */
	
	/**
	 * Redux actions for the pause state
	 * @module actions/tabs
	 */
	
	const constants = __webpack_require__(179);
	
	/**
	 * @typedef {Object} TabAction
	 * @memberof actions/tabs
	 * @static
	 * @property {number} type The type of Action
	 * @property {number} value The payload of the Action
	 */
	
	/**
	 * @memberof actions/tabs
	 * @static
	 * @param {Array} tabs
	 * @returns {TabAction} with type constants.ADD_TABS and tabs as value
	 */
	function newTabs(tabs) {
	  return {
	    type: constants.ADD_TABS,
	    value: tabs
	  };
	}
	
	/**
	 * @memberof actions/tabs
	 * @static
	 * @param {String} $0.id Unique ID of the tab to select
	 * @returns {TabAction}
	 */
	function selectTab({ id }) {
	  return {
	    type: constants.SELECT_TAB,
	    id: id
	  };
	}
	
	/**
	 * @memberof actions/tabs
	 * @static
	 * @param {String} value String which should be used to filter tabs
	 * @returns {TabAction} with type constants.FILTER_TABS
	 *          and filter string as value
	 */
	function filterTabs(value) {
	  return {
	    type: constants.FILTER_TABS,
	    value
	  };
	}
	
	module.exports = {
	  newTabs,
	  selectTab,
	  filterTabs
	};

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	const feature = __webpack_require__(198);
	
	module.exports = feature;


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	const pick = __webpack_require__(199);
	let config;
	
	const flag = __webpack_require__(119);
	
	/**
	 * Gets a config value for a given key
	 * e.g "chrome.webSocketPort"
	 */
	function getValue(key) {
	  return pick(config, key);
	}
	
	function isEnabled(key) {
	  return config.features && config.features[key];
	}
	
	function isDevelopment() {
	  if (isFirefoxPanel()) {
	    // Default to production if compiling for the Firefox panel
	    return ("production") === "development";
	  }
	  return ("production") !== "production";
	}
	
	function isTesting() {
	  return flag.testing;
	}
	
	function isFirefoxPanel() {
	  return ("firefox-panel") == "firefox-panel";
	}
	
	function isApplication() {
	  return ("firefox-panel") == "application";
	}
	
	function isFirefox() {
	  return /firefox/i.test(navigator.userAgent);
	}
	
	function setConfig(value) {
	  config = value;
	}
	
	function getConfig() {
	  return config;
	}
	
	module.exports = {
	  isEnabled,
	  getValue,
	  isDevelopment,
	  isTesting,
	  isFirefoxPanel,
	  isApplication,
	  isFirefox,
	  getConfig,
	  setConfig
	};


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(200);
	
	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}
	
	module.exports = get;


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(201),
	    toKey = __webpack_require__(243);
	
	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = castPath(path, object);
	
	  var index = 0,
	      length = path.length;
	
	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}
	
	module.exports = baseGet;


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(202),
	    isKey = __webpack_require__(203),
	    stringToPath = __webpack_require__(205),
	    toString = __webpack_require__(240);
	
	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value, object) {
	  if (isArray(value)) {
	    return value;
	  }
	  return isKey(value, object) ? [value] : stringToPath(toString(value));
	}
	
	module.exports = castPath;


/***/ },
/* 202 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;
	
	module.exports = isArray;


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(202),
	    isSymbol = __webpack_require__(204);
	
	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;
	
	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}
	
	module.exports = isKey;


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(6),
	    isObjectLike = __webpack_require__(14);
	
	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';
	
	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag);
	}
	
	module.exports = isSymbol;


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	var memoizeCapped = __webpack_require__(206);
	
	/** Used to match property names within property paths. */
	var reLeadingDot = /^\./,
	    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
	
	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;
	
	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoizeCapped(function(string) {
	  var result = [];
	  if (reLeadingDot.test(string)) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});
	
	module.exports = stringToPath;


/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	var memoize = __webpack_require__(207);
	
	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;
	
	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped(func) {
	  var result = memoize(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });
	
	  var cache = result.cache;
	  return result;
	}
	
	module.exports = memoizeCapped;


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	var MapCache = __webpack_require__(208);
	
	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';
	
	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;
	
	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}
	
	// Expose `MapCache`.
	memoize.Cache = MapCache;
	
	module.exports = memoize;


/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	var mapCacheClear = __webpack_require__(209),
	    mapCacheDelete = __webpack_require__(234),
	    mapCacheGet = __webpack_require__(237),
	    mapCacheHas = __webpack_require__(238),
	    mapCacheSet = __webpack_require__(239);
	
	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;
	
	module.exports = MapCache;


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	var Hash = __webpack_require__(210),
	    ListCache = __webpack_require__(225),
	    Map = __webpack_require__(233);
	
	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}
	
	module.exports = mapCacheClear;


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var hashClear = __webpack_require__(211),
	    hashDelete = __webpack_require__(221),
	    hashGet = __webpack_require__(222),
	    hashHas = __webpack_require__(223),
	    hashSet = __webpack_require__(224);
	
	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;
	
	module.exports = Hash;


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(212);
	
	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}
	
	module.exports = hashClear;


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(213);
	
	/* Built-in method references that are verified to be native. */
	var nativeCreate = getNative(Object, 'create');
	
	module.exports = nativeCreate;


/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsNative = __webpack_require__(214),
	    getValue = __webpack_require__(220);
	
	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}
	
	module.exports = getNative;


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(215),
	    isMasked = __webpack_require__(217),
	    isObject = __webpack_require__(216),
	    toSource = __webpack_require__(219);
	
	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
	
	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);
	
	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}
	
	module.exports = baseIsNative;


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(6),
	    isObject = __webpack_require__(216);
	
	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';
	
	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}
	
	module.exports = isFunction;


/***/ },
/* 216 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}
	
	module.exports = isObject;


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	var coreJsData = __webpack_require__(218);
	
	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());
	
	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}
	
	module.exports = isMasked;


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(8);
	
	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];
	
	module.exports = coreJsData;


/***/ },
/* 219 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var funcProto = Function.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}
	
	module.exports = toSource;


/***/ },
/* 220 */
/***/ function(module, exports) {

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}
	
	module.exports = getValue;


/***/ },
/* 221 */
/***/ function(module, exports) {

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}
	
	module.exports = hashDelete;


/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(212);
	
	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}
	
	module.exports = hashGet;


/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(212);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
	}
	
	module.exports = hashHas;


/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(212);
	
	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';
	
	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}
	
	module.exports = hashSet;


/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	var listCacheClear = __webpack_require__(226),
	    listCacheDelete = __webpack_require__(227),
	    listCacheGet = __webpack_require__(230),
	    listCacheHas = __webpack_require__(231),
	    listCacheSet = __webpack_require__(232);
	
	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;
	
	module.exports = ListCache;


/***/ },
/* 226 */
/***/ function(module, exports) {

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}
	
	module.exports = listCacheClear;


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(228);
	
	/** Used for built-in method references. */
	var arrayProto = Array.prototype;
	
	/** Built-in value references. */
	var splice = arrayProto.splice;
	
	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}
	
	module.exports = listCacheDelete;


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(229);
	
	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}
	
	module.exports = assocIndexOf;


/***/ },
/* 229 */
/***/ function(module, exports) {

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}
	
	module.exports = eq;


/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(228);
	
	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  return index < 0 ? undefined : data[index][1];
	}
	
	module.exports = listCacheGet;


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(228);
	
	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}
	
	module.exports = listCacheHas;


/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(228);
	
	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}
	
	module.exports = listCacheSet;


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(213),
	    root = __webpack_require__(8);
	
	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map');
	
	module.exports = Map;


/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(235);
	
	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}
	
	module.exports = mapCacheDelete;


/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	var isKeyable = __webpack_require__(236);
	
	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}
	
	module.exports = getMapData;


/***/ },
/* 236 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}
	
	module.exports = isKeyable;


/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(235);
	
	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}
	
	module.exports = mapCacheGet;


/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(235);
	
	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}
	
	module.exports = mapCacheHas;


/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(235);
	
	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;
	
	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}
	
	module.exports = mapCacheSet;


/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	var baseToString = __webpack_require__(241);
	
	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}
	
	module.exports = toString;


/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(7),
	    arrayMap = __webpack_require__(242),
	    isArray = __webpack_require__(202),
	    isSymbol = __webpack_require__(204);
	
	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;
	
	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;
	
	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}
	
	module.exports = baseToString;


/***/ },
/* 242 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);
	
	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}
	
	module.exports = arrayMap;


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	var isSymbol = __webpack_require__(204);
	
	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;
	
	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}
	
	module.exports = toKey;


/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	
	
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	/* global window */
	
	/**
	 * Redux store utils
	 * @module utils/create-store
	 */
	
	var _require = __webpack_require__(3),
	    createStore = _require.createStore,
	    applyMiddleware = _require.applyMiddleware;
	
	var _require2 = __webpack_require__(245),
	    waitUntilService = _require2.waitUntilService;
	
	var _require3 = __webpack_require__(246),
	    log = _require3.log;
	
	var _require4 = __webpack_require__(247),
	    history = _require4.history;
	
	var _require5 = __webpack_require__(248),
	    promise = _require5.promise;
	
	var _require6 = __webpack_require__(253),
	    thunk = _require6.thunk;
	
	/**
	 * @memberof utils/create-store
	 * @static
	 */
	
	
	/**
	 * This creates a dispatcher with all the standard middleware in place
	 * that all code requires. It can also be optionally configured in
	 * various ways, such as logging and recording.
	 *
	 * @param {object} opts:
	 *        - log: log all dispatched actions to console
	 *        - history: an array to store every action in. Should only be
	 *                   used in tests.
	 *        - middleware: array of middleware to be included in the redux store
	 * @memberof utils/create-store
	 * @static
	 */
	var configureStore = function () {
	  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	  var middleware = [thunk(opts.makeThunkArgs), promise,
	
	  // Order is important: services must go last as they always
	  // operate on "already transformed" actions. Actions going through
	  // them shouldn't have any special fields like promises, they
	  // should just be normal JSON objects.
	  waitUntilService];
	
	  if (opts.history) {
	    middleware.push(history(opts.history));
	  }
	
	  if (opts.middleware) {
	    opts.middleware.forEach(fn => middleware.push(fn));
	  }
	
	  if (opts.log) {
	    middleware.push(log);
	  }
	
	  // Hook in the redux devtools browser extension if it exists
	  var devtoolsExt = typeof window === "object" && window.devToolsExtension ? window.devToolsExtension() : f => f;
	
	  return applyMiddleware.apply(undefined, middleware)(devtoolsExt(createStore));
	};
	
	module.exports = configureStore;

/***/ },
/* 245 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	/**
	 * A middleware which acts like a service, because it is stateful
	 * and "long-running" in the background. It provides the ability
	 * for actions to install a function to be run once when a specific
	 * condition is met by an action coming through the system. Think of
	 * it as a thunk that blocks until the condition is met. Example:
	 *
	 * ```js
	 * const services = { WAIT_UNTIL: require('wait-service').NAME };
	 *
	 * { type: services.WAIT_UNTIL,
	 *   predicate: action => action.type === constants.ADD_ITEM,
	 *   run: (dispatch, getState, action) => {
	 *     // Do anything here. You only need to accept the arguments
	 *     // if you need them. `action` is the action that satisfied
	 *     // the predicate.
	 *   }
	 * }
	 * ```
	 */
	var NAME = exports.NAME = "@@service/waitUntil";
	
	function waitUntilService(_ref) {
	  var dispatch = _ref.dispatch,
	      getState = _ref.getState;
	
	  var pending = [];
	
	  function checkPending(action) {
	    var readyRequests = [];
	    var stillPending = [];
	
	    // Find the pending requests whose predicates are satisfied with
	    // this action. Wait to run the requests until after we update the
	    // pending queue because the request handler may synchronously
	    // dispatch again and run this service (that use case is
	    // completely valid).
	    for (var request of pending) {
	      if (request.predicate(action)) {
	        readyRequests.push(request);
	      } else {
	        stillPending.push(request);
	      }
	    }
	
	    pending = stillPending;
	    for (var _request of readyRequests) {
	      _request.run(dispatch, getState, action);
	    }
	  }
	
	  return next => action => {
	    if (action.type === NAME) {
	      pending.push(action);
	      return null;
	    }
	    var result = next(action);
	    checkPending(action);
	    return result;
	  };
	}
	exports.waitUntilService = waitUntilService;

/***/ },
/* 246 */
/***/ function(module, exports) {

	/**
	 * A middleware that logs all actions coming through the system
	 * to the console.
	 */
	function log(_ref) {
	  var dispatch = _ref.dispatch,
	      getState = _ref.getState;
	
	  return next => action => {
	    var actionText = JSON.stringify(action, null, 2);
	    var truncatedActionText = `${ actionText.slice(0, 1000) }...`;
	    console.log(`[DISPATCH ${ action.type }]`, action, truncatedActionText);
	    next(action);
	  };
	}
	
	exports.log = log;

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	var _require = __webpack_require__(197),
	    isDevelopment = _require.isDevelopment;
	
	/**
	 * A middleware that stores every action coming through the store in the passed
	 * in logging object. Should only be used for tests, as it collects all
	 * action information, which will cause memory bloat.
	 */
	
	
	exports.history = function () {
	  var log = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	  return (_ref) => {
	    var dispatch = _ref.dispatch,
	        getState = _ref.getState;
	
	    if (isDevelopment()) {
	      console.warn("Using history middleware stores all actions in state for " + "testing and devtools is not currently running in test " + "mode. Be sure this is intentional.");
	    }
	    return next => action => {
	      log.push(action);
	      next(action);
	    };
	  };
	};

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	var defer = __webpack_require__(249);
	
	var _require = __webpack_require__(250),
	    entries = _require.entries,
	    toObject = _require.toObject;
	
	var _require2 = __webpack_require__(251),
	    executeSoon = _require2.executeSoon;
	
	var PROMISE = exports.PROMISE = "@@dispatch/promise";
	var seqIdVal = 1;
	
	function seqIdGen() {
	  return seqIdVal++;
	}
	
	function promiseMiddleware(_ref) {
	  var dispatch = _ref.dispatch,
	      getState = _ref.getState;
	
	  return next => action => {
	    if (!(PROMISE in action)) {
	      return next(action);
	    }
	
	    var promiseInst = action[PROMISE];
	    var seqId = seqIdGen().toString();
	
	    // Create a new action that doesn't have the promise field and has
	    // the `seqId` field that represents the sequence id
	    action = Object.assign(toObject(entries(action).filter(pair => pair[0] !== PROMISE)), { seqId });
	
	    dispatch(Object.assign({}, action, { status: "start" }));
	
	    // Return the promise so action creators can still compose if they
	    // want to.
	    var deferred = defer();
	    promiseInst.then(value => {
	      executeSoon(() => {
	        dispatch(Object.assign({}, action, {
	          status: "done",
	          value: value
	        }));
	        deferred.resolve(value);
	      });
	    }, error => {
	      executeSoon(() => {
	        dispatch(Object.assign({}, action, {
	          status: "error",
	          error: error.message || error
	        }));
	        deferred.reject(error);
	      });
	    });
	    return deferred.promise;
	  };
	}
	
	exports.promise = promiseMiddleware;

/***/ },
/* 249 */
/***/ function(module, exports) {

	
	
	function defer() {
	  var resolve = void 0; // eslint-disable-line no-unused-vars
	  var reject = void 0; // eslint-disable-line no-unused-vars
	  var promise = new Promise(function (innerResolve, innerReject) {
	    resolve = innerResolve;
	    reject = innerReject;
	  });
	  return {
	    resolve,
	    reject,
	    promise
	  };
	}
	
	module.exports = defer;

/***/ },
/* 250 */
/***/ function(module, exports) {

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	/**
	 * Utils for utils, by utils
	 * @module utils/utils
	 */
	
	/**
	 * @memberof utils/utils
	 * @static
	 */
	function handleError(err) {
	  console.log("ERROR: ", err);
	}
	
	/**
	 * @memberof utils/utils
	 * @static
	 */
	function promisify(context, method) {
	  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    args[_key - 2] = arguments[_key];
	  }
	
	  return new Promise((resolve, reject) => {
	    args.push(response => {
	      if (response.error) {
	        reject(response);
	      } else {
	        resolve(response);
	      }
	    });
	    method.apply(context, args);
	  });
	}
	
	/**
	 * @memberof utils/utils
	 * @static
	 */
	function truncateStr(str, size) {
	  if (str.length > size) {
	    return `${ str.slice(0, size) }...`;
	  }
	  return str;
	}
	
	/**
	 * @memberof utils/utils
	 * @static
	 */
	function endTruncateStr(str, size) {
	  if (str.length > size) {
	    return `...${ str.slice(str.length - size) }`;
	  }
	  return str;
	}
	
	var msgId = 1;
	/**
	 * @memberof utils/utils
	 * @static
	 */
	function workerTask(worker, method) {
	  return function () {
	    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	      args[_key2] = arguments[_key2];
	    }
	
	    return new Promise((resolve, reject) => {
	      var id = msgId++;
	      worker.postMessage({ id, method, args });
	
	      var listener = (_ref) => {
	        var result = _ref.data;
	
	        if (result.id !== id) {
	          return;
	        }
	
	        worker.removeEventListener("message", listener);
	        if (result.error) {
	          reject(result.error);
	        } else {
	          resolve(result.response);
	        }
	      };
	
	      worker.addEventListener("message", listener);
	    });
	  };
	}
	
	/**
	 * Interleaves two arrays element by element, returning the combined array, like
	 * a zip. In the case of arrays with different sizes, undefined values will be
	 * interleaved at the end along with the extra values of the larger array.
	 *
	 * @param Array a
	 * @param Array b
	 * @returns Array
	 *          The combined array, in the form [a1, b1, a2, b2, ...]
	 * @memberof utils/utils
	 * @static
	 */
	function zip(a, b) {
	  if (!b) {
	    return a;
	  }
	  if (!a) {
	    return b;
	  }
	  var pairs = [];
	  for (var i = 0, aLength = a.length, bLength = b.length; i < aLength || i < bLength; i++) {
	    pairs.push([a[i], b[i]]);
	  }
	  return pairs;
	}
	
	/**
	 * Converts an object into an array with 2-element arrays as key/value
	 * pairs of the object. `{ foo: 1, bar: 2}` would become
	 * `[[foo, 1], [bar 2]]` (order not guaranteed);
	 *
	 * @returns array
	 * @memberof utils/utils
	 * @static
	 */
	function entries(obj) {
	  return Object.keys(obj).map(k => [k, obj[k]]);
	}
	
	/**
	 * @memberof utils/utils
	 * @static
	 */
	function mapObject(obj, iteratee) {
	  return toObject(entries(obj).map((_ref2) => {
	    var _ref3 = _slicedToArray(_ref2, 2),
	        key = _ref3[0],
	        value = _ref3[1];
	
	    return [key, iteratee(key, value)];
	  }));
	}
	
	/**
	 * Takes an array of 2-element arrays as key/values pairs and
	 * constructs an object using them.
	 * @memberof utils/utils
	 * @static
	 */
	function toObject(arr) {
	  var obj = {};
	  for (var pair of arr) {
	    obj[pair[0]] = pair[1];
	  }
	  return obj;
	}
	
	/**
	 * Composes the given functions into a single function, which will
	 * apply the results of each function right-to-left, starting with
	 * applying the given arguments to the right-most function.
	 * `compose(foo, bar, baz)` === `args => foo(bar(baz(args)`
	 *
	 * @param ...function funcs
	 * @returns function
	 * @memberof utils/utils
	 * @static
	 */
	function compose() {
	  for (var _len3 = arguments.length, funcs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	    funcs[_key3] = arguments[_key3];
	  }
	
	  return function () {
	    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	      args[_key4] = arguments[_key4];
	    }
	
	    var initialValue = funcs[funcs.length - 1].apply(null, args);
	    var leftFuncs = funcs.slice(0, -1);
	    return leftFuncs.reduceRight((composed, f) => f(composed), initialValue);
	  };
	}
	
	/**
	 * @memberof utils/utils
	 * @static
	 */
	function updateObj(obj, fields) {
	  return Object.assign({}, obj, fields);
	}
	
	/**
	 * @memberof utils/utils
	 * @static
	 */
	function throttle(func, ms) {
	  var timeout = void 0,
	      _this = void 0;
	  return function () {
	    for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
	      args[_key5] = arguments[_key5];
	    }
	
	    _this = this;
	    if (!timeout) {
	      timeout = setTimeout(() => {
	        func.apply.apply(func, [_this].concat(_toConsumableArray(args)));
	        timeout = null;
	      }, ms);
	    }
	  };
	}
	
	module.exports = {
	  handleError,
	  promisify,
	  truncateStr,
	  endTruncateStr,
	  workerTask,
	  zip,
	  entries,
	  toObject,
	  mapObject,
	  compose,
	  updateObj,
	  throttle
	};

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(252);
	
	function reportException(who, exception) {
	  var msg = `${ who } threw an exception: `;
	  console.error(msg, exception);
	}
	
	function executeSoon(fn) {
	  setTimeout(fn, 0);
	}
	
	module.exports = {
	  reportException,
	  executeSoon,
	  assert
	};

/***/ },
/* 252 */
/***/ function(module, exports) {

	function assert(condition, message) {
	  if (!condition) {
	    throw new Error(`Assertion failure: ${ message }`);
	  }
	}
	
	module.exports = assert;

/***/ },
/* 253 */
/***/ function(module, exports) {

	
	/**
	 * A middleware that allows thunks (functions) to be dispatched. If
	 * it's a thunk, it is called with an argument that contains
	 * `dispatch`, `getState`, and any additional args passed in via the
	 * middleware constructure. This allows the action to create multiple
	 * actions (most likely asynchronously).
	 */
	function thunk(makeArgs) {
	  return (_ref) => {
	    var dispatch = _ref.dispatch,
	        getState = _ref.getState;
	
	    var args = { dispatch, getState };
	
	    return next => action => {
	      return typeof action === "function" ? action(makeArgs ? makeArgs(args, getState()) : args) : next(action);
	    };
	  };
	}
	exports.thunk = thunk;

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	var _require = __webpack_require__(23),
	    createSource = _require.createSource,
	    firefox = _require.firefox;
	
	var _require2 = __webpack_require__(255),
	    prefs = _require2.prefs;
	
	function onFirefoxConnect(actions) {
	  var tabTarget = firefox.getTabTarget();
	  var threadClient = firefox.getThreadClient();
	
	  if (!tabTarget) {
	    return;
	  }
	
	  tabTarget.on("will-navigate", actions.willNavigate);
	  tabTarget.on("navigate", actions.navigated);
	
	  // In Firefox, we need to initially request all of the sources. This
	  // usually fires off individual `newSource` notifications as the
	  // debugger finds them, but there may be existing sources already in
	  // the debugger (if it's paused already, or if loading the page from
	  // bfcache) so explicity fire `newSource` events for all returned
	  // sources.
	  return threadClient.getSources().then((_ref) => {
	    var sources = _ref.sources;
	
	    actions.newSources(sources.map(createSource));
	
	    // If the threadClient is already paused, make sure to show a
	    // paused state.
	    var pausedPacket = threadClient.getLastPausePacket();
	    if (pausedPacket) {
	      firefox.clientEvents.paused(null, pausedPacket);
	    }
	  });
	}
	
	function onConnect(connection, actions) {
	  // NOTE: the landing page does not connect to a JS process
	  if (!connection) {
	    return;
	  }
	
	  var pauseOnExceptions = prefs.pauseOnExceptions,
	      ignoreCaughtExceptions = prefs.ignoreCaughtExceptions;
	
	  if (pauseOnExceptions || ignoreCaughtExceptions) {
	    actions.pauseOnExceptions(pauseOnExceptions, ignoreCaughtExceptions);
	  }
	
	  var tab = connection.tab;
	
	  if (tab.clientType == "firefox") {
	    return onFirefoxConnect(actions);
	  }
	}
	
	module.exports = {
	  onFirefoxConnect,
	  onConnect
	};

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	var { PrefsHelper } = __webpack_require__(256);
	const { Services: { pref }} = __webpack_require__(28);
	const { isDevelopment } = __webpack_require__(197);
	
	if (isDevelopment()) {
	  pref("devtools.debugger.client-source-maps-enabled", true);
	  pref("devtools.debugger.pause-on-exceptions", false);
	  pref("devtools.debugger.ignore-caught-exceptions", false);
	  pref("devtools.debugger.call-stack-visible", false);
	  pref("devtools.debugger.scopes-visible", false);
	  pref("devtools.debugger.start-panel-collapsed", false);
	  pref("devtools.debugger.end-panel-collapsed", false);
	  pref("devtools.debugger.tabs", "[]");
	  pref("devtools.debugger.pending-selected-location", "{}");
	}
	
	const prefs = new PrefsHelper("devtools", {
	  clientSourceMapsEnabled: ["Bool", "debugger.client-source-maps-enabled"],
	  pauseOnExceptions: ["Bool", "debugger.pause-on-exceptions"],
	  ignoreCaughtExceptions: ["Bool", "debugger.ignore-caught-exceptions"],
	  callStackVisible: ["Bool", "debugger.call-stack-visible"],
	  scopesVisible: ["Bool", "debugger.scopes-visible"],
	  startPanelCollapsed: ["Bool", "debugger.start-panel-collapsed"],
	  endPanelCollapsed: ["Bool", "debugger.end-panel-collapsed"],
	  tabs: ["Json", "debugger.tabs"],
	  pendingSelectedLocation: ["Json", "debugger.pending-selected-location"]
	});
	
	module.exports = { prefs };


/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	const { KeyShortcuts } = __webpack_require__(257);
	const { DebuggerTransport } = __webpack_require__(265);
	const { DebuggerClient } = __webpack_require__(276);
	const PrefsHelper = __webpack_require__(280).PrefsHelper;
	const { TargetFactory } = __webpack_require__(281);
	const DevToolsUtils = __webpack_require__(266);
	const AppConstants = __webpack_require__(268);
	const EventEmitter = __webpack_require__(258);
	const WebsocketTransport = __webpack_require__(282);
	const Menu = __webpack_require__(283);
	const MenuItem = __webpack_require__(284);
	const Tree = __webpack_require__(285);
	const sourceUtils = __webpack_require__(286);
	const frame = __webpack_require__(287);
	
	module.exports = {
	  KeyShortcuts,
	  PrefsHelper,
	  DebuggerClient,
	  DebuggerTransport,
	  TargetFactory,
	  DevToolsUtils,
	  AppConstants,
	  EventEmitter,
	  WebsocketTransport,
	  Menu,
	  MenuItem,
	  Tree,
	  sourceUtils,
	  frame
	};


/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	const { Services: { appinfo }} = __webpack_require__(28);
	const EventEmitter = __webpack_require__(258);
	const isOSX = appinfo.OS === "Darwin";
	"use strict";
	
	// List of electron keys mapped to DOM API (DOM_VK_*) key code
	const ElectronKeysMapping = {
	  "F1": "DOM_VK_F1",
	  "F2": "DOM_VK_F2",
	  "F3": "DOM_VK_F3",
	  "F4": "DOM_VK_F4",
	  "F5": "DOM_VK_F5",
	  "F6": "DOM_VK_F6",
	  "F7": "DOM_VK_F7",
	  "F8": "DOM_VK_F8",
	  "F9": "DOM_VK_F9",
	  "F10": "DOM_VK_F10",
	  "F11": "DOM_VK_F11",
	  "F12": "DOM_VK_F12",
	  "F13": "DOM_VK_F13",
	  "F14": "DOM_VK_F14",
	  "F15": "DOM_VK_F15",
	  "F16": "DOM_VK_F16",
	  "F17": "DOM_VK_F17",
	  "F18": "DOM_VK_F18",
	  "F19": "DOM_VK_F19",
	  "F20": "DOM_VK_F20",
	  "F21": "DOM_VK_F21",
	  "F22": "DOM_VK_F22",
	  "F23": "DOM_VK_F23",
	  "F24": "DOM_VK_F24",
	  "Space": "DOM_VK_SPACE",
	  "Backspace": "DOM_VK_BACK_SPACE",
	  "Delete": "DOM_VK_DELETE",
	  "Insert": "DOM_VK_INSERT",
	  "Return": "DOM_VK_RETURN",
	  "Enter": "DOM_VK_RETURN",
	  "Up": "DOM_VK_UP",
	  "Down": "DOM_VK_DOWN",
	  "Left": "DOM_VK_LEFT",
	  "Right": "DOM_VK_RIGHT",
	  "Home": "DOM_VK_HOME",
	  "End": "DOM_VK_END",
	  "PageUp": "DOM_VK_PAGE_UP",
	  "PageDown": "DOM_VK_PAGE_DOWN",
	  "Escape": "DOM_VK_ESCAPE",
	  "Esc": "DOM_VK_ESCAPE",
	  "Tab": "DOM_VK_TAB",
	  "VolumeUp": "DOM_VK_VOLUME_UP",
	  "VolumeDown": "DOM_VK_VOLUME_DOWN",
	  "VolumeMute": "DOM_VK_VOLUME_MUTE",
	  "PrintScreen": "DOM_VK_PRINTSCREEN",
	};
	
	/**
	 * Helper to listen for keyboard events decribed in .properties file.
	 *
	 * let shortcuts = new KeyShortcuts({
	 *   window
	 * });
	 * shortcuts.on("Ctrl+F", event => {
	 *   // `event` is the KeyboardEvent which relates to the key shortcuts
	 * });
	 *
	 * @param DOMWindow window
	 *        The window object of the document to listen events from.
	 * @param DOMElement target
	 *        Optional DOM Element on which we should listen events from.
	 *        If omitted, we listen for all events fired on `window`.
	 */
	function KeyShortcuts({ window, target }) {
	  this.window = window;
	  this.target = target || window;
	  this.keys = new Map();
	  this.eventEmitter = new EventEmitter();
	  this.target.addEventListener("keydown", this);
	}
	
	/*
	 * Parse an electron-like key string and return a normalized object which
	 * allow efficient match on DOM key event. The normalized object matches DOM
	 * API.
	 *
	 * @param DOMWindow window
	 *        Any DOM Window object, just to fetch its `KeyboardEvent` object
	 * @param String str
	 *        The shortcut string to parse, following this document:
	 *        https://github.com/electron/electron/blob/master/docs/api/accelerator.md
	 */
	KeyShortcuts.parseElectronKey = function(window, str) {
	  let modifiers = str.split("+");
	  let key = modifiers.pop();
	
	  let shortcut = {
	    ctrl: false,
	    meta: false,
	    alt: false,
	    shift: false,
	    // Set for character keys
	    key: undefined,
	    // Set for non-character keys
	    keyCode: undefined,
	  };
	  for (let mod of modifiers) {
	    if (mod === "Alt") {
	      shortcut.alt = true;
	    } else if (["Command", "Cmd"].includes(mod)) {
	      shortcut.meta = true;
	    } else if (["CommandOrControl", "CmdOrCtrl"].includes(mod)) {
	      if (isOSX) {
	        shortcut.meta = true;
	      } else {
	        shortcut.ctrl = true;
	      }
	    } else if (["Control", "Ctrl"].includes(mod)) {
	      shortcut.ctrl = true;
	    } else if (mod === "Shift") {
	      shortcut.shift = true;
	    } else {
	      console.error("Unsupported modifier:", mod, "from key:", str);
	      return null;
	    }
	  }
	
	  // Plus is a special case. It's a character key and shouldn't be matched
	  // against a keycode as it is only accessible via Shift/Capslock
	  if (key === "Plus") {
	    key = "+";
	  }
	
	  if (typeof key === "string" && key.length === 1) {
	    // Match any single character
	    shortcut.key = key.toLowerCase();
	  } else if (key in ElectronKeysMapping) {
	    // Maps the others manually to DOM API DOM_VK_*
	    key = ElectronKeysMapping[key];
	    shortcut.keyCode = window.KeyboardEvent[key];
	    // Used only to stringify the shortcut
	    shortcut.keyCodeString = key;
	    shortcut.key = key;
	  } else {
	    console.error("Unsupported key:", key);
	    return null;
	  }
	
	  return shortcut;
	};
	
	KeyShortcuts.stringify = function(shortcut) {
	  let list = [];
	  if (shortcut.alt) {
	    list.push("Alt");
	  }
	  if (shortcut.ctrl) {
	    list.push("Ctrl");
	  }
	  if (shortcut.meta) {
	    list.push("Cmd");
	  }
	  if (shortcut.shift) {
	    list.push("Shift");
	  }
	  let key;
	  if (shortcut.key) {
	    key = shortcut.key.toUpperCase();
	  } else {
	    key = shortcut.keyCodeString;
	  }
	  list.push(key);
	  return list.join("+");
	};
	
	KeyShortcuts.prototype = {
	  destroy() {
	    this.target.removeEventListener("keydown", this);
	    this.keys.clear();
	  },
	
	  doesEventMatchShortcut(event, shortcut) {
	    if (shortcut.meta != event.metaKey) {
	      return false;
	    }
	    if (shortcut.ctrl != event.ctrlKey) {
	      return false;
	    }
	    if (shortcut.alt != event.altKey) {
	      return false;
	    }
	    // Shift is a special modifier, it may implicitely be required if the
	    // expected key is a special character accessible via shift.
	    if (shortcut.shift != event.shiftKey && event.key &&
	        event.key.match(/[a-zA-Z]/)) {
	      return false;
	    }
	    if (shortcut.keyCode) {
	      return event.keyCode == shortcut.keyCode;
	    } else if (event.key in ElectronKeysMapping) {
	      return ElectronKeysMapping[event.key] === shortcut.key;
	    }
	
	    // get the key from the keyCode if key is not provided.
	    let key = event.key || String.fromCharCode(event.keyCode);
	
	    // For character keys, we match if the final character is the expected one.
	    // But for digits we also accept indirect match to please azerty keyboard,
	    // which requires Shift to be pressed to get digits.
	    return key.toLowerCase() == shortcut.key ||
	      (shortcut.key.match(/^[0-9]$/) &&
	       event.keyCode == shortcut.key.charCodeAt(0));
	  },
	
	  handleEvent(event) {
	    for (let [key, shortcut] of this.keys) {
	      if (this.doesEventMatchShortcut(event, shortcut)) {
	        this.eventEmitter.emit(key, event);
	      }
	    }
	  },
	
	  on(key, listener) {
	    if (typeof listener !== "function") {
	      throw new Error("KeyShortcuts.on() expects a function as " +
	                      "second argument");
	    }
	    if (!this.keys.has(key)) {
	      let shortcut = KeyShortcuts.parseElectronKey(this.window, key);
	      // The key string is wrong and we were unable to compute the key shortcut
	      if (!shortcut) {
	        return;
	      }
	      this.keys.set(key, shortcut);
	    }
	    this.eventEmitter.on(key, listener);
	  },
	
	  off(key, listener) {
	    this.eventEmitter.off(key, listener);
	  },
	};
	exports.KeyShortcuts = KeyShortcuts;


/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	/**
	 * EventEmitter.
	 */
	
	var EventEmitter = function EventEmitter() {};
	module.exports = EventEmitter;
	
	const { Cu } = __webpack_require__(259);
	const promise = __webpack_require__(264);
	
	/**
	 * Decorate an object with event emitter functionality.
	 *
	 * @param Object aObjectToDecorate
	 *        Bind all public methods of EventEmitter to
	 *        the aObjectToDecorate object.
	 */
	EventEmitter.decorate = function EventEmitter_decorate (aObjectToDecorate) {
	  let emitter = new EventEmitter();
	  aObjectToDecorate.on = emitter.on.bind(emitter);
	  aObjectToDecorate.off = emitter.off.bind(emitter);
	  aObjectToDecorate.once = emitter.once.bind(emitter);
	  aObjectToDecorate.emit = emitter.emit.bind(emitter);
	};
	
	EventEmitter.prototype = {
	  /**
	   * Connect a listener.
	   *
	   * @param string aEvent
	   *        The event name to which we're connecting.
	   * @param function aListener
	   *        Called when the event is fired.
	   */
	  on: function EventEmitter_on(aEvent, aListener) {
	    if (!this._eventEmitterListeners)
	      this._eventEmitterListeners = new Map();
	    if (!this._eventEmitterListeners.has(aEvent)) {
	      this._eventEmitterListeners.set(aEvent, []);
	    }
	    this._eventEmitterListeners.get(aEvent).push(aListener);
	  },
	
	  /**
	   * Listen for the next time an event is fired.
	   *
	   * @param string aEvent
	   *        The event name to which we're connecting.
	   * @param function aListener
	   *        (Optional) Called when the event is fired. Will be called at most
	   *        one time.
	   * @return promise
	   *        A promise which is resolved when the event next happens. The
	   *        resolution value of the promise is the first event argument. If
	   *        you need access to second or subsequent event arguments (it's rare
	   *        that this is needed) then use aListener
	   */
	  once: function EventEmitter_once(aEvent, aListener) {
	    let deferred = promise.defer();
	
	    let handler = (aEvent, aFirstArg, ...aRest) => {
	      this.off(aEvent, handler);
	      if (aListener) {
	        aListener.apply(null, [aEvent, aFirstArg, ...aRest]);
	      }
	      deferred.resolve(aFirstArg);
	    };
	
	    handler._originalListener = aListener;
	    this.on(aEvent, handler);
	
	    return deferred.promise;
	  },
	
	  /**
	   * Remove a previously-registered event listener.  Works for events
	   * registered with either on or once.
	   *
	   * @param string aEvent
	   *        The event name whose listener we're disconnecting.
	   * @param function aListener
	   *        The listener to remove.
	   */
	  off: function EventEmitter_off(aEvent, aListener) {
	    if (!this._eventEmitterListeners)
	      return;
	    let listeners = this._eventEmitterListeners.get(aEvent);
	    if (listeners) {
	      this._eventEmitterListeners.set(aEvent, listeners.filter(l => {
	        return l !== aListener && l._originalListener !== aListener;
	      }));
	    }
	  },
	
	  /**
	   * Emit an event.  All arguments to this method will
	   * be sent to listener functions.
	   */
	  emit: function EventEmitter_emit(aEvent) {
	    if (!this._eventEmitterListeners || !this._eventEmitterListeners.has(aEvent)) {
	      return;
	    }
	
	    let originalListeners = this._eventEmitterListeners.get(aEvent);
	    for (let listener of this._eventEmitterListeners.get(aEvent)) {
	      // If the object was destroyed during event emission, stop
	      // emitting.
	      if (!this._eventEmitterListeners) {
	        break;
	      }
	
	      // If listeners were removed during emission, make sure the
	      // event handler we're going to fire wasn't removed.
	      if (originalListeners === this._eventEmitterListeners.get(aEvent) ||
	          this._eventEmitterListeners.get(aEvent).some(l => l === listener)) {
	        try {
	          listener.apply(null, arguments);
	        }
	        catch (ex) {
	          // Prevent a bad listener from interfering with the others.
	          let msg = ex + ": " + ex.stack;
	          //console.error(msg);
	          console.log(msg);
	        }
	      }
	    }
	  },
	};


/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A sham for https://developer.mozilla.org/en-US/Add-ons/SDK/Low-Level_APIs/chrome
	 */
	
	var { inDOMUtils } = __webpack_require__(260);
	
	var ourServices = {
	  inIDOMUtils: inDOMUtils,
	  nsIClipboardHelper: {
	    copyString: () => {}
	  },
	  nsIXULChromeRegistry: {
	    isLocaleRTL: () => {return false;}
	  },
	  nsIDOMParser: {
	
	  },
	};
	
	module.exports = {
	  Cc: name => {
	    if(typeof console !== "undefined") {
	      console.log('Cc sham for', name);
	    }
	    return {
	      getService: (name) => ourServices[name],
	      createInstance: (iface) => ourServices[iface],
	    };
	  },
	  CC: (name, iface, method) => {
	    if(typeof console !== "undefined") {
	      console.log('CC sham for', name, iface, method);
	    }
	    return {
	    };
	  },
	  Ci: {
	    nsIThread: {
	      "DISPATCH_NORMAL":0,
	      "DISPATCH_SYNC":1
	    },
	    nsIDOMNode: typeof HTMLElement !== "undefined" ? HTMLElement : null,
	    nsIFocusManager: {
	      MOVEFOCUS_BACKWARD: 2,
	      MOVEFOCUS_FORWARD: 1,
	    },
	    nsIDOMKeyEvent: {
	
	    },
	    nsIDOMCSSRule: {"UNKNOWN_RULE":0,"STYLE_RULE":1,"CHARSET_RULE":2,"IMPORT_RULE":3,"MEDIA_RULE":4,"FONT_FACE_RULE":5,"PAGE_RULE":6,"KEYFRAMES_RULE":7,"KEYFRAME_RULE":8,"MOZ_KEYFRAMES_RULE":7,"MOZ_KEYFRAME_RULE":8,"NAMESPACE_RULE":10,"COUNTER_STYLE_RULE":11,"SUPPORTS_RULE":12,"FONT_FEATURE_VALUES_RULE":14},
	    inIDOMUtils: "inIDOMUtils",
	    nsIClipboardHelper: "nsIClipboardHelper",
	    nsIXULChromeRegistry: "nsIXULChromeRegistry",
	  },
	  Cu: {
	    reportError: msg => { (typeof console !== "undefined") ? console.error(msg) : dump(msg) },
	    callFunctionWithAsyncStack: fn => fn(),
	  },
	  Cr: {},
	  components: {
	    isSuccessCode: () => (returnCode & 0x80000000) === 0,
	  }
	};


/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	// A sham for inDOMUtils.
	
	"use strict";
	
	var { CSSLexer } = __webpack_require__(261);
	var { cssColors } = __webpack_require__(262);
	var { cssProperties } = __webpack_require__(263);
	
	var cssRGBMap;
	
	// From inIDOMUtils.idl.
	var EXCLUDE_SHORTHANDS = (1 << 0);
	var INCLUDE_ALIASES = (1 << 1);
	var TYPE_LENGTH = 0;
	var TYPE_PERCENTAGE = 1;
	var TYPE_COLOR = 2;
	var TYPE_URL = 3;
	var TYPE_ANGLE = 4;
	var TYPE_FREQUENCY = 5;
	var TYPE_TIME = 6;
	var TYPE_GRADIENT = 7;
	var TYPE_TIMING_FUNCTION = 8;
	var TYPE_IMAGE_RECT = 9;
	var TYPE_NUMBER = 10;
	
	function getCSSLexer(text) {
	  return new CSSLexer(text);
	}
	
	function rgbToColorName(r, g, b) {
	  if (!cssRGBMap) {
	    cssRGBMap = new Map();
	    for (let name in cssColors) {
	      cssRGBMap.set(JSON.stringify(cssColors[name]), name);
	    }
	  }
	  let value = cssRGBMap.get(JSON.stringify([r, g, b]));
	  if (!value) {
	    throw new Error("no such color");
	  }
	  return value;
	}
	
	// Taken from dom/tests/mochitest/ajax/mochikit/MochiKit/Color.js
	function _hslValue(n1, n2, hue) {
	  if (hue > 6.0) {
	    hue -= 6.0;
	  } else if (hue < 0.0) {
	    hue += 6.0;
	  }
	  var val;
	  if (hue < 1.0) {
	    val = n1 + (n2 - n1) * hue;
	  } else if (hue < 3.0) {
	    val = n2;
	  } else if (hue < 4.0) {
	    val = n1 + (n2 - n1) * (4.0 - hue);
	  } else {
	    val = n1;
	  }
	  return val;
	}
	
	// Taken from dom/tests/mochitest/ajax/mochikit/MochiKit/Color.js
	// and then modified.
	function hslToRGB([hue, saturation, lightness]) {
	  var red;
	  var green;
	  var blue;
	  if (saturation === 0) {
	    red = lightness;
	    green = lightness;
	    blue = lightness;
	  } else {
	    var m2;
	    if (lightness <= 0.5) {
	      m2 = lightness * (1.0 + saturation);
	    } else {
	      m2 = lightness + saturation - (lightness * saturation);
	    }
	    var m1 = (2.0 * lightness) - m2;
	    var f = _hslValue;
	    var h6 = hue * 6.0;
	    red = f(m1, m2, h6 + 2);
	    green = f(m1, m2, h6);
	    blue = f(m1, m2, h6 - 2);
	  }
	  return [red, green, blue];
	}
	
	function colorToRGBA(name) {
	  name = name.trim().toLowerCase();
	  if (name in cssColors) {
	    return cssColors[name];
	  }
	
	  if (name === "transparent") {
	    return [0, 0, 0, 0];
	  }
	
	  let lexer = getCSSLexer(name);
	
	  let getToken = function() {
	    while (true) {
	      let token = lexer.nextToken();
	      if (!token || token.tokenType !== "comment" ||
	          token.tokenType !== "whitespace") {
	        return token;
	      }
	    }
	  };
	
	  let requireComma = function(token) {
	    if (token.tokenType !== "symbol" || token.text !== ",") {
	      return null;
	    }
	    return getToken();
	  };
	
	  let func = getToken();
	  if (!func || func.tokenType !== "function") {
	    return null;
	  }
	  let alpha = false;
	  if (func.text === "rgb" || func.text === "hsl") {
	    // Nothing.
	  } else if (func.text === "rgba" || func.text === "hsla") {
	    alpha = true;
	  } else {
	    return null;
	  }
	
	  let vals = [];
	  for (let i = 0; i < 3; ++i) {
	    let token = getToken();
	    if (i > 0) {
	      token = requireComma(token);
	    }
	    if (token.tokenType !== "number" || !token.isInteger) {
	      return null;
	    }
	    let num = token.number;
	    if (num < 0) {
	      num = 0;
	    } else if (num > 255) {
	      num = 255;
	    }
	    vals.push(num);
	  }
	
	  if (func.text === "hsl" || func.text === "hsla") {
	    vals = hslToRGB(vals);
	  }
	
	  if (alpha) {
	    let token = requireComma(getToken());
	    if (token.tokenType !== "number") {
	      return null;
	    }
	    let num = token.number;
	    if (num < 0) {
	      num = 0;
	    } else if (num > 1) {
	      num = 1;
	    }
	    vals.push(num);
	  } else {
	    vals.push(1);
	  }
	
	  let parenToken = getToken();
	  if (!parenToken || parenToken.tokenType !== "symbol" ||
	      parenToken.text !== ")") {
	    return null;
	  }
	  if (getToken() !== null) {
	    return null;
	  }
	
	  return vals;
	}
	
	function isValidCSSColor(name) {
	  return colorToRGBA(name) !== null;
	}
	
	function isVariable(name) {
	  return name.startsWith("--");
	}
	
	function cssPropertyIsShorthand(name) {
	  if (isVariable(name)) {
	    return false;
	  }
	  if (!(name in cssProperties)) {
	    throw Error("unknown property " + name);
	  }
	  return !!cssProperties[name].subproperties;
	}
	
	function getSubpropertiesForCSSProperty(name) {
	  if (isVariable(name)) {
	    return [name];
	  }
	  if (!(name in cssProperties)) {
	    throw Error("unknown property " + name);
	  }
	  if ("subproperties" in cssProperties[name]) {
	    return cssProperties[name].subproperties.slice();
	  }
	  return [name];
	}
	
	function getCSSValuesForProperty(name) {
	  if (isVariable(name)) {
	    return ["initial", "inherit", "unset"];
	  }
	  if (!(name in cssProperties)) {
	    throw Error("unknown property " + name);
	  }
	  return cssProperties[name].values.slice();
	}
	
	function getCSSPropertyNames(flags) {
	  let names = Object.keys(cssProperties);
	  if ((flags & EXCLUDE_SHORTHANDS) !== 0) {
	    names = names.filter((name) => cssProperties[name].subproperties);
	  }
	  if ((flags & INCLUDE_ALIASES) === 0) {
	    names = names.filter((name) => !cssProperties[name].alias);
	  }
	  return names;
	}
	
	function cssPropertySupportsType(name, type) {
	  if (isVariable(name)) {
	    return false;
	  }
	  if (!(name in cssProperties)) {
	    throw Error("unknown property " + name);
	  }
	  return (cssProperties[name].supports & (1 << type)) !== 0;
	}
	
	function isInheritedProperty(name) {
	  if (isVariable(name)) {
	    return true;
	  }
	  if (!(name in cssProperties)) {
	    return false;
	  }
	  return cssProperties[name].inherited;
	}
	
	function cssPropertyIsValid(name, value) {
	  if (isVariable(name)) {
	    return true;
	  }
	  if (!(name in cssProperties)) {
	    return false;
	  }
	  let elt = document.createElement("div");
	  elt.style = name + ":" + value;
	  return elt.style.length > 0;
	}
	
	exports.inDOMUtils = {
	  getCSSLexer,
	  rgbToColorName,
	  colorToRGBA,
	  isValidCSSColor,
	  cssPropertyIsShorthand,
	  getSubpropertiesForCSSProperty,
	  getCSSValuesForProperty,
	  getCSSPropertyNames,
	  cssPropertySupportsType,
	  isInheritedProperty,
	  cssPropertyIsValid,
	
	  // Constants.
	  EXCLUDE_SHORTHANDS,
	  INCLUDE_ALIASES,
	  TYPE_LENGTH,
	  TYPE_PERCENTAGE,
	  TYPE_COLOR,
	  TYPE_URL,
	  TYPE_ANGLE,
	  TYPE_FREQUENCY,
	  TYPE_TIME,
	  TYPE_GRADIENT,
	  TYPE_TIMING_FUNCTION,
	  TYPE_IMAGE_RECT,
	  TYPE_NUMBER,
	};


/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	(function (root, factory) {
	    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
	    // Rhino, and plain browser loading.
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports !== 'undefined') {
	        factory(exports);
	    } else {
	        factory(root);
	    }
	}(this, function (exports) {
	
	function between(num, first, last) { return num >= first && num <= last; }
	function digit(code) { return between(code, 0x30,0x39); }
	function hexdigit(code) { return digit(code) || between(code, 0x41,0x46) || between(code, 0x61,0x66); }
	function uppercaseletter(code) { return between(code, 0x41,0x5a); }
	function lowercaseletter(code) { return between(code, 0x61,0x7a); }
	function letter(code) { return uppercaseletter(code) || lowercaseletter(code); }
	function nonascii(code) { return code >= 0x80; }
	function namestartchar(code) { return letter(code) || nonascii(code) || code == 0x5f; }
	function namechar(code) { return namestartchar(code) || digit(code) || code == 0x2d; }
	function nonprintable(code) { return between(code, 0,8) || code == 0xb || between(code, 0xe,0x1f) || code == 0x7f; }
	function newline(code) { return code == 0xa; }
	function whitespace(code) { return newline(code) || code == 9 || code == 0x20; }
	
	var maximumallowedcodepoint = 0x10ffff;
	
	var InvalidCharacterError = function(message) {
		this.message = message;
	};
	InvalidCharacterError.prototype = new Error;
	InvalidCharacterError.prototype.name = 'InvalidCharacterError';
	
	function stringFromCode(code) {
		if(code <= 0xffff) return String.fromCharCode(code);
		// Otherwise, encode astral char as surrogate pair.
		code -= Math.pow(2, 20);
		var lead = Math.floor(code/Math.pow(2, 10)) + 0xd800;
		var trail = code % Math.pow(2, 10) + 0xdc00;
		return String.fromCharCode(lead) + String.fromCharCode(trail);
	}
	
	function* tokenize(str, options) {
		if (options === undefined) {
			options = {};
		}
		if (options.loc === undefined) {
			options.loc = false;
		}
		if (options.offsets === undefined) {
			options.offsets = false;
		}
		if (options.keepComments === undefined) {
			options.keepComments = false;
		}
		if (options.startOffset === undefined) {
			options.startOffset = 0;
		}
	
		var i = options.startOffset - 1;
		var code;
	
		// Line number information.
		var line = 0;
		var column = 0;
		// The only use of lastLineLength is in reconsume().
		var lastLineLength = 0;
		var incrLineno = function() {
			line += 1;
			lastLineLength = column;
			column = 0;
		};
		var locStart = {line:line, column:column};
		var offsetStart = i;
	
		var codepoint = function(i) {
			if(i >= str.length) {
				return -1;
			}
			return str.charCodeAt(i);
		};
		var next = function(num) {
			if(num === undefined)
				num = 1;
			if(num > 3)
				throw "Spec Error: no more than three codepoints of lookahead.";
	
			var rcode;
			for (var offset = i + 1; num-- > 0; ++offset) {
				rcode = codepoint(offset);
				if (rcode === 0xd && codepoint(offset+1) === 0xa) {
					++offset;
					rcode = 0xa;
				} else if (rcode === 0xd || rcode === 0xc) {
					rcode = 0xa;
				} else if (rcode === 0x0) {
					rcode = 0xfffd;
				}
			}
	
			return rcode;
		};
		var consume = function(num) {
			if(num === undefined)
				num = 1;
			while(num-- > 0) {
				++i;
				code = codepoint(i);
				if (code === 0xd && codepoint(i+1) === 0xa) {
					++i;
					code = 0xa;
				} else if (code === 0xd || code === 0xc) {
					code = 0xa;
				} else if (code === 0x0) {
					code = 0xfffd;
				}
				if(newline(code)) incrLineno();
				else column++;
			}
			return true;
		};
		var reconsume = function() {
			i -= 1;		// This is ok even in the \r\n case.
			if (newline(code)) {
				line -= 1;
				column = lastLineLength;
			} else {
				column -= 1;
			}
			return true;
		};
		var eof = function(codepoint) {
			if(codepoint === undefined) codepoint = code;
			return codepoint == -1;
		};
		var donothing = function() {};
		var parseerror = function() { console.log("Parse error at index " + i + ", processing codepoint 0x" + code.toString(16) + ".");return true; };
	
		var consumeAToken = function() {
			consume();
			if (!options.keepComments) {
				while(code == 0x2f && next() == 0x2a) {
					consumeAComment();
					consume();
				}
			}
			locStart.line = line;
			locStart.column = column;
			offsetStart = i;
			if(whitespace(code)) {
				while(whitespace(next())) consume();
				return new WhitespaceToken;
			}
			else if(code == 0x2f && next() == 0x2a) return consumeAComment();
			else if(code == 0x22) return consumeAStringToken();
			else if(code == 0x23) {
				if(namechar(next()) || areAValidEscape(next(1), next(2))) {
					var token = new HashToken();
					if(wouldStartAnIdentifier(next(1), next(2), next(3))) {
						token.type = "id";
						token.tokenType = "id";
					}
					token.value = consumeAName();
					token.text = token.value;
					return token;
				} else {
					return new DelimToken(code);
				}
			}
			else if(code == 0x24) {
				if(next() == 0x3d) {
					consume();
					return new SuffixMatchToken();
				} else {
					return new DelimToken(code);
				}
			}
			else if(code == 0x27) return consumeAStringToken();
			else if(code == 0x28) return new OpenParenToken();
			else if(code == 0x29) return new CloseParenToken();
			else if(code == 0x2a) {
				if(next() == 0x3d) {
					consume();
					return new SubstringMatchToken();
				} else {
					return new DelimToken(code);
				}
			}
			else if(code == 0x2b) {
				if(startsWithANumber()) {
					reconsume();
					return consumeANumericToken();
				} else {
					return new DelimToken(code);
				}
			}
			else if(code == 0x2c) return new CommaToken();
			else if(code == 0x2d) {
				if(startsWithANumber()) {
					reconsume();
					return consumeANumericToken();
				} else if(next(1) == 0x2d && next(2) == 0x3e) {
					consume(2);
					return new CDCToken();
				} else if(startsWithAnIdentifier()) {
					reconsume();
					return consumeAnIdentlikeToken();
				} else {
					return new DelimToken(code);
				}
			}
			else if(code == 0x2e) {
				if(startsWithANumber()) {
					reconsume();
					return consumeANumericToken();
				} else {
					return new DelimToken(code);
				}
			}
			else if(code == 0x3a) return new ColonToken;
			else if(code == 0x3b) return new SemicolonToken;
			else if(code == 0x3c) {
				if(next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) {
					consume(3);
					return new CDOToken();
				} else {
					return new DelimToken(code);
				}
			}
			else if(code == 0x40) {
				if(wouldStartAnIdentifier(next(1), next(2), next(3))) {
					return new AtKeywordToken(consumeAName());
				} else {
					return new DelimToken(code);
				}
			}
			else if(code == 0x5b) return new OpenSquareToken();
			else if(code == 0x5c) {
				if(startsWithAValidEscape()) {
					reconsume();
					return consumeAnIdentlikeToken();
				} else {
					parseerror();
					return new DelimToken(code);
				}
			}
			else if(code == 0x5d) return new CloseSquareToken();
			else if(code == 0x5e) {
				if(next() == 0x3d) {
					consume();
					return new PrefixMatchToken();
				} else {
					return new DelimToken(code);
				}
			}
			else if(code == 0x7b) return new OpenCurlyToken();
			else if(code == 0x7c) {
				if(next() == 0x3d) {
					consume();
					return new DashMatchToken();
				// } else if(next() == 0x7c) {
				// 	consume();
				// 	return new ColumnToken();
				} else {
					return new DelimToken(code);
				}
			}
			else if(code == 0x7d) return new CloseCurlyToken();
			else if(code == 0x7e) {
				if(next() == 0x3d) {
					consume();
					return new IncludeMatchToken();
				} else {
					return new DelimToken(code);
				}
			}
			else if(digit(code)) {
				reconsume();
				return consumeANumericToken();
			}
			else if(namestartchar(code)) {
				reconsume();
				return consumeAnIdentlikeToken();
			}
			else if(eof()) return new EOFToken();
			else return new DelimToken(code);
		};
	
		var consumeAComment = function() {
			consume();
			var comment = "";
			while(true) {
				consume();
				if(code == 0x2a && next() == 0x2f) {
					consume();
					break;
				} else if(eof()) {
					break;
				}
				comment += stringFromCode(code);
			}
			return new CommentToken(comment);
		};
	
		var consumeANumericToken = function() {
			var num = consumeANumber();
			var token;
			if(wouldStartAnIdentifier(next(1), next(2), next(3))) {
				token = new DimensionToken();
				token.value = num.value;
				token.repr = num.repr;
				token.type = num.type;
				token.unit = consumeAName();
				token.text = token.unit;
			} else if(next() == 0x25) {
				consume();
				token = new PercentageToken();
				token.value = num.value;
				token.repr = num.repr;
			} else {
				var token = new NumberToken();
				token.value = num.value;
				token.repr = num.repr;
				token.type = num.type;
			}
			token.number = token.value;
			token.isInteger = token.type === "integer";
			// FIXME hasSign
			return token;
		};
	
		var consumeAnIdentlikeToken = function() {
			var str = consumeAName();
			if(str.toLowerCase() == "url" && next() == 0x28) {
				consume();
				while(whitespace(next(1)) && whitespace(next(2)))
					consume();
				if((next() == 0x22 || next() == 0x27) ||
				   (whitespace(next()) && (next(2) == 0x22 || next(2) == 0x27))) {
					while(whitespace(next()))
						consume();
					consume();
					let str = consumeAStringToken();
					while(whitespace(next()))
						consume();
					// The closing paren.
					consume();
					return new URLToken(str.text);
				} else {
					return consumeAURLToken();
				}
			} else if(next() == 0x28) {
				consume();
				return new FunctionToken(str);
			} else {
				return new IdentToken(str);
			}
		};
	
		var consumeAStringToken = function(endingCodePoint) {
			if(endingCodePoint === undefined) endingCodePoint = code;
			var string = "";
			while(consume()) {
				if(code == endingCodePoint || eof()) {
					return new StringToken(string);
				} else if(newline(code)) {
					reconsume();
					return new BadStringToken(string);
				} else if(code == 0x5c) {
					if(eof(next())) {
						donothing();
					} else if(newline(next())) {
						consume();
					} else {
						string += stringFromCode(consumeEscape());
					}
				} else {
					string += stringFromCode(code);
				}
			}
		};
	
		var consumeAURLToken = function() {
			var token = new URLToken("");
			while(whitespace(next())) consume();
			if(eof(next())) return token;
			while(consume()) {
				if(code == 0x29 || eof()) {
					break;
				} else if(whitespace(code)) {
					while(whitespace(next()))
						consume();
					if(next() == 0x29 || eof(next())) {
						consume();
						break;
					} else {
						consumeTheRemnantsOfABadURL();
						return new BadURLToken();
					}
				} else if(code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) {
					parseerror();
					consumeTheRemnantsOfABadURL();
					return new BadURLToken();
				} else if(code == 0x5c) {
					if(startsWithAValidEscape()) {
						token.value += stringFromCode(consumeEscape());
					} else {
						parseerror();
						consumeTheRemnantsOfABadURL();
						return new BadURLToken();
					}
				} else {
					token.value += stringFromCode(code);
				}
			}
			token.text = token.value;
			return token;
		};
	
		var consumeEscape = function() {
			// Assume the the current character is the \
			// and the next code point is not a newline.
			consume();
			if(hexdigit(code)) {
				// Consume 1-6 hex digits
				var digits = [code];
				for(var total = 0; total < 5; total++) {
					if(hexdigit(next())) {
						consume();
						digits.push(code);
					} else {
						break;
					}
				}
				if(whitespace(next())) consume();
				var value = parseInt(digits.map(function(x){return String.fromCharCode(x);}).join(''), 16);
				if( value > maximumallowedcodepoint ) value = 0xfffd;
				return value;
			} else if(eof()) {
				return 0xfffd;
			} else {
				return code;
			}
		};
	
		var areAValidEscape = function(c1, c2) {
			if(c1 != 0x5c) return false;
			if(newline(c2)) return false;
			return true;
		};
		var startsWithAValidEscape = function() {
			return areAValidEscape(code, next());
		};
	
		var wouldStartAnIdentifier = function(c1, c2, c3) {
			if(c1 == 0x2d) {
				return namestartchar(c2) || c2 == 0x2d || areAValidEscape(c2, c3);
			} else if(namestartchar(c1)) {
				return true;
			} else if(c1 == 0x5c) {
				return areAValidEscape(c1, c2);
			} else {
				return false;
			}
		};
		var startsWithAnIdentifier = function() {
			return wouldStartAnIdentifier(code, next(1), next(2));
		};
	
		var wouldStartANumber = function(c1, c2, c3) {
			if(c1 == 0x2b || c1 == 0x2d) {
				if(digit(c2)) return true;
				if(c2 == 0x2e && digit(c3)) return true;
				return false;
			} else if(c1 == 0x2e) {
				if(digit(c2)) return true;
				return false;
			} else if(digit(c1)) {
				return true;
			} else {
				return false;
			}
		};
		var startsWithANumber = function() {
			return wouldStartANumber(code, next(1), next(2));
		};
	
		var consumeAName = function() {
			var result = "";
			while(consume()) {
				if(namechar(code)) {
					result += stringFromCode(code);
				} else if(startsWithAValidEscape()) {
					result += stringFromCode(consumeEscape());
				} else {
					reconsume();
					return result;
				}
			}
		};
	
		var consumeANumber = function() {
			var repr = [];
			var type = "integer";
			if(next() == 0x2b || next() == 0x2d) {
				consume();
				repr += stringFromCode(code);
			}
			while(digit(next())) {
				consume();
				repr += stringFromCode(code);
			}
			if(next(1) == 0x2e && digit(next(2))) {
				consume();
				repr += stringFromCode(code);
				consume();
				repr += stringFromCode(code);
				type = "number";
				while(digit(next())) {
					consume();
					repr += stringFromCode(code);
				}
			}
			var c1 = next(1), c2 = next(2), c3 = next(3);
			if((c1 == 0x45 || c1 == 0x65) && digit(c2)) {
				consume();
				repr += stringFromCode(code);
				consume();
				repr += stringFromCode(code);
				type = "number";
				while(digit(next())) {
					consume();
					repr += stringFromCode(code);
				}
			} else if((c1 == 0x45 || c1 == 0x65) && (c2 == 0x2b || c2 == 0x2d) && digit(c3)) {
				consume();
				repr += stringFromCode(code);
				consume();
				repr += stringFromCode(code);
				consume();
				repr += stringFromCode(code);
				type = "number";
				while(digit(next())) {
					consume();
					repr += stringFromCode(code);
				}
			}
			var value = convertAStringToANumber(repr);
			return {type:type, value:value, repr:repr};
		};
	
		var convertAStringToANumber = function(string) {
			// CSS's number rules are identical to JS, afaik.
			return +string;
		};
	
		var consumeTheRemnantsOfABadURL = function() {
			while(consume()) {
				if(code == 0x2d || eof()) {
					return;
				} else if(startsWithAValidEscape()) {
					consumeEscape();
					donothing();
				} else {
					donothing();
				}
			}
		};
	
	
	
		var iterationCount = 0;
		while(!eof(next())) {
			var token = consumeAToken();
			if (options.loc) {
				token.loc = {};
				token.loc.start = {line:locStart.line, column:locStart.column};
				token.loc.end = {line:line, column:column};
			}
			if (options.offsets) {
				token.startOffset = offsetStart;
				token.endOffset = i + 1;
			}
			yield token;
			iterationCount++;
			if(iterationCount > str.length*2) return "I'm infinite-looping!";
		}
	}
	
	function CSSParserToken() { throw "Abstract Base Class"; }
	CSSParserToken.prototype.toJSON = function() {
		return {token: this.tokenType};
	};
	CSSParserToken.prototype.toString = function() { return this.tokenType; };
	CSSParserToken.prototype.toSource = function() { return ''+this; };
	
	function BadStringToken(text) {
		this.text = text;
		return this;
	}
	BadStringToken.prototype = Object.create(CSSParserToken.prototype);
	BadStringToken.prototype.tokenType = "bad_string";
	
	function BadURLToken() { return this; }
	BadURLToken.prototype = Object.create(CSSParserToken.prototype);
	BadURLToken.prototype.tokenType = "bad_url";
	
	function WhitespaceToken() { return this; }
	WhitespaceToken.prototype = Object.create(CSSParserToken.prototype);
	WhitespaceToken.prototype.tokenType = "whitespace";
	WhitespaceToken.prototype.toString = function() { return "WS"; };
	WhitespaceToken.prototype.toSource = function() { return " "; };
	
	function CDOToken() { return this; }
	CDOToken.prototype = Object.create(CSSParserToken.prototype);
	CDOToken.prototype.tokenType = "htmlcomment";
	CDOToken.prototype.toSource = function() { return "<!--"; };
	
	function CDCToken() { return this; }
	CDCToken.prototype = Object.create(CSSParserToken.prototype);
	CDCToken.prototype.tokenType = "htmlcomment";
	CDCToken.prototype.toSource = function() { return "-->"; };
	
	function ColonToken() { return this; }
	ColonToken.prototype = Object.create(CSSParserToken.prototype);
	ColonToken.prototype.tokenType = "symbol";
	ColonToken.prototype.text = ":";
	
	function SemicolonToken() { return this; }
	SemicolonToken.prototype = Object.create(CSSParserToken.prototype);
	SemicolonToken.prototype.tokenType = "symbol";
	SemicolonToken.prototype.text = ";";
	
	function CommaToken() { return this; }
	CommaToken.prototype = Object.create(CSSParserToken.prototype);
	CommaToken.prototype.tokenType = "symbol";
	CommaToken.prototype.text = ",";
	
	function GroupingToken() { throw "Abstract Base Class"; }
	GroupingToken.prototype = Object.create(CSSParserToken.prototype);
	
	function OpenCurlyToken() { this.value = "{"; this.mirror = "}"; return this; }
	OpenCurlyToken.prototype = Object.create(GroupingToken.prototype);
	OpenCurlyToken.prototype.tokenType = "symbol";
	OpenCurlyToken.prototype.text = "{";
	
	function CloseCurlyToken() { this.value = "}"; this.mirror = "{"; return this; }
	CloseCurlyToken.prototype = Object.create(GroupingToken.prototype);
	CloseCurlyToken.prototype.tokenType = "symbol";
	CloseCurlyToken.prototype.text = "}";
	
	function OpenSquareToken() { this.value = "["; this.mirror = "]"; return this; }
	OpenSquareToken.prototype = Object.create(GroupingToken.prototype);
	OpenSquareToken.prototype.tokenType = "symbol";
	OpenSquareToken.prototype.text = "[";
	
	function CloseSquareToken() { this.value = "]"; this.mirror = "["; return this; }
	CloseSquareToken.prototype = Object.create(GroupingToken.prototype);
	CloseSquareToken.prototype.tokenType = "symbol";
	CloseSquareToken.prototype.text = "]";
	
	function OpenParenToken() { this.value = "("; this.mirror = ")"; return this; }
	OpenParenToken.prototype = Object.create(GroupingToken.prototype);
	OpenParenToken.prototype.tokenType = "symbol";
	OpenParenToken.prototype.text = "(";
	
	function CloseParenToken() { this.value = ")"; this.mirror = "("; return this; }
	CloseParenToken.prototype = Object.create(GroupingToken.prototype);
	CloseParenToken.prototype.tokenType = "symbol";
	CloseParenToken.prototype.text = ")";
	
	function IncludeMatchToken() { return this; }
	IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);
	IncludeMatchToken.prototype.tokenType = "includes";
	
	function DashMatchToken() { return this; }
	DashMatchToken.prototype = Object.create(CSSParserToken.prototype);
	DashMatchToken.prototype.tokenType = "dashmatch";
	
	function PrefixMatchToken() { return this; }
	PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);
	PrefixMatchToken.prototype.tokenType = "beginsmatch";
	
	function SuffixMatchToken() { return this; }
	SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);
	SuffixMatchToken.prototype.tokenType = "endsmatch";
	
	function SubstringMatchToken() { return this; }
	SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);
	SubstringMatchToken.prototype.tokenType = "containsmatch";
	
	function ColumnToken() { return this; }
	ColumnToken.prototype = Object.create(CSSParserToken.prototype);
	ColumnToken.prototype.tokenType = "||";
	
	function EOFToken() { return this; }
	EOFToken.prototype = Object.create(CSSParserToken.prototype);
	EOFToken.prototype.tokenType = "EOF";
	EOFToken.prototype.toSource = function() { return ""; };
	
	function DelimToken(code) {
		this.value = stringFromCode(code);
		this.text = this.value;
		return this;
	}
	DelimToken.prototype = Object.create(CSSParserToken.prototype);
	DelimToken.prototype.tokenType = "symbol";
	DelimToken.prototype.toString = function() { return "DELIM("+this.value+")"; };
	DelimToken.prototype.toJSON = function() {
		var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
		json.value = this.value;
		return json;
	};
	DelimToken.prototype.toSource = function() {
		if(this.value == "\\")
			return "\\\n";
		else
			return this.value;
	};
	
	function StringValuedToken() { throw "Abstract Base Class"; }
	StringValuedToken.prototype = Object.create(CSSParserToken.prototype);
	StringValuedToken.prototype.ASCIIMatch = function(str) {
		return this.value.toLowerCase() == str.toLowerCase();
	};
	StringValuedToken.prototype.toJSON = function() {
		var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
		json.value = this.value;
		return json;
	};
	
	function IdentToken(val) {
		this.value = val;
		this.text = val;
	}
	IdentToken.prototype = Object.create(StringValuedToken.prototype);
	IdentToken.prototype.tokenType = "ident";
	IdentToken.prototype.toString = function() { return "IDENT("+this.value+")"; };
	IdentToken.prototype.toSource = function() {
		return escapeIdent(this.value);
	};
	
	function FunctionToken(val) {
		this.value = val;
		this.text = val;
		this.mirror = ")";
	}
	FunctionToken.prototype = Object.create(StringValuedToken.prototype);
	FunctionToken.prototype.tokenType = "function";
	FunctionToken.prototype.toString = function() { return "FUNCTION("+this.value+")"; };
	FunctionToken.prototype.toSource = function() {
		return escapeIdent(this.value) + "(";
	};
	
	function AtKeywordToken(val) {
		this.value = val;
		this.text = val;
	}
	AtKeywordToken.prototype = Object.create(StringValuedToken.prototype);
	AtKeywordToken.prototype.tokenType = "at";
	AtKeywordToken.prototype.toString = function() { return "AT("+this.value+")"; };
	AtKeywordToken.prototype.toSource = function() {
		return "@" + escapeIdent(this.value);
	};
	
	function HashToken(val) {
		this.value = val;
		this.text = val;
		this.type = "unrestricted";
	}
	HashToken.prototype = Object.create(StringValuedToken.prototype);
	HashToken.prototype.tokenType = "hash";
	HashToken.prototype.toString = function() { return "HASH("+this.value+")"; };
	HashToken.prototype.toJSON = function() {
		var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
		json.value = this.value;
		json.type = this.type;
		return json;
	};
	HashToken.prototype.toSource = function() {
		if(this.type == "id") {
			return "#" + escapeIdent(this.value);
		} else {
			return "#" + escapeHash(this.value);
		}
	};
	
	function StringToken(val) {
		this.value = val;
		this.text = val;
	}
	StringToken.prototype = Object.create(StringValuedToken.prototype);
	StringToken.prototype.tokenType = "string";
	StringToken.prototype.toString = function() {
		return '"' + escapeString(this.value) + '"';
	};
	
	function CommentToken(val) {
		this.value = val;
	}
	CommentToken.prototype = Object.create(StringValuedToken.prototype);
	CommentToken.prototype.tokenType = "comment";
	CommentToken.prototype.toString = function() {
		return '/*' + this.value + '*/';
	}
	CommentToken.prototype.toSource = CommentToken.prototype.toString;
	
	function URLToken(val) {
		this.value = val;
		this.text = val;
	}
	URLToken.prototype = Object.create(StringValuedToken.prototype);
	URLToken.prototype.tokenType = "url";
	URLToken.prototype.toString = function() { return "URL("+this.value+")"; };
	URLToken.prototype.toSource = function() {
		return 'url("' + escapeString(this.value) + '")';
	};
	
	function NumberToken() {
		this.value = null;
		this.type = "integer";
		this.repr = "";
	}
	NumberToken.prototype = Object.create(CSSParserToken.prototype);
	NumberToken.prototype.tokenType = "number";
	NumberToken.prototype.toString = function() {
		if(this.type == "integer")
			return "INT("+this.value+")";
		return "NUMBER("+this.value+")";
	};
	NumberToken.prototype.toJSON = function() {
		var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
		json.value = this.value;
		json.type = this.type;
		json.repr = this.repr;
		return json;
	};
	NumberToken.prototype.toSource = function() { return this.repr; };
	
	function PercentageToken() {
		this.value = null;
		this.repr = "";
	}
	PercentageToken.prototype = Object.create(CSSParserToken.prototype);
	PercentageToken.prototype.tokenType = "percentage";
	PercentageToken.prototype.toString = function() { return "PERCENTAGE("+this.value+")"; };
	PercentageToken.prototype.toJSON = function() {
		var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
		json.value = this.value;
		json.repr = this.repr;
		return json;
	};
	PercentageToken.prototype.toSource = function() { return this.repr + "%"; };
	
	function DimensionToken() {
		this.value = null;
		this.type = "integer";
		this.repr = "";
		this.unit = "";
	}
	DimensionToken.prototype = Object.create(CSSParserToken.prototype);
	DimensionToken.prototype.tokenType = "dimension";
	DimensionToken.prototype.toString = function() { return "DIM("+this.value+","+this.unit+")"; };
	DimensionToken.prototype.toJSON = function() {
		var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
		json.value = this.value;
		json.type = this.type;
		json.repr = this.repr;
		json.unit = this.unit;
		return json;
	};
	DimensionToken.prototype.toSource = function() {
		var source = this.repr;
		var unit = escapeIdent(this.unit);
		if(unit[0].toLowerCase() == "e" && (unit[1] == "-" || between(unit.charCodeAt(1), 0x30, 0x39))) {
			// Unit is ambiguous with scinot
			// Remove the leading "e", replace with escape.
			unit = "\\65 " + unit.slice(1, unit.length);
		}
		return source+unit;
	};
	
	function escapeIdent(string) {
		string = ''+string;
		var result = '';
		var firstcode = string.charCodeAt(0);
		for(var i = 0; i < string.length; i++) {
			var code = string.charCodeAt(i);
			if(code === 0x0) {
				throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
			}
	
			if(
				between(code, 0x1, 0x1f) || code == 0x7f ||
				(i === 0 && between(code, 0x30, 0x39)) ||
				(i == 1 && between(code, 0x30, 0x39) && firstcode == 0x2d)
			) {
				result += '\\' + code.toString(16) + ' ';
			} else if(
				code >= 0x80 ||
				code == 0x2d ||
				code == 0x5f ||
				between(code, 0x30, 0x39) ||
				between(code, 0x41, 0x5a) ||
				between(code, 0x61, 0x7a)
			) {
				result += string[i];
			} else {
				result += '\\' + string[i];
			}
		}
		return result;
	}
	
	function escapeHash(string) {
		// Escapes the contents of "unrestricted"-type hash tokens.
		// Won't preserve the ID-ness of "id"-type hash tokens;
		// use escapeIdent() for that.
		string = ''+string;
		var result = '';
		for(var i = 0; i < string.length; i++) {
			var code = string.charCodeAt(i);
			if(code === 0x0) {
				throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
			}
	
			if(
				code >= 0x80 ||
				code == 0x2d ||
				code == 0x5f ||
				between(code, 0x30, 0x39) ||
				between(code, 0x41, 0x5a) ||
				between(code, 0x61, 0x7a)
			) {
				result += string[i];
			} else {
				result += '\\' + code.toString(16) + ' ';
			}
		}
		return result;
	}
	
	function escapeString(string) {
		string = ''+string;
		var result = '';
		for(var i = 0; i < string.length; i++) {
			var code = string.charCodeAt(i);
	
			if(code === 0x0) {
				throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
			}
	
			if(between(code, 0x1, 0x1f) || code == 0x7f) {
				result += '\\' + code.toString(16) + ' ';
			} else if(code == 0x22 || code == 0x5c) {
				result += '\\' + string[i];
			} else {
				result += string[i];
			}
		}
		return result;
	}
	
	// Exportation.
	exports.tokenize = tokenize;
	exports.IdentToken = IdentToken;
	exports.FunctionToken = FunctionToken;
	exports.AtKeywordToken = AtKeywordToken;
	exports.HashToken = HashToken;
	exports.StringToken = StringToken;
	exports.BadStringToken = BadStringToken;
	exports.URLToken = URLToken;
	exports.BadURLToken = BadURLToken;
	exports.DelimToken = DelimToken;
	exports.NumberToken = NumberToken;
	exports.PercentageToken = PercentageToken;
	exports.DimensionToken = DimensionToken;
	exports.IncludeMatchToken = IncludeMatchToken;
	exports.DashMatchToken = DashMatchToken;
	exports.PrefixMatchToken = PrefixMatchToken;
	exports.SuffixMatchToken = SuffixMatchToken;
	exports.SubstringMatchToken = SubstringMatchToken;
	exports.ColumnToken = ColumnToken;
	exports.WhitespaceToken = WhitespaceToken;
	exports.CDOToken = CDOToken;
	exports.CDCToken = CDCToken;
	exports.ColonToken = ColonToken;
	exports.SemicolonToken = SemicolonToken;
	exports.CommaToken = CommaToken;
	exports.OpenParenToken = OpenParenToken;
	exports.CloseParenToken = CloseParenToken;
	exports.OpenSquareToken = OpenSquareToken;
	exports.CloseSquareToken = CloseSquareToken;
	exports.OpenCurlyToken = OpenCurlyToken;
	exports.CloseCurlyToken = CloseCurlyToken;
	exports.EOFToken = EOFToken;
	exports.CSSParserToken = CSSParserToken;
	exports.GroupingToken = GroupingToken;
	
	function TokenStream(tokens) {
		// Assume that tokens is a iterator.
		this.tokens = tokens;
		this.token = undefined;
		this.stored = [];
	}
	TokenStream.prototype.consume = function(num) {
		if(num === undefined) num = 1;
		while (num-- > 0) {
			if (this.stored.length > 0) {
				this.token = this.stored.shift();
			} else {
				var n = this.tokens.next();
				while (!n.done && n.value instanceof CommentToken) {
					n = this.tokens.next();
				}
				if (n.done) {
					this.token = new EOFToken();
					break;
				}
				this.token = n.value;
			}
		}
		//console.log(this.i, this.token);
		return true;
	};
	TokenStream.prototype.next = function() {
		if (this.stored.length === 0) {
			var n = this.tokens.next();
			while (!n.done && n.value instanceof CommentToken) {
				n = this.tokens.next();
			}
			if (n.done)
				return new EOFToken();
			this.stored.push(n.value);
		}
		return this.stored[0];
	};
	TokenStream.prototype.reconsume = function() {
		this.stored.unshift(this.token);
	};
	
	function parseerror(s, msg) {
		console.log("Parse error at token " + s.i + ": " + s.token + ".\n" + msg);
		return true;
	}
	function donothing(){ return true; }
	
	function consumeAListOfRules(s, topLevel) {
		var rules = [];
		var rule;
		while(s.consume()) {
			if(s.token instanceof WhitespaceToken) {
				continue;
			} else if(s.token instanceof EOFToken) {
				return rules;
			} else if(s.token instanceof CDOToken || s.token instanceof CDCToken) {
				if(topLevel == "top-level") continue;
				s.reconsume();
				if(rule = consumeAQualifiedRule(s)) rules.push(rule);
			} else if(s.token instanceof AtKeywordToken) {
				s.reconsume();
				if(rule = consumeAnAtRule(s)) rules.push(rule);
			} else {
				s.reconsume();
				if(rule = consumeAQualifiedRule(s)) rules.push(rule);
			}
		}
	}
	
	function consumeAnAtRule(s) {
		s.consume();
		var rule = new AtRule(s.token.value);
		while(s.consume()) {
			if(s.token instanceof SemicolonToken || s.token instanceof EOFToken) {
				return rule;
			} else if(s.token instanceof OpenCurlyToken) {
				rule.value = consumeASimpleBlock(s);
				return rule;
			} else {
				s.reconsume();
				rule.prelude.push(consumeAComponentValue(s));
			}
		}
	}
	
	function consumeAQualifiedRule(s) {
		var rule = new QualifiedRule();
		while(s.consume()) {
			if(s.token instanceof EOFToken) {
				parseerror(s, "Hit EOF when trying to parse the prelude of a qualified rule.");
				return;
			} else if(s.token instanceof OpenCurlyToken) {
				rule.value = consumeASimpleBlock(s);
				return rule;
			} else {
				s.reconsume();
				rule.prelude.push(consumeAComponentValue(s));
			}
		}
	}
	
	function consumeAListOfDeclarations(s) {
		var decls = [];
		while(s.consume()) {
			if(s.token instanceof WhitespaceToken || s.token instanceof SemicolonToken) {
				donothing();
			} else if(s.token instanceof EOFToken) {
				return decls;
			} else if(s.token instanceof AtKeywordToken) {
				s.reconsume();
				decls.push(consumeAnAtRule(s));
			} else if(s.token instanceof IdentToken) {
				var temp = [s.token];
				while(!(s.next() instanceof SemicolonToken || s.next() instanceof EOFToken))
					temp.push(consumeAComponentValue(s));
				var decl;
				if(decl = consumeADeclaration(new TokenStream(temp))) decls.push(decl);
			} else {
				parseerror(s);
				s.reconsume();
				while(!(s.next() instanceof SemicolonToken || s.next() instanceof EOFToken))
					consumeAComponentValue(s);
			}
		}
	}
	
	function consumeADeclaration(s) {
		// Assumes that the next input token will be an ident token.
		s.consume();
		var decl = new Declaration(s.token.value);
		while(s.next() instanceof WhitespaceToken) s.consume();
		if(!(s.next() instanceof ColonToken)) {
			parseerror(s);
			return;
		} else {
			s.consume();
		}
		while(!(s.next() instanceof EOFToken)) {
			decl.value.push(consumeAComponentValue(s));
		}
		var foundImportant = false;
		for(var i = decl.value.length - 1; i >= 0; i--) {
			if(decl.value[i] instanceof WhitespaceToken) {
				continue;
			} else if(decl.value[i] instanceof IdentToken && decl.value[i].ASCIIMatch("important")) {
				foundImportant = true;
			} else if(foundImportant && decl.value[i] instanceof DelimToken && decl.value[i].value == "!") {
				decl.value.splice(i, decl.value.length);
				decl.important = true;
				break;
			} else {
				break;
			}
		}
		return decl;
	}
	
	function consumeAComponentValue(s) {
		s.consume();
		if(s.token instanceof OpenCurlyToken || s.token instanceof OpenSquareToken || s.token instanceof OpenParenToken)
			return consumeASimpleBlock(s);
		if(s.token instanceof FunctionToken)
			return consumeAFunction(s);
		return s.token;
	}
	
	function consumeASimpleBlock(s) {
		var mirror = s.token.mirror;
		var block = new SimpleBlock(s.token.value);
		block.startToken = s.token;
		while(s.consume()) {
			if(s.token instanceof EOFToken || (s.token instanceof GroupingToken && s.token.value == mirror))
				return block;
			else {
				s.reconsume();
				block.value.push(consumeAComponentValue(s));
			}
		}
	}
	
	function consumeAFunction(s) {
		var func = new Func(s.token.value);
		while(s.consume()) {
			if(s.token instanceof EOFToken || s.token instanceof CloseParenToken)
				return func;
			else {
				s.reconsume();
				func.value.push(consumeAComponentValue(s));
			}
		}
	}
	
	function normalizeInput(input) {
		if(typeof input == "string")
			return new TokenStream(tokenize(input));
		if(input instanceof TokenStream)
			return input;
		if(typeof (input.next) == "function")
			return new TokenStream(input);
		if(input.length !== undefined)
			return new TokenStream(input[Symbol.iterator]());
		else throw SyntaxError(input);
	}
	
	function parseAStylesheet(s) {
		s = normalizeInput(s);
		var sheet = new Stylesheet();
		sheet.value = consumeAListOfRules(s, "top-level");
		return sheet;
	}
	
	function parseAListOfRules(s) {
		s = normalizeInput(s);
		return consumeAListOfRules(s);
	}
	
	function parseARule(s) {
		s = normalizeInput(s);
		while(s.next() instanceof WhitespaceToken) s.consume();
		if(s.next() instanceof EOFToken) throw SyntaxError();
		var rule;
		var startToken = s.next();
		if(startToken instanceof AtKeywordToken) {
			rule = consumeAnAtRule(s);
		} else {
			rule = consumeAQualifiedRule(s);
			if(!rule) throw SyntaxError();
		}
		rule.startToken = startToken;
		rule.endToken = s.token;
		return rule;
	}
	
	function parseADeclaration(s) {
		s = normalizeInput(s);
		while(s.next() instanceof WhitespaceToken) s.consume();
		if(!(s.next() instanceof IdentToken)) throw SyntaxError();
		var decl = consumeADeclaration(s);
		if(decl)
			return decl;
		else
			throw SyntaxError();
	}
	
	function parseAListOfDeclarations(s) {
		s = normalizeInput(s);
		return consumeAListOfDeclarations(s);
	}
	
	function parseAComponentValue(s) {
		s = normalizeInput(s);
		while(s.next() instanceof WhitespaceToken) s.consume();
		if(s.next() instanceof EOFToken) throw SyntaxError();
		var val = consumeAComponentValue(s);
		if(!val) throw SyntaxError();
		while(s.next() instanceof WhitespaceToken) s.consume();
		if(s.next() instanceof EOFToken)
			return val;
		throw SyntaxError();
	}
	
	function parseAListOfComponentValues(s) {
		s = normalizeInput(s);
		var vals = [];
		while(true) {
			var val = consumeAComponentValue(s);
			if(val instanceof EOFToken)
				return vals;
			else
				vals.push(val);
		}
	}
	
	function parseACommaSeparatedListOfComponentValues(s) {
		s = normalizeInput(s);
		var listOfCVLs = [];
		while(true) {
			var vals = [];
			while(true) {
				var val = consumeAComponentValue(s);
				if(val instanceof EOFToken) {
					listOfCVLs.push(vals);
					return listOfCVLs;
				} else if(val instanceof CommaToken) {
					listOfCVLs.push(vals);
					break;
				} else {
					vals.push(val);
				}
			}
		}
	}
	
	
	function CSSParserRule() { throw "Abstract Base Class"; }
	CSSParserRule.prototype.toString = function(indent) {
		return JSON.stringify(this,null,indent);
	};
	CSSParserRule.prototype.toJSON = function() {
		return {type:this.type, value:this.value};
	};
	
	function Stylesheet() {
		this.value = [];
		return this;
	}
	Stylesheet.prototype = Object.create(CSSParserRule.prototype);
	Stylesheet.prototype.type = "STYLESHEET";
	
	function AtRule(name) {
		this.name = name;
		this.prelude = [];
		this.value = null;
		return this;
	}
	AtRule.prototype = Object.create(CSSParserRule.prototype);
	AtRule.prototype.type = "AT-RULE";
	AtRule.prototype.toJSON = function() {
		var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
		json.name = this.name;
		json.prelude = this.prelude;
		return json;
	};
	
	function QualifiedRule() {
		this.prelude = [];
		this.value = [];
		return this;
	}
	QualifiedRule.prototype = Object.create(CSSParserRule.prototype);
	QualifiedRule.prototype.type = "QUALIFIED-RULE";
	QualifiedRule.prototype.toJSON = function() {
		var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
		json.prelude = this.prelude;
		return json;
	};
	
	function Declaration(name) {
		this.name = name;
		this.value = [];
		this.important = false;
		return this;
	}
	Declaration.prototype = Object.create(CSSParserRule.prototype);
	Declaration.prototype.type = "DECLARATION";
	Declaration.prototype.toJSON = function() {
		var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
		json.name = this.name;
		json.important = this.important;
		return json;
	};
	
	function SimpleBlock(type) {
		this.name = type;
		this.value = [];
		return this;
	}
	SimpleBlock.prototype = Object.create(CSSParserRule.prototype);
	SimpleBlock.prototype.type = "BLOCK";
	SimpleBlock.prototype.toJSON = function() {
		var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
		json.name = this.name;
		return json;
	};
	
	function Func(name) {
		this.name = name;
		this.value = [];
		return this;
	}
	Func.prototype = Object.create(CSSParserRule.prototype);
	Func.prototype.type = "FUNCTION";
	Func.prototype.toJSON = function() {
		var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
		json.name = this.name;
		return json;
	};
	
	function CSSLexer(text) {
		this.stream = tokenize(text, {
			loc: true,
			offsets: true,
			keepComments: true
		});
		this.lineNumber = 0;
		this.columnNumber = 0;
		return this;
	}
	
	CSSLexer.prototype.performEOFFixup = function(input, preserveBackslash) {
		// Just lie for now.
		return "";
	};
	
	CSSLexer.prototype.nextToken = function() {
		if (!this.stream) {
			return null;
		}
		let v = this.stream.next();
		if (v.done || v.value.tokenType === "EOF") {
			this.stream = null;
			return null;
		}
		this.lineNumber = v.value.loc.start.line;
		this.columnNumber = v.value.loc.start.column;
		return v.value;
	};
	
	// Exportation.
	exports.CSSParserRule = CSSParserRule;
	exports.Stylesheet = Stylesheet;
	exports.AtRule = AtRule;
	exports.QualifiedRule = QualifiedRule;
	exports.Declaration = Declaration;
	exports.SimpleBlock = SimpleBlock;
	exports.Func = Func;
	exports.parseAStylesheet = parseAStylesheet;
	exports.parseAListOfRules = parseAListOfRules;
	exports.parseARule = parseARule;
	exports.parseADeclaration = parseADeclaration;
	exports.parseAListOfDeclarations = parseAListOfDeclarations;
	exports.parseAComponentValue = parseAComponentValue;
	exports.parseAListOfComponentValues = parseAListOfComponentValues;
	exports.parseACommaSeparatedListOfComponentValues = parseACommaSeparatedListOfComponentValues;
	exports.CSSLexer = CSSLexer;
	
	}));


/***/ },
/* 262 */
/***/ function(module, exports) {

	// auto-generated from nsColorNameList.h
	var cssColors = {
	  aliceblue: [240, 248, 255],
	  antiquewhite: [250, 235, 215],
	  aqua: [0, 255, 255],
	  aquamarine: [127, 255, 212],
	  azure: [240, 255, 255],
	  beige: [245, 245, 220],
	  bisque: [255, 228, 196],
	  black: [0, 0, 0],
	  blanchedalmond: [255, 235, 205],
	  blue: [0, 0, 255],
	  blueviolet: [138, 43, 226],
	  brown: [165, 42, 42],
	  burlywood: [222, 184, 135],
	  cadetblue: [95, 158, 160],
	  chartreuse: [127, 255, 0],
	  chocolate: [210, 105, 30],
	  coral: [255, 127, 80],
	  cornflowerblue: [100, 149, 237],
	  cornsilk: [255, 248, 220],
	  crimson: [220, 20, 60],
	  cyan: [0, 255, 255],
	  darkblue: [0, 0, 139],
	  darkcyan: [0, 139, 139],
	  darkgoldenrod: [184, 134, 11],
	  darkgray: [169, 169, 169],
	  darkgreen: [0, 100, 0],
	  darkgrey: [169, 169, 169],
	  darkkhaki: [189, 183, 107],
	  darkmagenta: [139, 0, 139],
	  darkolivegreen: [85, 107, 47],
	  darkorange: [255, 140, 0],
	  darkorchid: [153, 50, 204],
	  darkred: [139, 0, 0],
	  darksalmon: [233, 150, 122],
	  darkseagreen: [143, 188, 143],
	  darkslateblue: [72, 61, 139],
	  darkslategray: [47, 79, 79],
	  darkslategrey: [47, 79, 79],
	  darkturquoise: [0, 206, 209],
	  darkviolet: [148, 0, 211],
	  deeppink: [255, 20, 147],
	  deepskyblue: [0, 191, 255],
	  dimgray: [105, 105, 105],
	  dimgrey: [105, 105, 105],
	  dodgerblue: [30, 144, 255],
	  firebrick: [178, 34, 34],
	  floralwhite: [255, 250, 240],
	  forestgreen: [34, 139, 34],
	  fuchsia: [255, 0, 255],
	  gainsboro: [220, 220, 220],
	  ghostwhite: [248, 248, 255],
	  gold: [255, 215, 0],
	  goldenrod: [218, 165, 32],
	  gray: [128, 128, 128],
	  grey: [128, 128, 128],
	  green: [0, 128, 0],
	  greenyellow: [173, 255, 47],
	  honeydew: [240, 255, 240],
	  hotpink: [255, 105, 180],
	  indianred: [205, 92, 92],
	  indigo: [75, 0, 130],
	  ivory: [255, 255, 240],
	  khaki: [240, 230, 140],
	  lavender: [230, 230, 250],
	  lavenderblush: [255, 240, 245],
	  lawngreen: [124, 252, 0],
	  lemonchiffon: [255, 250, 205],
	  lightblue: [173, 216, 230],
	  lightcoral: [240, 128, 128],
	  lightcyan: [224, 255, 255],
	  lightgoldenrodyellow: [250, 250, 210],
	  lightgray: [211, 211, 211],
	  lightgreen: [144, 238, 144],
	  lightgrey: [211, 211, 211],
	  lightpink: [255, 182, 193],
	  lightsalmon: [255, 160, 122],
	  lightseagreen: [32, 178, 170],
	  lightskyblue: [135, 206, 250],
	  lightslategray: [119, 136, 153],
	  lightslategrey: [119, 136, 153],
	  lightsteelblue: [176, 196, 222],
	  lightyellow: [255, 255, 224],
	  lime: [0, 255, 0],
	  limegreen: [50, 205, 50],
	  linen: [250, 240, 230],
	  magenta: [255, 0, 255],
	  maroon: [128, 0, 0],
	  mediumaquamarine: [102, 205, 170],
	  mediumblue: [0, 0, 205],
	  mediumorchid: [186, 85, 211],
	  mediumpurple: [147, 112, 219],
	  mediumseagreen: [60, 179, 113],
	  mediumslateblue: [123, 104, 238],
	  mediumspringgreen: [0, 250, 154],
	  mediumturquoise: [72, 209, 204],
	  mediumvioletred: [199, 21, 133],
	  midnightblue: [25, 25, 112],
	  mintcream: [245, 255, 250],
	  mistyrose: [255, 228, 225],
	  moccasin: [255, 228, 181],
	  navajowhite: [255, 222, 173],
	  navy: [0, 0, 128],
	  oldlace: [253, 245, 230],
	  olive: [128, 128, 0],
	  olivedrab: [107, 142, 35],
	  orange: [255, 165, 0],
	  orangered: [255, 69, 0],
	  orchid: [218, 112, 214],
	  palegoldenrod: [238, 232, 170],
	  palegreen: [152, 251, 152],
	  paleturquoise: [175, 238, 238],
	  palevioletred: [219, 112, 147],
	  papayawhip: [255, 239, 213],
	  peachpuff: [255, 218, 185],
	  peru: [205, 133, 63],
	  pink: [255, 192, 203],
	  plum: [221, 160, 221],
	  powderblue: [176, 224, 230],
	  purple: [128, 0, 128],
	  rebeccapurple: [102, 51, 153],
	  red: [255, 0, 0],
	  rosybrown: [188, 143, 143],
	  royalblue: [65, 105, 225],
	  saddlebrown: [139, 69, 19],
	  salmon: [250, 128, 114],
	  sandybrown: [244, 164, 96],
	  seagreen: [46, 139, 87],
	  seashell: [255, 245, 238],
	  sienna: [160, 82, 45],
	  silver: [192, 192, 192],
	  skyblue: [135, 206, 235],
	  slateblue: [106, 90, 205],
	  slategray: [112, 128, 144],
	  slategrey: [112, 128, 144],
	  snow: [255, 250, 250],
	  springgreen: [0, 255, 127],
	  steelblue: [70, 130, 180],
	  tan: [210, 180, 140],
	  teal: [0, 128, 128],
	  thistle: [216, 191, 216],
	  tomato: [255, 99, 71],
	  turquoise: [64, 224, 208],
	  violet: [238, 130, 238],
	  wheat: [245, 222, 179],
	  white: [255, 255, 255],
	  whitesmoke: [245, 245, 245],
	  yellow: [255, 255, 0],
	  yellowgreen: [154, 205, 50],
	};
	module.exports = { cssColors };


/***/ },
/* 263 */
/***/ function(module, exports) {

	// auto-generated by means you would rather not know
	var cssProperties = {
	  "-moz-appearance": {
	    inherited: false,
	    supports: 0,
	    values: ["-moz-gtk-info-bar", "-moz-mac-disclosure-button-closed", "-moz-mac-disclosure-button-open", "-moz-mac-fullscreen-button", "-moz-mac-help-button", "-moz-mac-vibrancy-dark", "-moz-mac-vibrancy-light", "-moz-win-borderless-glass", "-moz-win-browsertabbar-toolbox", "-moz-win-communications-toolbox", "-moz-win-exclude-glass", "-moz-win-glass", "-moz-win-media-toolbox", "-moz-window-button-box", "-moz-window-button-box-maximized", "-moz-window-button-close", "-moz-window-button-maximize", "-moz-window-button-minimize", "-moz-window-button-restore", "-moz-window-frame-bottom", "-moz-window-frame-left", "-moz-window-frame-right", "-moz-window-titlebar", "-moz-window-titlebar-maximized", "button", "button-arrow-down", "button-arrow-next", "button-arrow-previous", "button-arrow-up", "button-bevel", "button-focus", "caret", "checkbox", "checkbox-container", "checkbox-label", "checkmenuitem", "dialog", "dualbutton", "groupbox", "inherit", "initial", "listbox", "listitem", "menuarrow", "menubar", "menucheckbox", "menuimage", "menuitem", "menuitemtext", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menupopup", "menuradio", "menuseparator", "meterbar", "meterchunk", "none", "number-input", "progressbar", "progressbar-vertical", "progresschunk", "progresschunk-vertical", "radio", "radio-container", "radio-label", "radiomenuitem", "range", "range-thumb", "resizer", "resizerpanel", "scale-horizontal", "scale-vertical", "scalethumb-horizontal", "scalethumb-vertical", "scalethumbend", "scalethumbstart", "scalethumbtick", "scrollbar", "scrollbar-small", "scrollbarbutton-down", "scrollbarbutton-left", "scrollbarbutton-right", "scrollbarbutton-up", "scrollbarthumb-horizontal", "scrollbarthumb-vertical", "scrollbartrack-horizontal", "scrollbartrack-vertical", "searchfield", "separator", "spinner", "spinner-downbutton", "spinner-textfield", "spinner-upbutton", "splitter", "statusbar", "statusbarpanel", "tab", "tab-scroll-arrow-back", "tab-scroll-arrow-forward", "tabpanel", "tabpanels", "textfield", "textfield-multiline", "toolbar", "toolbarbutton", "toolbarbutton-dropdown", "toolbargripper", "toolbox", "tooltip", "treeheader", "treeheadercell", "treeheadersortarrow", "treeitem", "treeline", "treetwisty", "treetwistyopen", "treeview", "unset", "window", ],
	  },
	  "-moz-outline-radius-topleft": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-outline-radius-topright": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-outline-radius-bottomright": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-outline-radius-bottomleft": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-tab-size": {
	    inherited: true,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "animation-delay": {
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "animation-direction": {
	    inherited: false,
	    supports: 0,
	    values: ["alternate", "alternate-reverse", "inherit", "initial", "normal", "reverse", "unset", ],
	  },
	  "animation-duration": {
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "animation-fill-mode": {
	    inherited: false,
	    supports: 0,
	    values: ["backwards", "both", "forwards", "inherit", "initial", "none", "unset", ],
	  },
	  "animation-iteration-count": {
	    inherited: false,
	    supports: 1024,
	    values: ["infinite", "inherit", "initial", "unset", ],
	  },
	  "animation-name": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "none", "unset", ],
	  },
	  "animation-play-state": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "paused", "running", "unset", ],
	  },
	  "animation-timing-function": {
	    inherited: false,
	    supports: 256,
	    values: ["cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "step-end", "step-start", "steps", "unset", ],
	  },
	  "background-attachment": {
	    inherited: false,
	    supports: 0,
	    values: ["fixed", "inherit", "initial", "local", "scroll", "unset", ],
	  },
	  "background-clip": {
	    inherited: false,
	    supports: 0,
	    values: ["border-box", "content-box", "inherit", "initial", "padding-box", "unset", ],
	  },
	  "background-color": {
	    inherited: false,
	    supports: 4,
	    values: ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "background-image": {
	    inherited: false,
	    supports: 648,
	    values: ["-moz-element", "-moz-image-rect", "-moz-linear-gradient", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "inherit", "initial", "linear-gradient", "none", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "unset", "url", ],
	  },
	  "background-blend-mode": {
	    inherited: false,
	    supports: 0,
	    values: ["color", "color-burn", "color-dodge", "darken", "difference", "exclusion", "hard-light", "hue", "inherit", "initial", "lighten", "luminosity", "multiply", "normal", "overlay", "saturation", "screen", "soft-light", "unset", ],
	  },
	  "background-origin": {
	    inherited: false,
	    supports: 0,
	    values: ["border-box", "content-box", "inherit", "initial", "padding-box", "unset", ],
	  },
	  "background-position": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "background-repeat": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "no-repeat", "repeat", "repeat-x", "repeat-y", "unset", ],
	  },
	  "background-size": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-binding": {
	    inherited: false,
	    supports: 8,
	    values: ["inherit", "initial", "none", "unset", "url", ],
	  },
	  "block-size": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "border-block-end-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-block-end-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "border-block-end-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "border-block-start-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-block-start-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "border-block-start-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "border-bottom-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "-moz-border-bottom-colors": {
	    inherited: false,
	    supports: 4,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "border-bottom-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "border-bottom-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "border-collapse": {
	    inherited: true,
	    supports: 0,
	    values: ["collapse", "inherit", "initial", "separate", "unset", ],
	  },
	  "border-image-source": {
	    inherited: false,
	    supports: 648,
	    values: ["-moz-element", "-moz-image-rect", "-moz-linear-gradient", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "inherit", "initial", "linear-gradient", "none", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "unset", "url", ],
	  },
	  "border-image-slice": {
	    inherited: false,
	    supports: 1026,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "border-image-width": {
	    inherited: false,
	    supports: 1027,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "border-image-outset": {
	    inherited: false,
	    supports: 1025,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "border-image-repeat": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "border-inline-end-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-inline-end-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "border-inline-end-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "border-inline-start-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-inline-start-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "border-inline-start-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "border-left-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "-moz-border-left-colors": {
	    inherited: false,
	    supports: 4,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "border-left-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "border-left-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "border-right-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "-moz-border-right-colors": {
	    inherited: false,
	    supports: 4,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "border-right-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "border-right-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "border-spacing": {
	    inherited: true,
	    supports: 1,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "border-top-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "-moz-border-top-colors": {
	    inherited: false,
	    supports: 4,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "border-top-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "border-top-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "border-top-left-radius": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "border-top-right-radius": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "border-bottom-right-radius": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "border-bottom-left-radius": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "bottom": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "box-decoration-break": {
	    inherited: false,
	    supports: 0,
	    values: ["clone", "inherit", "initial", "slice", "unset", ],
	  },
	  "box-shadow": {
	    inherited: false,
	    supports: 5,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "box-sizing": {
	    inherited: false,
	    supports: 0,
	    values: ["border-box", "content-box", "inherit", "initial", "padding-box", "unset", ],
	  },
	  "caption-side": {
	    inherited: true,
	    supports: 0,
	    values: ["bottom", "bottom-outside", "inherit", "initial", "left", "right", "top", "top-outside", "unset", ],
	  },
	  "clear": {
	    inherited: false,
	    supports: 0,
	    values: ["both", "inherit", "initial", "inline-end", "inline-start", "left", "none", "right", "unset", ],
	  },
	  "clip": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "color": {
	    inherited: true,
	    supports: 4,
	    values: ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "-moz-column-count": {
	    inherited: false,
	    supports: 1024,
	    values: ["auto", "inherit", "initial", "unset", ],
	  },
	  "-moz-column-fill": {
	    inherited: false,
	    supports: 0,
	    values: ["auto", "balance", "inherit", "initial", "unset", ],
	  },
	  "-moz-column-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "-moz-column-gap": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "normal", "unset", ],
	  },
	  "-moz-column-rule-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "-moz-column-rule-style": {
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "-moz-column-rule-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "contain": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "layout", "none", "paint", "strict", "style", "unset", ],
	  },
	  "content": {
	    inherited: false,
	    supports: 8,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-control-character-visibility": {
	    inherited: true,
	    supports: 0,
	    values: ["hidden", "inherit", "initial", "unset", "visible", ],
	  },
	  "counter-increment": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "counter-reset": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "cursor": {
	    inherited: true,
	    supports: 8,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "direction": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "ltr", "rtl", "unset", ],
	  },
	  "display": {
	    inherited: false,
	    supports: 0,
	    values: ["-moz-box", "-moz-deck", "-moz-grid", "-moz-grid-group", "-moz-grid-line", "-moz-groupbox", "-moz-inline-box", "-moz-inline-grid", "-moz-inline-stack", "-moz-popup", "-moz-stack", "block", "contents", "flex", "grid", "inherit", "initial", "inline", "inline-block", "inline-flex", "inline-grid", "inline-table", "list-item", "none", "ruby", "ruby-base", "ruby-base-container", "ruby-text", "ruby-text-container", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "unset", ],
	  },
	  "empty-cells": {
	    inherited: true,
	    supports: 0,
	    values: ["hide", "inherit", "initial", "show", "unset", ],
	  },
	  "align-content": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "align-items": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "align-self": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "flex-basis": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "flex-direction": {
	    inherited: false,
	    supports: 0,
	    values: ["column", "column-reverse", "inherit", "initial", "row", "row-reverse", "unset", ],
	  },
	  "flex-grow": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "flex-shrink": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "flex-wrap": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "nowrap", "unset", "wrap", "wrap-reverse", ],
	  },
	  "order": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "justify-content": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "justify-items": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "justify-self": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "float": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "inline-end", "inline-start", "left", "none", "right", "unset", ],
	  },
	  "-moz-float-edge": {
	    inherited: false,
	    supports: 0,
	    values: ["content-box", "inherit", "initial", "margin-box", "unset", ],
	  },
	  "font-family": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "font-feature-settings": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "font-kerning": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "none", "normal", "unset", ],
	  },
	  "font-language-override": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "normal", "unset", ],
	  },
	  "font-size": {
	    inherited: true,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "large", "larger", "medium", "small", "smaller", "unset", "x-large", "x-small", "xx-large", "xx-small", ],
	  },
	  "font-size-adjust": {
	    inherited: true,
	    supports: 1024,
	    values: ["inherit", "initial", "none", "unset", ],
	  },
	  "font-stretch": {
	    inherited: true,
	    supports: 0,
	    values: ["condensed", "expanded", "extra-condensed", "extra-expanded", "inherit", "initial", "normal", "semi-condensed", "semi-expanded", "ultra-condensed", "ultra-expanded", "unset", ],
	  },
	  "font-style": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "italic", "normal", "oblique", "unset", ],
	  },
	  "font-synthesis": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "font-variant-alternates": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "font-variant-caps": {
	    inherited: true,
	    supports: 0,
	    values: ["all-petite-caps", "all-small-caps", "inherit", "initial", "normal", "petite-caps", "small-caps", "titling-caps", "unicase", "unset", ],
	  },
	  "font-variant-east-asian": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "font-variant-ligatures": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "font-variant-numeric": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "font-variant-position": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "normal", "sub", "super", "unset", ],
	  },
	  "font-weight": {
	    inherited: true,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-force-broken-image-icon": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-auto-flow": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-auto-columns": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-auto-rows": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-template-areas": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-template-columns": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-template-rows": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-column-start": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-column-end": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-row-start": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-row-end": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-column-gap": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "grid-row-gap": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "height": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "image-orientation": {
	    inherited: true,
	    supports: 16,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-image-region": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "ime-mode": {
	    inherited: false,
	    supports: 0,
	    values: ["active", "auto", "disabled", "inactive", "inherit", "initial", "normal", "unset", ],
	  },
	  "inline-size": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "left": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "letter-spacing": {
	    inherited: true,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "normal", "unset", ],
	  },
	  "line-height": {
	    inherited: true,
	    supports: 1027,
	    values: ["-moz-block-height", "inherit", "initial", "normal", "unset", ],
	  },
	  "list-style-image": {
	    inherited: true,
	    supports: 8,
	    values: ["inherit", "initial", "none", "unset", "url", ],
	  },
	  "list-style-position": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "inside", "outside", "unset", ],
	  },
	  "list-style-type": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "margin-block-end": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "margin-block-start": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "margin-bottom": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "margin-inline-end": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "margin-inline-start": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "margin-left": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "margin-right": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "margin-top": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "marker-offset": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "max-block-size": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "none", "unset", ],
	  },
	  "max-height": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "calc", "inherit", "initial", "none", "unset", ],
	  },
	  "max-inline-size": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "calc", "inherit", "initial", "none", "unset", ],
	  },
	  "max-width": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "calc", "inherit", "initial", "none", "unset", ],
	  },
	  "min-height": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "min-block-size": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "min-inline-size": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "min-width": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "mix-blend-mode": {
	    inherited: false,
	    supports: 0,
	    values: ["color", "color-burn", "color-dodge", "darken", "difference", "exclusion", "hard-light", "hue", "inherit", "initial", "lighten", "luminosity", "multiply", "normal", "overlay", "saturation", "screen", "soft-light", "unset", ],
	  },
	  "isolation": {
	    inherited: false,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "isolate", "unset", ],
	  },
	  "object-fit": {
	    inherited: false,
	    supports: 0,
	    values: ["contain", "cover", "fill", "inherit", "initial", "none", "scale-down", "unset", ],
	  },
	  "object-position": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "offset-block-end": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "offset-block-start": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "offset-inline-end": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "offset-inline-start": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "opacity": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-orient": {
	    inherited: false,
	    supports: 0,
	    values: ["block", "horizontal", "inherit", "initial", "inline", "unset", "vertical", ],
	  },
	  "outline-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "outline-style": {
	    inherited: false,
	    supports: 0,
	    values: ["auto", "dashed", "dotted", "double", "groove", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "outline-width": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "outline-offset": {
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "overflow-x": {
	    inherited: false,
	    supports: 0,
	    values: ["-moz-hidden-unscrollable", "auto", "hidden", "inherit", "initial", "scroll", "unset", "visible", ],
	  },
	  "overflow-y": {
	    inherited: false,
	    supports: 0,
	    values: ["-moz-hidden-unscrollable", "auto", "hidden", "inherit", "initial", "scroll", "unset", "visible", ],
	  },
	  "padding-block-end": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "padding-block-start": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "padding-bottom": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "padding-inline-end": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "padding-inline-start": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "padding-left": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "padding-right": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "padding-top": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "page-break-after": {
	    inherited: false,
	    supports: 0,
	    values: ["always", "auto", "avoid", "inherit", "initial", "left", "right", "unset", ],
	  },
	  "page-break-before": {
	    inherited: false,
	    supports: 0,
	    values: ["always", "auto", "avoid", "inherit", "initial", "left", "right", "unset", ],
	  },
	  "page-break-inside": {
	    inherited: false,
	    supports: 0,
	    values: ["auto", "avoid", "inherit", "initial", "unset", ],
	  },
	  "paint-order": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "pointer-events": {
	    inherited: true,
	    supports: 0,
	    values: ["all", "auto", "fill", "inherit", "initial", "none", "painted", "stroke", "unset", "visible", "visiblefill", "visiblepainted", "visiblestroke", ],
	  },
	  "position": {
	    inherited: false,
	    supports: 0,
	    values: ["absolute", "fixed", "inherit", "initial", "relative", "static", "sticky", "unset", ],
	  },
	  "quotes": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "resize": {
	    inherited: false,
	    supports: 0,
	    values: ["both", "horizontal", "inherit", "initial", "none", "unset", "vertical", ],
	  },
	  "right": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "ruby-align": {
	    inherited: true,
	    supports: 0,
	    values: ["center", "inherit", "initial", "space-around", "space-between", "start", "unset", ],
	  },
	  "ruby-position": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "over", "under", "unset", ],
	  },
	  "scroll-behavior": {
	    inherited: false,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "smooth", "unset", ],
	  },
	  "scroll-snap-coordinate": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "scroll-snap-destination": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "scroll-snap-points-x": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "scroll-snap-points-y": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "scroll-snap-type-x": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "mandatory", "none", "proximity", "unset", ],
	  },
	  "scroll-snap-type-y": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "mandatory", "none", "proximity", "unset", ],
	  },
	  "table-layout": {
	    inherited: false,
	    supports: 0,
	    values: ["auto", "fixed", "inherit", "initial", "unset", ],
	  },
	  "text-align": {
	    inherited: true,
	    supports: 0,
	    values: ["-moz-center", "-moz-left", "-moz-right", "center", "end", "inherit", "initial", "justify", "left", "right", "start", "unset", ],
	  },
	  "-moz-text-align-last": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "center", "end", "inherit", "initial", "justify", "left", "right", "start", "unset", ],
	  },
	  "text-decoration-color": {
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "text-decoration-line": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "text-decoration-style": {
	    inherited: false,
	    supports: 0,
	    values: ["-moz-none", "dashed", "dotted", "double", "inherit", "initial", "solid", "unset", "wavy", ],
	  },
	  "text-indent": {
	    inherited: true,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "text-orientation": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "mixed", "sideways", "sideways-right", "unset", "upright", ],
	  },
	  "text-overflow": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "text-shadow": {
	    inherited: true,
	    supports: 5,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-text-size-adjust": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "none", "unset", ],
	  },
	  "text-transform": {
	    inherited: true,
	    supports: 0,
	    values: ["capitalize", "full-width", "inherit", "initial", "lowercase", "none", "unset", "uppercase", ],
	  },
	  "transform": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "transform-box": {
	    inherited: false,
	    supports: 0,
	    values: ["border-box", "fill-box", "inherit", "initial", "unset", "view-box", ],
	  },
	  "transform-origin": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "perspective-origin": {
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "perspective": {
	    inherited: false,
	    supports: 1,
	    values: ["inherit", "initial", "none", "unset", ],
	  },
	  "transform-style": {
	    inherited: false,
	    supports: 0,
	    values: ["flat", "inherit", "initial", "preserve-3d", "unset", ],
	  },
	  "backface-visibility": {
	    inherited: false,
	    supports: 0,
	    values: ["hidden", "inherit", "initial", "unset", "visible", ],
	  },
	  "top": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "transition-delay": {
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "transition-duration": {
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "transition-property": {
	    inherited: false,
	    supports: 0,
	    values: ["all", "inherit", "initial", "none", "unset", ],
	  },
	  "transition-timing-function": {
	    inherited: false,
	    supports: 256,
	    values: ["cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "step-end", "step-start", "steps", "unset", ],
	  },
	  "unicode-bidi": {
	    inherited: false,
	    supports: 0,
	    values: ["-moz-isolate", "-moz-isolate-override", "-moz-plaintext", "bidi-override", "embed", "inherit", "initial", "normal", "unset", ],
	  },
	  "-moz-user-focus": {
	    inherited: true,
	    supports: 0,
	    values: ["ignore", "inherit", "initial", "none", "normal", "select-after", "select-all", "select-before", "select-menu", "select-same", "unset", ],
	  },
	  "-moz-user-input": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "disabled", "enabled", "inherit", "initial", "none", "unset", ],
	  },
	  "-moz-user-modify": {
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "read-only", "read-write", "unset", "write-only", ],
	  },
	  "-moz-user-select": {
	    inherited: false,
	    supports: 0,
	    values: ["-moz-all", "-moz-none", "-moz-text", "all", "auto", "element", "elements", "inherit", "initial", "none", "text", "toggle", "tri-state", "unset", ],
	  },
	  "vertical-align": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "-moz-middle-with-baseline", "baseline", "bottom", "calc", "inherit", "initial", "middle", "sub", "super", "text-bottom", "text-top", "top", "unset", ],
	  },
	  "visibility": {
	    inherited: true,
	    supports: 0,
	    values: ["collapse", "hidden", "inherit", "initial", "unset", "visible", ],
	  },
	  "white-space": {
	    inherited: true,
	    supports: 0,
	    values: ["-moz-pre-space", "inherit", "initial", "normal", "nowrap", "pre", "pre-line", "pre-wrap", "unset", ],
	  },
	  "width": {
	    inherited: false,
	    supports: 3,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "-moz-window-dragging": {
	    inherited: true,
	    supports: 0,
	    values: ["drag", "inherit", "initial", "no-drag", "unset", ],
	  },
	  "word-break": {
	    inherited: true,
	    supports: 0,
	    values: ["break-all", "inherit", "initial", "keep-all", "normal", "unset", ],
	  },
	  "word-spacing": {
	    inherited: true,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "normal", "unset", ],
	  },
	  "word-wrap": {
	    inherited: true,
	    supports: 0,
	    values: ["break-word", "inherit", "initial", "normal", "unset", ],
	  },
	  "hyphens": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "manual", "none", "unset", ],
	  },
	  "writing-mode": {
	    inherited: true,
	    supports: 0,
	    values: ["horizontal-tb", "inherit", "initial", "lr", "lr-tb", "rl", "rl-tb", "sideways-lr", "sideways-rl", "tb", "tb-rl", "unset", "vertical-lr", "vertical-rl", ],
	  },
	  "z-index": {
	    inherited: false,
	    supports: 1024,
	    values: ["auto", "inherit", "initial", "unset", ],
	  },
	  "-moz-box-align": {
	    inherited: false,
	    supports: 0,
	    values: ["baseline", "center", "end", "inherit", "initial", "start", "stretch", "unset", ],
	  },
	  "-moz-box-direction": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "normal", "reverse", "unset", ],
	  },
	  "-moz-box-flex": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-box-orient": {
	    inherited: false,
	    supports: 0,
	    values: ["block-axis", "horizontal", "inherit", "initial", "inline-axis", "unset", "vertical", ],
	  },
	  "-moz-box-pack": {
	    inherited: false,
	    supports: 0,
	    values: ["center", "end", "inherit", "initial", "justify", "start", "unset", ],
	  },
	  "-moz-box-ordinal-group": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-stack-sizing": {
	    inherited: false,
	    supports: 0,
	    values: ["ignore", "inherit", "initial", "stretch-to-fit", "unset", ],
	  },
	  "clip-path": {
	    inherited: false,
	    supports: 8,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "clip-rule": {
	    inherited: true,
	    supports: 0,
	    values: ["evenodd", "inherit", "initial", "nonzero", "unset", ],
	  },
	  "color-interpolation": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "linearrgb", "srgb", "unset", ],
	  },
	  "color-interpolation-filters": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "linearrgb", "srgb", "unset", ],
	  },
	  "dominant-baseline": {
	    inherited: false,
	    supports: 0,
	    values: ["alphabetic", "auto", "central", "hanging", "ideographic", "inherit", "initial", "mathematical", "middle", "no-change", "reset-size", "text-after-edge", "text-before-edge", "unset", "use-script", ],
	  },
	  "fill": {
	    inherited: true,
	    supports: 12,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "fill-opacity": {
	    inherited: true,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "fill-rule": {
	    inherited: true,
	    supports: 0,
	    values: ["evenodd", "inherit", "initial", "nonzero", "unset", ],
	  },
	  "filter": {
	    inherited: false,
	    supports: 8,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "flood-color": {
	    inherited: false,
	    supports: 4,
	    values: ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "flood-opacity": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "image-rendering": {
	    inherited: true,
	    supports: 0,
	    values: ["-moz-crisp-edges", "auto", "inherit", "initial", "optimizequality", "optimizespeed", "unset", ],
	  },
	  "lighting-color": {
	    inherited: false,
	    supports: 4,
	    values: ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "marker-end": {
	    inherited: true,
	    supports: 8,
	    values: ["inherit", "initial", "none", "unset", "url", ],
	  },
	  "marker-mid": {
	    inherited: true,
	    supports: 8,
	    values: ["inherit", "initial", "none", "unset", "url", ],
	  },
	  "marker-start": {
	    inherited: true,
	    supports: 8,
	    values: ["inherit", "initial", "none", "unset", "url", ],
	  },
	  "mask": {
	    inherited: false,
	    supports: 8,
	    values: ["inherit", "initial", "none", "unset", "url", ],
	  },
	  "mask-type": {
	    inherited: false,
	    supports: 0,
	    values: ["alpha", "inherit", "initial", "luminance", "unset", ],
	  },
	  "shape-rendering": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "crispedges", "geometricprecision", "inherit", "initial", "optimizespeed", "unset", ],
	  },
	  "stop-color": {
	    inherited: false,
	    supports: 4,
	    values: ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "stop-opacity": {
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "stroke": {
	    inherited: true,
	    supports: 12,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "stroke-dasharray": {
	    inherited: true,
	    supports: 1027,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "stroke-dashoffset": {
	    inherited: true,
	    supports: 1027,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "stroke-linecap": {
	    inherited: true,
	    supports: 0,
	    values: ["butt", "inherit", "initial", "round", "square", "unset", ],
	  },
	  "stroke-linejoin": {
	    inherited: true,
	    supports: 0,
	    values: ["bevel", "inherit", "initial", "miter", "round", "unset", ],
	  },
	  "stroke-miterlimit": {
	    inherited: true,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "stroke-opacity": {
	    inherited: true,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "stroke-width": {
	    inherited: true,
	    supports: 1027,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "text-anchor": {
	    inherited: true,
	    supports: 0,
	    values: ["end", "inherit", "initial", "middle", "start", "unset", ],
	  },
	  "text-rendering": {
	    inherited: true,
	    supports: 0,
	    values: ["auto", "geometricprecision", "inherit", "initial", "optimizelegibility", "optimizespeed", "unset", ],
	  },
	  "vector-effect": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "non-scaling-stroke", "none", "unset", ],
	  },
	  "will-change": {
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-outline-radius": {
	    subproperties: ["-moz-outline-radius-topleft", "-moz-outline-radius-topright", "-moz-outline-radius-bottomright", "-moz-outline-radius-bottomleft", ],
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "all": {
	    subproperties: ["-moz-appearance", "-moz-outline-radius-topleft", "-moz-outline-radius-topright", "-moz-outline-radius-bottomright", "-moz-outline-radius-bottomleft", "-moz-tab-size", "-x-system-font", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "background-attachment", "background-clip", "background-color", "background-image", "background-blend-mode", "background-origin", "background-position", "background-repeat", "background-size", "-moz-binding", "block-size", "border-block-end-color", "border-block-end-style", "border-block-end-width", "border-block-start-color", "border-block-start-style", "border-block-start-width", "border-bottom-color", "-moz-border-bottom-colors", "border-bottom-style", "border-bottom-width", "border-collapse", "border-image-source", "border-image-slice", "border-image-width", "border-image-outset", "border-image-repeat", "border-inline-end-color", "border-inline-end-style", "border-inline-end-width", "border-inline-start-color", "border-inline-start-style", "border-inline-start-width", "border-left-color", "-moz-border-left-colors", "border-left-style", "border-left-width", "border-right-color", "-moz-border-right-colors", "border-right-style", "border-right-width", "border-spacing", "border-top-color", "-moz-border-top-colors", "border-top-style", "border-top-width", "border-top-left-radius", "border-top-right-radius", "border-bottom-right-radius", "border-bottom-left-radius", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "caption-side", "clear", "clip", "color", "-moz-column-count", "-moz-column-fill", "-moz-column-width", "-moz-column-gap", "-moz-column-rule-color", "-moz-column-rule-style", "-moz-column-rule-width", "contain", "content", "-moz-control-character-visibility", "counter-increment", "counter-reset", "cursor", "display", "empty-cells", "align-content", "align-items", "align-self", "flex-basis", "flex-direction", "flex-grow", "flex-shrink", "flex-wrap", "order", "justify-content", "justify-items", "justify-self", "float", "-moz-float-edge", "font-family", "font-feature-settings", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "-moz-osx-font-smoothing", "font-stretch", "font-style", "font-synthesis", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-weight", "-moz-force-broken-image-icon", "grid-auto-flow", "grid-auto-columns", "grid-auto-rows", "grid-template-areas", "grid-template-columns", "grid-template-rows", "grid-column-start", "grid-column-end", "grid-row-start", "grid-row-end", "grid-column-gap", "grid-row-gap", "height", "image-orientation", "-moz-image-region", "ime-mode", "inline-size", "left", "letter-spacing", "line-height", "list-style-image", "list-style-position", "list-style-type", "margin-block-end", "margin-block-start", "margin-bottom", "margin-inline-end", "margin-inline-start", "margin-left", "margin-right", "margin-top", "marker-offset", "max-block-size", "max-height", "max-inline-size", "max-width", "-moz-min-font-size-ratio", "min-height", "min-block-size", "min-inline-size", "min-width", "mix-blend-mode", "isolation", "object-fit", "object-position", "offset-block-end", "offset-block-start", "offset-inline-end", "offset-inline-start", "opacity", "-moz-orient", "outline-color", "outline-style", "outline-width", "outline-offset", "overflow-clip-box", "overflow-x", "overflow-y", "padding-block-end", "padding-block-start", "padding-bottom", "padding-inline-end", "padding-inline-start", "padding-left", "padding-right", "padding-top", "page-break-after", "page-break-before", "page-break-inside", "paint-order", "pointer-events", "position", "quotes", "resize", "right", "ruby-align", "ruby-position", "scroll-behavior", "scroll-snap-coordinate", "scroll-snap-destination", "scroll-snap-points-x", "scroll-snap-points-y", "scroll-snap-type-x", "scroll-snap-type-y", "table-layout", "text-align", "-moz-text-align-last", "text-combine-upright", "text-decoration-color", "text-decoration-line", "text-decoration-style", "text-indent", "text-orientation", "text-overflow", "text-shadow", "-moz-text-size-adjust", "text-transform", "transform", "transform-box", "transform-origin", "perspective-origin", "perspective", "transform-style", "backface-visibility", "top", "-moz-top-layer", "touch-action", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "-moz-user-focus", "-moz-user-input", "-moz-user-modify", "-moz-user-select", "vertical-align", "visibility", "white-space", "width", "-moz-window-dragging", "-moz-window-shadow", "word-break", "word-spacing", "word-wrap", "hyphens", "writing-mode", "z-index", "-moz-box-align", "-moz-box-direction", "-moz-box-flex", "-moz-box-orient", "-moz-box-pack", "-moz-box-ordinal-group", "-moz-stack-sizing", "clip-path", "clip-rule", "color-interpolation", "color-interpolation-filters", "dominant-baseline", "fill", "fill-opacity", "fill-rule", "filter", "flood-color", "flood-opacity", "image-rendering", "lighting-color", "marker-end", "marker-mid", "marker-start", "mask", "mask-type", "shape-rendering", "stop-color", "stop-opacity", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-rendering", "vector-effect", "will-change", ],
	    inherited: false,
	    supports: 2015,
	    values: ["-moz-all", "-moz-available", "-moz-block-height", "-moz-box", "-moz-calc", "-moz-center", "-moz-crisp-edges", "-moz-deck", "-moz-element", "-moz-fit-content", "-moz-grid", "-moz-grid-group", "-moz-grid-line", "-moz-groupbox", "-moz-gtk-info-bar", "-moz-hidden-unscrollable", "-moz-image-rect", "-moz-inline-box", "-moz-inline-grid", "-moz-inline-stack", "-moz-left", "-moz-linear-gradient", "-moz-mac-disclosure-button-closed", "-moz-mac-disclosure-button-open", "-moz-mac-fullscreen-button", "-moz-mac-help-button", "-moz-mac-vibrancy-dark", "-moz-mac-vibrancy-light", "-moz-max-content", "-moz-middle-with-baseline", "-moz-min-content", "-moz-none", "-moz-popup", "-moz-pre-space", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "-moz-right", "-moz-stack", "-moz-text", "-moz-use-text-color", "-moz-win-borderless-glass", "-moz-win-browsertabbar-toolbox", "-moz-win-communications-toolbox", "-moz-win-exclude-glass", "-moz-win-glass", "-moz-win-media-toolbox", "-moz-window-button-box", "-moz-window-button-box-maximized", "-moz-window-button-close", "-moz-window-button-maximize", "-moz-window-button-minimize", "-moz-window-button-restore", "-moz-window-frame-bottom", "-moz-window-frame-left", "-moz-window-frame-right", "-moz-window-titlebar", "-moz-window-titlebar-maximized", "absolute", "active", "aliceblue", "all", "all-petite-caps", "all-small-caps", "alpha", "alphabetic", "alternate", "alternate-reverse", "always", "antiquewhite", "aqua", "aquamarine", "auto", "avoid", "azure", "backwards", "balance", "baseline", "beige", "bevel", "bisque", "black", "blanchedalmond", "block", "block-axis", "blue", "blueviolet", "border-box", "both", "bottom", "bottom-outside", "break-all", "break-word", "brown", "burlywood", "butt", "button", "button-arrow-down", "button-arrow-next", "button-arrow-previous", "button-arrow-up", "button-bevel", "button-focus", "cadetblue", "calc", "capitalize", "caret", "center", "central", "chartreuse", "checkbox", "checkbox-container", "checkbox-label", "checkmenuitem", "chocolate", "clone", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse", "condensed", "contain", "content-box", "contents", "coral", "cornflowerblue", "cornsilk", "cover", "crimson", "crispedges", "cubic-bezier", "currentColor", "cyan", "darkblue", "darkcyan", "darken", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dialog", "difference", "dimgray", "dimgrey", "disabled", "dodgerblue", "dotted", "double", "drag", "dualbutton", "ease", "ease-in", "ease-in-out", "ease-out", "element", "elements", "enabled", "end", "evenodd", "exclusion", "expanded", "extra-condensed", "extra-expanded", "fill", "fill-box", "firebrick", "fixed", "flat", "flex", "floralwhite", "forestgreen", "forwards", "fuchsia", "full-width", "gainsboro", "geometricprecision", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "grid", "groove", "groupbox", "hanging", "hard-light", "hidden", "hide", "honeydew", "horizontal", "horizontal-tb", "hotpink", "hsl", "hsla", "hue", "ideographic", "ignore", "inactive", "indianred", "indigo", "infinite", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-end", "inline-flex", "inline-grid", "inline-start", "inline-table", "inset", "inside", "isolate", "italic", "ivory", "justify", "keep-all", "khaki", "large", "larger", "lavender", "lavenderblush", "lawngreen", "layout", "left", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lighten", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linear", "linear-gradient", "linearrgb", "linen", "list-item", "listbox", "listitem", "local", "lowercase", "lr", "lr-tb", "luminance", "luminosity", "magenta", "mandatory", "manual", "margin-box", "maroon", "mathematical", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "menuarrow", "menubar", "menucheckbox", "menuimage", "menuitem", "menuitemtext", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menupopup", "menuradio", "menuseparator", "meterbar", "meterchunk", "middle", "midnightblue", "mintcream", "mistyrose", "miter", "mixed", "moccasin", "multiply", "navajowhite", "navy", "no-change", "no-drag", "no-repeat", "non-scaling-stroke", "none", "nonzero", "normal", "nowrap", "number-input", "oblique", "oldlace", "olive", "olivedrab", "optimizelegibility", "optimizequality", "optimizespeed", "orange", "orangered", "orchid", "outset", "outside", "over", "overlay", "padding-box", "paint", "painted", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "paused", "peachpuff", "peru", "petite-caps", "pink", "plum", "powderblue", "pre", "pre-line", "pre-wrap", "preserve-3d", "progressbar", "progressbar-vertical", "progresschunk", "progresschunk-vertical", "proximity", "purple", "radial-gradient", "radio", "radio-container", "radio-label", "radiomenuitem", "range", "range-thumb", "read-only", "read-write", "rebeccapurple", "red", "relative", "repeat", "repeat-x", "repeat-y", "repeating-linear-gradient", "repeating-radial-gradient", "reset-size", "resizer", "resizerpanel", "reverse", "rgb", "rgba", "ridge", "right", "rl", "rl-tb", "rosybrown", "round", "row", "row-reverse", "royalblue", "ruby", "ruby-base", "ruby-base-container", "ruby-text", "ruby-text-container", "running", "saddlebrown", "salmon", "sandybrown", "saturation", "scale-down", "scale-horizontal", "scale-vertical", "scalethumb-horizontal", "scalethumb-vertical", "scalethumbend", "scalethumbstart", "scalethumbtick", "screen", "scroll", "scrollbar", "scrollbar-small", "scrollbarbutton-down", "scrollbarbutton-left", "scrollbarbutton-right", "scrollbarbutton-up", "scrollbarthumb-horizontal", "scrollbarthumb-vertical", "scrollbartrack-horizontal", "scrollbartrack-vertical", "seagreen", "searchfield", "seashell", "select-after", "select-all", "select-before", "select-menu", "select-same", "semi-condensed", "semi-expanded", "separate", "separator", "show", "sideways", "sideways-lr", "sideways-right", "sideways-rl", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "slice", "small", "small-caps", "smaller", "smooth", "snow", "soft-light", "solid", "space-around", "space-between", "spinner", "spinner-downbutton", "spinner-textfield", "spinner-upbutton", "splitter", "springgreen", "square", "srgb", "start", "static", "statusbar", "statusbarpanel", "steelblue", "step-end", "step-start", "steps", "sticky", "stretch", "stretch-to-fit", "strict", "stroke", "style", "sub", "super", "tab", "tab-scroll-arrow-back", "tab-scroll-arrow-forward", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "tabpanel", "tabpanels", "tan", "tb", "tb-rl", "teal", "text", "text-after-edge", "text-before-edge", "text-bottom", "text-top", "textfield", "textfield-multiline", "thick", "thin", "thistle", "titling-caps", "toggle", "tomato", "toolbar", "toolbarbutton", "toolbarbutton-dropdown", "toolbargripper", "toolbox", "tooltip", "top", "top-outside", "transparent", "treeheader", "treeheadercell", "treeheadersortarrow", "treeitem", "treeline", "treetwisty", "treetwistyopen", "treeview", "tri-state", "turquoise", "ultra-condensed", "ultra-expanded", "under", "unicase", "unset", "uppercase", "upright", "url", "use-script", "vertical", "vertical-lr", "vertical-rl", "view-box", "violet", "visible", "visiblefill", "visiblepainted", "visiblestroke", "wavy", "wheat", "white", "whitesmoke", "window", "wrap", "wrap-reverse", "write-only", "x-large", "x-small", "xx-large", "xx-small", "yellow", "yellowgreen", ],
	  },
	  "animation": {
	    subproperties: ["animation-duration", "animation-timing-function", "animation-delay", "animation-direction", "animation-fill-mode", "animation-iteration-count", "animation-play-state", "animation-name", ],
	    inherited: false,
	    supports: 1344,
	    values: ["alternate", "alternate-reverse", "backwards", "both", "cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "forwards", "infinite", "inherit", "initial", "linear", "none", "normal", "paused", "reverse", "running", "step-end", "step-start", "steps", "unset", ],
	  },
	  "background": {
	    subproperties: ["background-color", "background-image", "background-repeat", "background-attachment", "background-position", "background-clip", "background-origin", "background-size", ],
	    inherited: false,
	    supports: 655,
	    values: ["-moz-element", "-moz-image-rect", "-moz-linear-gradient", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "border-box", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "content-box", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "fixed", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linear-gradient", "linen", "local", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "no-repeat", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "padding-box", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "radial-gradient", "rebeccapurple", "red", "repeat", "repeat-x", "repeat-y", "repeating-linear-gradient", "repeating-radial-gradient", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "scroll", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "url", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border": {
	    subproperties: ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width", "border-top-style", "border-right-style", "border-bottom-style", "border-left-style", "border-top-color", "border-right-color", "border-bottom-color", "border-left-color", "-moz-border-top-colors", "-moz-border-right-colors", "-moz-border-bottom-colors", "-moz-border-left-colors", "border-image-source", "border-image-slice", "border-image-width", "border-image-outset", "border-image-repeat", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-element", "-moz-image-rect", "-moz-linear-gradient", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linear-gradient", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "radial-gradient", "rebeccapurple", "red", "repeating-linear-gradient", "repeating-radial-gradient", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "url", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-block-end": {
	    subproperties: ["border-block-end-width", "border-block-end-style", "border-block-end-color", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-block-start": {
	    subproperties: ["border-block-start-width", "border-block-start-style", "border-block-start-color", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-bottom": {
	    subproperties: ["border-bottom-width", "border-bottom-style", "border-bottom-color", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-color": {
	    subproperties: ["border-top-color", "border-right-color", "border-bottom-color", "border-left-color", ],
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-image": {
	    subproperties: ["border-image-source", "border-image-slice", "border-image-width", "border-image-outset", "border-image-repeat", ],
	    inherited: false,
	    supports: 1675,
	    values: ["-moz-element", "-moz-image-rect", "-moz-linear-gradient", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "inherit", "initial", "linear-gradient", "none", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "unset", "url", ],
	  },
	  "border-inline-end": {
	    subproperties: ["border-inline-end-width", "border-inline-end-style", "border-inline-end-color", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-inline-start": {
	    subproperties: ["border-inline-start-width", "border-inline-start-style", "border-inline-start-color", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-left": {
	    subproperties: ["border-left-width", "border-left-style", "border-left-color", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-right": {
	    subproperties: ["border-right-width", "border-right-style", "border-right-color", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-style": {
	    subproperties: ["border-top-style", "border-right-style", "border-bottom-style", "border-left-style", ],
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "border-top": {
	    subproperties: ["border-top-width", "border-top-style", "border-top-color", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "border-width": {
	    subproperties: ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width", ],
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "border-radius": {
	    subproperties: ["border-top-left-radius", "border-top-right-radius", "border-bottom-right-radius", "border-bottom-left-radius", ],
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-columns": {
	    subproperties: ["-moz-column-count", "-moz-column-width", ],
	    inherited: false,
	    supports: 1025,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "-moz-column-rule": {
	    subproperties: ["-moz-column-rule-width", "-moz-column-rule-style", "-moz-column-rule-color", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "flex": {
	    subproperties: ["flex-grow", "flex-shrink", "flex-basis", ],
	    inherited: false,
	    supports: 1027,
	    values: ["-moz-available", "-moz-calc", "-moz-fit-content", "-moz-max-content", "-moz-min-content", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "flex-flow": {
	    subproperties: ["flex-direction", "flex-wrap", ],
	    inherited: false,
	    supports: 0,
	    values: ["column", "column-reverse", "inherit", "initial", "nowrap", "row", "row-reverse", "unset", "wrap", "wrap-reverse", ],
	  },
	  "font": {
	    subproperties: ["font-family", "font-style", "font-weight", "font-size", "line-height", "font-size-adjust", "font-stretch", "-x-system-font", "font-feature-settings", "font-language-override", "font-kerning", "font-synthesis", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", ],
	    inherited: true,
	    supports: 1027,
	    values: ["-moz-block-height", "-moz-calc", "all-petite-caps", "all-small-caps", "auto", "calc", "condensed", "expanded", "extra-condensed", "extra-expanded", "inherit", "initial", "italic", "large", "larger", "medium", "none", "normal", "oblique", "petite-caps", "semi-condensed", "semi-expanded", "small", "small-caps", "smaller", "sub", "super", "titling-caps", "ultra-condensed", "ultra-expanded", "unicase", "unset", "x-large", "x-small", "xx-large", "xx-small", ],
	  },
	  "font-variant": {
	    subproperties: ["font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", ],
	    inherited: true,
	    supports: 0,
	    values: ["all-petite-caps", "all-small-caps", "inherit", "initial", "normal", "petite-caps", "small-caps", "sub", "super", "titling-caps", "unicase", "unset", ],
	  },
	  "grid-template": {
	    subproperties: ["grid-template-areas", "grid-template-columns", "grid-template-rows", ],
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid": {
	    subproperties: ["grid-template-areas", "grid-template-columns", "grid-template-rows", "grid-auto-flow", "grid-auto-columns", "grid-auto-rows", "grid-column-gap", "grid-row-gap", ],
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "grid-column": {
	    subproperties: ["grid-column-start", "grid-column-end", ],
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-row": {
	    subproperties: ["grid-row-start", "grid-row-end", ],
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-area": {
	    subproperties: ["grid-row-start", "grid-column-start", "grid-row-end", "grid-column-end", ],
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "grid-gap": {
	    subproperties: ["grid-column-gap", "grid-row-gap", ],
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "list-style": {
	    subproperties: ["list-style-type", "list-style-image", "list-style-position", ],
	    inherited: true,
	    supports: 8,
	    values: ["inherit", "initial", "inside", "none", "outside", "unset", "url", ],
	  },
	  "margin": {
	    subproperties: ["margin-top", "margin-right", "margin-bottom", "margin-left", ],
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "outline": {
	    subproperties: ["outline-width", "outline-style", "outline-color", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "auto", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "overflow": {
	    subproperties: ["overflow-x", "overflow-y", ],
	    inherited: false,
	    supports: 0,
	    values: ["-moz-hidden-unscrollable", "auto", "hidden", "inherit", "initial", "scroll", "unset", "visible", ],
	  },
	  "padding": {
	    subproperties: ["padding-top", "padding-right", "padding-bottom", "padding-left", ],
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "scroll-snap-type": {
	    subproperties: ["scroll-snap-type-x", "scroll-snap-type-y", ],
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "mandatory", "none", "proximity", "unset", ],
	  },
	  "text-decoration": {
	    subproperties: ["text-decoration-color", "text-decoration-line", "text-decoration-style", ],
	    inherited: false,
	    supports: 4,
	    values: ["-moz-none", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wavy", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "transition": {
	    subproperties: ["transition-property", "transition-duration", "transition-timing-function", "transition-delay", ],
	    inherited: false,
	    supports: 320,
	    values: ["all", "cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "none", "step-end", "step-start", "steps", "unset", ],
	  },
	  "marker": {
	    subproperties: ["marker-start", "marker-mid", "marker-end", ],
	    inherited: true,
	    supports: 8,
	    values: ["inherit", "initial", "none", "unset", "url", ],
	  },
	  "-moz-transform": {
	    alias: true,
	    subproperties: ["transform", ],
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-transform-origin": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-perspective-origin": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-perspective": {
	    alias: true,
	    inherited: false,
	    supports: 1,
	    values: ["inherit", "initial", "none", "unset", ],
	  },
	  "-moz-transform-style": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["flat", "inherit", "initial", "preserve-3d", "unset", ],
	  },
	  "-moz-backface-visibility": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["hidden", "inherit", "initial", "unset", "visible", ],
	  },
	  "-moz-border-image": {
	    alias: true,
	    subproperties: ["border-image-source", "border-image-slice", "border-image-width", "border-image-outset", "border-image-repeat", ],
	    inherited: false,
	    supports: 1675,
	    values: ["-moz-element", "-moz-image-rect", "-moz-linear-gradient", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "inherit", "initial", "linear-gradient", "none", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "unset", "url", ],
	  },
	  "-moz-transition": {
	    alias: true,
	    subproperties: ["transition-property", "transition-duration", "transition-timing-function", "transition-delay", ],
	    inherited: false,
	    supports: 320,
	    values: ["all", "cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "none", "step-end", "step-start", "steps", "unset", ],
	  },
	  "-moz-transition-delay": {
	    alias: true,
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-transition-duration": {
	    alias: true,
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-transition-property": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["all", "inherit", "initial", "none", "unset", ],
	  },
	  "-moz-transition-timing-function": {
	    alias: true,
	    inherited: false,
	    supports: 256,
	    values: ["cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "step-end", "step-start", "steps", "unset", ],
	  },
	  "-moz-animation": {
	    alias: true,
	    subproperties: ["animation-duration", "animation-timing-function", "animation-delay", "animation-direction", "animation-fill-mode", "animation-iteration-count", "animation-play-state", "animation-name", ],
	    inherited: false,
	    supports: 1344,
	    values: ["alternate", "alternate-reverse", "backwards", "both", "cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "forwards", "infinite", "inherit", "initial", "linear", "none", "normal", "paused", "reverse", "running", "step-end", "step-start", "steps", "unset", ],
	  },
	  "-moz-animation-delay": {
	    alias: true,
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-animation-direction": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["alternate", "alternate-reverse", "inherit", "initial", "normal", "reverse", "unset", ],
	  },
	  "-moz-animation-duration": {
	    alias: true,
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-animation-fill-mode": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["backwards", "both", "forwards", "inherit", "initial", "none", "unset", ],
	  },
	  "-moz-animation-iteration-count": {
	    alias: true,
	    inherited: false,
	    supports: 1024,
	    values: ["infinite", "inherit", "initial", "unset", ],
	  },
	  "-moz-animation-name": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "none", "unset", ],
	  },
	  "-moz-animation-play-state": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "paused", "running", "unset", ],
	  },
	  "-moz-animation-timing-function": {
	    alias: true,
	    inherited: false,
	    supports: 256,
	    values: ["cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "step-end", "step-start", "steps", "unset", ],
	  },
	  "-moz-box-sizing": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["border-box", "content-box", "inherit", "initial", "padding-box", "unset", ],
	  },
	  "-moz-font-feature-settings": {
	    alias: true,
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-moz-font-language-override": {
	    alias: true,
	    inherited: true,
	    supports: 0,
	    values: ["inherit", "initial", "normal", "unset", ],
	  },
	  "-moz-padding-end": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "-moz-padding-start": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "calc", "inherit", "initial", "unset", ],
	  },
	  "-moz-margin-end": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "-moz-margin-start": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["-moz-calc", "auto", "calc", "inherit", "initial", "unset", ],
	  },
	  "-moz-border-end": {
	    alias: true,
	    subproperties: ["border-inline-end-width", "border-inline-end-style", "border-inline-end-color", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "-moz-border-end-color": {
	    alias: true,
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "-moz-border-end-style": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "-moz-border-end-width": {
	    alias: true,
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "-moz-border-start": {
	    alias: true,
	    subproperties: ["border-inline-start-width", "border-inline-start-style", "border-inline-start-color", ],
	    inherited: false,
	    supports: 5,
	    values: ["-moz-calc", "-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "calc", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "dashed", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "dotted", "double", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "groove", "hidden", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "inset", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "medium", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "none", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "outset", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "ridge", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "solid", "springgreen", "steelblue", "tan", "teal", "thick", "thin", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "-moz-border-start-color": {
	    alias: true,
	    inherited: false,
	    supports: 4,
	    values: ["-moz-use-text-color", "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "currentColor", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "hsl", "hsla", "indianred", "indigo", "inherit", "initial", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rgb", "rgba", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "unset", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen", ],
	  },
	  "-moz-border-start-style": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["dashed", "dotted", "double", "groove", "hidden", "inherit", "initial", "inset", "none", "outset", "ridge", "solid", "unset", ],
	  },
	  "-moz-border-start-width": {
	    alias: true,
	    inherited: false,
	    supports: 1,
	    values: ["-moz-calc", "calc", "inherit", "initial", "medium", "thick", "thin", "unset", ],
	  },
	  "-moz-hyphens": {
	    alias: true,
	    inherited: true,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "manual", "none", "unset", ],
	  },
	  "-webkit-animation": {
	    alias: true,
	    subproperties: ["animation-duration", "animation-timing-function", "animation-delay", "animation-direction", "animation-fill-mode", "animation-iteration-count", "animation-play-state", "animation-name", ],
	    inherited: false,
	    supports: 1344,
	    values: ["alternate", "alternate-reverse", "backwards", "both", "cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "forwards", "infinite", "inherit", "initial", "linear", "none", "normal", "paused", "reverse", "running", "step-end", "step-start", "steps", "unset", ],
	  },
	  "-webkit-animation-delay": {
	    alias: true,
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-animation-direction": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["alternate", "alternate-reverse", "inherit", "initial", "normal", "reverse", "unset", ],
	  },
	  "-webkit-animation-duration": {
	    alias: true,
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-animation-fill-mode": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["backwards", "both", "forwards", "inherit", "initial", "none", "unset", ],
	  },
	  "-webkit-animation-iteration-count": {
	    alias: true,
	    inherited: false,
	    supports: 1024,
	    values: ["infinite", "inherit", "initial", "unset", ],
	  },
	  "-webkit-animation-name": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "none", "unset", ],
	  },
	  "-webkit-animation-play-state": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "paused", "running", "unset", ],
	  },
	  "-webkit-animation-timing-function": {
	    alias: true,
	    inherited: false,
	    supports: 256,
	    values: ["cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "step-end", "step-start", "steps", "unset", ],
	  },
	  "-webkit-text-size-adjust": {
	    alias: true,
	    inherited: true,
	    supports: 0,
	    values: ["auto", "inherit", "initial", "none", "unset", ],
	  },
	  "-webkit-transform": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-transform-origin": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-transform-style": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["flat", "inherit", "initial", "preserve-3d", "unset", ],
	  },
	  "-webkit-backface-visibility": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["hidden", "inherit", "initial", "unset", "visible", ],
	  },
	  "-webkit-perspective": {
	    alias: true,
	    inherited: false,
	    supports: 1,
	    values: ["inherit", "initial", "none", "unset", ],
	  },
	  "-webkit-perspective-origin": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-transition": {
	    alias: true,
	    subproperties: ["transition-property", "transition-duration", "transition-timing-function", "transition-delay", ],
	    inherited: false,
	    supports: 320,
	    values: ["all", "cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "none", "step-end", "step-start", "steps", "unset", ],
	  },
	  "-webkit-transition-delay": {
	    alias: true,
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-transition-duration": {
	    alias: true,
	    inherited: false,
	    supports: 64,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-transition-property": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["all", "inherit", "initial", "none", "unset", ],
	  },
	  "-webkit-transition-timing-function": {
	    alias: true,
	    inherited: false,
	    supports: 256,
	    values: ["cubic-bezier", "ease", "ease-in", "ease-in-out", "ease-out", "inherit", "initial", "linear", "step-end", "step-start", "steps", "unset", ],
	  },
	  "-webkit-border-radius": {
	    alias: true,
	    subproperties: ["border-top-left-radius", "border-top-right-radius", "border-bottom-right-radius", "border-bottom-left-radius", ],
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-border-top-left-radius": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-border-top-right-radius": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-border-bottom-left-radius": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-border-bottom-right-radius": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-appearance": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["-moz-gtk-info-bar", "-moz-mac-disclosure-button-closed", "-moz-mac-disclosure-button-open", "-moz-mac-fullscreen-button", "-moz-mac-help-button", "-moz-mac-vibrancy-dark", "-moz-mac-vibrancy-light", "-moz-win-borderless-glass", "-moz-win-browsertabbar-toolbox", "-moz-win-communications-toolbox", "-moz-win-exclude-glass", "-moz-win-glass", "-moz-win-media-toolbox", "-moz-window-button-box", "-moz-window-button-box-maximized", "-moz-window-button-close", "-moz-window-button-maximize", "-moz-window-button-minimize", "-moz-window-button-restore", "-moz-window-frame-bottom", "-moz-window-frame-left", "-moz-window-frame-right", "-moz-window-titlebar", "-moz-window-titlebar-maximized", "button", "button-arrow-down", "button-arrow-next", "button-arrow-previous", "button-arrow-up", "button-bevel", "button-focus", "caret", "checkbox", "checkbox-container", "checkbox-label", "checkmenuitem", "dialog", "dualbutton", "groupbox", "inherit", "initial", "listbox", "listitem", "menuarrow", "menubar", "menucheckbox", "menuimage", "menuitem", "menuitemtext", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menupopup", "menuradio", "menuseparator", "meterbar", "meterchunk", "none", "number-input", "progressbar", "progressbar-vertical", "progresschunk", "progresschunk-vertical", "radio", "radio-container", "radio-label", "radiomenuitem", "range", "range-thumb", "resizer", "resizerpanel", "scale-horizontal", "scale-vertical", "scalethumb-horizontal", "scalethumb-vertical", "scalethumbend", "scalethumbstart", "scalethumbtick", "scrollbar", "scrollbar-small", "scrollbarbutton-down", "scrollbarbutton-left", "scrollbarbutton-right", "scrollbarbutton-up", "scrollbarthumb-horizontal", "scrollbarthumb-vertical", "scrollbartrack-horizontal", "scrollbartrack-vertical", "searchfield", "separator", "spinner", "spinner-downbutton", "spinner-textfield", "spinner-upbutton", "splitter", "statusbar", "statusbarpanel", "tab", "tab-scroll-arrow-back", "tab-scroll-arrow-forward", "tabpanel", "tabpanels", "textfield", "textfield-multiline", "toolbar", "toolbarbutton", "toolbarbutton-dropdown", "toolbargripper", "toolbox", "tooltip", "treeheader", "treeheadercell", "treeheadersortarrow", "treeitem", "treeline", "treetwisty", "treetwistyopen", "treeview", "unset", "window", ],
	  },
	  "-webkit-background-clip": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["border-box", "content-box", "inherit", "initial", "padding-box", "unset", ],
	  },
	  "-webkit-background-origin": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["border-box", "content-box", "inherit", "initial", "padding-box", "unset", ],
	  },
	  "-webkit-background-size": {
	    alias: true,
	    inherited: false,
	    supports: 3,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-border-image": {
	    alias: true,
	    subproperties: ["border-image-source", "border-image-slice", "border-image-width", "border-image-outset", "border-image-repeat", ],
	    inherited: false,
	    supports: 1675,
	    values: ["-moz-element", "-moz-image-rect", "-moz-linear-gradient", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "inherit", "initial", "linear-gradient", "none", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "unset", "url", ],
	  },
	  "-webkit-border-image-outset": {
	    alias: true,
	    inherited: false,
	    supports: 1025,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-border-image-repeat": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-border-image-slice": {
	    alias: true,
	    inherited: false,
	    supports: 1026,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-border-image-source": {
	    alias: true,
	    inherited: false,
	    supports: 648,
	    values: ["-moz-element", "-moz-image-rect", "-moz-linear-gradient", "-moz-radial-gradient", "-moz-repeating-linear-gradient", "-moz-repeating-radial-gradient", "inherit", "initial", "linear-gradient", "none", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "unset", "url", ],
	  },
	  "-webkit-border-image-width": {
	    alias: true,
	    inherited: false,
	    supports: 1027,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-box-shadow": {
	    alias: true,
	    inherited: false,
	    supports: 5,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-box-sizing": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["border-box", "content-box", "inherit", "initial", "padding-box", "unset", ],
	  },
	  "-webkit-box-flex": {
	    alias: true,
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-box-ordinal-group": {
	    alias: true,
	    inherited: false,
	    supports: 1024,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-box-align": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-box-pack": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["inherit", "initial", "unset", ],
	  },
	  "-webkit-user-select": {
	    alias: true,
	    inherited: false,
	    supports: 0,
	    values: ["-moz-all", "-moz-none", "-moz-text", "all", "auto", "element", "elements", "inherit", "initial", "none", "text", "toggle", "tri-state", "unset", ],
	  },
	};
	module.exports = { cssProperties };


/***/ },
/* 264 */
/***/ function(module, exports) {

	/*
	 * A sham for https://dxr.mozilla.org/mozilla-central/source/toolkit/modules/Promise.jsm
	 */
	
	/**
	 * Promise.jsm is mostly the Promise web API with a `defer` method. Just drop this in here,
	 * and use the native web API (although building with webpack/babel, it may replace this
	 * with it's own version if we want to target environments that do not have `Promise`.
	 */
	
	let p = typeof window != "undefined" ?  window.Promise : Promise;
	p.defer = function defer() {
	  var resolve, reject;
	  var promise = new Promise(function() {
	    resolve = arguments[0];
	    reject = arguments[1];
	  });
	  return {
	    resolve: resolve,
	    reject: reject,
	    promise: promise
	  };
	}
	
	module.exports = p;


/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-env browser */
	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	// TODO: Get rid of this code once the marionette server loads transport.js as
	// an SDK module (see bug 1000814)
	
	"use strict";
	
	const DevToolsUtils = __webpack_require__(266);
	const { dumpn, dumpv } = DevToolsUtils;
	const StreamUtils = __webpack_require__(272);
	const { Packet, JSONPacket, BulkPacket } =
	  __webpack_require__(273);
	const promise = __webpack_require__(264);
	const EventEmitter = __webpack_require__(258);
	const utf8 = __webpack_require__(275);
	
	const PACKET_HEADER_MAX = 200;
	
	/**
	 * An adapter that handles data transfers between the debugger client and
	 * server. It can work with both nsIPipe and nsIServerSocket transports so
	 * long as the properly created input and output streams are specified.
	 * (However, for intra-process connections, LocalDebuggerTransport, below,
	 * is more efficient than using an nsIPipe pair with DebuggerTransport.)
	 *
	 * @param input nsIAsyncInputStream
	 *        The input stream.
	 * @param output nsIAsyncOutputStream
	 *        The output stream.
	 *
	 * Given a DebuggerTransport instance dt:
	 * 1) Set dt.hooks to a packet handler object (described below).
	 * 2) Call dt.ready() to begin watching for input packets.
	 * 3) Call dt.send() / dt.startBulkSend() to send packets.
	 * 4) Call dt.close() to close the connection, and disengage from the event
	 *    loop.
	 *
	 * A packet handler is an object with the following methods:
	 *
	 * - onPacket(packet) - called when we have received a complete packet.
	 *   |packet| is the parsed form of the packet --- a JavaScript value, not
	 *   a JSON-syntax string.
	 *
	 * - onBulkPacket(packet) - called when we have switched to bulk packet
	 *   receiving mode. |packet| is an object containing:
	 *   * actor:  Name of actor that will receive the packet
	 *   * type:   Name of actor's method that should be called on receipt
	 *   * length: Size of the data to be read
	 *   * stream: This input stream should only be used directly if you can ensure
	 *             that you will read exactly |length| bytes and will not close the
	 *             stream when reading is complete
	 *   * done:   If you use the stream directly (instead of |copyTo| below), you
	 *             must signal completion by resolving / rejecting this deferred.
	 *             If it's rejected, the transport will be closed.  If an Error is
	 *             supplied as a rejection value, it will be logged via |dumpn|.
	 *             If you do use |copyTo|, resolving is taken care of for you when
	 *             copying completes.
	 *   * copyTo: A helper function for getting your data out of the stream that
	 *             meets the stream handling requirements above, and has the
	 *             following signature:
	 *     @param  output nsIAsyncOutputStream
	 *             The stream to copy to.
	 *     @return Promise
	 *             The promise is resolved when copying completes or rejected if any
	 *             (unexpected) errors occur.
	 *             This object also emits "progress" events for each chunk that is
	 *             copied.  See stream-utils.js.
	 *
	 * - onClosed(reason) - called when the connection is closed. |reason| is
	 *   an optional nsresult or object, typically passed when the transport is
	 *   closed due to some error in a underlying stream.
	 *
	 * See ./packets.js and the Remote Debugging Protocol specification for more
	 * details on the format of these packets.
	 */
	function DebuggerTransport(socket) {
	  EventEmitter.decorate(this);
	
	  this._socket = socket;
	
	  // The current incoming (possibly partial) header, which will determine which
	  // type of Packet |_incoming| below will become.
	  this._incomingHeader = "";
	  // The current incoming Packet object
	  this._incoming = null;
	  // A queue of outgoing Packet objects
	  this._outgoing = [];
	
	  this.hooks = null;
	  this.active = false;
	
	  this._incomingEnabled = true;
	  this._outgoingEnabled = true;
	
	  this.close = this.close.bind(this);
	}
	
	DebuggerTransport.prototype = {
	  /**
	   * Transmit an object as a JSON packet.
	   *
	   * This method returns immediately, without waiting for the entire
	   * packet to be transmitted, registering event handlers as needed to
	   * transmit the entire packet. Packets are transmitted in the order
	   * they are passed to this method.
	   */
	  send: function(object) {
	    this.emit("send", object);
	
	    let packet = new JSONPacket(this);
	    packet.object = object;
	    this._outgoing.push(packet);
	    this._flushOutgoing();
	  },
	
	  /**
	   * Transmit streaming data via a bulk packet.
	   *
	   * This method initiates the bulk send process by queuing up the header data.
	   * The caller receives eventual access to a stream for writing.
	   *
	   * N.B.: Do *not* attempt to close the stream handed to you, as it will
	   * continue to be used by this transport afterwards.  Most users should
	   * instead use the provided |copyFrom| function instead.
	   *
	   * @param header Object
	   *        This is modeled after the format of JSON packets above, but does not
	   *        actually contain the data, but is instead just a routing header:
	   *          * actor:  Name of actor that will receive the packet
	   *          * type:   Name of actor's method that should be called on receipt
	   *          * length: Size of the data to be sent
	   * @return Promise
	   *         The promise will be resolved when you are allowed to write to the
	   *         stream with an object containing:
	   *           * stream:   This output stream should only be used directly if
	   *                       you can ensure that you will write exactly |length|
	   *                       bytes and will not close the stream when writing is
	   *                       complete
	   *           * done:     If you use the stream directly (instead of |copyFrom|
	   *                       below), you must signal completion by resolving /
	   *                       rejecting this deferred.  If it's rejected, the
	   *                       transport will be closed.  If an Error is supplied as
	   *                       a rejection value, it will be logged via |dumpn|.  If
	   *                       you do use |copyFrom|, resolving is taken care of for
	   *                       you when copying completes.
	   *           * copyFrom: A helper function for getting your data onto the
	   *                       stream that meets the stream handling requirements
	   *                       above, and has the following signature:
	   *             @param  input nsIAsyncInputStream
	   *                     The stream to copy from.
	   *             @return Promise
	   *                     The promise is resolved when copying completes or
	   *                     rejected if any (unexpected) errors occur.
	   *                     This object also emits "progress" events for each chunk
	   *                     that is copied.  See stream-utils.js.
	   */
	  startBulkSend: function(header) {
	    this.emit("startBulkSend", header);
	
	    let packet = new BulkPacket(this);
	    packet.header = header;
	    this._outgoing.push(packet);
	    this._flushOutgoing();
	    return packet.streamReadyForWriting;
	  },
	
	  /**
	   * Close the transport.
	   * @param reason nsresult / object (optional)
	   *        The status code or error message that corresponds to the reason for
	   *        closing the transport (likely because a stream closed or failed).
	   */
	  close: function(reason) {
	    this.emit("onClosed", reason);
	
	    this.active = false;
	    this._socket.close();
	    this._destroyIncoming();
	    this._destroyAllOutgoing();
	    if (this.hooks) {
	      this.hooks.onClosed(reason);
	      this.hooks = null;
	    }
	    if (reason) {
	      dumpn("Transport closed: " + DevToolsUtils.safeErrorString(reason));
	    } else {
	      dumpn("Transport closed.");
	    }
	  },
	
	  /**
	   * The currently outgoing packet (at the top of the queue).
	   */
	  get _currentOutgoing() {
	    return this._outgoing[0];
	  },
	
	  /**
	   * Flush data to the outgoing stream.  Waits until the output stream notifies
	   * us that it is ready to be written to (via onOutputStreamReady).
	   */
	  _flushOutgoing: function() {
	    if (!this._outgoingEnabled || this._outgoing.length === 0) {
	      return;
	    }
	
	    // If the top of the packet queue has nothing more to send, remove it.
	    if (this._currentOutgoing.done) {
	      this._finishCurrentOutgoing();
	    }
	
	    if (this._outgoing.length > 0) {
	      setTimeout(this.onOutputStreamReady.bind(this), 0);
	    }
	  },
	
	  /**
	   * Pause this transport's attempts to write to the output stream.  This is
	   * used when we've temporarily handed off our output stream for writing bulk
	   * data.
	   */
	  pauseOutgoing: function() {
	    this._outgoingEnabled = false;
	  },
	
	  /**
	   * Resume this transport's attempts to write to the output stream.
	   */
	  resumeOutgoing: function() {
	    this._outgoingEnabled = true;
	    this._flushOutgoing();
	  },
	
	  // nsIOutputStreamCallback
	  /**
	   * This is called when the output stream is ready for more data to be written.
	   * The current outgoing packet will attempt to write some amount of data, but
	   * may not complete.
	   */
	  onOutputStreamReady: DevToolsUtils.makeInfallible(function() {
	    if (!this._outgoingEnabled || this._outgoing.length === 0) {
	      return;
	    }
	
	    try {
	      this._currentOutgoing.write({
	        write: data => {
	          let count = data.length;
	          this._socket.send(data);
	          return count;
	        }
	      });
	    } catch(e) {
	      if (e.result != Cr.NS_BASE_STREAM_WOULD_BLOCK) {
	        this.close(e.result);
	        return;
	      } else {
	        throw e;
	      }
	    }
	
	    this._flushOutgoing();
	  }, "DebuggerTransport.prototype.onOutputStreamReady"),
	
	  /**
	   * Remove the current outgoing packet from the queue upon completion.
	   */
	  _finishCurrentOutgoing: function() {
	    if (this._currentOutgoing) {
	      this._currentOutgoing.destroy();
	      this._outgoing.shift();
	    }
	  },
	
	  /**
	   * Clear the entire outgoing queue.
	   */
	  _destroyAllOutgoing: function() {
	    for (let packet of this._outgoing) {
	      packet.destroy();
	    }
	    this._outgoing = [];
	  },
	
	  /**
	   * Initialize the input stream for reading. Once this method has been called,
	   * we watch for packets on the input stream, and pass them to the appropriate
	   * handlers via this.hooks.
	   */
	  ready: function() {
	    this.active = true;
	    this._waitForIncoming();
	  },
	
	  /**
	   * Asks the input stream to notify us (via onInputStreamReady) when it is
	   * ready for reading.
	   */
	  _waitForIncoming: function() {
	    if (this._incomingEnabled && !this._socket.onmessage) {
	      this._socket.onmessage = this.onInputStreamReady.bind(this);
	    }
	  },
	
	  /**
	   * Pause this transport's attempts to read from the input stream.  This is
	   * used when we've temporarily handed off our input stream for reading bulk
	   * data.
	   */
	  pauseIncoming: function() {
	    this._incomingEnabled = false;
	  },
	
	  /**
	   * Resume this transport's attempts to read from the input stream.
	   */
	  resumeIncoming: function() {
	    this._incomingEnabled = true;
	    this._flushIncoming();
	    this._waitForIncoming();
	  },
	
	  // nsIInputStreamCallback
	  /**
	   * Called when the stream is either readable or closed.
	   */
	  onInputStreamReady:
	  DevToolsUtils.makeInfallible(function(event) {
	    let data = event.data;
	    // TODO: ws-tcp-proxy decodes utf-8, but the transport expects to see the
	    // encoded bytes.  Simplest step is to re-encode for now.
	    data = utf8.encode(data);
	    let stream = {
	      available() {
	        return data.length;
	      },
	      readBytes(count) {
	        let result = data.slice(0, count);
	        data = data.slice(count);
	        return result;
	      },
	    };
	
	    try {
	      while (data && this._incomingEnabled &&
	             this._processIncoming(stream, stream.available())) {}
	      this._waitForIncoming();
	    } catch(e) {
	      if (e.result != Cr.NS_BASE_STREAM_WOULD_BLOCK) {
	        this.close(e.result);
	      } else {
	        throw e;
	      }
	    }
	  }, "DebuggerTransport.prototype.onInputStreamReady"),
	
	  /**
	   * Process the incoming data.  Will create a new currently incoming Packet if
	   * needed.  Tells the incoming Packet to read as much data as it can, but
	   * reading may not complete.  The Packet signals that its data is ready for
	   * delivery by calling one of this transport's _on*Ready methods (see
	   * ./packets.js and the _on*Ready methods below).
	   * @return boolean
	   *         Whether incoming stream processing should continue for any
	   *         remaining data.
	   */
	  _processIncoming: function(stream, count) {
	    dumpv("Data available: " + count);
	
	    if (!count) {
	      dumpv("Nothing to read, skipping");
	      return false;
	    }
	
	    try {
	      if (!this._incoming) {
	        dumpv("Creating a new packet from incoming");
	
	        if (!this._readHeader(stream)) {
	          return false; // Not enough data to read packet type
	        }
	
	        // Attempt to create a new Packet by trying to parse each possible
	        // header pattern.
	        this._incoming = Packet.fromHeader(this._incomingHeader, this);
	        if (!this._incoming) {
	          throw new Error("No packet types for header: " +
	                          this._incomingHeader);
	        }
	      }
	
	      if (!this._incoming.done) {
	        // We have an incomplete packet, keep reading it.
	        dumpv("Existing packet incomplete, keep reading");
	        this._incoming.read(stream);
	      }
	    } catch(e) {
	      let msg = "Error reading incoming packet: (" + e + " - " + e.stack + ")";
	      dumpn(msg);
	
	      // Now in an invalid state, shut down the transport.
	      this.close();
	      return false;
	    }
	
	    if (!this._incoming.done) {
	      // Still not complete, we'll wait for more data.
	      dumpv("Packet not done, wait for more");
	      return true;
	    }
	
	    // Ready for next packet
	    this._flushIncoming();
	    return true;
	  },
	
	  /**
	   * Read as far as we can into the incoming data, attempting to build up a
	   * complete packet header (which terminates with ":").  We'll only read up to
	   * PACKET_HEADER_MAX characters.
	   * @return boolean
	   *         True if we now have a complete header.
	   */
	  _readHeader: function(stream) {
	    let amountToRead = PACKET_HEADER_MAX - this._incomingHeader.length;
	    this._incomingHeader +=
	      StreamUtils.delimitedRead(stream, ":", amountToRead);
	    if (dumpv.wantVerbose) {
	      dumpv("Header read: " + this._incomingHeader);
	    }
	
	    if (this._incomingHeader.endsWith(":")) {
	      if (dumpv.wantVerbose) {
	        dumpv("Found packet header successfully: " + this._incomingHeader);
	      }
	      return true;
	    }
	
	    if (this._incomingHeader.length >= PACKET_HEADER_MAX) {
	      throw new Error("Failed to parse packet header!");
	    }
	
	    // Not enough data yet.
	    return false;
	  },
	
	  /**
	   * If the incoming packet is done, log it as needed and clear the buffer.
	   */
	  _flushIncoming: function() {
	    if (!this._incoming.done) {
	      return;
	    }
	    if (dumpn.wantLogging) {
	      dumpn("Got: " + this._incoming);
	    }
	    this._destroyIncoming();
	  },
	
	  /**
	   * Handler triggered by an incoming JSONPacket completing it's |read| method.
	   * Delivers the packet to this.hooks.onPacket.
	   */
	  _onJSONObjectReady: function(object) {
	    DevToolsUtils.executeSoon(DevToolsUtils.makeInfallible(() => {
	      // Ensure the transport is still alive by the time this runs.
	      if (this.active) {
	        this.emit("onPacket", object);
	        this.hooks.onPacket(object);
	      }
	    }, "DebuggerTransport instance's this.hooks.onPacket"));
	  },
	
	  /**
	   * Handler triggered by an incoming BulkPacket entering the |read| phase for
	   * the stream portion of the packet.  Delivers info about the incoming
	   * streaming data to this.hooks.onBulkPacket.  See the main comment on the
	   * transport at the top of this file for more details.
	   */
	  _onBulkReadReady: function(...args) {
	    DevToolsUtils.executeSoon(DevToolsUtils.makeInfallible(() => {
	      // Ensure the transport is still alive by the time this runs.
	      if (this.active) {
	        this.emit("onBulkPacket", ...args);
	        this.hooks.onBulkPacket(...args);
	      }
	    }, "DebuggerTransport instance's this.hooks.onBulkPacket"));
	  },
	
	  /**
	   * Remove all handlers and references related to the current incoming packet,
	   * either because it is now complete or because the transport is closing.
	   */
	  _destroyIncoming: function() {
	    if (this._incoming) {
	      this._incoming.destroy();
	    }
	    this._incomingHeader = "";
	    this._incoming = null;
	  }
	
	};
	
	exports.DebuggerTransport = DebuggerTransport;
	
	/**
	 * An adapter that handles data transfers between the debugger client and
	 * server when they both run in the same process. It presents the same API as
	 * DebuggerTransport, but instead of transmitting serialized messages across a
	 * connection it merely calls the packet dispatcher of the other side.
	 *
	 * @param other LocalDebuggerTransport
	 *        The other endpoint for this debugger connection.
	 *
	 * @see DebuggerTransport
	 */
	function LocalDebuggerTransport(other) {
	  EventEmitter.decorate(this);
	
	  this.other = other;
	  this.hooks = null;
	
	  /*
	   * A packet number, shared between this and this.other. This isn't used
	   * by the protocol at all, but it makes the packet traces a lot easier to
	   * follow.
	   */
	  this._serial = this.other ? this.other._serial : { count: 0 };
	  this.close = this.close.bind(this);
	}
	
	LocalDebuggerTransport.prototype = {
	  /**
	   * Transmit a message by directly calling the onPacket handler of the other
	   * endpoint.
	   */
	  send: function(packet) {
	    this.emit("send", packet);
	
	    let serial = this._serial.count++;
	    if (dumpn.wantLogging) {
	      /* Check 'from' first, as 'echo' packets have both. */
	      if (packet.from) {
	        dumpn("Packet " + serial + " sent from " + uneval(packet.from));
	      } else if (packet.to) {
	        dumpn("Packet " + serial + " sent to " + uneval(packet.to));
	      }
	    }
	    this._deepFreeze(packet);
	    let other = this.other;
	    if (other) {
	      DevToolsUtils.executeSoon(DevToolsUtils.makeInfallible(() => {
	        // Avoid the cost of JSON.stringify() when logging is disabled.
	        if (dumpn.wantLogging) {
	          dumpn("Received packet " + serial + ": " + JSON.stringify(packet, null, 2));
	        }
	        if (other.hooks) {
	          other.emit("onPacket", packet);
	          other.hooks.onPacket(packet);
	        }
	      }, "LocalDebuggerTransport instance's this.other.hooks.onPacket"));
	    }
	  },
	
	  /**
	   * Send a streaming bulk packet directly to the onBulkPacket handler of the
	   * other endpoint.
	   *
	   * This case is much simpler than the full DebuggerTransport, since there is
	   * no primary stream we have to worry about managing while we hand it off to
	   * others temporarily.  Instead, we can just make a single use pipe and be
	   * done with it.
	   */
	  startBulkSend: function({actor, type, length}) {
	    this.emit("startBulkSend", {actor, type, length});
	
	    let serial = this._serial.count++;
	
	    dumpn("Sent bulk packet " + serial + " for actor " + actor);
	    if (!this.other) {
	      return;
	    }
	
	    let pipe = new Pipe(true, true, 0, 0, null);
	
	    DevToolsUtils.executeSoon(DevToolsUtils.makeInfallible(() => {
	      dumpn("Received bulk packet " + serial);
	      if (!this.other.hooks) {
	        return;
	      }
	
	      // Receiver
	      let deferred = promise.defer();
	      let packet = {
	        actor: actor,
	        type: type,
	        length: length,
	        copyTo: (output) => {
	          let copying =
	            StreamUtils.copyStream(pipe.inputStream, output, length);
	          deferred.resolve(copying);
	          return copying;
	        },
	        stream: pipe.inputStream,
	        done: deferred
	      };
	
	      this.other.emit("onBulkPacket", packet);
	      this.other.hooks.onBulkPacket(packet);
	
	      // Await the result of reading from the stream
	      deferred.promise.then(() => pipe.inputStream.close(), this.close);
	    }, "LocalDebuggerTransport instance's this.other.hooks.onBulkPacket"));
	
	    // Sender
	    let sendDeferred = promise.defer();
	
	    // The remote transport is not capable of resolving immediately here, so we
	    // shouldn't be able to either.
	    DevToolsUtils.executeSoon(() => {
	      let copyDeferred = promise.defer();
	
	      sendDeferred.resolve({
	        copyFrom: (input) => {
	          let copying =
	            StreamUtils.copyStream(input, pipe.outputStream, length);
	          copyDeferred.resolve(copying);
	          return copying;
	        },
	        stream: pipe.outputStream,
	        done: copyDeferred
	      });
	
	      // Await the result of writing to the stream
	      copyDeferred.promise.then(() => pipe.outputStream.close(), this.close);
	    });
	
	    return sendDeferred.promise;
	  },
	
	  /**
	   * Close the transport.
	   */
	  close: function() {
	    this.emit("close");
	
	    if (this.other) {
	      // Remove the reference to the other endpoint before calling close(), to
	      // avoid infinite recursion.
	      let other = this.other;
	      this.other = null;
	      other.close();
	    }
	    if (this.hooks) {
	      try {
	        this.hooks.onClosed();
	      } catch(ex) {
	        console.error(ex);
	      }
	      this.hooks = null;
	    }
	  },
	
	  /**
	   * An empty method for emulating the DebuggerTransport API.
	   */
	  ready: function() {},
	
	  /**
	   * Helper function that makes an object fully immutable.
	   */
	  _deepFreeze: function(object) {
	    Object.freeze(object);
	    for (let prop in object) {
	      // Freeze the properties that are objects, not on the prototype, and not
	      // already frozen. Note that this might leave an unfrozen reference
	      // somewhere in the object if there is an already frozen object containing
	      // an unfrozen object.
	      if (object.hasOwnProperty(prop) && typeof object === "object" &&
	          !Object.isFrozen(object)) {
	        this._deepFreeze(o[prop]);
	      }
	    }
	  }
	};
	
	exports.LocalDebuggerTransport = LocalDebuggerTransport;
	
	/**
	 * A transport for the debugging protocol that uses nsIMessageSenders to
	 * exchange packets with servers running in child processes.
	 *
	 * In the parent process, |sender| should be the nsIMessageSender for the
	 * child process. In a child process, |sender| should be the child process
	 * message manager, which sends packets to the parent.
	 *
	 * |prefix| is a string included in the message names, to distinguish
	 * multiple servers running in the same child process.
	 *
	 * This transport exchanges messages named 'debug:<prefix>:packet', where
	 * <prefix> is |prefix|, whose data is the protocol packet.
	 */
	function ChildDebuggerTransport(sender, prefix) {
	  EventEmitter.decorate(this);
	
	  this._sender = sender.QueryInterface(Ci.nsIMessageSender);
	  this._messageName = "debug:" + prefix + ":packet";
	}
	
	/*
	 * To avoid confusion, we use 'message' to mean something that
	 * nsIMessageSender conveys, and 'packet' to mean a remote debugging
	 * protocol packet.
	 */
	ChildDebuggerTransport.prototype = {
	  constructor: ChildDebuggerTransport,
	
	  hooks: null,
	
	  ready: function () {
	    this._sender.addMessageListener(this._messageName, this);
	  },
	
	  close: function () {
	    this._sender.removeMessageListener(this._messageName, this);
	    this.emit("onClosed");
	    this.hooks.onClosed();
	  },
	
	  receiveMessage: function ({data}) {
	    this.emit("onPacket", data);
	    this.hooks.onPacket(data);
	  },
	
	  send: function (packet) {
	    this.emit("send", packet);
	    this._sender.sendAsyncMessage(this._messageName, packet);
	  },
	
	  startBulkSend: function() {
	    throw new Error("Can't send bulk data to child processes.");
	  }
	};
	
	exports.ChildDebuggerTransport = ChildDebuggerTransport;
	
	// WorkerDebuggerTransport is defined differently depending on whether we are
	// on the main thread or a worker thread. In the former case, we are required
	// by the devtools loader, and isWorker will be false. Otherwise, we are
	// required by the worker loader, and isWorker will be true.
	//
	// Each worker debugger supports only a single connection to the main thread.
	// However, its theoretically possible for multiple servers to connect to the
	// same worker. Consequently, each transport has a connection id, to allow
	// messages from multiple connections to be multiplexed on a single channel.
	
	if (typeof WorkerGlobalScope === 'undefined') { // i.e. not in a worker
	  (function () { // Main thread
	    /**
	     * A transport that uses a WorkerDebugger to send packets from the main
	     * thread to a worker thread.
	     */
	    function WorkerDebuggerTransport(dbg, id) {
	      this._dbg = dbg;
	      this._id = id;
	      this.onMessage = this._onMessage.bind(this);
	    }
	
	    WorkerDebuggerTransport.prototype = {
	      constructor: WorkerDebuggerTransport,
	
	      ready: function () {
	        this._dbg.addListener(this);
	      },
	
	      close: function () {
	        this._dbg.removeListener(this);
	        if (this.hooks) {
	          this.hooks.onClosed();
	        }
	      },
	
	      send: function (packet) {
	        this._dbg.postMessage(JSON.stringify({
	          type: "message",
	          id: this._id,
	          message: packet
	        }));
	      },
	
	      startBulkSend: function () {
	        throw new Error("Can't send bulk data from worker threads!");
	      },
	
	      _onMessage: function (message) {
	        let packet = JSON.parse(message);
	        if (packet.type !== "message" || packet.id !== this._id) {
	          return;
	        }
	
	        if (this.hooks) {
	          this.hooks.onPacket(packet.message);
	        }
	      }
	    };
	
	    exports.WorkerDebuggerTransport = WorkerDebuggerTransport;
	  }).call(this);
	} else {
	  (function () { // Worker thread
	    /*
	     * A transport that uses a WorkerDebuggerGlobalScope to send packets from a
	     * worker thread to the main thread.
	     */
	    function WorkerDebuggerTransport(scope, id) {
	      this._scope = scope;
	      this._id = id;
	      this._onMessage = this._onMessage.bind(this);
	    }
	
	    WorkerDebuggerTransport.prototype = {
	      constructor: WorkerDebuggerTransport,
	
	      ready: function () {
	        this._scope.addEventListener("message", this._onMessage);
	      },
	
	      close: function () {
	        this._scope.removeEventListener("message", this._onMessage);
	        if (this.hooks) {
	          this.hooks.onClosed();
	        }
	      },
	
	      send: function (packet) {
	        this._scope.postMessage(JSON.stringify({
	          type: "message",
	          id: this._id,
	          message: packet
	        }));
	      },
	
	      startBulkSend: function () {
	        throw new Error("Can't send bulk data from worker threads!");
	      },
	
	      _onMessage: function (event) {
	        let packet = JSON.parse(event.data);
	        if (packet.type !== "message" || packet.id !== this._id) {
	          return;
	        }
	
	        if (this.hooks) {
	          this.hooks.onPacket(packet.message);
	        }
	      }
	    };
	
	    exports.WorkerDebuggerTransport = WorkerDebuggerTransport;
	  }).call(this);
	}


/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	/* General utilities used throughout devtools. */
	var { Ci, Cu, Cc, components } = __webpack_require__(259);
	const { Services } = __webpack_require__(28);
	var promise = __webpack_require__(264);
	
	const { FileUtils } = __webpack_require__(267);
	
	/**
	 * Turn the error |aError| into a string, without fail.
	 */
	exports.safeErrorString = function safeErrorString(aError) {
	  try {
	    let errorString = aError.toString();
	    if (typeof errorString == "string") {
	      // Attempt to attach a stack to |errorString|. If it throws an error, or
	      // isn't a string, don't use it.
	      try {
	        if (aError.stack) {
	          let stack = aError.stack.toString();
	          if (typeof stack == "string") {
	            errorString += "\nStack: " + stack;
	          }
	        }
	      } catch (ee) { }
	
	      // Append additional line and column number information to the output,
	      // since it might not be part of the stringified error.
	      if (typeof aError.lineNumber == "number" && typeof aError.columnNumber == "number") {
	        errorString += "Line: " + aError.lineNumber + ", column: " + aError.columnNumber;
	      }
	
	      return errorString;
	    }
	  } catch (ee) { }
	
	  // We failed to find a good error description, so do the next best thing.
	  return Object.prototype.toString.call(aError);
	};
	
	/**
	 * Report that |aWho| threw an exception, |aException|.
	 */
	exports.reportException = function reportException(aWho, aException) {
	  let msg = aWho + " threw an exception: " + exports.safeErrorString(aException);
	
	  console.log(msg);
	
	//  if (Cu && console.error) {
	//    /*
	//     * Note that the xpcshell test harness registers an observer for
	//     * console messages, so when we're running tests, this will cause
	//     * the test to quit.
	//     */
	//    console.error(msg);
	//  }
	};
	
	/**
	 * Given a handler function that may throw, return an infallible handler
	 * function that calls the fallible handler, and logs any exceptions it
	 * throws.
	 *
	 * @param aHandler function
	 *      A handler function, which may throw.
	 * @param aName string
	 *      A name for aHandler, for use in error messages. If omitted, we use
	 *      aHandler.name.
	 *
	 * (SpiderMonkey does generate good names for anonymous functions, but we
	 * don't have a way to get at them from JavaScript at the moment.)
	 */
	exports.makeInfallible = function makeInfallible(aHandler, aName) {
	  if (!aName)
	    aName = aHandler.name;
	
	  return function(/* arguments */) {
	    // try {
	    return aHandler.apply(this, arguments);
	    // } catch (ex) {
	    //   let who = "Handler function";
	    //   if (aName) {
	    //     who += " " + aName;
	    //   }
	    //   return exports.reportException(who, ex);
	    // }
	  };
	};
	
	/**
	 * Waits for the next tick in the event loop to execute a callback.
	 */
	exports.executeSoon = function executeSoon(aFn) {
	  setTimeout(aFn, 0);
	};
	
	/**
	 * Waits for the next tick in the event loop.
	 *
	 * @return Promise
	 *         A promise that is resolved after the next tick in the event loop.
	 */
	exports.waitForTick = function waitForTick() {
	  let deferred = promise.defer();
	  exports.executeSoon(deferred.resolve);
	  return deferred.promise;
	};
	
	/**
	 * Waits for the specified amount of time to pass.
	 *
	 * @param number aDelay
	 *        The amount of time to wait, in milliseconds.
	 * @return Promise
	 *         A promise that is resolved after the specified amount of time passes.
	 */
	exports.waitForTime = function waitForTime(aDelay) {
	  let deferred = promise.defer();
	  setTimeout(deferred.resolve, aDelay);
	  return deferred.promise;
	};
	
	/**
	 * Like Array.prototype.forEach, but doesn't cause jankiness when iterating over
	 * very large arrays by yielding to the browser and continuing execution on the
	 * next tick.
	 *
	 * @param Array aArray
	 *        The array being iterated over.
	 * @param Function aFn
	 *        The function called on each item in the array. If a promise is
	 *        returned by this function, iterating over the array will be paused
	 *        until the respective promise is resolved.
	 * @returns Promise
	 *          A promise that is resolved once the whole array has been iterated
	 *          over, and all promises returned by the aFn callback are resolved.
	 */
	exports.yieldingEach = function yieldingEach(aArray, aFn) {
	  const deferred = promise.defer();
	
	  let i = 0;
	  let len = aArray.length;
	  let outstanding = [deferred.promise];
	
	  (function loop() {
	    const start = Date.now();
	
	    while (i < len) {
	      // Don't block the main thread for longer than 16 ms at a time. To
	      // maintain 60fps, you have to render every frame in at least 16ms; we
	      // aren't including time spent in non-JS here, but this is Good
	      // Enough(tm).
	      if (Date.now() - start > 16) {
	        exports.executeSoon(loop);
	        return;
	      }
	
	      try {
	        outstanding.push(aFn(aArray[i], i++));
	      } catch (e) {
	        deferred.reject(e);
	        return;
	      }
	    }
	
	    deferred.resolve();
	  }());
	
	  return promise.all(outstanding);
	};
	
	/**
	 * Like XPCOMUtils.defineLazyGetter, but with a |this| sensitive getter that
	 * allows the lazy getter to be defined on a prototype and work correctly with
	 * instances.
	 *
	 * @param Object aObject
	 *        The prototype object to define the lazy getter on.
	 * @param String aKey
	 *        The key to define the lazy getter on.
	 * @param Function aCallback
	 *        The callback that will be called to determine the value. Will be
	 *        called with the |this| value of the current instance.
	 */
	exports.defineLazyPrototypeGetter =
	function defineLazyPrototypeGetter(aObject, aKey, aCallback) {
	  Object.defineProperty(aObject, aKey, {
	    configurable: true,
	    get: function() {
	      const value = aCallback.call(this);
	
	      Object.defineProperty(this, aKey, {
	        configurable: true,
	        writable: true,
	        value: value
	      });
	
	      return value;
	    }
	  });
	};
	
	/**
	 * Safely get the property value from a Debugger.Object for a given key. Walks
	 * the prototype chain until the property is found.
	 *
	 * @param Debugger.Object aObject
	 *        The Debugger.Object to get the value from.
	 * @param String aKey
	 *        The key to look for.
	 * @return Any
	 */
	exports.getProperty = function getProperty(aObj, aKey) {
	  let root = aObj;
	  try {
	    do {
	      const desc = aObj.getOwnPropertyDescriptor(aKey);
	      if (desc) {
	        if ("value" in desc) {
	          return desc.value;
	        }
	        // Call the getter if it's safe.
	        return exports.hasSafeGetter(desc) ? desc.get.call(root).return : undefined;
	      }
	      aObj = aObj.proto;
	    } while (aObj);
	  } catch (e) {
	    // If anything goes wrong report the error and return undefined.
	    exports.reportException("getProperty", e);
	  }
	  return undefined;
	};
	
	/**
	 * Determines if a descriptor has a getter which doesn't call into JavaScript.
	 *
	 * @param Object aDesc
	 *        The descriptor to check for a safe getter.
	 * @return Boolean
	 *         Whether a safe getter was found.
	 */
	exports.hasSafeGetter = function hasSafeGetter(aDesc) {
	  // Scripted functions that are CCWs will not appear scripted until after
	  // unwrapping.
	  try {
	    let fn = aDesc.get.unwrap();
	    return fn && fn.callable && fn.class == "Function" && fn.script === undefined;
	  } catch (e) {
	    // Avoid exception 'Object in compartment marked as invisible to Debugger'
	    return false;
	  }
	};
	
	/**
	 * Check if it is safe to read properties and execute methods from the given JS
	 * object. Safety is defined as being protected from unintended code execution
	 * from content scripts (or cross-compartment code).
	 *
	 * See bugs 945920 and 946752 for discussion.
	 *
	 * @type Object aObj
	 *       The object to check.
	 * @return Boolean
	 *         True if it is safe to read properties from aObj, or false otherwise.
	 */
	exports.isSafeJSObject = function isSafeJSObject(aObj) {
	  // If we are running on a worker thread, Cu is not available. In this case,
	  // we always return false, just to be on the safe side.
	  if (isWorker) {
	    return false;
	  }
	
	  if (Cu.getGlobalForObject(aObj) ==
	      Cu.getGlobalForObject(exports.isSafeJSObject)) {
	    return true; // aObj is not a cross-compartment wrapper.
	  }
	
	  let principal = Cu.getObjectPrincipal(aObj);
	  if (Services.scriptSecurityManager.isSystemPrincipal(principal)) {
	    return true; // allow chrome objects
	  }
	
	  return Cu.isXrayWrapper(aObj);
	};
	
	exports.dumpn = function dumpn(str) {
	  if (exports.dumpn.wantLogging) {
	    console.log("DBG-SERVER: " + str + "\n");
	  }
	};
	
	// We want wantLogging to be writable. The exports object is frozen by the
	// loader, so define it on dumpn instead.
	exports.dumpn.wantLogging = false;
	
	/**
	 * A verbose logger for low-level tracing.
	 */
	exports.dumpv = function(msg) {
	  if (exports.dumpv.wantVerbose) {
	    exports.dumpn(msg);
	  }
	};
	
	// We want wantLogging to be writable. The exports object is frozen by the
	// loader, so define it on dumpn instead.
	exports.dumpv.wantVerbose = false;
	
	/**
	 * Utility function for updating an object with the properties of
	 * other objects.
	 *
	 * @param aTarget Object
	 *        The object being updated.
	 * @param aNewAttrs Object
	 *        The rest params are objects to update aTarget with. You
	 *        can pass as many as you like.
	 */
	exports.update = function update(aTarget, ...aArgs) {
	  for (let attrs of aArgs) {
	    for (let key in attrs) {
	      let desc = Object.getOwnPropertyDescriptor(attrs, key);
	
	      if (desc) {
	        Object.defineProperty(aTarget, key, desc);
	      }
	    }
	  }
	
	  return aTarget;
	};
	
	/**
	 * Utility function for getting the values from an object as an array
	 *
	 * @param aObject Object
	 *        The object to iterate over
	 */
	exports.values = function values(aObject) {
	  return Object.keys(aObject).map(k => aObject[k]);
	};
	
	/**
	 * Defines a getter on a specified object that will be created upon first use.
	 *
	 * @param aObject
	 *        The object to define the lazy getter on.
	 * @param aName
	 *        The name of the getter to define on aObject.
	 * @param aLambda
	 *        A function that returns what the getter should return.  This will
	 *        only ever be called once.
	 */
	exports.defineLazyGetter = function defineLazyGetter(aObject, aName, aLambda) {
	  Object.defineProperty(aObject, aName, {
	    get: function() {
	      delete aObject[aName];
	      return aObject[aName] = aLambda.apply(aObject);
	    },
	    configurable: true,
	    enumerable: true
	  });
	};
	
	// DEPRECATED: use DevToolsUtils.assert(condition, message) instead!
	let haveLoggedDeprecationMessage = false;
	exports.dbg_assert = function dbg_assert(cond, e) {
	  if (!haveLoggedDeprecationMessage) {
	    haveLoggedDeprecationMessage = true;
	    const deprecationMessage = "DevToolsUtils.dbg_assert is deprecated! Use DevToolsUtils.assert instead!"
	          + Error().stack;
	    console.log(deprecationMessage);
	    if (typeof console === "object" && console && console.warn) {
	      console.warn(deprecationMessage);
	    }
	  }
	
	  if (!cond) {
	    return e;
	  }
	};
	
	const { AppConstants } = __webpack_require__(268);
	
	/**
	 * No operation. The empty function.
	 */
	exports.noop = function() { };
	
	function reallyAssert(condition, message) {
	  if (!condition) {
	    const err = new Error("Assertion failure: " + message);
	    exports.reportException("DevToolsUtils.assert", err);
	    throw err;
	  }
	}
	
	/**
	 * DevToolsUtils.assert(condition, message)
	 *
	 * @param Boolean condition
	 * @param String message
	 *
	 * Assertions are enabled when any of the following are true:
	 *   - This is a DEBUG_JS_MODULES build
	 *   - This is a DEBUG build
	 *   - DevToolsUtils.testing is set to true
	 *
	 * If assertions are enabled, then `condition` is checked and if false-y, the
	 * assertion failure is logged and then an error is thrown.
	 *
	 * If assertions are not enabled, then this function is a no-op.
	 *
	 * This is an improvement over `dbg_assert`, which doesn't actually cause any
	 * fatal behavior, and is therefore much easier to accidentally ignore.
	 */
	Object.defineProperty(exports, "assert", {
	  get: () => (AppConstants.DEBUG || AppConstants.DEBUG_JS_MODULES || this.testing)
	    ? reallyAssert
	    : exports.noop,
	});
	
	/**
	 * Defines a getter on a specified object for a module.  The module will not
	 * be imported until first use.
	 *
	 * @param aObject
	 *        The object to define the lazy getter on.
	 * @param aName
	 *        The name of the getter to define on aObject for the module.
	 * @param aResource
	 *        The URL used to obtain the module.
	 * @param aSymbol
	 *        The name of the symbol exported by the module.
	 *        This parameter is optional and defaults to aName.
	 */
	exports.defineLazyModuleGetter = function defineLazyModuleGetter(aObject, aName,
	                                                                 aResource,
	                                                                 aSymbol)
	{
	  this.defineLazyGetter(aObject, aName, function XPCU_moduleLambda() {
	    var temp = {};
	    Cu.import(aResource, temp);
	    return temp[aSymbol || aName];
	  });
	};
	
	const { NetUtil } = __webpack_require__(269);
	
	const { TextDecoder, OS } = __webpack_require__(270);
	
	const NetworkHelper = __webpack_require__(271);
	
	/**
	 * Performs a request to load the desired URL and returns a promise.
	 *
	 * @param aURL String
	 *        The URL we will request.
	 * @param aOptions Object
	 *        An object with the following optional properties:
	 *        - loadFromCache: if false, will bypass the cache and
	 *          always load fresh from the network (default: true)
	 *        - policy: the nsIContentPolicy type to apply when fetching the URL
	 *        - window: the window to get the loadGroup from
	 *        - charset: the charset to use if the channel doesn't provide one
	 * @returns Promise that resolves with an object with the following members on
	 *          success:
	 *           - content: the document at that URL, as a string,
	 *           - contentType: the content type of the document
	 *
	 *          If an error occurs, the promise is rejected with that error.
	 *
	 * XXX: It may be better to use nsITraceableChannel to get to the sources
	 * without relying on caching when we can (not for eval, etc.):
	 * http://www.softwareishard.com/blog/firebug/nsitraceablechannel-intercept-http-traffic/
	 */
	function mainThreadFetch(aURL, aOptions = { loadFromCache: true,
	                                          policy: Ci.nsIContentPolicy.TYPE_OTHER,
	                                          window: null,
	                                          charset: null }) {
	  // Create a channel.
	  let url = aURL.split(" -> ").pop();
	  let channel;
	  try {
	    channel = newChannelForURL(url, aOptions);
	  } catch (ex) {
	    return promise.reject(ex);
	  }
	
	  // Set the channel options.
	  channel.loadFlags = aOptions.loadFromCache
	    ? channel.LOAD_FROM_CACHE
	    : channel.LOAD_BYPASS_CACHE;
	
	  if (aOptions.window) {
	    // Respect private browsing.
	    channel.loadGroup = aOptions.window.QueryInterface(Ci.nsIInterfaceRequestor)
	                          .getInterface(Ci.nsIWebNavigation)
	                          .QueryInterface(Ci.nsIDocumentLoader)
	                          .loadGroup;
	  }
	
	  let deferred = promise.defer();
	  let onResponse = (stream, status, request) => {
	    if (!components.isSuccessCode(status)) {
	      deferred.reject(new Error(`Failed to fetch ${url}. Code ${status}.`));
	      return;
	    }
	
	    try {
	      // We cannot use NetUtil to do the charset conversion as if charset
	      // information is not available and our default guess is wrong the method
	      // might fail and we lose the stream data. This means we can't fall back
	      // to using the locale default encoding (bug 1181345).
	
	      // Read and decode the data according to the locale default encoding.
	      let available = stream.available();
	      let source = NetUtil.readInputStreamToString(stream, available);
	      stream.close();
	
	      // If the channel or the caller has correct charset information, the
	      // content will be decoded correctly. If we have to fall back to UTF-8 and
	      // the guess is wrong, the conversion fails and convertToUnicode returns
	      // the input unmodified. Essentially we try to decode the data as UTF-8
	      // and if that fails, we use the locale specific default encoding. This is
	      // the best we can do if the source does not provide charset info.
	      let charset = channel.contentCharset || aOptions.charset || "UTF-8";
	      let unicodeSource = NetworkHelper.convertToUnicode(source, charset);
	
	      deferred.resolve({
	        content: unicodeSource,
	        contentType: request.contentType
	      });
	    } catch (ex) {
	      let uri = request.originalURI;
	      if (ex.name === "NS_BASE_STREAM_CLOSED" && uri instanceof Ci.nsIFileURL) {
	        // Empty files cause NS_BASE_STREAM_CLOSED exception. Use OS.File to
	        // differentiate between empty files and other errors (bug 1170864).
	        // This can be removed when bug 982654 is fixed.
	
	        uri.QueryInterface(Ci.nsIFileURL);
	        let result = OS.File.read(uri.file.path).then(bytes => {
	          // Convert the bytearray to a String.
	          let decoder = new TextDecoder();
	          let content = decoder.decode(bytes);
	
	          // We can't detect the contentType without opening a channel
	          // and that failed already. This is the best we can do here.
	          return {
	            content,
	            contentType: "text/plain"
	          };
	        });
	
	        deferred.resolve(result);
	      } else {
	        deferred.reject(ex);
	      }
	    }
	  };
	
	  // Open the channel
	  try {
	    NetUtil.asyncFetch(channel, onResponse);
	  } catch (ex) {
	    return promise.reject(ex);
	  }
	
	  return deferred.promise;
	}
	
	/**
	 * Opens a channel for given URL. Tries a bit harder than NetUtil.newChannel.
	 *
	 * @param {String} url - The URL to open a channel for.
	 * @param {Object} options - The options object passed to @method fetch.
	 * @return {nsIChannel} - The newly created channel. Throws on failure.
	 */
	function newChannelForURL(url, { policy }) {
	  let channelOptions = {
	    contentPolicyType: policy,
	    loadUsingSystemPrincipal: true,
	    uri: url
	  };
	
	  try {
	    return NetUtil.newChannel(channelOptions);
	  } catch (e) {
	    // In the xpcshell tests, the script url is the absolute path of the test
	    // file, which will make a malformed URI error be thrown. Add the file
	    // scheme to see if it helps.
	    channelOptions.uri = "file://" + url;
	
	    return NetUtil.newChannel(channelOptions);
	  }
	}
	
	// Fetch is defined differently depending on whether we are on the main thread
	// or a worker thread.
	if (typeof WorkerGlobalScope === "undefined") { // i.e. not in a worker
	  exports.fetch = mainThreadFetch;
	} else {
	  // Services is not available in worker threads, nor is there any other way
	  // to fetch a URL. We need to enlist the help from the main thread here, by
	  // issuing an rpc request, to fetch the URL on our behalf.
	  exports.fetch = function(url, options) {
	    return rpc("fetch", url, options);
	  };
	}
	
	/**
	 * Returns a promise that is resolved or rejected when all promises have settled
	 * (resolved or rejected).
	 *
	 * This differs from Promise.all, which will reject immediately after the first
	 * rejection, instead of waiting for the remaining promises to settle.
	 *
	 * @param values
	 *        Iterable of promises that may be pending, resolved, or rejected. When
	 *        when all promises have settled (resolved or rejected), the returned
	 *        promise will be resolved or rejected as well.
	 *
	 * @return A new promise that is fulfilled when all values have settled
	 *         (resolved or rejected). Its resolution value will be an array of all
	 *         resolved values in the given order, or undefined if values is an
	 *         empty array. The reject reason will be forwarded from the first
	 *         promise in the list of given promises to be rejected.
	 */
	exports.settleAll = values => {
	  if (values === null || typeof (values[Symbol.iterator]) != "function") {
	    throw new Error("settleAll() expects an iterable.");
	  }
	
	  let deferred = promise.defer();
	
	  values = Array.isArray(values) ? values : [...values];
	  let countdown = values.length;
	  let resolutionValues = new Array(countdown);
	  let rejectionValue;
	  let rejectionOccurred = false;
	
	  if (!countdown) {
	    deferred.resolve(resolutionValues);
	    return deferred.promise;
	  }
	
	  function checkForCompletion() {
	    if (--countdown > 0) {
	      return;
	    }
	    if (!rejectionOccurred) {
	      deferred.resolve(resolutionValues);
	    } else {
	      deferred.reject(rejectionValue);
	    }
	  }
	
	  for (let i = 0; i < values.length; i++) {
	    let index = i;
	    let value = values[i];
	    let resolver = result => {
	      resolutionValues[index] = result;
	      checkForCompletion();
	    };
	    let rejecter = error => {
	      if (!rejectionOccurred) {
	        rejectionValue = error;
	        rejectionOccurred = true;
	      }
	      checkForCompletion();
	    };
	
	    if (value && typeof (value.then) == "function") {
	      value.then(resolver, rejecter);
	    } else {
	      // Given value is not a promise, forward it as a resolution value.
	      resolver(value);
	    }
	  }
	
	  return deferred.promise;
	};
	
	/**
	 * When the testing flag is set, various behaviors may be altered from
	 * production mode, typically to enable easier testing or enhanced debugging.
	 */
	var testing = false;
	Object.defineProperty(exports, "testing", {
	  get: function() {
	    return testing;
	  },
	  set: function(state) {
	    testing = state;
	  }
	});
	
	/**
	 * Open the file at the given path for reading.
	 *
	 * @param {String} filePath
	 *
	 * @returns Promise<nsIInputStream>
	 */
	exports.openFileStream = function(filePath) {
	  return new Promise((resolve, reject) => {
	    const uri = NetUtil.newURI(new FileUtils.File(filePath));
	    NetUtil.asyncFetch(
	      { uri, loadUsingSystemPrincipal: true },
	      (stream, result) => {
	        if (!components.isSuccessCode(result)) {
	          reject(new Error(`Could not open "${filePath}": result = ${result}`));
	          return;
	        }
	
	        resolve(stream);
	      }
	    );
	  });
	};
	
	exports.isGenerator = function(fn) {
	  if (typeof fn !== "function") {
	    return false;
	  }
	  let proto = Object.getPrototypeOf(fn);
	  if (!proto) {
	    return false;
	  }
	  let ctor = proto.constructor;
	  if (!ctor) {
	    return false;
	  }
	  return ctor.name == "GeneratorFunction";
	};
	
	exports.isPromise = function(p) {
	  return p && typeof p.then === "function";
	};
	
	/**
	 * Return true if `thing` is a SavedFrame, false otherwise.
	 */
	exports.isSavedFrame = function(thing) {
	  return Object.prototype.toString.call(thing) === "[object SavedFrame]";
	};


/***/ },
/* 267 */
/***/ function(module, exports) {

	/*
	 * A sham for https://dxr.mozilla.org/mozilla-central/source/toolkit/modules/FileUtils.jsm
	 */


/***/ },
/* 268 */
/***/ function(module, exports) {

	/*
	 * A sham for https://dxr.mozilla.org/mozilla-central/source/toolkit/modules/AppConstants.jsm
	 */
	
	module.exports = { AppConstants: {} };


/***/ },
/* 269 */
/***/ function(module, exports) {

	/*
	 * A sham for https://dxr.mozilla.org/mozilla-central/source/netwerk/base/NetUtil.jsm
	 */


/***/ },
/* 270 */
/***/ function(module, exports) {

	/*
	 * A sham for https://dxr.mozilla.org/mozilla-central/source/toolkit/components/osfile/osfile.jsm
	 */


/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	/* vim:set ts=2 sw=2 sts=2 et: */
	/*
	 * Software License Agreement (BSD License)
	 *
	 * Copyright (c) 2007, Parakey Inc.
	 * All rights reserved.
	 *
	 * Redistribution and use of this software in source and binary forms, with or without modification,
	 * are permitted provided that the following conditions are met:
	 *
	 * * Redistributions of source code must retain the above
	 *   copyright notice, this list of conditions and the
	 *   following disclaimer.
	 *
	 * * Redistributions in binary form must reproduce the above
	 *   copyright notice, this list of conditions and the
	 *   following disclaimer in the documentation and/or other
	 *   materials provided with the distribution.
	 *
	 * * Neither the name of Parakey Inc. nor the names of its
	 *   contributors may be used to endorse or promote products
	 *   derived from this software without specific prior
	 *   written permission of Parakey Inc.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
	 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
	 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
	 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
	 * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
	 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
	
	/*
	 * Creator:
	 *  Joe Hewitt
	 * Contributors
	 *  John J. Barton (IBM Almaden)
	 *  Jan Odvarko (Mozilla Corp.)
	 *  Max Stepanov (Aptana Inc.)
	 *  Rob Campbell (Mozilla Corp.)
	 *  Hans Hillen (Paciello Group, Mozilla)
	 *  Curtis Bartley (Mozilla Corp.)
	 *  Mike Collins (IBM Almaden)
	 *  Kevin Decker
	 *  Mike Ratcliffe (Comartis AG)
	 *  Hernan Rodríguez Colmeiro
	 *  Austin Andrews
	 *  Christoph Dorn
	 *  Steven Roussey (AppCenter Inc, Network54)
	 *  Mihai Sucan (Mozilla Corp.)
	 */
	
	"use strict";
	
	const {components, Cc, Ci, Cu} = __webpack_require__(259);
	const { NetUtil } = __webpack_require__(269);
	const DevToolsUtils = __webpack_require__(266);
	
	// The cache used in the `nsIURL` function.
	const gNSURLStore = new Map();
	
	/**
	 * Helper object for networking stuff.
	 *
	 * Most of the following functions have been taken from the Firebug source. They
	 * have been modified to match the Firefox coding rules.
	 */
	var NetworkHelper = {
	  /**
	   * Converts aText with a given aCharset to unicode.
	   *
	   * @param string aText
	   *        Text to convert.
	   * @param string aCharset
	   *        Charset to convert the text to.
	   * @returns string
	   *          Converted text.
	   */
	  convertToUnicode: function NH_convertToUnicode(aText, aCharset)
	  {
	    let conv = Cc("@mozilla.org/intl/scriptableunicodeconverter").
	               createInstance(Ci.nsIScriptableUnicodeConverter);
	    try {
	      conv.charset = aCharset || "UTF-8";
	      return conv.ConvertToUnicode(aText);
	    }
	    catch (ex) {
	      return aText;
	    }
	  },
	
	  /**
	   * Reads all available bytes from aStream and converts them to aCharset.
	   *
	   * @param nsIInputStream aStream
	   * @param string aCharset
	   * @returns string
	   *          UTF-16 encoded string based on the content of aStream and aCharset.
	   */
	  readAndConvertFromStream: function NH_readAndConvertFromStream(aStream, aCharset)
	  {
	    let text = null;
	    try {
	      text = NetUtil.readInputStreamToString(aStream, aStream.available())
	      return this.convertToUnicode(text, aCharset);
	    }
	    catch (err) {
	      return text;
	    }
	  },
	
	   /**
	   * Reads the posted text from aRequest.
	   *
	   * @param nsIHttpChannel aRequest
	   * @param string aCharset
	   *        The content document charset, used when reading the POSTed data.
	   * @returns string or null
	   *          Returns the posted string if it was possible to read from aRequest
	   *          otherwise null.
	   */
	  readPostTextFromRequest: function NH_readPostTextFromRequest(aRequest, aCharset)
	  {
	    if (aRequest instanceof Ci.nsIUploadChannel) {
	      let iStream = aRequest.uploadStream;
	
	      let isSeekableStream = false;
	      if (iStream instanceof Ci.nsISeekableStream) {
	        isSeekableStream = true;
	      }
	
	      let prevOffset;
	      if (isSeekableStream) {
	        prevOffset = iStream.tell();
	        iStream.seek(Ci.nsISeekableStream.NS_SEEK_SET, 0);
	      }
	
	      // Read data from the stream.
	      let text = this.readAndConvertFromStream(iStream, aCharset);
	
	      // Seek locks the file, so seek to the beginning only if necko hasn't
	      // read it yet, since necko doesn't seek to 0 before reading (at lest
	      // not till 459384 is fixed).
	      if (isSeekableStream && prevOffset == 0) {
	        iStream.seek(Ci.nsISeekableStream.NS_SEEK_SET, 0);
	      }
	      return text;
	    }
	    return null;
	  },
	
	  /**
	   * Reads the posted text from the page's cache.
	   *
	   * @param nsIDocShell aDocShell
	   * @param string aCharset
	   * @returns string or null
	   *          Returns the posted string if it was possible to read from
	   *          aDocShell otherwise null.
	   */
	  readPostTextFromPage: function NH_readPostTextFromPage(aDocShell, aCharset)
	  {
	    let webNav = aDocShell.QueryInterface(Ci.nsIWebNavigation);
	    return this.readPostTextFromPageViaWebNav(webNav, aCharset);
	  },
	
	  /**
	   * Reads the posted text from the page's cache, given an nsIWebNavigation
	   * object.
	   *
	   * @param nsIWebNavigation aWebNav
	   * @param string aCharset
	   * @returns string or null
	   *          Returns the posted string if it was possible to read from
	   *          aWebNav, otherwise null.
	   */
	  readPostTextFromPageViaWebNav:
	  function NH_readPostTextFromPageViaWebNav(aWebNav, aCharset)
	  {
	    if (aWebNav instanceof Ci.nsIWebPageDescriptor) {
	      let descriptor = aWebNav.currentDescriptor;
	
	      if (descriptor instanceof Ci.nsISHEntry && descriptor.postData &&
	          descriptor instanceof Ci.nsISeekableStream) {
	        descriptor.seek(NS_SEEK_SET, 0);
	
	        return this.readAndConvertFromStream(descriptor, aCharset);
	      }
	    }
	    return null;
	  },
	
	  /**
	   * Gets the web appId that is associated with aRequest.
	   *
	   * @param nsIHttpChannel aRequest
	   * @returns number|null
	   *          The appId for the given request, if available.
	   */
	  getAppIdForRequest: function NH_getAppIdForRequest(aRequest)
	  {
	    try {
	      return this.getRequestLoadContext(aRequest).appId;
	    } catch (ex) {
	      // request loadContent is not always available.
	    }
	    return null;
	  },
	
	  /**
	   * Gets the topFrameElement that is associated with aRequest. This
	   * works in single-process and multiprocess contexts. It may cross
	   * the content/chrome boundary.
	   *
	   * @param nsIHttpChannel aRequest
	   * @returns nsIDOMElement|null
	   *          The top frame element for the given request.
	   */
	  getTopFrameForRequest: function NH_getTopFrameForRequest(aRequest)
	  {
	    try {
	      return this.getRequestLoadContext(aRequest).topFrameElement;
	    } catch (ex) {
	      // request loadContent is not always available.
	    }
	    return null;
	  },
	
	  /**
	   * Gets the nsIDOMWindow that is associated with aRequest.
	   *
	   * @param nsIHttpChannel aRequest
	   * @returns nsIDOMWindow or null
	   */
	  getWindowForRequest: function NH_getWindowForRequest(aRequest)
	  {
	    try {
	      return this.getRequestLoadContext(aRequest).associatedWindow;
	    } catch (ex) {
	      // TODO: bug 802246 - getWindowForRequest() throws on b2g: there is no
	      // associatedWindow property.
	    }
	    return null;
	  },
	
	  /**
	   * Gets the nsILoadContext that is associated with aRequest.
	   *
	   * @param nsIHttpChannel aRequest
	   * @returns nsILoadContext or null
	   */
	  getRequestLoadContext: function NH_getRequestLoadContext(aRequest)
	  {
	    try {
	      return aRequest.notificationCallbacks.getInterface(Ci.nsILoadContext);
	    } catch (ex) { }
	
	    try {
	      return aRequest.loadGroup.notificationCallbacks.getInterface(Ci.nsILoadContext);
	    } catch (ex) { }
	
	    return null;
	  },
	
	  /**
	   * Determines whether the request has been made for the top level document.
	   *
	   * @param nsIHttpChannel aRequest
	   * @returns Boolean True if the request represents the top level document.
	   */
	  isTopLevelLoad: function(aRequest)
	  {
	    if (aRequest instanceof Ci.nsIChannel) {
	      let loadInfo = aRequest.loadInfo;
	      if (loadInfo && loadInfo.parentOuterWindowID == loadInfo.outerWindowID) {
	        return (aRequest.loadFlags & Ci.nsIChannel.LOAD_DOCUMENT_URI);
	      }
	    }
	
	    return false;
	  },
	
	  /**
	   * Loads the content of aUrl from the cache.
	   *
	   * @param string aUrl
	   *        URL to load the cached content for.
	   * @param string aCharset
	   *        Assumed charset of the cached content. Used if there is no charset
	   *        on the channel directly.
	   * @param function aCallback
	   *        Callback that is called with the loaded cached content if available
	   *        or null if something failed while getting the cached content.
	   */
	  loadFromCache: function NH_loadFromCache(aUrl, aCharset, aCallback)
	  {
	    let channel = NetUtil.newChannel({uri: aUrl, loadUsingSystemPrincipal: true});
	
	    // Ensure that we only read from the cache and not the server.
	    channel.loadFlags = Ci.nsIRequest.LOAD_FROM_CACHE |
	      Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE |
	      Ci.nsICachingChannel.LOAD_BYPASS_LOCAL_CACHE_IF_BUSY;
	
	    NetUtil.asyncFetch(
	      channel,
	      (aInputStream, aStatusCode, aRequest) => {
	        if (!components.isSuccessCode(aStatusCode)) {
	          aCallback(null);
	          return;
	        }
	
	        // Try to get the encoding from the channel. If there is none, then use
	        // the passed assumed aCharset.
	        let aChannel = aRequest.QueryInterface(Ci.nsIChannel);
	        let contentCharset = aChannel.contentCharset || aCharset;
	
	        // Read the content of the stream using contentCharset as encoding.
	        aCallback(this.readAndConvertFromStream(aInputStream, contentCharset));
	      });
	  },
	
	  /**
	   * Parse a raw Cookie header value.
	   *
	   * @param string aHeader
	   *        The raw Cookie header value.
	   * @return array
	   *         Array holding an object for each cookie. Each object holds the
	   *         following properties: name and value.
	   */
	  parseCookieHeader: function NH_parseCookieHeader(aHeader)
	  {
	    let cookies = aHeader.split(";");
	    let result = [];
	
	    cookies.forEach(function(aCookie) {
	      let equal = aCookie.indexOf("=");
	      let name = aCookie.substr(0, equal);
	      let value = aCookie.substr(equal + 1);
	      result.push({name: unescape(name.trim()),
	                   value: unescape(value.trim())});
	    });
	
	    return result;
	  },
	
	  /**
	   * Parse a raw Set-Cookie header value.
	   *
	   * @param string aHeader
	   *        The raw Set-Cookie header value.
	   * @return array
	   *         Array holding an object for each cookie. Each object holds the
	   *         following properties: name, value, secure (boolean), httpOnly
	   *         (boolean), path, domain and expires (ISO date string).
	   */
	  parseSetCookieHeader: function NH_parseSetCookieHeader(aHeader)
	  {
	    let rawCookies = aHeader.split(/\r\n|\n|\r/);
	    let cookies = [];
	
	    rawCookies.forEach(function(aCookie) {
	      let equal = aCookie.indexOf("=");
	      let name = unescape(aCookie.substr(0, equal).trim());
	      let parts = aCookie.substr(equal + 1).split(";");
	      let value = unescape(parts.shift().trim());
	
	      let cookie = {name: name, value: value};
	
	      parts.forEach(function(aPart) {
	        let part = aPart.trim();
	        if (part.toLowerCase() == "secure") {
	          cookie.secure = true;
	        }
	        else if (part.toLowerCase() == "httponly") {
	          cookie.httpOnly = true;
	        }
	        else if (part.indexOf("=") > -1) {
	          let pair = part.split("=");
	          pair[0] = pair[0].toLowerCase();
	          if (pair[0] == "path" || pair[0] == "domain") {
	            cookie[pair[0]] = pair[1];
	          }
	          else if (pair[0] == "expires") {
	            try {
	              pair[1] = pair[1].replace(/-/g, ' ');
	              cookie.expires = new Date(pair[1]).toISOString();
	            }
	            catch (ex) { }
	          }
	        }
	      });
	
	      cookies.push(cookie);
	    });
	
	    return cookies;
	  },
	
	  // This is a list of all the mime category maps jviereck could find in the
	  // firebug code base.
	  mimeCategoryMap: {
	    "text/plain": "txt",
	    "text/html": "html",
	    "text/xml": "xml",
	    "text/xsl": "txt",
	    "text/xul": "txt",
	    "text/css": "css",
	    "text/sgml": "txt",
	    "text/rtf": "txt",
	    "text/x-setext": "txt",
	    "text/richtext": "txt",
	    "text/javascript": "js",
	    "text/jscript": "txt",
	    "text/tab-separated-values": "txt",
	    "text/rdf": "txt",
	    "text/xif": "txt",
	    "text/ecmascript": "js",
	    "text/vnd.curl": "txt",
	    "text/x-json": "json",
	    "text/x-js": "txt",
	    "text/js": "txt",
	    "text/vbscript": "txt",
	    "view-source": "txt",
	    "view-fragment": "txt",
	    "application/xml": "xml",
	    "application/xhtml+xml": "xml",
	    "application/atom+xml": "xml",
	    "application/rss+xml": "xml",
	    "application/vnd.mozilla.maybe.feed": "xml",
	    "application/vnd.mozilla.xul+xml": "xml",
	    "application/javascript": "js",
	    "application/x-javascript": "js",
	    "application/x-httpd-php": "txt",
	    "application/rdf+xml": "xml",
	    "application/ecmascript": "js",
	    "application/http-index-format": "txt",
	    "application/json": "json",
	    "application/x-js": "txt",
	    "multipart/mixed": "txt",
	    "multipart/x-mixed-replace": "txt",
	    "image/svg+xml": "svg",
	    "application/octet-stream": "bin",
	    "image/jpeg": "image",
	    "image/jpg": "image",
	    "image/gif": "image",
	    "image/png": "image",
	    "image/bmp": "image",
	    "application/x-shockwave-flash": "flash",
	    "video/x-flv": "flash",
	    "audio/mpeg3": "media",
	    "audio/x-mpeg-3": "media",
	    "video/mpeg": "media",
	    "video/x-mpeg": "media",
	    "audio/ogg": "media",
	    "application/ogg": "media",
	    "application/x-ogg": "media",
	    "application/x-midi": "media",
	    "audio/midi": "media",
	    "audio/x-mid": "media",
	    "audio/x-midi": "media",
	    "music/crescendo": "media",
	    "audio/wav": "media",
	    "audio/x-wav": "media",
	    "text/json": "json",
	    "application/x-json": "json",
	    "application/json-rpc": "json",
	    "application/x-web-app-manifest+json": "json",
	    "application/manifest+json": "json"
	  },
	
	  /**
	   * Check if the given MIME type is a text-only MIME type.
	   *
	   * @param string aMimeType
	   * @return boolean
	   */
	  isTextMimeType: function NH_isTextMimeType(aMimeType)
	  {
	    if (aMimeType.indexOf("text/") == 0) {
	      return true;
	    }
	
	    // XML and JSON often come with custom MIME types, so in addition to the
	    // standard "application/xml" and "application/json", we also look for
	    // variants like "application/x-bigcorp+xml". For JSON we allow "+json" and
	    // "-json" as suffixes.
	    if (/^application\/\w+(?:[\.-]\w+)*(?:\+xml|[-+]json)$/.test(aMimeType)) {
	      return true;
	    }
	
	    let category = this.mimeCategoryMap[aMimeType] || null;
	    switch (category) {
	      case "txt":
	      case "js":
	      case "json":
	      case "css":
	      case "html":
	      case "svg":
	      case "xml":
	        return true;
	
	      default:
	        return false;
	    }
	  },
	
	  /**
	   * Takes a securityInfo object of nsIRequest, the nsIRequest itself and
	   * extracts security information from them.
	   *
	   * @param object securityInfo
	   *        The securityInfo object of a request. If null channel is assumed
	   *        to be insecure.
	   * @param object httpActivity
	   *        The httpActivity object for the request with at least members
	   *        { private, hostname }.
	   *
	   * @return object
	   *         Returns an object containing following members:
	   *          - state: The security of the connection used to fetch this
	   *                   request. Has one of following string values:
	   *                    * "insecure": the connection was not secure (only http)
	   *                    * "weak": the connection has minor security issues
	   *                    * "broken": secure connection failed (e.g. expired cert)
	   *                    * "secure": the connection was properly secured.
	   *          If state == broken:
	   *            - errorMessage: full error message from nsITransportSecurityInfo.
	   *          If state == secure:
	   *            - protocolVersion: one of TLSv1, TLSv1.1, TLSv1.2.
	   *            - cipherSuite: the cipher suite used in this connection.
	   *            - cert: information about certificate used in this connection.
	   *                    See parseCertificateInfo for the contents.
	   *            - hsts: true if host uses Strict Transport Security, false otherwise
	   *            - hpkp: true if host uses Public Key Pinning, false otherwise
	   *          If state == weak: Same as state == secure and
	   *            - weaknessReasons: list of reasons that cause the request to be
	   *                               considered weak. See getReasonsForWeakness.
	   */
	  parseSecurityInfo: function NH_parseSecurityInfo(securityInfo, httpActivity) {
	    const info = {
	      state: "insecure",
	    };
	
	    // The request did not contain any security info.
	    if (!securityInfo) {
	      return info;
	    }
	
	    /**
	     * Different scenarios to consider here and how they are handled:
	     * - request is HTTP, the connection is not secure
	     *   => securityInfo is null
	     *      => state === "insecure"
	     *
	     * - request is HTTPS, the connection is secure
	     *   => .securityState has STATE_IS_SECURE flag
	     *      => state === "secure"
	     *
	     * - request is HTTPS, the connection has security issues
	     *   => .securityState has STATE_IS_INSECURE flag
	     *   => .errorCode is an NSS error code.
	     *      => state === "broken"
	     *
	     * - request is HTTPS, the connection was terminated before the security
	     *   could be validated
	     *   => .securityState has STATE_IS_INSECURE flag
	     *   => .errorCode is NOT an NSS error code.
	     *   => .errorMessage is not available.
	     *      => state === "insecure"
	     *
	     * - request is HTTPS but it uses a weak cipher or old protocol, see
	     *   https://hg.mozilla.org/mozilla-central/annotate/def6ed9d1c1a/
	     *   security/manager/ssl/nsNSSCallbacks.cpp#l1233
	     * - request is mixed content (which makes no sense whatsoever)
	     *   => .securityState has STATE_IS_BROKEN flag
	     *   => .errorCode is NOT an NSS error code
	     *   => .errorMessage is not available
	     *      => state === "weak"
	     */
	
	    securityInfo.QueryInterface(Ci.nsITransportSecurityInfo);
	    securityInfo.QueryInterface(Ci.nsISSLStatusProvider);
	
	    const wpl = Ci.nsIWebProgressListener;
	    const NSSErrorsService = Cc['@mozilla.org/nss_errors_service;1']
	                               .getService(Ci.nsINSSErrorsService);
	    const SSLStatus = securityInfo.SSLStatus;
	    if (!NSSErrorsService.isNSSErrorCode(securityInfo.errorCode)) {
	      const state = securityInfo.securityState;
	
	      let uri = null;
	      if (httpActivity.channel && httpActivity.channel.URI) {
	        uri = httpActivity.channel.URI;
	      }
	      if (uri && !uri.schemeIs("https") && !uri.schemeIs("wss")) {
	        // it is not enough to look at the transport security info - schemes other than
	        // https and wss are subject to downgrade/etc at the scheme level and should
	        // always be considered insecure
	        info.state = "insecure";
	      } else if (state & wpl.STATE_IS_SECURE) {
	        // The connection is secure if the scheme is sufficient
	        info.state = "secure";
	      } else if (state & wpl.STATE_IS_BROKEN) {
	        // The connection is not secure, there was no error but there's some
	        // minor security issues.
	        info.state = "weak";
	        info.weaknessReasons = this.getReasonsForWeakness(state);
	      } else if (state & wpl.STATE_IS_INSECURE) {
	        // This was most likely an https request that was aborted before
	        // validation. Return info as info.state = insecure.
	        return info;
	      } else {
	        DevToolsUtils.reportException("NetworkHelper.parseSecurityInfo",
	          "Security state " + state + " has no known STATE_IS_* flags.");
	        return info;
	      }
	
	      // Cipher suite.
	      info.cipherSuite = SSLStatus.cipherName;
	
	      // Protocol version.
	      info.protocolVersion = this.formatSecurityProtocol(SSLStatus.protocolVersion);
	
	      // Certificate.
	      info.cert = this.parseCertificateInfo(SSLStatus.serverCert);
	
	      // HSTS and HPKP if available.
	      if (httpActivity.hostname) {
	        const sss = Cc("@mozilla.org/ssservice;1")
	                      .getService(Ci.nsISiteSecurityService);
	
	
	        // SiteSecurityService uses different storage if the channel is
	        // private. Thus we must give isSecureHost correct flags or we
	        // might get incorrect results.
	        let flags = (httpActivity.private) ?
	                      Ci.nsISocketProvider.NO_PERMANENT_STORAGE : 0;
	
	        let host = httpActivity.hostname;
	
	        info.hsts = sss.isSecureHost(sss.HEADER_HSTS, host, flags);
	        info.hpkp = sss.isSecureHost(sss.HEADER_HPKP, host, flags);
	      } else {
	        DevToolsUtils.reportException("NetworkHelper.parseSecurityInfo",
	          "Could not get HSTS/HPKP status as hostname is not available.");
	        info.hsts = false;
	        info.hpkp = false;
	      }
	
	    } else {
	      // The connection failed.
	      info.state = "broken";
	      info.errorMessage = securityInfo.errorMessage;
	    }
	
	    return info;
	  },
	
	  /**
	   * Takes an nsIX509Cert and returns an object with certificate information.
	   *
	   * @param nsIX509Cert cert
	   *        The certificate to extract the information from.
	   * @return object
	   *         An object with following format:
	   *           {
	   *             subject: { commonName, organization, organizationalUnit },
	   *             issuer: { commonName, organization, organizationUnit },
	   *             validity: { start, end },
	   *             fingerprint: { sha1, sha256 }
	   *           }
	   */
	  parseCertificateInfo: function NH_parseCertifificateInfo(cert) {
	    let info = {};
	    if (cert) {
	      info.subject = {
	        commonName: cert.commonName,
	        organization: cert.organization,
	        organizationalUnit: cert.organizationalUnit,
	      };
	
	      info.issuer = {
	        commonName: cert.issuerCommonName,
	        organization: cert.issuerOrganization,
	        organizationUnit: cert.issuerOrganizationUnit,
	      };
	
	      info.validity = {
	        start: cert.validity.notBeforeLocalDay,
	        end: cert.validity.notAfterLocalDay,
	      };
	
	      info.fingerprint = {
	        sha1: cert.sha1Fingerprint,
	        sha256: cert.sha256Fingerprint,
	      };
	    } else {
	      DevToolsUtils.reportException("NetworkHelper.parseCertificateInfo",
	        "Secure connection established without certificate.");
	    }
	
	    return info;
	  },
	
	  /**
	   * Takes protocolVersion of SSLStatus object and returns human readable
	   * description.
	   *
	   * @param Number version
	   *        One of nsISSLStatus version constants.
	   * @return string
	   *         One of TLSv1, TLSv1.1, TLSv1.2 if @param version is valid,
	   *         Unknown otherwise.
	   */
	  formatSecurityProtocol: function NH_formatSecurityProtocol(version) {
	    switch (version) {
	      case Ci.nsISSLStatus.TLS_VERSION_1:
	        return "TLSv1";
	      case Ci.nsISSLStatus.TLS_VERSION_1_1:
	        return "TLSv1.1";
	      case Ci.nsISSLStatus.TLS_VERSION_1_2:
	        return "TLSv1.2";
	      default:
	        DevToolsUtils.reportException("NetworkHelper.formatSecurityProtocol",
	          "protocolVersion " + version + " is unknown.");
	        return "Unknown";
	    }
	  },
	
	  /**
	   * Takes the securityState bitfield and returns reasons for weak connection
	   * as an array of strings.
	   *
	   * @param Number state
	   *        nsITransportSecurityInfo.securityState.
	   *
	   * @return Array[String]
	   *         List of weakness reasons. A subset of { cipher } where
	   *         * cipher: The cipher suite is consireded to be weak (RC4).
	   */
	  getReasonsForWeakness: function NH_getReasonsForWeakness(state) {
	    const wpl = Ci.nsIWebProgressListener;
	
	    // If there's non-fatal security issues the request has STATE_IS_BROKEN
	    // flag set. See https://hg.mozilla.org/mozilla-central/file/44344099d119
	    // /security/manager/ssl/nsNSSCallbacks.cpp#l1233
	    let reasons = [];
	
	    if (state & wpl.STATE_IS_BROKEN) {
	      let isCipher = state & wpl.STATE_USES_WEAK_CRYPTO;
	
	      if (isCipher) {
	        reasons.push("cipher");
	      }
	
	      if (!isCipher) {
	        DevToolsUtils.reportException("NetworkHelper.getReasonsForWeakness",
	          "STATE_IS_BROKEN without a known reason. Full state was: " + state);
	      }
	    }
	
	    return reasons;
	  },
	
	  /**
	   * Parse a url's query string into its components
	   *
	   * @param string aQueryString
	   *        The query part of a url
	   * @return array
	   *         Array of query params {name, value}
	   */
	  parseQueryString: function(aQueryString) {
	    // Make sure there's at least one param available.
	    // Be careful here, params don't necessarily need to have values, so
	    // no need to verify the existence of a "=".
	    if (!aQueryString) {
	      return;
	    }
	
	    // Turn the params string into an array containing { name: value } tuples.
	    let paramsArray = aQueryString.replace(/^[?&]/, "").split("&").map(e => {
	      let param = e.split("=");
	      return {
	        name: param[0] ? NetworkHelper.convertToUnicode(unescape(param[0])) : "",
	        value: param[1] ? NetworkHelper.convertToUnicode(unescape(param[1])) : ""
	      }});
	
	    return paramsArray;
	  },
	
	  /**
	   * Helper for getting an nsIURL instance out of a string.
	   */
	  nsIURL: function(aUrl, aStore = gNSURLStore) {
	    if (aStore.has(aUrl)) {
	      return aStore.get(aUrl);
	    }
	
	    var uri = Services.io.newURI(aUrl).QueryInterface(Ci.nsIURL);
	    aStore.set(aUrl, uri);
	    return uri;
	  }
	};
	
	for (let prop of Object.getOwnPropertyNames(NetworkHelper)) {
	  exports[prop] = NetworkHelper[prop];
	}


/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	const { Ci, Cc, Cr, CC } = __webpack_require__(259);
	const { Services } = __webpack_require__(28);
	const { dumpv } = __webpack_require__(266);
	const EventEmitter = __webpack_require__(258);
	const promise = __webpack_require__(264);
	
	const IOUtil = Cc("@mozilla.org/io-util;1").getService(Ci.nsIIOUtil);
	
	const ScriptableInputStream = CC("@mozilla.org/scriptableinputstream;1",
	          "nsIScriptableInputStream", "init");
	
	const BUFFER_SIZE = 0x8000;
	
	/**
	 * This helper function (and its companion object) are used by bulk senders and
	 * receivers to read and write data in and out of other streams.  Functions that
	 * make use of this tool are passed to callers when it is time to read or write
	 * bulk data.  It is highly recommended to use these copier functions instead of
	 * the stream directly because the copier enforces the agreed upon length.
	 * Since bulk mode reuses an existing stream, the sender and receiver must write
	 * and read exactly the agreed upon amount of data, or else the entire transport
	 * will be left in a invalid state.  Additionally, other methods of stream
	 * copying (such as NetUtil.asyncCopy) close the streams involved, which would
	 * terminate the debugging transport, and so it is avoided here.
	 *
	 * Overall, this *works*, but clearly the optimal solution would be able to just
	 * use the streams directly.  If it were possible to fully implement
	 * nsIInputStream / nsIOutputStream in JS, wrapper streams could be created to
	 * enforce the length and avoid closing, and consumers could use familiar stream
	 * utilities like NetUtil.asyncCopy.
	 *
	 * The function takes two async streams and copies a precise number of bytes
	 * from one to the other.  Copying begins immediately, but may complete at some
	 * future time depending on data size.  Use the returned promise to know when
	 * it's complete.
	 *
	 * @param input nsIAsyncInputStream
	 *        The stream to copy from.
	 * @param output nsIAsyncOutputStream
	 *        The stream to copy to.
	 * @param length Integer
	 *        The amount of data that needs to be copied.
	 * @return Promise
	 *         The promise is resolved when copying completes or rejected if any
	 *         (unexpected) errors occur.
	 */
	function copyStream(input, output, length) {
	  let copier = new StreamCopier(input, output, length);
	  return copier.copy();
	}
	
	function StreamCopier(input, output, length) {
	  EventEmitter.decorate(this);
	  this._id = StreamCopier._nextId++;
	  this.input = input;
	  // Save off the base output stream, since we know it's async as we've required
	  this.baseAsyncOutput = output;
	  if (IOUtil.outputStreamIsBuffered(output)) {
	    this.output = output;
	  } else {
	    this.output = Cc("@mozilla.org/network/buffered-output-stream;1")
	                  .createInstance(Ci.nsIBufferedOutputStream);
	    this.output.init(output, BUFFER_SIZE);
	  }
	  this._length = length;
	  this._amountLeft = length;
	  this._deferred = promise.defer();
	
	  this._copy = this._copy.bind(this);
	  this._flush = this._flush.bind(this);
	  this._destroy = this._destroy.bind(this);
	
	  // Copy promise's then method up to this object.
	  // Allows the copier to offer a promise interface for the simple succeed or
	  // fail scenarios, but also emit events (due to the EventEmitter) for other
	  // states, like progress.
	  this.then = this._deferred.promise.then.bind(this._deferred.promise);
	  this.then(this._destroy, this._destroy);
	
	  // Stream ready callback starts as |_copy|, but may switch to |_flush| at end
	  // if flushing would block the output stream.
	  this._streamReadyCallback = this._copy;
	}
	StreamCopier._nextId = 0;
	
	StreamCopier.prototype = {
	
	  copy: function() {
	    // Dispatch to the next tick so that it's possible to attach a progress
	    // event listener, even for extremely fast copies (like when testing).
	    Services.tm.currentThread.dispatch(() => {
	      try {
	        this._copy();
	      } catch (e) {
	        this._deferred.reject(e);
	      }
	    }, 0);
	    return this;
	  },
	
	  _copy: function() {
	    let bytesAvailable = this.input.available();
	    let amountToCopy = Math.min(bytesAvailable, this._amountLeft);
	    this._debug("Trying to copy: " + amountToCopy);
	
	    let bytesCopied;
	    try {
	      bytesCopied = this.output.writeFrom(this.input, amountToCopy);
	    } catch (e) {
	      if (e.result == Cr.NS_BASE_STREAM_WOULD_BLOCK) {
	        this._debug("Base stream would block, will retry");
	        this._debug("Waiting for output stream");
	        this.baseAsyncOutput.asyncWait(this, 0, 0, Services.tm.currentThread);
	        return;
	      } else {
	        throw e;
	      }
	    }
	
	    this._amountLeft -= bytesCopied;
	    this._debug("Copied: " + bytesCopied +
	                ", Left: " + this._amountLeft);
	    this._emitProgress();
	
	    if (this._amountLeft === 0) {
	      this._debug("Copy done!");
	      this._flush();
	      return;
	    }
	
	    this._debug("Waiting for input stream");
	    this.input.asyncWait(this, 0, 0, Services.tm.currentThread);
	  },
	
	  _emitProgress: function() {
	    this.emit("progress", {
	      bytesSent: this._length - this._amountLeft,
	      totalBytes: this._length
	    });
	  },
	
	  _flush: function() {
	    try {
	      this.output.flush();
	    } catch (e) {
	      if (e.result == Cr.NS_BASE_STREAM_WOULD_BLOCK ||
	          e.result == Cr.NS_ERROR_FAILURE) {
	        this._debug("Flush would block, will retry");
	        this._streamReadyCallback = this._flush;
	        this._debug("Waiting for output stream");
	        this.baseAsyncOutput.asyncWait(this, 0, 0, Services.tm.currentThread);
	        return;
	      } else {
	        throw e;
	      }
	    }
	    this._deferred.resolve();
	  },
	
	  _destroy: function() {
	    this._destroy = null;
	    this._copy = null;
	    this._flush = null;
	    this.input = null;
	    this.output = null;
	  },
	
	  // nsIInputStreamCallback
	  onInputStreamReady: function() {
	    this._streamReadyCallback();
	  },
	
	  // nsIOutputStreamCallback
	  onOutputStreamReady: function() {
	    this._streamReadyCallback();
	  },
	
	  _debug: function(msg) {
	    // Prefix logs with the copier ID, which makes logs much easier to
	    // understand when several copiers are running simultaneously
	    dumpv("Copier: " + this._id + " " + msg);
	  }
	
	};
	
	/**
	 * Read from a stream, one byte at a time, up to the next |delimiter|
	 * character, but stopping if we've read |count| without finding it.  Reading
	 * also terminates early if there are less than |count| bytes available on the
	 * stream.  In that case, we only read as many bytes as the stream currently has
	 * to offer.
	 * TODO: This implementation could be removed if bug 984651 is fixed, which
	 *       provides a native version of the same idea.
	 * @param stream nsIInputStream
	 *        The input stream to read from.
	 * @param delimiter string
	 *        The character we're trying to find.
	 * @param count integer
	 *        The max number of characters to read while searching.
	 * @return string
	 *         The data collected.  If the delimiter was found, this string will
	 *         end with it.
	 */
	function delimitedRead(stream, delimiter, count) {
	  dumpv("Starting delimited read for " + delimiter + " up to " +
	        count + " bytes");
	
	  let scriptableStream;
	  if (stream.readBytes) {
	    scriptableStream = stream;
	  } else {
	    scriptableStream = new ScriptableInputStream(stream);
	  }
	
	  let data = "";
	
	  // Don't exceed what's available on the stream
	  count = Math.min(count, stream.available());
	
	  if (count <= 0) {
	    return data;
	  }
	
	  let char;
	  while (char !== delimiter && count > 0) {
	    char = scriptableStream.readBytes(1);
	    count--;
	    data += char;
	  }
	
	  return data;
	}
	
	module.exports = {
	  copyStream: copyStream,
	  delimitedRead: delimitedRead
	};


/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	"use strict";
	
	/**
	 * Packets contain read / write functionality for the different packet types
	 * supported by the debugging protocol, so that a transport can focus on
	 * delivery and queue management without worrying too much about the specific
	 * packet types.
	 *
	 * They are intended to be "one use only", so a new packet should be
	 * instantiated for each incoming or outgoing packet.
	 *
	 * A complete Packet type should expose at least the following:
	 *   * read(stream, scriptableStream)
	 *     Called when the input stream has data to read
	 *   * write(stream)
	 *     Called when the output stream is ready to write
	 *   * get done()
	 *     Returns true once the packet is done being read / written
	 *   * destroy()
	 *     Called to clean up at the end of use
	 */
	
	const { Cc, Ci, Cu } = __webpack_require__(259);
	const DevToolsUtils = __webpack_require__(266);
	const { dumpn, dumpv } = DevToolsUtils;
	const StreamUtils = __webpack_require__(272);
	const promise = __webpack_require__(264);
	
	/*DevToolsUtils.defineLazyGetter(this, "unicodeConverter", () => {
	  const unicodeConverter = Cc("@mozilla.org/intl/scriptableunicodeconverter")
	                           .createInstance(Ci.nsIScriptableUnicodeConverter);
	  unicodeConverter.charset = "UTF-8";
	  return unicodeConverter;
	});*/
	const utf8 = __webpack_require__(274);
	
	// The transport's previous check ensured the header length did not exceed 20
	// characters.  Here, we opt for the somewhat smaller, but still large limit of
	// 1 TiB.
	const PACKET_LENGTH_MAX = Math.pow(2, 40);
	
	/**
	 * A generic Packet processing object (extended by two subtypes below).
	 */
	function Packet(transport) {
	  this._transport = transport;
	  this._length = 0;
	}
	
	/**
	 * Attempt to initialize a new Packet based on the incoming packet header we've
	 * received so far.  We try each of the types in succession, trying JSON packets
	 * first since they are much more common.
	 * @param header string
	 *        The packet header string to attempt parsing.
	 * @param transport DebuggerTransport
	 *        The transport instance that will own the packet.
	 * @return Packet
	 *         The parsed packet of the matching type, or null if no types matched.
	 */
	Packet.fromHeader = function(header, transport) {
	  return JSONPacket.fromHeader(header, transport) ||
	         BulkPacket.fromHeader(header, transport);
	};
	
	Packet.prototype = {
	
	  get length() {
	    return this._length;
	  },
	
	  set length(length) {
	    if (length > PACKET_LENGTH_MAX) {
	      throw Error("Packet length " + length + " exceeds the max length of " +
	                  PACKET_LENGTH_MAX);
	    }
	    this._length = length;
	  },
	
	  destroy: function() {
	    this._transport = null;
	  }
	
	};
	
	exports.Packet = Packet;
	
	/**
	 * With a JSON packet (the typical packet type sent via the transport), data is
	 * transferred as a JSON packet serialized into a string, with the string length
	 * prepended to the packet, followed by a colon ([length]:[packet]). The
	 * contents of the JSON packet are specified in the Remote Debugging Protocol
	 * specification.
	 * @param transport DebuggerTransport
	 *        The transport instance that will own the packet.
	 */
	function JSONPacket(transport) {
	  Packet.call(this, transport);
	  this._data = "";
	  this._done = false;
	}
	
	/**
	 * Attempt to initialize a new JSONPacket based on the incoming packet header
	 * we've received so far.
	 * @param header string
	 *        The packet header string to attempt parsing.
	 * @param transport DebuggerTransport
	 *        The transport instance that will own the packet.
	 * @return JSONPacket
	 *         The parsed packet, or null if it's not a match.
	 */
	JSONPacket.fromHeader = function(header, transport) {
	  let match = this.HEADER_PATTERN.exec(header);
	
	  if (!match) {
	    return null;
	  }
	
	  dumpv("Header matches JSON packet");
	  let packet = new JSONPacket(transport);
	  packet.length = +match[1];
	  return packet;
	};
	
	JSONPacket.HEADER_PATTERN = /^(\d+):$/;
	
	JSONPacket.prototype = Object.create(Packet.prototype);
	
	Object.defineProperty(JSONPacket.prototype, "object", {
	  /**
	   * Gets the object (not the serialized string) being read or written.
	   */
	  get: function() { return this._object; },
	
	  /**
	   * Sets the object to be sent when write() is called.
	   */
	  set: function(object) {
	    this._object = object;
	    let data = JSON.stringify(object);
	    this._data = data;
	    this.length = this._data.length;
	  }
	});
	
	JSONPacket.prototype.read = function(stream, scriptableStream) {
	  dumpv("Reading JSON packet");
	
	  // Read in more packet data.
	  this._readData(stream, scriptableStream);
	
	  if (!this.done) {
	    // Don't have a complete packet yet.
	    return;
	  }
	
	  let json = this._data;
	  try {
	    json = utf8.decode(json);
	    this._object = JSON.parse(json);
	  } catch(e) {
	    let msg = "Error parsing incoming packet: " + json + " (" + e +
	              " - " + e.stack + ")";
	    if (console.error) {
	      console.error(msg);
	    }
	    dumpn(msg);
	    return;
	  }
	
	  this._transport._onJSONObjectReady(this._object);
	}
	
	JSONPacket.prototype._readData = function(stream, scriptableStream) {
	  if (!scriptableStream) {
	    scriptableStream = stream;
	  }
	  if (dumpv.wantVerbose) {
	    dumpv("Reading JSON data: _l: " + this.length + " dL: " +
	          this._data.length + " sA: " + stream.available());
	  }
	  let bytesToRead = Math.min(this.length - this._data.length,
	                             stream.available());
	  this._data += scriptableStream.readBytes(bytesToRead);
	  this._done = this._data.length === this.length;
	}
	
	JSONPacket.prototype.write = function(stream) {
	  dumpv("Writing JSON packet");
	
	  if (this._outgoing === undefined) {
	    // Format the serialized packet to a buffer
	    this._outgoing = this.length + ":" + this._data;
	  }
	
	  let written = stream.write(this._outgoing, this._outgoing.length);
	  this._outgoing = this._outgoing.slice(written);
	  this._done = !this._outgoing.length;
	}
	
	Object.defineProperty(JSONPacket.prototype, "done", {
	  get: function() { return this._done; }
	});
	
	JSONPacket.prototype.toString = function() {
	  return JSON.stringify(this._object, null, 2);
	}
	
	exports.JSONPacket = JSONPacket;
	
	/**
	 * With a bulk packet, data is transferred by temporarily handing over the
	 * transport's input or output stream to the application layer for writing data
	 * directly.  This can be much faster for large data sets, and avoids various
	 * stages of copies and data duplication inherent in the JSON packet type.  The
	 * bulk packet looks like:
	 *
	 * bulk [actor] [type] [length]:[data]
	 *
	 * The interpretation of the data portion depends on the kind of actor and the
	 * packet's type.  See the Remote Debugging Protocol Stream Transport spec for
	 * more details.
	 * @param transport DebuggerTransport
	 *        The transport instance that will own the packet.
	 */
	function BulkPacket(transport) {
	  Packet.call(this, transport);
	  this._done = false;
	  this._readyForWriting = promise.defer();
	}
	
	/**
	 * Attempt to initialize a new BulkPacket based on the incoming packet header
	 * we've received so far.
	 * @param header string
	 *        The packet header string to attempt parsing.
	 * @param transport DebuggerTransport
	 *        The transport instance that will own the packet.
	 * @return BulkPacket
	 *         The parsed packet, or null if it's not a match.
	 */
	BulkPacket.fromHeader = function(header, transport) {
	  let match = this.HEADER_PATTERN.exec(header);
	
	  if (!match) {
	    return null;
	  }
	
	  dumpv("Header matches bulk packet");
	  let packet = new BulkPacket(transport);
	  packet.header = {
	    actor: match[1],
	    type: match[2],
	    length: +match[3]
	  };
	  return packet;
	};
	
	BulkPacket.HEADER_PATTERN = /^bulk ([^: ]+) ([^: ]+) (\d+):$/;
	
	BulkPacket.prototype = Object.create(Packet.prototype);
	
	BulkPacket.prototype.read = function(stream) {
	  dumpv("Reading bulk packet, handing off input stream");
	
	  // Temporarily pause monitoring of the input stream
	  this._transport.pauseIncoming();
	
	  let deferred = promise.defer();
	
	  this._transport._onBulkReadReady({
	    actor: this.actor,
	    type: this.type,
	    length: this.length,
	    copyTo: (output) => {
	      dumpv("CT length: " + this.length);
	      let copying = StreamUtils.copyStream(stream, output, this.length);
	      deferred.resolve(copying);
	      return copying;
	    },
	    stream: stream,
	    done: deferred
	  });
	
	  // Await the result of reading from the stream
	  deferred.promise.then(() => {
	    dumpv("onReadDone called, ending bulk mode");
	    this._done = true;
	    this._transport.resumeIncoming();
	  }, this._transport.close);
	
	  // Ensure this is only done once
	  this.read = () => {
	    throw new Error("Tried to read() a BulkPacket's stream multiple times.");
	  };
	}
	
	BulkPacket.prototype.write = function(stream) {
	  dumpv("Writing bulk packet");
	
	  if (this._outgoingHeader === undefined) {
	    dumpv("Serializing bulk packet header");
	    // Format the serialized packet header to a buffer
	    this._outgoingHeader = "bulk " + this.actor + " " + this.type + " " +
	                           this.length + ":";
	  }
	
	  // Write the header, or whatever's left of it to write.
	  if (this._outgoingHeader.length) {
	    dumpv("Writing bulk packet header");
	    let written = stream.write(this._outgoingHeader,
	                               this._outgoingHeader.length);
	    this._outgoingHeader = this._outgoingHeader.slice(written);
	    return;
	  }
	
	  dumpv("Handing off output stream");
	
	  // Temporarily pause the monitoring of the output stream
	  this._transport.pauseOutgoing();
	
	  let deferred = promise.defer();
	
	  this._readyForWriting.resolve({
	    copyFrom: (input) => {
	      dumpv("CF length: " + this.length);
	      let copying = StreamUtils.copyStream(input, stream, this.length);
	      deferred.resolve(copying);
	      return copying;
	    },
	    stream: stream,
	    done: deferred
	  });
	
	  // Await the result of writing to the stream
	  deferred.promise.then(() => {
	    dumpv("onWriteDone called, ending bulk mode");
	    this._done = true;
	    this._transport.resumeOutgoing();
	  }, this._transport.close);
	
	  // Ensure this is only done once
	  this.write = () => {
	    throw new Error("Tried to write() a BulkPacket's stream multiple times.");
	  };
	}
	
	Object.defineProperty(BulkPacket.prototype, "streamReadyForWriting", {
	  get: function() {
	    return this._readyForWriting.promise;
	  }
	});
	
	Object.defineProperty(BulkPacket.prototype, "header", {
	  get: function() {
	    return {
	      actor: this.actor,
	      type: this.type,
	      length: this.length
	    };
	  },
	
	  set: function(header) {
	    this.actor = header.actor;
	    this.type = header.type;
	    this.length = header.length;
	  },
	});
	
	Object.defineProperty(BulkPacket.prototype, "done", {
	  get: function() { return this._done; },
	});
	
	
	BulkPacket.prototype.toString = function() {
	  return "Bulk: " + JSON.stringify(this.header, null, 2);
	}
	
	exports.BulkPacket = BulkPacket;
	
	/**
	 * RawPacket is used to test the transport's error handling of malformed
	 * packets, by writing data directly onto the stream.
	 * @param transport DebuggerTransport
	 *        The transport instance that will own the packet.
	 * @param data string
	 *        The raw string to send out onto the stream.
	 */
	function RawPacket(transport, data) {
	  Packet.call(this, transport);
	  this._data = data;
	  this.length = data.length;
	  this._done = false;
	}
	
	RawPacket.prototype = Object.create(Packet.prototype);
	
	RawPacket.prototype.read = function(stream) {
	  // This hasn't yet been needed for testing.
	  throw Error("Not implmented.");
	}
	
	RawPacket.prototype.write = function(stream) {
	  let written = stream.write(this._data, this._data.length);
	  this._data = this._data.slice(written);
	  this._done = !this._data.length;
	}
	
	Object.defineProperty(RawPacket.prototype, "done", {
	  get: function() { return this._done; }
	});
	
	exports.RawPacket = RawPacket;


/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/utf8js v2.0.0 by @mathias */
	;(function(root) {
	
		// Detect free variables `exports`
		var freeExports = typeof exports == 'object' && exports;
	
		// Detect free variable `module`
		var freeModule = typeof module == 'object' && module &&
			module.exports == freeExports && module;
	
		// Detect free variable `global`, from Node.js or Browserified code,
		// and use it as `root`
		var freeGlobal = typeof global == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
			root = freeGlobal;
		}
	
		/*--------------------------------------------------------------------------*/
	
		var stringFromCharCode = String.fromCharCode;
	
		// Taken from https://mths.be/punycode
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			var value;
			var extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		// Taken from https://mths.be/punycode
		function ucs2encode(array) {
			var length = array.length;
			var index = -1;
			var value;
			var output = '';
			while (++index < length) {
				value = array[index];
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
			}
			return output;
		}
	
		function checkScalarValue(codePoint) {
			if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
				throw Error(
					'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
					' is not a scalar value'
				);
			}
		}
		/*--------------------------------------------------------------------------*/
	
		function createByte(codePoint, shift) {
			return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
		}
	
		function encodeCodePoint(codePoint) {
			if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
				return stringFromCharCode(codePoint);
			}
			var symbol = '';
			if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
				symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
			}
			else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
				checkScalarValue(codePoint);
				symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
				symbol += createByte(codePoint, 6);
			}
			else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
				symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
				symbol += createByte(codePoint, 12);
				symbol += createByte(codePoint, 6);
			}
			symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
			return symbol;
		}
	
		function utf8encode(string) {
			var codePoints = ucs2decode(string);
			var length = codePoints.length;
			var index = -1;
			var codePoint;
			var byteString = '';
			while (++index < length) {
				codePoint = codePoints[index];
				byteString += encodeCodePoint(codePoint);
			}
			return byteString;
		}
	
		/*--------------------------------------------------------------------------*/
	
		function readContinuationByte() {
			if (byteIndex >= byteCount) {
				throw Error('Invalid byte index');
			}
	
			var continuationByte = byteArray[byteIndex] & 0xFF;
			byteIndex++;
	
			if ((continuationByte & 0xC0) == 0x80) {
				return continuationByte & 0x3F;
			}
	
			// If we end up here, it’s not a continuation byte
			throw Error('Invalid continuation byte');
		}
	
		function decodeSymbol() {
			var byte1;
			var byte2;
			var byte3;
			var byte4;
			var codePoint;
	
			if (byteIndex > byteCount) {
				throw Error('Invalid byte index');
			}
	
			if (byteIndex == byteCount) {
				return false;
			}
	
			// Read first byte
			byte1 = byteArray[byteIndex] & 0xFF;
			byteIndex++;
	
			// 1-byte sequence (no continuation bytes)
			if ((byte1 & 0x80) == 0) {
				return byte1;
			}
	
			// 2-byte sequence
			if ((byte1 & 0xE0) == 0xC0) {
				var byte2 = readContinuationByte();
				codePoint = ((byte1 & 0x1F) << 6) | byte2;
				if (codePoint >= 0x80) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}
	
			// 3-byte sequence (may include unpaired surrogates)
			if ((byte1 & 0xF0) == 0xE0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
				if (codePoint >= 0x0800) {
					checkScalarValue(codePoint);
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}
	
			// 4-byte sequence
			if ((byte1 & 0xF8) == 0xF0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				byte4 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
					(byte3 << 0x06) | byte4;
				if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
					return codePoint;
				}
			}
	
			throw Error('Invalid UTF-8 detected');
		}
	
		var byteArray;
		var byteCount;
		var byteIndex;
		function utf8decode(byteString) {
			byteArray = ucs2decode(byteString);
			byteCount = byteArray.length;
			byteIndex = 0;
			var codePoints = [];
			var tmp;
			while ((tmp = decodeSymbol()) !== false) {
				codePoints.push(tmp);
			}
			return ucs2encode(codePoints);
		}
	
		/*--------------------------------------------------------------------------*/
	
		var utf8 = {
			'version': '2.0.0',
			'encode': utf8encode,
			'decode': utf8decode
		};
	
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return utf8;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}	else if (freeExports && !freeExports.nodeType) {
			if (freeModule) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = utf8;
			} else { // in Narwhal or RingoJS v0.7.0-
				var object = {};
				var hasOwnProperty = object.hasOwnProperty;
				for (var key in utf8) {
					hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.utf8 = utf8;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(51)(module), (function() { return this; }())))

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/utf8js v2.0.0 by @mathias */
	;(function(root) {
	
		// Detect free variables `exports`
		var freeExports = typeof exports == 'object' && exports;
	
		// Detect free variable `module`
		var freeModule = typeof module == 'object' && module &&
			module.exports == freeExports && module;
	
		// Detect free variable `global`, from Node.js or Browserified code,
		// and use it as `root`
		var freeGlobal = typeof global == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
			root = freeGlobal;
		}
	
		/*--------------------------------------------------------------------------*/
	
		var stringFromCharCode = String.fromCharCode;
	
		// Taken from https://mths.be/punycode
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			var value;
			var extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		// Taken from https://mths.be/punycode
		function ucs2encode(array) {
			var length = array.length;
			var index = -1;
			var value;
			var output = '';
			while (++index < length) {
				value = array[index];
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
			}
			return output;
		}
	
		function checkScalarValue(codePoint) {
			if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
				throw Error(
					'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
					' is not a scalar value'
				);
			}
		}
		/*--------------------------------------------------------------------------*/
	
		function createByte(codePoint, shift) {
			return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
		}
	
		function encodeCodePoint(codePoint) {
			if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
				return stringFromCharCode(codePoint);
			}
			var symbol = '';
			if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
				symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
			}
			else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
				checkScalarValue(codePoint);
				symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
				symbol += createByte(codePoint, 6);
			}
			else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
				symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
				symbol += createByte(codePoint, 12);
				symbol += createByte(codePoint, 6);
			}
			symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
			return symbol;
		}
	
		function utf8encode(string) {
			var codePoints = ucs2decode(string);
			var length = codePoints.length;
			var index = -1;
			var codePoint;
			var byteString = '';
			while (++index < length) {
				codePoint = codePoints[index];
				byteString += encodeCodePoint(codePoint);
			}
			return byteString;
		}
	
		/*--------------------------------------------------------------------------*/
	
		function readContinuationByte() {
			if (byteIndex >= byteCount) {
				throw Error('Invalid byte index');
			}
	
			var continuationByte = byteArray[byteIndex] & 0xFF;
			byteIndex++;
	
			if ((continuationByte & 0xC0) == 0x80) {
				return continuationByte & 0x3F;
			}
	
			// If we end up here, it’s not a continuation byte
			throw Error('Invalid continuation byte');
		}
	
		function decodeSymbol() {
			var byte1;
			var byte2;
			var byte3;
			var byte4;
			var codePoint;
	
			if (byteIndex > byteCount) {
				throw Error('Invalid byte index');
			}
	
			if (byteIndex == byteCount) {
				return false;
			}
	
			// Read first byte
			byte1 = byteArray[byteIndex] & 0xFF;
			byteIndex++;
	
			// 1-byte sequence (no continuation bytes)
			if ((byte1 & 0x80) == 0) {
				return byte1;
			}
	
			// 2-byte sequence
			if ((byte1 & 0xE0) == 0xC0) {
				var byte2 = readContinuationByte();
				codePoint = ((byte1 & 0x1F) << 6) | byte2;
				if (codePoint >= 0x80) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}
	
			// 3-byte sequence (may include unpaired surrogates)
			if ((byte1 & 0xF0) == 0xE0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
				if (codePoint >= 0x0800) {
					checkScalarValue(codePoint);
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}
	
			// 4-byte sequence
			if ((byte1 & 0xF8) == 0xF0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				byte4 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
					(byte3 << 0x06) | byte4;
				if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
					return codePoint;
				}
			}
	
			throw Error('Invalid UTF-8 detected');
		}
	
		var byteArray;
		var byteCount;
		var byteIndex;
		function utf8decode(byteString) {
			byteArray = ucs2decode(byteString);
			byteCount = byteArray.length;
			byteIndex = 0;
			var codePoints = [];
			var tmp;
			while ((tmp = decodeSymbol()) !== false) {
				codePoints.push(tmp);
			}
			return ucs2encode(codePoints);
		}
	
		/*--------------------------------------------------------------------------*/
	
		var utf8 = {
			'version': '2.0.0',
			'encode': utf8encode,
			'decode': utf8decode
		};
	
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return utf8;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}	else if (freeExports && !freeExports.nodeType) {
			if (freeModule) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = utf8;
			} else { // in Narwhal or RingoJS v0.7.0-
				var object = {};
				var hasOwnProperty = object.hasOwnProperty;
				for (var key in utf8) {
					hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.utf8 = utf8;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(51)(module), (function() { return this; }())))

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	const { Ci, Cu, components } = __webpack_require__(259);
	const { Services } = __webpack_require__(28);
	const DevToolsUtils = __webpack_require__(266);
	
	// WARNING I swapped the sync one for the async one here
	// const promise = require("resource://devtools/shared/deprecated-sync-thenables.js", {}).Promise;
	const promise = __webpack_require__(264);
	
	const events = __webpack_require__(277);
	const { WebConsoleClient } = __webpack_require__(279);
	/* const { DebuggerSocket } = require("../shared/security/socket");*/
	/* const Authentication = require("../shared/security/auth");*/
	
	const noop = () => {};
	
	/**
	 * TODO: Get rid of this API in favor of EventTarget (bug 1042642)
	 *
	 * Add simple event notification to a prototype object. Any object that has
	 * some use for event notifications or the observer pattern in general can be
	 * augmented with the necessary facilities by passing its prototype to this
	 * function.
	 *
	 * @param aProto object
	 *        The prototype object that will be modified.
	 */
	function eventSource(aProto) {
	  /**
	   * Add a listener to the event source for a given event.
	   *
	   * @param aName string
	   *        The event to listen for.
	   * @param aListener function
	   *        Called when the event is fired. If the same listener
	   *        is added more than once, it will be called once per
	   *        addListener call.
	   */
	  aProto.addListener = function(aName, aListener) {
	    if (typeof aListener != "function") {
	      throw TypeError("Listeners must be functions.");
	    }
	
	    if (!this._listeners) {
	      this._listeners = {};
	    }
	
	    this._getListeners(aName).push(aListener);
	  };
	
	  /**
	   * Add a listener to the event source for a given event. The
	   * listener will be removed after it is called for the first time.
	   *
	   * @param aName string
	   *        The event to listen for.
	   * @param aListener function
	   *        Called when the event is fired.
	   */
	  aProto.addOneTimeListener = function(aName, aListener) {
	    let l = (...args) => {
	      this.removeListener(aName, l);
	      aListener.apply(null, args);
	    };
	    this.addListener(aName, l);
	  };
	
	  /**
	   * Remove a listener from the event source previously added with
	   * addListener().
	   *
	   * @param aName string
	   *        The event name used during addListener to add the listener.
	   * @param aListener function
	   *        The callback to remove. If addListener was called multiple
	   *        times, all instances will be removed.
	   */
	  aProto.removeListener = function(aName, aListener) {
	    if (!this._listeners || (aListener && !this._listeners[aName])) {
	      return;
	    }
	
	    if (!aListener) {
	      this._listeners[aName] = [];
	    }
	    else {
	      this._listeners[aName] =
	        this._listeners[aName].filter(function(l) { return l != aListener; });
	    }
	  };
	
	  /**
	   * Returns the listeners for the specified event name. If none are defined it
	   * initializes an empty list and returns that.
	   *
	   * @param aName string
	   *        The event name.
	   */
	  aProto._getListeners = function(aName) {
	    if (aName in this._listeners) {
	      return this._listeners[aName];
	    }
	    this._listeners[aName] = [];
	    return this._listeners[aName];
	  };
	
	  /**
	   * Notify listeners of an event.
	   *
	   * @param aName string
	   *        The event to fire.
	   * @param arguments
	   *        All arguments will be passed along to the listeners,
	   *        including the name argument.
	   */
	  aProto.emit = function() {
	    if (!this._listeners) {
	      return;
	    }
	
	    let name = arguments[0];
	    let listeners = this._getListeners(name).slice(0);
	
	    for (let listener of listeners) {
	      try {
	        listener.apply(null, arguments);
	      } catch (e) {
	        // Prevent a bad listener from interfering with the others.
	        DevToolsUtils.reportException("notify event '" + name + "'", e);
	      }
	    }
	  };
	}
	
	/**
	 * Set of protocol messages that affect thread state, and the
	 * state the actor is in after each message.
	 */
	const ThreadStateTypes = {
	  "paused": "paused",
	  "resumed": "attached",
	  "detached": "detached"
	};
	
	/**
	 * Set of protocol messages that are sent by the server without a prior request
	 * by the client.
	 */
	const UnsolicitedNotifications = {
	  "consoleAPICall": "consoleAPICall",
	  "eventNotification": "eventNotification",
	  "fileActivity": "fileActivity",
	  "lastPrivateContextExited": "lastPrivateContextExited",
	  "logMessage": "logMessage",
	  "networkEvent": "networkEvent",
	  "networkEventUpdate": "networkEventUpdate",
	  "newGlobal": "newGlobal",
	  "newScript": "newScript",
	  "tabDetached": "tabDetached",
	  "tabListChanged": "tabListChanged",
	  "reflowActivity": "reflowActivity",
	  "addonListChanged": "addonListChanged",
	  "workerListChanged": "workerListChanged",
	  "serviceWorkerRegistrationListChanged": "serviceWorkerRegistrationList",
	  "tabNavigated": "tabNavigated",
	  "frameUpdate": "frameUpdate",
	  "pageError": "pageError",
	  "documentLoad": "documentLoad",
	  "enteredFrame": "enteredFrame",
	  "exitedFrame": "exitedFrame",
	  "appOpen": "appOpen",
	  "appClose": "appClose",
	  "appInstall": "appInstall",
	  "appUninstall": "appUninstall",
	  "evaluationResult": "evaluationResult",
	  "newSource": "newSource",
	  "updatedSource": "updatedSource",
	};
	
	/**
	 * Set of pause types that are sent by the server and not as an immediate
	 * response to a client request.
	 */
	const UnsolicitedPauses = {
	  "resumeLimit": "resumeLimit",
	  "debuggerStatement": "debuggerStatement",
	  "breakpoint": "breakpoint",
	  "DOMEvent": "DOMEvent",
	  "watchpoint": "watchpoint",
	  "exception": "exception"
	};
	
	/**
	 * Creates a client for the remote debugging protocol server. This client
	 * provides the means to communicate with the server and exchange the messages
	 * required by the protocol in a traditional JavaScript API.
	 */
	const DebuggerClient = exports.DebuggerClient = function(aTransport)
	{
	  this._transport = aTransport;
	  this._transport.hooks = this;
	
	  // Map actor ID to client instance for each actor type.
	  this._clients = new Map();
	
	  this._pendingRequests = new Map();
	  this._activeRequests = new Map();
	  this._eventsEnabled = true;
	
	  this.traits = {};
	
	  this.request = this.request.bind(this);
	  this.localTransport = this._transport.onOutputStreamReady === undefined;
	
	  /*
	   * As the first thing on the connection, expect a greeting packet from
	   * the connection's root actor.
	   */
	  this.mainRoot = null;
	  this.expectReply("root", (aPacket) => {
	    this.mainRoot = new RootClient(this, aPacket);
	    this.emit("connected", aPacket.applicationType, aPacket.traits);
	  });
	};
	
	/**
	 * A declarative helper for defining methods that send requests to the server.
	 *
	 * @param aPacketSkeleton
	 *        The form of the packet to send. Can specify fields to be filled from
	 *        the parameters by using the |args| function.
	 * @param telemetry
	 *        The unique suffix of the telemetry histogram id.
	 * @param before
	 *        The function to call before sending the packet. Is passed the packet,
	 *        and the return value is used as the new packet. The |this| context is
	 *        the instance of the client object we are defining a method for.
	 * @param after
	 *        The function to call after the response is received. It is passed the
	 *        response, and the return value is considered the new response that
	 *        will be passed to the callback. The |this| context is the instance of
	 *        the client object we are defining a method for.
	 * @return Request
	 *         The `Request` object that is a Promise object and resolves once
	 *         we receive the response. (See request method for more details)
	 */
	DebuggerClient.requester = function(aPacketSkeleton, config = {}) {
	  let { telemetry, before, after } = config;
	  return DevToolsUtils.makeInfallible(function(...args) {
	    let histogram, startTime;
	    if (telemetry) {
	      let transportType = this._transport.onOutputStreamReady === undefined
	        ? "LOCAL_"
	        : "REMOTE_";
	      let histogramId = "DEVTOOLS_DEBUGGER_RDP_"
	        + transportType + telemetry + "_MS";
	      histogram = Services.telemetry.getHistogramById(histogramId);
	      startTime = +new Date();
	    }
	    let outgoingPacket = {
	      to: aPacketSkeleton.to || this.actor
	    };
	
	    let maxPosition = -1;
	    for (let k of Object.keys(aPacketSkeleton)) {
	      if (aPacketSkeleton[k] instanceof DebuggerClient.Argument) {
	        let { position } = aPacketSkeleton[k];
	        outgoingPacket[k] = aPacketSkeleton[k].getArgument(args);
	        maxPosition = Math.max(position, maxPosition);
	      } else {
	        outgoingPacket[k] = aPacketSkeleton[k];
	      }
	    }
	
	    if (before) {
	      outgoingPacket = before.call(this, outgoingPacket);
	    }
	
	    return this.request(outgoingPacket, DevToolsUtils.makeInfallible((aResponse) => {
	      if (after) {
	        let { from } = aResponse;
	        aResponse = after.call(this, aResponse);
	        if (!aResponse.from) {
	          aResponse.from = from;
	        }
	      }
	
	      // The callback is always the last parameter.
	      let thisCallback = args[maxPosition + 1];
	      if (thisCallback) {
	        thisCallback(aResponse);
	      }
	
	      if (histogram) {
	        histogram.add(+new Date() - startTime);
	      }
	    }, "DebuggerClient.requester request callback"));
	  }, "DebuggerClient.requester");
	};
	
	function args(aPos) {
	  return new DebuggerClient.Argument(aPos);
	}
	
	DebuggerClient.Argument = function(aPosition) {
	  this.position = aPosition;
	};
	
	DebuggerClient.Argument.prototype.getArgument = function(aParams) {
	  if (!(this.position in aParams)) {
	    throw new Error("Bad index into params: " + this.position);
	  }
	  return aParams[this.position];
	};
	
	// Expose these to save callers the trouble of importing DebuggerSocket
	DebuggerClient.socketConnect = function(options) {
	  // Defined here instead of just copying the function to allow lazy-load
	  return DebuggerSocket.connect(options);
	};
	DevToolsUtils.defineLazyGetter(DebuggerClient, "Authenticators", () => {
	  return Authentication.Authenticators;
	});
	DevToolsUtils.defineLazyGetter(DebuggerClient, "AuthenticationResult", () => {
	  return Authentication.AuthenticationResult;
	});
	
	DebuggerClient.prototype = {
	  /**
	   * Connect to the server and start exchanging protocol messages.
	   *
	   * @param aOnConnected function
	   *        If specified, will be called when the greeting packet is
	   *        received from the debugging server.
	   *
	   * @return Promise
	   *         Resolves once connected with an array whose first element
	   *         is the application type, by default "browser", and the second
	   *         element is the traits object (help figure out the features
	   *         and behaviors of the server we connect to. See RootActor).
	   */
	  connect: function(aOnConnected) {
	    return Promise.race([
	      new Promise((resolve, reject) => {
	        this.emit("connect");
	
	        // Also emit the event on the |DebuggerClient| object (not on the instance),
	        // so it's possible to track all instances.
	        events.emit(DebuggerClient, "connect", this);
	
	        this.addOneTimeListener("connected", (aName, aApplicationType, aTraits) => {
	          this.traits = aTraits;
	          if (aOnConnected) {
	            aOnConnected(aApplicationType, aTraits);
	          }
	          resolve([aApplicationType, aTraits]);
	        });
	
	        this._transport.ready();
	      }),
	      new Promise((resolve, reject) => {
	        setTimeout(() => reject(new Error("Connect timeout error")), 6000);
	      })
	    ]);
	  },
	
	  /**
	   * Shut down communication with the debugging server.
	   *
	   * @param aOnClosed function
	   *        If specified, will be called when the debugging connection
	   *        has been closed.
	   */
	  close: function(aOnClosed) {
	    // Disable detach event notifications, because event handlers will be in a
	    // cleared scope by the time they run.
	    this._eventsEnabled = false;
	
	    let cleanup = () => {
	      this._transport.close();
	      this._transport = null;
	    };
	
	    // If the connection is already closed,
	    // there is no need to detach client
	    // as we won't be able to send any message.
	    if (this._closed) {
	      cleanup();
	      if (aOnClosed) {
	        aOnClosed();
	      }
	      return;
	    }
	
	    if (aOnClosed) {
	      this.addOneTimeListener("closed", function(aEvent) {
	        aOnClosed();
	      });
	    }
	
	    // Call each client's `detach` method by calling
	    // lastly registered ones first to give a chance
	    // to detach child clients first.
	    let clients = [...this._clients.values()];
	    this._clients.clear();
	    const detachClients = () => {
	      let client = clients.pop();
	      if (!client) {
	        // All clients detached.
	        cleanup();
	        return;
	      }
	      if (client.detach) {
	        client.detach(detachClients);
	        return;
	      }
	      detachClients();
	    };
	    detachClients();
	  },
	
	  /*
	   * This function exists only to preserve DebuggerClient's interface;
	   * new code should say 'client.mainRoot.listTabs()'.
	   */
	  listTabs: function(aOnResponse) { return this.mainRoot.listTabs(aOnResponse); },
	
	  /*
	   * This function exists only to preserve DebuggerClient's interface;
	   * new code should say 'client.mainRoot.listAddons()'.
	   */
	  listAddons: function(aOnResponse) { return this.mainRoot.listAddons(aOnResponse); },
	
	  getTab: function(aFilter) { return this.mainRoot.getTab(aFilter); },
	
	  /**
	   * Attach to a tab actor.
	   *
	   * @param string aTabActor
	   *        The actor ID for the tab to attach.
	   * @param function aOnResponse
	   *        Called with the response packet and a TabClient
	   *        (which will be undefined on error).
	   */
	  attachTab: function(aTabActor, aOnResponse = noop) {
	    if (this._clients.has(aTabActor)) {
	      let cachedTab = this._clients.get(aTabActor);
	      let cachedResponse = {
	        cacheDisabled: cachedTab.cacheDisabled,
	        javascriptEnabled: cachedTab.javascriptEnabled,
	        traits: cachedTab.traits,
	      };
	      DevToolsUtils.executeSoon(() => aOnResponse(cachedResponse, cachedTab));
	      return promise.resolve([cachedResponse, cachedTab]);
	    }
	
	    let packet = {
	      to: aTabActor,
	      type: "attach"
	    };
	    return this.request(packet).then(aResponse => {
	      let tabClient;
	      if (!aResponse.error) {
	        tabClient = new TabClient(this, aResponse);
	        this.registerClient(tabClient);
	      }
	      aOnResponse(aResponse, tabClient);
	      return [aResponse, tabClient];
	    });
	  },
	
	  attachWorker: function DC_attachWorker(aWorkerActor, aOnResponse = noop) {
	    let workerClient = this._clients.get(aWorkerActor);
	    if (workerClient !== undefined) {
	      let response = {
	        from: workerClient.actor,
	        type: "attached",
	        url: workerClient.url
	      };
	      DevToolsUtils.executeSoon(() => aOnResponse(response, workerClient));
	      return promise.resolve([response, workerClient]);
	    }
	
	    return this.request({ to: aWorkerActor, type: "attach" }).then(aResponse => {
	      if (aResponse.error) {
	        aOnResponse(aResponse, null);
	        return [aResponse, null];
	      }
	
	      let workerClient = new WorkerClient(this, aResponse);
	      this.registerClient(workerClient);
	      aOnResponse(aResponse, workerClient);
	      return [aResponse, workerClient];
	    });
	  },
	
	  /**
	   * Attach to an addon actor.
	   *
	   * @param string aAddonActor
	   *        The actor ID for the addon to attach.
	   * @param function aOnResponse
	   *        Called with the response packet and a AddonClient
	   *        (which will be undefined on error).
	   */
	  attachAddon: function DC_attachAddon(aAddonActor, aOnResponse = noop) {
	    let packet = {
	      to: aAddonActor,
	      type: "attach"
	    };
	    return this.request(packet).then(aResponse => {
	      let addonClient;
	      if (!aResponse.error) {
	        addonClient = new AddonClient(this, aAddonActor);
	        this.registerClient(addonClient);
	        this.activeAddon = addonClient;
	      }
	      aOnResponse(aResponse, addonClient);
	      return [aResponse, addonClient];
	    });
	  },
	
	  /**
	   * Attach to a Web Console actor.
	   *
	   * @param string aConsoleActor
	   *        The ID for the console actor to attach to.
	   * @param array aListeners
	   *        The console listeners you want to start.
	   * @param function aOnResponse
	   *        Called with the response packet and a WebConsoleClient
	   *        instance (which will be undefined on error).
	   */
	  attachConsole:
	  function(aConsoleActor, aListeners, aOnResponse = noop) {
	    let packet = {
	      to: aConsoleActor,
	      type: "startListeners",
	      listeners: aListeners,
	    };
	
	    return this.request(packet).then(aResponse => {
	      let consoleClient;
	      if (!aResponse.error) {
	        if (this._clients.has(aConsoleActor)) {
	          consoleClient = this._clients.get(aConsoleActor);
	        } else {
	          consoleClient = new WebConsoleClient(this, aResponse);
	          this.registerClient(consoleClient);
	        }
	      }
	      aOnResponse(aResponse, consoleClient);
	      return [aResponse, consoleClient];
	    });
	  },
	
	  /**
	   * Attach to a global-scoped thread actor for chrome debugging.
	   *
	   * @param string aThreadActor
	   *        The actor ID for the thread to attach.
	   * @param function aOnResponse
	   *        Called with the response packet and a ThreadClient
	   *        (which will be undefined on error).
	   * @param object aOptions
	   *        Configuration options.
	   *        - useSourceMaps: whether to use source maps or not.
	   */
	  attachThread: function(aThreadActor, aOnResponse = noop, aOptions = {}) {
	    if (this._clients.has(aThreadActor)) {
	      let client = this._clients.get(aThreadActor);
	      DevToolsUtils.executeSoon(() => aOnResponse({}, client));
	      return promise.resolve([{}, client]);
	    }
	
	    let packet = {
	      to: aThreadActor,
	      type: "attach",
	      options: aOptions
	    };
	    return this.request(packet).then(aResponse => {
	      if (!aResponse.error) {
	        var threadClient = new ThreadClient(this, aThreadActor);
	        this.registerClient(threadClient);
	      }
	      aOnResponse(aResponse, threadClient);
	      return [aResponse, threadClient];
	    });
	  },
	
	  /**
	   * Attach to a trace actor.
	   *
	   * @param string aTraceActor
	   *        The actor ID for the tracer to attach.
	   * @param function aOnResponse
	   *        Called with the response packet and a TraceClient
	   *        (which will be undefined on error).
	   */
	  attachTracer: function(aTraceActor, aOnResponse = noop) {
	    if (this._clients.has(aTraceActor)) {
	      let client = this._clients.get(aTraceActor);
	      DevToolsUtils.executeSoon(() => aOnResponse({}, client));
	      return promise.resolve([{}, client]);
	    }
	
	    let packet = {
	      to: aTraceActor,
	      type: "attach"
	    };
	    return this.request(packet).then(aResponse => {
	      if (!aResponse.error) {
	        var traceClient = new TraceClient(this, aTraceActor);
	        this.registerClient(traceClient);
	      }
	      aOnResponse(aResponse, traceClient);
	      return [aResponse, traceClient];
	    });
	  },
	
	  /**
	   * Fetch the ChromeActor for the main process or ChildProcessActor for a
	   * a given child process ID.
	   *
	   * @param number aId
	   *        The ID for the process to attach (returned by `listProcesses`).
	   *        Connected to the main process if omitted, or is 0.
	   */
	  getProcess: function(aId) {
	    let packet = {
	      to: "root",
	      type: "getProcess"
	    };
	    if (typeof (aId) == "number") {
	      packet.id = aId;
	    }
	    return this.request(packet);
	  },
	
	  /**
	   * Release an object actor.
	   *
	   * @param string aActor
	   *        The actor ID to send the request to.
	   * @param aOnResponse function
	   *        If specified, will be called with the response packet when
	   *        debugging server responds.
	   */
	  release: DebuggerClient.requester({
	    to: args(0),
	    type: "release"
	  }, {
	    telemetry: "RELEASE"
	  }),
	
	  /**
	   * Send a request to the debugging server.
	   *
	   * @param aRequest object
	   *        A JSON packet to send to the debugging server.
	   * @param aOnResponse function
	   *        If specified, will be called with the JSON response packet when
	   *        debugging server responds.
	   * @return Request
	   *         This object emits a number of events to allow you to respond to
	   *         different parts of the request lifecycle.
	   *         It is also a Promise object, with a `then` method, that is resolved
	   *         whenever a JSON or a Bulk response is received; and is rejected
	   *         if the response is an error.
	   *         Note: This return value can be ignored if you are using JSON alone,
	   *         because the callback provided in |aOnResponse| will be bound to the
	   *         "json-reply" event automatically.
	   *
	   *         Events emitted:
	   *         * json-reply: The server replied with a JSON packet, which is
	   *           passed as event data.
	   *         * bulk-reply: The server replied with bulk data, which you can read
	   *           using the event data object containing:
	   *           * actor:  Name of actor that received the packet
	   *           * type:   Name of actor's method that was called on receipt
	   *           * length: Size of the data to be read
	   *           * stream: This input stream should only be used directly if you
	   *                     can ensure that you will read exactly |length| bytes
	   *                     and will not close the stream when reading is complete
	   *           * done:   If you use the stream directly (instead of |copyTo|
	   *                     below), you must signal completion by resolving /
	   *                     rejecting this deferred.  If it's rejected, the
	   *                     transport will be closed.  If an Error is supplied as a
	   *                     rejection value, it will be logged via |dumpn|.  If you
	   *                     do use |copyTo|, resolving is taken care of for you
	   *                     when copying completes.
	   *           * copyTo: A helper function for getting your data out of the
	   *                     stream that meets the stream handling requirements
	   *                     above, and has the following signature:
	   *             @param  output nsIAsyncOutputStream
	   *                     The stream to copy to.
	   *             @return Promise
	   *                     The promise is resolved when copying completes or
	   *                     rejected if any (unexpected) errors occur.
	   *                     This object also emits "progress" events for each chunk
	   *                     that is copied.  See stream-utils.js.
	   */
	  request: function(aRequest, aOnResponse) {
	    if (!this.mainRoot) {
	      throw Error("Have not yet received a hello packet from the server.");
	    }
	    let type = aRequest.type || "";
	    if (!aRequest.to) {
	      throw Error("'" + type + "' request packet has no destination.");
	    }
	    if (this._closed) {
	      let msg = "'" + type + "' request packet to " +
	                "'" + aRequest.to + "' " +
	               "can't be sent as the connection is closed.";
	      let resp = { error: "connectionClosed", message: msg };
	      if (aOnResponse) {
	        aOnResponse(resp);
	      }
	      return promise.reject(resp);
	    }
	
	    let request = new Request(aRequest);
	    request.format = "json";
	    request.stack = components.stack;
	    if (aOnResponse) {
	      request.on("json-reply", aOnResponse);
	    }
	
	    this._sendOrQueueRequest(request);
	
	    // Implement a Promise like API on the returned object
	    // that resolves/rejects on request response
	    let deferred = promise.defer();
	    function listenerJson(resp) {
	      request.off("json-reply", listenerJson);
	      request.off("bulk-reply", listenerBulk);
	      if (resp.error) {
	        deferred.reject(resp);
	      } else {
	        deferred.resolve(resp);
	      }
	    }
	    function listenerBulk(resp) {
	      request.off("json-reply", listenerJson);
	      request.off("bulk-reply", listenerBulk);
	      deferred.resolve(resp);
	    }
	    request.on("json-reply", listenerJson);
	    request.on("bulk-reply", listenerBulk);
	    request.then = deferred.promise.then.bind(deferred.promise);
	
	    return request;
	  },
	
	  /**
	   * Transmit streaming data via a bulk request.
	   *
	   * This method initiates the bulk send process by queuing up the header data.
	   * The caller receives eventual access to a stream for writing.
	   *
	   * Since this opens up more options for how the server might respond (it could
	   * send back either JSON or bulk data), and the returned Request object emits
	   * events for different stages of the request process that you may want to
	   * react to.
	   *
	   * @param request Object
	   *        This is modeled after the format of JSON packets above, but does not
	   *        actually contain the data, but is instead just a routing header:
	   *          * actor:  Name of actor that will receive the packet
	   *          * type:   Name of actor's method that should be called on receipt
	   *          * length: Size of the data to be sent
	   * @return Request
	   *         This object emits a number of events to allow you to respond to
	   *         different parts of the request lifecycle.
	   *
	   *         Events emitted:
	   *         * bulk-send-ready: Ready to send bulk data to the server, using the
	   *           event data object containing:
	   *           * stream:   This output stream should only be used directly if
	   *                       you can ensure that you will write exactly |length|
	   *                       bytes and will not close the stream when writing is
	   *                       complete
	   *           * done:     If you use the stream directly (instead of |copyFrom|
	   *                       below), you must signal completion by resolving /
	   *                       rejecting this deferred.  If it's rejected, the
	   *                       transport will be closed.  If an Error is supplied as
	   *                       a rejection value, it will be logged via |dumpn|.  If
	   *                       you do use |copyFrom|, resolving is taken care of for
	   *                       you when copying completes.
	   *           * copyFrom: A helper function for getting your data onto the
	   *                       stream that meets the stream handling requirements
	   *                       above, and has the following signature:
	   *             @param  input nsIAsyncInputStream
	   *                     The stream to copy from.
	   *             @return Promise
	   *                     The promise is resolved when copying completes or
	   *                     rejected if any (unexpected) errors occur.
	   *                     This object also emits "progress" events for each chunk
	   *                     that is copied.  See stream-utils.js.
	   *         * json-reply: The server replied with a JSON packet, which is
	   *           passed as event data.
	   *         * bulk-reply: The server replied with bulk data, which you can read
	   *           using the event data object containing:
	   *           * actor:  Name of actor that received the packet
	   *           * type:   Name of actor's method that was called on receipt
	   *           * length: Size of the data to be read
	   *           * stream: This input stream should only be used directly if you
	   *                     can ensure that you will read exactly |length| bytes
	   *                     and will not close the stream when reading is complete
	   *           * done:   If you use the stream directly (instead of |copyTo|
	   *                     below), you must signal completion by resolving /
	   *                     rejecting this deferred.  If it's rejected, the
	   *                     transport will be closed.  If an Error is supplied as a
	   *                     rejection value, it will be logged via |dumpn|.  If you
	   *                     do use |copyTo|, resolving is taken care of for you
	   *                     when copying completes.
	   *           * copyTo: A helper function for getting your data out of the
	   *                     stream that meets the stream handling requirements
	   *                     above, and has the following signature:
	   *             @param  output nsIAsyncOutputStream
	   *                     The stream to copy to.
	   *             @return Promise
	   *                     The promise is resolved when copying completes or
	   *                     rejected if any (unexpected) errors occur.
	   *                     This object also emits "progress" events for each chunk
	   *                     that is copied.  See stream-utils.js.
	   */
	  startBulkRequest: function(request) {
	    if (!this.traits.bulk) {
	      throw Error("Server doesn't support bulk transfers");
	    }
	    if (!this.mainRoot) {
	      throw Error("Have not yet received a hello packet from the server.");
	    }
	    if (!request.type) {
	      throw Error("Bulk packet is missing the required 'type' field.");
	    }
	    if (!request.actor) {
	      throw Error("'" + request.type + "' bulk packet has no destination.");
	    }
	    if (!request.length) {
	      throw Error("'" + request.type + "' bulk packet has no length.");
	    }
	
	    request = new Request(request);
	    request.format = "bulk";
	
	    this._sendOrQueueRequest(request);
	
	    return request;
	  },
	
	  /**
	   * If a new request can be sent immediately, do so.  Otherwise, queue it.
	   */
	  _sendOrQueueRequest(request) {
	    let actor = request.actor;
	    if (!this._activeRequests.has(actor)) {
	      this._sendRequest(request);
	    } else {
	      this._queueRequest(request);
	    }
	  },
	
	  /**
	   * Send a request.
	   * @throws Error if there is already an active request in flight for the same
	   *         actor.
	   */
	  _sendRequest(request) {
	    let actor = request.actor;
	    this.expectReply(actor, request);
	
	    if (request.format === "json") {
	      this._transport.send(request.request);
	      return false;
	    }
	
	    this._transport.startBulkSend(request.request).then((...args) => {
	      request.emit("bulk-send-ready", ...args);
	    });
	  },
	
	  /**
	   * Queue a request to be sent later.  Queues are only drained when an in
	   * flight request to a given actor completes.
	   */
	  _queueRequest(request) {
	    let actor = request.actor;
	    let queue = this._pendingRequests.get(actor) || [];
	    queue.push(request);
	    this._pendingRequests.set(actor, queue);
	  },
	
	  /**
	   * Attempt the next request to a given actor (if any).
	   */
	  _attemptNextRequest(actor) {
	    if (this._activeRequests.has(actor)) {
	      return;
	    }
	    let queue = this._pendingRequests.get(actor);
	    if (!queue) {
	      return;
	    }
	    let request = queue.shift();
	    if (queue.length === 0) {
	      this._pendingRequests.delete(actor);
	    }
	    this._sendRequest(request);
	  },
	
	  /**
	   * Arrange to hand the next reply from |aActor| to the handler bound to
	   * |aRequest|.
	   *
	   * DebuggerClient.prototype.request / startBulkRequest usually takes care of
	   * establishing the handler for a given request, but in rare cases (well,
	   * greetings from new root actors, is the only case at the moment) we must be
	   * prepared for a "reply" that doesn't correspond to any request we sent.
	   */
	  expectReply: function(aActor, aRequest) {
	    if (this._activeRequests.has(aActor)) {
	      throw Error("clashing handlers for next reply from " + uneval(aActor));
	    }
	
	    // If a handler is passed directly (as it is with the handler for the root
	    // actor greeting), create a dummy request to bind this to.
	    if (typeof aRequest === "function") {
	      let handler = aRequest;
	      aRequest = new Request();
	      aRequest.on("json-reply", handler);
	    }
	
	    this._activeRequests.set(aActor, aRequest);
	  },
	
	  // Transport hooks.
	
	  /**
	   * Called by DebuggerTransport to dispatch incoming packets as appropriate.
	   *
	   * @param aPacket object
	   *        The incoming packet.
	   */
	  onPacket: function(aPacket) {
	    if (!aPacket.from) {
	      DevToolsUtils.reportException(
	        "onPacket",
	        new Error("Server did not specify an actor, dropping packet: " +
	                  JSON.stringify(aPacket)));
	      return;
	    }
	
	    // If we have a registered Front for this actor, let it handle the packet
	    // and skip all the rest of this unpleasantness.
	    let front = this.getActor(aPacket.from);
	    if (front) {
	      front.onPacket(aPacket);
	      return;
	    }
	
	    if (this._clients.has(aPacket.from) && aPacket.type) {
	      let client = this._clients.get(aPacket.from);
	      let type = aPacket.type;
	      if (client.events.indexOf(type) != -1) {
	        client.emit(type, aPacket);
	        // we ignore the rest, as the client is expected to handle this packet.
	        return;
	      }
	    }
	
	    let activeRequest;
	    // See if we have a handler function waiting for a reply from this
	    // actor. (Don't count unsolicited notifications or pauses as
	    // replies.)
	    if (this._activeRequests.has(aPacket.from) &&
	        !(aPacket.type in UnsolicitedNotifications) &&
	        !(aPacket.type == ThreadStateTypes.paused &&
	          aPacket.why.type in UnsolicitedPauses)) {
	      activeRequest = this._activeRequests.get(aPacket.from);
	      this._activeRequests.delete(aPacket.from);
	    }
	
	    // If there is a subsequent request for the same actor, hand it off to the
	    // transport.  Delivery of packets on the other end is always async, even
	    // in the local transport case.
	    this._attemptNextRequest(aPacket.from);
	
	    // Packets that indicate thread state changes get special treatment.
	    if (aPacket.type in ThreadStateTypes &&
	        this._clients.has(aPacket.from) &&
	        typeof this._clients.get(aPacket.from)._onThreadState == "function") {
	      this._clients.get(aPacket.from)._onThreadState(aPacket);
	    }
	
	    // TODO: Bug 1151156 - Remove once Gecko 40 is on b2g-stable.
	    if (!this.traits.noNeedToFakeResumptionOnNavigation) {
	      // On navigation the server resumes, so the client must resume as well.
	      // We achieve that by generating a fake resumption packet that triggers
	      // the client's thread state change listeners.
	      if (aPacket.type == UnsolicitedNotifications.tabNavigated &&
	          this._clients.has(aPacket.from) &&
	          this._clients.get(aPacket.from).thread) {
	        let thread = this._clients.get(aPacket.from).thread;
	        let resumption = { from: thread._actor, type: "resumed" };
	        thread._onThreadState(resumption);
	      }
	    }
	
	    // Only try to notify listeners on events, not responses to requests
	    // that lack a packet type.
	    if (aPacket.type) {
	      this.emit(aPacket.type, aPacket);
	    }
	
	    if (activeRequest) {
	      let emitReply = () => activeRequest.emit("json-reply", aPacket);
	      if (activeRequest.stack) {
	        Cu.callFunctionWithAsyncStack(emitReply, activeRequest.stack,
	                                      "DevTools RDP");
	      } else {
	        emitReply();
	      }
	    }
	  },
	
	  /**
	   * Called by the DebuggerTransport to dispatch incoming bulk packets as
	   * appropriate.
	   *
	   * @param packet object
	   *        The incoming packet, which contains:
	   *        * actor:  Name of actor that will receive the packet
	   *        * type:   Name of actor's method that should be called on receipt
	   *        * length: Size of the data to be read
	   *        * stream: This input stream should only be used directly if you can
	   *                  ensure that you will read exactly |length| bytes and will
	   *                  not close the stream when reading is complete
	   *        * done:   If you use the stream directly (instead of |copyTo|
	   *                  below), you must signal completion by resolving /
	   *                  rejecting this deferred.  If it's rejected, the transport
	   *                  will be closed.  If an Error is supplied as a rejection
	   *                  value, it will be logged via |dumpn|.  If you do use
	   *                  |copyTo|, resolving is taken care of for you when copying
	   *                  completes.
	   *        * copyTo: A helper function for getting your data out of the stream
	   *                  that meets the stream handling requirements above, and has
	   *                  the following signature:
	   *          @param  output nsIAsyncOutputStream
	   *                  The stream to copy to.
	   *          @return Promise
	   *                  The promise is resolved when copying completes or rejected
	   *                  if any (unexpected) errors occur.
	   *                  This object also emits "progress" events for each chunk
	   *                  that is copied.  See stream-utils.js.
	   */
	  onBulkPacket: function(packet) {
	    let { actor, type, length } = packet;
	
	    if (!actor) {
	      DevToolsUtils.reportException(
	        "onBulkPacket",
	        new Error("Server did not specify an actor, dropping bulk packet: " +
	                  JSON.stringify(packet)));
	      return;
	    }
	
	    // See if we have a handler function waiting for a reply from this
	    // actor.
	    if (!this._activeRequests.has(actor)) {
	      return;
	    }
	
	    let activeRequest = this._activeRequests.get(actor);
	    this._activeRequests.delete(actor);
	
	    // If there is a subsequent request for the same actor, hand it off to the
	    // transport.  Delivery of packets on the other end is always async, even
	    // in the local transport case.
	    this._attemptNextRequest(actor);
	
	    activeRequest.emit("bulk-reply", packet);
	  },
	
	  /**
	   * Called by DebuggerTransport when the underlying stream is closed.
	   *
	   * @param aStatus nsresult
	   *        The status code that corresponds to the reason for closing
	   *        the stream.
	   */
	  onClosed: function(aStatus) {
	    this._closed = true;
	    this.emit("closed");
	
	    // Reject all pending and active requests
	    let reject = function(type, request, actor) {
	      // Server can send packets on its own and client only pass a callback
	      // to expectReply, so that there is no request object.
	      let msg;
	      if (request.request) {
	        msg = "'" + request.request.type + "' " + type + " request packet" +
	              " to '" + actor + "' " +
	              "can't be sent as the connection just closed.";
	      } else {
	        msg = "server side packet from '" + actor + "' can't be received " +
	              "as the connection just closed.";
	      }
	      let packet = { error: "connectionClosed", message: msg };
	      request.emit("json-reply", packet);
	    };
	
	    let pendingRequests = new Map(this._pendingRequests);
	    this._pendingRequests.clear();
	    pendingRequests.forEach((list, actor) => {
	      list.forEach(request => reject("pending", request, actor));
	    });
	    let activeRequests = new Map(this._activeRequests);
	    this._activeRequests.clear();
	    activeRequests.forEach(reject.bind(null, "active"));
	
	    // The |_pools| array on the client-side currently is used only by
	    // protocol.js to store active fronts, mirroring the actor pools found in
	    // the server.  So, read all usages of "pool" as "protocol.js front".
	    //
	    // In the normal case where we shutdown cleanly, the toolbox tells each tool
	    // to close, and they each call |destroy| on any fronts they were using.
	    // When |destroy| or |cleanup| is called on a protocol.js front, it also
	    // removes itself from the |_pools| array.  Once the toolbox has shutdown,
	    // the connection is closed, and we reach here.  All fronts (should have
	    // been) |destroy|ed, so |_pools| should empty.
	    //
	    // If the connection instead aborts unexpectedly, we may end up here with
	    // all fronts used during the life of the connection.  So, we call |cleanup|
	    // on them clear their state, reject pending requests, and remove themselves
	    // from |_pools|.  This saves the toolbox from hanging indefinitely, in case
	    // it waits for some server response before shutdown that will now never
	    // arrive.
	    for (let pool of this._pools) {
	      pool.cleanup();
	    }
	  },
	
	  registerClient: function(client) {
	    let actorID = client.actor;
	    if (!actorID) {
	      throw new Error("DebuggerServer.registerClient expects " +
	                      "a client instance with an `actor` attribute.");
	    }
	    if (!Array.isArray(client.events)) {
	      throw new Error("DebuggerServer.registerClient expects " +
	                      "a client instance with an `events` attribute " +
	                      "that is an array.");
	    }
	    if (client.events.length > 0 && typeof (client.emit) != "function") {
	      throw new Error("DebuggerServer.registerClient expects " +
	                      "a client instance with non-empty `events` array to" +
	                      "have an `emit` function.");
	    }
	    if (this._clients.has(actorID)) {
	      throw new Error("DebuggerServer.registerClient already registered " +
	                      "a client for this actor.");
	    }
	    this._clients.set(actorID, client);
	  },
	
	  unregisterClient: function(client) {
	    let actorID = client.actor;
	    if (!actorID) {
	      throw new Error("DebuggerServer.unregisterClient expects " +
	                      "a Client instance with a `actor` attribute.");
	    }
	    this._clients.delete(actorID);
	  },
	
	  /**
	   * Actor lifetime management, echos the server's actor pools.
	   */
	  __pools: null,
	  get _pools() {
	    if (this.__pools) {
	      return this.__pools;
	    }
	    this.__pools = new Set();
	    return this.__pools;
	  },
	
	  addActorPool: function(pool) {
	    this._pools.add(pool);
	  },
	  removeActorPool: function(pool) {
	    this._pools.delete(pool);
	  },
	  getActor: function(actorID) {
	    let pool = this.poolFor(actorID);
	    return pool ? pool.get(actorID) : null;
	  },
	
	  poolFor: function(actorID) {
	    for (let pool of this._pools) {
	      if (pool.has(actorID)) return pool;
	    }
	    return null;
	  },
	
	  /**
	   * Currently attached addon.
	   */
	  activeAddon: null
	};
	
	eventSource(DebuggerClient.prototype);
	
	function Request(request) {
	  this.request = request;
	}
	
	Request.prototype = {
	
	  on: function(type, listener) {
	    events.on(this, type, listener);
	  },
	
	  off: function(type, listener) {
	    events.off(this, type, listener);
	  },
	
	  once: function(type, listener) {
	    events.once(this, type, listener);
	  },
	
	  emit: function(type, ...args) {
	    events.emit(this, type, ...args);
	  },
	
	  get actor() { return this.request.to || this.request.actor; }
	
	};
	
	/**
	 * Creates a tab client for the remote debugging protocol server. This client
	 * is a front to the tab actor created in the server side, hiding the protocol
	 * details in a traditional JavaScript API.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aForm object
	 *        The protocol form for this tab.
	 */
	function TabClient(aClient, aForm) {
	  this.client = aClient;
	  this._actor = aForm.from;
	  this._threadActor = aForm.threadActor;
	  this.javascriptEnabled = aForm.javascriptEnabled;
	  this.cacheDisabled = aForm.cacheDisabled;
	  this.thread = null;
	  this.request = this.client.request;
	  this.traits = aForm.traits || {};
	  this.events = ["workerListChanged"];
	}
	
	TabClient.prototype = {
	  get actor() { return this._actor; },
	  get _transport() { return this.client._transport; },
	
	  /**
	   * Attach to a thread actor.
	   *
	   * @param object aOptions
	   *        Configuration options.
	   *        - useSourceMaps: whether to use source maps or not.
	   * @param function aOnResponse
	   *        Called with the response packet and a ThreadClient
	   *        (which will be undefined on error).
	   */
	  attachThread: function(aOptions = {}, aOnResponse = noop) {
	    if (this.thread) {
	      DevToolsUtils.executeSoon(() => aOnResponse({}, this.thread));
	      return promise.resolve([{}, this.thread]);
	    }
	
	    let packet = {
	      to: this._threadActor,
	      type: "attach",
	      options: aOptions
	    };
	    return this.request(packet).then(aResponse => {
	      if (!aResponse.error) {
	        this.thread = new ThreadClient(this, this._threadActor);
	        this.client.registerClient(this.thread);
	      }
	      aOnResponse(aResponse, this.thread);
	      return [aResponse, this.thread];
	    });
	  },
	
	  /**
	   * Detach the client from the tab actor.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  detach: DebuggerClient.requester({
	    type: "detach"
	  }, {
	    before: function(aPacket) {
	      if (this.thread) {
	        this.thread.detach();
	      }
	      return aPacket;
	    },
	    after: function(aResponse) {
	      this.client.unregisterClient(this);
	      return aResponse;
	    },
	    telemetry: "TABDETACH"
	  }),
	
	  /**
	   * Bring the window to the front.
	   */
	  focus: DebuggerClient.requester({
	    type: "focus"
	  }, {}),
	
	  /**
	   * Reload the page in this tab.
	   *
	   * @param [optional] object options
	   *        An object with a `force` property indicating whether or not
	   *        this reload should skip the cache
	   */
	  reload: function(options = { force: false }) {
	    return this._reload(options);
	  },
	  _reload: DebuggerClient.requester({
	    type: "reload",
	    options: args(0)
	  }, {
	    telemetry: "RELOAD"
	  }),
	
	  /**
	   * Navigate to another URL.
	   *
	   * @param string url
	   *        The URL to navigate to.
	   */
	  navigateTo: DebuggerClient.requester({
	    type: "navigateTo",
	    url: args(0)
	  }, {
	    telemetry: "NAVIGATETO"
	  }),
	
	  /**
	   * Reconfigure the tab actor.
	   *
	   * @param object aOptions
	   *        A dictionary object of the new options to use in the tab actor.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  reconfigure: DebuggerClient.requester({
	    type: "reconfigure",
	    options: args(0)
	  }, {
	    telemetry: "RECONFIGURETAB"
	  }),
	
	  listWorkers: DebuggerClient.requester({
	    type: "listWorkers"
	  }, {
	    telemetry: "LISTWORKERS"
	  }),
	
	  attachWorker: function(aWorkerActor, aOnResponse) {
	    this.client.attachWorker(aWorkerActor, aOnResponse);
	  },
	
	  /**
	   * Resolve a location ({ url, line, column }) to its current
	   * source mapping location.
	   *
	   * @param {String} arg[0].url
	   * @param {Number} arg[0].line
	   * @param {Number?} arg[0].column
	   */
	  resolveLocation: DebuggerClient.requester({
	    type: "resolveLocation",
	    location: args(0)
	  }),
	};
	
	eventSource(TabClient.prototype);
	
	function WorkerClient(aClient, aForm) {
	  this.client = aClient;
	  this._actor = aForm.from;
	  this._isClosed = false;
	  this._url = aForm.url;
	
	  this._onClose = this._onClose.bind(this);
	
	  this.addListener("close", this._onClose);
	
	  this.traits = {};
	}
	
	WorkerClient.prototype = {
	  get _transport() {
	    return this.client._transport;
	  },
	
	  get request() {
	    return this.client.request;
	  },
	
	  get actor() {
	    return this._actor;
	  },
	
	  get url() {
	    return this._url;
	  },
	
	  get isClosed() {
	    return this._isClosed;
	  },
	
	  detach: DebuggerClient.requester({ type: "detach" }, {
	    after: function(aResponse) {
	      if (this.thread) {
	        this.client.unregisterClient(this.thread);
	      }
	      this.client.unregisterClient(this);
	      return aResponse;
	    },
	
	    telemetry: "WORKERDETACH"
	  }),
	
	  attachThread: function(aOptions = {}, aOnResponse = noop) {
	    if (this.thread) {
	      let response = [{
	        type: "connected",
	        threadActor: this.thread._actor,
	        consoleActor: this.consoleActor,
	      }, this.thread];
	      DevToolsUtils.executeSoon(() => aOnResponse(response));
	      return response;
	    }
	
	    // The connect call on server doesn't attach the thread as of version 44.
	    return this.request({
	      to: this._actor,
	      type: "connect",
	      options: aOptions,
	    }).then(connectReponse => {
	      if (connectReponse.error) {
	        aOnResponse(connectReponse, null);
	        return [connectResponse, null];
	      }
	
	      return this.request({
	        to: connectReponse.threadActor,
	        type: "attach",
	        options: aOptions
	      }).then(attachResponse => {
	        if (attachResponse.error) {
	          aOnResponse(attachResponse, null);
	        }
	
	        this.thread = new ThreadClient(this, connectReponse.threadActor);
	        this.consoleActor = connectReponse.consoleActor;
	        this.client.registerClient(this.thread);
	
	        aOnResponse(connectReponse, this.thread);
	        return [connectResponse, this.thread];
	      });
	    });
	  },
	
	  _onClose: function() {
	    this.removeListener("close", this._onClose);
	
	    if (this.thread) {
	      this.client.unregisterClient(this.thread);
	    }
	    this.client.unregisterClient(this);
	    this._isClosed = true;
	  },
	
	  reconfigure: function() {
	    return Promise.resolve();
	  },
	
	  events: ["close"]
	};
	
	eventSource(WorkerClient.prototype);
	
	function AddonClient(aClient, aActor) {
	  this._client = aClient;
	  this._actor = aActor;
	  this.request = this._client.request;
	  this.events = [];
	}
	
	AddonClient.prototype = {
	  get actor() { return this._actor; },
	  get _transport() { return this._client._transport; },
	
	  /**
	   * Detach the client from the addon actor.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  detach: DebuggerClient.requester({
	    type: "detach"
	  }, {
	    after: function(aResponse) {
	      if (this._client.activeAddon === this) {
	        this._client.activeAddon = null;
	      }
	      this._client.unregisterClient(this);
	      return aResponse;
	    },
	    telemetry: "ADDONDETACH"
	  })
	};
	
	/**
	 * A RootClient object represents a root actor on the server. Each
	 * DebuggerClient keeps a RootClient instance representing the root actor
	 * for the initial connection; DebuggerClient's 'listTabs' and
	 * 'listChildProcesses' methods forward to that root actor.
	 *
	 * @param aClient object
	 *      The client connection to which this actor belongs.
	 * @param aGreeting string
	 *      The greeting packet from the root actor we're to represent.
	 *
	 * Properties of a RootClient instance:
	 *
	 * @property actor string
	 *      The name of this child's root actor.
	 * @property applicationType string
	 *      The application type, as given in the root actor's greeting packet.
	 * @property traits object
	 *      The traits object, as given in the root actor's greeting packet.
	 */
	function RootClient(aClient, aGreeting) {
	  this._client = aClient;
	  this.actor = aGreeting.from;
	  this.applicationType = aGreeting.applicationType;
	  this.traits = aGreeting.traits;
	}
	exports.RootClient = RootClient;
	
	RootClient.prototype = {
	  constructor: RootClient,
	
	  /**
	   * List the open tabs.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  listTabs: DebuggerClient.requester({ type: "listTabs" },
	                                     { telemetry: "LISTTABS" }),
	
	  /**
	   * List the installed addons.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  listAddons: DebuggerClient.requester({ type: "listAddons" },
	                                       { telemetry: "LISTADDONS" }),
	
	  /**
	   * List the registered workers.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  listWorkers: DebuggerClient.requester({ type: "listWorkers" },
	                                        { telemetry: "LISTWORKERS" }),
	
	  /**
	   * List the registered service workers.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  listServiceWorkerRegistrations: DebuggerClient.requester({ type: "listServiceWorkerRegistrations" },
	                                                           { telemetry: "LISTSERVICEWORKERREGISTRATIONS" }),
	
	  /**
	   * List the running processes.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  listProcesses: DebuggerClient.requester({ type: "listProcesses" },
	                                          { telemetry: "LISTPROCESSES" }),
	
	  /**
	   * Fetch the TabActor for the currently selected tab, or for a specific
	   * tab given as first parameter.
	   *
	   * @param [optional] object aFilter
	   *        A dictionary object with following optional attributes:
	   *         - outerWindowID: used to match tabs in parent process
	   *         - tabId: used to match tabs in child processes
	   *         - tab: a reference to xul:tab element
	   *        If nothing is specified, returns the actor for the currently
	   *        selected tab.
	   */
	  getTab: function(aFilter) {
	    let packet = {
	      to: this.actor,
	      type: "getTab"
	    };
	
	    if (aFilter) {
	      if (typeof (aFilter.outerWindowID) == "number") {
	        packet.outerWindowID = aFilter.outerWindowID;
	      } else if (typeof (aFilter.tabId) == "number") {
	        packet.tabId = aFilter.tabId;
	      } else if ("tab" in aFilter) {
	        let browser = aFilter.tab.linkedBrowser;
	        if (browser.frameLoader.tabParent) {
	          // Tabs in child process
	          packet.tabId = browser.frameLoader.tabParent.tabId;
	        } else {
	          // Tabs in parent process
	          let windowUtils = browser.contentWindow
	            .QueryInterface(Ci.nsIInterfaceRequestor)
	            .getInterface(Ci.nsIDOMWindowUtils);
	          packet.outerWindowID = windowUtils.outerWindowID;
	        }
	      } else {
	        // Throw if a filter object have been passed but without
	        // any clearly idenfified filter.
	        throw new Error("Unsupported argument given to getTab request");
	      }
	    }
	
	    return this.request(packet);
	  },
	
	  /**
	   * Description of protocol's actors and methods.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  protocolDescription: DebuggerClient.requester({ type: "protocolDescription" },
	                                                 { telemetry: "PROTOCOLDESCRIPTION" }),
	
	  /*
	   * Methods constructed by DebuggerClient.requester require these forwards
	   * on their 'this'.
	   */
	  get _transport() { return this._client._transport; },
	  get request() { return this._client.request; }
	};
	
	/**
	 * Creates a thread client for the remote debugging protocol server. This client
	 * is a front to the thread actor created in the server side, hiding the
	 * protocol details in a traditional JavaScript API.
	 *
	 * @param aClient DebuggerClient|TabClient
	 *        The parent of the thread (tab for tab-scoped debuggers, DebuggerClient
	 *        for chrome debuggers).
	 * @param aActor string
	 *        The actor ID for this thread.
	 */
	function ThreadClient(aClient, aActor) {
	  this._parent = aClient;
	  this.client = aClient instanceof DebuggerClient ? aClient : aClient.client;
	  this._actor = aActor;
	  this._frameCache = [];
	  this._scriptCache = {};
	  this._pauseGrips = {};
	  this._threadGrips = {};
	  this.request = this.client.request;
	}
	
	ThreadClient.prototype = {
	  _state: "paused",
	  get state() { return this._state; },
	  get paused() { return this._state === "paused"; },
	
	  _pauseOnExceptions: false,
	  _ignoreCaughtExceptions: false,
	  _pauseOnDOMEvents: null,
	
	  _actor: null,
	  get actor() { return this._actor; },
	
	  get _transport() { return this.client._transport; },
	
	  _assertPaused: function(aCommand) {
	    if (!this.paused) {
	      throw Error(aCommand + " command sent while not paused. Currently " + this._state);
	    }
	  },
	
	  /**
	   * Resume a paused thread. If the optional aLimit parameter is present, then
	   * the thread will also pause when that limit is reached.
	   *
	   * @param [optional] object aLimit
	   *        An object with a type property set to the appropriate limit (next,
	   *        step, or finish) per the remote debugging protocol specification.
	   *        Use null to specify no limit.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  _doResume: DebuggerClient.requester({
	    type: "resume",
	    resumeLimit: args(0)
	  }, {
	    before: function(aPacket) {
	      this._assertPaused("resume");
	
	      // Put the client in a tentative "resuming" state so we can prevent
	      // further requests that should only be sent in the paused state.
	      this._state = "resuming";
	
	      if (this._pauseOnExceptions) {
	        aPacket.pauseOnExceptions = this._pauseOnExceptions;
	      }
	      if (this._ignoreCaughtExceptions) {
	        aPacket.ignoreCaughtExceptions = this._ignoreCaughtExceptions;
	      }
	      if (this._pauseOnDOMEvents) {
	        aPacket.pauseOnDOMEvents = this._pauseOnDOMEvents;
	      }
	      return aPacket;
	    },
	    after: function(aResponse) {
	      if (aResponse.error) {
	        // There was an error resuming, back to paused state.
	        this._state = "paused";
	      }
	      return aResponse;
	    },
	    telemetry: "RESUME"
	  }),
	
	  /**
	   * Reconfigure the thread actor.
	   *
	   * @param object aOptions
	   *        A dictionary object of the new options to use in the thread actor.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  reconfigure: DebuggerClient.requester({
	    type: "reconfigure",
	    options: args(0)
	  }, {
	    telemetry: "RECONFIGURETHREAD"
	  }),
	
	  /**
	   * Resume a paused thread.
	   */
	  resume: function(aOnResponse) {
	    return this._doResume(null, aOnResponse);
	  },
	
	  /**
	   * Resume then pause without stepping.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  resumeThenPause: function(aOnResponse) {
	    return this._doResume({ type: "break" }, aOnResponse);
	  },
	
	  /**
	   * Step over a function call.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  stepOver: function(aOnResponse) {
	    return this._doResume({ type: "next" }, aOnResponse);
	  },
	
	  /**
	   * Step into a function call.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  stepIn: function(aOnResponse) {
	    return this._doResume({ type: "step" }, aOnResponse);
	  },
	
	  /**
	   * Step out of a function call.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  stepOut: function(aOnResponse) {
	    return this._doResume({ type: "finish" }, aOnResponse);
	  },
	
	  /**
	   * Immediately interrupt a running thread.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  interrupt: function(aOnResponse) {
	    return this._doInterrupt(null, aOnResponse);
	  },
	
	  /**
	   * Pause execution right before the next JavaScript bytecode is executed.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  breakOnNext: function(aOnResponse) {
	    return this._doInterrupt("onNext", aOnResponse);
	  },
	
	  /**
	   * Interrupt a running thread.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  _doInterrupt: DebuggerClient.requester({
	    type: "interrupt",
	    when: args(0)
	  }, {
	    telemetry: "INTERRUPT"
	  }),
	
	  /**
	   * Enable or disable pausing when an exception is thrown.
	   *
	   * @param boolean aFlag
	   *        Enables pausing if true, disables otherwise.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  pauseOnExceptions: function(aPauseOnExceptions,
	                               aIgnoreCaughtExceptions,
	                               aOnResponse = noop) {
	    this._pauseOnExceptions = aPauseOnExceptions;
	    this._ignoreCaughtExceptions = aIgnoreCaughtExceptions;
	
	    // Otherwise send the flag using a standard resume request.
	    if (!this.paused) {
	      return this.interrupt(aResponse => {
	        if (aResponse.error) {
	          // Can't continue if pausing failed.
	          aOnResponse(aResponse);
	          return aResponse;
	        }
	        return this.resume(aOnResponse);
	      });
	    }
	
	    aOnResponse();
	    return promise.resolve();
	  },
	
	  /**
	   * Enable pausing when the specified DOM events are triggered. Disabling
	   * pausing on an event can be realized by calling this method with the updated
	   * array of events that doesn't contain it.
	   *
	   * @param array|string events
	   *        An array of strings, representing the DOM event types to pause on,
	   *        or "*" to pause on all DOM events. Pass an empty array to
	   *        completely disable pausing on DOM events.
	   * @param function onResponse
	   *        Called with the response packet in a future turn of the event loop.
	   */
	  pauseOnDOMEvents: function(events, onResponse = noop) {
	    this._pauseOnDOMEvents = events;
	    // If the debuggee is paused, the value of the array will be communicated in
	    // the next resumption. Otherwise we have to force a pause in order to send
	    // the array.
	    if (this.paused) {
	      DevToolsUtils.executeSoon(() => onResponse({}));
	      return {};
	    }
	    return this.interrupt(response => {
	      // Can't continue if pausing failed.
	      if (response.error) {
	        onResponse(response);
	        return response;
	      }
	      return this.resume(onResponse);
	    });
	  },
	
	  /**
	   * Send a clientEvaluate packet to the debuggee. Response
	   * will be a resume packet.
	   *
	   * @param string aFrame
	   *        The actor ID of the frame where the evaluation should take place.
	   * @param string aExpression
	   *        The expression that will be evaluated in the scope of the frame
	   *        above.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  eval: DebuggerClient.requester({
	    type: "clientEvaluate",
	    frame: args(0),
	    expression: args(1)
	  }, {
	    before: function(aPacket) {
	      this._assertPaused("eval");
	      // Put the client in a tentative "resuming" state so we can prevent
	      // further requests that should only be sent in the paused state.
	      this._state = "resuming";
	      return aPacket;
	    },
	    after: function(aResponse) {
	      if (aResponse.error) {
	        // There was an error resuming, back to paused state.
	        this._state = "paused";
	      }
	      return aResponse;
	    },
	    telemetry: "CLIENTEVALUATE"
	  }),
	
	  /**
	   * Detach from the thread actor.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  detach: DebuggerClient.requester({
	    type: "detach"
	  }, {
	    after: function(aResponse) {
	      this.client.unregisterClient(this);
	      this._parent.thread = null;
	      return aResponse;
	    },
	    telemetry: "THREADDETACH"
	  }),
	
	  /**
	   * Release multiple thread-lifetime object actors. If any pause-lifetime
	   * actors are included in the request, a |notReleasable| error will return,
	   * but all the thread-lifetime ones will have been released.
	   *
	   * @param array actors
	   *        An array with actor IDs to release.
	   */
	  releaseMany: DebuggerClient.requester({
	    type: "releaseMany",
	    actors: args(0),
	  }, {
	    telemetry: "RELEASEMANY"
	  }),
	
	  /**
	   * Promote multiple pause-lifetime object actors to thread-lifetime ones.
	   *
	   * @param array actors
	   *        An array with actor IDs to promote.
	   */
	  threadGrips: DebuggerClient.requester({
	    type: "threadGrips",
	    actors: args(0)
	  }, {
	    telemetry: "THREADGRIPS"
	  }),
	
	  /**
	   * Return the event listeners defined on the page.
	   *
	   * @param aOnResponse Function
	   *        Called with the thread's response.
	   */
	  eventListeners: DebuggerClient.requester({
	    type: "eventListeners"
	  }, {
	    telemetry: "EVENTLISTENERS"
	  }),
	
	  /**
	   * Request the loaded sources for the current thread.
	   *
	   * @param aOnResponse Function
	   *        Called with the thread's response.
	   */
	  getSources: DebuggerClient.requester({
	    type: "sources"
	  }, {
	    telemetry: "SOURCES"
	  }),
	
	  /**
	   * Clear the thread's source script cache. A scriptscleared event
	   * will be sent.
	   */
	  _clearScripts: function() {
	    if (Object.keys(this._scriptCache).length > 0) {
	      this._scriptCache = {};
	      this.emit("scriptscleared");
	    }
	  },
	
	  /**
	   * Request frames from the callstack for the current thread.
	   *
	   * @param aStart integer
	   *        The number of the youngest stack frame to return (the youngest
	   *        frame is 0).
	   * @param aCount integer
	   *        The maximum number of frames to return, or null to return all
	   *        frames.
	   * @param aOnResponse function
	   *        Called with the thread's response.
	   */
	  getFrames: DebuggerClient.requester({
	    type: "frames",
	    start: args(0),
	    count: args(1)
	  }, {
	    telemetry: "FRAMES"
	  }),
	
	  /**
	   * An array of cached frames. Clients can observe the framesadded and
	   * framescleared event to keep up to date on changes to this cache,
	   * and can fill it using the fillFrames method.
	   */
	  get cachedFrames() { return this._frameCache; },
	
	  /**
	   * true if there are more stack frames available on the server.
	   */
	  get moreFrames() {
	    return this.paused && (!this._frameCache || this._frameCache.length == 0
	          || !this._frameCache[this._frameCache.length - 1].oldest);
	  },
	
	  /**
	   * Ensure that at least aTotal stack frames have been loaded in the
	   * ThreadClient's stack frame cache. A framesadded event will be
	   * sent when the stack frame cache is updated.
	   *
	   * @param aTotal number
	   *        The minimum number of stack frames to be included.
	   * @param aCallback function
	   *        Optional callback function called when frames have been loaded
	   * @returns true if a framesadded notification should be expected.
	   */
	  fillFrames: function(aTotal, aCallback = noop) {
	    this._assertPaused("fillFrames");
	    if (this._frameCache.length >= aTotal) {
	      return false;
	    }
	
	    let numFrames = this._frameCache.length;
	
	    this.getFrames(numFrames, aTotal - numFrames, (aResponse) => {
	      if (aResponse.error) {
	        aCallback(aResponse);
	        return;
	      }
	
	      let threadGrips = DevToolsUtils.values(this._threadGrips);
	
	      for (let i in aResponse.frames) {
	        let frame = aResponse.frames[i];
	        if (!frame.where.source) {
	          // Older servers use urls instead, so we need to resolve
	          // them to source actors
	          for (let grip of threadGrips) {
	            if (grip instanceof SourceClient && grip.url === frame.url) {
	              frame.where.source = grip._form;
	            }
	          }
	        }
	
	        this._frameCache[frame.depth] = frame;
	      }
	
	      // If we got as many frames as we asked for, there might be more
	      // frames available.
	      this.emit("framesadded");
	
	      aCallback(aResponse);
	    });
	
	    return true;
	  },
	
	  /**
	   * Clear the thread's stack frame cache. A framescleared event
	   * will be sent.
	   */
	  _clearFrames: function() {
	    if (this._frameCache.length > 0) {
	      this._frameCache = [];
	      this.emit("framescleared");
	    }
	  },
	
	  /**
	   * Return a ObjectClient object for the given object grip.
	   *
	   * @param aGrip object
	   *        A pause-lifetime object grip returned by the protocol.
	   */
	  pauseGrip: function(aGrip) {
	    if (aGrip.actor in this._pauseGrips) {
	      return this._pauseGrips[aGrip.actor];
	    }
	
	    let client = new ObjectClient(this.client, aGrip);
	    this._pauseGrips[aGrip.actor] = client;
	    return client;
	  },
	
	  /**
	   * Get or create a long string client, checking the grip client cache if it
	   * already exists.
	   *
	   * @param aGrip Object
	   *        The long string grip returned by the protocol.
	   * @param aGripCacheName String
	   *        The property name of the grip client cache to check for existing
	   *        clients in.
	   */
	  _longString: function(aGrip, aGripCacheName) {
	    if (aGrip.actor in this[aGripCacheName]) {
	      return this[aGripCacheName][aGrip.actor];
	    }
	
	    let client = new LongStringClient(this.client, aGrip);
	    this[aGripCacheName][aGrip.actor] = client;
	    return client;
	  },
	
	  /**
	   * Return an instance of LongStringClient for the given long string grip that
	   * is scoped to the current pause.
	   *
	   * @param aGrip Object
	   *        The long string grip returned by the protocol.
	   */
	  pauseLongString: function(aGrip) {
	    return this._longString(aGrip, "_pauseGrips");
	  },
	
	  /**
	   * Return an instance of LongStringClient for the given long string grip that
	   * is scoped to the thread lifetime.
	   *
	   * @param aGrip Object
	   *        The long string grip returned by the protocol.
	   */
	  threadLongString: function(aGrip) {
	    return this._longString(aGrip, "_threadGrips");
	  },
	
	  /**
	   * Clear and invalidate all the grip clients from the given cache.
	   *
	   * @param aGripCacheName
	   *        The property name of the grip cache we want to clear.
	   */
	  _clearObjectClients: function(aGripCacheName) {
	    for (let id in this[aGripCacheName]) {
	      this[aGripCacheName][id].valid = false;
	    }
	    this[aGripCacheName] = {};
	  },
	
	  /**
	   * Invalidate pause-lifetime grip clients and clear the list of current grip
	   * clients.
	   */
	  _clearPauseGrips: function() {
	    this._clearObjectClients("_pauseGrips");
	  },
	
	  /**
	   * Invalidate thread-lifetime grip clients and clear the list of current grip
	   * clients.
	   */
	  _clearThreadGrips: function() {
	    this._clearObjectClients("_threadGrips");
	  },
	
	  /**
	   * Handle thread state change by doing necessary cleanup and notifying all
	   * registered listeners.
	   */
	  _onThreadState: function(aPacket) {
	    this._state = ThreadStateTypes[aPacket.type];
	    // The debugger UI may not be initialized yet so we want to keep
	    // the packet around so it knows what to pause state to display
	    // when it's initialized
	    this._lastPausePacket = aPacket.type === "resumed" ? null : aPacket;
	    this._clearFrames();
	    this._clearPauseGrips();
	    aPacket.type === ThreadStateTypes.detached && this._clearThreadGrips();
	    this.client._eventsEnabled && this.emit(aPacket.type, aPacket);
	  },
	
	  getLastPausePacket: function() {
	    return this._lastPausePacket;
	  },
	
	  /**
	   * Return an EnvironmentClient instance for the given environment actor form.
	   */
	  environment: function(aForm) {
	    return new EnvironmentClient(this.client, aForm);
	  },
	
	  /**
	   * Return an instance of SourceClient for the given source actor form.
	   */
	  source: function(aForm) {
	    if (aForm.actor in this._threadGrips) {
	      return this._threadGrips[aForm.actor];
	    }
	
	    return this._threadGrips[aForm.actor] = new SourceClient(this, aForm);
	  },
	
	  /**
	   * Request the prototype and own properties of mutlipleObjects.
	   *
	   * @param aOnResponse function
	   *        Called with the request's response.
	   * @param actors [string]
	   *        List of actor ID of the queried objects.
	   */
	  getPrototypesAndProperties: DebuggerClient.requester({
	    type: "prototypesAndProperties",
	    actors: args(0)
	  }, {
	    telemetry: "PROTOTYPESANDPROPERTIES"
	  }),
	
	  events: ["newSource"]
	};
	
	eventSource(ThreadClient.prototype);
	
	/**
	 * Creates a tracing profiler client for the remote debugging protocol
	 * server. This client is a front to the trace actor created on the
	 * server side, hiding the protocol details in a traditional
	 * JavaScript API.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aActor string
	 *        The actor ID for this thread.
	 */
	function TraceClient(aClient, aActor) {
	  this._client = aClient;
	  this._actor = aActor;
	  this._activeTraces = new Set();
	  this._waitingPackets = new Map();
	  this._expectedPacket = 0;
	  this.request = this._client.request;
	  this.events = [];
	}
	
	TraceClient.prototype = {
	  get actor() { return this._actor; },
	  get tracing() { return this._activeTraces.size > 0; },
	
	  get _transport() { return this._client._transport; },
	
	  /**
	   * Detach from the trace actor.
	   */
	  detach: DebuggerClient.requester({
	    type: "detach"
	  }, {
	    after: function(aResponse) {
	      this._client.unregisterClient(this);
	      return aResponse;
	    },
	    telemetry: "TRACERDETACH"
	  }),
	
	  /**
	   * Start a new trace.
	   *
	   * @param aTrace [string]
	   *        An array of trace types to be recorded by the new trace.
	   *
	   * @param aName string
	   *        The name of the new trace.
	   *
	   * @param aOnResponse function
	   *        Called with the request's response.
	   */
	  startTrace: DebuggerClient.requester({
	    type: "startTrace",
	    name: args(1),
	    trace: args(0)
	  }, {
	    after: function(aResponse) {
	      if (aResponse.error) {
	        return aResponse;
	      }
	
	      if (!this.tracing) {
	        this._waitingPackets.clear();
	        this._expectedPacket = 0;
	      }
	      this._activeTraces.add(aResponse.name);
	
	      return aResponse;
	    },
	    telemetry: "STARTTRACE"
	  }),
	
	  /**
	   * End a trace. If a name is provided, stop the named
	   * trace. Otherwise, stop the most recently started trace.
	   *
	   * @param aName string
	   *        The name of the trace to stop.
	   *
	   * @param aOnResponse function
	   *        Called with the request's response.
	   */
	  stopTrace: DebuggerClient.requester({
	    type: "stopTrace",
	    name: args(0)
	  }, {
	    after: function(aResponse) {
	      if (aResponse.error) {
	        return aResponse;
	      }
	
	      this._activeTraces.delete(aResponse.name);
	
	      return aResponse;
	    },
	    telemetry: "STOPTRACE"
	  })
	};
	
	/**
	 * Grip clients are used to retrieve information about the relevant object.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aGrip object
	 *        A pause-lifetime object grip returned by the protocol.
	 */
	function ObjectClient(aClient, aGrip)
	{
	  this._grip = aGrip;
	  this._client = aClient;
	  this.request = this._client.request;
	}
	exports.ObjectClient = ObjectClient;
	
	ObjectClient.prototype = {
	  get actor() { return this._grip.actor; },
	  get _transport() { return this._client._transport; },
	
	  valid: true,
	
	  get isFrozen() {
	    return this._grip.frozen;
	  },
	  get isSealed() {
	    return this._grip.sealed;
	  },
	  get isExtensible() {
	    return this._grip.extensible;
	  },
	
	  getDefinitionSite: DebuggerClient.requester({
	    type: "definitionSite"
	  }, {
	    before: function(aPacket) {
	      if (this._grip.class != "Function") {
	        throw new Error("getDefinitionSite is only valid for function grips.");
	      }
	      return aPacket;
	    }
	  }),
	
	  /**
	   * Request the names of a function's formal parameters.
	   *
	   * @param aOnResponse function
	   *        Called with an object of the form:
	   *        { parameterNames:[<parameterName>, ...] }
	   *        where each <parameterName> is the name of a parameter.
	   */
	  getParameterNames: DebuggerClient.requester({
	    type: "parameterNames"
	  }, {
	    before: function(aPacket) {
	      if (this._grip.class !== "Function") {
	        throw new Error("getParameterNames is only valid for function grips.");
	      }
	      return aPacket;
	    },
	    telemetry: "PARAMETERNAMES"
	  }),
	
	  /**
	   * Request the names of the properties defined on the object and not its
	   * prototype.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getOwnPropertyNames: DebuggerClient.requester({
	    type: "ownPropertyNames"
	  }, {
	    telemetry: "OWNPROPERTYNAMES"
	  }),
	
	  /**
	   * Request the prototype and own properties of the object.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getPrototypeAndProperties: DebuggerClient.requester({
	    type: "prototypeAndProperties"
	  }, {
	    telemetry: "PROTOTYPEANDPROPERTIES"
	  }),
	
	  /**
	   * Request a PropertyIteratorClient instance to ease listing
	   * properties for this object.
	   *
	   * @param options Object
	   *        A dictionary object with various boolean attributes:
	   *        - ignoreSafeGetters Boolean
	   *          If true, do not iterate over safe getters.
	   *        - ignoreIndexedProperties Boolean
	   *          If true, filters out Array items.
	   *          e.g. properties names between `0` and `object.length`.
	   *        - ignoreNonIndexedProperties Boolean
	   *          If true, filters out items that aren't array items
	   *          e.g. properties names that are not a number between `0`
	   *          and `object.length`.
	   *        - sort Boolean
	   *          If true, the iterator will sort the properties by name
	   *          before dispatching them.
	   * @param aOnResponse function Called with the client instance.
	   */
	  enumProperties: DebuggerClient.requester({
	    type: "enumProperties",
	    options: args(0)
	  }, {
	    after: function(aResponse) {
	      if (aResponse.iterator) {
	        return { iterator: new PropertyIteratorClient(this._client, aResponse.iterator) };
	      }
	      return aResponse;
	    },
	    telemetry: "ENUMPROPERTIES"
	  }),
	
	  /**
	   * Request a PropertyIteratorClient instance to enumerate entries in a
	   * Map/Set-like object.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  enumEntries: DebuggerClient.requester({
	    type: "enumEntries"
	  }, {
	    before: function(packet) {
	      if (!["Map", "WeakMap", "Set", "WeakSet"].includes(this._grip.class)) {
	        throw new Error("enumEntries is only valid for Map/Set-like grips.");
	      }
	      return packet;
	    },
	    after: function(response) {
	      if (response.iterator) {
	        return {
	          iterator: new PropertyIteratorClient(this._client, response.iterator)
	        };
	      }
	      return response;
	    }
	  }),
	
	  /**
	   * Request the property descriptor of the object's specified property.
	   *
	   * @param aName string The name of the requested property.
	   * @param aOnResponse function Called with the request's response.
	   */
	  getProperty: DebuggerClient.requester({
	    type: "property",
	    name: args(0)
	  }, {
	    telemetry: "PROPERTY"
	  }),
	
	  /**
	   * Request the prototype of the object.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getPrototype: DebuggerClient.requester({
	    type: "prototype"
	  }, {
	    telemetry: "PROTOTYPE"
	  }),
	
	  /**
	   * Request the display string of the object.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getDisplayString: DebuggerClient.requester({
	    type: "displayString"
	  }, {
	    telemetry: "DISPLAYSTRING"
	  }),
	
	  /**
	   * Request the scope of the object.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getScope: DebuggerClient.requester({
	    type: "scope"
	  }, {
	    before: function(aPacket) {
	      if (this._grip.class !== "Function") {
	        throw new Error("scope is only valid for function grips.");
	      }
	      return aPacket;
	    },
	    telemetry: "SCOPE"
	  }),
	
	  /**
	   * Request the promises directly depending on the current promise.
	   */
	  getDependentPromises: DebuggerClient.requester({
	    type: "dependentPromises"
	  }, {
	    before: function(aPacket) {
	      if (this._grip.class !== "Promise") {
	        throw new Error("getDependentPromises is only valid for promise " +
	          "grips.");
	      }
	      return aPacket;
	    }
	  }),
	
	  /**
	   * Request the stack to the promise's allocation point.
	   */
	  getPromiseAllocationStack: DebuggerClient.requester({
	    type: "allocationStack"
	  }, {
	    before: function(aPacket) {
	      if (this._grip.class !== "Promise") {
	        throw new Error("getAllocationStack is only valid for promise grips.");
	      }
	      return aPacket;
	    }
	  }),
	
	  /**
	   * Request the stack to the promise's fulfillment point.
	   */
	  getPromiseFulfillmentStack: DebuggerClient.requester({
	    type: "fulfillmentStack"
	  }, {
	    before: function(packet) {
	      if (this._grip.class !== "Promise") {
	        throw new Error("getPromiseFulfillmentStack is only valid for " +
	          "promise grips.");
	      }
	      return packet;
	    }
	  }),
	
	  /**
	   * Request the stack to the promise's rejection point.
	   */
	  getPromiseRejectionStack: DebuggerClient.requester({
	    type: "rejectionStack"
	  }, {
	    before: function(packet) {
	      if (this._grip.class !== "Promise") {
	        throw new Error("getPromiseRejectionStack is only valid for " +
	          "promise grips.");
	      }
	      return packet;
	    }
	  })
	};
	
	/**
	 * A PropertyIteratorClient provides a way to access to property names and
	 * values of an object efficiently, slice by slice.
	 * Note that the properties can be sorted in the backend,
	 * this is controled while creating the PropertyIteratorClient
	 * from ObjectClient.enumProperties.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aGrip Object
	 *        A PropertyIteratorActor grip returned by the protocol via
	 *        TabActor.enumProperties request.
	 */
	function PropertyIteratorClient(aClient, aGrip) {
	  this._grip = aGrip;
	  this._client = aClient;
	  this.request = this._client.request;
	}
	
	PropertyIteratorClient.prototype = {
	  get actor() { return this._grip.actor; },
	
	  /**
	   * Get the total number of properties available in the iterator.
	   */
	  get count() { return this._grip.count; },
	
	  /**
	   * Get one or more property names that correspond to the positions in the
	   * indexes parameter.
	   *
	   * @param indexes Array
	   *        An array of property indexes.
	   * @param aCallback Function
	   *        The function called when we receive the property names.
	   */
	  names: DebuggerClient.requester({
	    type: "names",
	    indexes: args(0)
	  }, {}),
	
	  /**
	   * Get a set of following property value(s).
	   *
	   * @param start Number
	   *        The index of the first property to fetch.
	   * @param count Number
	   *        The number of properties to fetch.
	   * @param aCallback Function
	   *        The function called when we receive the property values.
	   */
	  slice: DebuggerClient.requester({
	    type: "slice",
	    start: args(0),
	    count: args(1)
	  }, {}),
	
	  /**
	   * Get all the property values.
	   *
	   * @param aCallback Function
	   *        The function called when we receive the property values.
	   */
	  all: DebuggerClient.requester({
	    type: "all"
	  }, {}),
	};
	
	/**
	 * A LongStringClient provides a way to access "very long" strings from the
	 * debugger server.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aGrip Object
	 *        A pause-lifetime long string grip returned by the protocol.
	 */
	function LongStringClient(aClient, aGrip) {
	  this._grip = aGrip;
	  this._client = aClient;
	  this.request = this._client.request;
	}
	exports.LongStringClient = LongStringClient;
	
	LongStringClient.prototype = {
	  get actor() { return this._grip.actor; },
	  get length() { return this._grip.length; },
	  get initial() { return this._grip.initial; },
	  get _transport() { return this._client._transport; },
	
	  valid: true,
	
	  /**
	   * Get the substring of this LongString from aStart to aEnd.
	   *
	   * @param aStart Number
	   *        The starting index.
	   * @param aEnd Number
	   *        The ending index.
	   * @param aCallback Function
	   *        The function called when we receive the substring.
	   */
	  substring: DebuggerClient.requester({
	    type: "substring",
	    start: args(0),
	    end: args(1)
	  }, {
	    telemetry: "SUBSTRING"
	  }),
	};
	
	/**
	 * A SourceClient provides a way to access the source text of a script.
	 *
	 * @param aClient ThreadClient
	 *        The thread client parent.
	 * @param aForm Object
	 *        The form sent across the remote debugging protocol.
	 */
	function SourceClient(aClient, aForm) {
	  this._form = aForm;
	  this._isBlackBoxed = aForm.isBlackBoxed;
	  this._isPrettyPrinted = aForm.isPrettyPrinted;
	  this._activeThread = aClient;
	  this._client = aClient.client;
	}
	
	SourceClient.prototype = {
	  get _transport() {
	    return this._client._transport;
	  },
	  get isBlackBoxed() {
	    return this._isBlackBoxed;
	  },
	  get isPrettyPrinted() {
	    return this._isPrettyPrinted;
	  },
	  get actor() {
	    return this._form.actor;
	  },
	  get request() {
	    return this._client.request;
	  },
	  get url() {
	    return this._form.url;
	  },
	
	  /**
	   * Black box this SourceClient's source.
	   *
	   * @param aCallback Function
	   *        The callback function called when we receive the response from the server.
	   */
	  blackBox: DebuggerClient.requester({
	    type: "blackbox"
	  }, {
	    telemetry: "BLACKBOX",
	    after: function(aResponse) {
	      if (!aResponse.error) {
	        this._isBlackBoxed = true;
	        if (this._activeThread) {
	          this._activeThread.emit("blackboxchange", this);
	        }
	      }
	      return aResponse;
	    }
	  }),
	
	  /**
	   * Un-black box this SourceClient's source.
	   *
	   * @param aCallback Function
	   *        The callback function called when we receive the response from the server.
	   */
	  unblackBox: DebuggerClient.requester({
	    type: "unblackbox"
	  }, {
	    telemetry: "UNBLACKBOX",
	    after: function(aResponse) {
	      if (!aResponse.error) {
	        this._isBlackBoxed = false;
	        if (this._activeThread) {
	          this._activeThread.emit("blackboxchange", this);
	        }
	      }
	      return aResponse;
	    }
	  }),
	
	  /**
	   * Get Executable Lines from a source
	   *
	   * @param aCallback Function
	   *        The callback function called when we receive the response from the server.
	   */
	  getExecutableLines: function(cb = noop) {
	    let packet = {
	      to: this._form.actor,
	      type: "getExecutableLines"
	    };
	
	    return this._client.request(packet).then(res => {
	      cb(res.lines);
	      return res.lines;
	    });
	  },
	
	  /**
	   * Get a long string grip for this SourceClient's source.
	   */
	  source: function(aCallback = noop) {
	    let packet = {
	      to: this._form.actor,
	      type: "source"
	    };
	    return this._client.request(packet).then(aResponse => {
	      return this._onSourceResponse(aResponse, aCallback);
	    });
	  },
	
	  /**
	   * Pretty print this source's text.
	   */
	  prettyPrint: function(aIndent, aCallback = noop) {
	    const packet = {
	      to: this._form.actor,
	      type: "prettyPrint",
	      indent: aIndent
	    };
	    return this._client.request(packet).then(aResponse => {
	      if (!aResponse.error) {
	        this._isPrettyPrinted = true;
	        this._activeThread._clearFrames();
	        this._activeThread.emit("prettyprintchange", this);
	      }
	      return this._onSourceResponse(aResponse, aCallback);
	    });
	  },
	
	  /**
	   * Stop pretty printing this source's text.
	   */
	  disablePrettyPrint: function(aCallback = noop) {
	    const packet = {
	      to: this._form.actor,
	      type: "disablePrettyPrint"
	    };
	    return this._client.request(packet).then(aResponse => {
	      if (!aResponse.error) {
	        this._isPrettyPrinted = false;
	        this._activeThread._clearFrames();
	        this._activeThread.emit("prettyprintchange", this);
	      }
	      return this._onSourceResponse(aResponse, aCallback);
	    });
	  },
	
	  _onSourceResponse: function(aResponse, aCallback) {
	    if (aResponse.error) {
	      aCallback(aResponse);
	      return aResponse;
	    }
	
	    if (typeof aResponse.source === "string") {
	      aCallback(aResponse);
	      return aResponse;
	    }
	
	    let { contentType, source } = aResponse;
	    let longString = this._activeThread.threadLongString(source);
	    return longString.substring(0, longString.length).then(function(aResponse) {
	      if (aResponse.error) {
	        aCallback(aResponse);
	        return aReponse;
	      }
	
	      let response = {
	        source: aResponse.substring,
	        contentType: contentType
	      };
	      aCallback(response);
	      return response;
	    });
	  },
	
	  /**
	   * Request to set a breakpoint in the specified location.
	   *
	   * @param object aLocation
	   *        The location and condition of the breakpoint in
	   *        the form of { line[, column, condition] }.
	   * @param function aOnResponse
	   *        Called with the thread's response.
	   */
	  setBreakpoint: function({ line, column, condition, noSliding }, aOnResponse = noop) {
	    // A helper function that sets the breakpoint.
	    let doSetBreakpoint = aCallback => {
	      let root = this._client.mainRoot;
	      let location = {
	        line: line,
	        column: column
	      };
	
	      let packet = {
	        to: this.actor,
	        type: "setBreakpoint",
	        location: location,
	        condition: condition,
	        noSliding: noSliding
	      };
	
	      // Backwards compatibility: send the breakpoint request to the
	      // thread if the server doesn't support Debugger.Source actors.
	      if (!root.traits.debuggerSourceActors) {
	        packet.to = this._activeThread.actor;
	        packet.location.url = this.url;
	      }
	
	      return this._client.request(packet).then(aResponse => {
	        // Ignoring errors, since the user may be setting a breakpoint in a
	        // dead script that will reappear on a page reload.
	        let bpClient;
	        if (aResponse.actor) {
	          bpClient = new BreakpointClient(
	            this._client,
	            this,
	            aResponse.actor,
	            location,
	            root.traits.conditionalBreakpoints ? condition : undefined
	          );
	        }
	        aOnResponse(aResponse, bpClient);
	        if (aCallback) {
	          aCallback();
	        }
	        return [aResponse, bpClient];
	      });
	    };
	
	    // If the debuggee is paused, just set the breakpoint.
	    if (this._activeThread.paused) {
	      return doSetBreakpoint();
	    }
	    // Otherwise, force a pause in order to set the breakpoint.
	    return this._activeThread.interrupt().then(aResponse => {
	      if (aResponse.error) {
	        // Can't set the breakpoint if pausing failed.
	        aOnResponse(aResponse);
	        return aResponse;
	      }
	
	      const { type, why } = aResponse;
	      const cleanUp = type == "paused" && why.type == "interrupted"
	            ? () => this._activeThread.resume()
	            : noop;
	
	      return doSetBreakpoint(cleanUp);
	    });
	  }
	};
	
	/**
	 * Breakpoint clients are used to remove breakpoints that are no longer used.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aSourceClient SourceClient
	 *        The source where this breakpoint exists
	 * @param aActor string
	 *        The actor ID for this breakpoint.
	 * @param aLocation object
	 *        The location of the breakpoint. This is an object with two properties:
	 *        url and line.
	 * @param aCondition string
	 *        The conditional expression of the breakpoint
	 */
	function BreakpointClient(aClient, aSourceClient, aActor, aLocation, aCondition) {
	  this._client = aClient;
	  this._actor = aActor;
	  this.location = aLocation;
	  this.location.actor = aSourceClient.actor;
	  this.location.url = aSourceClient.url;
	  this.source = aSourceClient;
	  this.request = this._client.request;
	
	  // The condition property should only exist if it's a truthy value
	  if (aCondition) {
	    this.condition = aCondition;
	  }
	}
	
	BreakpointClient.prototype = {
	
	  _actor: null,
	  get actor() { return this._actor; },
	  get _transport() { return this._client._transport; },
	
	  /**
	   * Remove the breakpoint from the server.
	   */
	  remove: DebuggerClient.requester({
	    type: "delete"
	  }, {
	    telemetry: "DELETE"
	  }),
	
	  /**
	   * Determines if this breakpoint has a condition
	   */
	  hasCondition: function() {
	    let root = this._client.mainRoot;
	    // XXX bug 990137: We will remove support for client-side handling of
	    // conditional breakpoints
	    if (root.traits.conditionalBreakpoints) {
	      return "condition" in this;
	    } else {
	      return "conditionalExpression" in this;
	    }
	  },
	
	  /**
	   * Get the condition of this breakpoint. Currently we have to
	   * support locally emulated conditional breakpoints until the
	   * debugger servers are updated (see bug 990137). We used a
	   * different property when moving it server-side to ensure that we
	   * are testing the right code.
	   */
	  getCondition: function() {
	    let root = this._client.mainRoot;
	    if (root.traits.conditionalBreakpoints) {
	      return this.condition;
	    } else {
	      return this.conditionalExpression;
	    }
	  },
	
	  /**
	   * Set the condition of this breakpoint
	   */
	  setCondition: function(gThreadClient, aCondition, noSliding) {
	    let root = this._client.mainRoot;
	    let deferred = promise.defer();
	
	    if (root.traits.conditionalBreakpoints) {
	      let info = {
	        line: this.location.line,
	        column: this.location.column,
	        condition: aCondition,
	        noSliding
	      };
	
	      // Remove the current breakpoint and add a new one with the
	      // condition.
	      this.remove(aResponse => {
	        if (aResponse && aResponse.error) {
	          deferred.reject(aResponse);
	          return;
	        }
	
	        this.source.setBreakpoint(info, (aResponse, aNewBreakpoint) => {
	          if (aResponse && aResponse.error) {
	            deferred.reject(aResponse);
	          } else {
	            deferred.resolve(aNewBreakpoint);
	          }
	        });
	      });
	    } else {
	      // The property shouldn't even exist if the condition is blank
	      if (aCondition === "") {
	        delete this.conditionalExpression;
	      }
	      else {
	        this.conditionalExpression = aCondition;
	      }
	      deferred.resolve(this);
	    }
	
	    return deferred.promise;
	  }
	};
	
	eventSource(BreakpointClient.prototype);
	
	/**
	 * Environment clients are used to manipulate the lexical environment actors.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aForm Object
	 *        The form sent across the remote debugging protocol.
	 */
	function EnvironmentClient(aClient, aForm) {
	  this._client = aClient;
	  this._form = aForm;
	  this.request = this._client.request;
	}
	exports.EnvironmentClient = EnvironmentClient;
	
	EnvironmentClient.prototype = {
	
	  get actor() {
	    return this._form.actor;
	  },
	  get _transport() { return this._client._transport; },
	
	  /**
	   * Fetches the bindings introduced by this lexical environment.
	   */
	  getBindings: DebuggerClient.requester({
	    type: "bindings"
	  }, {
	    telemetry: "BINDINGS"
	  }),
	
	  /**
	   * Changes the value of the identifier whose name is name (a string) to that
	   * represented by value (a grip).
	   */
	  assign: DebuggerClient.requester({
	    type: "assign",
	    name: args(0),
	    value: args(1)
	  }, {
	    telemetry: "ASSIGN"
	  })
	};
	
	eventSource(EnvironmentClient.prototype);


/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";
	
	module.metadata = {
	  "stability": "unstable"
	};
	
	const UNCAUGHT_ERROR = 'An error event was emitted for which there was no listener.';
	const BAD_LISTENER = 'The event listener must be a function.';
	
	const { ns } = __webpack_require__(278);
	
	const event = ns();
	
	const EVENT_TYPE_PATTERN = /^on([A-Z]\w+$)/;
	exports.EVENT_TYPE_PATTERN = EVENT_TYPE_PATTERN;
	
	// Utility function to access given event `target` object's event listeners for
	// the specific event `type`. If listeners for this type does not exists they
	// will be created.
	const observers = function observers(target, type) {
	  if (!target) throw TypeError("Event target must be an object");
	  let listeners = event(target);
	  return type in listeners ? listeners[type] : listeners[type] = [];
	};
	
	/**
	 * Registers an event `listener` that is called every time events of
	 * specified `type` is emitted on the given event `target`.
	 * @param {Object} target
	 *    Event target object.
	 * @param {String} type
	 *    The type of event.
	 * @param {Function} listener
	 *    The listener function that processes the event.
	 */
	function on(target, type, listener) {
	  if (typeof(listener) !== 'function')
	    throw new Error(BAD_LISTENER);
	
	  let listeners = observers(target, type);
	  if (!~listeners.indexOf(listener))
	    listeners.push(listener);
	}
	exports.on = on;
	
	
	var onceWeakMap = new WeakMap();
	
	
	/**
	 * Registers an event `listener` that is called only the next time an event
	 * of the specified `type` is emitted on the given event `target`.
	 * @param {Object} target
	 *    Event target object.
	 * @param {String} type
	 *    The type of the event.
	 * @param {Function} listener
	 *    The listener function that processes the event.
	 */
	function once(target, type, listener) {
	  let replacement = function observer(...args) {
	    off(target, type, observer);
	    onceWeakMap.delete(listener);
	    listener.apply(target, args);
	  };
	  onceWeakMap.set(listener, replacement);
	  on(target, type, replacement);
	}
	exports.once = once;
	
	/**
	 * Execute each of the listeners in order with the supplied arguments.
	 * All the exceptions that are thrown by listeners during the emit
	 * are caught and can be handled by listeners of 'error' event. Thrown
	 * exceptions are passed as an argument to an 'error' event listener.
	 * If no 'error' listener is registered exception will be logged into an
	 * error console.
	 * @param {Object} target
	 *    Event target object.
	 * @param {String} type
	 *    The type of event.
	 * @params {Object|Number|String|Boolean} args
	 *    Arguments that will be passed to listeners.
	 */
	function emit (target, type, ...args) {
	  emitOnObject(target, type, target, ...args);
	}
	exports.emit = emit;
	
	/**
	 * A variant of emit that allows setting the this property for event listeners
	 */
	function emitOnObject(target, type, thisArg, ...args) {
	  let all = observers(target, '*').length;
	  let state = observers(target, type);
	  let listeners = state.slice();
	  let count = listeners.length;
	  let index = 0;
	
	  // If error event and there are no handlers (explicit or catch-all)
	  // then print error message to the console.
	  if (count === 0 && type === 'error' && all === 0)
	    console.exception(args[0]);
	  while (index < count) {
	    try {
	      let listener = listeners[index];
	      // Dispatch only if listener is still registered.
	      if (~state.indexOf(listener))
	        listener.apply(thisArg, args);
	    }
	    catch (error) {
	      // If exception is not thrown by a error listener and error listener is
	      // registered emit `error` event. Otherwise dump exception to the console.
	      if (type !== 'error') emit(target, 'error', error);
	      else console.exception(error);
	    }
	    index++;
	  }
	   // Also emit on `"*"` so that one could listen for all events.
	  if (type !== '*') emit(target, '*', type, ...args);
	}
	exports.emitOnObject = emitOnObject;
	
	/**
	 * Removes an event `listener` for the given event `type` on the given event
	 * `target`. If no `listener` is passed removes all listeners of the given
	 * `type`. If `type` is not passed removes all the listeners of the given
	 * event `target`.
	 * @param {Object} target
	 *    The event target object.
	 * @param {String} type
	 *    The type of event.
	 * @param {Function} listener
	 *    The listener function that processes the event.
	 */
	function off(target, type, listener) {
	  let length = arguments.length;
	  if (length === 3) {
	    if (onceWeakMap.has(listener)) {
	      listener = onceWeakMap.get(listener);
	      onceWeakMap.delete(listener);
	    }
	
	    let listeners = observers(target, type);
	    let index = listeners.indexOf(listener);
	    if (~index)
	      listeners.splice(index, 1);
	  }
	  else if (length === 2) {
	    observers(target, type).splice(0);
	  }
	  else if (length === 1) {
	    let listeners = event(target);
	    Object.keys(listeners).forEach(type => delete listeners[type]);
	  }
	}
	exports.off = off;
	
	/**
	 * Returns a number of event listeners registered for the given event `type`
	 * on the given event `target`.
	 */
	function count(target, type) {
	  return observers(target, type).length;
	}
	exports.count = count;
	
	/**
	 * Registers listeners on the given event `target` from the given `listeners`
	 * dictionary. Iterates over the listeners and if property name matches name
	 * pattern `onEventType` and property is a function, then registers it as
	 * an `eventType` listener on `target`.
	 *
	 * @param {Object} target
	 *    The type of event.
	 * @param {Object} listeners
	 *    Dictionary of listeners.
	 */
	function setListeners(target, listeners) {
	  Object.keys(listeners || {}).forEach(key => {
	    let match = EVENT_TYPE_PATTERN.exec(key);
	    let type = match && match[1].toLowerCase();
	    if (!type) return;
	
	    let listener = listeners[key];
	    if (typeof(listener) === 'function')
	      on(target, type, listener);
	  });
	}
	exports.setListeners = setListeners;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(51)(module)))

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	"use strict";
	
	module.metadata = {
	  "stability": "unstable"
	};
	
	const create = Object.create;
	const prototypeOf = Object.getPrototypeOf;
	
	/**
	 * Returns a new namespace, function that may can be used to access an
	 * namespaced object of the argument argument. Namespaced object are associated
	 * with owner objects via weak references. Namespaced objects inherit from the
	 * owners ancestor namespaced object. If owner's ancestor is `null` then
	 * namespaced object inherits from given `prototype`. Namespaces can be used
	 * to define internal APIs that can be shared via enclosing `namespace`
	 * function.
	 * @examples
	 *    const internals = ns();
	 *    internals(object).secret = secret;
	 */
	function ns() {
	  const map = new WeakMap();
	  return function namespace(target) {
	    if (!target)        // If `target` is not an object return `target` itself.
	      return target;
	    // If target has no namespaced object yet, create one that inherits from
	    // the target prototype's namespaced object.
	    if (!map.has(target))
	      map.set(target, create(namespace(prototypeOf(target) || null)));
	
	    return map.get(target);
	  };
	};
	
	// `Namespace` is a e4x function in the scope, so we export the function also as
	// `ns` as alias to avoid clashing.
	exports.ns = ns;
	exports.Namespace = ns;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(51)(module)))

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- js-indent-level: 2; indent-tabs-mode: nil -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	"use strict";
	
	const {Cc, Ci, Cu} = __webpack_require__(259);
	const DevToolsUtils = __webpack_require__(266);
	const EventEmitter = __webpack_require__(258);
	const promise = __webpack_require__(264);
	const {LongStringClient} = __webpack_require__(276);
	
	/**
	 * A WebConsoleClient is used as a front end for the WebConsoleActor that is
	 * created on the server, hiding implementation details.
	 *
	 * @param object aDebuggerClient
	 *        The DebuggerClient instance we live for.
	 * @param object aResponse
	 *        The response packet received from the "startListeners" request sent to
	 *        the WebConsoleActor.
	 */
	function WebConsoleClient(aDebuggerClient, aResponse)
	{
	  this._actor = aResponse.from;
	  this._client = aDebuggerClient;
	  this._longStrings = {};
	  this.traits = aResponse.traits || {};
	  this.events = [];
	  this._networkRequests = new Map();
	
	  this.pendingEvaluationResults = new Map();
	  this.onEvaluationResult = this.onEvaluationResult.bind(this);
	  this.onNetworkEvent = this._onNetworkEvent.bind(this);
	  this.onNetworkEventUpdate = this._onNetworkEventUpdate.bind(this);
	
	  this._client.addListener("evaluationResult", this.onEvaluationResult);
	  this._client.addListener("networkEvent", this.onNetworkEvent);
	  this._client.addListener("networkEventUpdate", this.onNetworkEventUpdate);
	  EventEmitter.decorate(this);
	}
	
	exports.WebConsoleClient = WebConsoleClient;
	
	WebConsoleClient.prototype = {
	  _longStrings: null,
	  traits: null,
	
	  /**
	   * Holds the network requests currently displayed by the Web Console. Each key
	   * represents the connection ID and the value is network request information.
	   * @private
	   * @type object
	   */
	  _networkRequests: null,
	
	  getNetworkRequest(actorId) {
	    return this._networkRequests.get(actorId);
	  },
	
	  hasNetworkRequest(actorId) {
	    return this._networkRequests.has(actorId);
	  },
	
	  removeNetworkRequest(actorId) {
	    this._networkRequests.delete(actorId);
	  },
	
	  getNetworkEvents() {
	    return this._networkRequests.values();
	  },
	
	  get actor() { return this._actor; },
	
	  /**
	   * The "networkEvent" message type handler. We redirect any message to
	   * the UI for displaying.
	   *
	   * @private
	   * @param string type
	   *        Message type.
	   * @param object packet
	   *        The message received from the server.
	   */
	  _onNetworkEvent: function (type, packet)
	  {
	    if (packet.from == this._actor) {
	      let actor = packet.eventActor;
	      let networkInfo = {
	        _type: "NetworkEvent",
	        timeStamp: actor.timeStamp,
	        node: null,
	        actor: actor.actor,
	        discardRequestBody: true,
	        discardResponseBody: true,
	        startedDateTime: actor.startedDateTime,
	        request: {
	          url: actor.url,
	          method: actor.method,
	        },
	        isXHR: actor.isXHR,
	        response: {},
	        timings: {},
	        updates: [], // track the list of network event updates
	        private: actor.private,
	        fromCache: actor.fromCache
	      };
	      this._networkRequests.set(actor.actor, networkInfo);
	
	      this.emit("networkEvent", networkInfo);
	    }
	  },
	
	  /**
	   * The "networkEventUpdate" message type handler. We redirect any message to
	   * the UI for displaying.
	   *
	   * @private
	   * @param string type
	   *        Message type.
	   * @param object packet
	   *        The message received from the server.
	   */
	  _onNetworkEventUpdate: function (type, packet)
	  {
	    let networkInfo = this.getNetworkRequest(packet.from);
	    if (!networkInfo) {
	      return;
	    }
	
	    networkInfo.updates.push(packet.updateType);
	
	    switch (packet.updateType) {
	      case "requestHeaders":
	        networkInfo.request.headersSize = packet.headersSize;
	        break;
	      case "requestPostData":
	        networkInfo.discardRequestBody = packet.discardRequestBody;
	        networkInfo.request.bodySize = packet.dataSize;
	        break;
	      case "responseStart":
	        networkInfo.response.httpVersion = packet.response.httpVersion;
	        networkInfo.response.status = packet.response.status;
	        networkInfo.response.statusText = packet.response.statusText;
	        networkInfo.response.headersSize = packet.response.headersSize;
	        networkInfo.response.remoteAddress = packet.response.remoteAddress;
	        networkInfo.response.remotePort = packet.response.remotePort;
	        networkInfo.discardResponseBody = packet.response.discardResponseBody;
	        break;
	      case "responseContent":
	        networkInfo.response.content = {
	          mimeType: packet.mimeType,
	        };
	        networkInfo.response.bodySize = packet.contentSize;
	        networkInfo.response.transferredSize = packet.transferredSize;
	        networkInfo.discardResponseBody = packet.discardResponseBody;
	        break;
	      case "eventTimings":
	        networkInfo.totalTime = packet.totalTime;
	        break;
	      case "securityInfo":
	        networkInfo.securityInfo = packet.state;
	        break;
	    }
	
	    this.emit("networkEventUpdate", {
	      packet: packet,
	      networkInfo
	    });
	  },
	
	  /**
	   * Retrieve the cached messages from the server.
	   *
	   * @see this.CACHED_MESSAGES
	   * @param array types
	   *        The array of message types you want from the server. See
	   *        this.CACHED_MESSAGES for known types.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getCachedMessages: function WCC_getCachedMessages(types, aOnResponse)
	  {
	    let packet = {
	      to: this._actor,
	      type: "getCachedMessages",
	      messageTypes: types,
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Inspect the properties of an object.
	   *
	   * @param string aActor
	   *        The WebConsoleObjectActor ID to send the request to.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  inspectObjectProperties:
	  function WCC_inspectObjectProperties(aActor, aOnResponse)
	  {
	    let packet = {
	      to: aActor,
	      type: "inspectProperties",
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Evaluate a JavaScript expression.
	   *
	   * @param string aString
	   *        The code you want to evaluate.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   * @param object [aOptions={}]
	   *        Options for evaluation:
	   *
	   *        - bindObjectActor: an ObjectActor ID. The OA holds a reference to
	   *        a Debugger.Object that wraps a content object. This option allows
	   *        you to bind |_self| to the D.O of the given OA, during string
	   *        evaluation.
	   *
	   *        See: Debugger.Object.executeInGlobalWithBindings() for information
	   *        about bindings.
	   *
	   *        Use case: the variable view needs to update objects and it does so
	   *        by knowing the ObjectActor it inspects and binding |_self| to the
	   *        D.O of the OA. As such, variable view sends strings like these for
	   *        eval:
	   *          _self["prop"] = value;
	   *
	   *        - frameActor: a FrameActor ID. The FA holds a reference to
	   *        a Debugger.Frame. This option allows you to evaluate the string in
	   *        the frame of the given FA.
	   *
	   *        - url: the url to evaluate the script as. Defaults to
	   *        "debugger eval code".
	   *
	   *        - selectedNodeActor: the NodeActor ID of the current selection in the
	   *        Inspector, if such a selection exists. This is used by helper functions
	   *        that can reference the currently selected node in the Inspector, like
	   *        $0.
	   */
	  evaluateJS: function WCC_evaluateJS(aString, aOnResponse, aOptions = {})
	  {
	    let packet = {
	      to: this._actor,
	      type: "evaluateJS",
	      text: aString,
	      bindObjectActor: aOptions.bindObjectActor,
	      frameActor: aOptions.frameActor,
	      url: aOptions.url,
	      selectedNodeActor: aOptions.selectedNodeActor,
	      selectedObjectActor: aOptions.selectedObjectActor,
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Evaluate a JavaScript expression asynchronously.
	   * See evaluateJS for parameter and response information.
	   */
	  evaluateJSAsync: function(aString, aOnResponse, aOptions = {})
	  {
	    // Pre-37 servers don't support async evaluation.
	    if (!this.traits.evaluateJSAsync) {
	      this.evaluateJS(aString, aOnResponse, aOptions);
	      return;
	    }
	
	    let packet = {
	      to: this._actor,
	      type: "evaluateJSAsync",
	      text: aString,
	      bindObjectActor: aOptions.bindObjectActor,
	      frameActor: aOptions.frameActor,
	      url: aOptions.url,
	      selectedNodeActor: aOptions.selectedNodeActor,
	      selectedObjectActor: aOptions.selectedObjectActor,
	    };
	
	    this._client.request(packet, response => {
	      // Null check this in case the client has been detached while waiting
	      // for a response.
	      if (this.pendingEvaluationResults) {
	        this.pendingEvaluationResults.set(response.resultID, aOnResponse);
	      }
	    });
	  },
	
	  /**
	   * Handler for the actors's unsolicited evaluationResult packet.
	   */
	  onEvaluationResult: function(aNotification, aPacket) {
	    // The client on the main thread can receive notification packets from
	    // multiple webconsole actors: the one on the main thread and the ones
	    // on worker threads.  So make sure we should be handling this request.
	    if (aPacket.from !== this._actor) {
	      return;
	    }
	
	    // Find the associated callback based on this ID, and fire it.
	    // In a sync evaluation, this would have already been called in
	    // direct response to the client.request function.
	    let onResponse = this.pendingEvaluationResults.get(aPacket.resultID);
	    if (onResponse) {
	      onResponse(aPacket);
	      this.pendingEvaluationResults.delete(aPacket.resultID);
	    } else {
	      DevToolsUtils.reportException("onEvaluationResult",
	        "No response handler for an evaluateJSAsync result (resultID: " + aPacket.resultID + ")");
	    }
	  },
	
	  /**
	   * Autocomplete a JavaScript expression.
	   *
	   * @param string aString
	   *        The code you want to autocomplete.
	   * @param number aCursor
	   *        Cursor location inside the string. Index starts from 0.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   * @param string aFrameActor
	   *        The id of the frame actor that made the call.
	   */
	  autocomplete: function WCC_autocomplete(aString, aCursor, aOnResponse, aFrameActor)
	  {
	    let packet = {
	      to: this._actor,
	      type: "autocomplete",
	      text: aString,
	      cursor: aCursor,
	      frameActor: aFrameActor,
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Clear the cache of messages (page errors and console API calls).
	   */
	  clearMessagesCache: function WCC_clearMessagesCache()
	  {
	    let packet = {
	      to: this._actor,
	      type: "clearMessagesCache",
	    };
	    this._client.request(packet);
	  },
	
	  /**
	   * Get Web Console-related preferences on the server.
	   *
	   * @param array aPreferences
	   *        An array with the preferences you want to retrieve.
	   * @param function [aOnResponse]
	   *        Optional function to invoke when the response is received.
	   */
	  getPreferences: function WCC_getPreferences(aPreferences, aOnResponse)
	  {
	    let packet = {
	      to: this._actor,
	      type: "getPreferences",
	      preferences: aPreferences,
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Set Web Console-related preferences on the server.
	   *
	   * @param object aPreferences
	   *        An object with the preferences you want to change.
	   * @param function [aOnResponse]
	   *        Optional function to invoke when the response is received.
	   */
	  setPreferences: function WCC_setPreferences(aPreferences, aOnResponse)
	  {
	    let packet = {
	      to: this._actor,
	      type: "setPreferences",
	      preferences: aPreferences,
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Retrieve the request headers from the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getRequestHeaders: function WCC_getRequestHeaders(aActor, aOnResponse)
	  {
	    let packet = {
	      to: aActor,
	      type: "getRequestHeaders",
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Retrieve the request cookies from the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getRequestCookies: function WCC_getRequestCookies(aActor, aOnResponse)
	  {
	    let packet = {
	      to: aActor,
	      type: "getRequestCookies",
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Retrieve the request post data from the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getRequestPostData: function WCC_getRequestPostData(aActor, aOnResponse)
	  {
	    let packet = {
	      to: aActor,
	      type: "getRequestPostData",
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Retrieve the response headers from the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getResponseHeaders: function WCC_getResponseHeaders(aActor, aOnResponse)
	  {
	    let packet = {
	      to: aActor,
	      type: "getResponseHeaders",
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Retrieve the response cookies from the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getResponseCookies: function WCC_getResponseCookies(aActor, aOnResponse)
	  {
	    let packet = {
	      to: aActor,
	      type: "getResponseCookies",
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Retrieve the response content from the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getResponseContent: function WCC_getResponseContent(aActor, aOnResponse)
	  {
	    let packet = {
	      to: aActor,
	      type: "getResponseContent",
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Retrieve the timing information for the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getEventTimings: function WCC_getEventTimings(aActor, aOnResponse)
	  {
	    let packet = {
	      to: aActor,
	      type: "getEventTimings",
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Retrieve the security information for the given NetworkEventActor.
	   *
	   * @param string aActor
	   *        The NetworkEventActor ID.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  getSecurityInfo: function WCC_getSecurityInfo(aActor, aOnResponse)
	  {
	    let packet = {
	      to: aActor,
	      type: "getSecurityInfo",
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Send a HTTP request with the given data.
	   *
	   * @param string aData
	   *        The details of the HTTP request.
	   * @param function aOnResponse
	   *        The function invoked when the response is received.
	   */
	  sendHTTPRequest: function WCC_sendHTTPRequest(aData, aOnResponse) {
	    let packet = {
	      to: this._actor,
	      type: "sendHTTPRequest",
	      request: aData
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Start the given Web Console listeners.
	   *
	   * @see this.LISTENERS
	   * @param array aListeners
	   *        Array of listeners you want to start. See this.LISTENERS for
	   *        known listeners.
	   * @param function aOnResponse
	   *        Function to invoke when the server response is received.
	   */
	  startListeners: function WCC_startListeners(aListeners, aOnResponse)
	  {
	    let packet = {
	      to: this._actor,
	      type: "startListeners",
	      listeners: aListeners,
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Stop the given Web Console listeners.
	   *
	   * @see this.LISTENERS
	   * @param array aListeners
	   *        Array of listeners you want to stop. See this.LISTENERS for
	   *        known listeners.
	   * @param function aOnResponse
	   *        Function to invoke when the server response is received.
	   */
	  stopListeners: function WCC_stopListeners(aListeners, aOnResponse)
	  {
	    let packet = {
	      to: this._actor,
	      type: "stopListeners",
	      listeners: aListeners,
	    };
	    this._client.request(packet, aOnResponse);
	  },
	
	  /**
	   * Return an instance of LongStringClient for the given long string grip.
	   *
	   * @param object aGrip
	   *        The long string grip returned by the protocol.
	   * @return object
	   *         The LongStringClient for the given long string grip.
	   */
	  longString: function WCC_longString(aGrip)
	  {
	    if (aGrip.actor in this._longStrings) {
	      return this._longStrings[aGrip.actor];
	    }
	
	    let client = new LongStringClient(this._client, aGrip);
	    this._longStrings[aGrip.actor] = client;
	    return client;
	  },
	
	  /**
	   * Close the WebConsoleClient. This stops all the listeners on the server and
	   * detaches from the console actor.
	   *
	   * @param function aOnResponse
	   *        Function to invoke when the server response is received.
	   */
	  detach: function WCC_detach(aOnResponse)
	  {
	    this._client.removeListener("evaluationResult", this.onEvaluationResult);
	    this._client.removeListener("networkEvent", this.onNetworkEvent);
	    this._client.removeListener("networkEventUpdate", this.onNetworkEventUpdate);
	    this.stopListeners(null, aOnResponse);
	    this._longStrings = null;
	    this._client = null;
	    this.pendingEvaluationResults.clear();
	    this.pendingEvaluationResults = null;
	    this.clearNetworkRequests();
	    this._networkRequests = null;
	  },
	
	  clearNetworkRequests: function () {
	    this._networkRequests.clear();
	  },
	
	  /**
	   * Fetches the full text of a LongString.
	   *
	   * @param object | string stringGrip
	   *        The long string grip containing the corresponding actor.
	   *        If you pass in a plain string (by accident or because you're lazy),
	   *        then a promise of the same string is simply returned.
	   * @return object Promise
	   *         A promise that is resolved when the full string contents
	   *         are available, or rejected if something goes wrong.
	   */
	  getString: function(stringGrip) {
	    // Make sure this is a long string.
	    if (typeof stringGrip != "object" || stringGrip.type != "longString") {
	      return promise.resolve(stringGrip); // Go home string, you're drunk.
	    }
	
	    // Fetch the long string only once.
	    if (stringGrip._fullText) {
	      return stringGrip._fullText.promise;
	    }
	
	    let deferred = stringGrip._fullText = promise.defer();
	    let { actor, initial, length } = stringGrip;
	    let longStringClient = this.longString(stringGrip);
	
	    longStringClient.substring(initial.length, length, aResponse => {
	      if (aResponse.error) {
	        DevToolsUtils.reportException("getString",
	            aResponse.error + ": " + aResponse.message);
	
	        deferred.reject(aResponse);
	        return;
	      }
	      deferred.resolve(initial + aResponse.substring);
	    });
	
	    return deferred.promise;
	  }
	};


/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	const { Services } = __webpack_require__(28);
	const EventEmitter = __webpack_require__(258);
	
	/**
	 * Shortcuts for lazily accessing and setting various preferences.
	 * Usage:
	 *   let prefs = new Prefs("root.path.to.branch", {
	 *     myIntPref: ["Int", "leaf.path.to.my-int-pref"],
	 *     myCharPref: ["Char", "leaf.path.to.my-char-pref"],
	 *     myJsonPref: ["Json", "leaf.path.to.my-json-pref"],
	 *     myFloatPref: ["Float", "leaf.path.to.my-float-pref"]
	 *     ...
	 *   });
	 *
	 * Get/set:
	 *   prefs.myCharPref = "foo";
	 *   let aux = prefs.myCharPref;
	 *
	 * Observe:
	 *   prefs.registerObserver();
	 *   prefs.on("pref-changed", (prefName, prefValue) => {
	 *     ...
	 *   });
	 *
	 * @param string prefsRoot
	 *        The root path to the required preferences branch.
	 * @param object prefsBlueprint
	 *        An object containing { accessorName: [prefType, prefName] } keys.
	 */
	function PrefsHelper(prefsRoot = "", prefsBlueprint = {}) {
	  EventEmitter.decorate(this);
	
	  let cache = new Map();
	
	  for (let accessorName in prefsBlueprint) {
	    let [prefType, prefName] = prefsBlueprint[accessorName];
	    map(this, cache, accessorName, prefType, prefsRoot, prefName);
	  }
	
	  let observer = makeObserver(this, cache, prefsRoot, prefsBlueprint);
	  this.registerObserver = () => observer.register();
	  this.unregisterObserver = () => observer.unregister();
	}
	
	/**
	 * Helper method for getting a pref value.
	 *
	 * @param Map cache
	 * @param string prefType
	 * @param string prefsRoot
	 * @param string prefName
	 * @return any
	 */
	function get(cache, prefType, prefsRoot, prefName) {
	  let cachedPref = cache.get(prefName);
	  if (cachedPref !== undefined) {
	    return cachedPref;
	  }
	  let value = Services.prefs["get" + prefType + "Pref"](
	    [prefsRoot, prefName].join(".")
	  );
	  cache.set(prefName, value);
	  return value;
	}
	
	/**
	 * Helper method for setting a pref value.
	 *
	 * @param Map cache
	 * @param string prefType
	 * @param string prefsRoot
	 * @param string prefName
	 * @param any value
	 */
	function set(cache, prefType, prefsRoot, prefName, value) {
	  Services.prefs["set" + prefType + "Pref"](
	    [prefsRoot, prefName].join("."),
	    value
	  );
	  cache.set(prefName, value);
	}
	
	/**
	 * Maps a property name to a pref, defining lazy getters and setters.
	 * Supported types are "Bool", "Char", "Int", "Float" (sugar around "Char"
	 * type and casting), and "Json" (which is basically just sugar for "Char"
	 * using the standard JSON serializer).
	 *
	 * @param PrefsHelper self
	 * @param Map cache
	 * @param string accessorName
	 * @param string prefType
	 * @param string prefsRoot
	 * @param string prefName
	 * @param array serializer [optional]
	 */
	function map(self, cache, accessorName, prefType, prefsRoot, prefName,
	             serializer = { in: e => e, out: e => e }) {
	  if (prefName in self) {
	    throw new Error(`Can't use ${prefName} because it overrides a property` +
	                    "on the instance.");
	  }
	  if (prefType == "Json") {
	    map(self, cache, accessorName, "Char", prefsRoot, prefName, {
	      in: JSON.parse,
	      out: JSON.stringify
	    });
	    return;
	  }
	  if (prefType == "Float") {
	    map(self, cache, accessorName, "Char", prefsRoot, prefName, {
	      in: Number.parseFloat,
	      out: (n) => n + ""
	    });
	    return;
	  }
	
	  Object.defineProperty(self, accessorName, {
	    get: () => serializer.in(get(cache, prefType, prefsRoot, prefName)),
	    set: (e) => set(cache, prefType, prefsRoot, prefName, serializer.out(e))
	  });
	}
	
	/**
	 * Finds the accessor for the provided pref, based on the blueprint object
	 * used in the constructor.
	 *
	 * @param PrefsHelper self
	 * @param object prefsBlueprint
	 * @return string
	 */
	function accessorNameForPref(somePrefName, prefsBlueprint) {
	  for (let accessorName in prefsBlueprint) {
	    let [, prefName] = prefsBlueprint[accessorName];
	    if (somePrefName == prefName) {
	      return accessorName;
	    }
	  }
	  return "";
	}
	
	/**
	 * Creates a pref observer for `self`.
	 *
	 * @param PrefsHelper self
	 * @param Map cache
	 * @param string prefsRoot
	 * @param object prefsBlueprint
	 * @return object
	 */
	function makeObserver(self, cache, prefsRoot, prefsBlueprint) {
	  return {
	    register: function() {
	      this._branch = Services.prefs.getBranch(prefsRoot + ".");
	      this._branch.addObserver("", this, false);
	    },
	    unregister: function() {
	      this._branch.removeObserver("", this);
	    },
	    observe: function(subject, topic, prefName) {
	      // If this particular pref isn't handled by the blueprint object,
	      // even though it's in the specified branch, ignore it.
	      let accessorName = accessorNameForPref(prefName, prefsBlueprint);
	      if (!(accessorName in self)) {
	        return;
	      }
	      cache.delete(prefName);
	      self.emit("pref-changed", accessorName, self[accessorName]);
	    }
	  };
	}
	
	exports.PrefsHelper = PrefsHelper;


/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	const promise = __webpack_require__(264);
	const EventEmitter = __webpack_require__(258);
	
	/* const { DebuggerServer } = require("../../server/main");*/
	const { DebuggerClient } = __webpack_require__(276);
	
	const targets = new WeakMap();
	const promiseTargets = new WeakMap();
	
	/**
	 * Functions for creating Targets
	 */
	exports.TargetFactory = {
	  /**
	   * Construct a Target
	   * @param {XULTab} tab
	   *        The tab to use in creating a new target.
	   *
	   * @return A target object
	   */
	  forTab: function(tab) {
	    let target = targets.get(tab);
	    if (target == null) {
	      target = new TabTarget(tab);
	      targets.set(tab, target);
	    }
	    return target;
	  },
	
	  /**
	   * Return a promise of a Target for a remote tab.
	   * @param {Object} options
	   *        The options object has the following properties:
	   *        {
	   *          form: the remote protocol form of a tab,
	   *          client: a DebuggerClient instance
	   *                  (caller owns this and is responsible for closing),
	   *          chrome: true if the remote target is the whole process
	   *        }
	   *
	   * @return A promise of a target object
	   */
	  forRemoteTab: function(options) {
	    let targetPromise = promiseTargets.get(options);
	    if (targetPromise == null) {
	      let target = new TabTarget(options);
	      targetPromise = target.makeRemote().then(() => target);
	      promiseTargets.set(options, targetPromise);
	    }
	    return targetPromise;
	  },
	
	  forWorker: function(workerClient) {
	    let target = targets.get(workerClient);
	    if (target == null) {
	      target = new WorkerTarget(workerClient);
	      targets.set(workerClient, target);
	    }
	    return target;
	  },
	
	  /**
	   * Creating a target for a tab that is being closed is a problem because it
	   * allows a leak as a result of coming after the close event which normally
	   * clears things up. This function allows us to ask if there is a known
	   * target for a tab without creating a target
	   * @return true/false
	   */
	  isKnownTab: function(tab) {
	    return targets.has(tab);
	  },
	};
	
	/**
	 * A Target represents something that we can debug. Targets are generally
	 * read-only. Any changes that you wish to make to a target should be done via
	 * a Tool that attaches to the target. i.e. a Target is just a pointer saying
	 * "the thing to debug is over there".
	 *
	 * Providing a generalized abstraction of a web-page or web-browser (available
	 * either locally or remotely) is beyond the scope of this class (and maybe
	 * also beyond the scope of this universe) However Target does attempt to
	 * abstract some common events and read-only properties common to many Tools.
	 *
	 * Supported read-only properties:
	 * - name, isRemote, url
	 *
	 * Target extends EventEmitter and provides support for the following events:
	 * - close: The target window has been closed. All tools attached to this
	 *          target should close. This event is not currently cancelable.
	 * - navigate: The target window has navigated to a different URL
	 *
	 * Optional events:
	 * - will-navigate: The target window will navigate to a different URL
	 * - hidden: The target is not visible anymore (for TargetTab, another tab is
	 *           selected)
	 * - visible: The target is visible (for TargetTab, tab is selected)
	 *
	 * Comparing Targets: 2 instances of a Target object can point at the same
	 * thing, so t1 !== t2 and t1 != t2 even when they represent the same object.
	 * To compare to targets use 't1.equals(t2)'.
	 */
	
	/**
	 * A TabTarget represents a page living in a browser tab. Generally these will
	 * be web pages served over http(s), but they don't have to be.
	 */
	function TabTarget(tab) {
	  EventEmitter.decorate(this);
	  this.destroy = this.destroy.bind(this);
	  this._handleThreadState = this._handleThreadState.bind(this);
	  this.on("thread-resumed", this._handleThreadState);
	  this.on("thread-paused", this._handleThreadState);
	  this.activeTab = this.activeConsole = null;
	  // Only real tabs need initialization here. Placeholder objects for remote
	  // targets will be initialized after a makeRemote method call.
	  if (tab && !["client", "form", "chrome"].every(tab.hasOwnProperty, tab)) {
	    this._tab = tab;
	    this._setupListeners();
	  } else {
	    this._form = tab.form;
	    this._client = tab.client;
	    this._chrome = tab.chrome;
	  }
	  // Default isTabActor to true if not explicitly specified
	  if (typeof tab.isTabActor == "boolean") {
	    this._isTabActor = tab.isTabActor;
	  } else {
	    this._isTabActor = true;
	  }
	}
	
	TabTarget.prototype = {
	  _webProgressListener: null,
	
	  /**
	   * Returns a promise for the protocol description from the root actor. Used
	   * internally with `target.actorHasMethod`. Takes advantage of caching if
	   * definition was fetched previously with the corresponding actor information.
	   * Actors are lazily loaded, so not only must the tool using a specific actor
	   * be in use, the actors are only registered after invoking a method (for
	   * performance reasons, added in bug 988237), so to use these actor detection
	   * methods, one must already be communicating with a specific actor of that
	   * type.
	   *
	   * Must be a remote target.
	   *
	   * @return {Promise}
	   * {
	   *   "category": "actor",
	   *   "typeName": "longstractor",
	   *   "methods": [{
	   *     "name": "substring",
	   *     "request": {
	   *       "type": "substring",
	   *       "start": {
	   *         "_arg": 0,
	   *         "type": "primitive"
	   *       },
	   *       "end": {
	   *         "_arg": 1,
	   *         "type": "primitive"
	   *       }
	   *     },
	   *     "response": {
	   *       "substring": {
	   *         "_retval": "primitive"
	   *       }
	   *     }
	   *   }],
	   *  "events": {}
	   * }
	   */
	  getActorDescription: function(actorName) {
	    if (!this.client) {
	      throw new Error("TabTarget#getActorDescription() can only be called on " +
	                      "remote tabs.");
	    }
	
	    let deferred = promise.defer();
	
	    if (this._protocolDescription &&
	        this._protocolDescription.types[actorName]) {
	      deferred.resolve(this._protocolDescription.types[actorName]);
	    } else {
	      this.client.mainRoot.protocolDescription(description => {
	        this._protocolDescription = description;
	        deferred.resolve(description.types[actorName]);
	      });
	    }
	
	    return deferred.promise;
	  },
	
	  /**
	   * Returns a boolean indicating whether or not the specific actor
	   * type exists. Must be a remote target.
	   *
	   * @param {String} actorName
	   * @return {Boolean}
	   */
	  hasActor: function(actorName) {
	    if (!this.client) {
	      throw new Error("TabTarget#hasActor() can only be called on remote " +
	                      "tabs.");
	    }
	    if (this.form) {
	      return !!this.form[actorName + "Actor"];
	    }
	    return false;
	  },
	
	  /**
	   * Queries the protocol description to see if an actor has
	   * an available method. The actor must already be lazily-loaded (read
	   * the restrictions in the `getActorDescription` comments),
	   * so this is for use inside of tool. Returns a promise that
	   * resolves to a boolean. Must be a remote target.
	   *
	   * @param {String} actorName
	   * @param {String} methodName
	   * @return {Promise}
	   */
	  actorHasMethod: function(actorName, methodName) {
	    if (!this.client) {
	      throw new Error("TabTarget#actorHasMethod() can only be called on " +
	                      "remote tabs.");
	    }
	    return this.getActorDescription(actorName).then(desc => {
	      if (desc && desc.methods) {
	        return !!desc.methods.find(method => method.name === methodName);
	      }
	      return false;
	    });
	  },
	
	  /**
	   * Returns a trait from the root actor.
	   *
	   * @param {String} traitName
	   * @return {Mixed}
	   */
	  getTrait: function(traitName) {
	    if (!this.client) {
	      throw new Error("TabTarget#getTrait() can only be called on remote " +
	                      "tabs.");
	    }
	
	    // If the targeted actor exposes traits and has a defined value for this
	    // traits, override the root actor traits
	    if (this.form.traits && traitName in this.form.traits) {
	      return this.form.traits[traitName];
	    }
	
	    return this.client.traits[traitName];
	  },
	
	  get tab() {
	    return this._tab;
	  },
	
	  get form() {
	    return this._form;
	  },
	
	  // Get a promise of the root form returned by a listTabs request. This promise
	  // is cached.
	  get root() {
	    if (!this._root) {
	      this._root = this._getRoot();
	    }
	    return this._root;
	  },
	
	  _getRoot: function() {
	    return new Promise((resolve, reject) => {
	      this.client.listTabs(response => {
	        if (response.error) {
	          reject(new Error(response.error + ": " + response.message));
	          return;
	        }
	
	        resolve(response);
	      });
	    });
	  },
	
	  get client() {
	    return this._client;
	  },
	
	  // Tells us if we are debugging content document
	  // or if we are debugging chrome stuff.
	  // Allows to controls which features are available against
	  // a chrome or a content document.
	  get chrome() {
	    return this._chrome;
	  },
	
	  // Tells us if the related actor implements TabActor interface
	  // and requires to call `attach` request before being used
	  // and `detach` during cleanup
	  get isTabActor() {
	    return this._isTabActor;
	  },
	
	  get window() {
	    // XXX - this is a footgun for e10s - there .contentWindow will be null,
	    // and even though .contentWindowAsCPOW *might* work, it will not work
	    // in all contexts.  Consumers of .window need to be refactored to not
	    // rely on this.
	    // if (Services.appinfo.processType != Ci.nsIXULRuntime.PROCESS_TYPE_DEFAULT) {
	    //   console.error("The .window getter on devtools' |target| object isn't " +
	    //                  "e10s friendly!\n" + Error().stack);
	    // }
	    // Be extra careful here, since this may be called by HS_getHudByWindow
	    // during shutdown.
	    if (this._tab && this._tab.linkedBrowser) {
	      return this._tab.linkedBrowser.contentWindow;
	    }
	    return null;
	  },
	
	  get name() {
	    if (this._tab && this._tab.linkedBrowser.contentDocument) {
	      return this._tab.linkedBrowser.contentDocument.title;
	    }
	    if (this.isAddon) {
	      return this._form.name;
	    }
	    return this._form.title;
	  },
	
	  get url() {
	    return this._tab ? this._tab.linkedBrowser.currentURI.spec :
	                       this._form.url;
	  },
	
	  get isRemote() {
	    return !this.isLocalTab;
	  },
	
	  get isAddon() {
	    return !!(this._form && this._form.actor &&
	              this._form.actor.match(/conn\d+\.addon\d+/));
	  },
	
	  get isLocalTab() {
	    return !!this._tab;
	  },
	
	  get isMultiProcess() {
	    return !this.window;
	  },
	
	  get isThreadPaused() {
	    return !!this._isThreadPaused;
	  },
	
	  /**
	   * Adds remote protocol capabilities to the target, so that it can be used
	   * for tools that support the Remote Debugging Protocol even for local
	   * connections.
	   */
	  makeRemote: function() {
	    if (this._remote) {
	      return this._remote.promise;
	    }
	
	    this._remote = promise.defer();
	
	    if (this.isLocalTab) {
	      // Since a remote protocol connection will be made, let's start the
	      // DebuggerServer here, once and for all tools.
	      if (!DebuggerServer.initialized) {
	        DebuggerServer.init();
	        DebuggerServer.addBrowserActors();
	      }
	
	      this._client = new DebuggerClient(DebuggerServer.connectPipe());
	      // A local TabTarget will never perform chrome debugging.
	      this._chrome = false;
	    }
	
	    this._setupRemoteListeners();
	
	    let attachTab = () => {
	      this._client.attachTab(this._form.actor, (response, tabClient) => {
	        if (!tabClient) {
	          this._remote.reject("Unable to attach to the tab");
	          return;
	        }
	        this.activeTab = tabClient;
	        this.threadActor = response.threadActor;
	        attachConsole();
	      });
	    };
	
	    let onConsoleAttached = (response, consoleClient) => {
	      if (!consoleClient) {
	        this._remote.reject("Unable to attach to the console");
	        return;
	      }
	      this.activeConsole = consoleClient;
	      this._remote.resolve(null);
	    };
	
	    let attachConsole = () => {
	      this._client.attachConsole(this._form.consoleActor,
	                                 [ "NetworkActivity" ],
	                                 onConsoleAttached);
	    };
	
	    if (this.isLocalTab) {
	      this._client.connect(() => {
	        this._client.getTab({ tab: this.tab }).then(response => {
	          this._form = response.tab;
	          attachTab();
	        });
	      });
	    } else if (this.isTabActor) {
	      // In the remote debugging case, the protocol connection will have been
	      // already initialized in the connection screen code.
	      attachTab();
	    } else {
	      // AddonActor and chrome debugging on RootActor doesn't inherits from
	      // TabActor and doesn't need to be attached.
	      attachConsole();
	    }
	
	    return this._remote.promise;
	  },
	
	  /**
	   * Listen to the different events.
	   */
	  _setupListeners: function() {
	    this._webProgressListener = new TabWebProgressListener(this);
	    this.tab.linkedBrowser.addProgressListener(this._webProgressListener);
	    this.tab.addEventListener("TabClose", this);
	    this.tab.parentNode.addEventListener("TabSelect", this);
	    this.tab.ownerDocument.defaultView.addEventListener("unload", this);
	  },
	
	  /**
	   * Teardown event listeners.
	   */
	  _teardownListeners: function() {
	    if (this._webProgressListener) {
	      this._webProgressListener.destroy();
	    }
	
	    this._tab.ownerDocument.defaultView.removeEventListener("unload", this);
	    this._tab.removeEventListener("TabClose", this);
	    this._tab.parentNode.removeEventListener("TabSelect", this);
	  },
	
	  /**
	   * Setup listeners for remote debugging, updating existing ones as necessary.
	   */
	  _setupRemoteListeners: function() {
	    this.client.addListener("closed", this.destroy);
	
	    this._onTabDetached = (aType, aPacket) => {
	      // We have to filter message to ensure that this detach is for this tab
	      if (aPacket.from == this._form.actor) {
	        this.destroy();
	      }
	    };
	    this.client.addListener("tabDetached", this._onTabDetached);
	
	    this._onTabNavigated = (aType, aPacket) => {
	      let event = Object.create(null);
	      event.url = aPacket.url;
	      event.title = aPacket.title;
	      event.nativeConsoleAPI = aPacket.nativeConsoleAPI;
	      event.isFrameSwitching = aPacket.isFrameSwitching;
	      // Send any stored event payload (DOMWindow or nsIRequest) for backwards
	      // compatibility with non-remotable tools.
	      if (aPacket.state == "start") {
	        event._navPayload = this._navRequest;
	        this.emit("will-navigate", event);
	        this._navRequest = null;
	      } else {
	        event._navPayload = this._navWindow;
	        this.emit("navigate", event);
	        this._navWindow = null;
	      }
	    };
	    this.client.addListener("tabNavigated", this._onTabNavigated);
	
	    this._onFrameUpdate = (aType, aPacket) => {
	      this.emit("frame-update", aPacket);
	    };
	    this.client.addListener("frameUpdate", this._onFrameUpdate);
	  },
	
	  /**
	   * Teardown listeners for remote debugging.
	   */
	  _teardownRemoteListeners: function() {
	    this.client.removeListener("closed", this.destroy);
	    this.client.removeListener("tabNavigated", this._onTabNavigated);
	    this.client.removeListener("tabDetached", this._onTabDetached);
	    this.client.removeListener("frameUpdate", this._onFrameUpdate);
	  },
	
	  /**
	   * Handle tabs events.
	   */
	  handleEvent: function(event) {
	    switch (event.type) {
	      case "TabClose":
	      case "unload":
	        this.destroy();
	        break;
	      case "TabSelect":
	        if (this.tab.selected) {
	          this.emit("visible", event);
	        } else {
	          this.emit("hidden", event);
	        }
	        break;
	    }
	  },
	
	  /**
	   * Handle script status.
	   */
	  _handleThreadState: function(event) {
	    switch (event) {
	      case "thread-resumed":
	        this._isThreadPaused = false;
	        break;
	      case "thread-paused":
	        this._isThreadPaused = true;
	        break;
	    }
	  },
	
	  /**
	   * Target is not alive anymore.
	   */
	  destroy: function() {
	    // If several things call destroy then we give them all the same
	    // destruction promise so we're sure to destroy only once
	    if (this._destroyer) {
	      return this._destroyer.promise;
	    }
	
	    this._destroyer = promise.defer();
	
	    // Before taking any action, notify listeners that destruction is imminent.
	    this.emit("close");
	
	    // First of all, do cleanup tasks that pertain to both remoted and
	    // non-remoted targets.
	    this.off("thread-resumed", this._handleThreadState);
	    this.off("thread-paused", this._handleThreadState);
	
	    if (this._tab) {
	      this._teardownListeners();
	    }
	
	    let cleanupAndResolve = () => {
	      this._cleanup();
	      this._destroyer.resolve(null);
	    };
	    // If this target was not remoted, the promise will be resolved before the
	    // function returns.
	    if (this._tab && !this._client) {
	      cleanupAndResolve();
	    } else if (this._client) {
	      // If, on the other hand, this target was remoted, the promise will be
	      // resolved after the remote connection is closed.
	      this._teardownRemoteListeners();
	
	      if (this.isLocalTab) {
	        // We started with a local tab and created the client ourselves, so we
	        // should close it.
	        this._client.close(cleanupAndResolve);
	      } else if (this.activeTab) {
	        // The client was handed to us, so we are not responsible for closing
	        // it. We just need to detach from the tab, if already attached.
	        // |detach| may fail if the connection is already dead, so proceed with
	        // cleanup directly after this.
	        this.activeTab.detach();
	        cleanupAndResolve();
	      } else {
	        cleanupAndResolve();
	      }
	    }
	
	    return this._destroyer.promise;
	  },
	
	  /**
	   * Clean up references to what this target points to.
	   */
	  _cleanup: function() {
	    if (this._tab) {
	      targets.delete(this._tab);
	    } else {
	      promiseTargets.delete(this._form);
	    }
	    this.activeTab = null;
	    this.activeConsole = null;
	    this._client = null;
	    this._tab = null;
	    this._form = null;
	    this._remote = null;
	  },
	
	  toString: function() {
	    let id = this._tab ? this._tab : (this._form && this._form.actor);
	    return `TabTarget:${id}`;
	  },
	};
	
	function WorkerTarget(workerClient) {
	  EventEmitter.decorate(this);
	  this._workerClient = workerClient;
	}
	
	/**
	 * A WorkerTarget represents a worker. Unlike TabTarget, which can represent
	 * either a local or remote tab, WorkerTarget always represents a remote worker.
	 * Moreover, unlike TabTarget, which is constructed with a placeholder object
	 * for remote tabs (from which a TabClient can then be lazily obtained),
	 * WorkerTarget is constructed with a WorkerClient directly.
	 *
	 * WorkerClient is designed to mimic the interface of TabClient as closely as
	 * possible. This allows us to debug workers as if they were ordinary tabs,
	 * requiring only minimal changes to the rest of the frontend.
	 */
	WorkerTarget.prototype = {
	  destroy: function() {},
	
	  get isRemote() {
	    return true;
	  },
	
	  get isTabActor() {
	    return true;
	  },
	
	  get url() {
	    return this._workerClient.url;
	  },
	
	  get isWorkerTarget() {
	    return true;
	  },
	
	  get form() {
	    return {
	      consoleActor: this._workerClient.consoleActor
	    };
	  },
	
	  get activeTab() {
	    return this._workerClient;
	  },
	
	  get client() {
	    return this._workerClient.client;
	  },
	
	  destroy: function() {},
	
	  hasActor: function(name) {
	    return false;
	  },
	
	  getTrait: function() {
	    return undefined;
	  },
	
	  makeRemote: function() {
	    return Promise.resolve();
	  }
	};


/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	"use strict";
	
	const EventEmitter = __webpack_require__(258);
	
	function WebSocketDebuggerTransport(socket) {
	  EventEmitter.decorate(this);
	
	  this.active = false;
	  this.hooks = null;
	  this.socket = socket;
	}
	
	WebSocketDebuggerTransport.prototype = {
	  ready() {
	    if (this.active) {
	      return;
	    }
	
	    this.socket.addEventListener("message", this);
	    this.socket.addEventListener("close", this);
	
	    this.active = true;
	  },
	
	  send(object) {
	    this.emit("send", object);
	    if (this.socket) {
	      this.socket.send(JSON.stringify(object));
	    }
	  },
	
	  startBulkSend() {
	    throw new Error("Bulk send is not supported by WebSocket transport");
	  },
	
	  close() {
	    this.emit("close");
	    this.active = false;
	
	    this.socket.removeEventListener("message", this);
	    this.socket.removeEventListener("close", this);
	    this.socket.close();
	    this.socket = null;
	
	    if (this.hooks) {
	      this.hooks.onClosed();
	      this.hooks = null;
	    }
	  },
	
	  handleEvent(event) {
	    switch (event.type) {
	      case "message":
	        this.onMessage(event);
	        break;
	      case "close":
	        this.close();
	        break;
	    }
	  },
	
	  onMessage({ data }) {
	    if (typeof data !== "string") {
	      throw new Error("Binary messages are not supported by WebSocket transport");
	    }
	
	    let object = JSON.parse(data);
	    this.emit("packet", object);
	    if (this.hooks) {
	      this.hooks.onPacket(object);
	    }
	  },
	};
	
	module.exports = WebSocketDebuggerTransport;


/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	"use strict";
	
	const EventEmitter = __webpack_require__(258);
	
	/**
	 * A partial implementation of the Menu API provided by electron:
	 * https://github.com/electron/electron/blob/master/docs/api/menu.md.
	 *
	 * Extra features:
	 *  - Emits an 'open' and 'close' event when the menu is opened/closed
	
	 * @param String id (non standard)
	 *        Needed so tests can confirm the XUL implementation is working
	 */
	function Menu({ id = null } = {}) {
	  this.menuitems = [];
	  this.id = id;
	
	  Object.defineProperty(this, "items", {
	    get() {
	      return this.menuitems;
	    }
	  });
	
	  EventEmitter.decorate(this);
	}
	
	/**
	 * Add an item to the end of the Menu
	 *
	 * @param {MenuItem} menuItem
	 */
	Menu.prototype.append = function (menuItem) {
	  this.menuitems.push(menuItem);
	};
	
	/**
	 * Add an item to a specified position in the menu
	 *
	 * @param {int} pos
	 * @param {MenuItem} menuItem
	 */
	Menu.prototype.insert = function (pos, menuItem) {
	  throw Error("Not implemented");
	};
	
	/**
	 * Show the Menu at a specified location on the screen
	 *
	 * Missing features:
	 *   - browserWindow - BrowserWindow (optional) - Default is null.
	 *   - positioningItem Number - (optional) OS X
	 *
	 * @param {int} screenX
	 * @param {int} screenY
	 * @param Toolbox toolbox (non standard)
	 *        Needed so we in which window to inject XUL
	 */
	Menu.prototype.popup = function (screenX, screenY, toolbox) {
	  let doc = toolbox.doc;
	  let popupset = doc.querySelector("popupset");
	  // See bug 1285229, on Windows, opening the same popup multiple times in a
	  // row ends up duplicating the popup. The newly inserted popup doesn't
	  // dismiss the old one. So remove any previously displayed popup before
	  // opening a new one.
	  let popup = popupset.querySelector("menupopup[menu-api=\"true\"]");
	  if (popup) {
	    popup.hidePopup();
	  }
	
	  popup = this.createPopup(doc)
	  popup.setAttribute("menu-api", "true");
	
	  if (this.id) {
	    popup.id = this.id;
	  }
	  this._createMenuItems(popup);
	
	  // Remove the menu from the DOM once it's hidden.
	  popup.addEventListener("popuphidden", (e) => {
	    if (e.target === popup) {
	      popup.remove();
	      this.emit("close", popup);
	    }
	  });
	
	  popup.addEventListener("popupshown", (e) => {
	    if (e.target === popup) {
	      this.emit("open", popup);
	    }
	  });
	
	  popupset.appendChild(popup);
	  popup.openPopupAtScreen(screenX, screenY, true);
	};
	
	Menu.prototype.createPopup = function(doc) {
	  return doc.createElement("menupopup");
	}
	
	Menu.prototype._createMenuItems = function (parent) {
	  let doc = parent.ownerDocument;
	  this.menuitems.forEach(item => {
	    if (!item.visible) {
	      return;
	    }
	
	    if (item.submenu) {
	      let menupopup = doc.createElement("menupopup");
	      item.submenu._createMenuItems(menupopup);
	
	      let menu = doc.createElement("menu");
	      menu.appendChild(menupopup);
	      menu.setAttribute("label", item.label);
	      if (item.disabled) {
	        menu.setAttribute("disabled", "true");
	      }
	      if (item.accesskey) {
	        menu.setAttribute("accesskey", item.accesskey);
	      }
	      if (item.id) {
	        menu.id = item.id;
	      }
	      parent.appendChild(menu);
	    } else if (item.type === "separator") {
	      let menusep = doc.createElement("menuseparator");
	      parent.appendChild(menusep);
	    } else {
	      let menuitem = doc.createElement("menuitem");
	      menuitem.setAttribute("label", item.label);
	      menuitem.textContent = item.label;
	      menuitem.addEventListener("command", () => item.click());
	
	      if (item.type === "checkbox") {
	        menuitem.setAttribute("type", "checkbox");
	      }
	      if (item.type === "radio") {
	        menuitem.setAttribute("type", "radio");
	      }
	      if (item.disabled) {
	        menuitem.setAttribute("disabled", "true");
	      }
	      if (item.checked) {
	        menuitem.setAttribute("checked", "true");
	      }
	      if (item.accesskey) {
	        menuitem.setAttribute("accesskey", item.accesskey);
	      }
	      if (item.id) {
	        menuitem.id = item.id;
	      }
	
	      parent.appendChild(menuitem);
	    }
	  });
	};
	
	Menu.setApplicationMenu = () => {
	  throw Error("Not implemented");
	};
	
	Menu.sendActionToFirstResponder = () => {
	  throw Error("Not implemented");
	};
	
	Menu.buildFromTemplate = () => {
	  throw Error("Not implemented");
	};
	
	module.exports = Menu;


/***/ },
/* 284 */
/***/ function(module, exports) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	"use strict";
	
	/**
	 * A partial implementation of the MenuItem API provided by electron:
	 * https://github.com/electron/electron/blob/master/docs/api/menu-item.md.
	 *
	 * Missing features:
	 *   - id String - Unique within a single menu. If defined then it can be used
	 *                 as a reference to this item by the position attribute.
	 *   - role String - Define the action of the menu item; when specified the
	 *                   click property will be ignored
	 *   - sublabel String
	 *   - accelerator Accelerator
	 *   - icon NativeImage
	 *   - position String - This field allows fine-grained definition of the
	 *                       specific location within a given menu.
	 *
	 * Implemented features:
	 *  @param Object options
	 *    Function click
	 *      Will be called with click(menuItem, browserWindow) when the menu item
	 *       is clicked
	 *    String type
	 *      Can be normal, separator, submenu, checkbox or radio
	 *    String label
	 *    Boolean enabled
	 *      If false, the menu item will be greyed out and unclickable.
	 *    Boolean checked
	 *      Should only be specified for checkbox or radio type menu items.
	 *    Menu submenu
	 *      Should be specified for submenu type menu items. If submenu is specified,
	 *      the type: 'submenu' can be omitted. If the value is not a Menu then it
	 *      will be automatically converted to one using Menu.buildFromTemplate.
	 *    Boolean visible
	 *      If false, the menu item will be entirely hidden.
	 */
	function MenuItem({
	    accesskey = null,
	    checked = false,
	    click = () => {},
	    disabled = false,
	    label = "",
	    id = null,
	    submenu = null,
	    type = "normal",
	    visible = true,
	} = { }) {
	  this.accesskey = accesskey;
	  this.checked = checked;
	  this.click = click;
	  this.disabled = disabled;
	  this.id = id;
	  this.label = label;
	  this.submenu = submenu;
	  this.type = type;
	  this.visible = visible;
	}
	
	module.exports = MenuItem;


/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
	 * You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	const { DOM: dom, createClass, createFactory, PropTypes } = __webpack_require__(2);
	// const { ViewHelpers } =
	// require("resource://devtools/client/shared/widgets/ViewHelpers.jsm");
	// let { VirtualScroll } = require("react-virtualized");
	// VirtualScroll = createFactory(VirtualScroll);
	
	const AUTO_EXPAND_DEPTH = 0; // depth
	
	/**
	 * An arrow that displays whether its node is expanded (▼) or collapsed
	 * (▶). When its node has no children, it is hidden.
	 */
	const ArrowExpander = createFactory(createClass({
	  displayName: "ArrowExpander",
	
	  shouldComponentUpdate(nextProps, nextState) {
	    return this.props.item !== nextProps.item
	      || this.props.visible !== nextProps.visible
	      || this.props.expanded !== nextProps.expanded;
	  },
	
	  render() {
	    const attrs = {
	      className: "arrow theme-twisty",
	      onClick: this.props.expanded
	        ? () => this.props.onCollapse(this.props.item)
	        : e => this.props.onExpand(this.props.item, e.altKey)
	    };
	
	    if (this.props.expanded) {
	      attrs.className += " open";
	    }
	
	    if (!this.props.visible) {
	      attrs.style = Object.assign({}, this.props.style || {}, {
	        visibility: "hidden"
	      });
	    }
	
	    return dom.div(attrs, this.props.children);
	  }
	}));
	
	const TreeNode = createFactory(createClass({
	  displayName: "TreeNode",
	
	  componentDidMount() {
	    if (this.props.focused) {
	      this.refs.button.focus();
	    }
	  },
	
	  componentDidUpdate() {
	    if (this.props.focused) {
	      this.refs.button.focus();
	    }
	  },
	
	  shouldComponentUpdate(nextProps) {
	    return this.props.item !== nextProps.item ||
	      this.props.focused !== nextProps.focused ||
	      this.props.expanded !== nextProps.expanded;
	  },
	
	  render() {
	    const arrow = ArrowExpander({
	      item: this.props.item,
	      expanded: this.props.expanded,
	      visible: this.props.hasChildren,
	      onExpand: this.props.onExpand,
	      onCollapse: this.props.onCollapse,
	    });
	
	    let isOddRow = this.props.index % 2;
	    return dom.div(
	      {
	        className: `tree-node div ${isOddRow ? "tree-node-odd" : ""}`,
	        onFocus: this.props.onFocus,
	        onClick: this.props.onFocus,
	        onBlur: this.props.onBlur,
	        style: {
	          padding: 0,
	          margin: 0
	        }
	      },
	
	      this.props.renderItem(this.props.item,
	                            this.props.depth,
	                            this.props.focused,
	                            arrow,
	                            this.props.expanded),
	
	      // XXX: OSX won't focus/blur regular elements even if you set tabindex
	      // unless there is an input/button child.
	      dom.button(this._buttonAttrs)
	    );
	  },
	
	  _buttonAttrs: {
	    ref: "button",
	    style: {
	      opacity: 0,
	      width: "0 !important",
	      height: "0 !important",
	      padding: "0 !important",
	      outline: "none",
	      MozAppearance: "none",
	      // XXX: Despite resetting all of the above properties (and margin), the
	      // button still ends up with ~79px width, so we set a large negative
	      // margin to completely hide it.
	      MozMarginStart: "-1000px !important",
	    }
	  }
	}));
	
	/**
	 * Create a function that calls the given function `fn` only once per animation
	 * frame.
	 *
	 * @param {Function} fn
	 * @returns {Function}
	 */
	function oncePerAnimationFrame(fn) {
	  let animationId = null;
	  let argsToPass = null;
	  return function(...args) {
	    argsToPass = args;
	    if (animationId !== null) {
	      return;
	    }
	
	    animationId = requestAnimationFrame(() => {
	      fn.call(this, ...argsToPass);
	      animationId = null;
	      argsToPass = null;
	    });
	  };
	}
	
	const NUMBER_OF_OFFSCREEN_ITEMS = 1;
	
	/**
	 * A generic tree component. See propTypes for the public API.
	 *
	 * @see `devtools/client/memory/components/test/mochitest/head.js` for usage
	 * @see `devtools/client/memory/components/heap.js` for usage
	 */
	const Tree = module.exports = createClass({
	  displayName: "Tree",
	
	  propTypes: {
	    // Required props
	
	    // A function to get an item's parent, or null if it is a root.
	    getParent: PropTypes.func.isRequired,
	    // A function to get an item's children.
	    getChildren: PropTypes.func.isRequired,
	    // A function which takes an item and ArrowExpander and returns a
	    // component.
	    renderItem: PropTypes.func.isRequired,
	    // A function which returns the roots of the tree (forest).
	    getRoots: PropTypes.func.isRequired,
	    // A function to get a unique key for the given item.
	    getKey: PropTypes.func.isRequired,
	    // A function to get whether an item is expanded or not. If an item is not
	    // expanded, then it must be collapsed.
	    isExpanded: PropTypes.func.isRequired,
	    // The height of an item in the tree including margin and padding, in
	    // pixels.
	    itemHeight: PropTypes.number.isRequired,
	
	    // Optional props
	
	    // The currently focused item, if any such item exists.
	    focused: PropTypes.any,
	    // Handle when a new item is focused.
	    onFocus: PropTypes.func,
	    // The depth to which we should automatically expand new items.
	    autoExpandDepth: PropTypes.number,
	    // Should auto expand all new items or just the new items under the first
	    // root item.
	    autoExpandAll: PropTypes.bool,
	    // Optional event handlers for when items are expanded or collapsed.
	    onExpand: PropTypes.func,
	    onCollapse: PropTypes.func,
	  },
	
	  getDefaultProps() {
	    return {
	      autoExpandDepth: AUTO_EXPAND_DEPTH,
	      autoExpandAll: true
	    };
	  },
	
	  getInitialState() {
	    return {
	      scroll: 0,
	      height: window.innerHeight,
	      seen: new Set(),
	    };
	  },
	
	  componentDidMount() {
	    window.addEventListener("resize", this._updateHeight);
	    this._autoExpand(this.props);
	    this._updateHeight();
	  },
	
	  componentWillUnmount() {
	    window.removeEventListener("resize", this._updateHeight);
	  },
	
	  componentWillReceiveProps(nextProps) {
	    this._autoExpand(nextProps);
	    this._updateHeight();
	  },
	
	  _autoExpand(props) {
	    if (!props.autoExpandDepth) {
	      return;
	    }
	
	    // Automatically expand the first autoExpandDepth levels for new items. Do
	    // not use the usual DFS infrastructure because we don't want to ignore
	    // collapsed nodes.
	    const autoExpand = (item, currentDepth) => {
	      if (currentDepth >= props.autoExpandDepth ||
	          this.state.seen.has(item)) {
	        return;
	      }
	
	      props.onExpand(item);
	      this.state.seen.add(item);
	
	      const children = props.getChildren(item);
	      const length = children.length;
	      for (let i = 0; i < length; i++) {
	        autoExpand(children[i], currentDepth + 1);
	      }
	    };
	
	    const roots = props.getRoots();
	    const length = roots.length;
	    if (props.autoExpandAll) {
	      for (let i = 0; i < length; i++) {
	        autoExpand(roots[i], 0);
	      }
	    } else if (length != 0) {
	      autoExpand(roots[0], 0);
	    }
	  },
	
	  render() {
	    const traversal = this._dfsFromRoots();
	
	    // Remove `NUMBER_OF_OFFSCREEN_ITEMS` from `begin` and add `2 *
	    // NUMBER_OF_OFFSCREEN_ITEMS` to `end` so that the top and bottom of the
	    // page are filled with the `NUMBER_OF_OFFSCREEN_ITEMS` previous and next
	    // items respectively, rather than whitespace if the item is not in full
	    // view.
	    // const begin = Math.max(((this.state.scroll / this.props.itemHeight) | 0) - NUMBER_OF_OFFSCREEN_ITEMS, 0);
	    // const end = begin + (2 * NUMBER_OF_OFFSCREEN_ITEMS) + ((this.state.height / this.props.itemHeight) | 0);
	    // const toRender = traversal;
	
	    // const nodes = [
	    //   dom.div({
	    //     key: "top-spacer",
	    //     style: {
	    //       padding: 0,
	    //       margin: 0,
	    //       height: begin * this.props.itemHeight + "px"
	    //     }
	    //   })
	    // ];
	
	    const renderItem = i => {
	      let { item, depth } = traversal[i];
	      return TreeNode({
	        key: this.props.getKey(item, i),
	        index: i,
	        item: item,
	        depth: depth,
	        renderItem: this.props.renderItem,
	        focused: this.props.focused === item,
	        expanded: this.props.isExpanded(item),
	        hasChildren: !!this.props.getChildren(item).length,
	        onExpand: this._onExpand,
	        onCollapse: this._onCollapse,
	        onFocus: () => this._focus(i, item),
	      });
	    };
	
	    // nodes.push(dom.div({
	    //   key: "bottom-spacer",
	    //   style: {
	    //     padding: 0,
	    //     margin: 0,
	    //     height: (traversal.length - 1 - end) * this.props.itemHeight + "px"
	    //   }
	    // }));
	
	    const style = Object.assign({}, this.props.style || {}, {
	      padding: 0,
	      margin: 0
	    });
	
	    return dom.div(
	      {
	        className: "tree",
	        ref: "tree",
	        onKeyDown: this._onKeyDown,
	        onKeyPress: this._preventArrowKeyScrolling,
	        onKeyUp: this._preventArrowKeyScrolling,
	        onScroll: this._onScroll,
	        style
	      },
	      // VirtualScroll({
	      //   width: this.props.width,
	      //   height: this.props.height,
	      //   rowsCount: traversal.length,
	      //   rowHeight: this.props.itemHeight,
	      //   rowRenderer: renderItem
	      // })
	      traversal.map((v, i) => renderItem(i))
	    );
	  },
	
	  _preventArrowKeyScrolling(e) {
	    switch (e.key) {
	      case "ArrowUp":
	      case "ArrowDown":
	      case "ArrowLeft":
	      case "ArrowRight":
	        e.preventDefault();
	        e.stopPropagation();
	        if (e.nativeEvent) {
	          if (e.nativeEvent.preventDefault) {
	            e.nativeEvent.preventDefault();
	          }
	          if (e.nativeEvent.stopPropagation) {
	            e.nativeEvent.stopPropagation();
	          }
	        }
	    }
	  },
	
	  /**
	   * Updates the state's height based on clientHeight.
	   */
	  _updateHeight() {
	    this.setState({
	      height: this.refs.tree.clientHeight
	    });
	  },
	
	  /**
	   * Perform a pre-order depth-first search from item.
	   */
	  _dfs(item, maxDepth = Infinity, traversal = [], _depth = 0) {
	    traversal.push({ item, depth: _depth });
	
	    if (!this.props.isExpanded(item)) {
	      return traversal;
	    }
	
	    const nextDepth = _depth + 1;
	
	    if (nextDepth > maxDepth) {
	      return traversal;
	    }
	
	    const children = this.props.getChildren(item);
	    const length = children.length;
	    for (let i = 0; i < length; i++) {
	      this._dfs(children[i], maxDepth, traversal, nextDepth);
	    }
	
	    return traversal;
	  },
	
	  /**
	   * Perform a pre-order depth-first search over the whole forest.
	   */
	  _dfsFromRoots(maxDepth = Infinity) {
	    const traversal = [];
	
	    const roots = this.props.getRoots();
	    const length = roots.length;
	    for (let i = 0; i < length; i++) {
	      this._dfs(roots[i], maxDepth, traversal);
	    }
	
	    return traversal;
	  },
	
	  /**
	   * Expands current row.
	   *
	   * @param {Object} item
	   * @param {Boolean} expandAllChildren
	   */
	  _onExpand: oncePerAnimationFrame(function(item, expandAllChildren) {
	    if (this.props.onExpand) {
	      this.props.onExpand(item);
	
	      if (expandAllChildren) {
	        const children = this._dfs(item);
	        const length = children.length;
	        for (let i = 0; i < length; i++) {
	          this.props.onExpand(children[i].item);
	        }
	      }
	    }
	  }),
	
	  /**
	   * Collapses current row.
	   *
	   * @param {Object} item
	   */
	  _onCollapse: oncePerAnimationFrame(function(item) {
	    if (this.props.onCollapse) {
	      this.props.onCollapse(item);
	    }
	  }),
	
	  /**
	   * Sets the passed in item to be the focused item.
	   *
	   * @param {Number} index
	   *        The index of the item in a full DFS traversal (ignoring collapsed
	   *        nodes). Ignored if `item` is undefined.
	   *
	   * @param {Object|undefined} item
	   *        The item to be focused, or undefined to focus no item.
	   */
	  _focus(index, item) {
	    if (item !== undefined) {
	      const itemStartPosition = index * this.props.itemHeight;
	      const itemEndPosition = (index + 1) * this.props.itemHeight;
	
	      // Note that if the height of the viewport (this.state.height) is less than
	      // `this.props.itemHeight`, we could accidentally try and scroll both up and
	      // down in a futile attempt to make both the item's start and end positions
	      // visible. Instead, give priority to the start of the item by checking its
	      // position first, and then using an "else if", rather than a separate "if",
	      // for the end position.
	      if (this.state.scroll > itemStartPosition) {
	        this.refs.tree.scrollTop = itemStartPosition;
	      } else if ((this.state.scroll + this.state.height) < itemEndPosition) {
	        this.refs.tree.scrollTop = itemEndPosition - this.state.height;
	      }
	    }
	
	    if (this.props.onFocus) {
	      this.props.onFocus(item);
	    }
	  },
	
	  /**
	   * Sets the state to have no focused item.
	   */
	  _onBlur() {
	    this._focus(0, undefined);
	  },
	
	  /**
	   * Fired on a scroll within the tree's container, updates
	   * the stored position of the view port to handle virtual view rendering.
	   *
	   * @param {Event} e
	   */
	  _onScroll: oncePerAnimationFrame(function(e) {
	    this.setState({
	      scroll: Math.max(this.refs.tree.scrollTop, 0),
	      height: this.refs.tree.clientHeight
	    });
	  }),
	
	  /**
	   * Handles key down events in the tree's container.
	   *
	   * @param {Event} e
	   */
	  _onKeyDown(e) {
	    if (this.props.focused == null) {
	      return;
	    }
	
	    // Allow parent nodes to use navigation arrows with modifiers.
	    if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
	      return;
	    }
	
	    this._preventArrowKeyScrolling(e);
	
	    switch (e.key) {
	      case "ArrowUp":
	        this._focusPrevNode();
	        return;
	
	      case "ArrowDown":
	        this._focusNextNode();
	        return;
	
	      case "ArrowLeft":
	        if (this.props.isExpanded(this.props.focused)
	            && this.props.getChildren(this.props.focused).length) {
	          this._onCollapse(this.props.focused);
	        } else {
	          this._focusParentNode();
	        }
	        return;
	
	      case "ArrowRight":
	        if (!this.props.isExpanded(this.props.focused)) {
	          this._onExpand(this.props.focused);
	        } else {
	          this._focusNextNode();
	        }
	        return;
	    }
	  },
	
	  /**
	   * Sets the previous node relative to the currently focused item, to focused.
	   */
	  _focusPrevNode: oncePerAnimationFrame(function() {
	    // Start a depth first search and keep going until we reach the currently
	    // focused node. Focus the previous node in the DFS, if it exists. If it
	    // doesn't exist, we're at the first node already.
	
	    let prev;
	    let prevIndex;
	
	    const traversal = this._dfsFromRoots();
	    const length = traversal.length;
	    for (let i = 0; i < length; i++) {
	      const item = traversal[i].item;
	      if (item === this.props.focused) {
	        break;
	      }
	      prev = item;
	      prevIndex = i;
	    }
	
	    if (prev === undefined) {
	      return;
	    }
	
	    this._focus(prevIndex, prev);
	  }),
	
	  /**
	   * Handles the down arrow key which will focus either the next child
	   * or sibling row.
	   */
	  _focusNextNode: oncePerAnimationFrame(function() {
	    // Start a depth first search and keep going until we reach the currently
	    // focused node. Focus the next node in the DFS, if it exists. If it
	    // doesn't exist, we're at the last node already.
	
	    const traversal = this._dfsFromRoots();
	    const length = traversal.length;
	    let i = 0;
	
	    while (i < length) {
	      if (traversal[i].item === this.props.focused) {
	        break;
	      }
	      i++;
	    }
	
	    if (i + 1 < traversal.length) {
	      this._focus(i + 1, traversal[i + 1].item);
	    }
	  }),
	
	  /**
	   * Handles the left arrow key, going back up to the current rows'
	   * parent row.
	   */
	  _focusParentNode: oncePerAnimationFrame(function() {
	    const parent = this.props.getParent(this.props.focused);
	    if (!parent) {
	      return;
	    }
	
	    const traversal = this._dfsFromRoots();
	    const length = traversal.length;
	    let parentIndex = 0;
	    for (; parentIndex < length; parentIndex++) {
	      if (traversal[parentIndex].item === parent) {
	        break;
	      }
	    }
	
	    this._focus(parentIndex, parent);
	  }),
	});


/***/ },
/* 286 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";
	
	// const { LocalizationHelper } = require("devtools/shared/l10n");
	//
	// const l10n = new LocalizationHelper("devtools/client/locales/components.properties");
	// const UNKNOWN_SOURCE_STRING = l10n.getStr("frame.unknownSource");
	
	const l10n = {
	  getStr: () => {}
	}
	
	// Character codes used in various parsing helper functions.
	const CHAR_CODE_A = "a".charCodeAt(0);
	const CHAR_CODE_C = "c".charCodeAt(0);
	const CHAR_CODE_D = "d".charCodeAt(0);
	const CHAR_CODE_E = "e".charCodeAt(0);
	const CHAR_CODE_F = "f".charCodeAt(0);
	const CHAR_CODE_H = "h".charCodeAt(0);
	const CHAR_CODE_I = "i".charCodeAt(0);
	const CHAR_CODE_J = "j".charCodeAt(0);
	const CHAR_CODE_L = "l".charCodeAt(0);
	const CHAR_CODE_M = "m".charCodeAt(0);
	const CHAR_CODE_O = "o".charCodeAt(0);
	const CHAR_CODE_P = "p".charCodeAt(0);
	const CHAR_CODE_R = "r".charCodeAt(0);
	const CHAR_CODE_S = "s".charCodeAt(0);
	const CHAR_CODE_T = "t".charCodeAt(0);
	const CHAR_CODE_U = "u".charCodeAt(0);
	const CHAR_CODE_COLON = ":".charCodeAt(0);
	const CHAR_CODE_SLASH = "/".charCodeAt(0);
	const CHAR_CODE_CAP_S = "S".charCodeAt(0);
	
	// The cache used in the `parseURL` function.
	const gURLStore = new Map();
	// The cache used in the `getSourceNames` function.
	const gSourceNamesStore = new Map();
	
	/**
	 * Takes a string and returns an object containing all the properties
	 * available on an URL instance, with additional properties (fileName),
	 * Leverages caching.
	 *
	 * @param {String} location
	 * @return {Object?} An object containing most properties available
	 *                   in https://developer.mozilla.org/en-US/docs/Web/API/URL
	 */
	
	function parseURL(location) {
	  let url = gURLStore.get(location);
	
	  if (url !== void 0) {
	    return url;
	  }
	
	  try {
	    url = new URL(location);
	    // The callers were generally written to expect a URL from
	    // sdk/url, which is subtly different.  So, work around some
	    // important differences here.
	    url = {
	      href: url.href,
	      protocol: url.protocol,
	      host: url.host,
	      hostname: url.hostname,
	      port: url.port || null,
	      pathname: url.pathname,
	      search: url.search,
	      hash: url.hash,
	      username: url.username,
	      password: url.password,
	      origin: url.origin,
	    };
	
	    // Definitions:
	    // Example: https://foo.com:8888/file.js
	    // `hostname`: "foo.com"
	    // `host`: "foo.com:8888"
	    let isChrome = isChromeScheme(location);
	
	    url.fileName = url.pathname ?
	      (url.pathname.slice(url.pathname.lastIndexOf("/") + 1) || "/") :
	      "/";
	
	    if (isChrome) {
	      url.hostname = null;
	      url.host = null;
	    }
	
	    gURLStore.set(location, url);
	    return url;
	  } catch (e) {
	    gURLStore.set(location, null);
	    return null;
	  }
	}
	
	/**
	 * Parse a source into a short and long name as well as a host name.
	 *
	 * @param {String} source
	 *        The source to parse. Can be a URI or names like "(eval)" or
	 *        "self-hosted".
	 * @return {Object}
	 *         An object with the following properties:
	 *           - {String} short: A short name for the source.
	 *             - "http://page.com/test.js#go?q=query" -> "test.js"
	 *           - {String} long: The full, long name for the source, with
	               hash/query stripped.
	 *             - "http://page.com/test.js#go?q=query" -> "http://page.com/test.js"
	 *           - {String?} host: If available, the host name for the source.
	 *             - "http://page.com/test.js#go?q=query" -> "page.com"
	 */
	function getSourceNames(source) {
	  let data = gSourceNamesStore.get(source);
	
	  if (data) {
	    return data;
	  }
	
	  let short, long, host;
	  const sourceStr = source ? String(source) : "";
	
	  // If `data:...` uri
	  if (isDataScheme(sourceStr)) {
	    let commaIndex = sourceStr.indexOf(",");
	    if (commaIndex > -1) {
	      // The `short` name for a data URI becomes `data:` followed by the actual
	      // encoded content, omitting the MIME type, and charset.
	      short = `data:${sourceStr.substring(commaIndex + 1)}`.slice(0, 100);
	      let result = { short, long: sourceStr };
	      gSourceNamesStore.set(source, result);
	      return result;
	    }
	  }
	
	  // If Scratchpad URI, like "Scratchpad/1"; no modifications,
	  // and short/long are the same.
	  if (isScratchpadScheme(sourceStr)) {
	    let result = { short: sourceStr, long: sourceStr };
	    gSourceNamesStore.set(source, result);
	    return result;
	  }
	
	  const parsedUrl = parseURL(sourceStr);
	
	  if (!parsedUrl) {
	    // Malformed URI.
	    long = sourceStr;
	    short = sourceStr.slice(0, 100);
	  } else {
	    host = parsedUrl.host;
	
	    long = parsedUrl.href;
	    if (parsedUrl.hash) {
	      long = long.replace(parsedUrl.hash, "");
	    }
	    if (parsedUrl.search) {
	      long = long.replace(parsedUrl.search, "");
	    }
	
	    short = parsedUrl.fileName;
	    // If `short` is just a slash, and we actually have a path,
	    // strip the slash and parse again to get a more useful short name.
	    // e.g. "http://foo.com/bar/" -> "bar", rather than "/"
	    if (short === "/" && parsedUrl.pathname !== "/") {
	      short = parseURL(long.replace(/\/$/, "")).fileName;
	    }
	  }
	
	  if (!short) {
	    if (!long) {
	      long = UNKNOWN_SOURCE_STRING;
	    }
	    short = long.slice(0, 100);
	  }
	
	  let result = { short, long, host };
	  gSourceNamesStore.set(source, result);
	  return result;
	}
	
	// For the functions below, we assume that we will never access the location
	// argument out of bounds, which is indeed the vast majority of cases.
	//
	// They are written this way because they are hot. Each frame is checked for
	// being content or chrome when processing the profile.
	
	function isColonSlashSlash(location, i = 0) {
	  return location.charCodeAt(++i) === CHAR_CODE_COLON &&
	         location.charCodeAt(++i) === CHAR_CODE_SLASH &&
	         location.charCodeAt(++i) === CHAR_CODE_SLASH;
	}
	
	/**
	 * Checks for a Scratchpad URI, like "Scratchpad/1"
	 */
	function isScratchpadScheme(location, i = 0) {
	  return location.charCodeAt(i) === CHAR_CODE_CAP_S &&
	         location.charCodeAt(++i) === CHAR_CODE_C &&
	         location.charCodeAt(++i) === CHAR_CODE_R &&
	         location.charCodeAt(++i) === CHAR_CODE_A &&
	         location.charCodeAt(++i) === CHAR_CODE_T &&
	         location.charCodeAt(++i) === CHAR_CODE_C &&
	         location.charCodeAt(++i) === CHAR_CODE_H &&
	         location.charCodeAt(++i) === CHAR_CODE_P &&
	         location.charCodeAt(++i) === CHAR_CODE_A &&
	         location.charCodeAt(++i) === CHAR_CODE_D &&
	         location.charCodeAt(++i) === CHAR_CODE_SLASH;
	}
	
	function isDataScheme(location, i = 0) {
	  return location.charCodeAt(i) === CHAR_CODE_D &&
	         location.charCodeAt(++i) === CHAR_CODE_A &&
	         location.charCodeAt(++i) === CHAR_CODE_T &&
	         location.charCodeAt(++i) === CHAR_CODE_A &&
	         location.charCodeAt(++i) === CHAR_CODE_COLON;
	}
	
	function isContentScheme(location, i = 0) {
	  let firstChar = location.charCodeAt(i);
	
	  switch (firstChar) {
	    // "http://" or "https://"
	    case CHAR_CODE_H:
	      if (location.charCodeAt(++i) === CHAR_CODE_T &&
	          location.charCodeAt(++i) === CHAR_CODE_T &&
	          location.charCodeAt(++i) === CHAR_CODE_P) {
	        if (location.charCodeAt(i + 1) === CHAR_CODE_S) {
	          ++i;
	        }
	        return isColonSlashSlash(location, i);
	      }
	      return false;
	
	    // "file://"
	    case CHAR_CODE_F:
	      if (location.charCodeAt(++i) === CHAR_CODE_I &&
	          location.charCodeAt(++i) === CHAR_CODE_L &&
	          location.charCodeAt(++i) === CHAR_CODE_E) {
	        return isColonSlashSlash(location, i);
	      }
	      return false;
	
	    // "app://"
	    case CHAR_CODE_A:
	      if (location.charCodeAt(++i) == CHAR_CODE_P &&
	          location.charCodeAt(++i) == CHAR_CODE_P) {
	        return isColonSlashSlash(location, i);
	      }
	      return false;
	
	    default:
	      return false;
	  }
	}
	
	function isChromeScheme(location, i = 0) {
	  let firstChar = location.charCodeAt(i);
	
	  switch (firstChar) {
	    // "chrome://"
	    case CHAR_CODE_C:
	      if (location.charCodeAt(++i) === CHAR_CODE_H &&
	          location.charCodeAt(++i) === CHAR_CODE_R &&
	          location.charCodeAt(++i) === CHAR_CODE_O &&
	          location.charCodeAt(++i) === CHAR_CODE_M &&
	          location.charCodeAt(++i) === CHAR_CODE_E) {
	        return isColonSlashSlash(location, i);
	      }
	      return false;
	
	    // "resource://"
	    case CHAR_CODE_R:
	      if (location.charCodeAt(++i) === CHAR_CODE_E &&
	          location.charCodeAt(++i) === CHAR_CODE_S &&
	          location.charCodeAt(++i) === CHAR_CODE_O &&
	          location.charCodeAt(++i) === CHAR_CODE_U &&
	          location.charCodeAt(++i) === CHAR_CODE_R &&
	          location.charCodeAt(++i) === CHAR_CODE_C &&
	          location.charCodeAt(++i) === CHAR_CODE_E) {
	        return isColonSlashSlash(location, i);
	      }
	      return false;
	
	    // "jar:file://"
	    case CHAR_CODE_J:
	      if (location.charCodeAt(++i) === CHAR_CODE_A &&
	          location.charCodeAt(++i) === CHAR_CODE_R &&
	          location.charCodeAt(++i) === CHAR_CODE_COLON &&
	          location.charCodeAt(++i) === CHAR_CODE_F &&
	          location.charCodeAt(++i) === CHAR_CODE_I &&
	          location.charCodeAt(++i) === CHAR_CODE_L &&
	          location.charCodeAt(++i) === CHAR_CODE_E) {
	        return isColonSlashSlash(location, i);
	      }
	      return false;
	
	    default:
	      return false;
	  }
	}
	
	/**
	 * A utility method to get the file name from a sourcemapped location
	 * The sourcemap location can be in any form. This method returns a
	 * formatted file name for different cases like Windows or OSX.
	 * @param source
	 * @returns String
	 */
	function getSourceMappedFile(source) {
	  // If sourcemapped source is a OSX path, return
	  // the characters after last "/".
	  // If sourcemapped source is a Windowss path, return
	  // the characters after last "\\".
	  if (source.lastIndexOf("/") >= 0) {
	    source = source.slice(source.lastIndexOf("/") + 1);
	  } else if (source.lastIndexOf("\\") >= 0) {
	    source = source.slice(source.lastIndexOf("\\") + 1);
	  }
	  return source;
	}
	
	exports.parseURL = parseURL;
	exports.getSourceNames = getSourceNames;
	exports.isScratchpadScheme = isScratchpadScheme;
	exports.isChromeScheme = isChromeScheme;
	exports.isContentScheme = isContentScheme;
	exports.isDataScheme = isDataScheme;
	exports.getSourceMappedFile = getSourceMappedFile;


/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
	 * You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	"use strict";
	
	const { DOM: dom, createClass, PropTypes } = __webpack_require__(2);
	const { getSourceNames, parseURL,
	        isScratchpadScheme, getSourceMappedFile } = __webpack_require__(286);
	// const { LocalizationHelper } = require("devtools/shared/l10n");
	//
	// const l10n = new LocalizationHelper("devtools/client/locales/components.properties");
	// const webl10n = new LocalizationHelper("devtools/client/locales/webconsole.properties");
	
	const l10n = { getStr: () => {} };
	const webl10n = { getStr: () => {} };
	
	module.exports = createClass({
	  displayName: "Frame",
	
	  propTypes: {
	    // SavedFrame, or an object containing all the required properties.
	    frame: PropTypes.shape({
	      functionDisplayName: PropTypes.string,
	      source: PropTypes.string.isRequired,
	      line: PropTypes.oneOfType([ PropTypes.string, PropTypes.number ]),
	      column: PropTypes.oneOfType([ PropTypes.string, PropTypes.number ]),
	    }).isRequired,
	    // Clicking on the frame link -- probably should link to the debugger.
	    onClick: PropTypes.func.isRequired,
	    // Option to display a function name before the source link.
	    showFunctionName: PropTypes.bool,
	    // Option to display a function name even if it's anonymous.
	    showAnonymousFunctionName: PropTypes.bool,
	    // Option to display a host name after the source link.
	    showHost: PropTypes.bool,
	    // Option to display a host name if the filename is empty or just '/'
	    showEmptyPathAsHost: PropTypes.bool,
	    // Option to display a full source instead of just the filename.
	    showFullSourceUrl: PropTypes.bool,
	    // Service to enable the source map feature for console.
	    sourceMapService: PropTypes.object,
	  },
	
	  getDefaultProps() {
	    return {
	      showFunctionName: false,
	      showAnonymousFunctionName: false,
	      showHost: false,
	      showEmptyPathAsHost: false,
	      showFullSourceUrl: false,
	    };
	  },
	
	  componentWillMount() {
	    const sourceMapService = this.props.sourceMapService;
	    if (sourceMapService) {
	      const source = this.getSource();
	      sourceMapService.subscribe(source, this.onSourceUpdated);
	    }
	  },
	
	  componentWillUnmount() {
	    const sourceMapService = this.props.sourceMapService;
	    if (sourceMapService) {
	      const source = this.getSource();
	      sourceMapService.unsubscribe(source, this.onSourceUpdated);
	    }
	  },
	
	  /**
	   * Component method to update the FrameView when a resolved location is available
	   * @param event
	   * @param location
	   */
	  onSourceUpdated(event, location, resolvedLocation) {
	    const frame = this.getFrame(resolvedLocation);
	    this.setState({
	      frame,
	      isSourceMapped: true,
	    });
	  },
	
	  /**
	   * Utility method to convert the Frame object to the
	   * Source Object model required by SourceMapService
	   * @param frame
	   * @returns {{url: *, line: *, column: *}}
	   */
	  getSource(frame) {
	    frame = frame || this.props.frame;
	    const { source, line, column } = frame;
	    return {
	      url: source,
	      line,
	      column,
	    };
	  },
	
	  /**
	   * Utility method to convert the Source object model to the
	   * Frame object model required by FrameView class.
	   * @param source
	   * @returns {{source: *, line: *, column: *, functionDisplayName: *}}
	   */
	  getFrame(source) {
	    const { url, line, column } = source;
	    return {
	      source: url,
	      line,
	      column,
	      functionDisplayName: this.props.frame.functionDisplayName,
	    };
	  },
	
	  render() {
	    let frame, isSourceMapped;
	    let {
	      onClick,
	      showFunctionName,
	      showAnonymousFunctionName,
	      showHost,
	      showEmptyPathAsHost,
	      showFullSourceUrl
	    } = this.props;
	
	    if (this.state && this.state.isSourceMapped) {
	      frame = this.state.frame;
	      isSourceMapped = this.state.isSourceMapped;
	    } else {
	      frame = this.props.frame;
	    }
	
	    let source = frame.source ? String(frame.source) : "";
	    let line = frame.line != void 0 ? Number(frame.line) : null;
	    let column = frame.column != void 0 ? Number(frame.column) : null;
	
	    const { short, long, host } = getSourceNames(source);
	    // Reparse the URL to determine if we should link this; `getSourceNames`
	    // has already cached this indirectly. We don't want to attempt to
	    // link to "self-hosted" and "(unknown)". However, we do want to link
	    // to Scratchpad URIs.
	    // Source mapped sources might not necessary linkable, but they
	    // are still valid in the debugger.
	    const isLinkable = !!(isScratchpadScheme(source) || parseURL(source))
	      || isSourceMapped;
	    const elements = [];
	    const sourceElements = [];
	    let sourceEl;
	
	    let tooltip = long;
	
	    // If the source is linkable and line > 0
	    const shouldDisplayLine = isLinkable && line;
	
	    // Exclude all falsy values, including `0`, as even
	    // a number 0 for line doesn't make sense, and should not be displayed.
	    // If source isn't linkable, don't attempt to append line and column
	    // info, as this probably doesn't make sense.
	    if (shouldDisplayLine) {
	      tooltip += `:${line}`;
	      // Intentionally exclude 0
	      if (column) {
	        tooltip += `:${column}`;
	      }
	    }
	
	    let attributes = {
	      "data-url": long,
	      className: "frame-link",
	    };
	
	    if (showFunctionName) {
	      let functionDisplayName = frame.functionDisplayName;
	      if (!functionDisplayName && showAnonymousFunctionName) {
	        functionDisplayName = webl10n.getStr("stacktrace.anonymousFunction");
	      }
	
	      if (functionDisplayName) {
	        elements.push(
	          dom.span({ className: "frame-link-function-display-name" },
	            functionDisplayName),
	          " "
	        );
	      }
	    }
	
	    let displaySource = showFullSourceUrl ? long : short;
	    if (isSourceMapped) {
	      displaySource = getSourceMappedFile(displaySource);
	    } else if (showEmptyPathAsHost && (displaySource === "" || displaySource === "/")) {
	      displaySource = host;
	    }
	
	    sourceElements.push(dom.span({
	      className: "frame-link-filename",
	    }, displaySource));
	
	    // If source is linkable, and we have a line number > 0
	    if (shouldDisplayLine) {
	      let lineInfo = `:${line}`;
	      // Add `data-line` attribute for testing
	      attributes["data-line"] = line;
	
	      // Intentionally exclude 0
	      if (column) {
	        lineInfo += `:${column}`;
	        // Add `data-column` attribute for testing
	        attributes["data-column"] = column;
	      }
	
	      sourceElements.push(dom.span({ className: "frame-link-line" }, lineInfo));
	    }
	
	    // Inner el is useful for achieving ellipsis on the left and correct LTR/RTL
	    // ordering. See CSS styles for frame-link-source-[inner] and bug 1290056.
	    let sourceInnerEl = dom.span({
	      className: "frame-link-source-inner",
	      title: isLinkable ?
	        l10n.getFormatStr("frame.viewsourceindebugger", tooltip) : tooltip,
	    }, sourceElements);
	
	    // If source is not a URL (self-hosted, eval, etc.), don't make
	    // it an anchor link, as we can't link to it.
	    if (isLinkable) {
	      sourceEl = dom.a({
	        onClick: e => {
	          e.preventDefault();
	          onClick(this.getSource(frame));
	        },
	        href: source,
	        className: "frame-link-source",
	        draggable: false,
	      }, sourceInnerEl);
	    } else {
	      sourceEl = dom.span({
	        className: "frame-link-source",
	      }, sourceInnerEl);
	    }
	    elements.push(sourceEl);
	
	    if (showHost && host) {
	      elements.push(" ", dom.span({ className: "frame-link-host" }, host));
	    }
	
	    return dom.span(attributes, ...elements);
	  }
	});


/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	var expressions = __webpack_require__(289);
	var eventListeners = __webpack_require__(293);
	var sources = __webpack_require__(294);
	var breakpoints = __webpack_require__(297);
	var asyncRequests = __webpack_require__(299);
	var pause = __webpack_require__(300);
	var ui = __webpack_require__(301);
	var coverage = __webpack_require__(302);
	
	module.exports = {
	  expressions: expressions.update,
	  eventListeners: eventListeners.update,
	  sources: sources.update,
	  breakpoints: breakpoints.update,
	  pause: pause.update,
	  asyncRequests,
	  ui: ui.update,
	  coverage: coverage.update
	};

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	var constants = __webpack_require__(290);
	var makeRecord = __webpack_require__(291);
	var I = __webpack_require__(292);
	
	var State = makeRecord({
	  expressions: I.List()
	});
	
	function update() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : State();
	  var action = arguments[1];
	
	  switch (action.type) {
	
	    case constants.ADD_EXPRESSION:
	      return state.setIn(["expressions", action.id], { id: action.id,
	        input: action.input,
	        value: action.value,
	        updating: false });
	
	    case constants.EVALUATE_EXPRESSION:
	      if (action.status === "done") {
	        return state.mergeIn(["expressions", action.id], { id: action.id,
	          input: action.input,
	          value: action.value,
	          updating: false });
	      }
	      break;
	
	    case constants.UPDATE_EXPRESSION:
	      return state.mergeIn(["expressions", action.id], { id: action.id,
	        input: action.input,
	        updating: true });
	
	    case constants.DELETE_EXPRESSION:
	      return deleteExpression(state, action.id);
	  }
	
	  return state;
	}
	
	function deleteExpression(state, id) {
	  var index = getExpressions({ pause: state }).findKey(e => e.id == id);
	  return state.deleteIn(["expressions", index]);
	}
	
	function getExpressions(state) {
	  return state.expressions.get("expressions");
	}
	
	module.exports = {
	  State,
	  update,
	  getExpressions
	};

/***/ },
/* 290 */
/***/ function(module, exports) {

	
	
	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	exports.UPDATE_EVENT_BREAKPOINTS = "UPDATE_EVENT_BREAKPOINTS";
	exports.FETCH_EVENT_LISTENERS = "FETCH_EVENT_LISTENERS";
	
	exports.TOGGLE_PRETTY_PRINT = "TOGGLE_PRETTY_PRINT";
	exports.BLACKBOX = "BLACKBOX";
	
	exports.ADD_BREAKPOINT = "ADD_BREAKPOINT";
	exports.REMOVE_BREAKPOINT = "REMOVE_BREAKPOINT";
	exports.ENABLE_BREAKPOINT = "ENABLE_BREAKPOINT";
	exports.DISABLE_BREAKPOINT = "DISABLE_BREAKPOINT";
	exports.SET_BREAKPOINT_CONDITION = "SET_BREAKPOINT_CONDITION";
	exports.TOGGLE_BREAKPOINTS = "TOGGLE_BREAKPOINTS";
	
	exports.ADD_SOURCE = "ADD_SOURCE";
	exports.ADD_SOURCES = "ADD_SOURCES";
	exports.LOAD_SOURCE_TEXT = "LOAD_SOURCE_TEXT";
	exports.SELECT_SOURCE = "SELECT_SOURCE";
	exports.SELECT_SOURCE_URL = "SELECT_SOURCE_URL";
	exports.CLOSE_TAB = "CLOSE_TAB";
	exports.CLOSE_TABS = "CLOSE_TABS";
	exports.NAVIGATE = "NAVIGATE";
	exports.RELOAD = "RELOAD";
	
	exports.ADD_TABS = "ADD_TABS";
	exports.SELECT_TAB = "SELECT_TAB";
	
	exports.BREAK_ON_NEXT = "BREAK_ON_NEXT";
	exports.RESUME = "RESUME";
	exports.PAUSED = "PAUSED";
	exports.PAUSE_ON_EXCEPTIONS = "PAUSE_ON_EXCEPTIONS";
	exports.COMMAND = "COMMAND";
	exports.SELECT_FRAME = "SELECT_FRAME";
	exports.LOAD_OBJECT_PROPERTIES = "LOAD_OBJECT_PROPERTIES";
	exports.ADD_EXPRESSION = "ADD_EXPRESSION";
	exports.EVALUATE_EXPRESSION = "EVALUATE_EXPRESSION";
	exports.UPDATE_EXPRESSION = "UPDATE_EXPRESSION";
	exports.DELETE_EXPRESSION = "DELETE_EXPRESSION";
	
	exports.RECORD_COVERAGE = "RECORD_COVERAGE";
	
	exports.TOGGLE_FILE_SEARCH = "TOGGLE_FILE_SEARCH";
	exports.SHOW_SOURCE = "SHOW_SOURCE";
	exports.TOGGLE_PANE = "TOGGLE_PANE";

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	
	
	/**
	 * When Flow 0.29 is released (very soon), we can use this Record type
	 * instead of the builtin immutable.js Record type. This is better
	 * because all the fields are actually typed, unlike the builtin one.
	 * This depends on a performance fix that will go out in 0.29 though;
	 * @module utils/makeRecord
	 */
	
	var I = __webpack_require__(292);
	
	/**
	 * @memberof utils/makeRecord
	 * @static
	 */
	
	
	/**
	 * Make an immutable record type
	 *
	 * @param spec - the keys and their default values
	 * @return a state record factory function
	 * @memberof utils/makeRecord
	 * @static
	 */
	function makeRecord(spec) {
	  return I.Record(spec);
	}
	
	module.exports = makeRecord;

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 *  Copyright (c) 2014-2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  (global.Immutable = factory());
	}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;
	
	  function createClass(ctor, superClass) {
	    if (superClass) {
	      ctor.prototype = Object.create(superClass.prototype);
	    }
	    ctor.prototype.constructor = ctor;
	  }
	
	  function Iterable(value) {
	      return isIterable(value) ? value : Seq(value);
	    }
	
	
	  createClass(KeyedIterable, Iterable);
	    function KeyedIterable(value) {
	      return isKeyed(value) ? value : KeyedSeq(value);
	    }
	
	
	  createClass(IndexedIterable, Iterable);
	    function IndexedIterable(value) {
	      return isIndexed(value) ? value : IndexedSeq(value);
	    }
	
	
	  createClass(SetIterable, Iterable);
	    function SetIterable(value) {
	      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
	    }
	
	
	
	  function isIterable(maybeIterable) {
	    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
	  }
	
	  function isKeyed(maybeKeyed) {
	    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
	  }
	
	  function isIndexed(maybeIndexed) {
	    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
	  }
	
	  function isAssociative(maybeAssociative) {
	    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
	  }
	
	  function isOrdered(maybeOrdered) {
	    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
	  }
	
	  Iterable.isIterable = isIterable;
	  Iterable.isKeyed = isKeyed;
	  Iterable.isIndexed = isIndexed;
	  Iterable.isAssociative = isAssociative;
	  Iterable.isOrdered = isOrdered;
	
	  Iterable.Keyed = KeyedIterable;
	  Iterable.Indexed = IndexedIterable;
	  Iterable.Set = SetIterable;
	
	
	  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
	
	  // Used for setting prototype methods that IE8 chokes on.
	  var DELETE = 'delete';
	
	  // Constants describing the size of trie nodes.
	  var SHIFT = 5; // Resulted in best performance after ______?
	  var SIZE = 1 << SHIFT;
	  var MASK = SIZE - 1;
	
	  // A consistent shared value representing "not set" which equals nothing other
	  // than itself, and nothing that could be provided externally.
	  var NOT_SET = {};
	
	  // Boolean references, Rough equivalent of `bool &`.
	  var CHANGE_LENGTH = { value: false };
	  var DID_ALTER = { value: false };
	
	  function MakeRef(ref) {
	    ref.value = false;
	    return ref;
	  }
	
	  function SetRef(ref) {
	    ref && (ref.value = true);
	  }
	
	  // A function which returns a value representing an "owner" for transient writes
	  // to tries. The return value will only ever equal itself, and will not equal
	  // the return of any subsequent call of this function.
	  function OwnerID() {}
	
	  // http://jsperf.com/copy-array-inline
	  function arrCopy(arr, offset) {
	    offset = offset || 0;
	    var len = Math.max(0, arr.length - offset);
	    var newArr = new Array(len);
	    for (var ii = 0; ii < len; ii++) {
	      newArr[ii] = arr[ii + offset];
	    }
	    return newArr;
	  }
	
	  function ensureSize(iter) {
	    if (iter.size === undefined) {
	      iter.size = iter.__iterate(returnTrue);
	    }
	    return iter.size;
	  }
	
	  function wrapIndex(iter, index) {
	    // This implements "is array index" which the ECMAString spec defines as:
	    //
	    //     A String property name P is an array index if and only if
	    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
	    //     to 2^32−1.
	    //
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
	    if (typeof index !== 'number') {
	      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
	      if ('' + uint32Index !== index || uint32Index === 4294967295) {
	        return NaN;
	      }
	      index = uint32Index;
	    }
	    return index < 0 ? ensureSize(iter) + index : index;
	  }
	
	  function returnTrue() {
	    return true;
	  }
	
	  function wholeSlice(begin, end, size) {
	    return (begin === 0 || (size !== undefined && begin <= -size)) &&
	      (end === undefined || (size !== undefined && end >= size));
	  }
	
	  function resolveBegin(begin, size) {
	    return resolveIndex(begin, size, 0);
	  }
	
	  function resolveEnd(end, size) {
	    return resolveIndex(end, size, size);
	  }
	
	  function resolveIndex(index, size, defaultIndex) {
	    return index === undefined ?
	      defaultIndex :
	      index < 0 ?
	        Math.max(0, size + index) :
	        size === undefined ?
	          index :
	          Math.min(size, index);
	  }
	
	  /* global Symbol */
	
	  var ITERATE_KEYS = 0;
	  var ITERATE_VALUES = 1;
	  var ITERATE_ENTRIES = 2;
	
	  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator';
	
	  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
	
	
	  function Iterator(next) {
	      this.next = next;
	    }
	
	    Iterator.prototype.toString = function() {
	      return '[Iterator]';
	    };
	
	
	  Iterator.KEYS = ITERATE_KEYS;
	  Iterator.VALUES = ITERATE_VALUES;
	  Iterator.ENTRIES = ITERATE_ENTRIES;
	
	  Iterator.prototype.inspect =
	  Iterator.prototype.toSource = function () { return this.toString(); }
	  Iterator.prototype[ITERATOR_SYMBOL] = function () {
	    return this;
	  };
	
	
	  function iteratorValue(type, k, v, iteratorResult) {
	    var value = type === 0 ? k : type === 1 ? v : [k, v];
	    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
	      value: value, done: false
	    });
	    return iteratorResult;
	  }
	
	  function iteratorDone() {
	    return { value: undefined, done: true };
	  }
	
	  function hasIterator(maybeIterable) {
	    return !!getIteratorFn(maybeIterable);
	  }
	
	  function isIterator(maybeIterator) {
	    return maybeIterator && typeof maybeIterator.next === 'function';
	  }
	
	  function getIterator(iterable) {
	    var iteratorFn = getIteratorFn(iterable);
	    return iteratorFn && iteratorFn.call(iterable);
	  }
	
	  function getIteratorFn(iterable) {
	    var iteratorFn = iterable && (
	      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
	      iterable[FAUX_ITERATOR_SYMBOL]
	    );
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }
	
	  function isArrayLike(value) {
	    return value && typeof value.length === 'number';
	  }
	
	  createClass(Seq, Iterable);
	    function Seq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        isIterable(value) ? value.toSeq() : seqFromValue(value);
	    }
	
	    Seq.of = function(/*...values*/) {
	      return Seq(arguments);
	    };
	
	    Seq.prototype.toSeq = function() {
	      return this;
	    };
	
	    Seq.prototype.toString = function() {
	      return this.__toString('Seq {', '}');
	    };
	
	    Seq.prototype.cacheResult = function() {
	      if (!this._cache && this.__iterateUncached) {
	        this._cache = this.entrySeq().toArray();
	        this.size = this._cache.length;
	      }
	      return this;
	    };
	
	    // abstract __iterateUncached(fn, reverse)
	
	    Seq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, true);
	    };
	
	    // abstract __iteratorUncached(type, reverse)
	
	    Seq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, true);
	    };
	
	
	
	  createClass(KeyedSeq, Seq);
	    function KeyedSeq(value) {
	      return value === null || value === undefined ?
	        emptySequence().toKeyedSeq() :
	        isIterable(value) ?
	          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
	          keyedSeqFromValue(value);
	    }
	
	    KeyedSeq.prototype.toKeyedSeq = function() {
	      return this;
	    };
	
	
	
	  createClass(IndexedSeq, Seq);
	    function IndexedSeq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
	    }
	
	    IndexedSeq.of = function(/*...values*/) {
	      return IndexedSeq(arguments);
	    };
	
	    IndexedSeq.prototype.toIndexedSeq = function() {
	      return this;
	    };
	
	    IndexedSeq.prototype.toString = function() {
	      return this.__toString('Seq [', ']');
	    };
	
	    IndexedSeq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, false);
	    };
	
	    IndexedSeq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, false);
	    };
	
	
	
	  createClass(SetSeq, Seq);
	    function SetSeq(value) {
	      return (
	        value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value
	      ).toSetSeq();
	    }
	
	    SetSeq.of = function(/*...values*/) {
	      return SetSeq(arguments);
	    };
	
	    SetSeq.prototype.toSetSeq = function() {
	      return this;
	    };
	
	
	
	  Seq.isSeq = isSeq;
	  Seq.Keyed = KeyedSeq;
	  Seq.Set = SetSeq;
	  Seq.Indexed = IndexedSeq;
	
	  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';
	
	  Seq.prototype[IS_SEQ_SENTINEL] = true;
	
	
	
	  createClass(ArraySeq, IndexedSeq);
	    function ArraySeq(array) {
	      this._array = array;
	      this.size = array.length;
	    }
	
	    ArraySeq.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
	    };
	
	    ArraySeq.prototype.__iterate = function(fn, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };
	
	    ArraySeq.prototype.__iterator = function(type, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
	      );
	    };
	
	
	
	  createClass(ObjectSeq, KeyedSeq);
	    function ObjectSeq(object) {
	      var keys = Object.keys(object);
	      this._object = object;
	      this._keys = keys;
	      this.size = keys.length;
	    }
	
	    ObjectSeq.prototype.get = function(key, notSetValue) {
	      if (notSetValue !== undefined && !this.has(key)) {
	        return notSetValue;
	      }
	      return this._object[key];
	    };
	
	    ObjectSeq.prototype.has = function(key) {
	      return this._object.hasOwnProperty(key);
	    };
	
	    ObjectSeq.prototype.__iterate = function(fn, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        if (fn(object[key], key, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };
	
	    ObjectSeq.prototype.__iterator = function(type, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, key, object[key]);
	      });
	    };
	
	  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;
	
	
	  createClass(IterableSeq, IndexedSeq);
	    function IterableSeq(iterable) {
	      this._iterable = iterable;
	      this.size = iterable.length || iterable.size;
	    }
	
	    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      var iterations = 0;
	      if (isIterator(iterator)) {
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (fn(step.value, iterations++, this) === false) {
	            break;
	          }
	        }
	      }
	      return iterations;
	    };
	
	    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      if (!isIterator(iterator)) {
	        return new Iterator(iteratorDone);
	      }
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, iterations++, step.value);
	      });
	    };
	
	
	
	  createClass(IteratorSeq, IndexedSeq);
	    function IteratorSeq(iterator) {
	      this._iterator = iterator;
	      this._iteratorCache = [];
	    }
	
	    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      while (iterations < cache.length) {
	        if (fn(cache[iterations], iterations++, this) === false) {
	          return iterations;
	        }
	      }
	      var step;
	      while (!(step = iterator.next()).done) {
	        var val = step.value;
	        cache[iterations] = val;
	        if (fn(val, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	
	    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      return new Iterator(function()  {
	        if (iterations >= cache.length) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          cache[iterations] = step.value;
	        }
	        return iteratorValue(type, iterations, cache[iterations++]);
	      });
	    };
	
	
	
	
	  // # pragma Helper functions
	
	  function isSeq(maybeSeq) {
	    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
	  }
	
	  var EMPTY_SEQ;
	
	  function emptySequence() {
	    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
	  }
	
	  function keyedSeqFromValue(value) {
	    var seq =
	      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
	      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
	      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
	      typeof value === 'object' ? new ObjectSeq(value) :
	      undefined;
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of [k, v] entries, '+
	        'or keyed object: ' + value
	      );
	    }
	    return seq;
	  }
	
	  function indexedSeqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value);
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values: ' + value
	      );
	    }
	    return seq;
	  }
	
	  function seqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value) ||
	      (typeof value === 'object' && new ObjectSeq(value));
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values, or keyed object: ' + value
	      );
	    }
	    return seq;
	  }
	
	  function maybeIndexedSeqFromValue(value) {
	    return (
	      isArrayLike(value) ? new ArraySeq(value) :
	      isIterator(value) ? new IteratorSeq(value) :
	      hasIterator(value) ? new IterableSeq(value) :
	      undefined
	    );
	  }
	
	  function seqIterate(seq, fn, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    }
	    return seq.__iterateUncached(fn, reverse);
	  }
	
	  function seqIterator(seq, type, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
	      });
	    }
	    return seq.__iteratorUncached(type, reverse);
	  }
	
	  function fromJS(json, converter) {
	    return converter ?
	      fromJSWith(converter, json, '', {'': json}) :
	      fromJSDefault(json);
	  }
	
	  function fromJSWith(converter, json, key, parentJSON) {
	    if (Array.isArray(json)) {
	      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    if (isPlainObj(json)) {
	      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    return json;
	  }
	
	  function fromJSDefault(json) {
	    if (Array.isArray(json)) {
	      return IndexedSeq(json).map(fromJSDefault).toList();
	    }
	    if (isPlainObj(json)) {
	      return KeyedSeq(json).map(fromJSDefault).toMap();
	    }
	    return json;
	  }
	
	  function isPlainObj(value) {
	    return value && (value.constructor === Object || value.constructor === undefined);
	  }
	
	  /**
	   * An extension of the "same-value" algorithm as [described for use by ES6 Map
	   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
	   *
	   * NaN is considered the same as NaN, however -0 and 0 are considered the same
	   * value, which is different from the algorithm described by
	   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
	   *
	   * This is extended further to allow Objects to describe the values they
	   * represent, by way of `valueOf` or `equals` (and `hashCode`).
	   *
	   * Note: because of this extension, the key equality of Immutable.Map and the
	   * value equality of Immutable.Set will differ from ES6 Map and Set.
	   *
	   * ### Defining custom values
	   *
	   * The easiest way to describe the value an object represents is by implementing
	   * `valueOf`. For example, `Date` represents a value by returning a unix
	   * timestamp for `valueOf`:
	   *
	   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
	   *     var date2 = new Date(1234567890000);
	   *     date1.valueOf(); // 1234567890000
	   *     assert( date1 !== date2 );
	   *     assert( Immutable.is( date1, date2 ) );
	   *
	   * Note: overriding `valueOf` may have other implications if you use this object
	   * where JavaScript expects a primitive, such as implicit string coercion.
	   *
	   * For more complex types, especially collections, implementing `valueOf` may
	   * not be performant. An alternative is to implement `equals` and `hashCode`.
	   *
	   * `equals` takes another object, presumably of similar type, and returns true
	   * if the it is equal. Equality is symmetrical, so the same result should be
	   * returned if this and the argument are flipped.
	   *
	   *     assert( a.equals(b) === b.equals(a) );
	   *
	   * `hashCode` returns a 32bit integer number representing the object which will
	   * be used to determine how to store the value object in a Map or Set. You must
	   * provide both or neither methods, one must not exist without the other.
	   *
	   * Also, an important relationship between these methods must be upheld: if two
	   * values are equal, they *must* return the same hashCode. If the values are not
	   * equal, they might have the same hashCode; this is called a hash collision,
	   * and while undesirable for performance reasons, it is acceptable.
	   *
	   *     if (a.equals(b)) {
	   *       assert( a.hashCode() === b.hashCode() );
	   *     }
	   *
	   * All Immutable collections implement `equals` and `hashCode`.
	   *
	   */
	  function is(valueA, valueB) {
	    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	      return true;
	    }
	    if (!valueA || !valueB) {
	      return false;
	    }
	    if (typeof valueA.valueOf === 'function' &&
	        typeof valueB.valueOf === 'function') {
	      valueA = valueA.valueOf();
	      valueB = valueB.valueOf();
	      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	        return true;
	      }
	      if (!valueA || !valueB) {
	        return false;
	      }
	    }
	    if (typeof valueA.equals === 'function' &&
	        typeof valueB.equals === 'function' &&
	        valueA.equals(valueB)) {
	      return true;
	    }
	    return false;
	  }
	
	  function deepEqual(a, b) {
	    if (a === b) {
	      return true;
	    }
	
	    if (
	      !isIterable(b) ||
	      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
	      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
	      isKeyed(a) !== isKeyed(b) ||
	      isIndexed(a) !== isIndexed(b) ||
	      isOrdered(a) !== isOrdered(b)
	    ) {
	      return false;
	    }
	
	    if (a.size === 0 && b.size === 0) {
	      return true;
	    }
	
	    var notAssociative = !isAssociative(a);
	
	    if (isOrdered(a)) {
	      var entries = a.entries();
	      return b.every(function(v, k)  {
	        var entry = entries.next().value;
	        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
	      }) && entries.next().done;
	    }
	
	    var flipped = false;
	
	    if (a.size === undefined) {
	      if (b.size === undefined) {
	        if (typeof a.cacheResult === 'function') {
	          a.cacheResult();
	        }
	      } else {
	        flipped = true;
	        var _ = a;
	        a = b;
	        b = _;
	      }
	    }
	
	    var allEqual = true;
	    var bSize = b.__iterate(function(v, k)  {
	      if (notAssociative ? !a.has(v) :
	          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
	        allEqual = false;
	        return false;
	      }
	    });
	
	    return allEqual && a.size === bSize;
	  }
	
	  createClass(Repeat, IndexedSeq);
	
	    function Repeat(value, times) {
	      if (!(this instanceof Repeat)) {
	        return new Repeat(value, times);
	      }
	      this._value = value;
	      this.size = times === undefined ? Infinity : Math.max(0, times);
	      if (this.size === 0) {
	        if (EMPTY_REPEAT) {
	          return EMPTY_REPEAT;
	        }
	        EMPTY_REPEAT = this;
	      }
	    }
	
	    Repeat.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Repeat []';
	      }
	      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
	    };
	
	    Repeat.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._value : notSetValue;
	    };
	
	    Repeat.prototype.includes = function(searchValue) {
	      return is(this._value, searchValue);
	    };
	
	    Repeat.prototype.slice = function(begin, end) {
	      var size = this.size;
	      return wholeSlice(begin, end, size) ? this :
	        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
	    };
	
	    Repeat.prototype.reverse = function() {
	      return this;
	    };
	
	    Repeat.prototype.indexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return 0;
	      }
	      return -1;
	    };
	
	    Repeat.prototype.lastIndexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return this.size;
	      }
	      return -1;
	    };
	
	    Repeat.prototype.__iterate = function(fn, reverse) {
	      for (var ii = 0; ii < this.size; ii++) {
	        if (fn(this._value, ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };
	
	    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
	      );
	    };
	
	    Repeat.prototype.equals = function(other) {
	      return other instanceof Repeat ?
	        is(this._value, other._value) :
	        deepEqual(other);
	    };
	
	
	  var EMPTY_REPEAT;
	
	  function invariant(condition, error) {
	    if (!condition) throw new Error(error);
	  }
	
	  createClass(Range, IndexedSeq);
	
	    function Range(start, end, step) {
	      if (!(this instanceof Range)) {
	        return new Range(start, end, step);
	      }
	      invariant(step !== 0, 'Cannot step a Range by 0');
	      start = start || 0;
	      if (end === undefined) {
	        end = Infinity;
	      }
	      step = step === undefined ? 1 : Math.abs(step);
	      if (end < start) {
	        step = -step;
	      }
	      this._start = start;
	      this._end = end;
	      this._step = step;
	      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
	      if (this.size === 0) {
	        if (EMPTY_RANGE) {
	          return EMPTY_RANGE;
	        }
	        EMPTY_RANGE = this;
	      }
	    }
	
	    Range.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Range []';
	      }
	      return 'Range [ ' +
	        this._start + '...' + this._end +
	        (this._step !== 1 ? ' by ' + this._step : '') +
	      ' ]';
	    };
	
	    Range.prototype.get = function(index, notSetValue) {
	      return this.has(index) ?
	        this._start + wrapIndex(this, index) * this._step :
	        notSetValue;
	    };
	
	    Range.prototype.includes = function(searchValue) {
	      var possibleIndex = (searchValue - this._start) / this._step;
	      return possibleIndex >= 0 &&
	        possibleIndex < this.size &&
	        possibleIndex === Math.floor(possibleIndex);
	    };
	
	    Range.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      begin = resolveBegin(begin, this.size);
	      end = resolveEnd(end, this.size);
	      if (end <= begin) {
	        return new Range(0, 0);
	      }
	      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
	    };
	
	    Range.prototype.indexOf = function(searchValue) {
	      var offsetValue = searchValue - this._start;
	      if (offsetValue % this._step === 0) {
	        var index = offsetValue / this._step;
	        if (index >= 0 && index < this.size) {
	          return index
	        }
	      }
	      return -1;
	    };
	
	    Range.prototype.lastIndexOf = function(searchValue) {
	      return this.indexOf(searchValue);
	    };
	
	    Range.prototype.__iterate = function(fn, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(value, ii, this) === false) {
	          return ii + 1;
	        }
	        value += reverse ? -step : step;
	      }
	      return ii;
	    };
	
	    Range.prototype.__iterator = function(type, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      var ii = 0;
	      return new Iterator(function()  {
	        var v = value;
	        value += reverse ? -step : step;
	        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
	      });
	    };
	
	    Range.prototype.equals = function(other) {
	      return other instanceof Range ?
	        this._start === other._start &&
	        this._end === other._end &&
	        this._step === other._step :
	        deepEqual(this, other);
	    };
	
	
	  var EMPTY_RANGE;
	
	  createClass(Collection, Iterable);
	    function Collection() {
	      throw TypeError('Abstract');
	    }
	
	
	  createClass(KeyedCollection, Collection);function KeyedCollection() {}
	
	  createClass(IndexedCollection, Collection);function IndexedCollection() {}
	
	  createClass(SetCollection, Collection);function SetCollection() {}
	
	
	  Collection.Keyed = KeyedCollection;
	  Collection.Indexed = IndexedCollection;
	  Collection.Set = SetCollection;
	
	  var imul =
	    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
	    Math.imul :
	    function imul(a, b) {
	      a = a | 0; // int
	      b = b | 0; // int
	      var c = a & 0xffff;
	      var d = b & 0xffff;
	      // Shift by 0 fixes the sign on the high part.
	      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
	    };
	
	  // v8 has an optimization for storing 31-bit signed numbers.
	  // Values which have either 00 or 11 as the high order bits qualify.
	  // This function drops the highest order bit in a signed number, maintaining
	  // the sign bit.
	  function smi(i32) {
	    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
	  }
	
	  function hash(o) {
	    if (o === false || o === null || o === undefined) {
	      return 0;
	    }
	    if (typeof o.valueOf === 'function') {
	      o = o.valueOf();
	      if (o === false || o === null || o === undefined) {
	        return 0;
	      }
	    }
	    if (o === true) {
	      return 1;
	    }
	    var type = typeof o;
	    if (type === 'number') {
	      if (o !== o || o === Infinity) {
	        return 0;
	      }
	      var h = o | 0;
	      if (h !== o) {
	        h ^= o * 0xFFFFFFFF;
	      }
	      while (o > 0xFFFFFFFF) {
	        o /= 0xFFFFFFFF;
	        h ^= o;
	      }
	      return smi(h);
	    }
	    if (type === 'string') {
	      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
	    }
	    if (typeof o.hashCode === 'function') {
	      return o.hashCode();
	    }
	    if (type === 'object') {
	      return hashJSObj(o);
	    }
	    if (typeof o.toString === 'function') {
	      return hashString(o.toString());
	    }
	    throw new Error('Value type ' + type + ' cannot be hashed.');
	  }
	
	  function cachedHashString(string) {
	    var hash = stringHashCache[string];
	    if (hash === undefined) {
	      hash = hashString(string);
	      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
	        STRING_HASH_CACHE_SIZE = 0;
	        stringHashCache = {};
	      }
	      STRING_HASH_CACHE_SIZE++;
	      stringHashCache[string] = hash;
	    }
	    return hash;
	  }
	
	  // http://jsperf.com/hashing-strings
	  function hashString(string) {
	    // This is the hash from JVM
	    // The hash code for a string is computed as
	    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
	    // where s[i] is the ith character of the string and n is the length of
	    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
	    // (exclusive) by dropping high bits.
	    var hash = 0;
	    for (var ii = 0; ii < string.length; ii++) {
	      hash = 31 * hash + string.charCodeAt(ii) | 0;
	    }
	    return smi(hash);
	  }
	
	  function hashJSObj(obj) {
	    var hash;
	    if (usingWeakMap) {
	      hash = weakMap.get(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }
	
	    hash = obj[UID_HASH_KEY];
	    if (hash !== undefined) {
	      return hash;
	    }
	
	    if (!canDefineProperty) {
	      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
	      if (hash !== undefined) {
	        return hash;
	      }
	
	      hash = getIENodeHash(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }
	
	    hash = ++objHashUID;
	    if (objHashUID & 0x40000000) {
	      objHashUID = 0;
	    }
	
	    if (usingWeakMap) {
	      weakMap.set(obj, hash);
	    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
	      throw new Error('Non-extensible objects are not allowed as keys.');
	    } else if (canDefineProperty) {
	      Object.defineProperty(obj, UID_HASH_KEY, {
	        'enumerable': false,
	        'configurable': false,
	        'writable': false,
	        'value': hash
	      });
	    } else if (obj.propertyIsEnumerable !== undefined &&
	               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
	      // Since we can't define a non-enumerable property on the object
	      // we'll hijack one of the less-used non-enumerable properties to
	      // save our hash on it. Since this is a function it will not show up in
	      // `JSON.stringify` which is what we want.
	      obj.propertyIsEnumerable = function() {
	        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
	      };
	      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
	    } else if (obj.nodeType !== undefined) {
	      // At this point we couldn't get the IE `uniqueID` to use as a hash
	      // and we couldn't use a non-enumerable property to exploit the
	      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
	      // itself.
	      obj[UID_HASH_KEY] = hash;
	    } else {
	      throw new Error('Unable to set a non-enumerable property on object.');
	    }
	
	    return hash;
	  }
	
	  // Get references to ES5 object methods.
	  var isExtensible = Object.isExtensible;
	
	  // True if Object.defineProperty works as expected. IE8 fails this test.
	  var canDefineProperty = (function() {
	    try {
	      Object.defineProperty({}, '@', {});
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }());
	
	  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
	  // and avoid memory leaks from the IE cloneNode bug.
	  function getIENodeHash(node) {
	    if (node && node.nodeType > 0) {
	      switch (node.nodeType) {
	        case 1: // Element
	          return node.uniqueID;
	        case 9: // Document
	          return node.documentElement && node.documentElement.uniqueID;
	      }
	    }
	  }
	
	  // If possible, use a WeakMap.
	  var usingWeakMap = typeof WeakMap === 'function';
	  var weakMap;
	  if (usingWeakMap) {
	    weakMap = new WeakMap();
	  }
	
	  var objHashUID = 0;
	
	  var UID_HASH_KEY = '__immutablehash__';
	  if (typeof Symbol === 'function') {
	    UID_HASH_KEY = Symbol(UID_HASH_KEY);
	  }
	
	  var STRING_HASH_CACHE_MIN_STRLEN = 16;
	  var STRING_HASH_CACHE_MAX_SIZE = 255;
	  var STRING_HASH_CACHE_SIZE = 0;
	  var stringHashCache = {};
	
	  function assertNotInfinite(size) {
	    invariant(
	      size !== Infinity,
	      'Cannot perform this action with an infinite size.'
	    );
	  }
	
	  createClass(Map, KeyedCollection);
	
	    // @pragma Construction
	
	    function Map(value) {
	      return value === null || value === undefined ? emptyMap() :
	        isMap(value) && !isOrdered(value) ? value :
	        emptyMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }
	
	    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);
	      return emptyMap().withMutations(function(map ) {
	        for (var i = 0; i < keyValues.length; i += 2) {
	          if (i + 1 >= keyValues.length) {
	            throw new Error('Missing value for key: ' + keyValues[i]);
	          }
	          map.set(keyValues[i], keyValues[i + 1]);
	        }
	      });
	    };
	
	    Map.prototype.toString = function() {
	      return this.__toString('Map {', '}');
	    };
	
	    // @pragma Access
	
	    Map.prototype.get = function(k, notSetValue) {
	      return this._root ?
	        this._root.get(0, undefined, k, notSetValue) :
	        notSetValue;
	    };
	
	    // @pragma Modification
	
	    Map.prototype.set = function(k, v) {
	      return updateMap(this, k, v);
	    };
	
	    Map.prototype.setIn = function(keyPath, v) {
	      return this.updateIn(keyPath, NOT_SET, function()  {return v});
	    };
	
	    Map.prototype.remove = function(k) {
	      return updateMap(this, k, NOT_SET);
	    };
	
	    Map.prototype.deleteIn = function(keyPath) {
	      return this.updateIn(keyPath, function()  {return NOT_SET});
	    };
	
	    Map.prototype.update = function(k, notSetValue, updater) {
	      return arguments.length === 1 ?
	        k(this) :
	        this.updateIn([k], notSetValue, updater);
	    };
	
	    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
	      if (!updater) {
	        updater = notSetValue;
	        notSetValue = undefined;
	      }
	      var updatedValue = updateInDeepMap(
	        this,
	        forceIterator(keyPath),
	        notSetValue,
	        updater
	      );
	      return updatedValue === NOT_SET ? undefined : updatedValue;
	    };
	
	    Map.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._root = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyMap();
	    };
	
	    // @pragma Composition
	
	    Map.prototype.merge = function(/*...iters*/) {
	      return mergeIntoMapWith(this, undefined, arguments);
	    };
	
	    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, merger, iters);
	    };
	
	    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.merge === 'function' ?
	          m.merge.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };
	
	    Map.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoMapWith(this, deepMerger, arguments);
	    };
	
	    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
	    };
	
	    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.mergeDeep === 'function' ?
	          m.mergeDeep.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };
	
	    Map.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator));
	    };
	
	    Map.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator, mapper));
	    };
	
	    // @pragma Mutability
	
	    Map.prototype.withMutations = function(fn) {
	      var mutable = this.asMutable();
	      fn(mutable);
	      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
	    };
	
	    Map.prototype.asMutable = function() {
	      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
	    };
	
	    Map.prototype.asImmutable = function() {
	      return this.__ensureOwner();
	    };
	
	    Map.prototype.wasAltered = function() {
	      return this.__altered;
	    };
	
	    Map.prototype.__iterator = function(type, reverse) {
	      return new MapIterator(this, type, reverse);
	    };
	
	    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      this._root && this._root.iterate(function(entry ) {
	        iterations++;
	        return fn(entry[1], entry[0], this$0);
	      }, reverse);
	      return iterations;
	    };
	
	    Map.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeMap(this.size, this._root, ownerID, this.__hash);
	    };
	
	
	  function isMap(maybeMap) {
	    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
	  }
	
	  Map.isMap = isMap;
	
	  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';
	
	  var MapPrototype = Map.prototype;
	  MapPrototype[IS_MAP_SENTINEL] = true;
	  MapPrototype[DELETE] = MapPrototype.remove;
	  MapPrototype.removeIn = MapPrototype.deleteIn;
	
	
	  // #pragma Trie Nodes
	
	
	
	    function ArrayMapNode(ownerID, entries) {
	      this.ownerID = ownerID;
	      this.entries = entries;
	    }
	
	    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };
	
	    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	
	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;
	
	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }
	
	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);
	
	      if (removed && entries.length === 1) {
	        return; // undefined
	      }
	
	      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
	        return createNodes(ownerID, entries, key, value);
	      }
	
	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);
	
	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }
	
	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }
	
	      return new ArrayMapNode(ownerID, newEntries);
	    };
	
	
	
	
	    function BitmapIndexedNode(ownerID, bitmap, nodes) {
	      this.ownerID = ownerID;
	      this.bitmap = bitmap;
	      this.nodes = nodes;
	    }
	
	    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
	      var bitmap = this.bitmap;
	      return (bitmap & bit) === 0 ? notSetValue :
	        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
	    };
	
	    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var bit = 1 << keyHashFrag;
	      var bitmap = this.bitmap;
	      var exists = (bitmap & bit) !== 0;
	
	      if (!exists && value === NOT_SET) {
	        return this;
	      }
	
	      var idx = popCount(bitmap & (bit - 1));
	      var nodes = this.nodes;
	      var node = exists ? nodes[idx] : undefined;
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	
	      if (newNode === node) {
	        return this;
	      }
	
	      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
	        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
	      }
	
	      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
	        return nodes[idx ^ 1];
	      }
	
	      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
	        return newNode;
	      }
	
	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
	      var newNodes = exists ? newNode ?
	        setIn(nodes, idx, newNode, isEditable) :
	        spliceOut(nodes, idx, isEditable) :
	        spliceIn(nodes, idx, newNode, isEditable);
	
	      if (isEditable) {
	        this.bitmap = newBitmap;
	        this.nodes = newNodes;
	        return this;
	      }
	
	      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
	    };
	
	
	
	
	    function HashArrayMapNode(ownerID, count, nodes) {
	      this.ownerID = ownerID;
	      this.count = count;
	      this.nodes = nodes;
	    }
	
	    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var node = this.nodes[idx];
	      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
	    };
	
	    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var removed = value === NOT_SET;
	      var nodes = this.nodes;
	      var node = nodes[idx];
	
	      if (removed && !node) {
	        return this;
	      }
	
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	      if (newNode === node) {
	        return this;
	      }
	
	      var newCount = this.count;
	      if (!node) {
	        newCount++;
	      } else if (!newNode) {
	        newCount--;
	        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
	          return packNodes(ownerID, nodes, newCount, idx);
	        }
	      }
	
	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newNodes = setIn(nodes, idx, newNode, isEditable);
	
	      if (isEditable) {
	        this.count = newCount;
	        this.nodes = newNodes;
	        return this;
	      }
	
	      return new HashArrayMapNode(ownerID, newCount, newNodes);
	    };
	
	
	
	
	    function HashCollisionNode(ownerID, keyHash, entries) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entries = entries;
	    }
	
	    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };
	
	    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	
	      var removed = value === NOT_SET;
	
	      if (keyHash !== this.keyHash) {
	        if (removed) {
	          return this;
	        }
	        SetRef(didAlter);
	        SetRef(didChangeSize);
	        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
	      }
	
	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;
	
	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }
	
	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);
	
	      if (removed && len === 2) {
	        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
	      }
	
	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);
	
	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }
	
	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }
	
	      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
	    };
	
	
	
	
	    function ValueNode(ownerID, keyHash, entry) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entry = entry;
	    }
	
	    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
	    };
	
	    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	      var keyMatch = is(key, this.entry[0]);
	      if (keyMatch ? value === this.entry[1] : removed) {
	        return this;
	      }
	
	      SetRef(didAlter);
	
	      if (removed) {
	        SetRef(didChangeSize);
	        return; // undefined
	      }
	
	      if (keyMatch) {
	        if (ownerID && ownerID === this.ownerID) {
	          this.entry[1] = value;
	          return this;
	        }
	        return new ValueNode(ownerID, this.keyHash, [key, value]);
	      }
	
	      SetRef(didChangeSize);
	      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
	    };
	
	
	
	  // #pragma Iterators
	
	  ArrayMapNode.prototype.iterate =
	  HashCollisionNode.prototype.iterate = function (fn, reverse) {
	    var entries = this.entries;
	    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
	      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
	        return false;
	      }
	    }
	  }
	
	  BitmapIndexedNode.prototype.iterate =
	  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
	    var nodes = this.nodes;
	    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
	      var node = nodes[reverse ? maxIndex - ii : ii];
	      if (node && node.iterate(fn, reverse) === false) {
	        return false;
	      }
	    }
	  }
	
	  ValueNode.prototype.iterate = function (fn, reverse) {
	    return fn(this.entry);
	  }
	
	  createClass(MapIterator, Iterator);
	
	    function MapIterator(map, type, reverse) {
	      this._type = type;
	      this._reverse = reverse;
	      this._stack = map._root && mapIteratorFrame(map._root);
	    }
	
	    MapIterator.prototype.next = function() {
	      var type = this._type;
	      var stack = this._stack;
	      while (stack) {
	        var node = stack.node;
	        var index = stack.index++;
	        var maxIndex;
	        if (node.entry) {
	          if (index === 0) {
	            return mapIteratorValue(type, node.entry);
	          }
	        } else if (node.entries) {
	          maxIndex = node.entries.length - 1;
	          if (index <= maxIndex) {
	            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
	          }
	        } else {
	          maxIndex = node.nodes.length - 1;
	          if (index <= maxIndex) {
	            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
	            if (subNode) {
	              if (subNode.entry) {
	                return mapIteratorValue(type, subNode.entry);
	              }
	              stack = this._stack = mapIteratorFrame(subNode, stack);
	            }
	            continue;
	          }
	        }
	        stack = this._stack = this._stack.__prev;
	      }
	      return iteratorDone();
	    };
	
	
	  function mapIteratorValue(type, entry) {
	    return iteratorValue(type, entry[0], entry[1]);
	  }
	
	  function mapIteratorFrame(node, prev) {
	    return {
	      node: node,
	      index: 0,
	      __prev: prev
	    };
	  }
	
	  function makeMap(size, root, ownerID, hash) {
	    var map = Object.create(MapPrototype);
	    map.size = size;
	    map._root = root;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }
	
	  var EMPTY_MAP;
	  function emptyMap() {
	    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
	  }
	
	  function updateMap(map, k, v) {
	    var newRoot;
	    var newSize;
	    if (!map._root) {
	      if (v === NOT_SET) {
	        return map;
	      }
	      newSize = 1;
	      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
	    } else {
	      var didChangeSize = MakeRef(CHANGE_LENGTH);
	      var didAlter = MakeRef(DID_ALTER);
	      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
	      if (!didAlter.value) {
	        return map;
	      }
	      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
	    }
	    if (map.__ownerID) {
	      map.size = newSize;
	      map._root = newRoot;
	      map.__hash = undefined;
	      map.__altered = true;
	      return map;
	    }
	    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
	  }
	
	  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (!node) {
	      if (value === NOT_SET) {
	        return node;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return new ValueNode(ownerID, keyHash, [key, value]);
	    }
	    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
	  }
	
	  function isLeafNode(node) {
	    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
	  }
	
	  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
	    if (node.keyHash === keyHash) {
	      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
	    }
	
	    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
	    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	
	    var newNode;
	    var nodes = idx1 === idx2 ?
	      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
	      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);
	
	    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
	  }
	
	  function createNodes(ownerID, entries, key, value) {
	    if (!ownerID) {
	      ownerID = new OwnerID();
	    }
	    var node = new ValueNode(ownerID, hash(key), [key, value]);
	    for (var ii = 0; ii < entries.length; ii++) {
	      var entry = entries[ii];
	      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
	    }
	    return node;
	  }
	
	  function packNodes(ownerID, nodes, count, excluding) {
	    var bitmap = 0;
	    var packedII = 0;
	    var packedNodes = new Array(count);
	    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
	      var node = nodes[ii];
	      if (node !== undefined && ii !== excluding) {
	        bitmap |= bit;
	        packedNodes[packedII++] = node;
	      }
	    }
	    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
	  }
	
	  function expandNodes(ownerID, nodes, bitmap, including, node) {
	    var count = 0;
	    var expandedNodes = new Array(SIZE);
	    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
	      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
	    }
	    expandedNodes[including] = node;
	    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
	  }
	
	  function mergeIntoMapWith(map, merger, iterables) {
	    var iters = [];
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = KeyedIterable(value);
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    return mergeIntoCollectionWith(map, merger, iters);
	  }
	
	  function deepMerger(existing, value, key) {
	    return existing && existing.mergeDeep && isIterable(value) ?
	      existing.mergeDeep(value) :
	      is(existing, value) ? existing : value;
	  }
	
	  function deepMergerWith(merger) {
	    return function(existing, value, key)  {
	      if (existing && existing.mergeDeepWith && isIterable(value)) {
	        return existing.mergeDeepWith(merger, value);
	      }
	      var nextValue = merger(existing, value, key);
	      return is(existing, nextValue) ? existing : nextValue;
	    };
	  }
	
	  function mergeIntoCollectionWith(collection, merger, iters) {
	    iters = iters.filter(function(x ) {return x.size !== 0});
	    if (iters.length === 0) {
	      return collection;
	    }
	    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
	      return collection.constructor(iters[0]);
	    }
	    return collection.withMutations(function(collection ) {
	      var mergeIntoMap = merger ?
	        function(value, key)  {
	          collection.update(key, NOT_SET, function(existing )
	            {return existing === NOT_SET ? value : merger(existing, value, key)}
	          );
	        } :
	        function(value, key)  {
	          collection.set(key, value);
	        }
	      for (var ii = 0; ii < iters.length; ii++) {
	        iters[ii].forEach(mergeIntoMap);
	      }
	    });
	  }
	
	  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
	    var isNotSet = existing === NOT_SET;
	    var step = keyPathIter.next();
	    if (step.done) {
	      var existingValue = isNotSet ? notSetValue : existing;
	      var newValue = updater(existingValue);
	      return newValue === existingValue ? existing : newValue;
	    }
	    invariant(
	      isNotSet || (existing && existing.set),
	      'invalid keyPath'
	    );
	    var key = step.value;
	    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
	    var nextUpdated = updateInDeepMap(
	      nextExisting,
	      keyPathIter,
	      notSetValue,
	      updater
	    );
	    return nextUpdated === nextExisting ? existing :
	      nextUpdated === NOT_SET ? existing.remove(key) :
	      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
	  }
	
	  function popCount(x) {
	    x = x - ((x >> 1) & 0x55555555);
	    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
	    x = (x + (x >> 4)) & 0x0f0f0f0f;
	    x = x + (x >> 8);
	    x = x + (x >> 16);
	    return x & 0x7f;
	  }
	
	  function setIn(array, idx, val, canEdit) {
	    var newArray = canEdit ? array : arrCopy(array);
	    newArray[idx] = val;
	    return newArray;
	  }
	
	  function spliceIn(array, idx, val, canEdit) {
	    var newLen = array.length + 1;
	    if (canEdit && idx + 1 === newLen) {
	      array[idx] = val;
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        newArray[ii] = val;
	        after = -1;
	      } else {
	        newArray[ii] = array[ii + after];
	      }
	    }
	    return newArray;
	  }
	
	  function spliceOut(array, idx, canEdit) {
	    var newLen = array.length - 1;
	    if (canEdit && idx === newLen) {
	      array.pop();
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        after = 1;
	      }
	      newArray[ii] = array[ii + after];
	    }
	    return newArray;
	  }
	
	  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
	  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
	  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
	
	  createClass(List, IndexedCollection);
	
	    // @pragma Construction
	
	    function List(value) {
	      var empty = emptyList();
	      if (value === null || value === undefined) {
	        return empty;
	      }
	      if (isList(value)) {
	        return value;
	      }
	      var iter = IndexedIterable(value);
	      var size = iter.size;
	      if (size === 0) {
	        return empty;
	      }
	      assertNotInfinite(size);
	      if (size > 0 && size < SIZE) {
	        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
	      }
	      return empty.withMutations(function(list ) {
	        list.setSize(size);
	        iter.forEach(function(v, i)  {return list.set(i, v)});
	      });
	    }
	
	    List.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    List.prototype.toString = function() {
	      return this.__toString('List [', ']');
	    };
	
	    // @pragma Access
	
	    List.prototype.get = function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      if (index >= 0 && index < this.size) {
	        index += this._origin;
	        var node = listNodeFor(this, index);
	        return node && node.array[index & MASK];
	      }
	      return notSetValue;
	    };
	
	    // @pragma Modification
	
	    List.prototype.set = function(index, value) {
	      return updateList(this, index, value);
	    };
	
	    List.prototype.remove = function(index) {
	      return !this.has(index) ? this :
	        index === 0 ? this.shift() :
	        index === this.size - 1 ? this.pop() :
	        this.splice(index, 1);
	    };
	
	    List.prototype.insert = function(index, value) {
	      return this.splice(index, 0, value);
	    };
	
	    List.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = this._origin = this._capacity = 0;
	        this._level = SHIFT;
	        this._root = this._tail = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyList();
	    };
	
	    List.prototype.push = function(/*...values*/) {
	      var values = arguments;
	      var oldSize = this.size;
	      return this.withMutations(function(list ) {
	        setListBounds(list, 0, oldSize + values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(oldSize + ii, values[ii]);
	        }
	      });
	    };
	
	    List.prototype.pop = function() {
	      return setListBounds(this, 0, -1);
	    };
	
	    List.prototype.unshift = function(/*...values*/) {
	      var values = arguments;
	      return this.withMutations(function(list ) {
	        setListBounds(list, -values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(ii, values[ii]);
	        }
	      });
	    };
	
	    List.prototype.shift = function() {
	      return setListBounds(this, 1);
	    };
	
	    // @pragma Composition
	
	    List.prototype.merge = function(/*...iters*/) {
	      return mergeIntoListWith(this, undefined, arguments);
	    };
	
	    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, merger, iters);
	    };
	
	    List.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoListWith(this, deepMerger, arguments);
	    };
	
	    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, deepMergerWith(merger), iters);
	    };
	
	    List.prototype.setSize = function(size) {
	      return setListBounds(this, 0, size);
	    };
	
	    // @pragma Iteration
	
	    List.prototype.slice = function(begin, end) {
	      var size = this.size;
	      if (wholeSlice(begin, end, size)) {
	        return this;
	      }
	      return setListBounds(
	        this,
	        resolveBegin(begin, size),
	        resolveEnd(end, size)
	      );
	    };
	
	    List.prototype.__iterator = function(type, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      return new Iterator(function()  {
	        var value = values();
	        return value === DONE ?
	          iteratorDone() :
	          iteratorValue(type, index++, value);
	      });
	    };
	
	    List.prototype.__iterate = function(fn, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      var value;
	      while ((value = values()) !== DONE) {
	        if (fn(value, index++, this) === false) {
	          break;
	        }
	      }
	      return index;
	    };
	
	    List.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        return this;
	      }
	      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
	    };
	
	
	  function isList(maybeList) {
	    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
	  }
	
	  List.isList = isList;
	
	  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';
	
	  var ListPrototype = List.prototype;
	  ListPrototype[IS_LIST_SENTINEL] = true;
	  ListPrototype[DELETE] = ListPrototype.remove;
	  ListPrototype.setIn = MapPrototype.setIn;
	  ListPrototype.deleteIn =
	  ListPrototype.removeIn = MapPrototype.removeIn;
	  ListPrototype.update = MapPrototype.update;
	  ListPrototype.updateIn = MapPrototype.updateIn;
	  ListPrototype.mergeIn = MapPrototype.mergeIn;
	  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  ListPrototype.withMutations = MapPrototype.withMutations;
	  ListPrototype.asMutable = MapPrototype.asMutable;
	  ListPrototype.asImmutable = MapPrototype.asImmutable;
	  ListPrototype.wasAltered = MapPrototype.wasAltered;
	
	
	
	    function VNode(array, ownerID) {
	      this.array = array;
	      this.ownerID = ownerID;
	    }
	
	    // TODO: seems like these methods are very similar
	
	    VNode.prototype.removeBefore = function(ownerID, level, index) {
	      if (index === level ? 1 << level : 0 || this.array.length === 0) {
	        return this;
	      }
	      var originIndex = (index >>> level) & MASK;
	      if (originIndex >= this.array.length) {
	        return new VNode([], ownerID);
	      }
	      var removingFirst = originIndex === 0;
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[originIndex];
	        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && removingFirst) {
	          return this;
	        }
	      }
	      if (removingFirst && !newChild) {
	        return this;
	      }
	      var editable = editableVNode(this, ownerID);
	      if (!removingFirst) {
	        for (var ii = 0; ii < originIndex; ii++) {
	          editable.array[ii] = undefined;
	        }
	      }
	      if (newChild) {
	        editable.array[originIndex] = newChild;
	      }
	      return editable;
	    };
	
	    VNode.prototype.removeAfter = function(ownerID, level, index) {
	      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
	        return this;
	      }
	      var sizeIndex = ((index - 1) >>> level) & MASK;
	      if (sizeIndex >= this.array.length) {
	        return this;
	      }
	
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[sizeIndex];
	        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
	          return this;
	        }
	      }
	
	      var editable = editableVNode(this, ownerID);
	      editable.array.splice(sizeIndex + 1);
	      if (newChild) {
	        editable.array[sizeIndex] = newChild;
	      }
	      return editable;
	    };
	
	
	
	  var DONE = {};
	
	  function iterateList(list, reverse) {
	    var left = list._origin;
	    var right = list._capacity;
	    var tailPos = getTailOffset(right);
	    var tail = list._tail;
	
	    return iterateNodeOrLeaf(list._root, list._level, 0);
	
	    function iterateNodeOrLeaf(node, level, offset) {
	      return level === 0 ?
	        iterateLeaf(node, offset) :
	        iterateNode(node, level, offset);
	    }
	
	    function iterateLeaf(node, offset) {
	      var array = offset === tailPos ? tail && tail.array : node && node.array;
	      var from = offset > left ? 0 : left - offset;
	      var to = right - offset;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        if (from === to) {
	          return DONE;
	        }
	        var idx = reverse ? --to : from++;
	        return array && array[idx];
	      };
	    }
	
	    function iterateNode(node, level, offset) {
	      var values;
	      var array = node && node.array;
	      var from = offset > left ? 0 : (left - offset) >> level;
	      var to = ((right - offset) >> level) + 1;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        do {
	          if (values) {
	            var value = values();
	            if (value !== DONE) {
	              return value;
	            }
	            values = null;
	          }
	          if (from === to) {
	            return DONE;
	          }
	          var idx = reverse ? --to : from++;
	          values = iterateNodeOrLeaf(
	            array && array[idx], level - SHIFT, offset + (idx << level)
	          );
	        } while (true);
	      };
	    }
	  }
	
	  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
	    var list = Object.create(ListPrototype);
	    list.size = capacity - origin;
	    list._origin = origin;
	    list._capacity = capacity;
	    list._level = level;
	    list._root = root;
	    list._tail = tail;
	    list.__ownerID = ownerID;
	    list.__hash = hash;
	    list.__altered = false;
	    return list;
	  }
	
	  var EMPTY_LIST;
	  function emptyList() {
	    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
	  }
	
	  function updateList(list, index, value) {
	    index = wrapIndex(list, index);
	
	    if (index !== index) {
	      return list;
	    }
	
	    if (index >= list.size || index < 0) {
	      return list.withMutations(function(list ) {
	        index < 0 ?
	          setListBounds(list, index).set(0, value) :
	          setListBounds(list, 0, index + 1).set(index, value)
	      });
	    }
	
	    index += list._origin;
	
	    var newTail = list._tail;
	    var newRoot = list._root;
	    var didAlter = MakeRef(DID_ALTER);
	    if (index >= getTailOffset(list._capacity)) {
	      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
	    } else {
	      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
	    }
	
	    if (!didAlter.value) {
	      return list;
	    }
	
	    if (list.__ownerID) {
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
	  }
	
	  function updateVNode(node, ownerID, level, index, value, didAlter) {
	    var idx = (index >>> level) & MASK;
	    var nodeHas = node && idx < node.array.length;
	    if (!nodeHas && value === undefined) {
	      return node;
	    }
	
	    var newNode;
	
	    if (level > 0) {
	      var lowerNode = node && node.array[idx];
	      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
	      if (newLowerNode === lowerNode) {
	        return node;
	      }
	      newNode = editableVNode(node, ownerID);
	      newNode.array[idx] = newLowerNode;
	      return newNode;
	    }
	
	    if (nodeHas && node.array[idx] === value) {
	      return node;
	    }
	
	    SetRef(didAlter);
	
	    newNode = editableVNode(node, ownerID);
	    if (value === undefined && idx === newNode.array.length - 1) {
	      newNode.array.pop();
	    } else {
	      newNode.array[idx] = value;
	    }
	    return newNode;
	  }
	
	  function editableVNode(node, ownerID) {
	    if (ownerID && node && ownerID === node.ownerID) {
	      return node;
	    }
	    return new VNode(node ? node.array.slice() : [], ownerID);
	  }
	
	  function listNodeFor(list, rawIndex) {
	    if (rawIndex >= getTailOffset(list._capacity)) {
	      return list._tail;
	    }
	    if (rawIndex < 1 << (list._level + SHIFT)) {
	      var node = list._root;
	      var level = list._level;
	      while (node && level > 0) {
	        node = node.array[(rawIndex >>> level) & MASK];
	        level -= SHIFT;
	      }
	      return node;
	    }
	  }
	
	  function setListBounds(list, begin, end) {
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      end = end | 0;
	    }
	    var owner = list.__ownerID || new OwnerID();
	    var oldOrigin = list._origin;
	    var oldCapacity = list._capacity;
	    var newOrigin = oldOrigin + begin;
	    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
	    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
	      return list;
	    }
	
	    // If it's going to end after it starts, it's empty.
	    if (newOrigin >= newCapacity) {
	      return list.clear();
	    }
	
	    var newLevel = list._level;
	    var newRoot = list._root;
	
	    // New origin might need creating a higher root.
	    var offsetShift = 0;
	    while (newOrigin + offsetShift < 0) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
	      newLevel += SHIFT;
	      offsetShift += 1 << newLevel;
	    }
	    if (offsetShift) {
	      newOrigin += offsetShift;
	      oldOrigin += offsetShift;
	      newCapacity += offsetShift;
	      oldCapacity += offsetShift;
	    }
	
	    var oldTailOffset = getTailOffset(oldCapacity);
	    var newTailOffset = getTailOffset(newCapacity);
	
	    // New size might need creating a higher root.
	    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
	      newLevel += SHIFT;
	    }
	
	    // Locate or create the new tail.
	    var oldTail = list._tail;
	    var newTail = newTailOffset < oldTailOffset ?
	      listNodeFor(list, newCapacity - 1) :
	      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
	
	    // Merge Tail into tree.
	    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
	      newRoot = editableVNode(newRoot, owner);
	      var node = newRoot;
	      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
	        var idx = (oldTailOffset >>> level) & MASK;
	        node = node.array[idx] = editableVNode(node.array[idx], owner);
	      }
	      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
	    }
	
	    // If the size has been reduced, there's a chance the tail needs to be trimmed.
	    if (newCapacity < oldCapacity) {
	      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
	    }
	
	    // If the new origin is within the tail, then we do not need a root.
	    if (newOrigin >= newTailOffset) {
	      newOrigin -= newTailOffset;
	      newCapacity -= newTailOffset;
	      newLevel = SHIFT;
	      newRoot = null;
	      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
	
	    // Otherwise, if the root has been trimmed, garbage collect.
	    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
	      offsetShift = 0;
	
	      // Identify the new top root node of the subtree of the old root.
	      while (newRoot) {
	        var beginIndex = (newOrigin >>> newLevel) & MASK;
	        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
	          break;
	        }
	        if (beginIndex) {
	          offsetShift += (1 << newLevel) * beginIndex;
	        }
	        newLevel -= SHIFT;
	        newRoot = newRoot.array[beginIndex];
	      }
	
	      // Trim the new sides of the new root.
	      if (newRoot && newOrigin > oldOrigin) {
	        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
	      }
	      if (newRoot && newTailOffset < oldTailOffset) {
	        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
	      }
	      if (offsetShift) {
	        newOrigin -= offsetShift;
	        newCapacity -= offsetShift;
	      }
	    }
	
	    if (list.__ownerID) {
	      list.size = newCapacity - newOrigin;
	      list._origin = newOrigin;
	      list._capacity = newCapacity;
	      list._level = newLevel;
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
	  }
	
	  function mergeIntoListWith(list, merger, iterables) {
	    var iters = [];
	    var maxSize = 0;
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = IndexedIterable(value);
	      if (iter.size > maxSize) {
	        maxSize = iter.size;
	      }
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    if (maxSize > list.size) {
	      list = list.setSize(maxSize);
	    }
	    return mergeIntoCollectionWith(list, merger, iters);
	  }
	
	  function getTailOffset(size) {
	    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
	  }
	
	  createClass(OrderedMap, Map);
	
	    // @pragma Construction
	
	    function OrderedMap(value) {
	      return value === null || value === undefined ? emptyOrderedMap() :
	        isOrderedMap(value) ? value :
	        emptyOrderedMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }
	
	    OrderedMap.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    OrderedMap.prototype.toString = function() {
	      return this.__toString('OrderedMap {', '}');
	    };
	
	    // @pragma Access
	
	    OrderedMap.prototype.get = function(k, notSetValue) {
	      var index = this._map.get(k);
	      return index !== undefined ? this._list.get(index)[1] : notSetValue;
	    };
	
	    // @pragma Modification
	
	    OrderedMap.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._map.clear();
	        this._list.clear();
	        return this;
	      }
	      return emptyOrderedMap();
	    };
	
	    OrderedMap.prototype.set = function(k, v) {
	      return updateOrderedMap(this, k, v);
	    };
	
	    OrderedMap.prototype.remove = function(k) {
	      return updateOrderedMap(this, k, NOT_SET);
	    };
	
	    OrderedMap.prototype.wasAltered = function() {
	      return this._map.wasAltered() || this._list.wasAltered();
	    };
	
	    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._list.__iterate(
	        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
	        reverse
	      );
	    };
	
	    OrderedMap.prototype.__iterator = function(type, reverse) {
	      return this._list.fromEntrySeq().__iterator(type, reverse);
	    };
	
	    OrderedMap.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      var newList = this._list.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        this._list = newList;
	        return this;
	      }
	      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
	    };
	
	
	  function isOrderedMap(maybeOrderedMap) {
	    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
	  }
	
	  OrderedMap.isOrderedMap = isOrderedMap;
	
	  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
	  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
	
	
	
	  function makeOrderedMap(map, list, ownerID, hash) {
	    var omap = Object.create(OrderedMap.prototype);
	    omap.size = map ? map.size : 0;
	    omap._map = map;
	    omap._list = list;
	    omap.__ownerID = ownerID;
	    omap.__hash = hash;
	    return omap;
	  }
	
	  var EMPTY_ORDERED_MAP;
	  function emptyOrderedMap() {
	    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
	  }
	
	  function updateOrderedMap(omap, k, v) {
	    var map = omap._map;
	    var list = omap._list;
	    var i = map.get(k);
	    var has = i !== undefined;
	    var newMap;
	    var newList;
	    if (v === NOT_SET) { // removed
	      if (!has) {
	        return omap;
	      }
	      if (list.size >= SIZE && list.size >= map.size * 2) {
	        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
	        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
	        if (omap.__ownerID) {
	          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
	        }
	      } else {
	        newMap = map.remove(k);
	        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
	      }
	    } else {
	      if (has) {
	        if (v === list.get(i)[1]) {
	          return omap;
	        }
	        newMap = map;
	        newList = list.set(i, [k, v]);
	      } else {
	        newMap = map.set(k, list.size);
	        newList = list.set(list.size, [k, v]);
	      }
	    }
	    if (omap.__ownerID) {
	      omap.size = newMap.size;
	      omap._map = newMap;
	      omap._list = newList;
	      omap.__hash = undefined;
	      return omap;
	    }
	    return makeOrderedMap(newMap, newList);
	  }
	
	  createClass(ToKeyedSequence, KeyedSeq);
	    function ToKeyedSequence(indexed, useKeys) {
	      this._iter = indexed;
	      this._useKeys = useKeys;
	      this.size = indexed.size;
	    }
	
	    ToKeyedSequence.prototype.get = function(key, notSetValue) {
	      return this._iter.get(key, notSetValue);
	    };
	
	    ToKeyedSequence.prototype.has = function(key) {
	      return this._iter.has(key);
	    };
	
	    ToKeyedSequence.prototype.valueSeq = function() {
	      return this._iter.valueSeq();
	    };
	
	    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
	      var reversedSequence = reverseFactory(this, true);
	      if (!this._useKeys) {
	        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
	      }
	      return reversedSequence;
	    };
	
	    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
	      var mappedSequence = mapFactory(this, mapper, context);
	      if (!this._useKeys) {
	        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
	      }
	      return mappedSequence;
	    };
	
	    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var ii;
	      return this._iter.__iterate(
	        this._useKeys ?
	          function(v, k)  {return fn(v, k, this$0)} :
	          ((ii = reverse ? resolveSize(this) : 0),
	            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
	        reverse
	      );
	    };
	
	    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
	      if (this._useKeys) {
	        return this._iter.__iterator(type, reverse);
	      }
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var ii = reverse ? resolveSize(this) : 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
	      });
	    };
	
	  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;
	
	
	  createClass(ToIndexedSequence, IndexedSeq);
	    function ToIndexedSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }
	
	    ToIndexedSequence.prototype.includes = function(value) {
	      return this._iter.includes(value);
	    };
	
	    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
	    };
	
	    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, iterations++, step.value, step)
	      });
	    };
	
	
	
	  createClass(ToSetSequence, SetSeq);
	    function ToSetSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }
	
	    ToSetSequence.prototype.has = function(key) {
	      return this._iter.includes(key);
	    };
	
	    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
	    };
	
	    ToSetSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, step.value, step.value, step);
	      });
	    };
	
	
	
	  createClass(FromEntriesSequence, KeyedSeq);
	    function FromEntriesSequence(entries) {
	      this._iter = entries;
	      this.size = entries.size;
	    }
	
	    FromEntriesSequence.prototype.entrySeq = function() {
	      return this._iter.toSeq();
	    };
	
	    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(entry ) {
	        // Check if entry exists first so array access doesn't throw for holes
	        // in the parent iteration.
	        if (entry) {
	          validateEntry(entry);
	          var indexedIterable = isIterable(entry);
	          return fn(
	            indexedIterable ? entry.get(1) : entry[1],
	            indexedIterable ? entry.get(0) : entry[0],
	            this$0
	          );
	        }
	      }, reverse);
	    };
	
	    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          // Check if entry exists first so array access doesn't throw for holes
	          // in the parent iteration.
	          if (entry) {
	            validateEntry(entry);
	            var indexedIterable = isIterable(entry);
	            return iteratorValue(
	              type,
	              indexedIterable ? entry.get(0) : entry[0],
	              indexedIterable ? entry.get(1) : entry[1],
	              step
	            );
	          }
	        }
	      });
	    };
	
	
	  ToIndexedSequence.prototype.cacheResult =
	  ToKeyedSequence.prototype.cacheResult =
	  ToSetSequence.prototype.cacheResult =
	  FromEntriesSequence.prototype.cacheResult =
	    cacheResultThrough;
	
	
	  function flipFactory(iterable) {
	    var flipSequence = makeSequence(iterable);
	    flipSequence._iter = iterable;
	    flipSequence.size = iterable.size;
	    flipSequence.flip = function()  {return iterable};
	    flipSequence.reverse = function () {
	      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
	      reversedSequence.flip = function()  {return iterable.reverse()};
	      return reversedSequence;
	    };
	    flipSequence.has = function(key ) {return iterable.includes(key)};
	    flipSequence.includes = function(key ) {return iterable.has(key)};
	    flipSequence.cacheResult = cacheResultThrough;
	    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
	    }
	    flipSequence.__iteratorUncached = function(type, reverse) {
	      if (type === ITERATE_ENTRIES) {
	        var iterator = iterable.__iterator(type, reverse);
	        return new Iterator(function()  {
	          var step = iterator.next();
	          if (!step.done) {
	            var k = step.value[0];
	            step.value[0] = step.value[1];
	            step.value[1] = k;
	          }
	          return step;
	        });
	      }
	      return iterable.__iterator(
	        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
	        reverse
	      );
	    }
	    return flipSequence;
	  }
	
	
	  function mapFactory(iterable, mapper, context) {
	    var mappedSequence = makeSequence(iterable);
	    mappedSequence.size = iterable.size;
	    mappedSequence.has = function(key ) {return iterable.has(key)};
	    mappedSequence.get = function(key, notSetValue)  {
	      var v = iterable.get(key, NOT_SET);
	      return v === NOT_SET ?
	        notSetValue :
	        mapper.call(context, v, key, iterable);
	    };
	    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(
	        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
	        reverse
	      );
	    }
	    mappedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var key = entry[0];
	        return iteratorValue(
	          type,
	          key,
	          mapper.call(context, entry[1], key, iterable),
	          step
	        );
	      });
	    }
	    return mappedSequence;
	  }
	
	
	  function reverseFactory(iterable, useKeys) {
	    var reversedSequence = makeSequence(iterable);
	    reversedSequence._iter = iterable;
	    reversedSequence.size = iterable.size;
	    reversedSequence.reverse = function()  {return iterable};
	    if (iterable.flip) {
	      reversedSequence.flip = function () {
	        var flipSequence = flipFactory(iterable);
	        flipSequence.reverse = function()  {return iterable.flip()};
	        return flipSequence;
	      };
	    }
	    reversedSequence.get = function(key, notSetValue) 
	      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
	    reversedSequence.has = function(key )
	      {return iterable.has(useKeys ? key : -1 - key)};
	    reversedSequence.includes = function(value ) {return iterable.includes(value)};
	    reversedSequence.cacheResult = cacheResultThrough;
	    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
	    };
	    reversedSequence.__iterator =
	      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
	    return reversedSequence;
	  }
	
	
	  function filterFactory(iterable, predicate, context, useKeys) {
	    var filterSequence = makeSequence(iterable);
	    if (useKeys) {
	      filterSequence.has = function(key ) {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
	      };
	      filterSequence.get = function(key, notSetValue)  {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
	          v : notSetValue;
	      };
	    }
	    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      }, reverse);
	      return iterations;
	    };
	    filterSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          var key = entry[0];
	          var value = entry[1];
	          if (predicate.call(context, value, key, iterable)) {
	            return iteratorValue(type, useKeys ? key : iterations++, value, step);
	          }
	        }
	      });
	    }
	    return filterSequence;
	  }
	
	
	  function countByFactory(iterable, grouper, context) {
	    var groups = Map().asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        0,
	        function(a ) {return a + 1}
	      );
	    });
	    return groups.asImmutable();
	  }
	
	
	  function groupByFactory(iterable, grouper, context) {
	    var isKeyedIter = isKeyed(iterable);
	    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
	      );
	    });
	    var coerce = iterableClass(iterable);
	    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
	  }
	
	
	  function sliceFactory(iterable, begin, end, useKeys) {
	    var originalSize = iterable.size;
	
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      if (end === Infinity) {
	        end = originalSize;
	      } else {
	        end = end | 0;
	      }
	    }
	
	    if (wholeSlice(begin, end, originalSize)) {
	      return iterable;
	    }
	
	    var resolvedBegin = resolveBegin(begin, originalSize);
	    var resolvedEnd = resolveEnd(end, originalSize);
	
	    // begin or end will be NaN if they were provided as negative numbers and
	    // this iterable's size is unknown. In that case, cache first so there is
	    // a known size and these do not resolve to NaN.
	    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
	      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
	    }
	
	    // Note: resolvedEnd is undefined when the original sequence's length is
	    // unknown and this slice did not supply an end and should contain all
	    // elements after resolvedBegin.
	    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
	    var resolvedSize = resolvedEnd - resolvedBegin;
	    var sliceSize;
	    if (resolvedSize === resolvedSize) {
	      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
	    }
	
	    var sliceSeq = makeSequence(iterable);
	
	    // If iterable.size is undefined, the size of the realized sliceSeq is
	    // unknown at this point unless the number of items to slice is 0
	    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;
	
	    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
	      sliceSeq.get = function (index, notSetValue) {
	        index = wrapIndex(this, index);
	        return index >= 0 && index < sliceSize ?
	          iterable.get(index + resolvedBegin, notSetValue) :
	          notSetValue;
	      }
	    }
	
	    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (sliceSize === 0) {
	        return 0;
	      }
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var skipped = 0;
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k)  {
	        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
	                 iterations !== sliceSize;
	        }
	      });
	      return iterations;
	    };
	
	    sliceSeq.__iteratorUncached = function(type, reverse) {
	      if (sliceSize !== 0 && reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      // Don't bother instantiating parent iterator if taking 0.
	      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
	      var skipped = 0;
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (skipped++ < resolvedBegin) {
	          iterator.next();
	        }
	        if (++iterations > sliceSize) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (useKeys || type === ITERATE_VALUES) {
	          return step;
	        } else if (type === ITERATE_KEYS) {
	          return iteratorValue(type, iterations - 1, undefined, step);
	        } else {
	          return iteratorValue(type, iterations - 1, step.value[1], step);
	        }
	      });
	    }
	
	    return sliceSeq;
	  }
	
	
	  function takeWhileFactory(iterable, predicate, context) {
	    var takeSequence = makeSequence(iterable);
	    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c) 
	        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
	      );
	      return iterations;
	    };
	    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterating = true;
	      return new Iterator(function()  {
	        if (!iterating) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var k = entry[0];
	        var v = entry[1];
	        if (!predicate.call(context, v, k, this$0)) {
	          iterating = false;
	          return iteratorDone();
	        }
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return takeSequence;
	  }
	
	
	  function skipWhileFactory(iterable, predicate, context, useKeys) {
	    var skipSequence = makeSequence(iterable);
	    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      });
	      return iterations;
	    };
	    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var skipping = true;
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step, k, v;
	        do {
	          step = iterator.next();
	          if (step.done) {
	            if (useKeys || type === ITERATE_VALUES) {
	              return step;
	            } else if (type === ITERATE_KEYS) {
	              return iteratorValue(type, iterations++, undefined, step);
	            } else {
	              return iteratorValue(type, iterations++, step.value[1], step);
	            }
	          }
	          var entry = step.value;
	          k = entry[0];
	          v = entry[1];
	          skipping && (skipping = predicate.call(context, v, k, this$0));
	        } while (skipping);
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return skipSequence;
	  }
	
	
	  function concatFactory(iterable, values) {
	    var isKeyedIterable = isKeyed(iterable);
	    var iters = [iterable].concat(values).map(function(v ) {
	      if (!isIterable(v)) {
	        v = isKeyedIterable ?
	          keyedSeqFromValue(v) :
	          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
	      } else if (isKeyedIterable) {
	        v = KeyedIterable(v);
	      }
	      return v;
	    }).filter(function(v ) {return v.size !== 0});
	
	    if (iters.length === 0) {
	      return iterable;
	    }
	
	    if (iters.length === 1) {
	      var singleton = iters[0];
	      if (singleton === iterable ||
	          isKeyedIterable && isKeyed(singleton) ||
	          isIndexed(iterable) && isIndexed(singleton)) {
	        return singleton;
	      }
	    }
	
	    var concatSeq = new ArraySeq(iters);
	    if (isKeyedIterable) {
	      concatSeq = concatSeq.toKeyedSeq();
	    } else if (!isIndexed(iterable)) {
	      concatSeq = concatSeq.toSetSeq();
	    }
	    concatSeq = concatSeq.flatten(true);
	    concatSeq.size = iters.reduce(
	      function(sum, seq)  {
	        if (sum !== undefined) {
	          var size = seq.size;
	          if (size !== undefined) {
	            return sum + size;
	          }
	        }
	      },
	      0
	    );
	    return concatSeq;
	  }
	
	
	  function flattenFactory(iterable, depth, useKeys) {
	    var flatSequence = makeSequence(iterable);
	    flatSequence.__iterateUncached = function(fn, reverse) {
	      var iterations = 0;
	      var stopped = false;
	      function flatDeep(iter, currentDepth) {var this$0 = this;
	        iter.__iterate(function(v, k)  {
	          if ((!depth || currentDepth < depth) && isIterable(v)) {
	            flatDeep(v, currentDepth + 1);
	          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
	            stopped = true;
	          }
	          return !stopped;
	        }, reverse);
	      }
	      flatDeep(iterable, 0);
	      return iterations;
	    }
	    flatSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(type, reverse);
	      var stack = [];
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (iterator) {
	          var step = iterator.next();
	          if (step.done !== false) {
	            iterator = stack.pop();
	            continue;
	          }
	          var v = step.value;
	          if (type === ITERATE_ENTRIES) {
	            v = v[1];
	          }
	          if ((!depth || stack.length < depth) && isIterable(v)) {
	            stack.push(iterator);
	            iterator = v.__iterator(type, reverse);
	          } else {
	            return useKeys ? step : iteratorValue(type, iterations++, v, step);
	          }
	        }
	        return iteratorDone();
	      });
	    }
	    return flatSequence;
	  }
	
	
	  function flatMapFactory(iterable, mapper, context) {
	    var coerce = iterableClass(iterable);
	    return iterable.toSeq().map(
	      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
	    ).flatten(true);
	  }
	
	
	  function interposeFactory(iterable, separator) {
	    var interposedSequence = makeSequence(iterable);
	    interposedSequence.size = iterable.size && iterable.size * 2 -1;
	    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k) 
	        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
	        fn(v, iterations++, this$0) !== false},
	        reverse
	      );
	      return iterations;
	    };
	    interposedSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      var step;
	      return new Iterator(function()  {
	        if (!step || iterations % 2) {
	          step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	        }
	        return iterations % 2 ?
	          iteratorValue(type, iterations++, separator) :
	          iteratorValue(type, iterations++, step.value, step);
	      });
	    };
	    return interposedSequence;
	  }
	
	
	  function sortFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    var isKeyedIterable = isKeyed(iterable);
	    var index = 0;
	    var entries = iterable.toSeq().map(
	      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
	    ).toArray();
	    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
	      isKeyedIterable ?
	      function(v, i)  { entries[i].length = 2; } :
	      function(v, i)  { entries[i] = v[1]; }
	    );
	    return isKeyedIterable ? KeyedSeq(entries) :
	      isIndexed(iterable) ? IndexedSeq(entries) :
	      SetSeq(entries);
	  }
	
	
	  function maxFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    if (mapper) {
	      var entry = iterable.toSeq()
	        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
	        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
	      return entry && entry[0];
	    } else {
	      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
	    }
	  }
	
	  function maxCompare(comparator, a, b) {
	    var comp = comparator(b, a);
	    // b is considered the new max if the comparator declares them equal, but
	    // they are not equal and b is in fact a nullish value.
	    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
	  }
	
	
	  function zipWithFactory(keyIter, zipper, iters) {
	    var zipSequence = makeSequence(keyIter);
	    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
	    // Note: this a generic base implementation of __iterate in terms of
	    // __iterator which may be more generically useful in the future.
	    zipSequence.__iterate = function(fn, reverse) {
	      /* generic:
	      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        iterations++;
	        if (fn(step.value[1], step.value[0], this) === false) {
	          break;
	        }
	      }
	      return iterations;
	      */
	      // indexed:
	      var iterator = this.__iterator(ITERATE_VALUES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        if (fn(step.value, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	    zipSequence.__iteratorUncached = function(type, reverse) {
	      var iterators = iters.map(function(i )
	        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
	      );
	      var iterations = 0;
	      var isDone = false;
	      return new Iterator(function()  {
	        var steps;
	        if (!isDone) {
	          steps = iterators.map(function(i ) {return i.next()});
	          isDone = steps.some(function(s ) {return s.done});
	        }
	        if (isDone) {
	          return iteratorDone();
	        }
	        return iteratorValue(
	          type,
	          iterations++,
	          zipper.apply(null, steps.map(function(s ) {return s.value}))
	        );
	      });
	    };
	    return zipSequence
	  }
	
	
	  // #pragma Helper Functions
	
	  function reify(iter, seq) {
	    return isSeq(iter) ? seq : iter.constructor(seq);
	  }
	
	  function validateEntry(entry) {
	    if (entry !== Object(entry)) {
	      throw new TypeError('Expected [K, V] tuple: ' + entry);
	    }
	  }
	
	  function resolveSize(iter) {
	    assertNotInfinite(iter.size);
	    return ensureSize(iter);
	  }
	
	  function iterableClass(iterable) {
	    return isKeyed(iterable) ? KeyedIterable :
	      isIndexed(iterable) ? IndexedIterable :
	      SetIterable;
	  }
	
	  function makeSequence(iterable) {
	    return Object.create(
	      (
	        isKeyed(iterable) ? KeyedSeq :
	        isIndexed(iterable) ? IndexedSeq :
	        SetSeq
	      ).prototype
	    );
	  }
	
	  function cacheResultThrough() {
	    if (this._iter.cacheResult) {
	      this._iter.cacheResult();
	      this.size = this._iter.size;
	      return this;
	    } else {
	      return Seq.prototype.cacheResult.call(this);
	    }
	  }
	
	  function defaultComparator(a, b) {
	    return a > b ? 1 : a < b ? -1 : 0;
	  }
	
	  function forceIterator(keyPath) {
	    var iter = getIterator(keyPath);
	    if (!iter) {
	      // Array might not be iterable in this environment, so we need a fallback
	      // to our wrapped type.
	      if (!isArrayLike(keyPath)) {
	        throw new TypeError('Expected iterable or array-like: ' + keyPath);
	      }
	      iter = getIterator(Iterable(keyPath));
	    }
	    return iter;
	  }
	
	  createClass(Record, KeyedCollection);
	
	    function Record(defaultValues, name) {
	      var hasInitialized;
	
	      var RecordType = function Record(values) {
	        if (values instanceof RecordType) {
	          return values;
	        }
	        if (!(this instanceof RecordType)) {
	          return new RecordType(values);
	        }
	        if (!hasInitialized) {
	          hasInitialized = true;
	          var keys = Object.keys(defaultValues);
	          setProps(RecordTypePrototype, keys);
	          RecordTypePrototype.size = keys.length;
	          RecordTypePrototype._name = name;
	          RecordTypePrototype._keys = keys;
	          RecordTypePrototype._defaultValues = defaultValues;
	        }
	        this._map = Map(values);
	      };
	
	      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
	      RecordTypePrototype.constructor = RecordType;
	
	      return RecordType;
	    }
	
	    Record.prototype.toString = function() {
	      return this.__toString(recordName(this) + ' {', '}');
	    };
	
	    // @pragma Access
	
	    Record.prototype.has = function(k) {
	      return this._defaultValues.hasOwnProperty(k);
	    };
	
	    Record.prototype.get = function(k, notSetValue) {
	      if (!this.has(k)) {
	        return notSetValue;
	      }
	      var defaultVal = this._defaultValues[k];
	      return this._map ? this._map.get(k, defaultVal) : defaultVal;
	    };
	
	    // @pragma Modification
	
	    Record.prototype.clear = function() {
	      if (this.__ownerID) {
	        this._map && this._map.clear();
	        return this;
	      }
	      var RecordType = this.constructor;
	      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
	    };
	
	    Record.prototype.set = function(k, v) {
	      if (!this.has(k)) {
	        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
	      }
	      if (this._map && !this._map.has(k)) {
	        var defaultVal = this._defaultValues[k];
	        if (v === defaultVal) {
	          return this;
	        }
	      }
	      var newMap = this._map && this._map.set(k, v);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };
	
	    Record.prototype.remove = function(k) {
	      if (!this.has(k)) {
	        return this;
	      }
	      var newMap = this._map && this._map.remove(k);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };
	
	    Record.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };
	
	    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
	    };
	
	    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
	    };
	
	    Record.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map && this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return makeRecord(this, newMap, ownerID);
	    };
	
	
	  var RecordPrototype = Record.prototype;
	  RecordPrototype[DELETE] = RecordPrototype.remove;
	  RecordPrototype.deleteIn =
	  RecordPrototype.removeIn = MapPrototype.removeIn;
	  RecordPrototype.merge = MapPrototype.merge;
	  RecordPrototype.mergeWith = MapPrototype.mergeWith;
	  RecordPrototype.mergeIn = MapPrototype.mergeIn;
	  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
	  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
	  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  RecordPrototype.setIn = MapPrototype.setIn;
	  RecordPrototype.update = MapPrototype.update;
	  RecordPrototype.updateIn = MapPrototype.updateIn;
	  RecordPrototype.withMutations = MapPrototype.withMutations;
	  RecordPrototype.asMutable = MapPrototype.asMutable;
	  RecordPrototype.asImmutable = MapPrototype.asImmutable;
	
	
	  function makeRecord(likeRecord, map, ownerID) {
	    var record = Object.create(Object.getPrototypeOf(likeRecord));
	    record._map = map;
	    record.__ownerID = ownerID;
	    return record;
	  }
	
	  function recordName(record) {
	    return record._name || record.constructor.name || 'Record';
	  }
	
	  function setProps(prototype, names) {
	    try {
	      names.forEach(setProp.bind(undefined, prototype));
	    } catch (error) {
	      // Object.defineProperty failed. Probably IE8.
	    }
	  }
	
	  function setProp(prototype, name) {
	    Object.defineProperty(prototype, name, {
	      get: function() {
	        return this.get(name);
	      },
	      set: function(value) {
	        invariant(this.__ownerID, 'Cannot set on an immutable record.');
	        this.set(name, value);
	      }
	    });
	  }
	
	  createClass(Set, SetCollection);
	
	    // @pragma Construction
	
	    function Set(value) {
	      return value === null || value === undefined ? emptySet() :
	        isSet(value) && !isOrdered(value) ? value :
	        emptySet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }
	
	    Set.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    Set.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };
	
	    Set.prototype.toString = function() {
	      return this.__toString('Set {', '}');
	    };
	
	    // @pragma Access
	
	    Set.prototype.has = function(value) {
	      return this._map.has(value);
	    };
	
	    // @pragma Modification
	
	    Set.prototype.add = function(value) {
	      return updateSet(this, this._map.set(value, true));
	    };
	
	    Set.prototype.remove = function(value) {
	      return updateSet(this, this._map.remove(value));
	    };
	
	    Set.prototype.clear = function() {
	      return updateSet(this, this._map.clear());
	    };
	
	    // @pragma Composition
	
	    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
	      iters = iters.filter(function(x ) {return x.size !== 0});
	      if (iters.length === 0) {
	        return this;
	      }
	      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
	        return this.constructor(iters[0]);
	      }
	      return this.withMutations(function(set ) {
	        for (var ii = 0; ii < iters.length; ii++) {
	          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
	        }
	      });
	    };
	
	    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (!iters.every(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };
	
	    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (iters.some(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };
	
	    Set.prototype.merge = function() {
	      return this.union.apply(this, arguments);
	    };
	
	    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return this.union.apply(this, iters);
	    };
	
	    Set.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator));
	    };
	
	    Set.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator, mapper));
	    };
	
	    Set.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };
	
	    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
	    };
	
	    Set.prototype.__iterator = function(type, reverse) {
	      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
	    };
	
	    Set.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return this.__make(newMap, ownerID);
	    };
	
	
	  function isSet(maybeSet) {
	    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
	  }
	
	  Set.isSet = isSet;
	
	  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';
	
	  var SetPrototype = Set.prototype;
	  SetPrototype[IS_SET_SENTINEL] = true;
	  SetPrototype[DELETE] = SetPrototype.remove;
	  SetPrototype.mergeDeep = SetPrototype.merge;
	  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
	  SetPrototype.withMutations = MapPrototype.withMutations;
	  SetPrototype.asMutable = MapPrototype.asMutable;
	  SetPrototype.asImmutable = MapPrototype.asImmutable;
	
	  SetPrototype.__empty = emptySet;
	  SetPrototype.__make = makeSet;
	
	  function updateSet(set, newMap) {
	    if (set.__ownerID) {
	      set.size = newMap.size;
	      set._map = newMap;
	      return set;
	    }
	    return newMap === set._map ? set :
	      newMap.size === 0 ? set.__empty() :
	      set.__make(newMap);
	  }
	
	  function makeSet(map, ownerID) {
	    var set = Object.create(SetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }
	
	  var EMPTY_SET;
	  function emptySet() {
	    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
	  }
	
	  createClass(OrderedSet, Set);
	
	    // @pragma Construction
	
	    function OrderedSet(value) {
	      return value === null || value === undefined ? emptyOrderedSet() :
	        isOrderedSet(value) ? value :
	        emptyOrderedSet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }
	
	    OrderedSet.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    OrderedSet.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };
	
	    OrderedSet.prototype.toString = function() {
	      return this.__toString('OrderedSet {', '}');
	    };
	
	
	  function isOrderedSet(maybeOrderedSet) {
	    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
	  }
	
	  OrderedSet.isOrderedSet = isOrderedSet;
	
	  var OrderedSetPrototype = OrderedSet.prototype;
	  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;
	
	  OrderedSetPrototype.__empty = emptyOrderedSet;
	  OrderedSetPrototype.__make = makeOrderedSet;
	
	  function makeOrderedSet(map, ownerID) {
	    var set = Object.create(OrderedSetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }
	
	  var EMPTY_ORDERED_SET;
	  function emptyOrderedSet() {
	    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
	  }
	
	  createClass(Stack, IndexedCollection);
	
	    // @pragma Construction
	
	    function Stack(value) {
	      return value === null || value === undefined ? emptyStack() :
	        isStack(value) ? value :
	        emptyStack().unshiftAll(value);
	    }
	
	    Stack.of = function(/*...values*/) {
	      return this(arguments);
	    };
	
	    Stack.prototype.toString = function() {
	      return this.__toString('Stack [', ']');
	    };
	
	    // @pragma Access
	
	    Stack.prototype.get = function(index, notSetValue) {
	      var head = this._head;
	      index = wrapIndex(this, index);
	      while (head && index--) {
	        head = head.next;
	      }
	      return head ? head.value : notSetValue;
	    };
	
	    Stack.prototype.peek = function() {
	      return this._head && this._head.value;
	    };
	
	    // @pragma Modification
	
	    Stack.prototype.push = function(/*...values*/) {
	      if (arguments.length === 0) {
	        return this;
	      }
	      var newSize = this.size + arguments.length;
	      var head = this._head;
	      for (var ii = arguments.length - 1; ii >= 0; ii--) {
	        head = {
	          value: arguments[ii],
	          next: head
	        };
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };
	
	    Stack.prototype.pushAll = function(iter) {
	      iter = IndexedIterable(iter);
	      if (iter.size === 0) {
	        return this;
	      }
	      assertNotInfinite(iter.size);
	      var newSize = this.size;
	      var head = this._head;
	      iter.reverse().forEach(function(value ) {
	        newSize++;
	        head = {
	          value: value,
	          next: head
	        };
	      });
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };
	
	    Stack.prototype.pop = function() {
	      return this.slice(1);
	    };
	
	    Stack.prototype.unshift = function(/*...values*/) {
	      return this.push.apply(this, arguments);
	    };
	
	    Stack.prototype.unshiftAll = function(iter) {
	      return this.pushAll(iter);
	    };
	
	    Stack.prototype.shift = function() {
	      return this.pop.apply(this, arguments);
	    };
	
	    Stack.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._head = undefined;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyStack();
	    };
	
	    Stack.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      var resolvedBegin = resolveBegin(begin, this.size);
	      var resolvedEnd = resolveEnd(end, this.size);
	      if (resolvedEnd !== this.size) {
	        // super.slice(begin, end);
	        return IndexedCollection.prototype.slice.call(this, begin, end);
	      }
	      var newSize = this.size - resolvedBegin;
	      var head = this._head;
	      while (resolvedBegin--) {
	        head = head.next;
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };
	
	    // @pragma Mutability
	
	    Stack.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeStack(this.size, this._head, ownerID, this.__hash);
	    };
	
	    // @pragma Iteration
	
	    Stack.prototype.__iterate = function(fn, reverse) {
	      if (reverse) {
	        return this.reverse().__iterate(fn);
	      }
	      var iterations = 0;
	      var node = this._head;
	      while (node) {
	        if (fn(node.value, iterations++, this) === false) {
	          break;
	        }
	        node = node.next;
	      }
	      return iterations;
	    };
	
	    Stack.prototype.__iterator = function(type, reverse) {
	      if (reverse) {
	        return this.reverse().__iterator(type);
	      }
	      var iterations = 0;
	      var node = this._head;
	      return new Iterator(function()  {
	        if (node) {
	          var value = node.value;
	          node = node.next;
	          return iteratorValue(type, iterations++, value);
	        }
	        return iteratorDone();
	      });
	    };
	
	
	  function isStack(maybeStack) {
	    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
	  }
	
	  Stack.isStack = isStack;
	
	  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';
	
	  var StackPrototype = Stack.prototype;
	  StackPrototype[IS_STACK_SENTINEL] = true;
	  StackPrototype.withMutations = MapPrototype.withMutations;
	  StackPrototype.asMutable = MapPrototype.asMutable;
	  StackPrototype.asImmutable = MapPrototype.asImmutable;
	  StackPrototype.wasAltered = MapPrototype.wasAltered;
	
	
	  function makeStack(size, head, ownerID, hash) {
	    var map = Object.create(StackPrototype);
	    map.size = size;
	    map._head = head;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }
	
	  var EMPTY_STACK;
	  function emptyStack() {
	    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
	  }
	
	  /**
	   * Contributes additional methods to a constructor
	   */
	  function mixin(ctor, methods) {
	    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
	    Object.keys(methods).forEach(keyCopier);
	    Object.getOwnPropertySymbols &&
	      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
	    return ctor;
	  }
	
	  Iterable.Iterator = Iterator;
	
	  mixin(Iterable, {
	
	    // ### Conversion to other types
	
	    toArray: function() {
	      assertNotInfinite(this.size);
	      var array = new Array(this.size || 0);
	      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
	      return array;
	    },
	
	    toIndexedSeq: function() {
	      return new ToIndexedSequence(this);
	    },
	
	    toJS: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
	      ).__toJS();
	    },
	
	    toJSON: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
	      ).__toJS();
	    },
	
	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, true);
	    },
	
	    toMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Map(this.toKeyedSeq());
	    },
	
	    toObject: function() {
	      assertNotInfinite(this.size);
	      var object = {};
	      this.__iterate(function(v, k)  { object[k] = v; });
	      return object;
	    },
	
	    toOrderedMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedMap(this.toKeyedSeq());
	    },
	
	    toOrderedSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	    toSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Set(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	    toSetSeq: function() {
	      return new ToSetSequence(this);
	    },
	
	    toSeq: function() {
	      return isIndexed(this) ? this.toIndexedSeq() :
	        isKeyed(this) ? this.toKeyedSeq() :
	        this.toSetSeq();
	    },
	
	    toStack: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Stack(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	    toList: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return List(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	
	    // ### Common JavaScript methods and properties
	
	    toString: function() {
	      return '[Iterable]';
	    },
	
	    __toString: function(head, tail) {
	      if (this.size === 0) {
	        return head + tail;
	      }
	      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
	    },
	
	
	    // ### ES6 Collection methods (ES6 Array and Map)
	
	    concat: function() {var values = SLICE$0.call(arguments, 0);
	      return reify(this, concatFactory(this, values));
	    },
	
	    includes: function(searchValue) {
	      return this.some(function(value ) {return is(value, searchValue)});
	    },
	
	    entries: function() {
	      return this.__iterator(ITERATE_ENTRIES);
	    },
	
	    every: function(predicate, context) {
	      assertNotInfinite(this.size);
	      var returnValue = true;
	      this.__iterate(function(v, k, c)  {
	        if (!predicate.call(context, v, k, c)) {
	          returnValue = false;
	          return false;
	        }
	      });
	      return returnValue;
	    },
	
	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, true));
	    },
	
	    find: function(predicate, context, notSetValue) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[1] : notSetValue;
	    },
	
	    forEach: function(sideEffect, context) {
	      assertNotInfinite(this.size);
	      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
	    },
	
	    join: function(separator) {
	      assertNotInfinite(this.size);
	      separator = separator !== undefined ? '' + separator : ',';
	      var joined = '';
	      var isFirst = true;
	      this.__iterate(function(v ) {
	        isFirst ? (isFirst = false) : (joined += separator);
	        joined += v !== null && v !== undefined ? v.toString() : '';
	      });
	      return joined;
	    },
	
	    keys: function() {
	      return this.__iterator(ITERATE_KEYS);
	    },
	
	    map: function(mapper, context) {
	      return reify(this, mapFactory(this, mapper, context));
	    },
	
	    reduce: function(reducer, initialReduction, context) {
	      assertNotInfinite(this.size);
	      var reduction;
	      var useFirst;
	      if (arguments.length < 2) {
	        useFirst = true;
	      } else {
	        reduction = initialReduction;
	      }
	      this.__iterate(function(v, k, c)  {
	        if (useFirst) {
	          useFirst = false;
	          reduction = v;
	        } else {
	          reduction = reducer.call(context, reduction, v, k, c);
	        }
	      });
	      return reduction;
	    },
	
	    reduceRight: function(reducer, initialReduction, context) {
	      var reversed = this.toKeyedSeq().reverse();
	      return reversed.reduce.apply(reversed, arguments);
	    },
	
	    reverse: function() {
	      return reify(this, reverseFactory(this, true));
	    },
	
	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, true));
	    },
	
	    some: function(predicate, context) {
	      return !this.every(not(predicate), context);
	    },
	
	    sort: function(comparator) {
	      return reify(this, sortFactory(this, comparator));
	    },
	
	    values: function() {
	      return this.__iterator(ITERATE_VALUES);
	    },
	
	
	    // ### More sequential methods
	
	    butLast: function() {
	      return this.slice(0, -1);
	    },
	
	    isEmpty: function() {
	      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
	    },
	
	    count: function(predicate, context) {
	      return ensureSize(
	        predicate ? this.toSeq().filter(predicate, context) : this
	      );
	    },
	
	    countBy: function(grouper, context) {
	      return countByFactory(this, grouper, context);
	    },
	
	    equals: function(other) {
	      return deepEqual(this, other);
	    },
	
	    entrySeq: function() {
	      var iterable = this;
	      if (iterable._cache) {
	        // We cache as an entries array, so we can just return the cache!
	        return new ArraySeq(iterable._cache);
	      }
	      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
	      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
	      return entriesSequence;
	    },
	
	    filterNot: function(predicate, context) {
	      return this.filter(not(predicate), context);
	    },
	
	    findEntry: function(predicate, context, notSetValue) {
	      var found = notSetValue;
	      this.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          found = [k, v];
	          return false;
	        }
	      });
	      return found;
	    },
	
	    findKey: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry && entry[0];
	    },
	
	    findLast: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
	    },
	
	    findLastEntry: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
	    },
	
	    findLastKey: function(predicate, context) {
	      return this.toKeyedSeq().reverse().findKey(predicate, context);
	    },
	
	    first: function() {
	      return this.find(returnTrue);
	    },
	
	    flatMap: function(mapper, context) {
	      return reify(this, flatMapFactory(this, mapper, context));
	    },
	
	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, true));
	    },
	
	    fromEntrySeq: function() {
	      return new FromEntriesSequence(this);
	    },
	
	    get: function(searchKey, notSetValue) {
	      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
	    },
	
	    getIn: function(searchKeyPath, notSetValue) {
	      var nested = this;
	      // Note: in an ES6 environment, we would prefer:
	      // for (var key of searchKeyPath) {
	      var iter = forceIterator(searchKeyPath);
	      var step;
	      while (!(step = iter.next()).done) {
	        var key = step.value;
	        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
	        if (nested === NOT_SET) {
	          return notSetValue;
	        }
	      }
	      return nested;
	    },
	
	    groupBy: function(grouper, context) {
	      return groupByFactory(this, grouper, context);
	    },
	
	    has: function(searchKey) {
	      return this.get(searchKey, NOT_SET) !== NOT_SET;
	    },
	
	    hasIn: function(searchKeyPath) {
	      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
	    },
	
	    isSubset: function(iter) {
	      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
	      return this.every(function(value ) {return iter.includes(value)});
	    },
	
	    isSuperset: function(iter) {
	      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
	      return iter.isSubset(this);
	    },
	
	    keyOf: function(searchValue) {
	      return this.findKey(function(value ) {return is(value, searchValue)});
	    },
	
	    keySeq: function() {
	      return this.toSeq().map(keyMapper).toIndexedSeq();
	    },
	
	    last: function() {
	      return this.toSeq().reverse().first();
	    },
	
	    lastKeyOf: function(searchValue) {
	      return this.toKeyedSeq().reverse().keyOf(searchValue);
	    },
	
	    max: function(comparator) {
	      return maxFactory(this, comparator);
	    },
	
	    maxBy: function(mapper, comparator) {
	      return maxFactory(this, comparator, mapper);
	    },
	
	    min: function(comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
	    },
	
	    minBy: function(mapper, comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
	    },
	
	    rest: function() {
	      return this.slice(1);
	    },
	
	    skip: function(amount) {
	      return this.slice(Math.max(0, amount));
	    },
	
	    skipLast: function(amount) {
	      return reify(this, this.toSeq().reverse().skip(amount).reverse());
	    },
	
	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, true));
	    },
	
	    skipUntil: function(predicate, context) {
	      return this.skipWhile(not(predicate), context);
	    },
	
	    sortBy: function(mapper, comparator) {
	      return reify(this, sortFactory(this, comparator, mapper));
	    },
	
	    take: function(amount) {
	      return this.slice(0, Math.max(0, amount));
	    },
	
	    takeLast: function(amount) {
	      return reify(this, this.toSeq().reverse().take(amount).reverse());
	    },
	
	    takeWhile: function(predicate, context) {
	      return reify(this, takeWhileFactory(this, predicate, context));
	    },
	
	    takeUntil: function(predicate, context) {
	      return this.takeWhile(not(predicate), context);
	    },
	
	    valueSeq: function() {
	      return this.toIndexedSeq();
	    },
	
	
	    // ### Hashable Object
	
	    hashCode: function() {
	      return this.__hash || (this.__hash = hashIterable(this));
	    }
	
	
	    // ### Internal
	
	    // abstract __iterate(fn, reverse)
	
	    // abstract __iterator(type, reverse)
	  });
	
	  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
	
	  var IterablePrototype = Iterable.prototype;
	  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
	  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
	  IterablePrototype.__toJS = IterablePrototype.toArray;
	  IterablePrototype.__toStringMapper = quoteString;
	  IterablePrototype.inspect =
	  IterablePrototype.toSource = function() { return this.toString(); };
	  IterablePrototype.chain = IterablePrototype.flatMap;
	  IterablePrototype.contains = IterablePrototype.includes;
	
	  mixin(KeyedIterable, {
	
	    // ### More sequential methods
	
	    flip: function() {
	      return reify(this, flipFactory(this));
	    },
	
	    mapEntries: function(mapper, context) {var this$0 = this;
	      var iterations = 0;
	      return reify(this,
	        this.toSeq().map(
	          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
	        ).fromEntrySeq()
	      );
	    },
	
	    mapKeys: function(mapper, context) {var this$0 = this;
	      return reify(this,
	        this.toSeq().flip().map(
	          function(k, v)  {return mapper.call(context, k, v, this$0)}
	        ).flip()
	      );
	    }
	
	  });
	
	  var KeyedIterablePrototype = KeyedIterable.prototype;
	  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
	  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
	  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
	  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};
	
	
	
	  mixin(IndexedIterable, {
	
	    // ### Conversion to other types
	
	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, false);
	    },
	
	
	    // ### ES6 Collection methods (ES6 Array and Map)
	
	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, false));
	    },
	
	    findIndex: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },
	
	    indexOf: function(searchValue) {
	      var key = this.keyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },
	
	    lastIndexOf: function(searchValue) {
	      var key = this.lastKeyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },
	
	    reverse: function() {
	      return reify(this, reverseFactory(this, false));
	    },
	
	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, false));
	    },
	
	    splice: function(index, removeNum /*, ...values*/) {
	      var numArgs = arguments.length;
	      removeNum = Math.max(removeNum | 0, 0);
	      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
	        return this;
	      }
	      // If index is negative, it should resolve relative to the size of the
	      // collection. However size may be expensive to compute if not cached, so
	      // only call count() if the number is in fact negative.
	      index = resolveBegin(index, index < 0 ? this.count() : this.size);
	      var spliced = this.slice(0, index);
	      return reify(
	        this,
	        numArgs === 1 ?
	          spliced :
	          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
	      );
	    },
	
	
	    // ### More collection methods
	
	    findLastIndex: function(predicate, context) {
	      var entry = this.findLastEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },
	
	    first: function() {
	      return this.get(0);
	    },
	
	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, false));
	    },
	
	    get: function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      return (index < 0 || (this.size === Infinity ||
	          (this.size !== undefined && index > this.size))) ?
	        notSetValue :
	        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
	    },
	
	    has: function(index) {
	      index = wrapIndex(this, index);
	      return index >= 0 && (this.size !== undefined ?
	        this.size === Infinity || index < this.size :
	        this.indexOf(index) !== -1
	      );
	    },
	
	    interpose: function(separator) {
	      return reify(this, interposeFactory(this, separator));
	    },
	
	    interleave: function(/*...iterables*/) {
	      var iterables = [this].concat(arrCopy(arguments));
	      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
	      var interleaved = zipped.flatten(true);
	      if (zipped.size) {
	        interleaved.size = zipped.size * iterables.length;
	      }
	      return reify(this, interleaved);
	    },
	
	    keySeq: function() {
	      return Range(0, this.size);
	    },
	
	    last: function() {
	      return this.get(-1);
	    },
	
	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, false));
	    },
	
	    zip: function(/*, ...iterables */) {
	      var iterables = [this].concat(arrCopy(arguments));
	      return reify(this, zipWithFactory(this, defaultZipper, iterables));
	    },
	
	    zipWith: function(zipper/*, ...iterables */) {
	      var iterables = arrCopy(arguments);
	      iterables[0] = this;
	      return reify(this, zipWithFactory(this, zipper, iterables));
	    }
	
	  });
	
	  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
	  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;
	
	
	
	  mixin(SetIterable, {
	
	    // ### ES6 Collection methods (ES6 Array and Map)
	
	    get: function(value, notSetValue) {
	      return this.has(value) ? value : notSetValue;
	    },
	
	    includes: function(value) {
	      return this.has(value);
	    },
	
	
	    // ### More sequential methods
	
	    keySeq: function() {
	      return this.valueSeq();
	    }
	
	  });
	
	  SetIterable.prototype.has = IterablePrototype.includes;
	  SetIterable.prototype.contains = SetIterable.prototype.includes;
	
	
	  // Mixin subclasses
	
	  mixin(KeyedSeq, KeyedIterable.prototype);
	  mixin(IndexedSeq, IndexedIterable.prototype);
	  mixin(SetSeq, SetIterable.prototype);
	
	  mixin(KeyedCollection, KeyedIterable.prototype);
	  mixin(IndexedCollection, IndexedIterable.prototype);
	  mixin(SetCollection, SetIterable.prototype);
	
	
	  // #pragma Helper functions
	
	  function keyMapper(v, k) {
	    return k;
	  }
	
	  function entryMapper(v, k) {
	    return [k, v];
	  }
	
	  function not(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    }
	  }
	
	  function neg(predicate) {
	    return function() {
	      return -predicate.apply(this, arguments);
	    }
	  }
	
	  function quoteString(value) {
	    return typeof value === 'string' ? JSON.stringify(value) : String(value);
	  }
	
	  function defaultZipper() {
	    return arrCopy(arguments);
	  }
	
	  function defaultNegComparator(a, b) {
	    return a < b ? 1 : a > b ? -1 : 0;
	  }
	
	  function hashIterable(iterable) {
	    if (iterable.size === Infinity) {
	      return 0;
	    }
	    var ordered = isOrdered(iterable);
	    var keyed = isKeyed(iterable);
	    var h = ordered ? 1 : 0;
	    var size = iterable.__iterate(
	      keyed ?
	        ordered ?
	          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
	          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
	        ordered ?
	          function(v ) { h = 31 * h + hash(v) | 0; } :
	          function(v ) { h = h + hash(v) | 0; }
	    );
	    return murmurHashOfSize(size, h);
	  }
	
	  function murmurHashOfSize(size, h) {
	    h = imul(h, 0xCC9E2D51);
	    h = imul(h << 15 | h >>> -15, 0x1B873593);
	    h = imul(h << 13 | h >>> -13, 5);
	    h = (h + 0xE6546B64 | 0) ^ size;
	    h = imul(h ^ h >>> 16, 0x85EBCA6B);
	    h = imul(h ^ h >>> 13, 0xC2B2AE35);
	    h = smi(h ^ h >>> 16);
	    return h;
	  }
	
	  function hashMerge(a, b) {
	    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
	  }
	
	  var Immutable = {
	
	    Iterable: Iterable,
	
	    Seq: Seq,
	    Collection: Collection,
	    Map: Map,
	    OrderedMap: OrderedMap,
	    List: List,
	    Stack: Stack,
	    Set: Set,
	    OrderedSet: OrderedSet,
	
	    Record: Record,
	    Range: Range,
	    Repeat: Repeat,
	
	    is: is,
	    fromJS: fromJS
	
	  };
	
	  return Immutable;
	
	}));

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	var constants = __webpack_require__(290);
	
	var initialState = {
	  activeEventNames: [],
	  listeners: [],
	  fetchingListeners: false
	};
	
	function update() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
	  var action = arguments[1];
	  var emit = arguments[2];
	
	  switch (action.type) {
	    case constants.UPDATE_EVENT_BREAKPOINTS:
	      state.activeEventNames = action.eventNames;
	      // emit("activeEventNames", state.activeEventNames);
	      break;
	    case constants.FETCH_EVENT_LISTENERS:
	      if (action.status === "begin") {
	        state.fetchingListeners = true;
	      } else if (action.status === "done") {
	        state.fetchingListeners = false;
	        state.listeners = action.listeners;
	      }
	      break;
	    case constants.NAVIGATE:
	      return initialState;
	  }
	
	  return state;
	}
	
	function getEventListeners(state) {
	  return state.eventListeners.listeners;
	}
	
	module.exports = {
	  update,
	  getEventListeners
	};

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	/**
	 * Sources reducer
	 * @module reducers/sources
	 */
	
	var I = __webpack_require__(292);
	var makeRecord = __webpack_require__(291);
	
	var _require = __webpack_require__(295),
	    getPrettySourceURL = _require.getPrettySourceURL;
	
	var _require2 = __webpack_require__(255),
	    prefs = _require2.prefs;
	
	var State = makeRecord({
	  sources: I.Map(),
	  selectedLocation: undefined,
	  pendingSelectedLocation: prefs.pendingSelectedLocation,
	  sourcesText: I.Map(),
	  tabs: I.List(restoreTabs())
	});
	
	function update() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : State();
	  var action = arguments[1];
	
	  var availableTabs = null;
	  var location = null;
	
	  switch (action.type) {
	    case "ADD_SOURCE":
	      {
	        var _source = action.source;
	        return state.mergeIn(["sources", action.source.id], _source);
	      }
	
	    case "SELECT_SOURCE":
	      location = {
	        line: action.line,
	        url: action.source.url
	      };
	      prefs.pendingSelectedLocation = location;
	
	      var sourceUrl = action.source.url || "";
	      return state.set("selectedLocation", {
	        sourceId: action.source.id,
	        line: action.line
	      }).set("pendingSelectedLocation", location).merge({
	        tabs: updateTabList({ sources: state }, sourceUrl, action.tabIndex)
	      });
	
	    case "SELECT_SOURCE_URL":
	      location = {
	        url: action.url,
	        line: action.line
	      };
	
	      prefs.pendingSelectedLocation = location;
	      return state.set("pendingSelectedLocation", location);
	
	    case "CLOSE_TAB":
	      availableTabs = removeSourceFromTabList(state.tabs, action.url);
	
	      return state.merge({ tabs: availableTabs }).set("selectedLocation", {
	        sourceId: getNewSelectedSourceId(state, availableTabs)
	      });
	
	    case "CLOSE_TABS":
	      availableTabs = removeSourcesFromTabList(state.tabs, action.urls);
	
	      return state.merge({ tabs: availableTabs }).set("selectedLocation", {
	        sourceId: getNewSelectedSourceId(state, availableTabs)
	      });
	
	    case "LOAD_SOURCE_TEXT":
	      return _updateText(state, action);
	
	    case "BLACKBOX":
	      if (action.status === "done") {
	        return state.setIn(["sources", action.source.id, "isBlackBoxed"], action.value.isBlackBoxed);
	      }
	      break;
	
	    case "TOGGLE_PRETTY_PRINT":
	      return _updateText(state, action);
	
	    case "NAVIGATE":
	      var source = getSelectedSource({ sources: state });
	      var _url = source && source.get("url");
	      prefs.pendingSelectedLocation = { url: _url };
	      return State().set("pendingSelectedLocation", { url: _url });
	  }
	
	  return state;
	}
	
	// TODO: Action is coerced to `any` unfortunately because how we type
	// asynchronous actions is wrong. The `value` may be null for the
	// "start" and "error" states but we don't type it like that. We need
	// to rethink how we type async actions.
	function _updateText(state, action) {
	  var source = action.source;
	  var sourceText = action.value;
	
	  if (action.status === "start") {
	    // Merge this in, don't set it. That way the previous value is
	    // still stored here, and we can retrieve it if whatever we're
	    // doing fails.
	    return state.mergeIn(["sourcesText", source.id], {
	      loading: true
	    });
	  }
	
	  if (action.status === "error") {
	    return state.setIn(["sourcesText", source.id], I.Map({
	      error: action.error
	    }));
	  }
	
	  return state.setIn(["sourcesText", source.id], I.Map({
	    text: sourceText.text,
	    contentType: sourceText.contentType
	  }));
	}
	
	function removeSourceFromTabList(tabs, url) {
	  var newTabs = tabs.filter(tab => tab != url);
	  prefs.tabs = newTabs;
	  return newTabs;
	}
	
	function removeSourcesFromTabList(tabs, urls) {
	  return urls.reduce((t, url) => removeSourceFromTabList(t, url), tabs);
	}
	
	function restoreTabs() {
	  var prefsTabs = prefs.tabs || [];
	  if (Object.keys(prefsTabs).length == 0) {
	    return;
	  }
	
	  return prefsTabs;
	}
	
	/**
	 * Adds the new source to the tab list if it is not already there
	 * @memberof reducers/sources
	 * @static
	 */
	function updateTabList(state, url, tabIndex) {
	  var tabs = state.sources.get("tabs");
	
	  var urlIndex = tabs.indexOf(url);
	  var includesUrl = !!tabs.find(tab => tab == url);
	
	  if (includesUrl) {
	    if (tabIndex != undefined) {
	      tabs = tabs.delete(urlIndex).insert(tabIndex, url);
	    }
	  } else {
	    tabs = tabs.insert(0, url);
	  }
	
	  prefs.tabs = tabs.toJS();
	  return tabs;
	}
	
	/**
	 * Gets the next tab to select when a tab closes. Heuristics:
	 * 1. if the selected tab is available, it remains selected
	 * 2. if it is gone, the next available tab to the left should be active
	 * 3. if the first tab is active and closed, select the second tab
	 *
	 * @memberof reducers/sources
	 * @static
	 */
	function getNewSelectedSourceId(state, availableTabs) {
	  var selectedLocation = state.selectedLocation;
	  if (!selectedLocation) {
	    return "";
	  }
	
	  var selectedTab = state.sources.find(source => source.get("id") == selectedLocation.sourceId);
	
	  var selectedTabUrl = selectedTab ? selectedTab.get("url") : "";
	
	  if (availableTabs.includes(selectedTabUrl)) {
	    var _sources = state.sources;
	    if (!_sources) {
	      return "";
	    }
	
	    var selectedSource = _sources.find(source => source.get("url") == selectedTabUrl);
	
	    if (selectedSource) {
	      return selectedSource.get("id");
	    }
	
	    return "";
	  }
	
	  var tabUrls = state.tabs.toJS();
	  var leftNeighborIndex = Math.max(tabUrls.indexOf(selectedTabUrl) - 1, 0);
	  var lastAvailbleTabIndex = availableTabs.size - 1;
	  var newSelectedTabIndex = Math.min(leftNeighborIndex, lastAvailbleTabIndex);
	  var tabSource = state.sources.find(source => source.get("url") == availableTabs.toJS()[newSelectedTabIndex]);
	
	  if (tabSource) {
	    return tabSource.get("id");
	  }
	
	  return "";
	}
	
	// Selectors
	
	// Unfortunately, it's really hard to make these functions accept just
	// the state that we care about and still type it with Flow. The
	// problem is that we want to re-export all selectors from a single
	// module for the UI, and all of those selectors should take the
	// top-level app state, so we'd have to "wrap" them to automatically
	// pick off the piece of state we're interested in. It's impossible
	// (right now) to type those wrapped functions.
	
	
	function getSource(state, id) {
	  return state.sources.sources.get(id);
	}
	
	function getSourceByURL(state, url) {
	  return state.sources.sources.find(source => source.get("url") == url);
	}
	
	function getSourceById(state, id) {
	  return state.sources.sources.find(source => source.get("id") == id);
	}
	
	function getSources(state) {
	  return state.sources.sources;
	}
	
	function getSourceText(state, id) {
	  return state.sources.sourcesText.get(id);
	}
	
	function getSourceTabs(state) {
	  var selectedLocation = getSelectedLocation(state);
	  if (!selectedLocation) {
	    return new I.List([]);
	  }
	
	  return state.sources.tabs.filter(tab => getSourceByURL(state, tab));
	}
	
	function getSelectedSource(state) {
	  var selectedLocation = state.sources.selectedLocation;
	  if (!selectedLocation) {
	    return;
	  }
	
	  return state.sources.sources.find(source => source.get("id") == selectedLocation.sourceId);
	}
	
	function getSelectedLocation(state) {
	  return state.sources.selectedLocation;
	}
	
	function getPendingSelectedLocation(state) {
	  return state.sources.pendingSelectedLocation;
	}
	
	function getPrettySource(state, id) {
	  var source = getSource(state, id);
	  if (!source) {
	    return;
	  }
	
	  return getSourceByURL(state, getPrettySourceURL(source.get("url")));
	}
	
	module.exports = {
	  State,
	  update,
	  getSource,
	  getSourceByURL,
	  getSourceById,
	  getSources,
	  getSourceText,
	  getSourceTabs,
	  getSelectedSource,
	  getSelectedLocation,
	  getPendingSelectedLocation,
	  getPrettySource
	};

/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	
	
	/**
	 * Utils for working with Source URLs
	 * @module utils/source
	 */
	
	var _require = __webpack_require__(250),
	    endTruncateStr = _require.endTruncateStr;
	
	var _require2 = __webpack_require__(296),
	    basename = _require2.basename;
	
	/**
	 * Trims the query part or reference identifier of a url string, if necessary.
	 *
	 * @memberof utils/source
	 * @static
	 */
	function trimUrlQuery(url) {
	  var length = url.length;
	  var q1 = url.indexOf("?");
	  var q2 = url.indexOf("&");
	  var q3 = url.indexOf("#");
	  var q = Math.min(q1 != -1 ? q1 : length, q2 != -1 ? q2 : length, q3 != -1 ? q3 : length);
	
	  return url.slice(0, q);
	}
	
	/**
	 * Returns true if the specified url and/or content type are specific to
	 * javascript files.
	 *
	 * @return boolean
	 *         True if the source is likely javascript.
	 *
	 * @memberof utils/source
	 * @static
	 */
	function isJavaScript(url) {
	  var contentType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
	
	  return url && /\.(jsm|js)?$/.test(trimUrlQuery(url)) || contentType.includes("javascript");
	}
	
	/**
	 * @memberof utils/source
	 * @static
	 */
	function isPretty(source) {
	  return source.url ? /formatted$/.test(source.url) : false;
	}
	
	/**
	 * @memberof utils/source
	 * @static
	 */
	function getPrettySourceURL(url) {
	  return `${ url }:formatted`;
	}
	
	/**
	 * @memberof utils/source
	 * @static
	 */
	function getRawSourceURL(url) {
	  return url.replace(/:formatted$/, "");
	}
	
	/**
	 * Show a source url's filename.
	 * If the source does not have a url, use the source id.
	 *
	 * @memberof utils/source
	 * @static
	 */
	function getFilename(source) {
	  var url = source.url,
	      id = source.id;
	
	  if (!url) {
	    var sourceId = id.split("/")[1];
	    return `SOURCE${ sourceId }`;
	  }
	
	  url = getRawSourceURL(url || "");
	  var name = basename(url) || "(index)";
	  return endTruncateStr(name, 50);
	}
	
	var contentTypeModeMap = {
	  "text/javascript": { name: "javascript" },
	  "text/typescript": { name: "javascript", typescript: true },
	  "text/coffeescript": "coffeescript",
	  "text/typescript-jsx": {
	    name: "jsx",
	    base: { name: "javascript", typescript: true }
	  },
	  "text/jsx": "jsx",
	  "text/x-elm": "elm",
	  "text/wasm": { name: "text" },
	  "html": { name: "htmlmixed" }
	};
	
	/**
	 *
	 * Returns Code Mirror mode for source content type
	 * @param contentType
	 * @return String
	 * @memberof utils/source
	 * @static
	 */
	
	function getMode(sourceText) {
	  var contentType = sourceText.contentType,
	      text = sourceText.text;
	
	  // //  or /*  */
	
	  if (text.match(/^\s*(\/\/ @flow|\/\* @flow \*\/)/)) {
	    return contentTypeModeMap["text/typescript"];
	  }
	
	  if (/script|elm|jsx|wasm/.test(contentType)) {
	    if (contentType in contentTypeModeMap) {
	      return contentTypeModeMap[contentType];
	    }
	
	    return contentTypeModeMap["text/javascript"];
	  }
	
	  // Use HTML mode for files in which the first non whitespace
	  // character is `<` regardless of extension.
	  if (text.match(/^\s*</)) {
	    return { name: "htmlmixed" };
	  }
	
	  return { name: "text" };
	}
	
	function getContentType(url) {
	  if (isJavaScript(url)) {
	    return "text/javascript";
	  }
	
	  if (url.match(/ts$/)) {
	    return "text/typescript";
	  }
	
	  if (url.match(/tsx$/)) {
	    return "text/typescript-jsx";
	  }
	
	  if (url.match(/jsx$/)) {
	    return "text/jsx";
	  }
	
	  if (url.match(/coffee$/)) {
	    return "text/coffeescript";
	  }
	
	  if (url.match(/elm$/)) {
	    return "text/elm";
	  }
	
	  return "text/plain";
	}
	
	module.exports = {
	  isJavaScript,
	  isPretty,
	  getPrettySourceURL,
	  getRawSourceURL,
	  getFilename,
	  getMode,
	  getContentType
	};

/***/ },
/* 296 */
/***/ function(module, exports) {

	function basename(path) {
	  return path.split("/").pop();
	}
	
	function dirname(path) {
	  var idx = path.lastIndexOf("/");
	  return path.slice(0, idx);
	}
	
	function isURL(str) {
	  return str.indexOf("://") !== -1;
	}
	
	function isAbsolute(str) {
	  return str[0] === "/";
	}
	
	function join(base, dir) {
	  return `${ base }/${ dir }`;
	}
	
	module.exports = {
	  basename, dirname, isURL, isAbsolute, join
	};

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	/**
	 * Breakpoints reducer
	 * @module reducers/breakpoints
	 */
	
	var fromJS = __webpack_require__(298);
	
	var _require = __webpack_require__(250),
	    updateObj = _require.updateObj;
	
	var I = __webpack_require__(292);
	var makeRecord = __webpack_require__(291);
	
	var State = makeRecord({
	  breakpoints: I.Map(),
	  breakpointsDisabled: false
	});
	
	// Return the first argument that is a string, or null if nothing is a
	// string.
	function firstString() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }
	
	  for (var arg of args) {
	    if (typeof arg === "string") {
	      return arg;
	    }
	  }
	  return null;
	}
	
	function locationMoved(location, newLocation) {
	  return location.line !== newLocation.line || location.column != null && location.column !== newLocation.column;
	}
	
	function makeLocationId(location) {
	  return `${ location.sourceId }:${ location.line }`;
	}
	
	function allBreakpointsDisabled(state) {
	  return state.breakpoints.every(x => x.disabled);
	}
	
	function update() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : State();
	  var action = arguments[1];
	
	  switch (action.type) {
	    case "ADD_BREAKPOINT":
	      {
	        var id = makeLocationId(action.breakpoint.location);
	
	        if (action.status === "start") {
	          var bp = state.breakpoints.get(id) || action.breakpoint;
	
	          return state.setIn(["breakpoints", id], updateObj(bp, {
	            disabled: false,
	            loading: true,
	            // We want to do an OR here, but we can't because we need
	            // empty strings to be truthy, i.e. an empty string is a valid
	            // condition.
	            condition: firstString(action.condition, bp.condition)
	          })).set("breakpointsDisabled", false);
	        } else if (action.status === "done") {
	          var _action$value = action.value,
	              breakpointId = _action$value.id,
	              text = _action$value.text;
	
	          var location = action.breakpoint.location;
	          var actualLocation = action.value.actualLocation;
	
	          // If the breakpoint moved, update the map
	
	          if (locationMoved(location, actualLocation)) {
	            state = state.deleteIn(["breakpoints", id]);
	
	            var movedId = makeLocationId(actualLocation);
	            var currentBp = state.breakpoints.get(movedId) || fromJS(action.breakpoint);
	            var newBp = updateObj(currentBp, { location: actualLocation });
	            state = state.setIn(["breakpoints", movedId], newBp);
	            location = actualLocation;
	          }
	
	          var locationId = makeLocationId(location);
	          var _bp = state.breakpoints.get(locationId);
	          return state.setIn(["breakpoints", locationId], updateObj(_bp, {
	            id: breakpointId,
	            disabled: false,
	            loading: false,
	            text: text
	          }));
	        } else if (action.status === "error") {
	          // Remove the optimistic update
	          return state.deleteIn(["breakpoints", id]);
	        }
	        break;
	      }
	
	    case "REMOVE_BREAKPOINT":
	      {
	        if (action.status === "done") {
	          var _id = makeLocationId(action.breakpoint.location);
	
	          if (action.disabled) {
	            var _bp2 = state.breakpoints.get(_id);
	            var _updatedState = state.setIn(["breakpoints", _id], updateObj(_bp2, {
	              loading: false, disabled: true
	            }));
	
	            return _updatedState.set("breakpointsDisabled", allBreakpointsDisabled(_updatedState));
	          }
	
	          var updatedState = state.deleteIn(["breakpoints", _id]);
	
	          return updatedState.set("breakpointsDisabled", allBreakpointsDisabled(updatedState));
	        }
	        break;
	      }
	
	    case "TOGGLE_BREAKPOINTS":
	      {
	        if (action.status === "start") {
	          return state.set("breakpointsDisabled", action.shouldDisableBreakpoints);
	        }
	        break;
	      }
	
	    case "SET_BREAKPOINT_CONDITION":
	      {
	        var _id2 = makeLocationId(action.breakpoint.location);
	
	        if (action.status === "start") {
	          var _bp3 = state.breakpoints.get(_id2);
	          return state.setIn(["breakpoints", _id2], updateObj(_bp3, {
	            loading: true,
	            condition: action.condition
	          }));
	        } else if (action.status === "done") {
	          var _bp4 = state.breakpoints.get(_id2);
	          return state.setIn(["breakpoints", _id2], updateObj(_bp4, {
	            id: action.value.id,
	            loading: false
	          }));
	        } else if (action.status === "error") {
	          return state.deleteIn(["breakpoints", _id2]);
	        }
	
	        break;
	      }
	  }
	
	  return state;
	}
	
	// Selectors
	
	function getBreakpoint(state, location) {
	  return state.breakpoints.breakpoints.get(makeLocationId(location));
	}
	
	function getBreakpoints(state) {
	  return state.breakpoints.breakpoints;
	}
	
	function getBreakpointsForSource(state, sourceId) {
	  return state.breakpoints.breakpoints.filter(bp => {
	    return bp.location.sourceId === sourceId;
	  });
	}
	
	function getBreakpointsDisabled(state) {
	  return state.breakpoints.get("breakpointsDisabled");
	}
	
	function getBreakpointsLoading(state) {
	  var breakpoints = getBreakpoints(state);
	  var isLoading = !!breakpoints.valueSeq().filter(bp => bp.loading).first();
	
	  return breakpoints.size > 0 && isLoading;
	}
	
	module.exports = {
	  State,
	  update,
	  makeLocationId,
	  getBreakpoint,
	  getBreakpoints,
	  getBreakpointsForSource,
	  getBreakpointsDisabled,
	  getBreakpointsLoading
	};

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	
	
	/**
	 * Immutable JS conversion utils
	 * @deprecated
	 * @module utils/fromJS
	 */
	
	var Immutable = __webpack_require__(292);
	
	/**
	 * When our app state is fully typed, we should be able to get rid of
	 * this function. This is only temporarily necessary to support
	 * converting typed objects to immutable.js, which usually happens in
	 * reducers.
	 *
	 * @memberof utils/fromJS
	 * @static
	 */
	function fromJS(value) {
	  if (Array.isArray(value)) {
	    return Immutable.Seq(value).map(fromJS).toList();
	  }
	  if (value && value.constructor.meta) {
	    // This adds support for tcomb objects which are native JS objects
	    // but are not "plain", so the above checks fail. Since they
	    // behave the same we can use the same constructors, but we need
	    // special checks for them.
	    var kind = value.constructor.meta.kind;
	    if (kind === "struct") {
	      return Immutable.Seq(value).map(fromJS).toMap();
	    } else if (kind === "list") {
	      return Immutable.Seq(value).map(fromJS).toList();
	    }
	  }
	
	  // If it's a primitive type, just return the value. Note `==` check
	  // for null, which is intentionally used to match either `null` or
	  // `undefined`.
	  if (value == null || typeof value !== "object") {
	    return value;
	  }
	
	  // Otherwise, treat it like an object. We can't reliably detect if
	  // it's a plain object because we might be objects from other JS
	  // contexts so `Object !== Object`.
	  return Immutable.Seq(value).map(fromJS).toMap();
	}
	
	module.exports = fromJS;

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	var constants = __webpack_require__(290);
	var initialState = [];
	
	function update() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
	  var action = arguments[1];
	  var seqId = action.seqId;
	
	
	  if (action.type === constants.NAVIGATE) {
	    return initialState;
	  } else if (seqId) {
	    var newState = void 0;
	    if (action.status === "start") {
	      newState = [].concat(_toConsumableArray(state), [seqId]);
	    } else if (action.status === "error" || action.status === "done") {
	      newState = state.filter(id => id !== seqId);
	    }
	
	    return newState;
	  }
	
	  return state;
	}
	
	module.exports = update;

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	var constants = __webpack_require__(290);
	var fromJS = __webpack_require__(298);
	var makeRecord = __webpack_require__(291);
	
	var _require = __webpack_require__(255),
	    prefs = _require.prefs;
	
	var I = __webpack_require__(292);
	
	var State = makeRecord({
	  pause: undefined,
	  isWaitingOnBreak: false,
	  frames: undefined,
	  selectedFrameId: undefined,
	  loadedObjects: I.Map(),
	  shouldPauseOnExceptions: prefs.pauseOnExceptions,
	  shouldIgnoreCaughtExceptions: prefs.ignoreCaughtExceptions,
	  expressions: I.List()
	});
	
	function update() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : State();
	  var action = arguments[1];
	
	  switch (action.type) {
	    case constants.PAUSED:
	      {
	        var _selectedFrameId = action.selectedFrameId,
	            _frames = action.frames,
	            pauseInfo = action.pauseInfo;
	
	        pauseInfo.isInterrupted = pauseInfo.why.type === "interrupted";
	
	        return state.merge({
	          isWaitingOnBreak: false,
	          pause: fromJS(pauseInfo),
	          selectedFrameId: _selectedFrameId,
	          frames: _frames
	        });
	      }
	
	    case constants.RESUME:
	      return state.merge({
	        pause: null,
	        frames: null,
	        selectedFrameId: null,
	        loadedObjects: {}
	      });
	
	    case constants.TOGGLE_PRETTY_PRINT:
	      if (action.status == "done") {
	        var _frames2 = action.value.frames;
	        var _pause = state.get("pause");
	        if (_pause) {
	          _pause = _pause.set("frame", fromJS(_frames2[0]));
	        }
	
	        return state.merge({ pause: _pause, frames: _frames2 });
	      }
	
	      break;
	    case constants.BREAK_ON_NEXT:
	      return state.set("isWaitingOnBreak", true);
	
	    case constants.SELECT_FRAME:
	      return state.set("selectedFrameId", action.frame.id);
	
	    case constants.LOAD_OBJECT_PROPERTIES:
	      if (action.status === "done") {
	        if (!action.value) {
	          return state;
	        }
	
	        var ownProperties = action.value.ownProperties;
	        var prototype = action.value.prototype;
	
	        return state.setIn(["loadedObjects", action.objectId], { ownProperties, prototype });
	      }
	      break;
	
	    case constants.NAVIGATE:
	      return State();
	
	    case constants.PAUSE_ON_EXCEPTIONS:
	      var _shouldPauseOnExceptions = action.shouldPauseOnExceptions,
	          _shouldIgnoreCaughtExceptions = action.shouldIgnoreCaughtExceptions;
	
	
	      prefs.pauseOnExceptions = _shouldPauseOnExceptions;
	      prefs.ignoreCaughtExceptions = _shouldIgnoreCaughtExceptions;
	
	      return state.merge({
	        shouldPauseOnExceptions: _shouldPauseOnExceptions,
	        shouldIgnoreCaughtExceptions: _shouldIgnoreCaughtExceptions
	      });
	  }
	
	  return state;
	}
	
	// Selectors
	
	// Unfortunately, it's really hard to make these functions accept just
	// the state that we care about and still type it with Flow. The
	// problem is that we want to re-export all selectors from a single
	// module for the UI, and all of those selectors should take the
	// top-level app state, so we'd have to "wrap" them to automatically
	// pick off the piece of state we're interested in. It's impossible
	// (right now) to type those wrapped functions.
	
	
	function getPause(state) {
	  return state.pause.get("pause");
	}
	
	function getLoadedObjects(state) {
	  return state.pause.get("loadedObjects");
	}
	
	function getIsWaitingOnBreak(state) {
	  return state.pause.get("isWaitingOnBreak");
	}
	
	function getShouldPauseOnExceptions(state) {
	  return state.pause.get("shouldPauseOnExceptions");
	}
	
	function getShouldIgnoreCaughtExceptions(state) {
	  return state.pause.get("shouldIgnoreCaughtExceptions");
	}
	
	function getFrames(state) {
	  return state.pause.get("frames");
	}
	
	function getSelectedFrame(state) {
	  var selectedFrameId = state.pause.get("selectedFrameId");
	  var frames = state.pause.get("frames");
	  return frames && frames.find(frame => frame.id == selectedFrameId);
	}
	
	// NOTE: currently only used for chrome
	function getChromeScopes(state) {
	  var frame = getSelectedFrame(state);
	  return frame ? frame.scopeChain : undefined;
	}
	
	module.exports = {
	  State,
	  update,
	  getPause,
	  getChromeScopes,
	  getLoadedObjects,
	  getIsWaitingOnBreak,
	  getShouldPauseOnExceptions,
	  getShouldIgnoreCaughtExceptions,
	  getFrames,
	  getSelectedFrame
	};

/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	
	
	/**
	 * UI reducer
	 * @module reducers/ui
	 */
	
	var constants = __webpack_require__(290);
	var makeRecord = __webpack_require__(291);
	
	var _require = __webpack_require__(255),
	    prefs = _require.prefs;
	
	var State = makeRecord({
	  searchOn: false,
	  shownSource: "",
	  startPanelCollapsed: prefs.startPanelCollapsed,
	  endPanelCollapsed: prefs.endPanelCollapsed
	});
	
	function update() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : State();
	  var action = arguments[1];
	
	  switch (action.type) {
	    case constants.TOGGLE_FILE_SEARCH:
	      {
	        return state.set("searchOn", action.searchOn);
	      }
	
	    case constants.SHOW_SOURCE:
	      {
	        return state.set("shownSource", action.sourceUrl);
	      }
	
	    case constants.TOGGLE_PANE:
	      {
	        if (action.position == "start") {
	          prefs.startPanelCollapsed = action.paneCollapsed;
	          return state.set("startPanelCollapsed", action.paneCollapsed);
	        }
	
	        prefs.endPanelCollapsed = action.paneCollapsed;
	        return state.set("endPanelCollapsed", action.paneCollapsed);
	      }
	
	    default:
	      {
	        return state;
	      }
	  }
	}
	
	// NOTE: we'd like to have the app state fully typed
	// https://github.com/devtools-html/debugger.html/blob/master/src/reducers/sources.js#L179-L185
	
	
	function getFileSearchState(state) {
	  return state.ui.get("searchOn");
	}
	
	function getShownSource(state) {
	  return state.ui.get("shownSource");
	}
	
	function getPaneCollapse(state, position) {
	  if (position == "start") {
	    return state.ui.get("startPanelCollapsed");
	  }
	
	  return state.ui.get("endPanelCollapsed");
	}
	
	module.exports = {
	  State,
	  update,
	  getFileSearchState,
	  getShownSource,
	  getPaneCollapse
	};

/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	
	
	/**
	 * Code Coverage reducer
	 * @module reducers/coverage
	 */
	
	var constants = __webpack_require__(290);
	var makeRecord = __webpack_require__(291);
	var I = __webpack_require__(292);
	var fromJS = __webpack_require__(298);
	
	var State = makeRecord({
	  coverageOn: false,
	  hitCount: I.Map()
	});
	
	function update() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : State();
	  var action = arguments[1];
	
	  switch (action.type) {
	    case constants.RECORD_COVERAGE:
	      return state.mergeIn(["hitCount"], fromJS(action.value.coverage)).setIn(["coverageOn"], true);
	
	    default:
	      {
	        return state;
	      }
	  }
	}
	
	// NOTE: we'd like to have the app state fully typed
	// https://github.com/devtools-html/debugger.html/blob/master/src/reducers/sources.js#L179-L185
	
	
	function getHitCountForSource(state, sourceId) {
	  var hitCount = state.coverage.get("hitCount");
	  return hitCount.get(sourceId);
	}
	
	function getCoverageEnabled(state) {
	  return state.coverage.get("coverageOn");
	}
	
	module.exports = {
	  State,
	  update,
	  getHitCountForSource,
	  getCoverageEnabled
	};

/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	var expressions = __webpack_require__(289);
	var sources = __webpack_require__(294);
	var pause = __webpack_require__(300);
	var breakpoints = __webpack_require__(297);
	var eventListeners = __webpack_require__(293);
	var ui = __webpack_require__(301);
	var coverage = __webpack_require__(302);
	
	/**
	 * @param object - location
	 */
	
	module.exports = {
	  getSource: sources.getSource,
	  getSourceByURL: sources.getSourceByURL,
	  getSourceById: sources.getSourceById,
	  getSources: sources.getSources,
	  getSourceText: sources.getSourceText,
	  getSourceTabs: sources.getSourceTabs,
	  getSelectedSource: sources.getSelectedSource,
	  getSelectedLocation: sources.getSelectedLocation,
	  getPendingSelectedLocation: sources.getPendingSelectedLocation,
	  getPrettySource: sources.getPrettySource,
	
	  getBreakpoint: breakpoints.getBreakpoint,
	  getBreakpoints: breakpoints.getBreakpoints,
	  getBreakpointsForSource: breakpoints.getBreakpointsForSource,
	  getBreakpointsDisabled: breakpoints.getBreakpointsDisabled,
	  getBreakpointsLoading: breakpoints.getBreakpointsLoading,
	
	  getPause: pause.getPause,
	  getChromeScopes: pause.getChromeScopes,
	  getLoadedObjects: pause.getLoadedObjects,
	  getIsWaitingOnBreak: pause.getIsWaitingOnBreak,
	  getShouldPauseOnExceptions: pause.getShouldPauseOnExceptions,
	  getShouldIgnoreCaughtExceptions: pause.getShouldIgnoreCaughtExceptions,
	  getFrames: pause.getFrames,
	  getSelectedFrame: pause.getSelectedFrame,
	
	  getHitCountForSource: coverage.getHitCountForSource,
	  getCoverageEnabled: coverage.getCoverageEnabled,
	
	  getEventListeners: eventListeners.getEventListeners,
	
	  getFileSearchState: ui.getFileSearchState,
	  getShownSource: ui.getShownSource,
	  getPaneCollapse: ui.getPaneCollapse,
	
	  getExpressions: expressions.getExpressions
	};

/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	var dom = React.DOM,
	    PropTypes = React.PropTypes,
	    createFactory = React.createFactory;
	
	var _require = __webpack_require__(305),
	    connect = _require.connect;
	
	var _require2 = __webpack_require__(3),
	    bindActionCreators = _require2.bindActionCreators;
	
	var actions = __webpack_require__(314);
	
	var _require3 = __webpack_require__(303),
	    getSources = _require3.getSources,
	    getSelectedSource = _require3.getSelectedSource,
	    getPaneCollapse = _require3.getPaneCollapse;
	
	var _require4 = __webpack_require__(256),
	    KeyShortcuts = _require4.KeyShortcuts;
	
	var shortcuts = new KeyShortcuts({ window });
	
	var verticalLayoutBreakpoint = window.matchMedia("(min-width: 700px)");
	
	__webpack_require__(389);
	__webpack_require__(391);
	__webpack_require__(393);
	__webpack_require__(395);
	
	var _require5 = __webpack_require__(28),
	    SplitBox = _require5.SplitBox;
	
	SplitBox = createFactory(SplitBox);
	
	var SourceSearch = createFactory(__webpack_require__(397));
	var Sources = createFactory(__webpack_require__(449));
	var Editor = createFactory(__webpack_require__(511));
	var SecondaryPanes = createFactory(__webpack_require__(547));
	var WelcomeBox = createFactory(__webpack_require__(627));
	var EditorTabs = createFactory(__webpack_require__(630));
	
	var App = React.createClass({
	  propTypes: {
	    sources: PropTypes.object,
	    selectSource: PropTypes.func,
	    selectedSource: PropTypes.object,
	    startPanelCollapsed: PropTypes.bool,
	    endPanelCollapsed: PropTypes.bool
	  },
	
	  displayName: "App",
	
	  getChildContext() {
	    return { shortcuts };
	  },
	
	  componentDidMount() {
	    verticalLayoutBreakpoint.addListener(this.onLayoutChange);
	  },
	
	  componentWillUnmount() {
	    verticalLayoutBreakpoint.removeListener(this.onLayoutChange);
	  },
	
	  getInitialState() {
	    return { horizontal: verticalLayoutBreakpoint.matches };
	  },
	
	  onLayoutChange() {
	    this.setState({
	      horizontal: verticalLayoutBreakpoint.matches
	    });
	  },
	
	  renderEditorPane() {
	    var _props = this.props,
	        startPanelCollapsed = _props.startPanelCollapsed,
	        endPanelCollapsed = _props.endPanelCollapsed;
	    var horizontal = this.state.horizontal;
	
	    return dom.div({ className: "editor-pane" }, dom.div({ className: "editor-container" }, EditorTabs({
	      startPanelCollapsed,
	      endPanelCollapsed,
	      horizontal
	    }), Editor({ horizontal }), !this.props.selectedSource ? WelcomeBox({ horizontal }) : null, SourceSearch()));
	  },
	
	  renderHorizontalLayout() {
	    var _props2 = this.props,
	        sources = _props2.sources,
	        startPanelCollapsed = _props2.startPanelCollapsed,
	        endPanelCollapsed = _props2.endPanelCollapsed;
	    var horizontal = this.state.horizontal;
	
	
	    var overflowX = endPanelCollapsed ? "hidden" : "auto";
	
	    return dom.div({ className: "debugger" }, SplitBox({
	      style: { width: "100vw" },
	      initialSize: "300px",
	      minSize: 10,
	      maxSize: "50%",
	      splitterSize: 1,
	      startPanel: Sources({ sources, horizontal }),
	      startPanelCollapsed,
	      endPanel: SplitBox({
	        style: { overflowX },
	        initialSize: "300px",
	        minSize: 10,
	        maxSize: "80%",
	        splitterSize: 1,
	        endPanelControl: true,
	        startPanel: this.renderEditorPane(),
	        endPanel: SecondaryPanes({ horizontal }),
	        endPanelCollapsed,
	        vert: horizontal
	      })
	    }));
	  },
	
	  renderVerticalLayout() {
	    var _props3 = this.props,
	        sources = _props3.sources,
	        startPanelCollapsed = _props3.startPanelCollapsed,
	        endPanelCollapsed = _props3.endPanelCollapsed;
	    var horizontal = this.state.horizontal;
	
	
	    return dom.div({ className: "debugger" }, SplitBox({
	      style: { width: "100vw" },
	      initialSize: "300px",
	      minSize: 30,
	      maxSize: "99%",
	      splitterSize: 1,
	      vert: horizontal,
	      startPanel: SplitBox({
	        style: { width: "100vw" },
	        initialSize: "150px",
	        minSize: 10,
	        maxSize: "40%",
	        splitterSize: 1,
	        startPanelCollapsed,
	        startPanel: Sources({ sources, horizontal }),
	        endPanel: this.renderEditorPane()
	      }),
	      endPanel: SecondaryPanes({ horizontal }),
	      endPanelCollapsed
	    }));
	  },
	
	  render() {
	    return this.state.horizontal ? this.renderHorizontalLayout() : this.renderVerticalLayout();
	  }
	});
	
	App.childContextTypes = {
	  shortcuts: PropTypes.object
	};
	
	module.exports = connect(state => ({ sources: getSources(state),
	  selectedSource: getSelectedSource(state),
	  startPanelCollapsed: getPaneCollapse(state, "start"),
	  endPanelCollapsed: getPaneCollapse(state, "end")
	}), dispatch => bindActionCreators(actions, dispatch))(App);

/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.connect = exports.Provider = undefined;
	
	var _Provider = __webpack_require__(306);
	
	var _Provider2 = _interopRequireDefault(_Provider);
	
	var _connect = __webpack_require__(309);
	
	var _connect2 = _interopRequireDefault(_connect);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	exports.Provider = _Provider2["default"];
	exports.connect = _connect2["default"];

/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = undefined;
	
	var _react = __webpack_require__(2);
	
	var _storeShape = __webpack_require__(307);
	
	var _storeShape2 = _interopRequireDefault(_storeShape);
	
	var _warning = __webpack_require__(308);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var didWarnAboutReceivingStore = false;
	function warnAboutReceivingStore() {
	  if (didWarnAboutReceivingStore) {
	    return;
	  }
	  didWarnAboutReceivingStore = true;
	
	  (0, _warning2["default"])('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
	}
	
	var Provider = function (_Component) {
	  _inherits(Provider, _Component);
	
	  Provider.prototype.getChildContext = function getChildContext() {
	    return { store: this.store };
	  };
	
	  function Provider(props, context) {
	    _classCallCheck(this, Provider);
	
	    var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));
	
	    _this.store = props.store;
	    return _this;
	  }
	
	  Provider.prototype.render = function render() {
	    var children = this.props.children;
	
	    return _react.Children.only(children);
	  };
	
	  return Provider;
	}(_react.Component);
	
	exports["default"] = Provider;
	
	if (false) {
	  Provider.prototype.componentWillReceiveProps = function (nextProps) {
	    var store = this.store;
	    var nextStore = nextProps.store;
	
	    if (store !== nextStore) {
	      warnAboutReceivingStore();
	    }
	  };
	}
	
	Provider.propTypes = {
	  store: _storeShape2["default"].isRequired,
	  children: _react.PropTypes.element.isRequired
	};
	Provider.childContextTypes = {
	  store: _storeShape2["default"].isRequired
	};

/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(2);
	
	exports["default"] = _react.PropTypes.shape({
	  subscribe: _react.PropTypes.func.isRequired,
	  dispatch: _react.PropTypes.func.isRequired,
	  getState: _react.PropTypes.func.isRequired
	});

/***/ },
/* 308 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that you can use this stack
	    // to find the callsite that caused this warning to fire.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.__esModule = true;
	exports["default"] = connect;
	
	var _react = __webpack_require__(2);
	
	var _storeShape = __webpack_require__(307);
	
	var _storeShape2 = _interopRequireDefault(_storeShape);
	
	var _shallowEqual = __webpack_require__(310);
	
	var _shallowEqual2 = _interopRequireDefault(_shallowEqual);
	
	var _wrapActionCreators = __webpack_require__(311);
	
	var _wrapActionCreators2 = _interopRequireDefault(_wrapActionCreators);
	
	var _warning = __webpack_require__(308);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _isPlainObject = __webpack_require__(5);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _hoistNonReactStatics = __webpack_require__(312);
	
	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);
	
	var _invariant = __webpack_require__(313);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var defaultMapStateToProps = function defaultMapStateToProps(state) {
	  return {};
	}; // eslint-disable-line no-unused-vars
	var defaultMapDispatchToProps = function defaultMapDispatchToProps(dispatch) {
	  return { dispatch: dispatch };
	};
	var defaultMergeProps = function defaultMergeProps(stateProps, dispatchProps, parentProps) {
	  return _extends({}, parentProps, stateProps, dispatchProps);
	};
	
	function getDisplayName(WrappedComponent) {
	  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
	}
	
	var errorObject = { value: null };
	function tryCatch(fn, ctx) {
	  try {
	    return fn.apply(ctx);
	  } catch (e) {
	    errorObject.value = e;
	    return errorObject;
	  }
	}
	
	// Helps track hot reloading.
	var nextVersion = 0;
	
	function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
	  var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
	
	  var shouldSubscribe = Boolean(mapStateToProps);
	  var mapState = mapStateToProps || defaultMapStateToProps;
	
	  var mapDispatch = undefined;
	  if (typeof mapDispatchToProps === 'function') {
	    mapDispatch = mapDispatchToProps;
	  } else if (!mapDispatchToProps) {
	    mapDispatch = defaultMapDispatchToProps;
	  } else {
	    mapDispatch = (0, _wrapActionCreators2["default"])(mapDispatchToProps);
	  }
	
	  var finalMergeProps = mergeProps || defaultMergeProps;
	  var _options$pure = options.pure;
	  var pure = _options$pure === undefined ? true : _options$pure;
	  var _options$withRef = options.withRef;
	  var withRef = _options$withRef === undefined ? false : _options$withRef;
	
	  var checkMergedEquals = pure && finalMergeProps !== defaultMergeProps;
	
	  // Helps track hot reloading.
	  var version = nextVersion++;
	
	  return function wrapWithConnect(WrappedComponent) {
	    var connectDisplayName = 'Connect(' + getDisplayName(WrappedComponent) + ')';
	
	    function checkStateShape(props, methodName) {
	      if (!(0, _isPlainObject2["default"])(props)) {
	        (0, _warning2["default"])(methodName + '() in ' + connectDisplayName + ' must return a plain object. ' + ('Instead received ' + props + '.'));
	      }
	    }
	
	    function computeMergedProps(stateProps, dispatchProps, parentProps) {
	      var mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps);
	      if (false) {
	        checkStateShape(mergedProps, 'mergeProps');
	      }
	      return mergedProps;
	    }
	
	    var Connect = function (_Component) {
	      _inherits(Connect, _Component);
	
	      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
	        return !pure || this.haveOwnPropsChanged || this.hasStoreStateChanged;
	      };
	
	      function Connect(props, context) {
	        _classCallCheck(this, Connect);
	
	        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));
	
	        _this.version = version;
	        _this.store = props.store || context.store;
	
	        (0, _invariant2["default"])(_this.store, 'Could not find "store" in either the context or ' + ('props of "' + connectDisplayName + '". ') + 'Either wrap the root component in a <Provider>, ' + ('or explicitly pass "store" as a prop to "' + connectDisplayName + '".'));
	
	        var storeState = _this.store.getState();
	        _this.state = { storeState: storeState };
	        _this.clearCache();
	        return _this;
	      }
	
	      Connect.prototype.computeStateProps = function computeStateProps(store, props) {
	        if (!this.finalMapStateToProps) {
	          return this.configureFinalMapState(store, props);
	        }
	
	        var state = store.getState();
	        var stateProps = this.doStatePropsDependOnOwnProps ? this.finalMapStateToProps(state, props) : this.finalMapStateToProps(state);
	
	        if (false) {
	          checkStateShape(stateProps, 'mapStateToProps');
	        }
	        return stateProps;
	      };
	
	      Connect.prototype.configureFinalMapState = function configureFinalMapState(store, props) {
	        var mappedState = mapState(store.getState(), props);
	        var isFactory = typeof mappedState === 'function';
	
	        this.finalMapStateToProps = isFactory ? mappedState : mapState;
	        this.doStatePropsDependOnOwnProps = this.finalMapStateToProps.length !== 1;
	
	        if (isFactory) {
	          return this.computeStateProps(store, props);
	        }
	
	        if (false) {
	          checkStateShape(mappedState, 'mapStateToProps');
	        }
	        return mappedState;
	      };
	
	      Connect.prototype.computeDispatchProps = function computeDispatchProps(store, props) {
	        if (!this.finalMapDispatchToProps) {
	          return this.configureFinalMapDispatch(store, props);
	        }
	
	        var dispatch = store.dispatch;
	
	        var dispatchProps = this.doDispatchPropsDependOnOwnProps ? this.finalMapDispatchToProps(dispatch, props) : this.finalMapDispatchToProps(dispatch);
	
	        if (false) {
	          checkStateShape(dispatchProps, 'mapDispatchToProps');
	        }
	        return dispatchProps;
	      };
	
	      Connect.prototype.configureFinalMapDispatch = function configureFinalMapDispatch(store, props) {
	        var mappedDispatch = mapDispatch(store.dispatch, props);
	        var isFactory = typeof mappedDispatch === 'function';
	
	        this.finalMapDispatchToProps = isFactory ? mappedDispatch : mapDispatch;
	        this.doDispatchPropsDependOnOwnProps = this.finalMapDispatchToProps.length !== 1;
	
	        if (isFactory) {
	          return this.computeDispatchProps(store, props);
	        }
	
	        if (false) {
	          checkStateShape(mappedDispatch, 'mapDispatchToProps');
	        }
	        return mappedDispatch;
	      };
	
	      Connect.prototype.updateStatePropsIfNeeded = function updateStatePropsIfNeeded() {
	        var nextStateProps = this.computeStateProps(this.store, this.props);
	        if (this.stateProps && (0, _shallowEqual2["default"])(nextStateProps, this.stateProps)) {
	          return false;
	        }
	
	        this.stateProps = nextStateProps;
	        return true;
	      };
	
	      Connect.prototype.updateDispatchPropsIfNeeded = function updateDispatchPropsIfNeeded() {
	        var nextDispatchProps = this.computeDispatchProps(this.store, this.props);
	        if (this.dispatchProps && (0, _shallowEqual2["default"])(nextDispatchProps, this.dispatchProps)) {
	          return false;
	        }
	
	        this.dispatchProps = nextDispatchProps;
	        return true;
	      };
	
	      Connect.prototype.updateMergedPropsIfNeeded = function updateMergedPropsIfNeeded() {
	        var nextMergedProps = computeMergedProps(this.stateProps, this.dispatchProps, this.props);
	        if (this.mergedProps && checkMergedEquals && (0, _shallowEqual2["default"])(nextMergedProps, this.mergedProps)) {
	          return false;
	        }
	
	        this.mergedProps = nextMergedProps;
	        return true;
	      };
	
	      Connect.prototype.isSubscribed = function isSubscribed() {
	        return typeof this.unsubscribe === 'function';
	      };
	
	      Connect.prototype.trySubscribe = function trySubscribe() {
	        if (shouldSubscribe && !this.unsubscribe) {
	          this.unsubscribe = this.store.subscribe(this.handleChange.bind(this));
	          this.handleChange();
	        }
	      };
	
	      Connect.prototype.tryUnsubscribe = function tryUnsubscribe() {
	        if (this.unsubscribe) {
	          this.unsubscribe();
	          this.unsubscribe = null;
	        }
	      };
	
	      Connect.prototype.componentDidMount = function componentDidMount() {
	        this.trySubscribe();
	      };
	
	      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        if (!pure || !(0, _shallowEqual2["default"])(nextProps, this.props)) {
	          this.haveOwnPropsChanged = true;
	        }
	      };
	
	      Connect.prototype.componentWillUnmount = function componentWillUnmount() {
	        this.tryUnsubscribe();
	        this.clearCache();
	      };
	
	      Connect.prototype.clearCache = function clearCache() {
	        this.dispatchProps = null;
	        this.stateProps = null;
	        this.mergedProps = null;
	        this.haveOwnPropsChanged = true;
	        this.hasStoreStateChanged = true;
	        this.haveStatePropsBeenPrecalculated = false;
	        this.statePropsPrecalculationError = null;
	        this.renderedElement = null;
	        this.finalMapDispatchToProps = null;
	        this.finalMapStateToProps = null;
	      };
	
	      Connect.prototype.handleChange = function handleChange() {
	        if (!this.unsubscribe) {
	          return;
	        }
	
	        var storeState = this.store.getState();
	        var prevStoreState = this.state.storeState;
	        if (pure && prevStoreState === storeState) {
	          return;
	        }
	
	        if (pure && !this.doStatePropsDependOnOwnProps) {
	          var haveStatePropsChanged = tryCatch(this.updateStatePropsIfNeeded, this);
	          if (!haveStatePropsChanged) {
	            return;
	          }
	          if (haveStatePropsChanged === errorObject) {
	            this.statePropsPrecalculationError = errorObject.value;
	          }
	          this.haveStatePropsBeenPrecalculated = true;
	        }
	
	        this.hasStoreStateChanged = true;
	        this.setState({ storeState: storeState });
	      };
	
	      Connect.prototype.getWrappedInstance = function getWrappedInstance() {
	        (0, _invariant2["default"])(withRef, 'To access the wrapped instance, you need to specify ' + '{ withRef: true } as the fourth argument of the connect() call.');
	
	        return this.refs.wrappedInstance;
	      };
	
	      Connect.prototype.render = function render() {
	        var haveOwnPropsChanged = this.haveOwnPropsChanged;
	        var hasStoreStateChanged = this.hasStoreStateChanged;
	        var haveStatePropsBeenPrecalculated = this.haveStatePropsBeenPrecalculated;
	        var statePropsPrecalculationError = this.statePropsPrecalculationError;
	        var renderedElement = this.renderedElement;
	
	        this.haveOwnPropsChanged = false;
	        this.hasStoreStateChanged = false;
	        this.haveStatePropsBeenPrecalculated = false;
	        this.statePropsPrecalculationError = null;
	
	        if (statePropsPrecalculationError) {
	          throw statePropsPrecalculationError;
	        }
	
	        var shouldUpdateStateProps = true;
	        var shouldUpdateDispatchProps = true;
	        if (pure && renderedElement) {
	          shouldUpdateStateProps = hasStoreStateChanged || haveOwnPropsChanged && this.doStatePropsDependOnOwnProps;
	          shouldUpdateDispatchProps = haveOwnPropsChanged && this.doDispatchPropsDependOnOwnProps;
	        }
	
	        var haveStatePropsChanged = false;
	        var haveDispatchPropsChanged = false;
	        if (haveStatePropsBeenPrecalculated) {
	          haveStatePropsChanged = true;
	        } else if (shouldUpdateStateProps) {
	          haveStatePropsChanged = this.updateStatePropsIfNeeded();
	        }
	        if (shouldUpdateDispatchProps) {
	          haveDispatchPropsChanged = this.updateDispatchPropsIfNeeded();
	        }
	
	        var haveMergedPropsChanged = true;
	        if (haveStatePropsChanged || haveDispatchPropsChanged || haveOwnPropsChanged) {
	          haveMergedPropsChanged = this.updateMergedPropsIfNeeded();
	        } else {
	          haveMergedPropsChanged = false;
	        }
	
	        if (!haveMergedPropsChanged && renderedElement) {
	          return renderedElement;
	        }
	
	        if (withRef) {
	          this.renderedElement = (0, _react.createElement)(WrappedComponent, _extends({}, this.mergedProps, {
	            ref: 'wrappedInstance'
	          }));
	        } else {
	          this.renderedElement = (0, _react.createElement)(WrappedComponent, this.mergedProps);
	        }
	
	        return this.renderedElement;
	      };
	
	      return Connect;
	    }(_react.Component);
	
	    Connect.displayName = connectDisplayName;
	    Connect.WrappedComponent = WrappedComponent;
	    Connect.contextTypes = {
	      store: _storeShape2["default"]
	    };
	    Connect.propTypes = {
	      store: _storeShape2["default"]
	    };
	
	    if (false) {
	      Connect.prototype.componentWillUpdate = function componentWillUpdate() {
	        if (this.version === version) {
	          return;
	        }
	
	        // We are hot reloading!
	        this.version = version;
	        this.trySubscribe();
	        this.clearCache();
	      };
	    }
	
	    return (0, _hoistNonReactStatics2["default"])(Connect, WrappedComponent);
	  };
	}

/***/ },
/* 310 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = shallowEqual;
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  var hasOwn = Object.prototype.hasOwnProperty;
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
	      return false;
	    }
	  }
	
	  return true;
	}

/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = wrapActionCreators;
	
	var _redux = __webpack_require__(3);
	
	function wrapActionCreators(actionCreators) {
	  return function (dispatch) {
	    return (0, _redux.bindActionCreators)(actionCreators, dispatch);
	  };
	}

/***/ },
/* 312 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	'use strict';
	
	var REACT_STATICS = {
	    childContextTypes: true,
	    contextTypes: true,
	    defaultProps: true,
	    displayName: true,
	    getDefaultProps: true,
	    mixins: true,
	    propTypes: true,
	    type: true
	};
	
	var KNOWN_STATICS = {
	    name: true,
	    length: true,
	    prototype: true,
	    caller: true,
	    arguments: true,
	    arity: true
	};
	
	var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';
	
	module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
	    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components
	        var keys = Object.getOwnPropertyNames(sourceComponent);
	
	        /* istanbul ignore else */
	        if (isGetOwnPropertySymbolsAvailable) {
	            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
	        }
	
	        for (var i = 0; i < keys.length; ++i) {
	            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
	                try {
	                    targetComponent[keys[i]] = sourceComponent[keys[i]];
	                } catch (error) {
	
	                }
	            }
	        }
	    }
	
	    return targetComponent;
	};


/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var invariant = function(condition, format, a, b, c, d, e, f) {
	  if (false) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};
	
	module.exports = invariant;


/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	var breakpoints = __webpack_require__(315);
	var expressions = __webpack_require__(322);
	var eventListeners = __webpack_require__(323);
	var sources = __webpack_require__(324);
	var pause = __webpack_require__(385);
	var navigation = __webpack_require__(386);
	var ui = __webpack_require__(387);
	var coverage = __webpack_require__(388);
	
	module.exports = Object.assign(navigation, breakpoints, expressions, eventListeners, sources, pause, ui, coverage);

/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	/**
	 * Redux actions for breakpoints
	 * @module actions/breakpoints
	 */
	
	var constants = __webpack_require__(290);
	
	var _require = __webpack_require__(248),
	    PROMISE = _require.PROMISE;
	
	var _require2 = __webpack_require__(303),
	    getBreakpoint = _require2.getBreakpoint,
	    getBreakpoints = _require2.getBreakpoints,
	    getSource = _require2.getSource;
	
	var _require3 = __webpack_require__(316),
	    getOriginalLocation = _require3.getOriginalLocation,
	    getGeneratedLocation = _require3.getGeneratedLocation,
	    isOriginalId = _require3.isOriginalId;
	
	function _breakpointExists(state, location) {
	  var currentBp = getBreakpoint(state, location);
	  return currentBp && !currentBp.disabled;
	}
	
	function _getOrCreateBreakpoint(state, location, condition) {
	  return getBreakpoint(state, location) || { location, condition, text: "" };
	}
	
	/**
	 * Enabling a breakpoint calls {@link addBreakpoint}
	 * which will reuse the existing breakpoint information that is stored.
	 *
	 * @memberof actions/breakpoints
	 * @static
	 */
	function enableBreakpoint(location) {
	  return addBreakpoint(location);
	}
	
	/**
	 * Add a new or enable an existing breakpoint
	 *
	 * @memberof actions/breakpoints
	 * @static
	 * @param {String} $1.condition Conditional breakpoint condition value
	 * @param {Function} $1.getTextForLine Get the text to represent the line
	 */
	function addBreakpoint(location) {
	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      condition = _ref.condition,
	      getTextForLine = _ref.getTextForLine;
	
	  return (_ref2) => {
	    var dispatch = _ref2.dispatch,
	        getState = _ref2.getState,
	        client = _ref2.client;
	
	    if (_breakpointExists(getState(), location)) {
	      return Promise.resolve();
	    }
	
	    var bp = _getOrCreateBreakpoint(getState(), location, condition);
	
	    return dispatch({
	      type: constants.ADD_BREAKPOINT,
	      breakpoint: bp,
	      condition: condition,
	      [PROMISE]: _asyncToGenerator(function* () {
	        if (isOriginalId(bp.location.sourceId)) {
	          var source = getSource(getState(), bp.location.sourceId);
	          location = yield getGeneratedLocation(bp.location, source.toJS());
	        }
	
	        var _ref4 = yield client.setBreakpoint(location, bp.condition, isOriginalId(bp.location.sourceId)),
	            id = _ref4.id,
	            actualLocation = _ref4.actualLocation,
	            hitCount = _ref4.hitCount;
	
	        actualLocation = yield getOriginalLocation(actualLocation);
	
	        // If this breakpoint is being re-enabled, it already has a
	        // text snippet.
	        var text = bp.text;
	        if (!text) {
	          text = getTextForLine ? getTextForLine(actualLocation.line) : "";
	        }
	
	        return { id, actualLocation, text, hitCount };
	      })()
	    });
	  };
	}
	
	/**
	 * Disable a single breakpoint
	 *
	 * @memberof actions/breakpoints
	 * @static
	 */
	function disableBreakpoint(location) {
	  return _removeOrDisableBreakpoint(location, true);
	}
	
	/**
	 * Remove a single breakpoint
	 *
	 * @memberof actions/breakpoints
	 * @static
	 */
	function removeBreakpoint(location) {
	  return _removeOrDisableBreakpoint(location);
	}
	
	function _removeOrDisableBreakpoint(location, isDisabled) {
	  return (_ref5) => {
	    var dispatch = _ref5.dispatch,
	        getState = _ref5.getState,
	        client = _ref5.client;
	
	    var bp = getBreakpoint(getState(), location);
	    if (!bp) {
	      throw new Error("attempt to remove breakpoint that does not exist");
	    }
	    if (bp.loading) {
	      // TODO(jwl): make this wait until the breakpoint is saved if it
	      // is still loading
	      throw new Error("attempt to remove unsaved breakpoint");
	    }
	
	    var action = {
	      type: constants.REMOVE_BREAKPOINT,
	      breakpoint: bp,
	      disabled: isDisabled
	    };
	
	    // If the breakpoint is already disabled, we don't need to remove
	    // it from the server. We just need to dispatch an action
	    // simulating a successful server request to remove it, and it
	    // will be removed completely from the state.
	    if (!bp.disabled) {
	      return dispatch(Object.assign({}, action, {
	        [PROMISE]: client.removeBreakpoint(bp.id)
	      }));
	    }
	    return dispatch(Object.assign({}, action, { status: "done" }));
	  };
	}
	
	/**
	 * Toggle All Breakpoints
	 *
	 * @memberof actions/breakpoints
	 * @static
	 */
	function toggleAllBreakpoints(shouldDisableBreakpoints) {
	  return (_ref6) => {
	    var dispatch = _ref6.dispatch,
	        getState = _ref6.getState;
	
	    var breakpoints = getBreakpoints(getState());
	    return dispatch({
	      type: constants.TOGGLE_BREAKPOINTS,
	      shouldDisableBreakpoints,
	      [PROMISE]: _asyncToGenerator(function* () {
	        for (var _ref8 of breakpoints) {
	          var _ref9 = _slicedToArray(_ref8, 2);
	
	          var breakpoint = _ref9[1];
	
	          if (shouldDisableBreakpoints) {
	            yield dispatch(disableBreakpoint(breakpoint.location));
	          } else {
	            yield dispatch(enableBreakpoint(breakpoint.location));
	          }
	        }
	      })()
	    });
	  };
	}
	
	/**
	 * Update the condition of a breakpoint.
	 *
	 * @throws {Error} "not implemented"
	 * @memberof actions/breakpoints
	 * @static
	 * @param {Location} location
	 *        @see DebuggerController.Breakpoints.addBreakpoint
	 * @param {string} condition
	 *        The condition to set on the breakpoint
	 */
	function setBreakpointCondition(location) {
	  var _ref10 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      condition = _ref10.condition,
	      getTextForLine = _ref10.getTextForLine;
	
	  // location: Location, condition: string, { getTextForLine }) {
	  return (_ref11) => {
	    var dispatch = _ref11.dispatch,
	        getState = _ref11.getState,
	        client = _ref11.client;
	
	    var bp = getBreakpoint(getState(), location);
	    if (!bp) {
	      return dispatch(addBreakpoint(location, { condition, getTextForLine }));
	    }
	
	    if (bp.loading) {
	      // TODO(jwl): when this function is called, make sure the action
	      // creator waits for the breakpoint to exist
	      throw new Error("breakpoint must be saved");
	    }
	
	    return dispatch({
	      type: constants.SET_BREAKPOINT_CONDITION,
	      breakpoint: bp,
	      condition: condition,
	      [PROMISE]: client.setBreakpointCondition(bp.id, location, condition, isOriginalId(bp.location.sourceId))
	    });
	  };
	}
	
	module.exports = {
	  enableBreakpoint,
	  addBreakpoint,
	  disableBreakpoint,
	  removeBreakpoint,
	  toggleAllBreakpoints,
	  setBreakpointCondition
	};

/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	var hasMappedSource = (() => {
	  var _ref = _asyncToGenerator(function* (location) {
	    if (isOriginalId(location.sourceId)) {
	      return true;
	    }
	
	    var loc = yield getOriginalLocation(location);
	    return loc.sourceId !== location.sourceId;
	  });
	
	  return function hasMappedSource(_x) {
	    return _ref.apply(this, arguments);
	  };
	})();
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	var _require = __webpack_require__(197),
	    getValue = _require.getValue;
	
	var _require2 = __webpack_require__(250),
	    workerTask = _require2.workerTask;
	
	var _require3 = __webpack_require__(317),
	    originalToGeneratedId = _require3.originalToGeneratedId,
	    generatedToOriginalId = _require3.generatedToOriginalId,
	    isGeneratedId = _require3.isGeneratedId,
	    isOriginalId = _require3.isOriginalId;
	
	var _require4 = __webpack_require__(255),
	    prefs = _require4.prefs;
	
	var sourceMapWorker = void 0;
	function restartWorker() {
	  if (sourceMapWorker) {
	    sourceMapWorker.terminate();
	  }
	  sourceMapWorker = new Worker(`${ getValue("baseWorkerURL") }source-map-worker.js`);
	
	  sourceMapWorker.postMessage({ id: 0, method: "enableSourceMaps" });
	}
	restartWorker();
	
	function destroyWorker() {
	  if (sourceMapWorker) {
	    sourceMapWorker.terminate();
	    sourceMapWorker = null;
	  }
	}
	
	function shouldSourceMap() {
	  return prefs.clientSourceMapsEnabled;
	}
	
	var getOriginalURLs = workerTask(sourceMapWorker, "getOriginalURLs");
	var getGeneratedLocation = workerTask(sourceMapWorker, "getGeneratedLocation");
	var getOriginalLocation = workerTask(sourceMapWorker, "getOriginalLocation");
	var getOriginalSourceText = workerTask(sourceMapWorker, "getOriginalSourceText");
	var applySourceMap = workerTask(sourceMapWorker, "applySourceMap");
	var clearSourceMaps = workerTask(sourceMapWorker, "clearSourceMaps");
	
	module.exports = {
	  originalToGeneratedId,
	  generatedToOriginalId,
	  isGeneratedId,
	  isOriginalId,
	  hasMappedSource,
	  getOriginalURLs,
	  getGeneratedLocation,
	  getOriginalLocation,
	  getOriginalSourceText,
	  applySourceMap,
	  clearSourceMaps,
	  destroyWorker,
	  shouldSourceMap
	};

/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	var md5 = __webpack_require__(318);
	
	function originalToGeneratedId(originalId) {
	  var match = originalId.match(/(.*)\/originalSource/);
	  return match ? match[1] : "";
	}
	
	function generatedToOriginalId(generatedId, url) {
	  return `${ generatedId }/originalSource-${ md5(url) }`;
	}
	
	function isOriginalId(id) {
	  return !!id.match(/\/originalSource/);
	}
	
	function isGeneratedId(id) {
	  return !isOriginalId(id);
	}
	
	module.exports = {
	  originalToGeneratedId, generatedToOriginalId, isOriginalId, isGeneratedId
	};

/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
	  var crypt = __webpack_require__(319),
	      utf8 = __webpack_require__(320).utf8,
	      isBuffer = __webpack_require__(321),
	      bin = __webpack_require__(320).bin,
	
	  // The core
	  md5 = function (message, options) {
	    // Convert to byte array
	    if (message.constructor == String)
	      if (options && options.encoding === 'binary')
	        message = bin.stringToBytes(message);
	      else
	        message = utf8.stringToBytes(message);
	    else if (isBuffer(message))
	      message = Array.prototype.slice.call(message, 0);
	    else if (!Array.isArray(message))
	      message = message.toString();
	    // else, assume byte array already
	
	    var m = crypt.bytesToWords(message),
	        l = message.length * 8,
	        a =  1732584193,
	        b = -271733879,
	        c = -1732584194,
	        d =  271733878;
	
	    // Swap endian
	    for (var i = 0; i < m.length; i++) {
	      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |
	             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;
	    }
	
	    // Padding
	    m[l >>> 5] |= 0x80 << (l % 32);
	    m[(((l + 64) >>> 9) << 4) + 14] = l;
	
	    // Method shortcuts
	    var FF = md5._ff,
	        GG = md5._gg,
	        HH = md5._hh,
	        II = md5._ii;
	
	    for (var i = 0; i < m.length; i += 16) {
	
	      var aa = a,
	          bb = b,
	          cc = c,
	          dd = d;
	
	      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);
	      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);
	      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);
	      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);
	      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);
	      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);
	      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);
	      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);
	      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);
	      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);
	      c = FF(c, d, a, b, m[i+10], 17, -42063);
	      b = FF(b, c, d, a, m[i+11], 22, -1990404162);
	      a = FF(a, b, c, d, m[i+12],  7,  1804603682);
	      d = FF(d, a, b, c, m[i+13], 12, -40341101);
	      c = FF(c, d, a, b, m[i+14], 17, -1502002290);
	      b = FF(b, c, d, a, m[i+15], 22,  1236535329);
	
	      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);
	      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);
	      c = GG(c, d, a, b, m[i+11], 14,  643717713);
	      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);
	      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);
	      d = GG(d, a, b, c, m[i+10],  9,  38016083);
	      c = GG(c, d, a, b, m[i+15], 14, -660478335);
	      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);
	      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);
	      d = GG(d, a, b, c, m[i+14],  9, -1019803690);
	      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);
	      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);
	      a = GG(a, b, c, d, m[i+13],  5, -1444681467);
	      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);
	      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);
	      b = GG(b, c, d, a, m[i+12], 20, -1926607734);
	
	      a = HH(a, b, c, d, m[i+ 5],  4, -378558);
	      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);
	      c = HH(c, d, a, b, m[i+11], 16,  1839030562);
	      b = HH(b, c, d, a, m[i+14], 23, -35309556);
	      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);
	      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);
	      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);
	      b = HH(b, c, d, a, m[i+10], 23, -1094730640);
	      a = HH(a, b, c, d, m[i+13],  4,  681279174);
	      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);
	      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);
	      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);
	      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);
	      d = HH(d, a, b, c, m[i+12], 11, -421815835);
	      c = HH(c, d, a, b, m[i+15], 16,  530742520);
	      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);
	
	      a = II(a, b, c, d, m[i+ 0],  6, -198630844);
	      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);
	      c = II(c, d, a, b, m[i+14], 15, -1416354905);
	      b = II(b, c, d, a, m[i+ 5], 21, -57434055);
	      a = II(a, b, c, d, m[i+12],  6,  1700485571);
	      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);
	      c = II(c, d, a, b, m[i+10], 15, -1051523);
	      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);
	      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);
	      d = II(d, a, b, c, m[i+15], 10, -30611744);
	      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);
	      b = II(b, c, d, a, m[i+13], 21,  1309151649);
	      a = II(a, b, c, d, m[i+ 4],  6, -145523070);
	      d = II(d, a, b, c, m[i+11], 10, -1120210379);
	      c = II(c, d, a, b, m[i+ 2], 15,  718787259);
	      b = II(b, c, d, a, m[i+ 9], 21, -343485551);
	
	      a = (a + aa) >>> 0;
	      b = (b + bb) >>> 0;
	      c = (c + cc) >>> 0;
	      d = (d + dd) >>> 0;
	    }
	
	    return crypt.endian([a, b, c, d]);
	  };
	
	  // Auxiliary functions
	  md5._ff  = function (a, b, c, d, x, s, t) {
	    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
	    return ((n << s) | (n >>> (32 - s))) + b;
	  };
	  md5._gg  = function (a, b, c, d, x, s, t) {
	    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
	    return ((n << s) | (n >>> (32 - s))) + b;
	  };
	  md5._hh  = function (a, b, c, d, x, s, t) {
	    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
	    return ((n << s) | (n >>> (32 - s))) + b;
	  };
	  md5._ii  = function (a, b, c, d, x, s, t) {
	    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
	    return ((n << s) | (n >>> (32 - s))) + b;
	  };
	
	  // Package private blocksize
	  md5._blocksize = 16;
	  md5._digestsize = 16;
	
	  module.exports = function (message, options) {
	    if (message === undefined || message === null)
	      throw new Error('Illegal argument ' + message);
	
	    var digestbytes = crypt.wordsToBytes(md5(message, options));
	    return options && options.asBytes ? digestbytes :
	        options && options.asString ? bin.bytesToString(digestbytes) :
	        crypt.bytesToHex(digestbytes);
	  };
	
	})();


/***/ },
/* 319 */
/***/ function(module, exports) {

	(function() {
	  var base64map
	      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
	
	  crypt = {
	    // Bit-wise rotation left
	    rotl: function(n, b) {
	      return (n << b) | (n >>> (32 - b));
	    },
	
	    // Bit-wise rotation right
	    rotr: function(n, b) {
	      return (n << (32 - b)) | (n >>> b);
	    },
	
	    // Swap big-endian to little-endian and vice versa
	    endian: function(n) {
	      // If number given, swap endian
	      if (n.constructor == Number) {
	        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
	      }
	
	      // Else, assume array and swap all items
	      for (var i = 0; i < n.length; i++)
	        n[i] = crypt.endian(n[i]);
	      return n;
	    },
	
	    // Generate an array of any length of random bytes
	    randomBytes: function(n) {
	      for (var bytes = []; n > 0; n--)
	        bytes.push(Math.floor(Math.random() * 256));
	      return bytes;
	    },
	
	    // Convert a byte array to big-endian 32-bit words
	    bytesToWords: function(bytes) {
	      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
	        words[b >>> 5] |= bytes[i] << (24 - b % 32);
	      return words;
	    },
	
	    // Convert big-endian 32-bit words to a byte array
	    wordsToBytes: function(words) {
	      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
	        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
	      return bytes;
	    },
	
	    // Convert a byte array to a hex string
	    bytesToHex: function(bytes) {
	      for (var hex = [], i = 0; i < bytes.length; i++) {
	        hex.push((bytes[i] >>> 4).toString(16));
	        hex.push((bytes[i] & 0xF).toString(16));
	      }
	      return hex.join('');
	    },
	
	    // Convert a hex string to a byte array
	    hexToBytes: function(hex) {
	      for (var bytes = [], c = 0; c < hex.length; c += 2)
	        bytes.push(parseInt(hex.substr(c, 2), 16));
	      return bytes;
	    },
	
	    // Convert a byte array to a base-64 string
	    bytesToBase64: function(bytes) {
	      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
	        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
	        for (var j = 0; j < 4; j++)
	          if (i * 8 + j * 6 <= bytes.length * 8)
	            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
	          else
	            base64.push('=');
	      }
	      return base64.join('');
	    },
	
	    // Convert a base-64 string to a byte array
	    base64ToBytes: function(base64) {
	      // Remove non-base-64 characters
	      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');
	
	      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
	          imod4 = ++i % 4) {
	        if (imod4 == 0) continue;
	        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
	            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
	            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
	      }
	      return bytes;
	    }
	  };
	
	  module.exports = crypt;
	})();


/***/ },
/* 320 */
/***/ function(module, exports) {

	var charenc = {
	  // UTF-8 encoding
	  utf8: {
	    // Convert a string to a byte array
	    stringToBytes: function(str) {
	      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
	    },
	
	    // Convert a byte array to a string
	    bytesToString: function(bytes) {
	      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
	    }
	  },
	
	  // Binary encoding
	  bin: {
	    // Convert a string to a byte array
	    stringToBytes: function(str) {
	      for (var bytes = [], i = 0; i < str.length; i++)
	        bytes.push(str.charCodeAt(i) & 0xFF);
	      return bytes;
	    },
	
	    // Convert a byte array to a string
	    bytesToString: function(bytes) {
	      for (var str = [], i = 0; i < bytes.length; i++)
	        str.push(String.fromCharCode(bytes[i]));
	      return str.join('');
	    }
	  }
	};
	
	module.exports = charenc;


/***/ },
/* 321 */
/***/ function(module, exports) {

	/*!
	 * Determine if an object is a Buffer
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	
	// The _isBuffer check is for Safari 5-7 support, because it's missing
	// Object.prototype.constructor. Remove this eventually
	module.exports = function (obj) {
	  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
	}
	
	function isBuffer (obj) {
	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	}
	
	// For Node v0.10 support. Remove this eventually.
	function isSlowBuffer (obj) {
	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
	}


/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	var constants = __webpack_require__(290);
	
	var _require = __webpack_require__(248),
	    PROMISE = _require.PROMISE;
	
	var _require2 = __webpack_require__(303),
	    getExpressions = _require2.getExpressions,
	    getSelectedFrame = _require2.getSelectedFrame;
	
	function expressionExists(expressions, expression) {
	  return !!expressions.find(e => e.input == expression.input);
	}
	
	/**
	 * Add expression for debugger to watch
	 *
	 * @param {object} expression
	 * @param {number} expression.id
	 * @memberof actions/pause
	 * @static
	 */
	function addExpression(expression) {
	  return (_ref) => {
	    var dispatch = _ref.dispatch,
	        getState = _ref.getState;
	
	    var expressions = getExpressions(getState()).toSeq();
	    if (!expression.input || expressionExists(expressions, expression)) {
	      return;
	    }
	
	    var id = parseInt(expression.id, 10) || expressions.size++;
	
	    dispatch({
	      type: constants.ADD_EXPRESSION,
	      id: id,
	      input: expression.input
	    });
	
	    var selectedFrame = getSelectedFrame(getState());
	    var selectedFrameId = selectedFrame ? selectedFrame.id : null;
	    dispatch(evaluateExpressions(selectedFrameId));
	  };
	}
	
	/**
	 *
	 * @param {object} expression
	 * @param {number} expression.id
	 * @memberof actions/pause
	 * @static
	 */
	function updateExpression(expression) {
	  return (_ref2) => {
	    var dispatch = _ref2.dispatch;
	
	    dispatch({
	      type: constants.UPDATE_EXPRESSION,
	      id: expression.id,
	      input: expression.input
	    });
	  };
	}
	
	/**
	 *
	 * @param {object} expression
	 * @param {number} expression.id
	 * @memberof actions/pause
	 * @static
	 */
	function deleteExpression(expression) {
	  return (_ref3) => {
	    var dispatch = _ref3.dispatch;
	
	    dispatch({
	      type: constants.DELETE_EXPRESSION,
	      id: expression.id
	    });
	  };
	}
	
	/**
	 *
	 * @memberof actions/pause
	 * @param {number} selectedFrameId
	 * @static
	 */
	function evaluateExpressions(frameId) {
	  return (() => {
	    var _ref4 = _asyncToGenerator(function* (_ref5) {
	      var dispatch = _ref5.dispatch,
	          getState = _ref5.getState,
	          client = _ref5.client;
	
	      for (var expression of getExpressions(getState())) {
	        if (!expression.input) {
	          console.warn("Expressions should not be empty");
	          continue;
	        }
	
	        yield dispatch({
	          type: constants.EVALUATE_EXPRESSION,
	          id: expression.id,
	          input: expression.input,
	          [PROMISE]: client.evaluate(expression.input, { frameId })
	        });
	      }
	    });
	
	    return function (_x) {
	      return _ref4.apply(this, arguments);
	    };
	  })();
	}
	
	module.exports = {
	  addExpression,
	  updateExpression,
	  deleteExpression,
	  evaluateExpressions
	};

/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	
	
	/**
	 * @memberof utils/utils
	 * @static
	 */
	var asPaused = (() => {
	  var _ref = _asyncToGenerator(function* (state, client, func) {
	    if (!getPause(state)) {
	      yield client.interrupt();
	      var result = void 0;
	
	      try {
	        result = yield func(client);
	      } catch (e) {
	        // Try to put the debugger back in a working state by resuming
	        // it
	        yield client.resume();
	        throw e;
	      }
	
	      yield client.resume();
	      return result;
	    }
	
	    return func(client);
	  });
	
	  return function asPaused(_x, _x2, _x3) {
	    return _ref.apply(this, arguments);
	  };
	})();
	
	/**
	 * @memberof actions/event-listeners
	 * @static
	 */
	
	
	var _getEventListeners = (() => {
	  var _ref3 = _asyncToGenerator(function* (threadClient) {
	    var response = yield threadClient.eventListeners();
	
	    // Make sure all the listeners are sorted by the event type, since
	    // they"re not guaranteed to be clustered together.
	    response.listeners.sort(function (a, b) {
	      return a.type > b.type ? 1 : -1;
	    });
	
	    // Add all the listeners in the debugger view event linsteners container.
	    var fetchedDefinitions = new Map();
	    var listeners = [];
	    for (var listener of response.listeners) {
	      var definitionSite = void 0;
	      if (fetchedDefinitions.has(listener.function.actor)) {
	        definitionSite = fetchedDefinitions.get(listener.function.actor);
	      } else if (listener.function.class == "Function") {
	        definitionSite = yield _getDefinitionSite(threadClient, listener.function);
	        if (!definitionSite) {
	          // We don"t know where this listener comes from so don"t show it in
	          // the UI as breaking on it doesn"t work (bug 942899).
	          continue;
	        }
	
	        fetchedDefinitions.set(listener.function.actor, definitionSite);
	      }
	      listener.function.url = definitionSite;
	      listeners.push(listener);
	    }
	    fetchedDefinitions.clear();
	
	    return listeners;
	  });
	
	  return function _getEventListeners(_x4) {
	    return _ref3.apply(this, arguments);
	  };
	})();
	
	var _getDefinitionSite = (() => {
	  var _ref4 = _asyncToGenerator(function* (threadClient, func) {
	    var grip = threadClient.pauseGrip(func);
	    var response = void 0;
	
	    try {
	      response = yield grip.getDefinitionSite();
	    } catch (e) {
	      // Don't make this error fatal, it would break the entire events pane.
	      reportException("_getDefinitionSite", e);
	      return null;
	    }
	
	    return response.source.url;
	  });
	
	  return function _getDefinitionSite(_x5, _x6) {
	    return _ref4.apply(this, arguments);
	  };
	})();
	
	/**
	 * @memberof actions/event-listeners
	 * @static
	 * @param {string} eventNames
	 */
	
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	/* global window gThreadClient setNamedTimeout services EVENTS */
	/* eslint no-shadow: 0  */
	
	/**
	 * Redux actions for the event listeners state
	 * @module actions/event-listeners
	 */
	
	var constants = __webpack_require__(290);
	
	var _require = __webpack_require__(251),
	    reportException = _require.reportException;
	
	var _require2 = __webpack_require__(303),
	    getPause = _require2.getPause,
	    getSourceByURL = _require2.getSourceByURL;
	
	// delay is in ms
	
	
	var FETCH_EVENT_LISTENERS_DELAY = 200;
	var fetchListenersTimerID = void 0;function fetchEventListeners() {
	  return (_ref2) => {
	    var dispatch = _ref2.dispatch,
	        getState = _ref2.getState,
	        client = _ref2.client;
	
	    // Make sure we"re not sending a batch of closely repeated requests.
	    // This can easily happen whenever new sources are fetched.
	    if (fetchListenersTimerID) {
	      clearTimeout(fetchListenersTimerID);
	    }
	
	    fetchListenersTimerID = setTimeout(() => {
	      // In case there is still a request of listeners going on (it
	      // takes several RDP round trips right now), make sure we wait
	      // on a currently running request
	      if (getState().eventListeners.fetchingListeners) {
	        dispatch({
	          type: services.WAIT_UNTIL,
	          predicate: action => action.type === constants.FETCH_EVENT_LISTENERS && action.status === "done",
	          run: dispatch => dispatch(fetchEventListeners())
	        });
	        return;
	      }
	
	      dispatch({
	        type: constants.FETCH_EVENT_LISTENERS,
	        status: "begin"
	      });
	
	      asPaused(getState(), client, _getEventListeners).then(listeners => {
	        dispatch({
	          type: constants.FETCH_EVENT_LISTENERS,
	          status: "done",
	          listeners: formatListeners(getState(), listeners)
	        });
	      });
	    }, FETCH_EVENT_LISTENERS_DELAY);
	  };
	}
	
	function formatListeners(state, listeners) {
	  return listeners.map(l => {
	    return {
	      selector: l.node.selector,
	      type: l.type,
	      sourceId: getSourceByURL(state, l.function.location.url).get("id"),
	      line: l.function.location.line
	    };
	  });
	}
	
	function updateEventBreakpoints(eventNames) {
	  return dispatch => {
	    setNamedTimeout("event-breakpoints-update", 0, () => {
	      gThreadClient.pauseOnDOMEvents(eventNames, function () {
	        // Notify that event breakpoints were added/removed on the server.
	        window.emit(EVENTS.EVENT_BREAKPOINTS_UPDATED);
	
	        dispatch({
	          type: constants.UPDATE_EVENT_BREAKPOINTS,
	          eventNames: eventNames
	        });
	      });
	    });
	  };
	}
	
	module.exports = { updateEventBreakpoints, fetchEventListeners };

/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	/**
	 * Redux actions for the sources state
	 * @module actions/sources
	 */
	
	var defer = __webpack_require__(249);
	
	var _require = __webpack_require__(248),
	    PROMISE = _require.PROMISE;
	
	var assert = __webpack_require__(252);
	
	var _require2 = __webpack_require__(325),
	    updateFrameLocations = _require2.updateFrameLocations;
	
	var _require3 = __webpack_require__(316),
	    getOriginalURLs = _require3.getOriginalURLs,
	    getOriginalSourceText = _require3.getOriginalSourceText,
	    generatedToOriginalId = _require3.generatedToOriginalId,
	    isOriginalId = _require3.isOriginalId,
	    getOriginalLocation = _require3.getOriginalLocation,
	    getGeneratedLocation = _require3.getGeneratedLocation,
	    isGeneratedId = _require3.isGeneratedId,
	    applySourceMap = _require3.applySourceMap,
	    shouldSourceMap = _require3.shouldSourceMap;
	
	var _require4 = __webpack_require__(383),
	    prettyPrint = _require4.prettyPrint;
	
	var _require5 = __webpack_require__(295),
	    getPrettySourceURL = _require5.getPrettySourceURL;
	
	var constants = __webpack_require__(290);
	
	var _require6 = __webpack_require__(384),
	    removeDocument = _require6.removeDocument;
	
	var _require7 = __webpack_require__(303),
	    getSource = _require7.getSource,
	    getSourceByURL = _require7.getSourceByURL,
	    getSourceText = _require7.getSourceText,
	    getPendingSelectedLocation = _require7.getPendingSelectedLocation,
	    getFrames = _require7.getFrames;
	
	/**
	 * Handler for the debugger client's unsolicited newSource notification.
	 * @memberof actions/sources
	 * @static
	 */
	function newSource(source) {
	  return (_ref) => {
	    var dispatch = _ref.dispatch,
	        getState = _ref.getState;
	
	    if (shouldSourceMap()) {
	      dispatch(loadSourceMap(source));
	    }
	
	    dispatch({
	      type: constants.ADD_SOURCE,
	      source
	    });
	
	    // If a request has been made to show this source, go ahead and
	    // select it.
	    var pendingLocation = getPendingSelectedLocation(getState());
	    if (pendingLocation && pendingLocation.url === source.url) {
	      dispatch(selectSource(source.id, { line: pendingLocation.line }));
	    }
	  };
	}
	
	function newSources(sources) {
	  return (_ref2) => {
	    var dispatch = _ref2.dispatch,
	        getState = _ref2.getState;
	
	    sources.filter(source => !getSource(getState(), source.id)).forEach(source => dispatch(newSource(source)));
	  };
	}
	
	/**
	 * @memberof actions/sources
	 * @static
	 */
	function loadSourceMap(generatedSource) {
	  return (() => {
	    var _ref3 = _asyncToGenerator(function* (_ref4) {
	      var dispatch = _ref4.dispatch,
	          getState = _ref4.getState;
	
	      var urls = yield getOriginalURLs(generatedSource);
	      if (!urls) {
	        // If this source doesn't have a sourcemap, do nothing.
	        return;
	      }
	
	      var originalSources = urls.map(function (originalUrl) {
	        return {
	          url: originalUrl,
	          id: generatedToOriginalId(generatedSource.id, originalUrl),
	          isPrettyPrinted: false
	        };
	      });
	
	      originalSources.forEach(function (s) {
	        return dispatch(newSource(s));
	      });
	    });
	
	    return function (_x) {
	      return _ref3.apply(this, arguments);
	    };
	  })();
	}
	
	/**
	 * Deterministically select a source that has a given URL. This will
	 * work regardless of the connection status or if the source exists
	 * yet. This exists mostly for external things to interact with the
	 * debugger.
	 *
	 * @memberof actions/sources
	 * @static
	 */
	function selectSourceURL(url) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	  return (_ref5) => {
	    var dispatch = _ref5.dispatch,
	        getState = _ref5.getState;
	
	    var source = getSourceByURL(getState(), url);
	    if (source) {
	      dispatch(selectSource(source.get("id"), options));
	    } else {
	      dispatch({
	        type: constants.SELECT_SOURCE_URL,
	        url: url,
	        tabIndex: options.tabIndex,
	        line: options.line
	      });
	    }
	  };
	}
	
	/**
	 * @memberof actions/sources
	 * @static
	 */
	function selectSource(id) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	  return (_ref6) => {
	    var dispatch = _ref6.dispatch,
	        getState = _ref6.getState,
	        client = _ref6.client;
	
	    if (!client) {
	      // No connection, do nothing. This happens when the debugger is
	      // shut down too fast and it tries to display a default source.
	      return;
	    }
	
	    var source = getSource(getState(), id).toJS();
	
	    // Make sure to start a request to load the source text.
	    dispatch(loadSourceText(source));
	
	    dispatch({ type: constants.TOGGLE_FILE_SEARCH, searchOn: false });
	
	    dispatch({
	      type: constants.SELECT_SOURCE,
	      source: source,
	      tabIndex: options.tabIndex,
	      line: options.line
	    });
	  };
	}
	
	/**
	 * @memberof actions/sources
	 * @static
	 */
	function jumpToMappedLocation(sourceLocation) {
	  return (() => {
	    var _ref7 = _asyncToGenerator(function* (_ref8) {
	      var dispatch = _ref8.dispatch,
	          getState = _ref8.getState,
	          client = _ref8.client;
	
	      if (!client) {
	        return;
	      }
	
	      var source = getSource(getState(), sourceLocation.sourceId);
	      var pairedLocation = isOriginalId(sourceLocation.sourceId) ? yield getGeneratedLocation(sourceLocation, source.toJS()) : yield getOriginalLocation(sourceLocation, source.toJS());
	
	      return dispatch(selectSource(pairedLocation.sourceId, { line: pairedLocation.line }));
	    });
	
	    return function (_x4) {
	      return _ref7.apply(this, arguments);
	    };
	  })();
	}
	
	/**
	 * @memberof actions/sources
	 * @static
	 */
	function closeTab(url) {
	  removeDocument(url);
	  return {
	    type: constants.CLOSE_TAB,
	    url
	  };
	}
	
	/**
	 * @memberof actions/sources
	 * @static
	 */
	function closeTabs(urls) {
	  return (_ref9) => {
	    var dispatch = _ref9.dispatch,
	        getState = _ref9.getState,
	        client = _ref9.client;
	
	    urls.forEach(url => {
	      var source = getSourceByURL(getState(), url);
	      if (source) {
	        removeDocument(source.get("id"));
	      }
	    });
	
	    dispatch({
	      type: constants.CLOSE_TABS,
	      urls
	    });
	  };
	}
	
	/**
	 * Toggle the pretty printing of a source's text. All subsequent calls to
	 * |getText| will return the pretty-toggled text. Nothing will happen for
	 * non-javascript files.
	 *
	 * @memberof actions/sources
	 * @static
	 * @param string id The source form from the RDP.
	 * @returns Promise
	 *          A promise that resolves to [aSource, prettyText] or rejects to
	 *          [aSource, error].
	 */
	function togglePrettyPrint(sourceId) {
	  return (_ref10) => {
	    var dispatch = _ref10.dispatch,
	        getState = _ref10.getState,
	        client = _ref10.client;
	
	    var source = getSource(getState(), sourceId).toJS();
	    var sourceText = getSourceText(getState(), sourceId).toJS();
	
	    if (sourceText.loading) {
	      return {};
	    }
	
	    assert(isGeneratedId(sourceId), "Pretty-printing only allowed on generated sources");
	
	    var url = getPrettySourceURL(source.url);
	    var id = generatedToOriginalId(source.id, url);
	    var originalSource = { url, id, isPrettyPrinted: false };
	    dispatch({
	      type: constants.ADD_SOURCE,
	      source: originalSource
	    });
	
	    return dispatch({
	      type: constants.TOGGLE_PRETTY_PRINT,
	      source: originalSource,
	      [PROMISE]: _asyncToGenerator(function* () {
	        var _ref12 = yield prettyPrint({
	          source, sourceText, url
	        }),
	            code = _ref12.code,
	            mappings = _ref12.mappings;
	
	        yield applySourceMap(source.id, url, code, mappings);
	
	        var frames = yield updateFrameLocations(getFrames(getState()));
	        dispatch(selectSource(originalSource.id));
	
	        return {
	          text: code,
	          contentType: "text/javascript",
	          frames
	        };
	      })()
	    });
	  };
	}
	
	/**
	 * @memberof actions/sources
	 * @static
	 */
	function loadSourceText(source) {
	  return (_ref13) => {
	    var dispatch = _ref13.dispatch,
	        getState = _ref13.getState,
	        client = _ref13.client;
	
	    // Fetch the source text only once.
	    var textInfo = getSourceText(getState(), source.id);
	    if (textInfo) {
	      // It's already loaded or is loading
	      return Promise.resolve(textInfo);
	    }
	
	    return dispatch({
	      type: constants.LOAD_SOURCE_TEXT,
	      source: source,
	      [PROMISE]: _asyncToGenerator(function* () {
	        if (isOriginalId(source.id)) {
	          return yield getOriginalSourceText(source);
	        }
	
	        var response = yield client.sourceContents(source.id);
	        return {
	          text: response.source,
	          contentType: response.contentType || "text/javascript"
	        };
	
	        // Automatically pretty print if enabled and the test is
	        // detected to be "minified"
	        // if (Prefs.autoPrettyPrint &&
	        //     !source.isPrettyPrinted &&
	        //     SourceUtils.isMinified(source.id, response.source)) {
	        //   dispatch(togglePrettyPrint(source));
	        // }
	      })()
	    });
	  };
	}
	
	// delay is in ms
	var FETCH_SOURCE_RESPONSE_DELAY = 200;
	
	/**
	 * Starts fetching all the sources, silently.
	 *
	 * @memberof actions/sources
	 * @static
	 * @param array actors
	 *        The urls for the sources to fetch. If fetching a source's text
	 *        takes too long, it will be discarded.
	 * @returns {Promise}
	 *         A promise that is resolved after source texts have been fetched.
	 */
	function getTextForSources(actors) {
	  return (_ref15) => {
	    var dispatch = _ref15.dispatch,
	        getState = _ref15.getState;
	
	    var deferred = defer();
	    var pending = new Set(actors);
	
	    var fetched = [];
	
	    // Can't use promise.all, because if one fetch operation is rejected, then
	    // everything is considered rejected, thus no other subsequent source will
	    // be getting fetched. We don't want that. Something like Q's allSettled
	    // would work like a charm here.
	
	    // Try to fetch as many sources as possible.
	
	    var _loop = function (actor) {
	      var source = getSource(getState(), actor);
	      dispatch(loadSourceText(source)).then((_ref24) => {
	        var text = _ref24.text,
	            contentType = _ref24.contentType;
	
	        onFetch([source, text, contentType]);
	      }, err => {
	        onError(source, err);
	      });
	    };
	
	    for (var actor of actors) {
	      _loop(actor);
	    }
	
	    setTimeout(onTimeout, FETCH_SOURCE_RESPONSE_DELAY);
	
	    /* Called if fetching a source takes too long. */
	    function onTimeout() {
	      pending = new Set();
	      maybeFinish();
	    }
	
	    /* Called if fetching a source finishes successfully. */
	    function onFetch(_ref16) {
	      var _ref17 = _slicedToArray(_ref16, 3),
	          aSource = _ref17[0],
	          aText = _ref17[1],
	          aContentType = _ref17[2];
	
	      // If fetching the source has previously timed out, discard it this time.
	      if (!pending.has(aSource.actor)) {
	        return;
	      }
	      pending.delete(aSource.actor);
	      fetched.push([aSource.actor, aText, aContentType]);
	      maybeFinish();
	    }
	
	    /* Called if fetching a source failed because of an error. */
	    function onError(_ref18) {
	      var _ref19 = _slicedToArray(_ref18, 2),
	          aSource = _ref19[0],
	          aError = _ref19[1];
	
	      pending.delete(aSource.actor);
	      maybeFinish();
	    }
	
	    /* Called every time something interesting
	     *  happens while fetching sources.
	     */
	    function maybeFinish() {
	      if (pending.size == 0) {
	        // Sort the fetched sources alphabetically by their url.
	        if (deferred) {
	          deferred.resolve(fetched.sort((_ref20, _ref21) => {
	            var _ref23 = _slicedToArray(_ref20, 1),
	                aFirst = _ref23[0];
	
	            var _ref22 = _slicedToArray(_ref21, 1),
	                aSecond = _ref22[0];
	
	            return aFirst > aSecond ? -1 : 1;
	          }));
	        }
	      }
	    }
	
	    return deferred.promise;
	  };
	}
	
	module.exports = {
	  newSource,
	  newSources,
	  selectSource,
	  selectSourceURL,
	  jumpToMappedLocation,
	  closeTab,
	  closeTabs,
	  togglePrettyPrint,
	  loadSourceText,
	  getTextForSources
	};

/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	var _require = __webpack_require__(326),
	    Frame = _require.Frame;
	
	var _require2 = __webpack_require__(316),
	    getOriginalLocation = _require2.getOriginalLocation;
	
	function updateFrameLocations(frames) {
	  if (!frames) {
	    return Promise.resolve(frames);
	  }
	  return Promise.all(frames.map(frame => {
	    return getOriginalLocation(frame.location).then(loc => {
	      return Frame.update(frame, {
	        $merge: { location: loc }
	      });
	    });
	  }));
	}
	
	// Map protocol pause "why" reason to a valid L10N key
	// These are the known unhandled reasons:
	// "breakpointConditionThrown", "clientEvaluated"
	// "interrupted", "attached"
	var reasons = {
	  "debuggerStatement": "whyPaused.debuggerStatement",
	  "breakpoint": "whyPaused.breakpoint",
	  "exception": "whyPaused.exception",
	  "resumeLimit": "whyPaused.resumeLimit",
	  "pauseOnDOMEvents": "whyPaused.pauseOnDOMEvents",
	  "breakpointConditionThrown": "whyPaused.breakpointConditionThrown",
	
	  // V8
	  "DOM": "whyPaused.breakpoint",
	  "EventListener": "whyPaused.pauseOnDOMEvents",
	  "XHR": "whyPaused.xhr",
	  "promiseRejection": "whyPaused.promiseRejection",
	  "assert": "whyPaused.assert",
	  "debugCommand": "whyPaused.debugCommand",
	  "other": "whyPaused.other"
	};
	
	function getPauseReason(pauseInfo) {
	  if (!pauseInfo) {
	    return null;
	  }
	
	  var reasonType = pauseInfo.getIn(["why"]).get("type");
	  if (!reasons[reasonType]) {
	    console.log("Please file an issue: reasonType=", reasonType);
	  }
	  return reasons[reasonType];
	}
	
	module.exports = {
	  updateFrameLocations,
	  getPauseReason
	};

/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	var t = __webpack_require__(327);
	
	var Location = t.struct({
	  sourceId: t.String,
	  line: t.Number,
	  column: t.union([t.Number, t.Nil])
	}, "Location");
	
	var Frame = t.struct({
	  id: t.String,
	  displayName: t.String,
	  location: Location,
	  this: t.union([t.Object, t.Nil]),
	  scope: t.union([t.Object, t.Nil]),
	  scopeChain: t.union([t.Array, t.Nil])
	}, "Frame");
	
	module.exports = {
	  Frame
	};

/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	/*! @preserve
	 *
	 * tcomb.js - Type checking and DDD for JavaScript
	 *
	 * The MIT License (MIT)
	 *
	 * Copyright (c) 2014-2016 Giulio Canti
	 *
	 */
	
	// core
	var t = __webpack_require__(328);
	
	// types
	t.Any = __webpack_require__(334);
	t.Array = __webpack_require__(342);
	t.Boolean = __webpack_require__(343);
	t.Date = __webpack_require__(345);
	t.Error = __webpack_require__(346);
	t.Function = __webpack_require__(347);
	t.Nil = __webpack_require__(348);
	t.Number = __webpack_require__(349);
	t.Integer = __webpack_require__(351);
	t.IntegerT = t.Integer;
	t.Object = __webpack_require__(357);
	t.RegExp = __webpack_require__(358);
	t.String = __webpack_require__(359);
	t.Type = __webpack_require__(360);
	t.TypeT = t.Type;
	
	// short alias are deprecated
	t.Arr = t.Array;
	t.Bool = t.Boolean;
	t.Dat = t.Date;
	t.Err = t.Error;
	t.Func = t.Function;
	t.Num = t.Number;
	t.Obj = t.Object;
	t.Re = t.RegExp;
	t.Str = t.String;
	
	// combinators
	t.dict = __webpack_require__(361);
	t.declare = __webpack_require__(362);
	t.enums = __webpack_require__(365);
	t.irreducible = __webpack_require__(335);
	t.list = __webpack_require__(366);
	t.maybe = __webpack_require__(367);
	t.refinement = __webpack_require__(352);
	t.struct = __webpack_require__(369);
	t.tuple = __webpack_require__(375);
	t.union = __webpack_require__(376);
	t.func = __webpack_require__(377);
	t.intersection = __webpack_require__(378);
	t.subtype = t.refinement;
	t.inter = __webpack_require__(379); // IE8 alias
	t['interface'] = t.inter;
	
	// functions
	t.assert = t;
	t.update = __webpack_require__(381);
	t.mixin = __webpack_require__(363);
	t.isType = __webpack_require__(339);
	t.is = __webpack_require__(356);
	t.getTypeName = __webpack_require__(338);
	t.match = __webpack_require__(382);
	
	module.exports = t;


/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(329);
	var isNil = __webpack_require__(330);
	var fail = __webpack_require__(331);
	var stringify = __webpack_require__(332);
	
	function assert(guard, message) {
	  if (guard !== true) {
	    if (isFunction(message)) { // handle lazy messages
	      message = message();
	    }
	    else if (isNil(message)) { // use a default message
	      message = 'Assert failed (turn on "Pause on exceptions" in your Source panel)';
	    }
	    assert.fail(message);
	  }
	}
	
	assert.fail = fail;
	assert.stringify = stringify;
	
	module.exports = assert;

/***/ },
/* 329 */
/***/ function(module, exports) {

	module.exports = function isFunction(x) {
	  return typeof x === 'function';
	};

/***/ },
/* 330 */
/***/ function(module, exports) {

	module.exports = function isNil(x) {
	  return x === null || x === void 0;
	};

/***/ },
/* 331 */
/***/ function(module, exports) {

	module.exports = function fail(message) {
	  throw new TypeError('[tcomb] ' + message);
	};

/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	var getFunctionName = __webpack_require__(333);
	
	function replacer(key, value) {
	  if (typeof value === 'function') {
	    return getFunctionName(value);
	  }
	  return value;
	}
	
	module.exports = function stringify(x) {
	  try { // handle "Converting circular structure to JSON" error
	    return JSON.stringify(x, replacer, 2);
	  }
	  catch (e) {
	    return String(x);
	  }
	};

/***/ },
/* 333 */
/***/ function(module, exports) {

	module.exports = function getFunctionName(f) {
	  return f.displayName || f.name || '<function' + f.length + '>';
	};

/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	var irreducible = __webpack_require__(335);
	
	module.exports = irreducible('Any', function () { return true; });


/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(328);
	var isString = __webpack_require__(336);
	var isFunction = __webpack_require__(329);
	var forbidNewOperator = __webpack_require__(337);
	
	module.exports = function irreducible(name, predicate) {
	
	  if (false) {
	    assert(isString(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to irreducible(name, predicate) (expected a string)'; });
	    assert(isFunction(predicate), 'Invalid argument predicate ' + assert.stringify(predicate) + ' supplied to irreducible(name, predicate) (expected a function)');
	  }
	
	  function Irreducible(value, path) {
	
	    if (false) {
	      forbidNewOperator(this, Irreducible);
	      path = path || [name];
	      assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
	    }
	
	    return value;
	  }
	
	  Irreducible.meta = {
	    kind: 'irreducible',
	    name: name,
	    predicate: predicate,
	    identity: true
	  };
	
	  Irreducible.displayName = name;
	
	  Irreducible.is = predicate;
	
	  return Irreducible;
	};


/***/ },
/* 336 */
/***/ function(module, exports) {

	module.exports = function isString(x) {
	  return typeof x === 'string';
	};

/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(328);
	var getTypeName = __webpack_require__(338);
	
	module.exports = function forbidNewOperator(x, type) {
	  assert(!(x instanceof type), function () { return 'Cannot use the new operator to instantiate the type ' + getTypeName(type); });
	};

/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	var isType = __webpack_require__(339);
	var getFunctionName = __webpack_require__(333);
	
	module.exports = function getTypeName(ctor) {
	  if (isType(ctor)) {
	    return ctor.displayName;
	  }
	  return getFunctionName(ctor);
	};

/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(329);
	var isObject = __webpack_require__(340);
	
	module.exports = function isType(x) {
	  return isFunction(x) && isObject(x.meta);
	};

/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	var isNil = __webpack_require__(330);
	var isArray = __webpack_require__(341);
	
	module.exports = function isObject(x) {
	  return !isNil(x) && typeof x === 'object' && !isArray(x);
	};

/***/ },
/* 341 */
/***/ function(module, exports) {

	module.exports = function isArray(x) {
	  return Array.isArray ? Array.isArray(x) : x instanceof Array;
	};

/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	var irreducible = __webpack_require__(335);
	var isArray = __webpack_require__(341);
	
	module.exports = irreducible('Array', isArray);


/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	var irreducible = __webpack_require__(335);
	var isBoolean = __webpack_require__(344);
	
	module.exports = irreducible('Boolean', isBoolean);


/***/ },
/* 344 */
/***/ function(module, exports) {

	module.exports = function isBoolean(x) {
	  return x === true || x === false;
	};

/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	var irreducible = __webpack_require__(335);
	
	module.exports = irreducible('Date', function (x) { return x instanceof Date; });


/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	var irreducible = __webpack_require__(335);
	
	module.exports = irreducible('Error', function (x) { return x instanceof Error; });


/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

	var irreducible = __webpack_require__(335);
	var isFunction = __webpack_require__(329);
	
	module.exports = irreducible('Function', isFunction);


/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	var irreducible = __webpack_require__(335);
	var isNil = __webpack_require__(330);
	
	module.exports = irreducible('Nil', isNil);


/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	var irreducible = __webpack_require__(335);
	var isNumber = __webpack_require__(350);
	
	module.exports = irreducible('Number', isNumber);


/***/ },
/* 350 */
/***/ function(module, exports) {

	module.exports = function isNumber(x) {
	  return typeof x === 'number' && isFinite(x) && !isNaN(x);
	};

/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	var refinement = __webpack_require__(352);
	var Number = __webpack_require__(349);
	
	module.exports = refinement(Number, function (x) { return x % 1 === 0; }, 'Integer');


/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(328);
	var isTypeName = __webpack_require__(353);
	var isFunction = __webpack_require__(329);
	var forbidNewOperator = __webpack_require__(337);
	var isIdentity = __webpack_require__(354);
	var create = __webpack_require__(355);
	var is = __webpack_require__(356);
	var getTypeName = __webpack_require__(338);
	var getFunctionName = __webpack_require__(333);
	
	function getDefaultName(type, predicate) {
	  return '{' + getTypeName(type) + ' | ' + getFunctionName(predicate) + '}';
	}
	
	function refinement(type, predicate, name) {
	
	  if (false) {
	    assert(isFunction(type), function () { return 'Invalid argument type ' + assert.stringify(type) + ' supplied to refinement(type, predicate, [name]) combinator (expected a type)'; });
	    assert(isFunction(predicate), function () { return 'Invalid argument predicate supplied to refinement(type, predicate, [name]) combinator (expected a function)'; });
	    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to refinement(type, predicate, [name]) combinator (expected a string)'; });
	  }
	
	  var displayName = name || getDefaultName(type, predicate);
	  var identity = isIdentity(type);
	
	  function Refinement(value, path) {
	
	    if (false) {
	      if (identity) {
	        forbidNewOperator(this, Refinement);
	      }
	      path = path || [displayName];
	    }
	
	    var x = create(type, value, path);
	
	    if (false) {
	      assert(predicate(x), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
	    }
	
	    return x;
	  }
	
	  Refinement.meta = {
	    kind: 'subtype',
	    type: type,
	    predicate: predicate,
	    name: name,
	    identity: identity
	  };
	
	  Refinement.displayName = displayName;
	
	  Refinement.is = function (x) {
	    return is(x, type) && predicate(x);
	  };
	
	  Refinement.update = function (instance, patch) {
	    return Refinement(assert.update(instance, patch));
	  };
	
	  return Refinement;
	}
	
	refinement.getDefaultName = getDefaultName;
	module.exports = refinement;


/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	var isNil = __webpack_require__(330);
	var isString = __webpack_require__(336);
	
	module.exports = function isTypeName(name) {
	  return isNil(name) || isString(name);
	};

/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(328);
	var Boolean = __webpack_require__(343);
	var isType = __webpack_require__(339);
	var getTypeName = __webpack_require__(338);
	
	// return true if the type constructor behaves like the identity function
	module.exports = function isIdentity(type) {
	  if (isType(type)) {
	    if (false) {
	      assert(Boolean.is(type.meta.identity), function () { return 'Invalid meta identity ' + assert.stringify(type.meta.identity) + ' supplied to type ' + getTypeName(type); });
	    }
	    return type.meta.identity;
	  }
	  // for tcomb the other constructors, like ES6 classes, are identity-like
	  return true;
	};

/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	var isType = __webpack_require__(339);
	var getFunctionName = __webpack_require__(333);
	var assert = __webpack_require__(328);
	var stringify = __webpack_require__(332);
	
	// creates an instance of a type, handling the optional new operator
	module.exports = function create(type, value, path) {
	  if (isType(type)) {
	    return !type.meta.identity && typeof value === 'object' && value !== null ? new type(value, path): type(value, path);
	  }
	
	  if (false) {
	    // here type should be a class constructor and value some instance, just check membership and return the value
	    path = path || [getFunctionName(type)];
	    assert(value instanceof type, function () { return 'Invalid value ' + stringify(value) + ' supplied to ' + path.join('/'); });
	  }
	
	  return value;
	};

/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	var isType = __webpack_require__(339);
	
	// returns true if x is an instance of type
	module.exports = function is(x, type) {
	  if (isType(type)) {
	    return type.is(x);
	  }
	  return x instanceof type; // type should be a class constructor
	};


/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	var irreducible = __webpack_require__(335);
	var isObject = __webpack_require__(340);
	
	module.exports = irreducible('Object', isObject);


/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	var irreducible = __webpack_require__(335);
	
	module.exports = irreducible('RegExp', function (x) { return x instanceof RegExp; });


/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	var irreducible = __webpack_require__(335);
	var isString = __webpack_require__(336);
	
	module.exports = irreducible('String', isString);


/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	var irreducible = __webpack_require__(335);
	var isType = __webpack_require__(339);
	
	module.exports = irreducible('Type', isType);

/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(328);
	var isTypeName = __webpack_require__(353);
	var isFunction = __webpack_require__(329);
	var getTypeName = __webpack_require__(338);
	var isIdentity = __webpack_require__(354);
	var isObject = __webpack_require__(340);
	var create = __webpack_require__(355);
	var is = __webpack_require__(356);
	
	function getDefaultName(domain, codomain) {
	  return '{[key: ' + getTypeName(domain) + ']: ' + getTypeName(codomain) + '}';
	}
	
	function dict(domain, codomain, name) {
	
	  if (false) {
	    assert(isFunction(domain), function () { return 'Invalid argument domain ' + assert.stringify(domain) + ' supplied to dict(domain, codomain, [name]) combinator (expected a type)'; });
	    assert(isFunction(codomain), function () { return 'Invalid argument codomain ' + assert.stringify(codomain) + ' supplied to dict(domain, codomain, [name]) combinator (expected a type)'; });
	    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to dict(domain, codomain, [name]) combinator (expected a string)'; });
	  }
	
	  var displayName = name || getDefaultName(domain, codomain);
	  var domainNameCache = getTypeName(domain);
	  var codomainNameCache = getTypeName(codomain);
	  var identity = isIdentity(domain) && isIdentity(codomain);
	
	  function Dict(value, path) {
	
	    if (true) {
	      if (identity) {
	        return value; // just trust the input if elements must not be hydrated
	      }
	    }
	
	    if (false) {
	      path = path || [displayName];
	      assert(isObject(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
	    }
	
	    var idempotent = true; // will remain true if I can reutilise the input
	    var ret = {}; // make a temporary copy, will be discarded if idempotent remains true
	    for (var k in value) {
	      if (value.hasOwnProperty(k)) {
	        k = create(domain, k, (  false ? path.concat(domainNameCache) : null ));
	        var actual = value[k];
	        var instance = create(codomain, actual, (  false ? path.concat(k + ': ' + codomainNameCache) : null ));
	        idempotent = idempotent && ( actual === instance );
	        ret[k] = instance;
	      }
	    }
	
	    if (idempotent) { // implements idempotency
	      ret = value;
	    }
	
	    if (false) {
	      Object.freeze(ret);
	    }
	
	    return ret;
	  }
	
	  Dict.meta = {
	    kind: 'dict',
	    domain: domain,
	    codomain: codomain,
	    name: name,
	    identity: identity
	  };
	
	  Dict.displayName = displayName;
	
	  Dict.is = function (x) {
	    if (!isObject(x)) {
	      return false;
	    }
	    for (var k in x) {
	      if (x.hasOwnProperty(k)) {
	        if (!is(k, domain) || !is(x[k], codomain)) {
	          return false;
	        }
	      }
	    }
	    return true;
	  };
	
	  Dict.update = function (instance, patch) {
	    return Dict(assert.update(instance, patch));
	  };
	
	  return Dict;
	}
	
	dict.getDefaultName = getDefaultName;
	module.exports = dict;


/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(328);
	var isTypeName = __webpack_require__(353);
	var isType = __webpack_require__(339);
	var isNil = __webpack_require__(330);
	var mixin = __webpack_require__(363);
	var getTypeName = __webpack_require__(338);
	var isUnion = __webpack_require__(364);
	
	// All the .declare-d types should be clearly different from each other thus they should have
	// different names when a name was not explicitly provided.
	var nextDeclareUniqueId = 1;
	
	module.exports = function declare(name) {
	  if (false) {
	    assert(isTypeName(name), function () { return 'Invalid argument name ' + name + ' supplied to declare([name]) (expected a string)'; });
	  }
	
	  var type;
	
	  function Declare(value, path) {
	    if (false) {
	      assert(!isNil(type), function () { return 'Type declared but not defined, don\'t forget to call .define on every declared type'; });
	      if (isUnion(type)) {
	        assert(type.dispatch === Declare.dispatch, function () { return 'Please define the custom ' + name + '.dispatch function before calling ' + name + '.define()'; });
	      }
	    }
	    return type(value, path);
	  }
	
	  Declare.define = function (spec) {
	    if (false) {
	      assert(isType(spec), function () { return 'Invalid argument type ' + assert.stringify(spec) +  ' supplied to define(type) (expected a type)'; });
	      assert(isNil(type), function () { return 'Declare.define(type) can only be invoked once'; });
	      assert(isNil(spec.meta.name) && Object.keys(spec.prototype).length === 0, function () { return 'Invalid argument type ' + assert.stringify(spec) + ' supplied to define(type) (expected a fresh, unnamed type)'; });
	    }
	
	    if (isUnion(spec) && Declare.hasOwnProperty('dispatch')) {
	      spec.dispatch = Declare.dispatch;
	    }
	    type = spec;
	    mixin(Declare, type, true); // true because it overwrites Declare.displayName
	    if (name) {
	      type.displayName = Declare.displayName = name;
	      Declare.meta.name = name;
	    }
	    Declare.meta.identity = type.meta.identity;
	    Declare.prototype = type.prototype;
	    return Declare;
	  };
	
	  Declare.displayName = name || ( getTypeName(Declare) + "$" + nextDeclareUniqueId++ );
	  // in general I can't say if this type will be an identity, for safety setting to false
	  Declare.meta = { identity: false };
	  Declare.prototype = null;
	  return Declare;
	};


/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	var isNil = __webpack_require__(330);
	var assert = __webpack_require__(328);
	
	// safe mixin, cannot override props unless specified
	module.exports = function mixin(target, source, overwrite) {
	  if (isNil(source)) { return target; }
	  for (var k in source) {
	    if (source.hasOwnProperty(k)) {
	      if (overwrite !== true) {
	        if (false) {
	          assert(!target.hasOwnProperty(k) || target[k] === source[k], function () { return 'Invalid call to mixin(target, source, [overwrite]): cannot overwrite property "' + k + '" of target object'; });
	        }
	      }
	      target[k] = source[k];
	    }
	  }
	  return target;
	};

/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	var isType = __webpack_require__(339);
	
	module.exports = function isUnion(x) {
	  return isType(x) && ( x.meta.kind === 'union' );
	};

/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(328);
	var isTypeName = __webpack_require__(353);
	var forbidNewOperator = __webpack_require__(337);
	var isString = __webpack_require__(336);
	var isObject = __webpack_require__(340);
	
	function getDefaultName(map) {
	  return Object.keys(map).map(function (k) { return assert.stringify(k); }).join(' | ');
	}
	
	function enums(map, name) {
	
	  if (false) {
	    assert(isObject(map), function () { return 'Invalid argument map ' + assert.stringify(map) + ' supplied to enums(map, [name]) combinator (expected a dictionary of String -> String | Number)'; });
	    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to enums(map, [name]) combinator (expected a string)'; });
	  }
	
	  var displayName = name || getDefaultName(map);
	
	  function Enums(value, path) {
	
	    if (false) {
	      forbidNewOperator(this, Enums);
	      path = path || [displayName];
	      assert(Enums.is(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (expected one of ' + assert.stringify(Object.keys(map)) + ')'; });
	    }
	
	    return value;
	  }
	
	  Enums.meta = {
	    kind: 'enums',
	    map: map,
	    name: name,
	    identity: true
	  };
	
	  Enums.displayName = displayName;
	
	  Enums.is = function (x) {
	    return map.hasOwnProperty(x);
	  };
	
	  return Enums;
	}
	
	enums.of = function (keys, name) {
	  keys = isString(keys) ? keys.split(' ') : keys;
	  var value = {};
	  keys.forEach(function (k) {
	    value[k] = k;
	  });
	  return enums(value, name);
	};
	
	enums.getDefaultName = getDefaultName;
	module.exports = enums;
	


/***/ },
/* 366 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(328);
	var isTypeName = __webpack_require__(353);
	var isFunction = __webpack_require__(329);
	var getTypeName = __webpack_require__(338);
	var isIdentity = __webpack_require__(354);
	var create = __webpack_require__(355);
	var is = __webpack_require__(356);
	var isArray = __webpack_require__(341);
	
	function getDefaultName(type) {
	  return 'Array<' + getTypeName(type) + '>';
	}
	
	function list(type, name) {
	
	  if (false) {
	    assert(isFunction(type), function () { return 'Invalid argument type ' + assert.stringify(type) + ' supplied to list(type, [name]) combinator (expected a type)'; });
	    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to list(type, [name]) combinator (expected a string)'; });
	  }
	
	  var displayName = name || getDefaultName(type);
	  var typeNameCache = getTypeName(type);
	  var identity = isIdentity(type); // the list is identity iif type is identity
	
	  function List(value, path) {
	
	    if (true) {
	      if (identity) {
	        return value; // just trust the input if elements must not be hydrated
	      }
	    }
	
	    if (false) {
	      path = path || [displayName];
	      assert(isArray(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (expected an array of ' + typeNameCache + ')'; });
	    }
	
	    var idempotent = true; // will remain true if I can reutilise the input
	    var ret = []; // make a temporary copy, will be discarded if idempotent remains true
	    for (var i = 0, len = value.length; i < len; i++ ) {
	      var actual = value[i];
	      var instance = create(type, actual, (  false ? path.concat(i + ': ' + typeNameCache) : null ));
	      idempotent = idempotent && ( actual === instance );
	      ret.push(instance);
	    }
	
	    if (idempotent) { // implements idempotency
	      ret = value;
	    }
	
	    if (false) {
	      Object.freeze(ret);
	    }
	
	    return ret;
	  }
	
	  List.meta = {
	    kind: 'list',
	    type: type,
	    name: name,
	    identity: identity
	  };
	
	  List.displayName = displayName;
	
	  List.is = function (x) {
	    return isArray(x) && x.every(function (e) {
	      return is(e, type);
	    });
	  };
	
	  List.update = function (instance, patch) {
	    return List(assert.update(instance, patch));
	  };
	
	  return List;
	}
	
	list.getDefaultName = getDefaultName;
	module.exports = list;


/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(328);
	var isTypeName = __webpack_require__(353);
	var isFunction = __webpack_require__(329);
	var isMaybe = __webpack_require__(368);
	var isIdentity = __webpack_require__(354);
	var Any = __webpack_require__(334);
	var create = __webpack_require__(355);
	var Nil = __webpack_require__(348);
	var forbidNewOperator = __webpack_require__(337);
	var is = __webpack_require__(356);
	var getTypeName = __webpack_require__(338);
	
	function getDefaultName(type) {
	  return '?' + getTypeName(type);
	}
	
	function maybe(type, name) {
	
	  if (isMaybe(type) || type === Any || type === Nil) { // makes the combinator idempotent and handle Any, Nil
	    return type;
	  }
	
	  if (false) {
	    assert(isFunction(type), function () { return 'Invalid argument type ' + assert.stringify(type) + ' supplied to maybe(type, [name]) combinator (expected a type)'; });
	    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to maybe(type, [name]) combinator (expected a string)'; });
	  }
	
	  var displayName = name || getDefaultName(type);
	  var identity = isIdentity(type);
	
	  function Maybe(value, path) {
	    if (false) {
	      if (identity) {
	        forbidNewOperator(this, Maybe);
	      }
	    }
	    return Nil.is(value) ? value : create(type, value, path);
	  }
	
	  Maybe.meta = {
	    kind: 'maybe',
	    type: type,
	    name: name,
	    identity: identity
	  };
	
	  Maybe.displayName = displayName;
	
	  Maybe.is = function (x) {
	    return Nil.is(x) || is(x, type);
	  };
	
	  return Maybe;
	}
	
	maybe.getDefaultName = getDefaultName;
	module.exports = maybe;


/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {

	var isType = __webpack_require__(339);
	
	module.exports = function isMaybe(x) {
	  return isType(x) && ( x.meta.kind === 'maybe' );
	};

/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(328);
	var isTypeName = __webpack_require__(353);
	var String = __webpack_require__(359);
	var Function = __webpack_require__(347);
	var isBoolean = __webpack_require__(344);
	var isObject = __webpack_require__(340);
	var isNil = __webpack_require__(330);
	var create = __webpack_require__(355);
	var getTypeName = __webpack_require__(338);
	var dict = __webpack_require__(361);
	var getDefaultInterfaceName = __webpack_require__(370);
	var extend = __webpack_require__(371);
	
	function getDefaultName(props) {
	  return 'Struct' + getDefaultInterfaceName(props);
	}
	
	function extendStruct(mixins, name) {
	  return extend(struct, mixins, name);
	}
	
	function getOptions(options) {
	  if (!isObject(options)) {
	    options = isNil(options) ? {} : { name: options };
	  }
	  if (!options.hasOwnProperty('strict')) {
	    options.strict = struct.strict;
	  }
	  if (!options.hasOwnProperty('defaultProps')) {
	    options.defaultProps = {};
	  }
	  return options;
	}
	
	function struct(props, options) {
	
	  options = getOptions(options);
	  var name = options.name;
	  var strict = options.strict;
	  var defaultProps = options.defaultProps;
	
	  if (false) {
	    assert(dict(String, Function).is(props), function () { return 'Invalid argument props ' + assert.stringify(props) + ' supplied to struct(props, [options]) combinator (expected a dictionary String -> Type)'; });
	    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to struct(props, [options]) combinator (expected a string)'; });
	    assert(isBoolean(strict), function () { return 'Invalid argument strict ' + assert.stringify(strict) + ' supplied to struct(props, [options]) combinator (expected a boolean)'; });
	    assert(isObject(defaultProps), function () { return 'Invalid argument defaultProps ' + assert.stringify(defaultProps) + ' supplied to struct(props, [options]) combinator (expected an object)'; });
	  }
	
	  var displayName = name || getDefaultName(props);
	
	  function Struct(value, path) {
	
	    if (Struct.is(value)) { // implements idempotency
	      return value;
	    }
	
	    if (false) {
	      path = path || [displayName];
	      assert(isObject(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (expected an object)'; });
	      // strictness
	      if (strict) {
	        for (k in value) {
	          if (value.hasOwnProperty(k)) {
	            assert(props.hasOwnProperty(k), function () { return 'Invalid additional prop "' + k + '" supplied to ' + path.join('/'); });
	          }
	        }
	      }
	    }
	
	    if (!(this instanceof Struct)) { // `new` is optional
	      return new Struct(value, path);
	    }
	
	    for (var k in props) {
	      if (props.hasOwnProperty(k)) {
	        var expected = props[k];
	        var actual = value[k];
	        // apply defaults
	        if (actual === undefined) {
	          actual = defaultProps[k];
	        }
	        this[k] = create(expected, actual, (  false ? path.concat(k + ': ' + getTypeName(expected)) : null ));
	      }
	    }
	
	    if (false) {
	      Object.freeze(this);
	    }
	
	  }
	
	  Struct.meta = {
	    kind: 'struct',
	    props: props,
	    name: name,
	    identity: false,
	    strict: strict,
	    defaultProps: defaultProps
	  };
	
	  Struct.displayName = displayName;
	
	  Struct.is = function (x) {
	    return x instanceof Struct;
	  };
	
	  Struct.update = function (instance, patch) {
	    return new Struct(assert.update(instance, patch));
	  };
	
	  Struct.extend = function (xs, name) {
	    return extendStruct([Struct].concat(xs), name);
	  };
	
	  return Struct;
	}
	
	struct.strict = false;
	struct.getOptions = getOptions;
	struct.getDefaultName = getDefaultName;
	struct.extend = extendStruct;
	module.exports = struct;


/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	var getTypeName = __webpack_require__(338);
	
	function getDefaultInterfaceName(props) {
	  return '{' + Object.keys(props).map(function (prop) {
	    return prop + ': ' + getTypeName(props[prop]);
	  }).join(', ') + '}';
	}
	
	module.exports = getDefaultInterfaceName;


/***/ },
/* 371 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(328);
	var isFunction = __webpack_require__(329);
	var isArray = __webpack_require__(341);
	var mixin = __webpack_require__(363);
	var isStruct = __webpack_require__(372);
	var isInterface = __webpack_require__(373);
	var isObject = __webpack_require__(340);
	var refinement = __webpack_require__(352);
	var decompose = __webpack_require__(374);
	
	function compose(predicates, unrefinedType) {
	  return predicates.reduce(function (type, predicate) {
	    return refinement(type, predicate);
	  }, unrefinedType);
	}
	
	function getProps(type) {
	  return isObject(type) ? type : type.meta.props;
	}
	
	function getDefaultProps(type) {
	  return isObject(type) ? null : type.meta.defaultProps;
	}
	
	function pushAll(arr, elements) {
	  Array.prototype.push.apply(arr, elements);
	}
	
	function extend(combinator, mixins, options) {
	  if (false) {
	    assert(isFunction(combinator), function () { return 'Invalid argument combinator supplied to extend(combinator, mixins, options), expected a function'; });
	    assert(isArray(mixins), function () { return 'Invalid argument mixins supplied to extend(combinator, mixins, options), expected an array'; });
	  }
	  var props = {};
	  var prototype = {};
	  var predicates = [];
	  var defaultProps = {};
	  mixins.forEach(function (x, i) {
	    var decomposition = decompose(x);
	    var unrefinedType = decomposition.unrefinedType;
	    if (false) {
	      assert(isObject(unrefinedType) || isStruct(unrefinedType) || isInterface(unrefinedType), function () { return 'Invalid argument mixins[' + i + '] supplied to extend(combinator, mixins, options), expected an object, struct, interface or a refinement (of struct or interface)'; });
	    }
	    pushAll(predicates, decomposition.predicates);
	    mixin(props, getProps(unrefinedType));
	    mixin(prototype, unrefinedType.prototype);
	    mixin(defaultProps, getDefaultProps(unrefinedType), true);
	  });
	  options = combinator.getOptions(options);
	  options.defaultProps = mixin(defaultProps, options.defaultProps, true);
	  var result = compose(predicates, combinator(props, options));
	  mixin(result.prototype, prototype);
	  return result;
	}
	
	module.exports = extend;

/***/ },
/* 372 */
/***/ function(module, exports, __webpack_require__) {

	var isType = __webpack_require__(339);
	
	module.exports = function isStruct(x) {
	  return isType(x) && ( x.meta.kind === 'struct' );
	};

/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

	var isType = __webpack_require__(339);
	
	module.exports = function isInterface(x) {
	  return isType(x) && ( x.meta.kind === 'interface' );
	};

/***/ },
/* 374 */
/***/ function(module, exports, __webpack_require__) {

	var isType = __webpack_require__(339);
	
	function isRefinement(type) {
	  return isType(type) && type.meta.kind === 'subtype';
	}
	
	function getPredicates(type) {
	  return isRefinement(type) ?
	    [type.meta.predicate].concat(getPredicates(type.meta.type)) :
	    [];
	}
	
	function getUnrefinedType(type) {
	  return isRefinement(type) ?
	    getUnrefinedType(type.meta.type) :
	    type;
	}
	
	function decompose(type) {
	  return {
	    predicates: getPredicates(type),
	    unrefinedType: getUnrefinedType(type)
	  };
	}
	
	module.exports = decompose;

/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(328);
	var isTypeName = __webpack_require__(353);
	var isFunction = __webpack_require__(329);
	var getTypeName = __webpack_require__(338);
	var isIdentity = __webpack_require__(354);
	var isArray = __webpack_require__(341);
	var create = __webpack_require__(355);
	var is = __webpack_require__(356);
	
	function getDefaultName(types) {
	  return '[' + types.map(getTypeName).join(', ') + ']';
	}
	
	function tuple(types, name) {
	
	  if (false) {
	    assert(isArray(types) && types.every(isFunction), function () { return 'Invalid argument types ' + assert.stringify(types) + ' supplied to tuple(types, [name]) combinator (expected an array of types)'; });
	    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to tuple(types, [name]) combinator (expected a string)'; });
	  }
	
	  var displayName = name || getDefaultName(types);
	  var identity = types.every(isIdentity);
	
	  function Tuple(value, path) {
	
	    if (true) {
	      if (identity) {
	        return value;
	      }
	    }
	
	    if (false) {
	      path = path || [displayName];
	      assert(isArray(value) && value.length === types.length, function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (expected an array of length ' + types.length + ')'; });
	    }
	
	    var idempotent = true;
	    var ret = [];
	    for (var i = 0, len = types.length; i < len; i++) {
	      var expected = types[i];
	      var actual = value[i];
	      var instance = create(expected, actual, (  false ? path.concat(i + ': ' + getTypeName(expected)) : null ));
	      idempotent = idempotent && ( actual === instance );
	      ret.push(instance);
	    }
	
	    if (idempotent) { // implements idempotency
	      ret = value;
	    }
	
	    if (false) {
	      Object.freeze(ret);
	    }
	
	    return ret;
	  }
	
	  Tuple.meta = {
	    kind: 'tuple',
	    types: types,
	    name: name,
	    identity: identity
	  };
	
	  Tuple.displayName = displayName;
	
	  Tuple.is = function (x) {
	    return isArray(x) &&
	      x.length === types.length &&
	      types.every(function (type, i) {
	        return is(x[i], type);
	      });
	  };
	
	  Tuple.update = function (instance, patch) {
	    return Tuple(assert.update(instance, patch));
	  };
	
	  return Tuple;
	}
	
	tuple.getDefaultName = getDefaultName;
	module.exports = tuple;

/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(328);
	var isTypeName = __webpack_require__(353);
	var isFunction = __webpack_require__(329);
	var getTypeName = __webpack_require__(338);
	var isIdentity = __webpack_require__(354);
	var isArray = __webpack_require__(341);
	var create = __webpack_require__(355);
	var is = __webpack_require__(356);
	var forbidNewOperator = __webpack_require__(337);
	var isUnion = __webpack_require__(364);
	var isNil = __webpack_require__(330);
	
	function getDefaultName(types) {
	  return types.map(getTypeName).join(' | ');
	}
	
	function union(types, name) {
	
	  if (false) {
	    assert(isArray(types) && types.every(isFunction) && types.length >= 2, function () { return 'Invalid argument types ' + assert.stringify(types) + ' supplied to union(types, [name]) combinator (expected an array of at least 2 types)'; });
	    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to union(types, [name]) combinator (expected a string)'; });
	  }
	
	  var displayName = name || getDefaultName(types);
	  var identity = types.every(isIdentity);
	
	  function Union(value, path) {
	
	    if (true) {
	      if (identity) {
	        return value;
	      }
	    }
	
	    var type = Union.dispatch(value);
	    if (!type && Union.is(value)) {
	      return value;
	    }
	
	    if (false) {
	      if (identity) {
	        forbidNewOperator(this, Union);
	      }
	      path = path || [displayName];
	      assert(isFunction(type), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (no constructor returned by dispatch)'; });
	      path[path.length - 1] += '(' + getTypeName(type) + ')';
	    }
	
	    return create(type, value, path);
	  }
	
	  Union.meta = {
	    kind: 'union',
	    types: types,
	    name: name,
	    identity: identity
	  };
	
	  Union.displayName = displayName;
	
	  Union.is = function (x) {
	    return types.some(function (type) {
	      return is(x, type);
	    });
	  };
	
	  Union.dispatch = function (x) { // default dispatch implementation
	    for (var i = 0, len = types.length; i < len; i++ ) {
	      var type = types[i];
	      if (isUnion(type)) { // handle union of unions
	        var t = type.dispatch(x);
	        if (!isNil(t)) {
	          return t;
	        }
	      }
	      else if (is(x, type)) {
	        return type;
	      }
	    }
	  };
	
	  Union.update = function (instance, patch) {
	    return Union(assert.update(instance, patch));
	  };
	
	  return Union;
	}
	
	union.getDefaultName = getDefaultName;
	module.exports = union;
	


/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(328);
	var isTypeName = __webpack_require__(353);
	var FunctionType = __webpack_require__(347);
	var isArray = __webpack_require__(341);
	var list = __webpack_require__(366);
	var isObject = __webpack_require__(340);
	var create = __webpack_require__(355);
	var isNil = __webpack_require__(330);
	var isBoolean = __webpack_require__(344);
	var tuple = __webpack_require__(375);
	var getFunctionName = __webpack_require__(333);
	var getTypeName = __webpack_require__(338);
	var isType = __webpack_require__(339);
	
	function getDefaultName(domain, codomain) {
	  return '(' + domain.map(getTypeName).join(', ') + ') => ' + getTypeName(codomain);
	}
	
	function isInstrumented(f) {
	  return FunctionType.is(f) && isObject(f.instrumentation);
	}
	
	function getOptionalArgumentsIndex(types) {
	  var end = types.length;
	  var areAllMaybes = false;
	  for (var i = end - 1; i >= 0; i--) {
	    var type = types[i];
	    if (!isType(type) || type.meta.kind !== 'maybe') {
	      return (i + 1);
	    } else {
	      areAllMaybes = true;
	    }
	  }
	  return areAllMaybes ? 0 : end;
	}
	
	function func(domain, codomain, name) {
	
	  domain = isArray(domain) ? domain : [domain]; // handle handy syntax for unary functions
	
	  if (false) {
	    assert(list(FunctionType).is(domain), function () { return 'Invalid argument domain ' + assert.stringify(domain) + ' supplied to func(domain, codomain, [name]) combinator (expected an array of types)'; });
	    assert(FunctionType.is(codomain), function () { return 'Invalid argument codomain ' + assert.stringify(codomain) + ' supplied to func(domain, codomain, [name]) combinator (expected a type)'; });
	    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to func(domain, codomain, [name]) combinator (expected a string)'; });
	  }
	
	  var displayName = name || getDefaultName(domain, codomain);
	  var domainLength = domain.length;
	  var optionalArgumentsIndex = getOptionalArgumentsIndex(domain);
	
	  function FuncType(value, path) {
	
	    if (!isInstrumented(value)) { // automatically instrument the function
	      return FuncType.of(value);
	    }
	
	    if (false) {
	      path = path || [displayName];
	      assert(FuncType.is(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
	    }
	
	    return value;
	  }
	
	  FuncType.meta = {
	    kind: 'func',
	    domain: domain,
	    codomain: codomain,
	    name: name,
	    identity: true
	  };
	
	  FuncType.displayName = displayName;
	
	  FuncType.is = function (x) {
	    return isInstrumented(x) &&
	      x.instrumentation.domain.length === domainLength &&
	      x.instrumentation.domain.every(function (type, i) {
	        return type === domain[i];
	      }) &&
	      x.instrumentation.codomain === codomain;
	  };
	
	  FuncType.of = function (f, curried) {
	
	    if (false) {
	      assert(FunctionType.is(f), function () { return 'Invalid argument f supplied to func.of ' + displayName + ' (expected a function)'; });
	      assert(isNil(curried) || isBoolean(curried), function () { return 'Invalid argument curried ' + assert.stringify(curried) + ' supplied to func.of ' + displayName + ' (expected a boolean)'; });
	    }
	
	    if (FuncType.is(f)) { // makes FuncType.of idempotent
	      return f;
	    }
	
	    function fn() {
	      var args = Array.prototype.slice.call(arguments);
	      var argsLength = args.length;
	
	      if (false) {
	        // type-check arguments
	        var tupleLength = curried ? argsLength : Math.max(argsLength, optionalArgumentsIndex);
	        tuple(domain.slice(0, tupleLength), 'arguments of function ' + displayName)(args);
	      }
	
	      if (curried && argsLength < domainLength) {
	        if (false) {
	          assert(argsLength > 0, 'Invalid arguments.length = 0 for curried function ' + displayName);
	        }
	        var g = Function.prototype.bind.apply(f, [this].concat(args));
	        var newDomain = func(domain.slice(argsLength), codomain);
	        return newDomain.of(g, true);
	      }
	      else {
	        return create(codomain, f.apply(this, args));
	      }
	    }
	
	    fn.instrumentation = {
	      domain: domain,
	      codomain: codomain,
	      f: f
	    };
	
	    fn.displayName = getFunctionName(f);
	
	    return fn;
	
	  };
	
	  return FuncType;
	
	}
	
	func.getDefaultName = getDefaultName;
	func.getOptionalArgumentsIndex = getOptionalArgumentsIndex;
	module.exports = func;


/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(328);
	var isTypeName = __webpack_require__(353);
	var isFunction = __webpack_require__(329);
	var isArray = __webpack_require__(341);
	var forbidNewOperator = __webpack_require__(354);
	var is = __webpack_require__(356);
	var getTypeName = __webpack_require__(338);
	var isIdentity = __webpack_require__(354);
	
	function getDefaultName(types) {
	  return types.map(getTypeName).join(' & ');
	}
	
	function intersection(types, name) {
	
	  if (false) {
	    assert(isArray(types) && types.every(isFunction) && types.length >= 2, function () { return 'Invalid argument types ' + assert.stringify(types) + ' supplied to intersection(types, [name]) combinator (expected an array of at least 2 types)'; });
	    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to intersection(types, [name]) combinator (expected a string)'; });
	  }
	
	  var displayName = name || getDefaultName(types);
	  var identity = types.every(isIdentity);
	
	  function Intersection(value, path) {
	
	    if (false) {
	      if (identity) {
	        forbidNewOperator(this, Intersection);
	      }
	      path = path || [displayName];
	      assert(Intersection.is(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
	    }
	
	    return value;
	  }
	
	  Intersection.meta = {
	    kind: 'intersection',
	    types: types,
	    name: name,
	    identity: identity
	  };
	
	  Intersection.displayName = displayName;
	
	  Intersection.is = function (x) {
	    return types.every(function (type) {
	      return is(x, type);
	    });
	  };
	
	  Intersection.update = function (instance, patch) {
	    return Intersection(assert.update(instance, patch));
	  };
	
	  return Intersection;
	}
	
	intersection.getDefaultName = getDefaultName;
	module.exports = intersection;
	


/***/ },
/* 379 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(328);
	var isTypeName = __webpack_require__(353);
	var String = __webpack_require__(359);
	var Function = __webpack_require__(347);
	var isBoolean = __webpack_require__(344);
	var isObject = __webpack_require__(340);
	var isNil = __webpack_require__(330);
	var create = __webpack_require__(355);
	var getTypeName = __webpack_require__(338);
	var dict = __webpack_require__(361);
	var getDefaultInterfaceName = __webpack_require__(370);
	var isIdentity = __webpack_require__(354);
	var is = __webpack_require__(356);
	var extend = __webpack_require__(371);
	var assign = __webpack_require__(380);
	
	function extendInterface(mixins, name) {
	  return extend(inter, mixins, name);
	}
	
	function getOptions(options) {
	  if (!isObject(options)) {
	    options = isNil(options) ? {} : { name: options };
	  }
	  if (!options.hasOwnProperty('strict')) {
	    options.strict = inter.strict;
	  }
	  return options;
	}
	
	function inter(props, options) {
	
	  options = getOptions(options);
	  var name = options.name;
	  var strict = options.strict;
	
	  if (false) {
	    assert(dict(String, Function).is(props), function () { return 'Invalid argument props ' + assert.stringify(props) + ' supplied to interface(props, [options]) combinator (expected a dictionary String -> Type)'; });
	    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to interface(props, [options]) combinator (expected a string)'; });
	    assert(isBoolean(strict), function () { return 'Invalid argument strict ' + assert.stringify(strict) + ' supplied to struct(props, [options]) combinator (expected a boolean)'; });
	  }
	
	  var displayName = name || getDefaultInterfaceName(props);
	  var identity = Object.keys(props).map(function (prop) { return props[prop]; }).every(isIdentity);
	
	  function Interface(value, path) {
	
	    if (true) {
	      if (identity) {
	        return value; // just trust the input if elements must not be hydrated
	      }
	    }
	
	    if (false) {
	      path = path || [displayName];
	      assert(!isNil(value), function () { return 'Invalid value ' + value + ' supplied to ' + path.join('/'); });
	      // strictness
	      if (strict) {
	        for (var k in value) {
	          assert(props.hasOwnProperty(k), function () { return 'Invalid additional prop "' + k + '" supplied to ' + path.join('/'); });
	        }
	      }
	    }
	
	    var idempotent = true;
	    var ret = identity ? {} : assign({}, value);
	    for (var prop in props) {
	      var expected = props[prop];
	      var actual = value[prop];
	      var instance = create(expected, actual, (  false ? path.concat(prop + ': ' + getTypeName(expected)) : null ));
	      idempotent = idempotent && ( actual === instance );
	      ret[prop] = instance;
	    }
	
	    if (idempotent) { // implements idempotency
	      ret = value;
	    }
	
	    if (false) {
	      Object.freeze(ret);
	    }
	
	    return ret;
	
	  }
	
	  Interface.meta = {
	    kind: 'interface',
	    props: props,
	    name: name,
	    identity: identity,
	    strict: strict
	  };
	
	  Interface.displayName = displayName;
	
	  Interface.is = function (x) {
	    if (isNil(x)) {
	      return false;
	    }
	    if (strict) {
	      for (var k in x) {
	        if (!props.hasOwnProperty(k)) {
	          return false;
	        }
	      }
	    }
	    for (var prop in props) {
	      if (!is(x[prop], props[prop])) {
	        return false;
	      }
	    }
	    return true;
	  };
	
	  Interface.update = function (instance, patch) {
	    return Interface(assert.update(instance, patch));
	  };
	
	  Interface.extend = function (xs, name) {
	    return extendInterface([Interface].concat(xs), name);
	  };
	
	  return Interface;
	}
	
	inter.strict = false;
	inter.getOptions = getOptions;
	inter.getDefaultName = getDefaultInterfaceName;
	inter.extend = extendInterface;
	module.exports = inter;


/***/ },
/* 380 */
/***/ function(module, exports) {

	function assign(x, y) {
	  for (var k in y) {
	    if (y.hasOwnProperty(k)) {
	      x[k] = y[k];
	    }
	  }
	  return x;
	}
	
	module.exports = assign;


/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(328);
	var isObject = __webpack_require__(340);
	var isFunction = __webpack_require__(329);
	var isArray = __webpack_require__(341);
	var isNumber = __webpack_require__(350);
	var assign = __webpack_require__(380);
	
	function getShallowCopy(x) {
	  if (isObject(x)) {
	    if (x instanceof Date || x instanceof RegExp) {
	      return x;
	    }
	    return assign({}, x);
	  }
	  if (isArray(x)) {
	    return x.concat();
	  }
	  return x;
	}
	
	function isCommand(k) {
	  return update.commands.hasOwnProperty(k);
	}
	
	function getCommand(k) {
	  return update.commands[k];
	}
	
	function update(instance, patch) {
	
	  if (false) {
	    assert(isObject(patch), function () { return 'Invalid argument patch ' + assert.stringify(patch) + ' supplied to function update(instance, patch): expected an object containing commands'; });
	  }
	
	  var value = instance;
	  var isChanged = false;
	  var newValue;
	  for (var k in patch) {
	    if (patch.hasOwnProperty(k)) {
	      if (isCommand(k)) {
	        newValue = getCommand(k)(patch[k], value);
	        if (newValue !== instance) {
	          isChanged = true;
	          value = newValue;
	        } else {
	          value = instance;
	        }
	      }
	      else {
	        if (value === instance) {
	          value = getShallowCopy(instance);
	        }
	        newValue = update(value[k], patch[k]);
	        isChanged = isChanged || ( newValue !== value[k] );
	        value[k] = newValue;
	      }
	    }
	  }
	  return isChanged ? value : instance;
	}
	
	// built-in commands
	
	function $apply(f, value) {
	  if (false) {
	    assert(isFunction(f), 'Invalid argument f supplied to immutability helper { $apply: f } (expected a function)');
	  }
	  return f(value);
	}
	
	function $push(elements, arr) {
	  if (false) {
	    assert(isArray(elements), 'Invalid argument elements supplied to immutability helper { $push: elements } (expected an array)');
	    assert(isArray(arr), 'Invalid value supplied to immutability helper $push (expected an array)');
	  }
	  if (elements.length > 0) {
	    return arr.concat(elements);
	  }
	  return arr;
	}
	
	function $remove(keys, obj) {
	  if (false) {
	    assert(isArray(keys), 'Invalid argument keys supplied to immutability helper { $remove: keys } (expected an array)');
	    assert(isObject(obj), 'Invalid value supplied to immutability helper $remove (expected an object)');
	  }
	  if (keys.length > 0) {
	    obj = getShallowCopy(obj);
	    for (var i = 0, len = keys.length; i < len; i++ ) {
	      delete obj[keys[i]];
	    }
	  }
	  return obj;
	}
	
	function $set(value) {
	  return value;
	}
	
	function $splice(splices, arr) {
	  if (false) {
	    assert(isArray(splices) && splices.every(isArray), 'Invalid argument splices supplied to immutability helper { $splice: splices } (expected an array of arrays)');
	    assert(isArray(arr), 'Invalid value supplied to immutability helper $splice (expected an array)');
	  }
	  if (splices.length > 0) {
	    arr = getShallowCopy(arr);
	    return splices.reduce(function (acc, splice) {
	      acc.splice.apply(acc, splice);
	      return acc;
	    }, arr);
	  }
	  return arr;
	}
	
	function $swap(config, arr) {
	  if (false) {
	    assert(isObject(config), 'Invalid argument config supplied to immutability helper { $swap: config } (expected an object)');
	    assert(isNumber(config.from), 'Invalid argument config.from supplied to immutability helper { $swap: config } (expected a number)');
	    assert(isNumber(config.to), 'Invalid argument config.to supplied to immutability helper { $swap: config } (expected a number)');
	    assert(isArray(arr), 'Invalid value supplied to immutability helper $swap (expected an array)');
	  }
	  if (config.from !== config.to) {
	    arr = getShallowCopy(arr);
	    var element = arr[config.to];
	    arr[config.to] = arr[config.from];
	    arr[config.from] = element;
	  }
	  return arr;
	}
	
	function $unshift(elements, arr) {
	  if (false) {
	    assert(isArray(elements), 'Invalid argument elements supplied to immutability helper {$unshift: elements} (expected an array)');
	    assert(isArray(arr), 'Invalid value supplied to immutability helper $unshift (expected an array)');
	  }
	  if (elements.length > 0) {
	    return elements.concat(arr);
	  }
	  return arr;
	}
	
	function $merge(whatToMerge, value) {
	  var isChanged = false;
	  var result = getShallowCopy(value);
	  for (var k in whatToMerge) {
	    if (whatToMerge.hasOwnProperty(k)) {
	      result[k] = whatToMerge[k];
	      isChanged = isChanged || ( result[k] !== value[k] );
	    }
	  }
	  return isChanged ? result : value;
	}
	
	update.commands = {
	  $apply: $apply,
	  $push: $push,
	  $remove: $remove,
	  $set: $set,
	  $splice: $splice,
	  $swap: $swap,
	  $unshift: $unshift,
	  $merge: $merge
	};
	
	module.exports = update;


/***/ },
/* 382 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(328);
	var isFunction = __webpack_require__(329);
	var isType = __webpack_require__(339);
	var Any = __webpack_require__(334);
	
	module.exports = function match(x) {
	  var type, guard, f, count;
	  for (var i = 1, len = arguments.length; i < len; ) {
	    type = arguments[i];
	    guard = arguments[i + 1];
	    f = arguments[i + 2];
	
	    if (isFunction(f) && !isType(f)) {
	      i = i + 3;
	    }
	    else {
	      f = guard;
	      guard = Any.is;
	      i = i + 2;
	    }
	
	    if (false) {
	      count = (count || 0) + 1;
	      assert(isType(type), function () { return 'Invalid type in clause #' + count; });
	      assert(isFunction(guard), function () { return 'Invalid guard in clause #' + count; });
	      assert(isFunction(f), function () { return 'Invalid block in clause #' + count; });
	    }
	
	    if (type.is(x) && guard(x)) {
	      return f(x);
	    }
	  }
	  assert.fail('Match error');
	};


/***/ },
/* 383 */
/***/ function(module, exports, __webpack_require__) {

	var prettyPrint = (() => {
	  var _ref = _asyncToGenerator(function* (_ref2) {
	    var source = _ref2.source,
	        sourceText = _ref2.sourceText,
	        url = _ref2.url;
	
	    var contentType = sourceText ? sourceText.contentType : null;
	    var indent = 2;
	
	    assert(isJavaScript(source.url, contentType), "Can't prettify non-javascript files.");
	
	    return yield _prettyPrint({
	      url,
	      indent,
	      source: sourceText.text
	    });
	  });
	
	  return function prettyPrint(_x) {
	    return _ref.apply(this, arguments);
	  };
	})();
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	var _require = __webpack_require__(197),
	    getValue = _require.getValue;
	
	var _require2 = __webpack_require__(250),
	    workerTask = _require2.workerTask;
	
	var _require3 = __webpack_require__(295),
	    isJavaScript = _require3.isJavaScript;
	
	var assert = __webpack_require__(252);
	
	var prettyPrintWorker = new Worker(`${ getValue("baseWorkerURL") }pretty-print-worker.js`);
	
	function destroyWorker() {
	  prettyPrintWorker.terminate();
	  prettyPrintWorker = null;
	}
	
	var _prettyPrint = workerTask(prettyPrintWorker, "prettyPrint");
	
	module.exports = {
	  prettyPrint,
	  destroyWorker
	};

/***/ },
/* 384 */
/***/ function(module, exports) {

	var sourceDocs = {};
	
	function getDocument(key) {
	  return sourceDocs[key];
	}
	
	function setDocument(key, doc) {
	  sourceDocs[key] = doc;
	}
	
	function removeDocument(key) {
	  delete sourceDocs[key];
	}
	
	function clearDocuments() {
	  sourceDocs = {};
	}
	
	module.exports = {
	  getDocument,
	  setDocument,
	  removeDocument,
	  clearDocuments
	};

/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	var constants = __webpack_require__(290);
	
	var _require = __webpack_require__(324),
	    selectSource = _require.selectSource;
	
	var _require2 = __webpack_require__(248),
	    PROMISE = _require2.PROMISE;
	
	var _require3 = __webpack_require__(303),
	    getPause = _require3.getPause;
	
	var _require4 = __webpack_require__(325),
	    updateFrameLocations = _require4.updateFrameLocations;
	
	var _require5 = __webpack_require__(322),
	    evaluateExpressions = _require5.evaluateExpressions;
	
	/**
	 * Redux actions for the pause state
	 * @module actions/pause
	 */
	
	/**
	 * Debugger has just resumed
	 *
	 * @memberof actions/pause
	 * @static
	 */
	function resumed() {
	  return (_ref) => {
	    var dispatch = _ref.dispatch,
	        client = _ref.client;
	
	    dispatch(evaluateExpressions(null));
	
	    return dispatch({
	      type: constants.RESUME,
	      value: undefined
	    });
	  };
	}
	
	/**
	 * Debugger has just paused
	 *
	 * @param {object} pauseInfo
	 * @memberof actions/pause
	 * @static
	 */
	function paused(pauseInfo) {
	  return (() => {
	    var _ref2 = _asyncToGenerator(function* (_ref3) {
	      var dispatch = _ref3.dispatch,
	          getState = _ref3.getState,
	          client = _ref3.client;
	      var frames = pauseInfo.frames,
	          why = pauseInfo.why;
	
	      frames = yield updateFrameLocations(frames);
	      var frame = frames[0];
	
	      dispatch({
	        type: constants.PAUSED,
	        pauseInfo: { why, frame },
	        frames: frames,
	        selectedFrameId: frame.id
	      });
	
	      dispatch(evaluateExpressions(frame.id));
	
	      dispatch(selectSource(frame.location.sourceId, { line: frame.location.line }));
	    });
	
	    return function (_x) {
	      return _ref2.apply(this, arguments);
	    };
	  })();
	}
	
	/**
	 *
	 * @memberof actions/pause
	 * @static
	 */
	function pauseOnExceptions(shouldPauseOnExceptions, shouldIgnoreCaughtExceptions) {
	  return (_ref4) => {
	    var dispatch = _ref4.dispatch,
	        client = _ref4.client;
	
	    dispatch({
	      type: constants.PAUSE_ON_EXCEPTIONS,
	      shouldPauseOnExceptions,
	      shouldIgnoreCaughtExceptions,
	      [PROMISE]: client.pauseOnExceptions(shouldPauseOnExceptions, shouldIgnoreCaughtExceptions)
	    });
	  };
	}
	
	/**
	 * Debugger commands like stepOver, stepIn, stepUp
	 *
	 * @param string $0.type
	 * @memberof actions/pause
	 * @static
	 */
	function command(_ref5) {
	  var type = _ref5.type;
	
	  return (_ref6) => {
	    var dispatch = _ref6.dispatch,
	        client = _ref6.client;
	
	    // execute debugger thread command e.g. stepIn, stepOver
	    client[type]();
	
	    return dispatch({
	      type: constants.COMMAND,
	      value: undefined
	    });
	  };
	}
	
	/**
	 * StepIn
	 * @memberof actions/pause
	 * @static
	 * @returns {Function} {@link command}
	 */
	function stepIn() {
	  return (_ref7) => {
	    var dispatch = _ref7.dispatch,
	        getState = _ref7.getState;
	
	    if (getPause(getState())) {
	      return dispatch(command({ type: "stepIn" }));
	    }
	  };
	}
	
	/**
	 * stepOver
	 * @memberof actions/pause
	 * @static
	 * @returns {Function} {@link command}
	 */
	function stepOver() {
	  return (_ref8) => {
	    var dispatch = _ref8.dispatch,
	        getState = _ref8.getState;
	
	    if (getPause(getState())) {
	      return dispatch(command({ type: "stepOver" }));
	    }
	  };
	}
	
	/**
	 * stepOut
	 * @memberof actions/pause
	 * @static
	 * @returns {Function} {@link command}
	 */
	function stepOut() {
	  return (_ref9) => {
	    var dispatch = _ref9.dispatch,
	        getState = _ref9.getState;
	
	    if (getPause(getState())) {
	      return dispatch(command({ type: "stepOut" }));
	    }
	  };
	}
	
	/**
	 * resume
	 * @memberof actions/pause
	 * @static
	 * @returns {Function} {@link command}
	 */
	function resume() {
	  return (_ref10) => {
	    var dispatch = _ref10.dispatch,
	        getState = _ref10.getState;
	
	    if (getPause(getState())) {
	      return dispatch(command({ type: "resume" }));
	    }
	  };
	}
	
	/**
	 * Debugger breakOnNext command.
	 * It's different from the comand action because we also want to
	 * highlight the pause icon.
	 *
	 * @memberof actions/pause
	 * @static
	 */
	function breakOnNext() {
	  return (_ref11) => {
	    var dispatch = _ref11.dispatch,
	        client = _ref11.client;
	
	    client.breakOnNext();
	
	    return dispatch({
	      type: constants.BREAK_ON_NEXT,
	      value: true
	    });
	  };
	}
	
	/**
	 * Select a frame
	 *
	 * @param frame
	 * @memberof actions/pause
	 * @static
	 */
	function selectFrame(frame) {
	  return (_ref12) => {
	    var dispatch = _ref12.dispatch;
	
	    dispatch(evaluateExpressions(frame.id));
	    dispatch(selectSource(frame.location.sourceId, { line: frame.location.line }));
	    dispatch({
	      type: constants.SELECT_FRAME,
	      frame
	    });
	  };
	}
	
	/**
	 * Load an object.
	 *
	 * @param grip
	 * TODO: Right now this if Firefox specific and is not implemented
	 * for Chrome, which is why it takes a grip.
	 * @memberof actions/pause
	 * @static
	 */
	function loadObjectProperties(grip) {
	  return (_ref13) => {
	    var dispatch = _ref13.dispatch,
	        client = _ref13.client;
	
	    dispatch({
	      type: constants.LOAD_OBJECT_PROPERTIES,
	      objectId: grip.actor,
	      [PROMISE]: client.getProperties(grip)
	    });
	  };
	}
	
	module.exports = {
	  resumed,
	  paused,
	  pauseOnExceptions,
	  command,
	  stepIn,
	  stepOut,
	  stepOver,
	  resume,
	  breakOnNext,
	  selectFrame,
	  loadObjectProperties
	};

/***/ },
/* 386 */
/***/ function(module, exports, __webpack_require__) {

	var constants = __webpack_require__(290);
	
	var _require = __webpack_require__(316),
	    clearSourceMaps = _require.clearSourceMaps;
	
	var _require2 = __webpack_require__(384),
	    clearDocuments = _require2.clearDocuments;
	
	/**
	 * Redux actions for the navigation state
	 * @module actions/navigation
	 */
	
	/**
	 * @memberof actions/navigation
	 * @static
	 */
	
	
	function willNavigate() {
	  clearSourceMaps();
	  clearDocuments();
	
	  return { type: constants.NAVIGATE };
	}
	
	/**
	 * @memberof actions/navigation
	 * @static
	 */
	function navigated() {
	  return (_ref) => {
	    // We need to load all the sources again because they might have
	    // come from bfcache, so we won't get a `newSource` notification.
	    //
	    // TODO: This seems to be buggy on the debugger server side. When
	    // the page is loaded from bfcache, we still get sources from the
	    // *previous* page as well. For now, emulate the current debugger
	    // behavior by not showing sources loaded by bfcache.
	    // return dispatch(sources.loadSources());
	
	    var dispatch = _ref.dispatch;
	  };
	}
	
	module.exports = {
	  willNavigate,
	  navigated
	};

/***/ },
/* 387 */
/***/ function(module, exports, __webpack_require__) {

	var constants = __webpack_require__(290);
	
	var _require = __webpack_require__(303),
	    getSource = _require.getSource;
	
	function toggleFileSearch(searchOn) {
	  return {
	    type: constants.TOGGLE_FILE_SEARCH,
	    searchOn
	  };
	}
	
	function showSource(sourceId) {
	  return (_ref) => {
	    var dispatch = _ref.dispatch,
	        getState = _ref.getState;
	
	    var source = getSource(getState(), sourceId);
	    dispatch({
	      type: constants.SHOW_SOURCE,
	      sourceUrl: source.get("url")
	    });
	  };
	}
	
	function togglePaneCollapse(position, paneCollapsed) {
	  return {
	    type: constants.TOGGLE_PANE,
	    position,
	    paneCollapsed
	  };
	}
	
	module.exports = {
	  toggleFileSearch,
	  showSource,
	  togglePaneCollapse
	};

/***/ },
/* 388 */
/***/ function(module, exports, __webpack_require__) {

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	var constants = __webpack_require__(290);
	
	
	function recordCoverage() {
	  return (() => {
	    var _ref = _asyncToGenerator(function* (_ref2) {
	      var dispatch = _ref2.dispatch,
	          getState = _ref2.getState,
	          client = _ref2.client;
	
	      var _ref3 = yield client.recordCoverage(),
	          coverage = _ref3.coverage;
	
	      return dispatch({
	        type: constants.RECORD_COVERAGE,
	        value: { coverage }
	      });
	    });
	
	    return function (_x) {
	      return _ref.apply(this, arguments);
	    };
	  })();
	}
	
	module.exports = {
	  recordCoverage
	};

/***/ },
/* 389 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 390 */,
/* 391 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 392 */,
/* 393 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 394 */,
/* 395 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 396 */,
/* 397 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	var dom = React.DOM,
	    PropTypes = React.PropTypes,
	    createFactory = React.createFactory;
	
	var _require = __webpack_require__(305),
	    connect = _require.connect;
	
	var _require2 = __webpack_require__(3),
	    bindActionCreators = _require2.bindActionCreators;
	
	var actions = __webpack_require__(314);
	
	var _require3 = __webpack_require__(303),
	    getSources = _require3.getSources,
	    getSelectedSource = _require3.getSelectedSource,
	    getFileSearchState = _require3.getFileSearchState;
	
	var _require4 = __webpack_require__(250),
	    endTruncateStr = _require4.endTruncateStr;
	
	var _require5 = __webpack_require__(398),
	    parseURL = _require5.parse;
	
	var _require6 = __webpack_require__(295),
	    isPretty = _require6.isPretty;
	
	__webpack_require__(404);
	
	var Autocomplete = createFactory(__webpack_require__(406));
	
	function searchResults(sources) {
	  function getSourcePath(source) {
	    var _parseURL = parseURL(source.get("url")),
	        path = _parseURL.path,
	        href = _parseURL.href;
	    // for URLs like "about:home" the path is null so we pass the full href
	
	
	    return path || href;
	  }
	
	  return sources.valueSeq().filter(source => !isPretty(source.toJS()) && source.get("url")).map(source => ({
	    value: getSourcePath(source),
	    title: getSourcePath(source).split("/").pop(),
	    subtitle: endTruncateStr(getSourcePath(source), 100),
	    id: source.get("id")
	  })).toJS();
	}
	
	var Search = React.createClass({
	  propTypes: {
	    sources: PropTypes.object,
	    selectSource: PropTypes.func,
	    selectedSource: PropTypes.object,
	    toggleFileSearch: PropTypes.func,
	    searchOn: PropTypes.bool
	  },
	
	  contextTypes: {
	    shortcuts: PropTypes.object
	  },
	
	  displayName: "Search",
	
	  getInitialState() {
	    return {
	      inputValue: ""
	    };
	  },
	
	  componentWillUnmount() {
	    var shortcuts = this.context.shortcuts;
	    shortcuts.off(`CmdOrCtrl+${ L10N.getStr("sources.search.key") }`, this.toggle);
	    shortcuts.off("Escape", this.onEscape);
	  },
	
	  componentDidMount() {
	    var shortcuts = this.context.shortcuts;
	    shortcuts.on(`CmdOrCtrl+${ L10N.getStr("sources.search.key") }`, this.toggle);
	    shortcuts.on("Escape", this.onEscape);
	  },
	
	  toggle(key, e) {
	    e.preventDefault();
	    this.props.toggleFileSearch(!this.props.searchOn);
	  },
	
	  onEscape(shortcut, e) {
	    if (this.props.searchOn) {
	      e.preventDefault();
	      this.setState({ inputValue: "" });
	      this.props.toggleFileSearch(false);
	    }
	  },
	
	  close() {
	    var inputValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
	
	    this.setState({ inputValue });
	    this.props.toggleFileSearch(false);
	  },
	
	  render() {
	    return this.props.searchOn ? dom.div({ className: "search-container" }, Autocomplete({
	      selectItem: result => {
	        this.props.selectSource(result.id);
	        this.setState({ inputValue: "" });
	        this.props.toggleFileSearch(false);
	      },
	      close: this.close,
	      items: searchResults(this.props.sources),
	      inputValue: this.state.inputValue
	    })) : null;
	  }
	
	});
	
	module.exports = connect(state => ({
	  sources: getSources(state),
	  selectedSource: getSelectedSource(state),
	  searchOn: getFileSearchState(state)
	}), dispatch => bindActionCreators(actions, dispatch))(Search);

/***/ },
/* 398 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var punycode = __webpack_require__(399);
	var util = __webpack_require__(400);
	
	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;
	
	exports.Url = Url;
	
	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}
	
	// Reference: RFC 3986, RFC 1808, RFC 2396
	
	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,
	
	    // Special case for a simple path URL
	    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
	
	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
	
	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
	
	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__(401);
	
	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && util.isObject(url) && url instanceof Url) return url;
	
	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}
	
	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!util.isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }
	
	  // Copy chrome, IE, opera backslash-handling behavior.
	  // Back slashes before the query string get converted to forward slashes
	  // See: https://code.google.com/p/chromium/issues/detail?id=25916
	  var queryIndex = url.indexOf('?'),
	      splitter =
	          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
	      uSplit = url.split(splitter),
	      slashRegex = /\\/g;
	  uSplit[0] = uSplit[0].replace(slashRegex, '/');
	  url = uSplit.join(splitter);
	
	  var rest = url;
	
	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();
	
	  if (!slashesDenoteHost && url.split('#').length === 1) {
	    // Try fast path regexp
	    var simplePath = simplePathPattern.exec(rest);
	    if (simplePath) {
	      this.path = rest;
	      this.href = rest;
	      this.pathname = simplePath[1];
	      if (simplePath[2]) {
	        this.search = simplePath[2];
	        if (parseQueryString) {
	          this.query = querystring.parse(this.search.substr(1));
	        } else {
	          this.query = this.search.substr(1);
	        }
	      } else if (parseQueryString) {
	        this.search = '';
	        this.query = {};
	      }
	      return this;
	    }
	  }
	
	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }
	
	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }
	
	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {
	
	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c
	
	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.
	
	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	
	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }
	
	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }
	
	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;
	
	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);
	
	    // pull out port.
	    this.parseHost();
	
	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';
	
	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';
	
	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }
	
	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }
	
	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a punycoded representation of "domain".
	      // It only converts parts of the domain name that
	      // have non-ASCII characters, i.e. it doesn't matter if
	      // you call it with a domain that already is ASCII-only.
	      this.hostname = punycode.toASCII(this.hostname);
	    }
	
	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;
	
	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }
	
	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {
	
	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      if (rest.indexOf(ae) === -1)
	        continue;
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }
	
	
	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }
	
	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }
	
	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};
	
	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (util.isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}
	
	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }
	
	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';
	
	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }
	
	  if (this.query &&
	      util.isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }
	
	  var search = this.search || (query && ('?' + query)) || '';
	
	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';
	
	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }
	
	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;
	
	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');
	
	  return protocol + host + pathname + search + hash;
	};
	
	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}
	
	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};
	
	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}
	
	Url.prototype.resolveObject = function(relative) {
	  if (util.isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }
	
	  var result = new Url();
	  var tkeys = Object.keys(this);
	  for (var tk = 0; tk < tkeys.length; tk++) {
	    var tkey = tkeys[tk];
	    result[tkey] = this[tkey];
	  }
	
	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;
	
	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }
	
	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    var rkeys = Object.keys(relative);
	    for (var rk = 0; rk < rkeys.length; rk++) {
	      var rkey = rkeys[rk];
	      if (rkey !== 'protocol')
	        result[rkey] = relative[rkey];
	    }
	
	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }
	
	    result.href = result.format();
	    return result;
	  }
	
	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      var keys = Object.keys(relative);
	      for (var v = 0; v < keys.length; v++) {
	        var k = keys[v];
	        result[k] = relative[k];
	      }
	      result.href = result.format();
	      return result;
	    }
	
	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }
	
	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];
	
	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }
	
	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!util.isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especially happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host || srcPath.length > 1) &&
	      (last === '.' || last === '..') || last === '');
	
	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last === '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }
	
	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }
	
	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }
	
	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');
	
	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especially happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }
	
	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);
	
	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }
	
	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }
	
	  //to support request.http
	  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};
	
	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};


/***/ },
/* 399 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {
	
		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}
	
		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,
	
		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
	
		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'
	
		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
	
		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},
	
		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,
	
		/** Temporary variable */
		key;
	
		/*--------------------------------------------------------------------------*/
	
		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}
	
		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}
	
		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}
	
		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}
	
		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}
	
		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}
	
		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}
	
		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;
	
			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.
	
			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}
	
			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}
	
			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.
	
			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {
	
				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {
	
					if (index >= inputLength) {
						error('invalid-input');
					}
	
					digit = basicToDigit(input.charCodeAt(index++));
	
					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}
	
					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	
					if (digit < t) {
						break;
					}
	
					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}
	
					w *= baseMinusT;
	
				}
	
				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);
	
				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}
	
				n += floor(i / out);
				i %= out;
	
				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);
	
			}
	
			return ucs2encode(output);
		}
	
		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;
	
			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);
	
			// Cache the length
			inputLength = input.length;
	
			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;
	
			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}
	
			handledCPCount = basicLength = output.length;
	
			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.
	
			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}
	
			// Main encoding loop:
			while (handledCPCount < inputLength) {
	
				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}
	
				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}
	
				delta += (m - n) * handledCPCountPlusOne;
				n = m;
	
				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];
	
					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}
	
					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}
	
						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}
	
				++delta;
				++n;
	
			}
			return output.join('');
		}
	
		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}
	
		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}
	
		/*--------------------------------------------------------------------------*/
	
		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};
	
		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(51)(module), (function() { return this; }())))

/***/ },
/* 400 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	  isString: function(arg) {
	    return typeof(arg) === 'string';
	  },
	  isObject: function(arg) {
	    return typeof(arg) === 'object' && arg !== null;
	  },
	  isNull: function(arg) {
	    return arg === null;
	  },
	  isNullOrUndefined: function(arg) {
	    return arg == null;
	  }
	};


/***/ },
/* 401 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.decode = exports.parse = __webpack_require__(402);
	exports.encode = exports.stringify = __webpack_require__(403);


/***/ },
/* 402 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};
	
	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }
	
	  var regexp = /\+/g;
	  qs = qs.split(sep);
	
	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }
	
	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }
	
	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;
	
	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }
	
	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);
	
	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }
	
	  return obj;
	};


/***/ },
/* 403 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;
	
	    case 'boolean':
	      return v ? 'true' : 'false';
	
	    case 'number':
	      return isFinite(v) ? v : '';
	
	    default:
	      return '';
	  }
	};
	
	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }
	
	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);
	
	  }
	
	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },
/* 404 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 405 */,
/* 406 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	var dom = React.DOM,
	    PropTypes = React.PropTypes;
	
	var _require = __webpack_require__(407),
	    filter = _require.filter;
	
	var classnames = __webpack_require__(413);
	var Svg = __webpack_require__(414);
	var CloseButton = __webpack_require__(444);
	
	__webpack_require__(447);
	
	var INITIAL_SELECTED_INDEX = 0;
	
	var Autocomplete = React.createClass({
	  propTypes: {
	    selectItem: PropTypes.func,
	    items: PropTypes.array,
	    close: PropTypes.func,
	    inputValue: PropTypes.string
	  },
	
	  displayName: "Autocomplete",
	
	  getInitialState() {
	    return {
	      inputValue: this.props.inputValue,
	      selectedIndex: INITIAL_SELECTED_INDEX
	    };
	  },
	
	  componentDidMount() {
	    var endOfInput = this.state.inputValue.length;
	    this.refs.searchInput.focus();
	    this.refs.searchInput.setSelectionRange(endOfInput, endOfInput);
	  },
	
	  componentDidUpdate() {
	    this.scrollList();
	  },
	
	  scrollList() {
	    var resultsEl = this.refs.results;
	    if (!resultsEl || resultsEl.children.length === 0) {
	      return;
	    }
	
	    var resultsHeight = resultsEl.clientHeight;
	    var itemHeight = resultsEl.children[0].clientHeight;
	    var numVisible = resultsHeight / itemHeight;
	    var positionsToScroll = this.state.selectedIndex - numVisible + 1;
	    var itemOffset = resultsHeight % itemHeight;
	    var scroll = positionsToScroll * (itemHeight + 2) + itemOffset;
	
	    resultsEl.scrollTop = Math.max(0, scroll);
	  },
	
	  getSearchResults() {
	    var inputValue = this.state.inputValue;
	
	    if (inputValue == "") {
	      return [];
	    }
	    return filter(this.props.items, this.state.inputValue, {
	      key: "value"
	    });
	  },
	
	  onKeyDown(e) {
	    var searchResults = this.getSearchResults(),
	        resultCount = searchResults.length;
	
	    if (e.key === "ArrowUp") {
	      this.setState({
	        selectedIndex: Math.max(0, this.state.selectedIndex - 1)
	      });
	      e.preventDefault();
	    } else if (e.key === "ArrowDown") {
	      this.setState({
	        selectedIndex: Math.min(resultCount - 1, this.state.selectedIndex + 1)
	      });
	      e.preventDefault();
	    } else if (e.key === "Enter") {
	      if (searchResults.length) {
	        this.props.selectItem(searchResults[this.state.selectedIndex]);
	      } else {
	        this.props.close(this.state.inputValue);
	      }
	      e.preventDefault();
	    } else if (e.key === "Tab") {
	      this.props.close(this.state.inputValue);
	      e.preventDefault();
	    }
	  },
	
	  renderSearchItem(result, index) {
	    return dom.li({
	      onClick: () => this.props.selectItem(result),
	      key: `${ result.id }${ result.value }`,
	      title: result.value,
	      className: classnames({
	        selected: index === this.state.selectedIndex
	      })
	    }, dom.div({ className: "title" }, result.title), dom.div({ className: "subtitle" }, result.subtitle));
	  },
	
	  renderInput() {
	    return dom.input({
	      ref: "searchInput",
	      value: this.state.inputValue,
	      onChange: e => this.setState({
	        inputValue: e.target.value,
	        selectedIndex: INITIAL_SELECTED_INDEX
	      }),
	      onFocus: e => this.setState({ focused: true }),
	      onBlur: e => this.setState({ focused: false }),
	      onKeyDown: this.onKeyDown,
	      placeholder: L10N.getStr("sourceSearch.search")
	    });
	  },
	
	  renderResults(results) {
	    if (results.length) {
	      return dom.ul({ className: "results", ref: "results" }, results.map(this.renderSearchItem));
	    } else if (this.state.inputValue && !results.length) {
	      return dom.div({ className: "no-result-msg" }, Svg("sad-face"), L10N.getFormatStr("sourceSearch.noResults", this.state.inputValue));
	    }
	  },
	
	  renderSummary(searchResults) {
	    if (searchResults && searchResults.length === 0) {
	      return;
	    }
	
	    var resultCountSummary = "";
	    if (this.state.inputValue) {
	      resultCountSummary = L10N.getFormatStr("sourceSearch.resultsSummary", searchResults.length, this.state.inputValue);
	    }
	    return dom.div({ className: "results-summary" }, resultCountSummary);
	  },
	
	  render() {
	    var searchResults = this.getSearchResults();
	    return dom.div({ className: classnames({
	        autocomplete: true,
	        focused: this.state.focused
	      })
	    }, dom.div({ className: "searchinput-container" }, Svg("magnifying-glass"), this.renderInput(), CloseButton({
	      buttonClass: "big",
	      handleClick: e => this.props.close()
	    })), this.renderSummary(searchResults), this.renderResults(searchResults));
	  }
	});
	
	module.exports = Autocomplete;

/***/ },
/* 407 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {(function() {
	  var Query, defaultPathSeparator, filter, matcher, parseOptions, pathScorer, preparedQueryCache, scorer;
	
	  filter = __webpack_require__(408);
	
	  matcher = __webpack_require__(412);
	
	  scorer = __webpack_require__(409);
	
	  pathScorer = __webpack_require__(410);
	
	  Query = __webpack_require__(411);
	
	  preparedQueryCache = null;
	
	  defaultPathSeparator = (typeof process !== "undefined" && process !== null ? process.platform : void 0) === "win32" ? '\\' : '/';
	
	  module.exports = {
	    filter: function(candidates, query, options) {
	      if (options == null) {
	        options = {};
	      }
	      if (!((query != null ? query.length : void 0) && (candidates != null ? candidates.length : void 0))) {
	        return [];
	      }
	      options = parseOptions(options, query);
	      return filter(candidates, query, options);
	    },
	    score: function(string, query, options) {
	      if (options == null) {
	        options = {};
	      }
	      if (!((string != null ? string.length : void 0) && (query != null ? query.length : void 0))) {
	        return 0;
	      }
	      options = parseOptions(options, query);
	      if (options.usePathScoring) {
	        return pathScorer.score(string, query, options);
	      } else {
	        return scorer.score(string, query, options);
	      }
	    },
	    match: function(string, query, options) {
	      var _i, _ref, _results;
	      if (options == null) {
	        options = {};
	      }
	      if (!string) {
	        return [];
	      }
	      if (!query) {
	        return [];
	      }
	      if (string === query) {
	        return (function() {
	          _results = [];
	          for (var _i = 0, _ref = string.length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
	          return _results;
	        }).apply(this);
	      }
	      options = parseOptions(options, query);
	      return matcher.match(string, query, options);
	    },
	    wrap: function(string, query, options) {
	      if (options == null) {
	        options = {};
	      }
	      if (!string) {
	        return [];
	      }
	      if (!query) {
	        return [];
	      }
	      options = parseOptions(options, query);
	      return matcher.wrap(string, query, options);
	    },
	    prepareQuery: function(query, options) {
	      if (options == null) {
	        options = {};
	      }
	      options = parseOptions(options, query);
	      return options.preparedQuery;
	    }
	  };
	
	  parseOptions = function(options, query) {
	    if (options.allowErrors == null) {
	      options.allowErrors = false;
	    }
	    if (options.usePathScoring == null) {
	      options.usePathScoring = true;
	    }
	    if (options.useExtensionBonus == null) {
	      options.useExtensionBonus = false;
	    }
	    if (options.pathSeparator == null) {
	      options.pathSeparator = defaultPathSeparator;
	    }
	    if (options.optCharRegEx == null) {
	      options.optCharRegEx = null;
	    }
	    if (options.wrap == null) {
	      options.wrap = null;
	    }
	    if (options.preparedQuery == null) {
	      options.preparedQuery = preparedQueryCache && preparedQueryCache.query === query ? preparedQueryCache : (preparedQueryCache = new Query(query, options));
	    }
	    return options;
	  };
	
	}).call(this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(186)))

/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	  var Query, pathScorer, pluckCandidates, scorer, sortCandidates;
	
	  scorer = __webpack_require__(409);
	
	  pathScorer = __webpack_require__(410);
	
	  Query = __webpack_require__(411);
	
	  pluckCandidates = function(a) {
	    return a.candidate;
	  };
	
	  sortCandidates = function(a, b) {
	    return b.score - a.score;
	  };
	
	  module.exports = function(candidates, query, options) {
	    var bKey, candidate, key, maxInners, maxResults, score, scoreProvider, scoredCandidates, spotLeft, string, usePathScoring, _i, _len;
	    scoredCandidates = [];
	    key = options.key, maxResults = options.maxResults, maxInners = options.maxInners, usePathScoring = options.usePathScoring;
	    spotLeft = (maxInners != null) && maxInners > 0 ? maxInners : candidates.length + 1;
	    bKey = key != null;
	    scoreProvider = usePathScoring ? pathScorer : scorer;
	    for (_i = 0, _len = candidates.length; _i < _len; _i++) {
	      candidate = candidates[_i];
	      string = bKey ? candidate[key] : candidate;
	      if (!string) {
	        continue;
	      }
	      score = scoreProvider.score(string, query, options);
	      if (score > 0) {
	        scoredCandidates.push({
	          candidate: candidate,
	          score: score
	        });
	        if (!--spotLeft) {
	          break;
	        }
	      }
	    }
	    scoredCandidates.sort(sortCandidates);
	    candidates = scoredCandidates.map(pluckCandidates);
	    if (maxResults != null) {
	      candidates = candidates.slice(0, maxResults);
	    }
	    return candidates;
	  };
	
	}).call(this);


/***/ },
/* 409 */
/***/ function(module, exports) {

	(function() {
	  var AcronymResult, computeScore, emptyAcronymResult, isAcronymFullWord, isMatch, isSeparator, isWordEnd, isWordStart, miss_coeff, pos_bonus, scoreAcronyms, scoreCharacter, scoreConsecutives, scoreExact, scoreExactMatch, scorePattern, scorePosition, scoreSize, tau_size, wm;
	
	  wm = 150;
	
	  pos_bonus = 20;
	
	  tau_size = 85;
	
	  miss_coeff = 0.75;
	
	  exports.score = function(string, query, options) {
	    var allowErrors, preparedQuery, score, string_lw;
	    preparedQuery = options.preparedQuery, allowErrors = options.allowErrors;
	    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {
	      return 0;
	    }
	    string_lw = string.toLowerCase();
	    score = computeScore(string, string_lw, preparedQuery);
	    return Math.ceil(score);
	  };
	
	  exports.isMatch = isMatch = function(subject, query_lw, query_up) {
	    var i, j, m, n, qj_lw, qj_up, si;
	    m = subject.length;
	    n = query_lw.length;
	    if (!m || n > m) {
	      return false;
	    }
	    i = -1;
	    j = -1;
	    while (++j < n) {
	      qj_lw = query_lw.charCodeAt(j);
	      qj_up = query_up.charCodeAt(j);
	      while (++i < m) {
	        si = subject.charCodeAt(i);
	        if (si === qj_lw || si === qj_up) {
	          break;
	        }
	      }
	      if (i === m) {
	        return false;
	      }
	    }
	    return true;
	  };
	
	  exports.computeScore = computeScore = function(subject, subject_lw, preparedQuery) {
	    var acro, acro_score, align, csc_diag, csc_invalid, csc_row, csc_score, i, j, m, miss_budget, miss_left, mm, n, pos, query, query_lw, record_miss, score, score_diag, score_row, score_up, si_lw, start, sz;
	    query = preparedQuery.query;
	    query_lw = preparedQuery.query_lw;
	    m = subject.length;
	    n = query.length;
	    acro = scoreAcronyms(subject, subject_lw, query, query_lw);
	    acro_score = acro.score;
	    if (acro.count === n) {
	      return scoreExact(n, m, acro_score, acro.pos);
	    }
	    pos = subject_lw.indexOf(query_lw);
	    if (pos > -1) {
	      return scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m);
	    }
	    score_row = new Array(n);
	    csc_row = new Array(n);
	    sz = scoreSize(n, m);
	    miss_budget = Math.ceil(miss_coeff * n) + 5;
	    miss_left = miss_budget;
	    j = -1;
	    while (++j < n) {
	      score_row[j] = 0;
	      csc_row[j] = 0;
	    }
	    i = subject_lw.indexOf(query_lw[0]);
	    if (i > -1) {
	      i--;
	    }
	    mm = subject_lw.lastIndexOf(query_lw[n - 1], m);
	    if (mm > i) {
	      m = mm + 1;
	    }
	    csc_invalid = true;
	    while (++i < m) {
	      si_lw = subject_lw[i];
	      if (preparedQuery.charCodes[si_lw.charCodeAt(0)] == null) {
	        if (csc_invalid !== true) {
	          j = -1;
	          while (++j < n) {
	            csc_row[j] = 0;
	          }
	          csc_invalid = true;
	        }
	        continue;
	      }
	      score = 0;
	      score_diag = 0;
	      csc_diag = 0;
	      record_miss = true;
	      csc_invalid = false;
	      j = -1;
	      while (++j < n) {
	        score_up = score_row[j];
	        if (score_up > score) {
	          score = score_up;
	        }
	        csc_score = 0;
	        if (query_lw[j] === si_lw) {
	          start = isWordStart(i, subject, subject_lw);
	          csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);
	          align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);
	          if (align > score) {
	            score = align;
	            miss_left = miss_budget;
	          } else {
	            if (record_miss && --miss_left <= 0) {
	              return score_row[n - 1] * sz;
	            }
	            record_miss = false;
	          }
	        }
	        score_diag = score_up;
	        csc_diag = csc_row[j];
	        csc_row[j] = csc_score;
	        score_row[j] = score;
	      }
	    }
	    score = score_row[n - 1];
	    return score * sz;
	  };
	
	  exports.isWordStart = isWordStart = function(pos, subject, subject_lw) {
	    var curr_s, prev_s;
	    if (pos === 0) {
	      return true;
	    }
	    curr_s = subject[pos];
	    prev_s = subject[pos - 1];
	    return isSeparator(prev_s) || (curr_s !== subject_lw[pos] && prev_s === subject_lw[pos - 1]);
	  };
	
	  exports.isWordEnd = isWordEnd = function(pos, subject, subject_lw, len) {
	    var curr_s, next_s;
	    if (pos === len - 1) {
	      return true;
	    }
	    curr_s = subject[pos];
	    next_s = subject[pos + 1];
	    return isSeparator(next_s) || (curr_s === subject_lw[pos] && next_s !== subject_lw[pos + 1]);
	  };
	
	  isSeparator = function(c) {
	    return c === ' ' || c === '.' || c === '-' || c === '_' || c === '/' || c === '\\';
	  };
	
	  scorePosition = function(pos) {
	    var sc;
	    if (pos < pos_bonus) {
	      sc = pos_bonus - pos;
	      return 100 + sc * sc;
	    } else {
	      return Math.max(100 + pos_bonus - pos, 0);
	    }
	  };
	
	  exports.scoreSize = scoreSize = function(n, m) {
	    return tau_size / (tau_size + Math.abs(m - n));
	  };
	
	  scoreExact = function(n, m, quality, pos) {
	    return 2 * n * (wm * quality + scorePosition(pos)) * scoreSize(n, m);
	  };
	
	  exports.scorePattern = scorePattern = function(count, len, sameCase, start, end) {
	    var bonus, sz;
	    sz = count;
	    bonus = 6;
	    if (sameCase === count) {
	      bonus += 2;
	    }
	    if (start) {
	      bonus += 3;
	    }
	    if (end) {
	      bonus += 1;
	    }
	    if (count === len) {
	      if (start) {
	        if (sameCase === len) {
	          sz += 2;
	        } else {
	          sz += 1;
	        }
	      }
	      if (end) {
	        bonus += 1;
	      }
	    }
	    return sameCase + sz * (sz + bonus);
	  };
	
	  exports.scoreCharacter = scoreCharacter = function(i, j, start, acro_score, csc_score) {
	    var posBonus;
	    posBonus = scorePosition(i);
	    if (start) {
	      return posBonus + wm * ((acro_score > csc_score ? acro_score : csc_score) + 10);
	    }
	    return posBonus + wm * csc_score;
	  };
	
	  exports.scoreConsecutives = scoreConsecutives = function(subject, subject_lw, query, query_lw, i, j, startOfWord) {
	    var k, m, mi, n, nj, sameCase, sz;
	    m = subject.length;
	    n = query.length;
	    mi = m - i;
	    nj = n - j;
	    k = mi < nj ? mi : nj;
	    sameCase = 0;
	    sz = 0;
	    if (query[j] === subject[i]) {
	      sameCase++;
	    }
	    while (++sz < k && query_lw[++j] === subject_lw[++i]) {
	      if (query[j] === subject[i]) {
	        sameCase++;
	      }
	    }
	    if (sz === 1) {
	      return 1 + 2 * sameCase;
	    }
	    return scorePattern(sz, n, sameCase, startOfWord, isWordEnd(i, subject, subject_lw, m));
	  };
	
	  exports.scoreExactMatch = scoreExactMatch = function(subject, subject_lw, query, query_lw, pos, n, m) {
	    var end, i, pos2, sameCase, start;
	    start = isWordStart(pos, subject, subject_lw);
	    if (!start) {
	      pos2 = subject_lw.indexOf(query_lw, pos + 1);
	      if (pos2 > -1) {
	        start = isWordStart(pos2, subject, subject_lw);
	        if (start) {
	          pos = pos2;
	        }
	      }
	    }
	    i = -1;
	    sameCase = 0;
	    while (++i < n) {
	      if (query[pos + i] === subject[i]) {
	        sameCase++;
	      }
	    }
	    end = isWordEnd(pos + n - 1, subject, subject_lw, m);
	    return scoreExact(n, m, scorePattern(n, n, sameCase, start, end), pos);
	  };
	
	  AcronymResult = (function() {
	    function AcronymResult(score, pos, count) {
	      this.score = score;
	      this.pos = pos;
	      this.count = count;
	    }
	
	    return AcronymResult;
	
	  })();
	
	  emptyAcronymResult = new AcronymResult(0, 0.1, 0);
	
	  exports.scoreAcronyms = scoreAcronyms = function(subject, subject_lw, query, query_lw) {
	    var count, fullWord, i, j, m, n, qj_lw, sameCase, score, sepCount, sumPos;
	    m = subject.length;
	    n = query.length;
	    if (!(m > 1 && n > 1)) {
	      return emptyAcronymResult;
	    }
	    count = 0;
	    sepCount = 0;
	    sumPos = 0;
	    sameCase = 0;
	    i = -1;
	    j = -1;
	    while (++j < n) {
	      qj_lw = query_lw[j];
	      if (isSeparator(qj_lw)) {
	        i = subject_lw.indexOf(qj_lw, i + 1);
	        if (i > -1) {
	          sepCount++;
	          continue;
	        } else {
	          break;
	        }
	      }
	      while (++i < m) {
	        if (qj_lw === subject_lw[i] && isWordStart(i, subject, subject_lw)) {
	          if (query[j] === subject[i]) {
	            sameCase++;
	          }
	          sumPos += i;
	          count++;
	          break;
	        }
	      }
	      if (i === m) {
	        break;
	      }
	    }
	    if (count < 2) {
	      return emptyAcronymResult;
	    }
	    fullWord = count === n ? isAcronymFullWord(subject, subject_lw, query, count) : false;
	    score = scorePattern(count, n, sameCase, true, fullWord);
	    return new AcronymResult(score, sumPos / count, count + sepCount);
	  };
	
	  isAcronymFullWord = function(subject, subject_lw, query, nbAcronymInQuery) {
	    var count, i, m, n;
	    m = subject.length;
	    n = query.length;
	    count = 0;
	    if (m > 12 * n) {
	      return false;
	    }
	    i = -1;
	    while (++i < m) {
	      if (isWordStart(i, subject, subject_lw) && ++count > nbAcronymInQuery) {
	        return false;
	      }
	    }
	    return true;
	  };
	
	}).call(this);


/***/ },
/* 410 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	  var computeScore, countDir, file_coeff, getExtension, getExtensionScore, isMatch, scorePath, scoreSize, tau_depth, _ref;
	
	  _ref = __webpack_require__(409), isMatch = _ref.isMatch, computeScore = _ref.computeScore, scoreSize = _ref.scoreSize;
	
	  tau_depth = 13;
	
	  file_coeff = 1.2;
	
	  exports.score = function(string, query, options) {
	    var allowErrors, preparedQuery, score, string_lw;
	    preparedQuery = options.preparedQuery, allowErrors = options.allowErrors;
	    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {
	      return 0;
	    }
	    string_lw = string.toLowerCase();
	    score = computeScore(string, string_lw, preparedQuery);
	    score = scorePath(string, string_lw, score, options);
	    return Math.ceil(score);
	  };
	
	  scorePath = function(subject, subject_lw, fullPathScore, options) {
	    var alpha, basePathScore, basePos, depth, end, extAdjust, fileLength, pathSeparator, preparedQuery, useExtensionBonus;
	    if (fullPathScore === 0) {
	      return 0;
	    }
	    preparedQuery = options.preparedQuery, useExtensionBonus = options.useExtensionBonus, pathSeparator = options.pathSeparator;
	    end = subject.length - 1;
	    while (subject[end] === pathSeparator) {
	      end--;
	    }
	    basePos = subject.lastIndexOf(pathSeparator, end);
	    fileLength = end - basePos;
	    extAdjust = 1.0;
	    if (useExtensionBonus) {
	      extAdjust += getExtensionScore(subject_lw, preparedQuery.ext, basePos, end, 2);
	      fullPathScore *= extAdjust;
	    }
	    if (basePos === -1) {
	      return fullPathScore;
	    }
	    depth = preparedQuery.depth;
	    while (basePos > -1 && depth-- > 0) {
	      basePos = subject.lastIndexOf(pathSeparator, basePos - 1);
	    }
	    basePathScore = basePos === -1 ? fullPathScore : extAdjust * computeScore(subject.slice(basePos + 1, end + 1), subject_lw.slice(basePos + 1, end + 1), preparedQuery);
	    alpha = 0.5 * tau_depth / (tau_depth + countDir(subject, end + 1, pathSeparator));
	    return alpha * basePathScore + (1 - alpha) * fullPathScore * scoreSize(0, file_coeff * fileLength);
	  };
	
	  exports.countDir = countDir = function(path, end, pathSeparator) {
	    var count, i;
	    if (end < 1) {
	      return 0;
	    }
	    count = 0;
	    i = -1;
	    while (++i < end && path[i] === pathSeparator) {
	      continue;
	    }
	    while (++i < end) {
	      if (path[i] === pathSeparator) {
	        count++;
	        while (++i < end && path[i] === pathSeparator) {
	          continue;
	        }
	      }
	    }
	    return count;
	  };
	
	  exports.getExtension = getExtension = function(str) {
	    var pos;
	    pos = str.lastIndexOf(".");
	    if (pos < 0) {
	      return "";
	    } else {
	      return str.substr(pos + 1);
	    }
	  };
	
	  getExtensionScore = function(candidate, ext, startPos, endPos, maxDepth) {
	    var m, matched, n, pos;
	    if (!ext.length) {
	      return 0;
	    }
	    pos = candidate.lastIndexOf(".", endPos);
	    if (!(pos > startPos)) {
	      return 0;
	    }
	    n = ext.length;
	    m = endPos - pos;
	    if (m < n) {
	      n = m;
	      m = ext.length;
	    }
	    pos++;
	    matched = -1;
	    while (++matched < n) {
	      if (candidate[pos + matched] !== ext[matched]) {
	        break;
	      }
	    }
	    if (matched === 0 && maxDepth > 0) {
	      return 0.9 * getExtensionScore(candidate, ext, startPos, pos - 2, maxDepth - 1);
	    }
	    return matched / m;
	  };
	
	}).call(this);


/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	  var Query, coreChars, countDir, getCharCodes, getExtension, opt_char_re, truncatedUpperCase, _ref;
	
	  _ref = __webpack_require__(410), countDir = _ref.countDir, getExtension = _ref.getExtension;
	
	  module.exports = Query = (function() {
	    function Query(query, _arg) {
	      var optCharRegEx, pathSeparator, _ref1;
	      _ref1 = _arg != null ? _arg : {}, optCharRegEx = _ref1.optCharRegEx, pathSeparator = _ref1.pathSeparator;
	      if (!(query && query.length)) {
	        return null;
	      }
	      this.query = query;
	      this.query_lw = query.toLowerCase();
	      this.core = coreChars(query, optCharRegEx);
	      this.core_lw = this.core.toLowerCase();
	      this.core_up = truncatedUpperCase(this.core);
	      this.depth = countDir(query, query.length, pathSeparator);
	      this.ext = getExtension(this.query_lw);
	      this.charCodes = getCharCodes(this.query_lw);
	    }
	
	    return Query;
	
	  })();
	
	  opt_char_re = /[ _\-:\/\\]/g;
	
	  coreChars = function(query, optCharRegEx) {
	    if (optCharRegEx == null) {
	      optCharRegEx = opt_char_re;
	    }
	    return query.replace(optCharRegEx, '');
	  };
	
	  truncatedUpperCase = function(str) {
	    var char, upper, _i, _len;
	    upper = "";
	    for (_i = 0, _len = str.length; _i < _len; _i++) {
	      char = str[_i];
	      upper += char.toUpperCase()[0];
	    }
	    return upper;
	  };
	
	  getCharCodes = function(str) {
	    var charCodes, i, len;
	    len = str.length;
	    i = -1;
	    charCodes = [];
	    while (++i < len) {
	      charCodes[str.charCodeAt(i)] = true;
	    }
	    return charCodes;
	  };
	
	}).call(this);


/***/ },
/* 412 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	  var basenameMatch, computeMatch, isMatch, isWordStart, match, mergeMatches, scoreAcronyms, scoreCharacter, scoreConsecutives, _ref;
	
	  _ref = __webpack_require__(409), isMatch = _ref.isMatch, isWordStart = _ref.isWordStart, scoreConsecutives = _ref.scoreConsecutives, scoreCharacter = _ref.scoreCharacter, scoreAcronyms = _ref.scoreAcronyms;
	
	  exports.match = match = function(string, query, options) {
	    var allowErrors, baseMatches, matches, pathSeparator, preparedQuery, string_lw;
	    allowErrors = options.allowErrors, preparedQuery = options.preparedQuery, pathSeparator = options.pathSeparator;
	    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {
	      return [];
	    }
	    string_lw = string.toLowerCase();
	    matches = computeMatch(string, string_lw, preparedQuery);
	    if (matches.length === 0) {
	      return matches;
	    }
	    if (string.indexOf(pathSeparator) > -1) {
	      baseMatches = basenameMatch(string, string_lw, preparedQuery, pathSeparator);
	      matches = mergeMatches(matches, baseMatches);
	    }
	    return matches;
	  };
	
	  exports.wrap = function(string, query, options) {
	    var matchIndex, matchPos, matchPositions, output, strPos, tagClass, tagClose, tagOpen, _ref1;
	    if ((options.wrap != null)) {
	      _ref1 = options.wrap, tagClass = _ref1.tagClass, tagOpen = _ref1.tagOpen, tagClose = _ref1.tagClose;
	    }
	    if (tagClass == null) {
	      tagClass = 'highlight';
	    }
	    if (tagOpen == null) {
	      tagOpen = '<strong class="' + tagClass + '">';
	    }
	    if (tagClose == null) {
	      tagClose = '</strong>';
	    }
	    if (string === query) {
	      return tagOpen + string + tagClose;
	    }
	    matchPositions = match(string, query, options);
	    if (matchPositions.length === 0) {
	      return string;
	    }
	    output = '';
	    matchIndex = -1;
	    strPos = 0;
	    while (++matchIndex < matchPositions.length) {
	      matchPos = matchPositions[matchIndex];
	      if (matchPos > strPos) {
	        output += string.substring(strPos, matchPos);
	        strPos = matchPos;
	      }
	      while (++matchIndex < matchPositions.length) {
	        if (matchPositions[matchIndex] === matchPos + 1) {
	          matchPos++;
	        } else {
	          matchIndex--;
	          break;
	        }
	      }
	      matchPos++;
	      if (matchPos > strPos) {
	        output += tagOpen;
	        output += string.substring(strPos, matchPos);
	        output += tagClose;
	        strPos = matchPos;
	      }
	    }
	    if (strPos < string.length - 1) {
	      output += string.substring(strPos);
	    }
	    return output;
	  };
	
	  basenameMatch = function(subject, subject_lw, preparedQuery, pathSeparator) {
	    var basePos, depth, end;
	    end = subject.length - 1;
	    while (subject[end] === pathSeparator) {
	      end--;
	    }
	    basePos = subject.lastIndexOf(pathSeparator, end);
	    if (basePos === -1) {
	      return [];
	    }
	    depth = preparedQuery.depth;
	    while (depth-- > 0) {
	      basePos = subject.lastIndexOf(pathSeparator, basePos - 1);
	      if (basePos === -1) {
	        return [];
	      }
	    }
	    basePos++;
	    end++;
	    return computeMatch(subject.slice(basePos, end), subject_lw.slice(basePos, end), preparedQuery, basePos);
	  };
	
	  mergeMatches = function(a, b) {
	    var ai, bj, i, j, m, n, out;
	    m = a.length;
	    n = b.length;
	    if (n === 0) {
	      return a.slice();
	    }
	    if (m === 0) {
	      return b.slice();
	    }
	    i = -1;
	    j = 0;
	    bj = b[j];
	    out = [];
	    while (++i < m) {
	      ai = a[i];
	      while (bj <= ai && ++j < n) {
	        if (bj < ai) {
	          out.push(bj);
	        }
	        bj = b[j];
	      }
	      out.push(ai);
	    }
	    while (j < n) {
	      out.push(b[j++]);
	    }
	    return out;
	  };
	
	  computeMatch = function(subject, subject_lw, preparedQuery, offset) {
	    var DIAGONAL, LEFT, STOP, UP, acro_score, align, backtrack, csc_diag, csc_row, csc_score, i, j, m, matches, move, n, pos, query, query_lw, score, score_diag, score_row, score_up, si_lw, start, trace;
	    if (offset == null) {
	      offset = 0;
	    }
	    query = preparedQuery.query;
	    query_lw = preparedQuery.query_lw;
	    m = subject.length;
	    n = query.length;
	    acro_score = scoreAcronyms(subject, subject_lw, query, query_lw).score;
	    score_row = new Array(n);
	    csc_row = new Array(n);
	    STOP = 0;
	    UP = 1;
	    LEFT = 2;
	    DIAGONAL = 3;
	    trace = new Array(m * n);
	    pos = -1;
	    j = -1;
	    while (++j < n) {
	      score_row[j] = 0;
	      csc_row[j] = 0;
	    }
	    i = -1;
	    while (++i < m) {
	      score = 0;
	      score_up = 0;
	      csc_diag = 0;
	      si_lw = subject_lw[i];
	      j = -1;
	      while (++j < n) {
	        csc_score = 0;
	        align = 0;
	        score_diag = score_up;
	        if (query_lw[j] === si_lw) {
	          start = isWordStart(i, subject, subject_lw);
	          csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);
	          align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);
	        }
	        score_up = score_row[j];
	        csc_diag = csc_row[j];
	        if (score > score_up) {
	          move = LEFT;
	        } else {
	          score = score_up;
	          move = UP;
	        }
	        if (align > score) {
	          score = align;
	          move = DIAGONAL;
	        } else {
	          csc_score = 0;
	        }
	        score_row[j] = score;
	        csc_row[j] = csc_score;
	        trace[++pos] = score > 0 ? move : STOP;
	      }
	    }
	    i = m - 1;
	    j = n - 1;
	    pos = i * n + j;
	    backtrack = true;
	    matches = [];
	    while (backtrack && i >= 0 && j >= 0) {
	      switch (trace[pos]) {
	        case UP:
	          i--;
	          pos -= n;
	          break;
	        case LEFT:
	          j--;
	          pos--;
	          break;
	        case DIAGONAL:
	          matches.push(i + offset);
	          j--;
	          i--;
	          pos -= n + 1;
	          break;
	        default:
	          backtrack = false;
	      }
	    }
	    matches.reverse();
	    return matches;
	  };
	
	}).call(this);


/***/ },
/* 413 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2016 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */
	
	(function () {
		'use strict';
	
		var hasOwn = {}.hasOwnProperty;
	
		function classNames () {
			var classes = [];
	
			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;
	
				var argType = typeof arg;
	
				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					classes.push(classNames.apply(null, arg));
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}
	
			return classes.join(' ');
		}
	
		if (typeof module !== 'undefined' && module.exports) {
			module.exports = classNames;
		} else if (true) {
			// register as 'classnames', consistent with npm package name
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			window.classNames = classNames;
		}
	}());


/***/ },
/* 414 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * This file maps the SVG React Components in the assets/images directory.
	 */
	var Svg = __webpack_require__(415);
	
	__webpack_require__(442);
	
	module.exports = Svg;

/***/ },
/* 415 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	var InlineSVG = __webpack_require__(416);
	
	var svg = {
	  "angle-brackets": __webpack_require__(417),
	  "arrow": __webpack_require__(418),
	  "blackBox": __webpack_require__(419),
	  "breakpoint": __webpack_require__(420),
	  "close": __webpack_require__(421),
	  "domain": __webpack_require__(422),
	  "file": __webpack_require__(423),
	  "folder": __webpack_require__(424),
	  "globe": __webpack_require__(425),
	  "magnifying-glass": __webpack_require__(426),
	  "pause": __webpack_require__(427),
	  "pause-exceptions": __webpack_require__(428),
	  "plus": __webpack_require__(429),
	  "prettyPrint": __webpack_require__(430),
	  "resume": __webpack_require__(431),
	  "settings": __webpack_require__(432),
	  "stepIn": __webpack_require__(433),
	  "stepOut": __webpack_require__(434),
	  "stepOver": __webpack_require__(435),
	  "subSettings": __webpack_require__(436),
	  "toggleBreakpoints": __webpack_require__(437),
	  "togglePanes": __webpack_require__(438),
	  "worker": __webpack_require__(439),
	  "sad-face": __webpack_require__(440),
	  "refresh": __webpack_require__(441)
	};
	
	module.exports = function (name, props) {
	  // eslint-disable-line
	  if (!svg[name]) {
	    throw new Error("Unknown SVG: " + name);
	  }
	  var className = name;
	  if (props && props.className) {
	    className = `${ name } ${ props.className }`;
	  }
	  if (name === "subSettings") {
	    className = "";
	  }
	  props = Object.assign({}, props, { className, src: svg[name] });
	  return React.createElement(InlineSVG, props);
	};

/***/ },
/* 416 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	    value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var DOMParser = typeof window !== 'undefined' && window.DOMParser;
	var process = process || {};
	process.env = process.env || {};
	var parserAvailable = typeof DOMParser !== 'undefined' && DOMParser.prototype != null && DOMParser.prototype.parseFromString != null;
	
	if ("production" !== process.env.NODE_ENV && !parserAvailable) {
	    console.info('<InlineSVG />: `raw` prop works only when `window.DOMParser` exists.');
	}
	
	function isParsable(src) {
	    // kinda naive but meh, ain't gonna use full-blown parser for this
	    return parserAvailable && typeof src === 'string' && src.trim().substr(0, 4) === '<svg';
	}
	
	// parse SVG string using `DOMParser`
	function parseFromSVGString(src) {
	    var parser = new DOMParser();
	    return parser.parseFromString(src, "image/svg+xml");
	}
	
	// Transform DOM prop/attr names applicable to `<svg>` element but react-limited
	function switchSVGAttrToReactProp(propName) {
	    switch (propName) {
	        case 'class':
	            return 'className';
	        default:
	            return propName;
	    }
	}
	
	var InlineSVG = (function (_React$Component) {
	    _inherits(InlineSVG, _React$Component);
	
	    _createClass(InlineSVG, null, [{
	        key: 'defaultProps',
	        value: {
	            element: 'i',
	            raw: false,
	            src: ''
	        },
	        enumerable: true
	    }, {
	        key: 'propTypes',
	        value: {
	            src: _react2['default'].PropTypes.string.isRequired,
	            element: _react2['default'].PropTypes.string,
	            raw: _react2['default'].PropTypes.bool
	        },
	        enumerable: true
	    }]);
	
	    function InlineSVG(props) {
	        _classCallCheck(this, InlineSVG);
	
	        _get(Object.getPrototypeOf(InlineSVG.prototype), 'constructor', this).call(this, props);
	        this._extractSVGProps = this._extractSVGProps.bind(this);
	    }
	
	    // Serialize `Attr` objects in `NamedNodeMap`
	
	    _createClass(InlineSVG, [{
	        key: '_serializeAttrs',
	        value: function _serializeAttrs(map) {
	            var ret = {};
	            var prop = undefined;
	            for (var i = 0; i < map.length; i++) {
	                prop = switchSVGAttrToReactProp(map[i].name);
	                ret[prop] = map[i].value;
	            }
	            return ret;
	        }
	
	        // get <svg /> element props
	    }, {
	        key: '_extractSVGProps',
	        value: function _extractSVGProps(src) {
	            var map = parseFromSVGString(src).documentElement.attributes;
	            return map.length > 0 ? this._serializeAttrs(map) : null;
	        }
	
	        // get content inside <svg> element.
	    }, {
	        key: '_stripSVG',
	        value: function _stripSVG(src) {
	            return parseFromSVGString(src).documentElement.innerHTML;
	        }
	    }, {
	        key: 'componentWillReceiveProps',
	        value: function componentWillReceiveProps(_ref) {
	            var children = _ref.children;
	
	            if ("production" !== process.env.NODE_ENV && children != null) {
	                console.info('<InlineSVG />: `children` prop will be ignored.');
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var Element = undefined,
	                __html = undefined,
	                svgProps = undefined;
	            var _props = this.props;
	            var element = _props.element;
	            var raw = _props.raw;
	            var src = _props.src;
	
	            var otherProps = _objectWithoutProperties(_props, ['element', 'raw', 'src']);
	
	            if (raw === true && isParsable(src)) {
	                Element = 'svg';
	                svgProps = this._extractSVGProps(src);
	                __html = this._stripSVG(src);
	            }
	            __html = __html || src;
	            Element = Element || element;
	            svgProps = svgProps || {};
	
	            return _react2['default'].createElement(Element, _extends({}, svgProps, otherProps, { src: null, children: null,
	                dangerouslySetInnerHTML: { __html: __html } }));
	        }
	    }]);
	
	    return InlineSVG;
	})(_react2['default'].Component);
	
	exports['default'] = InlineSVG;
	module.exports = exports['default'];

/***/ },
/* 417 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"-1 73 16 11\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><g id=\"Shape-Copy-3-+-Shape-Copy-4\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" transform=\"translate(0.000000, 74.000000)\"><path d=\"M0.749321284,4.16081709 L4.43130681,0.242526751 C4.66815444,-0.00952143591 5.06030999,-0.0211407611 5.30721074,0.216574262 C5.55411149,0.454289284 5.56226116,0.851320812 5.32541353,1.103369 L1.95384971,4.69131519 L5.48809879,8.09407556 C5.73499955,8.33179058 5.74314922,8.72882211 5.50630159,8.9808703 C5.26945396,9.23291849 4.87729841,9.24453781 4.63039766,9.00682279 L0.827097345,5.34502101 C0.749816996,5.31670099 0.677016974,5.27216098 0.613753508,5.21125118 C0.427367989,5.03179997 0.377040713,4.7615583 0.465458792,4.53143559 C0.492371834,4.43667624 0.541703274,4.34676528 0.613628034,4.27022448 C0.654709457,4.22650651 0.70046335,4.19002189 0.749321284,4.16081709 Z\" id=\"Shape-Copy-3\" stroke=\"#FFFFFF\" stroke-width=\"0.05\" fill=\"#DDE1E4\"></path><path d=\"M13.7119065,5.44453032 L9.77062746,9.09174784 C9.51677479,9.3266604 9.12476399,9.31089603 8.89504684,9.05653714 C8.66532968,8.80217826 8.68489539,8.40554539 8.93874806,8.17063283 L12.5546008,4.82456128 L9.26827469,1.18571135 C9.03855754,0.931352463 9.05812324,0.534719593 9.31197591,0.299807038 C9.56582858,0.0648944831 9.95783938,0.0806588502 10.1875565,0.335017737 L13.72891,4.25625178 C13.8013755,4.28980469 13.8684335,4.3382578 13.9254821,4.40142604 C14.0883019,4.58171146 14.1258883,4.83347168 14.0435812,5.04846202 C14.0126705,5.15680232 13.9526426,5.2583679 13.8641331,5.34027361 C13.8174417,5.38348136 13.7660763,5.41820853 13.7119065,5.44453032 Z\" id=\"Shape-Copy-4\" stroke=\"#FFFFFF\" stroke-width=\"0.05\" fill=\"#DDE1E4\"></path></g></svg>"

/***/ },
/* 418 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 16 16\"><path d=\"M8 13.4c-.5 0-.9-.2-1.2-.6L.4 5.2C0 4.7-.1 4.3.2 3.7S1 3 1.6 3h12.8c.6 0 1.2.1 1.4.7.3.6.2 1.1-.2 1.6l-6.4 7.6c-.3.4-.7.5-1.2.5z\"></path></svg>"

/***/ },
/* 419 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><g fill-rule=\"evenodd\"><circle cx=\"8\" cy=\"8.5\" r=\"1.5\"></circle><path d=\"M15.498 8.28l-.001-.03v-.002-.004l-.002-.018-.004-.031c0-.002 0-.002 0 0l-.004-.035.006.082c-.037-.296-.133-.501-.28-.661-.4-.522-.915-1.042-1.562-1.604-1.36-1.182-2.74-1.975-4.178-2.309a6.544 6.544 0 0 0-2.755-.042c-.78.153-1.565.462-2.369.91C3.252 5.147 2.207 6 1.252 7.035c-.216.233-.36.398-.499.577-.338.437-.338 1 0 1.437.428.552.941 1.072 1.59 1.635 1.359 1.181 2.739 1.975 4.177 2.308.907.21 1.829.223 2.756.043.78-.153 1.564-.462 2.369-.91 1.097-.612 2.141-1.464 3.097-2.499.217-.235.36-.398.498-.578.12-.128.216-.334.248-.554 0 .01 0 .01-.008.04l.013-.079-.001.011.003-.031.001-.017v.005l.001-.02v.008l.002-.03.001-.05-.001-.044v-.004-.004zm-.954.045v.007l.001.004V8.33v.012l-.001.01v-.005-.005l.002-.015-.001.008c-.002.014-.002.014 0 0l-.007.084c.003-.057-.004-.041-.014-.031-.143.182-.27.327-.468.543-.89.963-1.856 1.752-2.86 2.311-.724.404-1.419.677-2.095.81a5.63 5.63 0 0 1-2.374-.036c-1.273-.295-2.523-1.014-3.774-2.101-.604-.525-1.075-1.001-1.457-1.496-.054-.07-.054-.107 0-.177.117-.152.244-.298.442-.512.89-.963 1.856-1.752 2.86-2.311.724-.404 1.419-.678 2.095-.81a5.631 5.631 0 0 1 2.374.036c1.272.295 2.523 1.014 3.774 2.101.603.524 1.074 1 1.457 1.496.035.041.043.057.046.076 0 .01 0 .01.008.043l-.009-.047.003.02-.002-.013v-.008.016c0-.004 0-.004 0 0v-.004z\"></path></g></svg>"

/***/ },
/* 420 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 60 12\"><path id=\"base-path\" d=\"M53.9,0H1C0.4,0,0,0.4,0,1v10c0,0.6,0.4,1,1,1h52.9c0.6,0,1.2-0.3,1.5-0.7L60,6l-4.4-5.3C55,0.3,54.5,0,53.9,0z\"></path></svg>"

/***/ },
/* 421 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 6 6\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><path d=\"M1.35191454,5.27895256 L5.31214367,1.35518468 C5.50830675,1.16082764 5.50977084,0.844248536 5.3154138,0.648085456 C5.12105677,0.451922377 4.80447766,0.450458288 4.60831458,0.644815324 L0.648085456,4.56858321 C0.451922377,4.76294025 0.450458288,5.07951935 0.644815324,5.27568243 C0.83917236,5.47184551 1.15575146,5.4733096 1.35191454,5.27895256 L1.35191454,5.27895256 Z\" id=\"Line\" stroke=\"none\" fill=\"#696969\" fill-rule=\"evenodd\"></path><path d=\"M5.31214367,4.56858321 L1.35191454,0.644815324 C1.15575146,0.450458288 0.83917236,0.451922377 0.644815324,0.648085456 C0.450458288,0.844248536 0.451922377,1.16082764 0.648085456,1.35518468 L4.60831458,5.27895256 C4.80447766,5.4733096 5.12105677,5.47184551 5.3154138,5.27568243 C5.50977084,5.07951935 5.50830675,4.76294025 5.31214367,4.56858321 L5.31214367,4.56858321 Z\" id=\"Line-Copy-2\" stroke=\"none\" fill=\"#696969\" fill-rule=\"evenodd\"></path></svg>"

/***/ },
/* 422 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.05 4.634l-2.144.003-.116.116v1.445l.92.965.492.034.116-.116v-.617L9.13 5.7l.035-.95M12.482 10.38l-1.505-1.462H9.362l-.564.516-.034 1.108.72.768 1.323.034-.117-.116v1.2l.972 1.02.315.034.116-.116v-1.154l.422-.374.034-.927-.117.117h.26l.408-.36V10.5l-.125-.124-.575-.033\"></path><path d=\"M8.47 15.073c-3.088 0-5.6-2.513-5.6-5.602V9.4v-.003c0-.018 0-.018.002-.034l.182-.088.724.587.49.033.497.543-.034.9.317.383h.47l.114.096-.032 1.9.524.553h.105l.025-.338 1.004-.95.054-.474.53-.462v-.888l-.588-.038-1.118-1.155H4.48l-.154-.09V9.01l.155-.1h1.164v-.273l.12-.115.7.033.494-.443.034-.746-.624-.655h-.724v.28l-.11.07H4.64l-.114-.09.025-.64.48-.43v-.244h-.382c-.102 0-.152-.128-.08-.2 1.04-1.01 2.428-1.59 3.903-1.59 1.374 0 2.672.5 3.688 1.39.08.068.03.198-.075.198l-1.144-.034-.81.803.52.523v.16l-.382.388h-.158l-.176-.177v-.16l.076-.074-.252-.252-.37.362.53.53c.072.072.005.194-.096.194l-.752-.005v.844h.783L9.885 8l.16-.143h.16l.62.61v.267l.58.027.003.002V8.76l.18-.03 1.234 1.24.753-.708h.382l.116.108c0 .02.003.016.003.036v.065c0 3.09-2.515 5.603-5.605 5.603M8.47 3C4.904 3 2 5.903 2 9.47c0 3.57 2.903 6.472 6.47 6.472 3.57 0 6.472-2.903 6.472-6.47C14.942 5.9 12.04 3 8.472 3\"></path></svg>"

/***/ },
/* 423 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4 2v12h9V4.775L9.888 2H4zm0-1h5.888c.246 0 .483.09.666.254l3.112 2.774c.212.19.334.462.334.747V14c0 .552-.448 1-1 1H4c-.552 0-1-.448-1-1V2c0-.552.448-1 1-1z\"></path><path d=\"M9 1.5v4c0 .325.306.564.62.485l4-1c.27-.067.432-.338.365-.606-.067-.27-.338-.432-.606-.365l-4 1L10 5.5v-4c0-.276-.224-.5-.5-.5s-.5.224-.5.5z\"></path></svg>"

/***/ },
/* 424 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2 5.193v7.652c0 .003-.002 0 .007 0H14v-7.69c0-.003.002 0-.007 0h-7.53v-2.15c0-.002-.004-.005-.01-.005H2.01C2 3 2 3 2 3.005V5.193zm-1 0V3.005C1 2.45 1.444 2 2.01 2h4.442c.558 0 1.01.45 1.01 1.005v1.15h6.53c.557 0 1.008.44 1.008 1v7.69c0 .553-.45 1-1.007 1H2.007c-.556 0-1.007-.44-1.007-1V5.193zM6.08 4.15H2v1h4.46v-1h-.38z\" fill-rule=\"evenodd\"></path></svg>"

/***/ },
/* 425 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"14 6 13 12\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><g id=\"world\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" transform=\"translate(14.000000, 6.000000)\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M6.35076107,0.354 C3.25095418,0.354 0.729,2.87582735 0.729,5.9758879 C0.729,9.07544113 3.25082735,11.5972685 6.35076107,11.5972685 C9.45044113,11.5972685 11.9723953,9.07544113 11.9723953,5.97576107 C11.9723953,2.87582735 9.45044113,0.354 6.35076107,0.354 L6.35076107,0.354 Z M6.35076107,10.8289121 C3.67445071,10.8289121 1.49722956,8.65181776 1.49722956,5.97576107 C1.49722956,5.9443064 1.49900522,5.91335907 1.49976622,5.88215806 L2.20090094,6.4213266 L2.56313696,6.4213266 L2.97268183,6.8306178 L2.97268183,7.68217686 L3.32324919,8.03287105 L3.73926255,8.03287105 L3.73926255,9.79940584 L4.27386509,10.3361645 L4.4591686,10.3361645 L4.4591686,10.000183 L5.37655417,9.08343163 L5.37655417,8.73400577 L5.85585737,8.25203907 L5.85585737,7.37206934 L5.32518666,7.37206934 L4.28439226,6.33140176 L2.82225748,6.33140176 L2.82225748,5.56938704 L3.96286973,5.56938704 L3.96286973,5.23949352 L4.65068695,5.23949352 L5.11477015,4.77667865 L5.11477015,4.03001076 L4.49087694,3.40662489 L3.75359472,3.40662489 L3.75359472,3.78725175 L2.96228149,3.78725175 L2.96228149,3.28385021 L3.42217919,2.82319151 L3.42217919,2.49786399 L2.97001833,2.49786399 C3.84466106,1.64744643 5.03714814,1.12222956 6.35063424,1.12222956 C7.57292716,1.12222956 8.69020207,1.57730759 9.54442463,2.32587797 L8.46164839,2.32587797 L7.680355,3.10666403 L8.21508437,3.64088607 L7.87238068,3.98257509 L7.7165025,3.82669692 L7.85297518,3.68946324 L7.78930484,3.62566607 L7.78943167,3.62566607 L7.56011699,3.39559038 L7.55986332,3.39571722 L7.49758815,3.33318838 L7.01904595,3.78585658 L7.55910232,4.32654712 L6.8069806,4.32198112 L6.8069806,5.25864535 L7.66716433,5.25864535 L7.6723645,4.72112565 L7.81289584,4.57996014 L8.31819988,5.08653251 L8.31819988,5.41921636 L9.00703176,5.41921636 L9.03366676,5.39321553 L9.03430093,5.39194719 L10.195587,6.55259911 L10.8637451,5.88520206 L11.2018828,5.88520206 C11.2023901,5.9153884 11.2041658,5.94532107 11.2041658,5.97563424 C11.2040389,8.65181776 9.0269446,10.8289121 6.35076107,10.8289121 L6.35076107,10.8289121 Z\" id=\"Shape\" stroke=\"#DDE1E5\" stroke-width=\"0.25\" fill=\"#DDE1E5\"></path><polygon id=\"Shape\" stroke=\"#DDE1E5\" stroke-width=\"0.25\" fill=\"#DDE1E5\" points=\"6.50676608 1.61523076 4.52892694 1.61789426 4.52892694 2.95192735 5.34560683 3.76733891 5.72496536 3.76733891 5.72496536 3.1967157 6.50676608 2.41592965\"></polygon><polygon id=\"Shape\" stroke=\"#DDE1E5\" stroke-width=\"0.25\" fill=\"#DDE1E5\" points=\"9.59959714 6.88718547 8.28623788 5.57268471 8.28623788 5.57002121 6.79607294 5.57002121 6.35101474 6.01469891 6.35101474 6.96201714 6.98429362 7.59466185 8.12909136 7.59466185 8.12909136 8.70343893 8.99434843 9.56882283 9.20971144 9.56882283 9.20971144 8.50329592 9.63029081 8.08271655 9.63029081 7.3026915 9.87025949 7.3026915 10.1711082 7.00082814 10.0558167 6.88718547\"></polygon></g></svg>"

/***/ },
/* 426 */
/***/ function(module, exports) {

	module.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"><path class=\"st0\" d=\"M9 9.3l3.6 3.6\"></path><ellipse fill=\"transparent\" cx=\"5.9\" cy=\"6.2\" rx=\"4.5\" ry=\"4.5\"></ellipse></svg>"

/***/ },
/* 427 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><g fill-rule=\"evenodd\"><path d=\"M5 12.503l.052-9a.5.5 0 0 0-1-.006l-.052 9a.5.5 0 0 0 1 .006zM12 12.497l-.05-9A.488.488 0 0 0 11.474 3a.488.488 0 0 0-.473.503l.05 9a.488.488 0 0 0 .477.497.488.488 0 0 0 .473-.503z\"></path></g></svg>"

/***/ },
/* 428 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.483 13.995H5.517l-3.512-3.512V5.516l3.512-3.512h4.966l3.512 3.512v4.967l-3.512 3.512zm4.37-9.042l-3.807-3.805A.503.503 0 0 0 10.691 1H5.309a.503.503 0 0 0-.356.148L1.147 4.953A.502.502 0 0 0 1 5.308v5.383c0 .134.053.262.147.356l3.806 3.806a.503.503 0 0 0 .356.147h5.382a.503.503 0 0 0 .355-.147l3.806-3.806A.502.502 0 0 0 15 10.69V5.308a.502.502 0 0 0-.147-.355z\"></path><path d=\"M10 10.5a.5.5 0 1 0 1 0v-5a.5.5 0 1 0-1 0v5zM5 10.5a.5.5 0 1 0 1 0v-5a.5.5 0 0 0-1 0v5z\"></path></svg>"

/***/ },
/* 429 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M8.5 8.5V14a.5.5 0 1 1-1 0V8.5H2a.5.5 0 0 1 0-1h5.5V2a.5.5 0 0 1 1 0v5.5H14a.5.5 0 1 1 0 1H8.5z\" fill-rule=\"evenodd\"></path></svg>"

/***/ },
/* 430 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4.525 13.21h-.472c-.574 0-.987-.154-1.24-.463-.253-.31-.38-.882-.38-1.719v-.573c0-.746-.097-1.265-.292-1.557-.196-.293-.51-.44-.945-.44v-.974c.435 0 .75-.146.945-.44.195-.292.293-.811.293-1.556v-.58c0-.833.126-1.404.379-1.712.253-.31.666-.464 1.24-.464h.472v.783h-.179c-.37 0-.628.08-.774.24-.145.159-.218.54-.218 1.141v.383c0 .824-.096 1.432-.287 1.823-.191.39-.516.679-.974.866.458.191.783.482.974.873.191.39.287.998.287 1.823v.382c0 .602.073.982.218 1.142.146.16.404.239.774.239h.18v.783zm9.502-4.752c-.43 0-.744.147-.942.44-.197.292-.296.811-.296 1.557v.573c0 .837-.125 1.41-.376 1.719-.251.309-.664.463-1.237.463h-.478v-.783h.185c.37 0 .628-.08.774-.24.145-.159.218-.539.218-1.14v-.383c0-.825.096-1.433.287-1.823.191-.39.516-.682.974-.873-.458-.187-.783-.476-.974-.866-.191-.391-.287-.999-.287-1.823v-.383c0-.602-.073-.982-.218-1.142-.146-.159-.404-.239-.774-.239h-.185v-.783h.478c.573 0 .986.155 1.237.464.25.308.376.88.376 1.712v.58c0 .673.088 1.174.263 1.503.176.329.5.493.975.493v.974z\" fill-rule=\"evenodd\"></path></svg>"

/***/ },
/* 431 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6.925 12.5l7.4-5-7.4-5v10zM6 12.5v-10c0-.785.8-1.264 1.415-.848l7.4 5c.58.392.58 1.304 0 1.696l-7.4 5C6.8 13.764 6 13.285 6 12.5z\" fill-rule=\"evenodd\"></path></svg>"

/***/ },
/* 432 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 33 12\"><path id=\"base-path\" d=\"M27.1,0H1C0.4,0,0,0.4,0,1v10c0,0.6,0.4,1,1,1h26.1 c0.6,0,1.2-0.3,1.5-0.7L33,6l-4.4-5.3C28.2,0.3,27.7,0,27.1,0z\"></path></svg>"

/***/ },
/* 433 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><g fill-rule=\"evenodd\"><path d=\"M1.5 14.042h4.095a.5.5 0 0 0 0-1H1.5a.5.5 0 1 0 0 1zM7.983 2a.5.5 0 0 1 .517.5v7.483l3.136-3.326a.5.5 0 1 1 .728.686l-4 4.243a.499.499 0 0 1-.73-.004L3.635 7.343a.5.5 0 0 1 .728-.686L7.5 9.983V3H1.536C1.24 3 1 2.776 1 2.5s.24-.5.536-.5h6.447zM10.5 14.042h4.095a.5.5 0 0 0 0-1H10.5a.5.5 0 1 0 0 1z\"></path></g></svg>"

/***/ },
/* 434 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><g fill-rule=\"evenodd\"><path d=\"M5 13.5H1a.5.5 0 1 0 0 1h4a.5.5 0 1 0 0-1zM12 13.5H8a.5.5 0 1 0 0 1h4a.5.5 0 1 0 0-1zM6.11 5.012A.427.427 0 0 1 6.21 5h7.083L9.646 1.354a.5.5 0 1 1 .708-.708l4.5 4.5a.498.498 0 0 1 0 .708l-4.5 4.5a.5.5 0 0 1-.708-.708L13.293 6H6.5v5.5a.5.5 0 1 1-1 0v-6a.5.5 0 0 1 .61-.488z\"></path></g></svg>"

/***/ },
/* 435 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><g fill-rule=\"evenodd\"><path d=\"M13.297 6.912C12.595 4.39 10.167 2.5 7.398 2.5A5.898 5.898 0 0 0 1.5 8.398a.5.5 0 0 0 1 0A4.898 4.898 0 0 1 7.398 3.5c2.75 0 5.102 2.236 5.102 4.898v.004L8.669 7.029a.5.5 0 0 0-.338.942l4.462 1.598a.5.5 0 0 0 .651-.34.506.506 0 0 0 .02-.043l2-5a.5.5 0 1 0-.928-.372l-1.24 3.098z\"></path><circle cx=\"7\" cy=\"12\" r=\"1\"></circle></g></svg>"

/***/ },
/* 436 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12.219 7c.345 0 .635.117.869.352.234.234.351.524.351.869 0 .351-.118.652-.356.903-.238.25-.526.376-.864.376-.332 0-.615-.125-.85-.376a1.276 1.276 0 0 1-.351-.903A1.185 1.185 0 0 1 12.218 7zM8.234 7c.345 0 .635.117.87.352.234.234.351.524.351.869 0 .351-.119.652-.356.903-.238.25-.526.376-.865.376-.332 0-.613-.125-.844-.376a1.286 1.286 0 0 1-.347-.903c0-.352.114-.643.342-.874.228-.231.51-.347.85-.347zM4.201 7c.339 0 .627.117.864.352.238.234.357.524.357.869 0 .351-.119.652-.357.903-.237.25-.525.376-.864.376-.338 0-.623-.125-.854-.376A1.286 1.286 0 0 1 3 8.221 1.185 1.185 0 0 1 4.201 7z\" fill-rule=\"evenodd\"></path></svg>"

/***/ },
/* 437 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><g fill-rule=\"evenodd\"><path d=\"M3.233 11.25l-.417 1H1.712C.763 12.25 0 11.574 0 10.747V6.503C0 5.675.755 5 1.712 5h4.127l-.417 1H1.597C1.257 6 1 6.225 1 6.503v4.244c0 .277.267.503.597.503h1.636zM7.405 11.27L7 12.306c.865.01 2.212-.024 2.315-.04.112-.016.112-.016.185-.035.075-.02.156-.046.251-.082.152-.056.349-.138.592-.244.415-.182.962-.435 1.612-.744l.138-.066a179.35 179.35 0 0 0 2.255-1.094c1.191-.546 1.191-2.074-.025-2.632l-.737-.34a3547.554 3547.554 0 0 0-3.854-1.78c-.029.11-.065.222-.11.336l-.232.596c.894.408 4.56 2.107 4.56 2.107.458.21.458.596 0 .806L9.197 11.27H7.405zM4.462 14.692l5-12a.5.5 0 1 0-.924-.384l-5 12a.5.5 0 1 0 .924.384z\"></path></g></svg>"

/***/ },
/* 438 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"#0b0b0b\"><path fill-opacity=\".3\" d=\"M12,3h2v10h-2V3z M5,9.9V6.1L8,8L5,9.9z\"></path><path d=\"M14,2H2C1.4,2,1,2.4,1,3v10c0,0.6,0.4,1,1,1h12c0.6,0,1-0.4,1-1V3C15,2.4,14.6,2,14,2z M2,13L2,13V3h0h9v10 H2L2,13z M14,13C14,13,14,13,14,13h-2V3h2c0,0,0,0,0,0V13z M8.5,7.2l-3-1.9C4.6,4.7,4,5,4,6.1v3.8c0,1.1,0.6,1.4,1.5,0.8l3-1.9 C9.5,8.3,9.5,7.8,8.5,7.2z M5,9.9V6.1L8,8L5,9.9z\"></path></svg>"

/***/ },
/* 439 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" d=\"M8.5 8.793L5.854 6.146l-.04-.035L7.5 4.426c.2-.2.3-.4.3-.6 0-.2-.1-.4-.2-.6l-1-1c-.4-.3-.9-.3-1.2 0l-4.1 4.1c-.2.2-.3.4-.3.6 0 .2.1.4.2.6l1 1c.3.3.9.3 1.2 0l1.71-1.71.036.04L7.793 9.5l-3.647 3.646c-.195.196-.195.512 0 .708.196.195.512.195.708 0L8.5 10.207l3.646 3.647c.196.195.512.195.708 0 .195-.196.195-.512 0-.708L9.207 9.5l2.565-2.565L13.3 8.5c.1.1 2.3 1.1 2.7.7.4-.4-.3-2.7-.5-2.9l-1.1-1.1c.1-.1.2-.4.2-.6 0-.2-.1-.4-.2-.6l-.4-.4c-.3-.3-.8-.3-1.1 0l-1.5-1.4c-.2-.2-.3-.2-.5-.2s-.3.1-.5.2L9.2 3.4c-.2.1-.2.2-.2.4s.1.4.2.5l1.874 1.92L8.5 8.792z\"></path></svg>"

/***/ },
/* 440 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" fill=\"#D92215\"><path d=\"M8 14.5c-3.6 0-6.5-2.9-6.5-6.5S4.4 1.5 8 1.5s6.5 2.9 6.5 6.5-2.9 6.5-6.5 6.5zm0-12C5 2.5 2.5 5 2.5 8S5 13.5 8 13.5 13.5 11 13.5 8 11 2.5 8 2.5z\"></path><circle cx=\"5\" cy=\"6\" r=\"1\" transform=\"translate(1 1)\"></circle><circle cx=\"9\" cy=\"6\" r=\"1\" transform=\"translate(1 1)\"></circle><path d=\"M5.5 11c-.1 0-.2 0-.3-.1-.2-.1-.3-.4-.1-.7C6 9 7 8.5 8.1 8.5c1.7.1 2.8 1.7 2.8 1.8.2.2.1.5-.1.7-.2.1-.6 0-.7-.2 0 0-.9-1.3-2-1.3-.7 0-1.4.4-2.1 1.3-.2.2-.4.2-.5.2z\"></path></svg>"

/***/ },
/* 441 */
/***/ function(module, exports) {

	module.exports = "<!-- This Source Code Form is subject to the terms of the Mozilla Public - License, v. 2.0. If a copy of the MPL was not distributed with this - file, You can obtain one at http://mozilla.org/MPL/2.0/. --><svg xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M13.917 7C13.44 4.162 10.973 2 8 2 4.686 2 2 4.686 2 8s2.686 6 6 6c2.22 0 4.16-1.207 5.197-3H12c-.912 1.214-2.364 2-4 2-2.76 0-5-2.24-5-5s2.24-5 5-5c2.42 0 4.437 1.718 4.9 4h1.017z\"></path><path d=\"M14 1L8 7h6V1zm-1 1L9 6h4V2z\" fill-rule=\"evenodd\"></path></svg>"

/***/ },
/* 442 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 443 */,
/* 444 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	var dom = React.DOM,
	    PropTypes = React.PropTypes;
	
	var Svg = __webpack_require__(414);
	
	__webpack_require__(445);
	
	function CloseButton(_ref) {
	  var handleClick = _ref.handleClick,
	      buttonClass = _ref.buttonClass,
	      tooltip = _ref.tooltip;
	
	  return dom.div({
	    className: buttonClass ? `close-btn-${ buttonClass }` : "close-btn",
	    onClick: handleClick,
	    title: tooltip
	  }, Svg("close"));
	}
	
	CloseButton.propTypes = {
	  handleClick: PropTypes.func.isRequired
	};
	
	module.exports = CloseButton;

/***/ },
/* 445 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 446 */,
/* 447 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 448 */,
/* 449 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	var dom = React.DOM,
	    PropTypes = React.PropTypes;
	
	var ImPropTypes = __webpack_require__(450);
	
	var _require = __webpack_require__(3),
	    bindActionCreators = _require.bindActionCreators;
	
	var _require2 = __webpack_require__(305),
	    connect = _require2.connect;
	
	var _require3 = __webpack_require__(451),
	    formatKeyShortcut = _require3.formatKeyShortcut;
	
	var SourcesTree = React.createFactory(__webpack_require__(452));
	var actions = __webpack_require__(314);
	
	var _require4 = __webpack_require__(303),
	    getSelectedSource = _require4.getSelectedSource,
	    getSources = _require4.getSources;
	
	__webpack_require__(509);
	
	var Sources = React.createClass({
	  propTypes: {
	    sources: ImPropTypes.map.isRequired,
	    selectSource: PropTypes.func.isRequired,
	    horizontal: PropTypes.bool.isRequired,
	    toggleFileSearch: PropTypes.func
	  },
	
	  displayName: "Sources",
	
	  renderShortcut() {
	    if (this.props.horizontal) {
	      return dom.span({
	        className: "sources-header-info",
	        dir: "ltr",
	        onClick: () => this.props.toggleFileSearch(true)
	      }, L10N.getFormatStr("sources.search", formatKeyShortcut(`CmdOrCtrl+${ L10N.getStr("sources.search.key") }`)));
	    }
	  },
	
	  render() {
	    var _props = this.props,
	        sources = _props.sources,
	        selectSource = _props.selectSource;
	
	
	    return dom.div({ className: "sources-panel" }, dom.div({ className: "sources-header" }, this.renderShortcut()), SourcesTree({ sources, selectSource }));
	  }
	});
	
	module.exports = connect(state => ({ selectedSource: getSelectedSource(state),
	  sources: getSources(state) }), dispatch => bindActionCreators(actions, dispatch))(Sources);

/***/ },
/* 450 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * This is a straight rip-off of the React.js ReactPropTypes.js proptype validators,
	 * modified to make it possible to validate Immutable.js data.
	 *     ImmutableTypes.listOf is patterned after React.PropTypes.arrayOf, but for Immutable.List
	 *     ImmutableTypes.shape  is based on React.PropTypes.shape, but for any Immutable.Iterable
	 */
	"use strict";
	
	var Immutable = __webpack_require__(292);
	
	var ANONYMOUS = "<<anonymous>>";
	
	var ImmutablePropTypes = {
	  listOf: createListOfTypeChecker,
	  mapOf: createMapOfTypeChecker,
	  orderedMapOf: createOrderedMapOfTypeChecker,
	  setOf: createSetOfTypeChecker,
	  orderedSetOf: createOrderedSetOfTypeChecker,
	  stackOf: createStackOfTypeChecker,
	  iterableOf: createIterableOfTypeChecker,
	  recordOf: createRecordOfTypeChecker,
	  shape: createShapeChecker,
	  contains: createShapeChecker,
	  mapContains: createMapContainsChecker,
	  // Primitive Types
	  list: createImmutableTypeChecker("List", Immutable.List.isList),
	  map: createImmutableTypeChecker("Map", Immutable.Map.isMap),
	  orderedMap: createImmutableTypeChecker("OrderedMap", Immutable.OrderedMap.isOrderedMap),
	  set: createImmutableTypeChecker("Set", Immutable.Set.isSet),
	  orderedSet: createImmutableTypeChecker("OrderedSet", Immutable.OrderedSet.isOrderedSet),
	  stack: createImmutableTypeChecker("Stack", Immutable.Stack.isStack),
	  seq: createImmutableTypeChecker("Seq", Immutable.Seq.isSeq),
	  record: createImmutableTypeChecker("Record", function (isRecord) {
	    return isRecord instanceof Immutable.Record;
	  }),
	  iterable: createImmutableTypeChecker("Iterable", Immutable.Iterable.isIterable)
	};
	
	function getPropType(propValue) {
	  var propType = typeof propValue;
	  if (Array.isArray(propValue)) {
	    return "array";
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return "object";
	  }
	  if (propValue instanceof Immutable.Iterable) {
	    return "Immutable." + propValue.toSource().split(" ")[0];
	  }
	  return propType;
	}
	
	function createChainableTypeChecker(validate) {
	  function checkType(isRequired, props, propName, componentName, location, propFullName) {
	    propFullName = propFullName || propName;
	    componentName = componentName || ANONYMOUS;
	    if (props[propName] == null) {
	      var locationName = location;
	      if (isRequired) {
	        return new Error("Required " + locationName + " `" + propFullName + "` was not specified in " + ("`" + componentName + "`."));
	      }
	    } else {
	      return validate(props, propName, componentName, location, propFullName);
	    }
	  }
	
	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);
	
	  return chainedCheckType;
	}
	
	function createImmutableTypeChecker(immutableClassName, immutableClassTypeValidator) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!immutableClassTypeValidator(propValue)) {
	      var propType = getPropType(propValue);
	      return new Error("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `" + immutableClassName + "`."));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createIterableTypeChecker(typeChecker, immutableClassName, immutableClassTypeValidator) {
	
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!immutableClassTypeValidator(propValue)) {
	      var locationName = location;
	      var propType = getPropType(propValue);
	      return new Error("Invalid " + locationName + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an Immutable.js " + immutableClassName + "."));
	    }
	
	    if (typeof typeChecker !== "function") {
	      return new Error("Invalid typeChecker supplied to `" + componentName + "` " + ("for propType `" + propFullName + "`, expected a function."));
	    }
	
	    var propValues = propValue.toArray();
	    for (var i = 0, len = propValues.length; i < len; i++) {
	      var error = typeChecker(propValues, i, componentName, location, "" + propFullName + "[" + i + "]");
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createListOfTypeChecker(typeChecker) {
	  return createIterableTypeChecker(typeChecker, "List", Immutable.List.isList);
	}
	
	function createMapOfTypeChecker(typeChecker) {
	  return createIterableTypeChecker(typeChecker, "Map", Immutable.Map.isMap);
	}
	
	function createOrderedMapOfTypeChecker(typeChecker) {
	  return createIterableTypeChecker(typeChecker, "OrderedMap", Immutable.OrderedMap.isOrderedMap);
	}
	
	function createSetOfTypeChecker(typeChecker) {
	  return createIterableTypeChecker(typeChecker, "Set", Immutable.Set.isSet);
	}
	
	function createOrderedSetOfTypeChecker(typeChecker) {
	  return createIterableTypeChecker(typeChecker, "OrderedSet", Immutable.OrderedSet.isOrderedSet);
	}
	
	function createStackOfTypeChecker(typeChecker) {
	  return createIterableTypeChecker(typeChecker, "Stack", Immutable.Stack.isStack);
	}
	
	function createIterableOfTypeChecker(typeChecker) {
	  return createIterableTypeChecker(typeChecker, "Iterable", Immutable.Iterable.isIterable);
	}
	
	function createRecordOfTypeChecker(recordKeys) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!(propValue instanceof Immutable.Record)) {
	      var propType = getPropType(propValue);
	      var locationName = location;
	      return new Error("Invalid " + locationName + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected an Immutable.js Record."));
	    }
	    for (var key in recordKeys) {
	      var checker = recordKeys[key];
	      if (!checker) {
	        continue;
	      }
	      var mutablePropValue = propValue.toObject();
	      var error = checker(mutablePropValue, key, componentName, location, "" + propFullName + "." + key);
	      if (error) {
	        return error;
	      }
	    }
	  }
	  return createChainableTypeChecker(validate);
	}
	
	// there is some irony in the fact that shapeTypes is a standard hash and not an immutable collection
	function createShapeTypeChecker(shapeTypes) {
	  var immutableClassName = arguments[1] === undefined ? "Iterable" : arguments[1];
	  var immutableClassTypeValidator = arguments[2] === undefined ? Immutable.Iterable.isIterable : arguments[2];
	
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!immutableClassTypeValidator(propValue)) {
	      var propType = getPropType(propValue);
	      var locationName = location;
	      return new Error("Invalid " + locationName + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected an Immutable.js " + immutableClassName + "."));
	    }
	    var mutablePropValue = propValue.toObject();
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(mutablePropValue, key, componentName, location, "" + propFullName + "." + key);
	      if (error) {
	        return error;
	      }
	    }
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createShapeChecker(shapeTypes) {
	  return createShapeTypeChecker(shapeTypes);
	}
	
	function createMapContainsChecker(shapeTypes) {
	  return createShapeTypeChecker(shapeTypes, "Map", Immutable.Map.isMap);
	}
	
	module.exports = ImmutablePropTypes;

/***/ },
/* 451 */
/***/ function(module, exports, __webpack_require__) {

	
	
	/**
	 * Utils for keyboard command strings
	 * @module utils/text
	 */
	
	var _require = __webpack_require__(28),
	    appinfo = _require.Services.appinfo;
	
	var isMacOS = appinfo.OS === "Darwin";
	
	/**
	 * Formats key for use in tooltips
	 * For macOS we use the following unicode
	 *
	 * cmd ⌘ = \u2318
	 * shift ⇧ – \u21E7
	 * option (alt) ⌥ \u2325
	 *
	 * For Win/Lin this replaces CommandOrControl or CmdOrCtrl with Ctrl
	 *
	 * @memberof utils/text
	 * @static
	 */
	function formatKeyShortcut(shortcut) {
	  if (isMacOS) {
	    return shortcut.replace(/Shift\+/g, "\u21E7+").replace(/Command\+|Cmd\+/g, "\u2318+").replace(/CommandOrControl\+|CmdOrCtrl\+/g, "\u2318+").replace(/Alt\+/g, "\u2325+");
	  }
	  return shortcut.replace(/CommandOrControl\+|CmdOrCtrl\+/g, "Ctrl+");
	}
	
	module.exports = {
	  formatKeyShortcut
	};

/***/ },
/* 452 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	
	var _require = __webpack_require__(3),
	    bindActionCreators = _require.bindActionCreators;
	
	var _require2 = __webpack_require__(305),
	    connect = _require2.connect;
	
	var dom = React.DOM,
	    PropTypes = React.PropTypes;
	
	var classnames = __webpack_require__(413);
	var ImPropTypes = __webpack_require__(450);
	
	var _require3 = __webpack_require__(292),
	    Set = _require3.Set;
	
	var _require4 = __webpack_require__(197),
	    isEnabled = _require4.isEnabled;
	
	var _require5 = __webpack_require__(303),
	    getShownSource = _require5.getShownSource,
	    getSelectedSource = _require5.getSelectedSource;
	
	var _require6 = __webpack_require__(453),
	    nodeHasChildren = _require6.nodeHasChildren,
	    createParentMap = _require6.createParentMap,
	    addToTree = _require6.addToTree,
	    collapseTree = _require6.collapseTree,
	    createTree = _require6.createTree,
	    getDirectories = _require6.getDirectories;
	
	var ManagedTree = React.createFactory(__webpack_require__(506));
	var actions = __webpack_require__(314);
	var Svg = __webpack_require__(414);
	
	var _require7 = __webpack_require__(250),
	    throttle = _require7.throttle;
	
	var SourcesTree = React.createClass({
	  propTypes: {
	    sources: ImPropTypes.map.isRequired,
	    selectSource: PropTypes.func.isRequired,
	    shownSource: PropTypes.string,
	    selectedSource: ImPropTypes.map
	  },
	
	  displayName: "SourcesTree",
	
	  getInitialState() {
	    return createTree(this.props.sources);
	  },
	
	  queueUpdate: throttle(function () {
	    if (!this.isMounted()) {
	      return;
	    }
	
	    this.forceUpdate();
	  }, 50),
	
	  shouldComponentUpdate() {
	    this.queueUpdate();
	    return false;
	  },
	
	  componentWillReceiveProps(nextProps) {
	    var selectedSource = this.props.selectedSource;
	
	    if (isEnabled("showSource") && nextProps.shownSource != this.props.shownSource) {
	      var listItems = getDirectories(nextProps.shownSource, this.state.sourceTree);
	
	      this.selectItem(listItems[0]);
	      return this.setState({ listItems });
	    }
	
	    if (nextProps.selectedSource && nextProps.selectedSource != selectedSource) {
	      var highlightItems = getDirectories(nextProps.selectedSource.get("url"), this.state.sourceTree);
	
	      return this.setState({ highlightItems });
	    }
	
	    if (nextProps.sources === this.props.sources) {
	      return;
	    }
	
	    if (nextProps.sources.size === 0) {
	      this.setState(createTree(nextProps.sources));
	      return;
	    }
	
	    var next = Set(nextProps.sources.valueSeq());
	    var prev = Set(this.props.sources.valueSeq());
	    var newSet = next.subtract(prev);
	
	    var uncollapsedTree = this.state.uncollapsedTree;
	    for (var source of newSet) {
	      addToTree(uncollapsedTree, source);
	    }
	
	    // TODO: recreating the tree every time messes with the expanded
	    // state of ManagedTree, because it depends on item instances
	    // being the same. The result is that if a source is added at a
	    // later time, all expanded state is lost.
	    var sourceTree = newSet.size > 0 ? collapseTree(uncollapsedTree) : this.state.sourceTree;
	
	    this.setState({ uncollapsedTree,
	      sourceTree,
	      parentMap: createParentMap(sourceTree) });
	  },
	
	  focusItem(item) {
	    this.setState({ focusedItem: item });
	  },
	
	  selectItem(item) {
	    if (!nodeHasChildren(item)) {
	      this.props.selectSource(item.contents.get("id"));
	    }
	  },
	
	  getIcon(item, depth) {
	    if (depth === 0) {
	      return Svg("domain");
	    }
	
	    if (!nodeHasChildren(item)) {
	      return Svg("file");
	    }
	
	    return Svg("folder");
	  },
	
	  renderItem(item, depth, focused, _, expanded, _ref) {
	    var setExpanded = _ref.setExpanded;
	
	    var arrow = Svg("arrow", {
	      className: classnames({ expanded: expanded,
	        hidden: !nodeHasChildren(item) }),
	      onClick: e => {
	        e.stopPropagation();
	        setExpanded(item, !expanded);
	      }
	    });
	
	    var icon = this.getIcon(item, depth);
	    var paddingDir = document.body.parentElement.dir == "ltr" ? "paddingLeft" : "paddingRight";
	    return dom.div({
	      className: classnames("node", { focused }),
	      style: { [paddingDir]: `${ depth * 15 }px` },
	      key: item.path,
	      onClick: () => this.selectItem(item),
	      onDoubleClick: e => setExpanded(item, !expanded)
	    }, dom.div(null, arrow, icon, item.name));
	  },
	
	  render: function () {
	    var _state = this.state,
	        focusedItem = _state.focusedItem,
	        sourceTree = _state.sourceTree,
	        parentMap = _state.parentMap,
	        listItems = _state.listItems,
	        highlightItems = _state.highlightItems;
	
	    var isEmpty = sourceTree.contents.length === 0;
	
	    var tree = ManagedTree({
	      key: isEmpty ? "empty" : "full",
	      getParent: item => {
	        return parentMap.get(item);
	      },
	      getChildren: item => {
	        if (nodeHasChildren(item)) {
	          return item.contents;
	        }
	        return [];
	      },
	      getRoots: () => sourceTree.contents,
	      getKey: (item, i) => item.path,
	      itemHeight: 18,
	      autoExpandDepth: 1,
	      autoExpandAll: false,
	      onFocus: this.focusItem,
	      listItems,
	      highlightItems,
	      renderItem: this.renderItem
	    });
	
	    return dom.div({
	      className: "sources-list",
	      onKeyDown: e => {
	        if (e.keyCode === 13 && focusedItem) {
	          this.selectItem(focusedItem);
	        }
	      }
	    }, tree);
	  }
	});
	
	module.exports = connect(state => {
	  return {
	    shownSource: getShownSource(state),
	    selectedSource: getSelectedSource(state)
	  };
	}, dispatch => bindActionCreators(actions, dispatch))(SourcesTree);

/***/ },
/* 453 */
/***/ function(module, exports, __webpack_require__) {

	
	
	/**
	 * Utils for Sources Tree Component
	 * @module utils/sources-tree
	 */
	
	var _require = __webpack_require__(398),
	    parse = _require.parse;
	
	var _require2 = __webpack_require__(251),
	    assert = _require2.assert;
	
	var _require3 = __webpack_require__(295),
	    isPretty = _require3.isPretty;
	
	var merge = __webpack_require__(454);
	
	var IGNORED_URLS = ["debugger eval code", "XStringBundle"];
	
	/**
	 * Temporary Source type to be used only within this module
	 * TODO: Replace with real Source type definition when refactoring types
	 * @memberof utils/sources-tree
	 * @static
	 */
	
	
	/**
	 * TODO: createNode is exported so this type could be useful to other modules
	 * @memberof utils/sources-tree
	 * @static
	 */
	
	
	/**
	 * @memberof utils/sources-tree
	 * @static
	 */
	function nodeHasChildren(item) {
	  return Array.isArray(item.contents);
	}
	
	/**
	 * @memberof utils/sources-tree
	 * @static
	 */
	function createNode(name, path, contents) {
	  return {
	    name,
	    path,
	    contents: contents || null
	  };
	}
	
	/**
	 * @memberof utils/sources-tree
	 * @static
	 */
	function createParentMap(tree) {
	  var map = new WeakMap();
	
	  function _traverse(subtree) {
	    if (nodeHasChildren(subtree)) {
	      for (var child of subtree.contents) {
	        map.set(child, subtree);
	        _traverse(child);
	      }
	    }
	  }
	
	  // Don't link each top-level path to the "root" node because the
	  // user never sees the root
	  tree.contents.forEach(_traverse);
	  return map;
	}
	
	/**
	 * @memberof utils/sources-tree
	 * @static
	 */
	function getFilenameFromPath(pathname) {
	  var filename = "";
	  if (pathname) {
	    filename = pathname.substring(pathname.lastIndexOf("/") + 1);
	    // This file does not have a name. Default should be (index).
	    if (filename == "" || !filename.includes(".")) {
	      filename = "(index)";
	    }
	  }
	  return filename;
	}
	
	/**
	 * @memberof utils/sources-tree
	 * @static
	 */
	function getURL(sourceUrl) {
	  var url = sourceUrl;
	  var def = { path: "", group: "", filename: "" };
	  if (!url) {
	    return def;
	  }
	
	  var _parse = parse(url),
	      pathname = _parse.pathname,
	      protocol = _parse.protocol,
	      host = _parse.host,
	      path = _parse.path;
	
	  var filename = getFilenameFromPath(pathname);
	
	  switch (protocol) {
	    case "javascript:":
	      // Ignore `javascript:` URLs for now
	      return def;
	
	    case "about:":
	      // An about page is a special case
	      return merge(def, {
	        path: "/",
	        group: url,
	        filename: filename
	      });
	
	    case null:
	      if (pathname && pathname.startsWith("/")) {
	        // If it's just a URL like "/foo/bar.js", resolve it to the file
	        // protocol
	        return merge(def, {
	          path: path,
	          group: "file://",
	          filename: filename
	        });
	      } else if (host === null) {
	        // We don't know what group to put this under, and it's a script
	        // with a weird URL. Just group them all under an anonymous group.
	        return merge(def, {
	          path: url,
	          group: "(no domain)",
	          filename: filename
	        });
	      }
	      break;
	
	    case "http:":
	    case "https:":
	      return merge(def, {
	        path: pathname,
	        group: host,
	        filename: filename
	      });
	  }
	
	  return merge(def, {
	    path: path,
	    group: protocol ? `${ protocol }//` : "",
	    filename: filename
	  });
	}
	
	/**
	 * @memberof utils/sources-tree
	 * @static
	 */
	function addToTree(tree, source) {
	  var url = getURL(source.get("url"));
	
	  if (IGNORED_URLS.indexOf(url) != -1 || !source.get("url") || !url.group || isPretty(source.toJS())) {
	    return;
	  }
	
	  url.path = decodeURIComponent(url.path);
	
	  var parts = url.path.split("/").filter(p => p !== "");
	  var isDir = parts.length === 0 || parts[parts.length - 1].indexOf(".") === -1;
	  parts.unshift(url.group);
	
	  var path = "";
	  var subtree = tree;
	
	  for (var i = 0; i < parts.length; i++) {
	    var part = parts[i];
	    var isLastPart = i === parts.length - 1;
	
	    // Currently we assume that we are descending into a node with
	    // children. This will fail if a path has a directory named the
	    // same as another file, like `foo/bar.js/file.js`.
	    //
	    // TODO: Be smarter about this, which we'll probably do when we
	    // are smarter about folders and collapsing empty ones.
	    assert(nodeHasChildren(subtree), `${ subtree.name } should have children`);
	    var children = subtree.contents;
	
	    var index = determineFileSortOrder(children, part, isLastPart);
	
	    if (index >= 0 && children[index].name === part) {
	      // A node with the same name already exists, simply traverse
	      // into it.
	      subtree = children[index];
	    } else {
	      // No node with this name exists, so insert a new one in the
	      // place that is alphabetically sorted.
	      var node = createNode(part, `${ path }/${ part }`, []);
	      var where = index === -1 ? children.length : index;
	      children.splice(where, 0, node);
	      subtree = children[where];
	    }
	
	    // Keep track of the children so we can tag each node with them.
	    path = `${ path }/${ part }`;
	  }
	
	  // Overwrite the contents of the final node to store the source
	  // there.
	  if (isDir) {
	    subtree.contents.unshift(createNode("(index)", source.get("url"), source));
	  } else {
	    subtree.contents = source;
	  }
	}
	
	/**
	 * Look at the nodes in the source tree, and determine the index of where to
	 * insert a new node. The ordering is index -> folder -> file.
	 * @memberof utils/sources-tree
	 * @static
	 */
	function determineFileSortOrder(nodes, pathPart, isLastPart) {
	  var partIsDir = !isLastPart || pathPart.indexOf(".") === -1;
	
	  return nodes.findIndex(node => {
	    var nodeIsDir = nodeHasChildren(node);
	
	    // The index will always be the first thing, so this pathPart will be
	    // after it.
	    if (node.name === "(index)") {
	      return false;
	    }
	
	    // If both the pathPart and node are the same type, then compare them
	    // alphabetically.
	    if (partIsDir === nodeIsDir) {
	      return node.name.localeCompare(pathPart) >= 0;
	    }
	
	    // If the pathPart and node differ, then stop here if the pathPart is a
	    // directory. Keep on searching if the part is a file, as it needs to be
	    // placed after the directories.
	    return partIsDir;
	  });
	}
	
	/**
	 * Take an existing source tree, and return a new one with collapsed nodes.
	 * @memberof utils/sources-tree
	 * @static
	 */
	function collapseTree(node) {
	  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	
	  // Node is a folder.
	  if (nodeHasChildren(node)) {
	    // Node is not a root/domain node, and only contains 1 item.
	    if (depth > 1 && node.contents.length === 1) {
	      var next = node.contents[0];
	      // Do not collapse if the next node is a leaf node.
	      if (nodeHasChildren(next)) {
	        return collapseTree(createNode(`${ node.name }/${ next.name }`, next.path, next.contents), depth + 1);
	      }
	    }
	    // Map the contents.
	    return createNode(node.name, node.path, node.contents.map(next => collapseTree(next, depth + 1)));
	  }
	  // Node is a leaf, not a folder, do not modify it.
	  return node;
	}
	
	/**
	 * @memberof utils/sources-tree
	 * @static
	 */
	function createTree(sources) {
	  var uncollapsedTree = createNode("root", "", []);
	  for (var source of sources.valueSeq()) {
	    addToTree(uncollapsedTree, source);
	  }
	  var sourceTree = collapseTree(uncollapsedTree);
	
	  return { uncollapsedTree,
	    sourceTree,
	    parentMap: createParentMap(sourceTree),
	    focusedItem: null };
	}
	
	function findSource(sourceTree, sourceUrl) {
	  var returnTarget = null;
	  function _traverse(subtree) {
	    if (nodeHasChildren(subtree)) {
	      for (var child of subtree.contents) {
	        _traverse(child);
	      }
	    } else if (!returnTarget && subtree.path.replace(/http(s)?:\//, "") == sourceUrl) {
	      returnTarget = subtree;
	      return;
	    }
	  }
	
	  sourceTree.contents.forEach(_traverse);
	  return returnTarget;
	}
	
	function getDirectories(sourceUrl, sourceTree) {
	  var url = getURL(sourceUrl);
	  var fullUrl = `/${ url.group }${ url.path }`;
	  var parentMap = createParentMap(sourceTree);
	  var source = findSource(sourceTree, fullUrl);
	
	  if (!source) {
	    return [];
	  }
	
	  var node = source;
	  var directories = [];
	  directories.push(source);
	  while (true) {
	    node = parentMap.get(node);
	    if (!node) {
	      return directories;
	    }
	    directories.push(node);
	  }
	}
	
	module.exports = {
	  createNode,
	  nodeHasChildren,
	  createParentMap,
	  addToTree,
	  collapseTree,
	  createTree,
	  getDirectories,
	  getURL
	};

/***/ },
/* 454 */
/***/ function(module, exports, __webpack_require__) {

	var baseMerge = __webpack_require__(455),
	    createAssigner = __webpack_require__(496);
	
	/**
	 * This method is like `_.assign` except that it recursively merges own and
	 * inherited enumerable string keyed properties of source objects into the
	 * destination object. Source properties that resolve to `undefined` are
	 * skipped if a destination value exists. Array and plain object properties
	 * are merged recursively. Other objects and value types are overridden by
	 * assignment. Source objects are applied from left to right. Subsequent
	 * sources overwrite property assignments of previous sources.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.5.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = {
	 *   'a': [{ 'b': 2 }, { 'd': 4 }]
	 * };
	 *
	 * var other = {
	 *   'a': [{ 'c': 3 }, { 'e': 5 }]
	 * };
	 *
	 * _.merge(object, other);
	 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	 */
	var merge = createAssigner(function(object, source, srcIndex) {
	  baseMerge(object, source, srcIndex);
	});
	
	module.exports = merge;


/***/ },
/* 455 */
/***/ function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(456),
	    assignMergeValue = __webpack_require__(462),
	    baseFor = __webpack_require__(465),
	    baseMergeDeep = __webpack_require__(467),
	    isObject = __webpack_require__(216),
	    keysIn = __webpack_require__(490);
	
	/**
	 * The base implementation of `_.merge` without support for multiple sources.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} [customizer] The function to customize merged values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMerge(object, source, srcIndex, customizer, stack) {
	  if (object === source) {
	    return;
	  }
	  baseFor(source, function(srcValue, key) {
	    if (isObject(srcValue)) {
	      stack || (stack = new Stack);
	      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	    }
	    else {
	      var newValue = customizer
	        ? customizer(object[key], srcValue, (key + ''), object, source, stack)
	        : undefined;
	
	      if (newValue === undefined) {
	        newValue = srcValue;
	      }
	      assignMergeValue(object, key, newValue);
	    }
	  }, keysIn);
	}
	
	module.exports = baseMerge;


/***/ },
/* 456 */
/***/ function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(225),
	    stackClear = __webpack_require__(457),
	    stackDelete = __webpack_require__(458),
	    stackGet = __webpack_require__(459),
	    stackHas = __webpack_require__(460),
	    stackSet = __webpack_require__(461);
	
	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}
	
	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;
	
	module.exports = Stack;


/***/ },
/* 457 */
/***/ function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(225);
	
	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	  this.size = 0;
	}
	
	module.exports = stackClear;


/***/ },
/* 458 */
/***/ function(module, exports) {

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);
	
	  this.size = data.size;
	  return result;
	}
	
	module.exports = stackDelete;


/***/ },
/* 459 */
/***/ function(module, exports) {

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}
	
	module.exports = stackGet;


/***/ },
/* 460 */
/***/ function(module, exports) {

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}
	
	module.exports = stackHas;


/***/ },
/* 461 */
/***/ function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(225),
	    Map = __webpack_require__(233),
	    MapCache = __webpack_require__(208);
	
	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;
	
	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}
	
	module.exports = stackSet;


/***/ },
/* 462 */
/***/ function(module, exports, __webpack_require__) {

	var baseAssignValue = __webpack_require__(463),
	    eq = __webpack_require__(229);
	
	/**
	 * This function is like `assignValue` except that it doesn't assign
	 * `undefined` values.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignMergeValue(object, key, value) {
	  if ((value !== undefined && !eq(object[key], value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}
	
	module.exports = assignMergeValue;


/***/ },
/* 463 */
/***/ function(module, exports, __webpack_require__) {

	var defineProperty = __webpack_require__(464);
	
	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && defineProperty) {
	    defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}
	
	module.exports = baseAssignValue;


/***/ },
/* 464 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(213);
	
	var defineProperty = (function() {
	  try {
	    var func = getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());
	
	module.exports = defineProperty;


/***/ },
/* 465 */
/***/ function(module, exports, __webpack_require__) {

	var createBaseFor = __webpack_require__(466);
	
	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();
	
	module.exports = baseFor;


/***/ },
/* 466 */
/***/ function(module, exports) {

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;
	
	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}
	
	module.exports = createBaseFor;


/***/ },
/* 467 */
/***/ function(module, exports, __webpack_require__) {

	var assignMergeValue = __webpack_require__(462),
	    cloneBuffer = __webpack_require__(468),
	    cloneTypedArray = __webpack_require__(469),
	    copyArray = __webpack_require__(472),
	    initCloneObject = __webpack_require__(473),
	    isArguments = __webpack_require__(476),
	    isArray = __webpack_require__(202),
	    isArrayLikeObject = __webpack_require__(478),
	    isBuffer = __webpack_require__(481),
	    isFunction = __webpack_require__(215),
	    isObject = __webpack_require__(216),
	    isPlainObject = __webpack_require__(5),
	    isTypedArray = __webpack_require__(483),
	    toPlainObject = __webpack_require__(487);
	
	/**
	 * A specialized version of `baseMerge` for arrays and objects which performs
	 * deep merges and tracks traversed objects enabling objects with circular
	 * references to be merged.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {string} key The key of the value to merge.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} mergeFunc The function to merge values.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	  var objValue = object[key],
	      srcValue = source[key],
	      stacked = stack.get(srcValue);
	
	  if (stacked) {
	    assignMergeValue(object, key, stacked);
	    return;
	  }
	  var newValue = customizer
	    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	    : undefined;
	
	  var isCommon = newValue === undefined;
	
	  if (isCommon) {
	    var isArr = isArray(srcValue),
	        isBuff = !isArr && isBuffer(srcValue),
	        isTyped = !isArr && !isBuff && isTypedArray(srcValue);
	
	    newValue = srcValue;
	    if (isArr || isBuff || isTyped) {
	      if (isArray(objValue)) {
	        newValue = objValue;
	      }
	      else if (isArrayLikeObject(objValue)) {
	        newValue = copyArray(objValue);
	      }
	      else if (isBuff) {
	        isCommon = false;
	        newValue = cloneBuffer(srcValue, true);
	      }
	      else if (isTyped) {
	        isCommon = false;
	        newValue = cloneTypedArray(srcValue, true);
	      }
	      else {
	        newValue = [];
	      }
	    }
	    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	      newValue = objValue;
	      if (isArguments(objValue)) {
	        newValue = toPlainObject(objValue);
	      }
	      else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
	        newValue = initCloneObject(srcValue);
	      }
	    }
	    else {
	      isCommon = false;
	    }
	  }
	  if (isCommon) {
	    // Recursively merge objects and arrays (susceptible to call stack limits).
	    stack.set(srcValue, newValue);
	    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	    stack['delete'](srcValue);
	  }
	  assignMergeValue(object, key, newValue);
	}
	
	module.exports = baseMergeDeep;


/***/ },
/* 468 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(8);
	
	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
	
	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;
	
	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined,
	    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
	
	/**
	 * Creates a clone of  `buffer`.
	 *
	 * @private
	 * @param {Buffer} buffer The buffer to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Buffer} Returns the cloned buffer.
	 */
	function cloneBuffer(buffer, isDeep) {
	  if (isDeep) {
	    return buffer.slice();
	  }
	  var length = buffer.length,
	      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
	
	  buffer.copy(result);
	  return result;
	}
	
	module.exports = cloneBuffer;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(51)(module)))

/***/ },
/* 469 */
/***/ function(module, exports, __webpack_require__) {

	var cloneArrayBuffer = __webpack_require__(470);
	
	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray(typedArray, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}
	
	module.exports = cloneTypedArray;


/***/ },
/* 470 */
/***/ function(module, exports, __webpack_require__) {

	var Uint8Array = __webpack_require__(471);
	
	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	  return result;
	}
	
	module.exports = cloneArrayBuffer;


/***/ },
/* 471 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(8);
	
	/** Built-in value references. */
	var Uint8Array = root.Uint8Array;
	
	module.exports = Uint8Array;


/***/ },
/* 472 */
/***/ function(module, exports) {

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;
	
	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}
	
	module.exports = copyArray;


/***/ },
/* 473 */
/***/ function(module, exports, __webpack_require__) {

	var baseCreate = __webpack_require__(474),
	    getPrototype = __webpack_require__(12),
	    isPrototype = __webpack_require__(475);
	
	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  return (typeof object.constructor == 'function' && !isPrototype(object))
	    ? baseCreate(getPrototype(object))
	    : {};
	}
	
	module.exports = initCloneObject;


/***/ },
/* 474 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(216);
	
	/** Built-in value references. */
	var objectCreate = Object.create;
	
	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate = (function() {
	  function object() {}
	  return function(proto) {
	    if (!isObject(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object;
	    object.prototype = undefined;
	    return result;
	  };
	}());
	
	module.exports = baseCreate;


/***/ },
/* 475 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
	
	  return value === proto;
	}
	
	module.exports = isPrototype;


/***/ },
/* 476 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsArguments = __webpack_require__(477),
	    isObjectLike = __webpack_require__(14);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;
	
	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};
	
	module.exports = isArguments;


/***/ },
/* 477 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(6),
	    isObjectLike = __webpack_require__(14);
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';
	
	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}
	
	module.exports = baseIsArguments;


/***/ },
/* 478 */
/***/ function(module, exports, __webpack_require__) {

	var isArrayLike = __webpack_require__(479),
	    isObjectLike = __webpack_require__(14);
	
	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}
	
	module.exports = isArrayLikeObject;


/***/ },
/* 479 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(215),
	    isLength = __webpack_require__(480);
	
	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}
	
	module.exports = isArrayLike;


/***/ },
/* 480 */
/***/ function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	
	module.exports = isLength;


/***/ },
/* 481 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(8),
	    stubFalse = __webpack_require__(482);
	
	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
	
	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;
	
	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined;
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
	
	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;
	
	module.exports = isBuffer;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(51)(module)))

/***/ },
/* 482 */
/***/ function(module, exports) {

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}
	
	module.exports = stubFalse;


/***/ },
/* 483 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsTypedArray = __webpack_require__(484),
	    baseUnary = __webpack_require__(485),
	    nodeUtil = __webpack_require__(486);
	
	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
	
	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
	
	module.exports = isTypedArray;


/***/ },
/* 484 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(6),
	    isLength = __webpack_require__(480),
	    isObjectLike = __webpack_require__(14);
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';
	
	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';
	
	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;
	
	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}
	
	module.exports = baseIsTypedArray;


/***/ },
/* 485 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}
	
	module.exports = baseUnary;


/***/ },
/* 486 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(9);
	
	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
	
	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;
	
	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;
	
	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());
	
	module.exports = nodeUtil;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(51)(module)))

/***/ },
/* 487 */
/***/ function(module, exports, __webpack_require__) {

	var copyObject = __webpack_require__(488),
	    keysIn = __webpack_require__(490);
	
	/**
	 * Converts `value` to a plain object flattening inherited enumerable string
	 * keyed properties of `value` to own properties of the plain object.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {Object} Returns the converted plain object.
	 * @example
	 *
	 * function Foo() {
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.assign({ 'a': 1 }, new Foo);
	 * // => { 'a': 1, 'b': 2 }
	 *
	 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	 * // => { 'a': 1, 'b': 2, 'c': 3 }
	 */
	function toPlainObject(value) {
	  return copyObject(value, keysIn(value));
	}
	
	module.exports = toPlainObject;


/***/ },
/* 488 */
/***/ function(module, exports, __webpack_require__) {

	var assignValue = __webpack_require__(489),
	    baseAssignValue = __webpack_require__(463);
	
	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});
	
	  var index = -1,
	      length = props.length;
	
	  while (++index < length) {
	    var key = props[index];
	
	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;
	
	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}
	
	module.exports = copyObject;


/***/ },
/* 489 */
/***/ function(module, exports, __webpack_require__) {

	var baseAssignValue = __webpack_require__(463),
	    eq = __webpack_require__(229);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}
	
	module.exports = assignValue;


/***/ },
/* 490 */
/***/ function(module, exports, __webpack_require__) {

	var arrayLikeKeys = __webpack_require__(491),
	    baseKeysIn = __webpack_require__(494),
	    isArrayLike = __webpack_require__(479);
	
	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}
	
	module.exports = keysIn;


/***/ },
/* 491 */
/***/ function(module, exports, __webpack_require__) {

	var baseTimes = __webpack_require__(492),
	    isArguments = __webpack_require__(476),
	    isArray = __webpack_require__(202),
	    isBuffer = __webpack_require__(481),
	    isIndex = __webpack_require__(493),
	    isTypedArray = __webpack_require__(483);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;
	
	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	module.exports = arrayLikeKeys;


/***/ },
/* 492 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);
	
	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}
	
	module.exports = baseTimes;


/***/ },
/* 493 */
/***/ function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;
	
	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}
	
	module.exports = isIndex;


/***/ },
/* 494 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(216),
	    isPrototype = __webpack_require__(475),
	    nativeKeysIn = __webpack_require__(495);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype(object),
	      result = [];
	
	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	module.exports = baseKeysIn;


/***/ },
/* 495 */
/***/ function(module, exports) {

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	module.exports = nativeKeysIn;


/***/ },
/* 496 */
/***/ function(module, exports, __webpack_require__) {

	var baseRest = __webpack_require__(497),
	    isIterateeCall = __webpack_require__(505);
	
	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;
	
	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;
	
	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}
	
	module.exports = createAssigner;


/***/ },
/* 497 */
/***/ function(module, exports, __webpack_require__) {

	var identity = __webpack_require__(498),
	    overRest = __webpack_require__(499),
	    setToString = __webpack_require__(501);
	
	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return setToString(overRest(func, start, identity), func + '');
	}
	
	module.exports = baseRest;


/***/ },
/* 498 */
/***/ function(module, exports) {

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}
	
	module.exports = identity;


/***/ },
/* 499 */
/***/ function(module, exports, __webpack_require__) {

	var apply = __webpack_require__(500);
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;
	
	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);
	
	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}
	
	module.exports = overRest;


/***/ },
/* 500 */
/***/ function(module, exports) {

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}
	
	module.exports = apply;


/***/ },
/* 501 */
/***/ function(module, exports, __webpack_require__) {

	var baseSetToString = __webpack_require__(502),
	    shortOut = __webpack_require__(504);
	
	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString);
	
	module.exports = setToString;


/***/ },
/* 502 */
/***/ function(module, exports, __webpack_require__) {

	var constant = __webpack_require__(503),
	    defineProperty = __webpack_require__(464),
	    identity = __webpack_require__(498);
	
	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !defineProperty ? identity : function(func, string) {
	  return defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};
	
	module.exports = baseSetToString;


/***/ },
/* 503 */
/***/ function(module, exports) {

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant(value) {
	  return function() {
	    return value;
	  };
	}
	
	module.exports = constant;


/***/ },
/* 504 */
/***/ function(module, exports) {

	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;
	
	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;
	
	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);
	
	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}
	
	module.exports = shortOut;


/***/ },
/* 505 */
/***/ function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(229),
	    isArrayLike = __webpack_require__(479),
	    isIndex = __webpack_require__(493),
	    isObject = __webpack_require__(216);
	
	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq(object[index], value);
	  }
	  return false;
	}
	
	module.exports = isIterateeCall;


/***/ },
/* 506 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	var Tree = React.createFactory(__webpack_require__(256).Tree);
	__webpack_require__(507);
	
	var ManagedTree = React.createClass({
	  propTypes: Tree.propTypes,
	
	  displayName: "ManagedTree",
	
	  getInitialState() {
	    return {
	      expanded: new Set(),
	      focusedItem: null
	    };
	  },
	
	  componentWillReceiveProps(nextProps) {
	    var listItems = nextProps.listItems;
	    if (listItems && listItems != this.props.listItems && listItems.length > 0) {
	      this.expandListItems(listItems);
	    }
	
	    var highlightItems = nextProps.highlightItems;
	    if (highlightItems && highlightItems != this.props.highlightItems && highlightItems.length > 0) {
	      this.highlightItem(highlightItems);
	    }
	  },
	
	  setExpanded(item, isExpanded) {
	    var expanded = this.state.expanded;
	    var key = this.props.getKey(item);
	    if (isExpanded) {
	      expanded.add(key);
	    } else {
	      expanded.delete(key);
	    }
	    this.setState({ expanded });
	
	    if (isExpanded && this.props.onExpand) {
	      this.props.onExpand(item);
	    } else if (!expanded && this.props.onCollapse) {
	      this.props.onCollapse(item);
	    }
	  },
	
	  expandListItems(listItems) {
	    var expanded = this.state.expanded;
	    listItems.forEach(item => expanded.add(this.props.getKey(item)));
	    this.focusItem(listItems[0]);
	    this.setState({ expanded: expanded });
	  },
	
	  highlightItem(highlightItems) {
	    var expanded = this.state.expanded;
	
	    // This file is visible, so we highlight it.
	    if (expanded.has(this.props.getKey(highlightItems[0]))) {
	      this.focusItem(highlightItems[0]);
	    } else {
	      // Look at folders starting from the top-level until finds a
	      // closed folder and highlights this folder
	      var index = highlightItems.reverse().findIndex(item => !expanded.has(this.props.getKey(item)));
	      this.focusItem(highlightItems[index]);
	    }
	  },
	
	  focusItem(item) {
	    if (!this.props.disabledFocus && this.state.focusedItem !== item) {
	      this.setState({ focusedItem: item });
	
	      if (this.props.onFocus) {
	        this.props.onFocus(item);
	      }
	    }
	  },
	
	  render() {
	    var _this = this;
	
	    var _state = this.state,
	        expanded = _state.expanded,
	        focusedItem = _state.focusedItem;
	
	
	    var props = Object.assign({}, this.props, {
	      isExpanded: item => expanded.has(this.props.getKey(item)),
	      focused: focusedItem,
	
	      onExpand: item => this.setExpanded(item, true),
	      onCollapse: item => this.setExpanded(item, false),
	      onFocus: this.focusItem,
	
	      renderItem: function () {
	        var _props;
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	          args[_key] = arguments[_key];
	        }
	
	        return (_props = _this.props).renderItem.apply(_props, args.concat([{
	          setExpanded: _this.setExpanded
	        }]));
	      }
	    });
	
	    return Tree(props);
	  }
	});
	
	module.exports = ManagedTree;

/***/ },
/* 507 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 508 */,
/* 509 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 510 */,
/* 511 */
/***/ function(module, exports, __webpack_require__) {

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	var React = __webpack_require__(2);
	var dom = React.DOM,
	    PropTypes = React.PropTypes,
	    createFactory = React.createFactory;
	
	
	var ReactDOM = __webpack_require__(22);
	var ImPropTypes = __webpack_require__(450);
	
	var _require = __webpack_require__(3),
	    bindActionCreators = _require.bindActionCreators;
	
	var _require2 = __webpack_require__(305),
	    connect = _require2.connect;
	
	var classnames = __webpack_require__(413);
	
	var SourceEditor = __webpack_require__(512);
	
	var _require3 = __webpack_require__(526),
	    find = _require3.find,
	    findNext = _require3.findNext,
	    findPrev = _require3.findPrev,
	    removeOverlay = _require3.removeOverlay;
	
	var _require4 = __webpack_require__(295),
	    getMode = _require4.getMode;
	
	var Footer = createFactory(__webpack_require__(528));
	var SearchBar = createFactory(__webpack_require__(535));
	
	var _require5 = __webpack_require__(541),
	    renderConditionalPanel = _require5.renderConditionalPanel;
	
	var _require6 = __webpack_require__(129),
	    debugGlobal = _require6.debugGlobal;
	
	var _require7 = __webpack_require__(303),
	    getSourceText = _require7.getSourceText,
	    getBreakpointsForSource = _require7.getBreakpointsForSource,
	    getSelectedLocation = _require7.getSelectedLocation,
	    getSelectedFrame = _require7.getSelectedFrame,
	    getSelectedSource = _require7.getSelectedSource,
	    getHitCountForSource = _require7.getHitCountForSource,
	    getCoverageEnabled = _require7.getCoverageEnabled;
	
	var _require8 = __webpack_require__(297),
	    makeLocationId = _require8.makeLocationId;
	
	var actions = __webpack_require__(314);
	var Breakpoint = React.createFactory(__webpack_require__(542));
	var HitMarker = React.createFactory(__webpack_require__(543));
	
	var _require9 = __webpack_require__(384),
	    getDocument = _require9.getDocument,
	    setDocument = _require9.setDocument;
	
	var _require10 = __webpack_require__(529),
	    shouldShowFooter = _require10.shouldShowFooter,
	    clearLineClass = _require10.clearLineClass,
	    onKeyDown = _require10.onKeyDown;
	
	var _require11 = __webpack_require__(197),
	    isFirefox = _require11.isFirefox;
	
	var _require12 = __webpack_require__(544),
	    showMenu = _require12.showMenu;
	
	var _require13 = __webpack_require__(197),
	    isEnabled = _require13.isEnabled;
	
	var _require14 = __webpack_require__(316),
	    isOriginalId = _require14.isOriginalId,
	    hasMappedSource = _require14.hasMappedSource;
	
	__webpack_require__(545);
	
	function isTextForSource(sourceText) {
	  return !sourceText.get("loading") && !sourceText.get("error");
	}
	
	function breakpointAtLine(breakpoints, line) {
	  return breakpoints.find(b => {
	    return b.location.line === line + 1;
	  });
	}
	
	function getTextForLine(codeMirror, line) {
	  return codeMirror.getLine(line - 1).trim();
	}
	
	function getCursorLine(codeMirror) {
	  return codeMirror.getCursor().line;
	}
	/**
	 * Forces the breakpoint gutter to be the same size as the line
	 * numbers gutter. Editor CSS will absolutely position the gutter
	 * beneath the line numbers. This makes it easy to be flexible with
	 * how we overlay breakpoints.
	 */
	function resizeBreakpointGutter(editor) {
	  var gutters = editor.display.gutters;
	  var lineNumbers = gutters.querySelector(".CodeMirror-linenumbers");
	  var breakpoints = gutters.querySelector(".breakpoints");
	  breakpoints.style.width = `${ lineNumbers.clientWidth }px`;
	}
	
	function traverseResults(e, ctx, dir) {
	  e.stopPropagation() || e.preventDefault();
	  var query = ctx.cm.getSelection();
	  if (dir == "prev") {
	    findPrev(ctx, query);
	  } else if (dir == "next") {
	    findNext(ctx, query);
	  }
	}
	
	function onCursorActivity(ctx) {
	  if (ctx.cm.somethingSelected()) {
	    var query = ctx.cm.getSelection();
	    find(ctx, query, true);
	  } else {
	    removeOverlay(ctx);
	  }
	}
	
	var Editor = React.createClass({
	  propTypes: {
	    breakpoints: ImPropTypes.map.isRequired,
	    hitCount: PropTypes.object,
	    selectedLocation: PropTypes.object,
	    selectedSource: ImPropTypes.map,
	    sourceText: PropTypes.object,
	    addBreakpoint: PropTypes.func,
	    disableBreakpoint: PropTypes.func,
	    enableBreakpoint: PropTypes.func,
	    removeBreakpoint: PropTypes.func,
	    setBreakpointCondition: PropTypes.func,
	    jumpToMappedLocation: PropTypes.func,
	    coverageOn: PropTypes.bool,
	    selectedFrame: PropTypes.object,
	    addExpression: PropTypes.func,
	    horizontal: PropTypes.bool
	  },
	
	  displayName: "Editor",
	
	  contextTypes: {
	    shortcuts: PropTypes.object
	  },
	
	  onGutterClick(cm, line, gutter, ev) {
	    // ignore right clicks in the gutter
	    if (ev.which === 3) {
	      return;
	    }
	
	    if (this.isCbPanelOpen()) {
	      return this.closeConditionalPanel(line);
	    }
	
	    this.toggleBreakpoint(line);
	  },
	
	  onContextMenu(cm, event) {
	    var _this = this;
	
	    return _asyncToGenerator(function* () {
	      if (event.target.classList.contains("CodeMirror-linenumber")) {
	        return _this.onGutterContextMenu(event);
	      }
	
	      var selectedLocation = _this.props.selectedLocation;
	
	
	      event.stopPropagation();
	      event.preventDefault();
	
	      var isMapped = yield hasMappedSource(selectedLocation);
	
	      var _editor$codeMirror$co = _this.editor.codeMirror.coordsChar({
	        left: event.clientX,
	        top: event.clientY
	      }),
	          line = _editor$codeMirror$co.line,
	          ch = _editor$codeMirror$co.ch;
	
	      var sourceLocation = {
	        sourceId: _this.props.selectedLocation.sourceId,
	        line: line + 1,
	        column: ch + 1
	      };
	
	      var pairedType = isOriginalId(_this.props.selectedLocation.sourceId) ? L10N.getStr("generated") : L10N.getStr("original");
	
	      var jumpLabel = {
	        accesskey: "C",
	        disabled: false,
	        label: L10N.getFormatStr("editor.jumpToMappedLocation1", pairedType),
	        click: function () {
	          return _this.props.jumpToMappedLocation(sourceLocation);
	        }
	      };
	
	      var watchExpressionLabel = {
	        accesskey: "E",
	        disabled: !_this.editor.codeMirror.somethingSelected(),
	        label: L10N.getStr("expressions.placeholder"),
	        click: function () {
	          return _this.props.addExpression({
	            input: _this.editor.codeMirror.getSelection()
	          });
	        }
	      };
	
	      var menuOptions = [];
	
	      if (isMapped) {
	        menuOptions.push(jumpLabel);
	      }
	
	      if (isEnabled("watchExpressions")) {
	        menuOptions.push(watchExpressionLabel);
	      }
	
	      showMenu(event, menuOptions);
	    })();
	  },
	
	  onGutterContextMenu(event) {
	    event.stopPropagation();
	    event.preventDefault();
	
	    var line = this.editor.codeMirror.lineAtHeight(event.clientY);
	    var bp = breakpointAtLine(this.props.breakpoints, line);
	    this.showGutterMenu(event, line, bp);
	  },
	
	  showConditionalPanel(line) {
	    if (this.isCbPanelOpen()) {
	      return;
	    }
	
	    var _props = this.props,
	        sourceId = _props.selectedLocation.sourceId,
	        setBreakpointCondition = _props.setBreakpointCondition,
	        breakpoints = _props.breakpoints;
	
	
	    var bp = breakpointAtLine(breakpoints, line);
	    var location = { sourceId, line: line + 1 };
	    var condition = bp ? bp.condition : "";
	
	    var setBreakpoint = value => {
	      setBreakpointCondition(location, {
	        condition: value,
	        getTextForLine: l => getTextForLine(this.editor.codeMirror, l)
	      });
	    };
	
	    var panel = renderConditionalPanel({
	      condition,
	      setBreakpoint,
	      closePanel: this.closeConditionalPanel
	    });
	
	    this.cbPanel = this.editor.codeMirror.addLineWidget(line, panel);
	    this.cbPanel.node.querySelector("input").focus();
	  },
	
	  closeConditionalPanel() {
	    this.cbPanel.clear();
	    this.cbPanel = null;
	  },
	
	  isCbPanelOpen() {
	    return !!this.cbPanel;
	  },
	
	  toggleBreakpoint(line) {
	    var bp = breakpointAtLine(this.props.breakpoints, line);
	
	    if (bp && bp.loading) {
	      return;
	    }
	
	    if (bp) {
	      this.props.removeBreakpoint({
	        sourceId: this.props.selectedLocation.sourceId,
	        line: line + 1
	      });
	    } else {
	      this.props.addBreakpoint({ sourceId: this.props.selectedLocation.sourceId,
	        line: line + 1 },
	      // Pass in a function to get line text because the breakpoint
	      // may slide and it needs to compute the value at the new
	      // line.
	      { getTextForLine: l => getTextForLine(this.editor.codeMirror, l) });
	    }
	  },
	
	  toggleBreakpointDisabledStatus(line) {
	    var bp = breakpointAtLine(this.props.breakpoints, line);
	
	    if (bp && bp.loading) {
	      return;
	    }
	
	    if (!bp) {
	      throw new Error("attempt to disable breakpoint that does not exist");
	    }
	
	    if (!bp.disabled) {
	      this.props.disableBreakpoint({
	        sourceId: this.props.selectedLocation.sourceId,
	        line: line + 1
	      });
	    } else {
	      this.props.enableBreakpoint({
	        sourceId: this.props.selectedLocation.sourceId,
	        line: line + 1
	      });
	    }
	  },
	
	  clearDebugLine(selectedFrame) {
	    if (selectedFrame) {
	      var line = selectedFrame.location.line;
	      this.editor.codeMirror.removeLineClass(line - 1, "line", "debug-line");
	    }
	  },
	
	  setDebugLine(selectedFrame, selectedLocation) {
	    if (selectedFrame && selectedLocation && selectedFrame.location.sourceId === selectedLocation.sourceId) {
	      var line = selectedFrame.location.line;
	      this.editor.codeMirror.addLineClass(line - 1, "line", "debug-line");
	    }
	  },
	
	  // If the location has changed and a specific line is requested,
	  // move to that line and flash it.
	  highlightLine() {
	    if (!this.pendingJumpLine) {
	      return;
	    }
	
	    // Make sure to clean up after ourselves. Not only does this
	    // cancel any existing animation, but it avoids it from
	    // happening ever again (in case CodeMirror re-applies the
	    // class, etc).
	    if (this.lastJumpLine) {
	      clearLineClass(this.editor.codeMirror, "highlight-line");
	    }
	
	    var line = this.pendingJumpLine;
	    this.editor.alignLine(line);
	
	    // We only want to do the flashing animation if it's not a debug
	    // line, which has it's own styling.
	    if (!this.props.selectedFrame || this.props.selectedFrame.location.line !== line) {
	      this.editor.codeMirror.addLineClass(line - 1, "line", "highlight-line");
	    }
	
	    this.lastJumpLine = line;
	    this.pendingJumpLine = null;
	  },
	
	  setText(text) {
	    if (!text || !this.editor) {
	      return;
	    }
	
	    this.editor.setText(text);
	  },
	
	  showGutterMenu(e, line, bp) {
	    var breakpoint = void 0,
	        conditional = void 0,
	        disabled = void 0;
	    if (!bp) {
	      breakpoint = {
	        id: "node-menu-add-breakpoint",
	        label: L10N.getStr("editor.addBreakpoint")
	      };
	      conditional = {
	        id: "node-menu-add-conditional-breakpoint",
	        label: L10N.getStr("editor.addConditionalBreakpoint")
	      };
	    } else {
	      breakpoint = {
	        id: "node-menu-remove-breakpoint",
	        label: L10N.getStr("editor.removeBreakpoint")
	      };
	      conditional = {
	        id: "node-menu-edit-conditional-breakpoint",
	        label: L10N.getStr("editor.editBreakpoint")
	      };
	      if (bp.disabled) {
	        disabled = {
	          id: "node-menu-enable-breakpoint",
	          label: L10N.getStr("editor.enableBreakpoint")
	        };
	      } else {
	        disabled = {
	          id: "node-menu-disable-breakpoint",
	          label: L10N.getStr("editor.disableBreakpoint")
	        };
	      }
	    }
	
	    var toggleBreakpoint = Object.assign({
	      accesskey: "B",
	      disabled: false,
	      click: () => {
	        this.toggleBreakpoint(line);
	        if (this.isCbPanelOpen()) {
	          this.closeConditionalPanel();
	        }
	      }
	    }, breakpoint);
	
	    var conditionalBreakpoint = Object.assign({
	      accesskey: "C",
	      disabled: false,
	      click: () => this.showConditionalPanel(line)
	    }, conditional);
	
	    var items = [toggleBreakpoint, conditionalBreakpoint];
	
	    if (bp) {
	      var disableBreakpoint = Object.assign({
	        accesskey: "D",
	        disabled: false,
	        click: () => this.toggleBreakpointDisabledStatus(line)
	      }, disabled);
	      items.push(disableBreakpoint);
	    }
	
	    showMenu(e, items);
	  },
	
	  componentDidMount() {
	    this.cbPanel = null;
	
	    this.editor = new SourceEditor({
	      mode: "javascript",
	      readOnly: true,
	      lineNumbers: true,
	      theme: "mozilla",
	      lineWrapping: false,
	      matchBrackets: true,
	      showAnnotationRuler: true,
	      enableCodeFolding: false,
	      gutters: ["breakpoints", "hit-markers"],
	      value: " ",
	      extraKeys: {
	        // Override code mirror keymap to avoid conflicts with split console.
	        Esc: false,
	        "Cmd-F": false,
	        "Cmd-G": false
	      }
	    });
	
	    // disables the default search shortcuts
	    this.editor._initShortcuts = () => {};
	
	    this.editor.appendToLocalElement(ReactDOM.findDOMNode(this).querySelector(".editor-mount"));
	
	    this.editor.codeMirror.on("gutterClick", this.onGutterClick);
	
	    // Set code editor wrapper to be focusable
	    this.editor.codeMirror.getWrapperElement().tabIndex = 0;
	    this.editor.codeMirror.getWrapperElement().addEventListener("keydown", e => onKeyDown(this.editor.codeMirror, e));
	
	    var ctx = { ed: this.editor, cm: this.editor.codeMirror };
	    ctx.cm.on("cursorActivity", cm => onCursorActivity(ctx));
	
	    if (!isFirefox()) {
	      this.editor.codeMirror.on("gutterContextMenu", (cm, line, eventName, event) => this.onGutterContextMenu(event));
	
	      this.editor.codeMirror.on("contextmenu", (cm, event) => this.onContextMenu(cm, event));
	    } else {
	      this.editor.codeMirror.getWrapperElement().addEventListener("contextmenu", event => this.onContextMenu(this.editor.codeMirror, event));
	    }
	    var shortcuts = this.context.shortcuts;
	    shortcuts.on("CmdOrCtrl+B", () => this.toggleBreakpoint(getCursorLine(this.editor.codeMirror)));
	    shortcuts.on("CmdOrCtrl+Shift+B", () => this.showConditionalPanel(getCursorLine(this.editor.codeMirror)));
	    // The default Esc command is overridden in the CodeMirror keymap to allow
	    // the Esc keypress event to be catched by the toolbox and trigger the
	    // split console. Restore it here, but preventDefault if and only if there
	    // is a multiselection.
	    shortcuts.on("Esc", (key, e) => {
	      var cm = this.editor.codeMirror;
	      if (cm.listSelections().length > 1) {
	        cm.execCommand("singleSelection");
	        e.preventDefault();
	      }
	    });
	
	    var searchAgainKey = L10N.getStr("sourceSearch.search.again.key");
	    shortcuts.on(`CmdOrCtrl+Shift+${ searchAgainKey }`, (_, e) => traverseResults(e, ctx, "prev"));
	    shortcuts.on(`CmdOrCtrl+${ searchAgainKey }`, (_, e) => traverseResults(e, ctx, "next"));
	
	    resizeBreakpointGutter(this.editor.codeMirror);
	    debugGlobal("cm", this.editor.codeMirror);
	
	    if (this.props.sourceText) {
	      this.setText(this.props.sourceText.get("text"));
	    }
	  },
	
	  componentWillUnmount() {
	    this.editor.destroy();
	    this.editor = null;
	
	    var searchAgainKey = L10N.getStr("sourceSearch.search.again.key");
	    var shortcuts = this.context.shortcuts;
	    shortcuts.off("CmdOrCtrl+B");
	    shortcuts.off("CmdOrCtrl+Shift+B");
	    shortcuts.off(`CmdOrCtrl+Shift+${ searchAgainKey }`);
	    shortcuts.off(`CmdOrCtrl+${ searchAgainKey }`);
	  },
	
	  componentWillReceiveProps(nextProps) {
	    // This lifecycle method is responsible for updating the editor
	    // text.
	    var sourceText = nextProps.sourceText,
	        selectedLocation = nextProps.selectedLocation;
	
	    this.clearDebugLine(this.props.selectedFrame);
	
	    if (!sourceText) {
	      this.showMessage("");
	    } else if (!isTextForSource(sourceText)) {
	      this.showMessage(sourceText.get("error") || L10N.getStr("loadingText"));
	    } else if (this.props.sourceText !== sourceText) {
	      this.showSourceText(sourceText, selectedLocation);
	    }
	
	    this.setDebugLine(nextProps.selectedFrame, selectedLocation);
	    resizeBreakpointGutter(this.editor.codeMirror);
	  },
	
	  showMessage(msg) {
	    this.editor.replaceDocument(this.editor.createDocument());
	    this.setText(msg);
	    this.editor.setMode({ name: "text" });
	  },
	
	  /**
	   * Handle getting the source document or creating a new
	   * document with the correct mode and text.
	   *
	   */
	  showSourceText(sourceText, selectedLocation) {
	    var doc = getDocument(selectedLocation.sourceId);
	    if (doc) {
	      this.editor.replaceDocument(doc);
	      return doc;
	    }
	
	    doc = this.editor.createDocument();
	    setDocument(selectedLocation.sourceId, doc);
	    this.editor.replaceDocument(doc);
	
	    this.setText(sourceText.get("text"));
	    this.editor.setMode(getMode(sourceText.toJS()));
	  },
	
	  componentDidUpdate(prevProps) {
	    // This is in `componentDidUpdate` so helper functions can expect
	    // `this.props` to be the current props. This lifecycle method is
	    // responsible for updating the editor annotations.
	    var selectedLocation = this.props.selectedLocation;
	
	    // If the location is different and a new line is requested,
	    // update the pending jump line. Note that if jumping to a line in
	    // a source where the text hasn't been loaded yet, we will set the
	    // line here but not jump until rendering the actual source.
	
	    if (prevProps.selectedLocation !== selectedLocation) {
	      if (selectedLocation && selectedLocation.line != undefined) {
	        this.pendingJumpLine = selectedLocation.line;
	      } else {
	        this.pendingJumpLine = null;
	      }
	    }
	
	    // Only update and jump around in real source texts. This will
	    // keep the jump state around until the real source text is
	    // loaded.
	    if (this.props.sourceText && isTextForSource(this.props.sourceText)) {
	      this.highlightLine();
	    }
	  },
	
	  renderBreakpoints() {
	    var _props2 = this.props,
	        breakpoints = _props2.breakpoints,
	        sourceText = _props2.sourceText;
	
	    var isLoading = sourceText && sourceText.get("loading");
	
	    if (isLoading) {
	      return;
	    }
	
	    return breakpoints.valueSeq().map(bp => {
	      return Breakpoint({
	        key: makeLocationId(bp.location),
	        breakpoint: bp,
	        editor: this.editor && this.editor.codeMirror
	      });
	    });
	  },
	
	  renderHitCounts() {
	    var _props3 = this.props,
	        hitCount = _props3.hitCount,
	        sourceText = _props3.sourceText;
	
	    var isLoading = sourceText && sourceText.get("loading");
	
	    if (isLoading || !hitCount) {
	      return;
	    }
	
	    return hitCount.filter(marker => marker.get("count") > 0).map(marker => {
	      return HitMarker({
	        key: marker.get("line"),
	        hitData: marker.toJS(),
	        editor: this.editor && this.editor.codeMirror
	      });
	    });
	  },
	
	  editorHeight() {
	    var _props4 = this.props,
	        selectedSource = _props4.selectedSource,
	        horizontal = _props4.horizontal;
	
	
	    if (!shouldShowFooter(selectedSource, horizontal)) {
	      return "100%";
	    }
	
	    return "";
	  },
	
	  render() {
	    var _props5 = this.props,
	        sourceText = _props5.sourceText,
	        selectedSource = _props5.selectedSource,
	        coverageOn = _props5.coverageOn,
	        horizontal = _props5.horizontal;
	
	
	    return dom.div({
	      className: classnames("editor-wrapper devtools-monospace", { "coverage-on": coverageOn })
	    }, SearchBar({
	      editor: this.editor,
	      selectedSource,
	      sourceText
	    }), dom.div({
	      className: "editor-mount",
	      style: { height: this.editorHeight() }
	    }), this.renderBreakpoints(), this.renderHitCounts(), Footer({ editor: this.editor, horizontal }));
	  }
	});
	
	module.exports = connect(state => {
	  var selectedLocation = getSelectedLocation(state);
	  var sourceId = selectedLocation && selectedLocation.sourceId;
	  var selectedSource = getSelectedSource(state);
	
	  return {
	    selectedLocation,
	    selectedSource,
	    sourceText: getSourceText(state, sourceId),
	    breakpoints: getBreakpointsForSource(state, sourceId),
	    hitCount: getHitCountForSource(state, sourceId),
	    selectedFrame: getSelectedFrame(state),
	    coverageOn: getCoverageEnabled(state)
	  };
	}, dispatch => bindActionCreators(actions, dispatch))(Editor);

/***/ },
/* 512 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * CodeMirror source editor utils
	 * @module utils/source-editor
	 */
	
	var CodeMirror = __webpack_require__(513);
	
	__webpack_require__(514);
	__webpack_require__(516);
	__webpack_require__(517);
	__webpack_require__(520);
	__webpack_require__(521);
	__webpack_require__(522);
	__webpack_require__(523);
	__webpack_require__(525);
	
	// Maximum allowed margin (in number of lines) from top or bottom of the editor
	// while shifting to a line which was initially out of view.
	var MAX_VERTICAL_OFFSET = 3;
	
	class SourceEditor {
	  constructor(opts) {
	    this.opts = opts;
	  }
	
	  appendToLocalElement(node) {
	    this.editor = CodeMirror(node, this.opts);
	  }
	
	  destroy() {
	    // No need to do anything.
	  }
	
	  get codeMirror() {
	    return this.editor;
	  }
	
	  setText(str) {
	    this.editor.setValue(str);
	  }
	
	  getText() {
	    return this.editor.getValue();
	  }
	
	  setMode(value) {
	    this.editor.setOption("mode", value);
	  }
	
	  /**
	   * Replaces the current document with a new source document
	   * @memberof utils/source-editor
	   */
	  replaceDocument(doc) {
	    this.editor.swapDoc(doc);
	  }
	
	  /**
	   * Creates a CodeMirror Document
	   * @returns CodeMirror.Doc
	   * @memberof utils/source-editor
	   */
	  createDocument() {
	    return new CodeMirror.Doc("");
	  }
	
	  /**
	   * Aligns the provided line to either "top", "center" or "bottom" of the
	   * editor view with a maximum margin of MAX_VERTICAL_OFFSET lines from top or
	   * bottom.
	   * @memberof utils/source-editor
	   */
	  alignLine(line) {
	    var align = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "top";
	
	    var cm = this.editor;
	    var from = cm.lineAtHeight(0, "page");
	    var to = cm.lineAtHeight(cm.getWrapperElement().clientHeight, "page");
	    var linesVisible = to - from;
	    var halfVisible = Math.round(linesVisible / 2);
	
	    // If the target line is in view, skip the vertical alignment part.
	    if (line <= to && line >= from) {
	      return;
	    }
	
	    // Setting the offset so that the line always falls in the upper half
	    // of visible lines (lower half for bottom aligned).
	    // MAX_VERTICAL_OFFSET is the maximum allowed value.
	    var offset = Math.min(halfVisible, MAX_VERTICAL_OFFSET);
	
	    var topLine = {
	      "center": Math.max(line - halfVisible, 0),
	      "bottom": Math.max(line - linesVisible + offset, 0),
	      "top": Math.max(line - offset, 0)
	    }[align || "top"] || offset;
	
	    // Bringing down the topLine to total lines in the editor if exceeding.
	    topLine = Math.min(topLine, cm.lineCount());
	    this.setFirstVisibleLine(topLine);
	  }
	
	  /**
	   * Scrolls the view such that the given line number is the first visible line.
	   * @memberof utils/source-editor
	   */
	  setFirstVisibleLine(line) {
	    var _editor$charCoords = this.editor.charCoords({ line: line, ch: 0 }, "local"),
	        top = _editor$charCoords.top;
	
	    this.editor.scrollTo(0, top);
	  }
	}
	
	module.exports = SourceEditor;

/***/ },
/* 513 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	// This is CodeMirror (http://codemirror.net), a code editor
	// implemented in JavaScript on top of the browser's DOM.
	//
	// You can find some technical background for some of the code below
	// at http://marijnhaverbeke.nl/blog/#cm-internals .
	
	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  (global.CodeMirror = factory());
	}(this, (function () { 'use strict';
	
	// Kludges for bugs and behavior differences that can't be feature
	// detected are enabled based on userAgent etc sniffing.
	var userAgent = navigator.userAgent
	var platform = navigator.platform
	
	var gecko = /gecko\/\d/i.test(userAgent)
	var ie_upto10 = /MSIE \d/.test(userAgent)
	var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent)
	var ie = ie_upto10 || ie_11up
	var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1])
	var webkit = /WebKit\//.test(userAgent)
	var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent)
	var chrome = /Chrome\//.test(userAgent)
	var presto = /Opera\//.test(userAgent)
	var safari = /Apple Computer/.test(navigator.vendor)
	var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent)
	var phantom = /PhantomJS/.test(userAgent)
	
	var ios = /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent)
	// This is woefully incomplete. Suggestions for alternative methods welcome.
	var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent)
	var mac = ios || /Mac/.test(platform)
	var chromeOS = /\bCrOS\b/.test(userAgent)
	var windows = /win/i.test(platform)
	
	var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/)
	if (presto_version) { presto_version = Number(presto_version[1]) }
	if (presto_version && presto_version >= 15) { presto = false; webkit = true }
	// Some browsers use the wrong event properties to signal cmd/ctrl on OS X
	var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11))
	var captureRightClick = gecko || (ie && ie_version >= 9)
	
	function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }
	
	var rmClass = function(node, cls) {
	  var current = node.className
	  var match = classTest(cls).exec(current)
	  if (match) {
	    var after = current.slice(match.index + match[0].length)
	    node.className = current.slice(0, match.index) + (after ? match[1] + after : "")
	  }
	}
	
	function removeChildren(e) {
	  for (var count = e.childNodes.length; count > 0; --count)
	    { e.removeChild(e.firstChild) }
	  return e
	}
	
	function removeChildrenAndAdd(parent, e) {
	  return removeChildren(parent).appendChild(e)
	}
	
	function elt(tag, content, className, style) {
	  var e = document.createElement(tag)
	  if (className) { e.className = className }
	  if (style) { e.style.cssText = style }
	  if (typeof content == "string") { e.appendChild(document.createTextNode(content)) }
	  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]) } }
	  return e
	}
	
	var range
	if (document.createRange) { range = function(node, start, end, endNode) {
	  var r = document.createRange()
	  r.setEnd(endNode || node, end)
	  r.setStart(node, start)
	  return r
	} }
	else { range = function(node, start, end) {
	  var r = document.body.createTextRange()
	  try { r.moveToElementText(node.parentNode) }
	  catch(e) { return r }
	  r.collapse(true)
	  r.moveEnd("character", end)
	  r.moveStart("character", start)
	  return r
	} }
	
	function contains(parent, child) {
	  if (child.nodeType == 3) // Android browser always returns false when child is a textnode
	    { child = child.parentNode }
	  if (parent.contains)
	    { return parent.contains(child) }
	  do {
	    if (child.nodeType == 11) { child = child.host }
	    if (child == parent) { return true }
	  } while (child = child.parentNode)
	}
	
	function activeElt() {
	  // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
	  // IE < 10 will throw when accessed while the page is loading or in an iframe.
	  // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
	  var activeElement
	  try {
	    activeElement = document.activeElement
	  } catch(e) {
	    activeElement = document.body || null
	  }
	  while (activeElement && activeElement.root && activeElement.root.activeElement)
	    { activeElement = activeElement.root.activeElement }
	  return activeElement
	}
	
	function addClass(node, cls) {
	  var current = node.className
	  if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls }
	}
	function joinClasses(a, b) {
	  var as = a.split(" ")
	  for (var i = 0; i < as.length; i++)
	    { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i] } }
	  return b
	}
	
	var selectInput = function(node) { node.select() }
	if (ios) // Mobile Safari apparently has a bug where select() is broken.
	  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length } }
	else if (ie) // Suppress mysterious IE10 errors
	  { selectInput = function(node) { try { node.select() } catch(_e) {} } }
	
	function bind(f) {
	  var args = Array.prototype.slice.call(arguments, 1)
	  return function(){return f.apply(null, args)}
	}
	
	function copyObj(obj, target, overwrite) {
	  if (!target) { target = {} }
	  for (var prop in obj)
	    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
	      { target[prop] = obj[prop] } }
	  return target
	}
	
	// Counts the column offset in a string, taking tabs into account.
	// Used mostly to find indentation.
	function countColumn(string, end, tabSize, startIndex, startValue) {
	  if (end == null) {
	    end = string.search(/[^\s\u00a0]/)
	    if (end == -1) { end = string.length }
	  }
	  for (var i = startIndex || 0, n = startValue || 0;;) {
	    var nextTab = string.indexOf("\t", i)
	    if (nextTab < 0 || nextTab >= end)
	      { return n + (end - i) }
	    n += nextTab - i
	    n += tabSize - (n % tabSize)
	    i = nextTab + 1
	  }
	}
	
	function Delayed() {this.id = null}
	Delayed.prototype.set = function(ms, f) {
	  clearTimeout(this.id)
	  this.id = setTimeout(f, ms)
	}
	
	function indexOf(array, elt) {
	  for (var i = 0; i < array.length; ++i)
	    { if (array[i] == elt) { return i } }
	  return -1
	}
	
	// Number of pixels added to scroller and sizer to hide scrollbar
	var scrollerGap = 30
	
	// Returned or thrown by various protocols to signal 'I'm not
	// handling this'.
	var Pass = {toString: function(){return "CodeMirror.Pass"}}
	
	// Reused option objects for setSelection & friends
	var sel_dontScroll = {scroll: false};
	var sel_mouse = {origin: "*mouse"};
	var sel_move = {origin: "+move"};
	// The inverse of countColumn -- find the offset that corresponds to
	// a particular column.
	function findColumn(string, goal, tabSize) {
	  for (var pos = 0, col = 0;;) {
	    var nextTab = string.indexOf("\t", pos)
	    if (nextTab == -1) { nextTab = string.length }
	    var skipped = nextTab - pos
	    if (nextTab == string.length || col + skipped >= goal)
	      { return pos + Math.min(skipped, goal - col) }
	    col += nextTab - pos
	    col += tabSize - (col % tabSize)
	    pos = nextTab + 1
	    if (col >= goal) { return pos }
	  }
	}
	
	var spaceStrs = [""]
	function spaceStr(n) {
	  while (spaceStrs.length <= n)
	    { spaceStrs.push(lst(spaceStrs) + " ") }
	  return spaceStrs[n]
	}
	
	function lst(arr) { return arr[arr.length-1] }
	
	function map(array, f) {
	  var out = []
	  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i) }
	  return out
	}
	
	function insertSorted(array, value, score) {
	  var pos = 0, priority = score(value)
	  while (pos < array.length && score(array[pos]) <= priority) { pos++ }
	  array.splice(pos, 0, value)
	}
	
	function nothing() {}
	
	function createObj(base, props) {
	  var inst
	  if (Object.create) {
	    inst = Object.create(base)
	  } else {
	    nothing.prototype = base
	    inst = new nothing()
	  }
	  if (props) { copyObj(props, inst) }
	  return inst
	}
	
	var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/
	function isWordCharBasic(ch) {
	  return /\w/.test(ch) || ch > "\x80" &&
	    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
	}
	function isWordChar(ch, helper) {
	  if (!helper) { return isWordCharBasic(ch) }
	  if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
	  return helper.test(ch)
	}
	
	function isEmpty(obj) {
	  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
	  return true
	}
	
	// Extending unicode characters. A series of a non-extending char +
	// any number of extending chars is treated as a single unit as far
	// as editing and measuring is concerned. This is not fully correct,
	// since some scripts/fonts/browsers also treat other configurations
	// of code points as a group.
	var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/
	function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }
	
	// The display handles the DOM integration, both for input reading
	// and content drawing. It holds references to DOM nodes and
	// display-related state.
	
	function Display(place, doc, input) {
	  var d = this
	  this.input = input
	
	  // Covers bottom-right square when both scrollbars are present.
	  d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler")
	  d.scrollbarFiller.setAttribute("cm-not-content", "true")
	  // Covers bottom of gutter when coverGutterNextToScrollbar is on
	  // and h scrollbar is present.
	  d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler")
	  d.gutterFiller.setAttribute("cm-not-content", "true")
	  // Will contain the actual code, positioned to cover the viewport.
	  d.lineDiv = elt("div", null, "CodeMirror-code")
	  // Elements are added to these to represent selection and cursors.
	  d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1")
	  d.cursorDiv = elt("div", null, "CodeMirror-cursors")
	  // A visibility: hidden element used to find the size of things.
	  d.measure = elt("div", null, "CodeMirror-measure")
	  // When lines outside of the viewport are measured, they are drawn in this.
	  d.lineMeasure = elt("div", null, "CodeMirror-measure")
	  // Wraps everything that needs to exist inside the vertically-padded coordinate system
	  d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
	                    null, "position: relative; outline: none")
	  // Moved around its parent to cover visible view.
	  d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative")
	  // Set to the height of the document, allowing scrolling.
	  d.sizer = elt("div", [d.mover], "CodeMirror-sizer")
	  d.sizerWidth = null
	  // Behavior of elts with overflow: auto and padding is
	  // inconsistent across browsers. This is used to ensure the
	  // scrollable area is big enough.
	  d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;")
	  // Will contain the gutters, if any.
	  d.gutters = elt("div", null, "CodeMirror-gutters")
	  d.lineGutter = null
	  // Actual scrollable element.
	  d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll")
	  d.scroller.setAttribute("tabIndex", "-1")
	  // The element in which the editor lives.
	  d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror")
	
	  // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
	  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0 }
	  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true }
	
	  if (place) {
	    if (place.appendChild) { place.appendChild(d.wrapper) }
	    else { place(d.wrapper) }
	  }
	
	  // Current rendered range (may be bigger than the view window).
	  d.viewFrom = d.viewTo = doc.first
	  d.reportedViewFrom = d.reportedViewTo = doc.first
	  // Information about the rendered lines.
	  d.view = []
	  d.renderedView = null
	  // Holds info about a single rendered line when it was rendered
	  // for measurement, while not in view.
	  d.externalMeasured = null
	  // Empty space (in pixels) above the view
	  d.viewOffset = 0
	  d.lastWrapHeight = d.lastWrapWidth = 0
	  d.updateLineNumbers = null
	
	  d.nativeBarWidth = d.barHeight = d.barWidth = 0
	  d.scrollbarsClipped = false
	
	  // Used to only resize the line number gutter when necessary (when
	  // the amount of lines crosses a boundary that makes its width change)
	  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null
	  // Set to true when a non-horizontal-scrolling line widget is
	  // added. As an optimization, line widget aligning is skipped when
	  // this is false.
	  d.alignWidgets = false
	
	  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null
	
	  // Tracks the maximum line length so that the horizontal scrollbar
	  // can be kept static when scrolling.
	  d.maxLine = null
	  d.maxLineLength = 0
	  d.maxLineChanged = false
	
	  // Used for measuring wheel scrolling granularity
	  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null
	
	  // True when shift is held down.
	  d.shift = false
	
	  // Used to track whether anything happened since the context menu
	  // was opened.
	  d.selForContextMenu = null
	
	  d.activeTouch = null
	
	  input.init(d)
	}
	
	// Find the line object corresponding to the given line number.
	function getLine(doc, n) {
	  n -= doc.first
	  if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
	  var chunk = doc
	  while (!chunk.lines) {
	    for (var i = 0;; ++i) {
	      var child = chunk.children[i], sz = child.chunkSize()
	      if (n < sz) { chunk = child; break }
	      n -= sz
	    }
	  }
	  return chunk.lines[n]
	}
	
	// Get the part of a document between two positions, as an array of
	// strings.
	function getBetween(doc, start, end) {
	  var out = [], n = start.line
	  doc.iter(start.line, end.line + 1, function (line) {
	    var text = line.text
	    if (n == end.line) { text = text.slice(0, end.ch) }
	    if (n == start.line) { text = text.slice(start.ch) }
	    out.push(text)
	    ++n
	  })
	  return out
	}
	// Get the lines between from and to, as array of strings.
	function getLines(doc, from, to) {
	  var out = []
	  doc.iter(from, to, function (line) { out.push(line.text) }) // iter aborts when callback returns truthy value
	  return out
	}
	
	// Update the height of a line, propagating the height change
	// upwards to parent nodes.
	function updateLineHeight(line, height) {
	  var diff = height - line.height
	  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff } }
	}
	
	// Given a line object, find its line number by walking up through
	// its parent links.
	function lineNo(line) {
	  if (line.parent == null) { return null }
	  var cur = line.parent, no = indexOf(cur.lines, line)
	  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
	    for (var i = 0;; ++i) {
	      if (chunk.children[i] == cur) { break }
	      no += chunk.children[i].chunkSize()
	    }
	  }
	  return no + cur.first
	}
	
	// Find the line at the given vertical position, using the height
	// information in the document tree.
	function lineAtHeight(chunk, h) {
	  var n = chunk.first
	  outer: do {
	    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
	      var child = chunk.children[i$1], ch = child.height
	      if (h < ch) { chunk = child; continue outer }
	      h -= ch
	      n += child.chunkSize()
	    }
	    return n
	  } while (!chunk.lines)
	  var i = 0
	  for (; i < chunk.lines.length; ++i) {
	    var line = chunk.lines[i], lh = line.height
	    if (h < lh) { break }
	    h -= lh
	  }
	  return n + i
	}
	
	function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}
	
	function lineNumberFor(options, i) {
	  return String(options.lineNumberFormatter(i + options.firstLineNumber))
	}
	
	// A Pos instance represents a position within the text.
	function Pos (line, ch) {
	  if (!(this instanceof Pos)) { return new Pos(line, ch) }
	  this.line = line; this.ch = ch
	}
	
	// Compare two positions, return 0 if they are the same, a negative
	// number when a is less, and a positive number otherwise.
	function cmp(a, b) { return a.line - b.line || a.ch - b.ch }
	
	function copyPos(x) {return Pos(x.line, x.ch)}
	function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
	function minPos(a, b) { return cmp(a, b) < 0 ? a : b }
	
	// Most of the external API clips given positions to make sure they
	// actually exist within the document.
	function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
	function clipPos(doc, pos) {
	  if (pos.line < doc.first) { return Pos(doc.first, 0) }
	  var last = doc.first + doc.size - 1
	  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
	  return clipToLen(pos, getLine(doc, pos.line).text.length)
	}
	function clipToLen(pos, linelen) {
	  var ch = pos.ch
	  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
	  else if (ch < 0) { return Pos(pos.line, 0) }
	  else { return pos }
	}
	function clipPosArray(doc, array) {
	  var out = []
	  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]) }
	  return out
	}
	
	// Optimize some code when these features are not used.
	var sawReadOnlySpans = false;
	var sawCollapsedSpans = false;
	function seeReadOnlySpans() {
	  sawReadOnlySpans = true
	}
	
	function seeCollapsedSpans() {
	  sawCollapsedSpans = true
	}
	
	// TEXTMARKER SPANS
	
	function MarkedSpan(marker, from, to) {
	  this.marker = marker
	  this.from = from; this.to = to
	}
	
	// Search an array of spans for a span matching the given marker.
	function getMarkedSpanFor(spans, marker) {
	  if (spans) { for (var i = 0; i < spans.length; ++i) {
	    var span = spans[i]
	    if (span.marker == marker) { return span }
	  } }
	}
	// Remove a span from an array, returning undefined if no spans are
	// left (we don't store arrays for lines without spans).
	function removeMarkedSpan(spans, span) {
	  var r
	  for (var i = 0; i < spans.length; ++i)
	    { if (spans[i] != span) { (r || (r = [])).push(spans[i]) } }
	  return r
	}
	// Add a span to a line.
	function addMarkedSpan(line, span) {
	  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span]
	  span.marker.attachLine(line)
	}
	
	// Used for the algorithm that adjusts markers for a change in the
	// document. These functions cut an array of spans at a given
	// character position, returning an array of remaining chunks (or
	// undefined if nothing remains).
	function markedSpansBefore(old, startCh, isInsert) {
	  var nw
	  if (old) { for (var i = 0; i < old.length; ++i) {
	    var span = old[i], marker = span.marker
	    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh)
	    if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
	      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)
	      ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to))
	    }
	  } }
	  return nw
	}
	function markedSpansAfter(old, endCh, isInsert) {
	  var nw
	  if (old) { for (var i = 0; i < old.length; ++i) {
	    var span = old[i], marker = span.marker
	    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh)
	    if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
	      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)
	      ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
	                                            span.to == null ? null : span.to - endCh))
	    }
	  } }
	  return nw
	}
	
	// Given a change object, compute the new set of marker spans that
	// cover the line in which the change took place. Removes spans
	// entirely within the change, reconnects spans belonging to the
	// same marker that appear on both sides of the change, and cuts off
	// spans partially within the change. Returns an array of span
	// arrays with one element for each line in (after) the change.
	function stretchSpansOverChange(doc, change) {
	  if (change.full) { return null }
	  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans
	  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans
	  if (!oldFirst && !oldLast) { return null }
	
	  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0
	  // Get the spans that 'stick out' on both sides
	  var first = markedSpansBefore(oldFirst, startCh, isInsert)
	  var last = markedSpansAfter(oldLast, endCh, isInsert)
	
	  // Next, merge those two ends
	  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0)
	  if (first) {
	    // Fix up .to properties of first
	    for (var i = 0; i < first.length; ++i) {
	      var span = first[i]
	      if (span.to == null) {
	        var found = getMarkedSpanFor(last, span.marker)
	        if (!found) { span.to = startCh }
	        else if (sameLine) { span.to = found.to == null ? null : found.to + offset }
	      }
	    }
	  }
	  if (last) {
	    // Fix up .from in last (or move them into first in case of sameLine)
	    for (var i$1 = 0; i$1 < last.length; ++i$1) {
	      var span$1 = last[i$1]
	      if (span$1.to != null) { span$1.to += offset }
	      if (span$1.from == null) {
	        var found$1 = getMarkedSpanFor(first, span$1.marker)
	        if (!found$1) {
	          span$1.from = offset
	          if (sameLine) { (first || (first = [])).push(span$1) }
	        }
	      } else {
	        span$1.from += offset
	        if (sameLine) { (first || (first = [])).push(span$1) }
	      }
	    }
	  }
	  // Make sure we didn't create any zero-length spans
	  if (first) { first = clearEmptySpans(first) }
	  if (last && last != first) { last = clearEmptySpans(last) }
	
	  var newMarkers = [first]
	  if (!sameLine) {
	    // Fill gap with whole-line-spans
	    var gap = change.text.length - 2, gapMarkers
	    if (gap > 0 && first)
	      { for (var i$2 = 0; i$2 < first.length; ++i$2)
	        { if (first[i$2].to == null)
	          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)) } } }
	    for (var i$3 = 0; i$3 < gap; ++i$3)
	      { newMarkers.push(gapMarkers) }
	    newMarkers.push(last)
	  }
	  return newMarkers
	}
	
	// Remove spans that are empty and don't have a clearWhenEmpty
	// option of false.
	function clearEmptySpans(spans) {
	  for (var i = 0; i < spans.length; ++i) {
	    var span = spans[i]
	    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
	      { spans.splice(i--, 1) }
	  }
	  if (!spans.length) { return null }
	  return spans
	}
	
	// Used to 'clip' out readOnly ranges when making a change.
	function removeReadOnlyRanges(doc, from, to) {
	  var markers = null
	  doc.iter(from.line, to.line + 1, function (line) {
	    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
	      var mark = line.markedSpans[i].marker
	      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
	        { (markers || (markers = [])).push(mark) }
	    } }
	  })
	  if (!markers) { return null }
	  var parts = [{from: from, to: to}]
	  for (var i = 0; i < markers.length; ++i) {
	    var mk = markers[i], m = mk.find(0)
	    for (var j = 0; j < parts.length; ++j) {
	      var p = parts[j]
	      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
	      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to)
	      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
	        { newParts.push({from: p.from, to: m.from}) }
	      if (dto > 0 || !mk.inclusiveRight && !dto)
	        { newParts.push({from: m.to, to: p.to}) }
	      parts.splice.apply(parts, newParts)
	      j += newParts.length - 1
	    }
	  }
	  return parts
	}
	
	// Connect or disconnect spans from a line.
	function detachMarkedSpans(line) {
	  var spans = line.markedSpans
	  if (!spans) { return }
	  for (var i = 0; i < spans.length; ++i)
	    { spans[i].marker.detachLine(line) }
	  line.markedSpans = null
	}
	function attachMarkedSpans(line, spans) {
	  if (!spans) { return }
	  for (var i = 0; i < spans.length; ++i)
	    { spans[i].marker.attachLine(line) }
	  line.markedSpans = spans
	}
	
	// Helpers used when computing which overlapping collapsed span
	// counts as the larger one.
	function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
	function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }
	
	// Returns a number indicating which of two overlapping collapsed
	// spans is larger (and thus includes the other). Falls back to
	// comparing ids when the spans cover exactly the same range.
	function compareCollapsedMarkers(a, b) {
	  var lenDiff = a.lines.length - b.lines.length
	  if (lenDiff != 0) { return lenDiff }
	  var aPos = a.find(), bPos = b.find()
	  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b)
	  if (fromCmp) { return -fromCmp }
	  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b)
	  if (toCmp) { return toCmp }
	  return b.id - a.id
	}
	
	// Find out whether a line ends or starts in a collapsed span. If
	// so, return the marker for that span.
	function collapsedSpanAtSide(line, start) {
	  var sps = sawCollapsedSpans && line.markedSpans, found
	  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
	    sp = sps[i]
	    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
	        (!found || compareCollapsedMarkers(found, sp.marker) < 0))
	      { found = sp.marker }
	  } }
	  return found
	}
	function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
	function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }
	
	// Test whether there exists a collapsed span that partially
	// overlaps (covers the start or end, but not both) of a new span.
	// Such overlap is not allowed.
	function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
	  var line = getLine(doc, lineNo)
	  var sps = sawCollapsedSpans && line.markedSpans
	  if (sps) { for (var i = 0; i < sps.length; ++i) {
	    var sp = sps[i]
	    if (!sp.marker.collapsed) { continue }
	    var found = sp.marker.find(0)
	    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker)
	    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker)
	    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
	    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
	        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
	      { return true }
	  } }
	}
	
	// A visual line is a line as drawn on the screen. Folding, for
	// example, can cause multiple logical lines to appear on the same
	// visual line. This finds the start of the visual line that the
	// given line is part of (usually that is the line itself).
	function visualLine(line) {
	  var merged
	  while (merged = collapsedSpanAtStart(line))
	    { line = merged.find(-1, true).line }
	  return line
	}
	
	// Returns an array of logical lines that continue the visual line
	// started by the argument, or undefined if there are no such lines.
	function visualLineContinued(line) {
	  var merged, lines
	  while (merged = collapsedSpanAtEnd(line)) {
	    line = merged.find(1, true).line
	    ;(lines || (lines = [])).push(line)
	  }
	  return lines
	}
	
	// Get the line number of the start of the visual line that the
	// given line number is part of.
	function visualLineNo(doc, lineN) {
	  var line = getLine(doc, lineN), vis = visualLine(line)
	  if (line == vis) { return lineN }
	  return lineNo(vis)
	}
	
	// Get the line number of the start of the next visual line after
	// the given line.
	function visualLineEndNo(doc, lineN) {
	  if (lineN > doc.lastLine()) { return lineN }
	  var line = getLine(doc, lineN), merged
	  if (!lineIsHidden(doc, line)) { return lineN }
	  while (merged = collapsedSpanAtEnd(line))
	    { line = merged.find(1, true).line }
	  return lineNo(line) + 1
	}
	
	// Compute whether a line is hidden. Lines count as hidden when they
	// are part of a visual line that starts with another line, or when
	// they are entirely covered by collapsed, non-widget span.
	function lineIsHidden(doc, line) {
	  var sps = sawCollapsedSpans && line.markedSpans
	  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
	    sp = sps[i]
	    if (!sp.marker.collapsed) { continue }
	    if (sp.from == null) { return true }
	    if (sp.marker.widgetNode) { continue }
	    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
	      { return true }
	  } }
	}
	function lineIsHiddenInner(doc, line, span) {
	  if (span.to == null) {
	    var end = span.marker.find(1, true)
	    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
	  }
	  if (span.marker.inclusiveRight && span.to == line.text.length)
	    { return true }
	  for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
	    sp = line.markedSpans[i]
	    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
	        (sp.to == null || sp.to != span.from) &&
	        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
	        lineIsHiddenInner(doc, line, sp)) { return true }
	  }
	}
	
	// Find the height above the given line.
	function heightAtLine(lineObj) {
	  lineObj = visualLine(lineObj)
	
	  var h = 0, chunk = lineObj.parent
	  for (var i = 0; i < chunk.lines.length; ++i) {
	    var line = chunk.lines[i]
	    if (line == lineObj) { break }
	    else { h += line.height }
	  }
	  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
	    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
	      var cur = p.children[i$1]
	      if (cur == chunk) { break }
	      else { h += cur.height }
	    }
	  }
	  return h
	}
	
	// Compute the character length of a line, taking into account
	// collapsed ranges (see markText) that might hide parts, and join
	// other lines onto it.
	function lineLength(line) {
	  if (line.height == 0) { return 0 }
	  var len = line.text.length, merged, cur = line
	  while (merged = collapsedSpanAtStart(cur)) {
	    var found = merged.find(0, true)
	    cur = found.from.line
	    len += found.from.ch - found.to.ch
	  }
	  cur = line
	  while (merged = collapsedSpanAtEnd(cur)) {
	    var found$1 = merged.find(0, true)
	    len -= cur.text.length - found$1.from.ch
	    cur = found$1.to.line
	    len += cur.text.length - found$1.to.ch
	  }
	  return len
	}
	
	// Find the longest line in the document.
	function findMaxLine(cm) {
	  var d = cm.display, doc = cm.doc
	  d.maxLine = getLine(doc, doc.first)
	  d.maxLineLength = lineLength(d.maxLine)
	  d.maxLineChanged = true
	  doc.iter(function (line) {
	    var len = lineLength(line)
	    if (len > d.maxLineLength) {
	      d.maxLineLength = len
	      d.maxLine = line
	    }
	  })
	}
	
	// BIDI HELPERS
	
	function iterateBidiSections(order, from, to, f) {
	  if (!order) { return f(from, to, "ltr") }
	  var found = false
	  for (var i = 0; i < order.length; ++i) {
	    var part = order[i]
	    if (part.from < to && part.to > from || from == to && part.to == from) {
	      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr")
	      found = true
	    }
	  }
	  if (!found) { f(from, to, "ltr") }
	}
	
	function bidiLeft(part) { return part.level % 2 ? part.to : part.from }
	function bidiRight(part) { return part.level % 2 ? part.from : part.to }
	
	function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0 }
	function lineRight(line) {
	  var order = getOrder(line)
	  if (!order) { return line.text.length }
	  return bidiRight(lst(order))
	}
	
	function compareBidiLevel(order, a, b) {
	  var linedir = order[0].level
	  if (a == linedir) { return true }
	  if (b == linedir) { return false }
	  return a < b
	}
	
	var bidiOther = null
	function getBidiPartAt(order, pos) {
	  var found
	  bidiOther = null
	  for (var i = 0; i < order.length; ++i) {
	    var cur = order[i]
	    if (cur.from < pos && cur.to > pos) { return i }
	    if ((cur.from == pos || cur.to == pos)) {
	      if (found == null) {
	        found = i
	      } else if (compareBidiLevel(order, cur.level, order[found].level)) {
	        if (cur.from != cur.to) { bidiOther = found }
	        return i
	      } else {
	        if (cur.from != cur.to) { bidiOther = i }
	        return found
	      }
	    }
	  }
	  return found
	}
	
	function moveInLine(line, pos, dir, byUnit) {
	  if (!byUnit) { return pos + dir }
	  do { pos += dir }
	  while (pos > 0 && isExtendingChar(line.text.charAt(pos)))
	  return pos
	}
	
	// This is needed in order to move 'visually' through bi-directional
	// text -- i.e., pressing left should make the cursor go left, even
	// when in RTL text. The tricky part is the 'jumps', where RTL and
	// LTR text touch each other. This often requires the cursor offset
	// to move more than one unit, in order to visually move one unit.
	function moveVisually(line, start, dir, byUnit) {
	  var bidi = getOrder(line)
	  if (!bidi) { return moveLogically(line, start, dir, byUnit) }
	  var pos = getBidiPartAt(bidi, start), part = bidi[pos]
	  var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit)
	
	  for (;;) {
	    if (target > part.from && target < part.to) { return target }
	    if (target == part.from || target == part.to) {
	      if (getBidiPartAt(bidi, target) == pos) { return target }
	      part = bidi[pos += dir]
	      return (dir > 0) == part.level % 2 ? part.to : part.from
	    } else {
	      part = bidi[pos += dir]
	      if (!part) { return null }
	      if ((dir > 0) == part.level % 2)
	        { target = moveInLine(line, part.to, -1, byUnit) }
	      else
	        { target = moveInLine(line, part.from, 1, byUnit) }
	    }
	  }
	}
	
	function moveLogically(line, start, dir, byUnit) {
	  var target = start + dir
	  if (byUnit) { while (target > 0 && isExtendingChar(line.text.charAt(target))) { target += dir } }
	  return target < 0 || target > line.text.length ? null : target
	}
	
	// Bidirectional ordering algorithm
	// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
	// that this (partially) implements.
	
	// One-char codes used for character types:
	// L (L):   Left-to-Right
	// R (R):   Right-to-Left
	// r (AL):  Right-to-Left Arabic
	// 1 (EN):  European Number
	// + (ES):  European Number Separator
	// % (ET):  European Number Terminator
	// n (AN):  Arabic Number
	// , (CS):  Common Number Separator
	// m (NSM): Non-Spacing Mark
	// b (BN):  Boundary Neutral
	// s (B):   Paragraph Separator
	// t (S):   Segment Separator
	// w (WS):  Whitespace
	// N (ON):  Other Neutrals
	
	// Returns null if characters are ordered as they appear
	// (left-to-right), or an array of sections ({from, to, level}
	// objects) in the order in which they occur visually.
	var bidiOrdering = (function() {
	  // Character types for codepoints 0 to 0xff
	  var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN"
	  // Character types for codepoints 0x600 to 0x6f9
	  var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111"
	  function charType(code) {
	    if (code <= 0xf7) { return lowTypes.charAt(code) }
	    else if (0x590 <= code && code <= 0x5f4) { return "R" }
	    else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
	    else if (0x6ee <= code && code <= 0x8ac) { return "r" }
	    else if (0x2000 <= code && code <= 0x200b) { return "w" }
	    else if (code == 0x200c) { return "b" }
	    else { return "L" }
	  }
	
	  var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/
	  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/
	  // Browsers seem to always treat the boundaries of block elements as being L.
	  var outerType = "L"
	
	  function BidiSpan(level, from, to) {
	    this.level = level
	    this.from = from; this.to = to
	  }
	
	  return function(str) {
	    if (!bidiRE.test(str)) { return false }
	    var len = str.length, types = []
	    for (var i = 0; i < len; ++i)
	      { types.push(charType(str.charCodeAt(i))) }
	
	    // W1. Examine each non-spacing mark (NSM) in the level run, and
	    // change the type of the NSM to the type of the previous
	    // character. If the NSM is at the start of the level run, it will
	    // get the type of sor.
	    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
	      var type = types[i$1]
	      if (type == "m") { types[i$1] = prev }
	      else { prev = type }
	    }
	
	    // W2. Search backwards from each instance of a European number
	    // until the first strong type (R, L, AL, or sor) is found. If an
	    // AL is found, change the type of the European number to Arabic
	    // number.
	    // W3. Change all ALs to R.
	    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
	      var type$1 = types[i$2]
	      if (type$1 == "1" && cur == "r") { types[i$2] = "n" }
	      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R" } }
	    }
	
	    // W4. A single European separator between two European numbers
	    // changes to a European number. A single common separator between
	    // two numbers of the same type changes to that type.
	    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
	      var type$2 = types[i$3]
	      if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1" }
	      else if (type$2 == "," && prev$1 == types[i$3+1] &&
	               (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1 }
	      prev$1 = type$2
	    }
	
	    // W5. A sequence of European terminators adjacent to European
	    // numbers changes to all European numbers.
	    // W6. Otherwise, separators and terminators change to Other
	    // Neutral.
	    for (var i$4 = 0; i$4 < len; ++i$4) {
	      var type$3 = types[i$4]
	      if (type$3 == ",") { types[i$4] = "N" }
	      else if (type$3 == "%") {
	        var end = (void 0)
	        for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
	        var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N"
	        for (var j = i$4; j < end; ++j) { types[j] = replace }
	        i$4 = end - 1
	      }
	    }
	
	    // W7. Search backwards from each instance of a European number
	    // until the first strong type (R, L, or sor) is found. If an L is
	    // found, then change the type of the European number to L.
	    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
	      var type$4 = types[i$5]
	      if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L" }
	      else if (isStrong.test(type$4)) { cur$1 = type$4 }
	    }
	
	    // N1. A sequence of neutrals takes the direction of the
	    // surrounding strong text if the text on both sides has the same
	    // direction. European and Arabic numbers act as if they were R in
	    // terms of their influence on neutrals. Start-of-level-run (sor)
	    // and end-of-level-run (eor) are used at level run boundaries.
	    // N2. Any remaining neutrals take the embedding direction.
	    for (var i$6 = 0; i$6 < len; ++i$6) {
	      if (isNeutral.test(types[i$6])) {
	        var end$1 = (void 0)
	        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
	        var before = (i$6 ? types[i$6-1] : outerType) == "L"
	        var after = (end$1 < len ? types[end$1] : outerType) == "L"
	        var replace$1 = before || after ? "L" : "R"
	        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1 }
	        i$6 = end$1 - 1
	      }
	    }
	
	    // Here we depart from the documented algorithm, in order to avoid
	    // building up an actual levels array. Since there are only three
	    // levels (0, 1, 2) in an implementation that doesn't take
	    // explicit embedding into account, we can build up the order on
	    // the fly, without following the level-based algorithm.
	    var order = [], m
	    for (var i$7 = 0; i$7 < len;) {
	      if (countsAsLeft.test(types[i$7])) {
	        var start = i$7
	        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
	        order.push(new BidiSpan(0, start, i$7))
	      } else {
	        var pos = i$7, at = order.length
	        for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
	        for (var j$2 = pos; j$2 < i$7;) {
	          if (countsAsNum.test(types[j$2])) {
	            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)) }
	            var nstart = j$2
	            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
	            order.splice(at, 0, new BidiSpan(2, nstart, j$2))
	            pos = j$2
	          } else { ++j$2 }
	        }
	        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)) }
	      }
	    }
	    if (order[0].level == 1 && (m = str.match(/^\s+/))) {
	      order[0].from = m[0].length
	      order.unshift(new BidiSpan(0, 0, m[0].length))
	    }
	    if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
	      lst(order).to -= m[0].length
	      order.push(new BidiSpan(0, len - m[0].length, len))
	    }
	    if (order[0].level == 2)
	      { order.unshift(new BidiSpan(1, order[0].to, order[0].to)) }
	    if (order[0].level != lst(order).level)
	      { order.push(new BidiSpan(order[0].level, len, len)) }
	
	    return order
	  }
	})()
	
	// Get the bidi ordering for the given line (and cache it). Returns
	// false for lines that are fully left-to-right, and an array of
	// BidiSpan objects otherwise.
	function getOrder(line) {
	  var order = line.order
	  if (order == null) { order = line.order = bidiOrdering(line.text) }
	  return order
	}
	
	// EVENT HANDLING
	
	// Lightweight event framework. on/off also work on DOM nodes,
	// registering native DOM handlers.
	
	var noHandlers = []
	
	var on = function(emitter, type, f) {
	  if (emitter.addEventListener) {
	    emitter.addEventListener(type, f, false)
	  } else if (emitter.attachEvent) {
	    emitter.attachEvent("on" + type, f)
	  } else {
	    var map = emitter._handlers || (emitter._handlers = {})
	    map[type] = (map[type] || noHandlers).concat(f)
	  }
	}
	
	function getHandlers(emitter, type) {
	  return emitter._handlers && emitter._handlers[type] || noHandlers
	}
	
	function off(emitter, type, f) {
	  if (emitter.removeEventListener) {
	    emitter.removeEventListener(type, f, false)
	  } else if (emitter.detachEvent) {
	    emitter.detachEvent("on" + type, f)
	  } else {
	    var map = emitter._handlers, arr = map && map[type]
	    if (arr) {
	      var index = indexOf(arr, f)
	      if (index > -1)
	        { map[type] = arr.slice(0, index).concat(arr.slice(index + 1)) }
	    }
	  }
	}
	
	function signal(emitter, type /*, values...*/) {
	  var handlers = getHandlers(emitter, type)
	  if (!handlers.length) { return }
	  var args = Array.prototype.slice.call(arguments, 2)
	  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args) }
	}
	
	// The DOM events that CodeMirror handles can be overridden by
	// registering a (non-DOM) handler on the editor for the event name,
	// and preventDefault-ing the event in that handler.
	function signalDOMEvent(cm, e, override) {
	  if (typeof e == "string")
	    { e = {type: e, preventDefault: function() { this.defaultPrevented = true }} }
	  signal(cm, override || e.type, cm, e)
	  return e_defaultPrevented(e) || e.codemirrorIgnore
	}
	
	function signalCursorActivity(cm) {
	  var arr = cm._handlers && cm._handlers.cursorActivity
	  if (!arr) { return }
	  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = [])
	  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
	    { set.push(arr[i]) } }
	}
	
	function hasHandler(emitter, type) {
	  return getHandlers(emitter, type).length > 0
	}
	
	// Add on and off methods to a constructor's prototype, to make
	// registering events on such objects more convenient.
	function eventMixin(ctor) {
	  ctor.prototype.on = function(type, f) {on(this, type, f)}
	  ctor.prototype.off = function(type, f) {off(this, type, f)}
	}
	
	// Due to the fact that we still support jurassic IE versions, some
	// compatibility wrappers are needed.
	
	function e_preventDefault(e) {
	  if (e.preventDefault) { e.preventDefault() }
	  else { e.returnValue = false }
	}
	function e_stopPropagation(e) {
	  if (e.stopPropagation) { e.stopPropagation() }
	  else { e.cancelBubble = true }
	}
	function e_defaultPrevented(e) {
	  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
	}
	function e_stop(e) {e_preventDefault(e); e_stopPropagation(e)}
	
	function e_target(e) {return e.target || e.srcElement}
	function e_button(e) {
	  var b = e.which
	  if (b == null) {
	    if (e.button & 1) { b = 1 }
	    else if (e.button & 2) { b = 3 }
	    else if (e.button & 4) { b = 2 }
	  }
	  if (mac && e.ctrlKey && b == 1) { b = 3 }
	  return b
	}
	
	// Detect drag-and-drop
	var dragAndDrop = function() {
	  // There is *some* kind of drag-and-drop support in IE6-8, but I
	  // couldn't get it to work yet.
	  if (ie && ie_version < 9) { return false }
	  var div = elt('div')
	  return "draggable" in div || "dragDrop" in div
	}()
	
	var zwspSupported
	function zeroWidthElement(measure) {
	  if (zwspSupported == null) {
	    var test = elt("span", "\u200b")
	    removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]))
	    if (measure.firstChild.offsetHeight != 0)
	      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8) }
	  }
	  var node = zwspSupported ? elt("span", "\u200b") :
	    elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px")
	  node.setAttribute("cm-text", "")
	  return node
	}
	
	// Feature-detect IE's crummy client rect reporting for bidi text
	var badBidiRects
	function hasBadBidiRects(measure) {
	  if (badBidiRects != null) { return badBidiRects }
	  var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"))
	  var r0 = range(txt, 0, 1).getBoundingClientRect()
	  var r1 = range(txt, 1, 2).getBoundingClientRect()
	  removeChildren(measure)
	  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
	  return badBidiRects = (r1.right - r0.right < 3)
	}
	
	// See if "".split is the broken IE version, if so, provide an
	// alternative way to split lines.
	var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
	  var pos = 0, result = [], l = string.length
	  while (pos <= l) {
	    var nl = string.indexOf("\n", pos)
	    if (nl == -1) { nl = string.length }
	    var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl)
	    var rt = line.indexOf("\r")
	    if (rt != -1) {
	      result.push(line.slice(0, rt))
	      pos += rt + 1
	    } else {
	      result.push(line)
	      pos = nl + 1
	    }
	  }
	  return result
	} : function (string) { return string.split(/\r\n?|\n/); }
	
	var hasSelection = window.getSelection ? function (te) {
	  try { return te.selectionStart != te.selectionEnd }
	  catch(e) { return false }
	} : function (te) {
	  var range
	  try {range = te.ownerDocument.selection.createRange()}
	  catch(e) {}
	  if (!range || range.parentElement() != te) { return false }
	  return range.compareEndPoints("StartToEnd", range) != 0
	}
	
	var hasCopyEvent = (function () {
	  var e = elt("div")
	  if ("oncopy" in e) { return true }
	  e.setAttribute("oncopy", "return;")
	  return typeof e.oncopy == "function"
	})()
	
	var badZoomedRects = null
	function hasBadZoomedRects(measure) {
	  if (badZoomedRects != null) { return badZoomedRects }
	  var node = removeChildrenAndAdd(measure, elt("span", "x"))
	  var normal = node.getBoundingClientRect()
	  var fromRange = range(node, 0, 1).getBoundingClientRect()
	  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
	}
	
	var modes = {};
	var mimeModes = {};
	// Extra arguments are stored as the mode's dependencies, which is
	// used by (legacy) mechanisms like loadmode.js to automatically
	// load a mode. (Preferred mechanism is the require/define calls.)
	function defineMode(name, mode) {
	  if (arguments.length > 2)
	    { mode.dependencies = Array.prototype.slice.call(arguments, 2) }
	  modes[name] = mode
	}
	
	function defineMIME(mime, spec) {
	  mimeModes[mime] = spec
	}
	
	// Given a MIME type, a {name, ...options} config object, or a name
	// string, return a mode config object.
	function resolveMode(spec) {
	  if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
	    spec = mimeModes[spec]
	  } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
	    var found = mimeModes[spec.name]
	    if (typeof found == "string") { found = {name: found} }
	    spec = createObj(found, spec)
	    spec.name = found.name
	  } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
	    return resolveMode("application/xml")
	  } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
	    return resolveMode("application/json")
	  }
	  if (typeof spec == "string") { return {name: spec} }
	  else { return spec || {name: "null"} }
	}
	
	// Given a mode spec (anything that resolveMode accepts), find and
	// initialize an actual mode object.
	function getMode(options, spec) {
	  spec = resolveMode(spec)
	  var mfactory = modes[spec.name]
	  if (!mfactory) { return getMode(options, "text/plain") }
	  var modeObj = mfactory(options, spec)
	  if (modeExtensions.hasOwnProperty(spec.name)) {
	    var exts = modeExtensions[spec.name]
	    for (var prop in exts) {
	      if (!exts.hasOwnProperty(prop)) { continue }
	      if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop] }
	      modeObj[prop] = exts[prop]
	    }
	  }
	  modeObj.name = spec.name
	  if (spec.helperType) { modeObj.helperType = spec.helperType }
	  if (spec.modeProps) { for (var prop$1 in spec.modeProps)
	    { modeObj[prop$1] = spec.modeProps[prop$1] } }
	
	  return modeObj
	}
	
	// This can be used to attach properties to mode objects from
	// outside the actual mode definition.
	var modeExtensions = {}
	function extendMode(mode, properties) {
	  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {})
	  copyObj(properties, exts)
	}
	
	function copyState(mode, state) {
	  if (state === true) { return state }
	  if (mode.copyState) { return mode.copyState(state) }
	  var nstate = {}
	  for (var n in state) {
	    var val = state[n]
	    if (val instanceof Array) { val = val.concat([]) }
	    nstate[n] = val
	  }
	  return nstate
	}
	
	// Given a mode and a state (for that mode), find the inner mode and
	// state at the position that the state refers to.
	function innerMode(mode, state) {
	  var info
	  while (mode.innerMode) {
	    info = mode.innerMode(state)
	    if (!info || info.mode == mode) { break }
	    state = info.state
	    mode = info.mode
	  }
	  return info || {mode: mode, state: state}
	}
	
	function startState(mode, a1, a2) {
	  return mode.startState ? mode.startState(a1, a2) : true
	}
	
	// STRING STREAM
	
	// Fed to the mode parsers, provides helper functions to make
	// parsers more succinct.
	
	var StringStream = function(string, tabSize) {
	  this.pos = this.start = 0
	  this.string = string
	  this.tabSize = tabSize || 8
	  this.lastColumnPos = this.lastColumnValue = 0
	  this.lineStart = 0
	}
	
	StringStream.prototype = {
	  eol: function() {return this.pos >= this.string.length},
	  sol: function() {return this.pos == this.lineStart},
	  peek: function() {return this.string.charAt(this.pos) || undefined},
	  next: function() {
	    if (this.pos < this.string.length)
	      { return this.string.charAt(this.pos++) }
	  },
	  eat: function(match) {
	    var ch = this.string.charAt(this.pos)
	    var ok
	    if (typeof match == "string") { ok = ch == match }
	    else { ok = ch && (match.test ? match.test(ch) : match(ch)) }
	    if (ok) {++this.pos; return ch}
	  },
	  eatWhile: function(match) {
	    var start = this.pos
	    while (this.eat(match)){}
	    return this.pos > start
	  },
	  eatSpace: function() {
	    var this$1 = this;
	
	    var start = this.pos
	    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos }
	    return this.pos > start
	  },
	  skipToEnd: function() {this.pos = this.string.length},
	  skipTo: function(ch) {
	    var found = this.string.indexOf(ch, this.pos)
	    if (found > -1) {this.pos = found; return true}
	  },
	  backUp: function(n) {this.pos -= n},
	  column: function() {
	    if (this.lastColumnPos < this.start) {
	      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue)
	      this.lastColumnPos = this.start
	    }
	    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
	  },
	  indentation: function() {
	    return countColumn(this.string, null, this.tabSize) -
	      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
	  },
	  match: function(pattern, consume, caseInsensitive) {
	    if (typeof pattern == "string") {
	      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; }
	      var substr = this.string.substr(this.pos, pattern.length)
	      if (cased(substr) == cased(pattern)) {
	        if (consume !== false) { this.pos += pattern.length }
	        return true
	      }
	    } else {
	      var match = this.string.slice(this.pos).match(pattern)
	      if (match && match.index > 0) { return null }
	      if (match && consume !== false) { this.pos += match[0].length }
	      return match
	    }
	  },
	  current: function(){return this.string.slice(this.start, this.pos)},
	  hideFirstChars: function(n, inner) {
	    this.lineStart += n
	    try { return inner() }
	    finally { this.lineStart -= n }
	  }
	}
	
	// Compute a style array (an array starting with a mode generation
	// -- for invalidation -- followed by pairs of end positions and
	// style strings), which is used to highlight the tokens on the
	// line.
	function highlightLine(cm, line, state, forceToEnd) {
	  // A styles array always starts with a number identifying the
	  // mode/overlays that it is based on (for easy invalidation).
	  var st = [cm.state.modeGen], lineClasses = {}
	  // Compute the base array of styles
	  runMode(cm, line.text, cm.doc.mode, state, function (end, style) { return st.push(end, style); },
	    lineClasses, forceToEnd)
	
	  // Run overlays, adjust style array.
	  var loop = function ( o ) {
	    var overlay = cm.state.overlays[o], i = 1, at = 0
	    runMode(cm, line.text, overlay.mode, true, function (end, style) {
	      var start = i
	      // Ensure there's a token end at the current position, and that i points at it
	      while (at < end) {
	        var i_end = st[i]
	        if (i_end > end)
	          { st.splice(i, 1, end, st[i+1], i_end) }
	        i += 2
	        at = Math.min(end, i_end)
	      }
	      if (!style) { return }
	      if (overlay.opaque) {
	        st.splice(start, i - start, end, "overlay " + style)
	        i = start + 2
	      } else {
	        for (; start < i; start += 2) {
	          var cur = st[start+1]
	          st[start+1] = (cur ? cur + " " : "") + "overlay " + style
	        }
	      }
	    }, lineClasses)
	  };
	
	  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );
	
	  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
	}
	
	function getLineStyles(cm, line, updateFrontier) {
	  if (!line.styles || line.styles[0] != cm.state.modeGen) {
	    var state = getStateBefore(cm, lineNo(line))
	    var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state)
	    line.stateAfter = state
	    line.styles = result.styles
	    if (result.classes) { line.styleClasses = result.classes }
	    else if (line.styleClasses) { line.styleClasses = null }
	    if (updateFrontier === cm.doc.frontier) { cm.doc.frontier++ }
	  }
	  return line.styles
	}
	
	function getStateBefore(cm, n, precise) {
	  var doc = cm.doc, display = cm.display
	  if (!doc.mode.startState) { return true }
	  var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter
	  if (!state) { state = startState(doc.mode) }
	  else { state = copyState(doc.mode, state) }
	  doc.iter(pos, n, function (line) {
	    processLine(cm, line.text, state)
	    var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo
	    line.stateAfter = save ? copyState(doc.mode, state) : null
	    ++pos
	  })
	  if (precise) { doc.frontier = pos }
	  return state
	}
	
	// Lightweight form of highlight -- proceed over this line and
	// update state, but don't save a style array. Used for lines that
	// aren't currently visible.
	function processLine(cm, text, state, startAt) {
	  var mode = cm.doc.mode
	  var stream = new StringStream(text, cm.options.tabSize)
	  stream.start = stream.pos = startAt || 0
	  if (text == "") { callBlankLine(mode, state) }
	  while (!stream.eol()) {
	    readToken(mode, stream, state)
	    stream.start = stream.pos
	  }
	}
	
	function callBlankLine(mode, state) {
	  if (mode.blankLine) { return mode.blankLine(state) }
	  if (!mode.innerMode) { return }
	  var inner = innerMode(mode, state)
	  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
	}
	
	function readToken(mode, stream, state, inner) {
	  for (var i = 0; i < 10; i++) {
	    if (inner) { inner[0] = innerMode(mode, state).mode }
	    var style = mode.token(stream, state)
	    if (stream.pos > stream.start) { return style }
	  }
	  throw new Error("Mode " + mode.name + " failed to advance stream.")
	}
	
	// Utility for getTokenAt and getLineTokens
	function takeToken(cm, pos, precise, asArray) {
	  var getObj = function (copy) { return ({
	    start: stream.start, end: stream.pos,
	    string: stream.current(),
	    type: style || null,
	    state: copy ? copyState(doc.mode, state) : state
	  }); }
	
	  var doc = cm.doc, mode = doc.mode, style
	  pos = clipPos(doc, pos)
	  var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise)
	  var stream = new StringStream(line.text, cm.options.tabSize), tokens
	  if (asArray) { tokens = [] }
	  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
	    stream.start = stream.pos
	    style = readToken(mode, stream, state)
	    if (asArray) { tokens.push(getObj(true)) }
	  }
	  return asArray ? tokens : getObj()
	}
	
	function extractLineClasses(type, output) {
	  if (type) { for (;;) {
	    var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/)
	    if (!lineClass) { break }
	    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length)
	    var prop = lineClass[1] ? "bgClass" : "textClass"
	    if (output[prop] == null)
	      { output[prop] = lineClass[2] }
	    else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
	      { output[prop] += " " + lineClass[2] }
	  } }
	  return type
	}
	
	// Run the given mode's parser over a line, calling f for each token.
	function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
	  var flattenSpans = mode.flattenSpans
	  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans }
	  var curStart = 0, curStyle = null
	  var stream = new StringStream(text, cm.options.tabSize), style
	  var inner = cm.options.addModeClass && [null]
	  if (text == "") { extractLineClasses(callBlankLine(mode, state), lineClasses) }
	  while (!stream.eol()) {
	    if (stream.pos > cm.options.maxHighlightLength) {
	      flattenSpans = false
	      if (forceToEnd) { processLine(cm, text, state, stream.pos) }
	      stream.pos = text.length
	      style = null
	    } else {
	      style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses)
	    }
	    if (inner) {
	      var mName = inner[0].name
	      if (mName) { style = "m-" + (style ? mName + " " + style : mName) }
	    }
	    if (!flattenSpans || curStyle != style) {
	      while (curStart < stream.start) {
	        curStart = Math.min(stream.start, curStart + 5000)
	        f(curStart, curStyle)
	      }
	      curStyle = style
	    }
	    stream.start = stream.pos
	  }
	  while (curStart < stream.pos) {
	    // Webkit seems to refuse to render text nodes longer than 57444
	    // characters, and returns inaccurate measurements in nodes
	    // starting around 5000 chars.
	    var pos = Math.min(stream.pos, curStart + 5000)
	    f(pos, curStyle)
	    curStart = pos
	  }
	}
	
	// Finds the line to start with when starting a parse. Tries to
	// find a line with a stateAfter, so that it can start with a
	// valid state. If that fails, it returns the line with the
	// smallest indentation, which tends to need the least context to
	// parse correctly.
	function findStartLine(cm, n, precise) {
	  var minindent, minline, doc = cm.doc
	  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100)
	  for (var search = n; search > lim; --search) {
	    if (search <= doc.first) { return doc.first }
	    var line = getLine(doc, search - 1)
	    if (line.stateAfter && (!precise || search <= doc.frontier)) { return search }
	    var indented = countColumn(line.text, null, cm.options.tabSize)
	    if (minline == null || minindent > indented) {
	      minline = search - 1
	      minindent = indented
	    }
	  }
	  return minline
	}
	
	// LINE DATA STRUCTURE
	
	// Line objects. These hold state related to a line, including
	// highlighting info (the styles array).
	function Line(text, markedSpans, estimateHeight) {
	  this.text = text
	  attachMarkedSpans(this, markedSpans)
	  this.height = estimateHeight ? estimateHeight(this) : 1
	}
	eventMixin(Line)
	Line.prototype.lineNo = function() { return lineNo(this) }
	
	// Change the content (text, markers) of a line. Automatically
	// invalidates cached information and tries to re-estimate the
	// line's height.
	function updateLine(line, text, markedSpans, estimateHeight) {
	  line.text = text
	  if (line.stateAfter) { line.stateAfter = null }
	  if (line.styles) { line.styles = null }
	  if (line.order != null) { line.order = null }
	  detachMarkedSpans(line)
	  attachMarkedSpans(line, markedSpans)
	  var estHeight = estimateHeight ? estimateHeight(line) : 1
	  if (estHeight != line.height) { updateLineHeight(line, estHeight) }
	}
	
	// Detach a line from the document tree and its markers.
	function cleanUpLine(line) {
	  line.parent = null
	  detachMarkedSpans(line)
	}
	
	// Convert a style as returned by a mode (either null, or a string
	// containing one or more styles) to a CSS style. This is cached,
	// and also looks for line-wide styles.
	var styleToClassCache = {};
	var styleToClassCacheWithMode = {};
	function interpretTokenStyle(style, options) {
	  if (!style || /^\s*$/.test(style)) { return null }
	  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache
	  return cache[style] ||
	    (cache[style] = style.replace(/\S+/g, "cm-$&"))
	}
	
	// Render the DOM representation of the text of a line. Also builds
	// up a 'line map', which points at the DOM nodes that represent
	// specific stretches of text, and is used by the measuring code.
	// The returned object contains the DOM node, this map, and
	// information about line-wide styles that were set by the mode.
	function buildLineContent(cm, lineView) {
	  // The padding-right forces the element to have a 'border', which
	  // is needed on Webkit to be able to get line-level bounding
	  // rectangles for it (in measureChar).
	  var content = elt("span", null, null, webkit ? "padding-right: .1px" : null)
	  var builder = {pre: elt("pre", [content], "CodeMirror-line"), content: content,
	                 col: 0, pos: 0, cm: cm,
	                 trailingSpace: false,
	                 splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")}
	  lineView.measure = {}
	
	  // Iterate over the logical lines that make up this visual line.
	  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
	    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0)
	    builder.pos = 0
	    builder.addToken = buildToken
	    // Optionally wire in some hacks into the token-rendering
	    // algorithm, to deal with browser quirks.
	    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
	      { builder.addToken = buildTokenBadBidi(builder.addToken, order) }
	    builder.map = []
	    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line)
	    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate))
	    if (line.styleClasses) {
	      if (line.styleClasses.bgClass)
	        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "") }
	      if (line.styleClasses.textClass)
	        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "") }
	    }
	
	    // Ensure at least a single node is present, for measuring.
	    if (builder.map.length == 0)
	      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))) }
	
	    // Store the map and a cache object for the current logical line
	    if (i == 0) {
	      lineView.measure.map = builder.map
	      lineView.measure.cache = {}
	    } else {
	      ;(lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
	      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({})
	    }
	  }
	
	  // See issue #2901
	  if (webkit) {
	    var last = builder.content.lastChild
	    if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
	      { builder.content.className = "cm-tab-wrap-hack" }
	  }
	
	  signal(cm, "renderLine", cm, lineView.line, builder.pre)
	  if (builder.pre.className)
	    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || "") }
	
	  return builder
	}
	
	function defaultSpecialCharPlaceholder(ch) {
	  var token = elt("span", "\u2022", "cm-invalidchar")
	  token.title = "\\u" + ch.charCodeAt(0).toString(16)
	  token.setAttribute("aria-label", token.title)
	  return token
	}
	
	// Build up the DOM representation for a single token, and add it to
	// the line map. Takes care to render special characters separately.
	function buildToken(builder, text, style, startStyle, endStyle, title, css) {
	  if (!text) { return }
	  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text
	  var special = builder.cm.state.specialChars, mustWrap = false
	  var content
	  if (!special.test(text)) {
	    builder.col += text.length
	    content = document.createTextNode(displayText)
	    builder.map.push(builder.pos, builder.pos + text.length, content)
	    if (ie && ie_version < 9) { mustWrap = true }
	    builder.pos += text.length
	  } else {
	    content = document.createDocumentFragment()
	    var pos = 0
	    while (true) {
	      special.lastIndex = pos
	      var m = special.exec(text)
	      var skipped = m ? m.index - pos : text.length - pos
	      if (skipped) {
	        var txt = document.createTextNode(displayText.slice(pos, pos + skipped))
	        if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])) }
	        else { content.appendChild(txt) }
	        builder.map.push(builder.pos, builder.pos + skipped, txt)
	        builder.col += skipped
	        builder.pos += skipped
	      }
	      if (!m) { break }
	      pos += skipped + 1
	      var txt$1 = (void 0)
	      if (m[0] == "\t") {
	        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize
	        txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"))
	        txt$1.setAttribute("role", "presentation")
	        txt$1.setAttribute("cm-text", "\t")
	        builder.col += tabWidth
	      } else if (m[0] == "\r" || m[0] == "\n") {
	        txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"))
	        txt$1.setAttribute("cm-text", m[0])
	        builder.col += 1
	      } else {
	        txt$1 = builder.cm.options.specialCharPlaceholder(m[0])
	        txt$1.setAttribute("cm-text", m[0])
	        if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])) }
	        else { content.appendChild(txt$1) }
	        builder.col += 1
	      }
	      builder.map.push(builder.pos, builder.pos + 1, txt$1)
	      builder.pos++
	    }
	  }
	  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32
	  if (style || startStyle || endStyle || mustWrap || css) {
	    var fullStyle = style || ""
	    if (startStyle) { fullStyle += startStyle }
	    if (endStyle) { fullStyle += endStyle }
	    var token = elt("span", [content], fullStyle, css)
	    if (title) { token.title = title }
	    return builder.content.appendChild(token)
	  }
	  builder.content.appendChild(content)
	}
	
	function splitSpaces(text, trailingBefore) {
	  if (text.length > 1 && !/  /.test(text)) { return text }
	  var spaceBefore = trailingBefore, result = ""
	  for (var i = 0; i < text.length; i++) {
	    var ch = text.charAt(i)
	    if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
	      { ch = "\u00a0" }
	    result += ch
	    spaceBefore = ch == " "
	  }
	  return result
	}
	
	// Work around nonsense dimensions being reported for stretches of
	// right-to-left text.
	function buildTokenBadBidi(inner, order) {
	  return function (builder, text, style, startStyle, endStyle, title, css) {
	    style = style ? style + " cm-force-border" : "cm-force-border"
	    var start = builder.pos, end = start + text.length
	    for (;;) {
	      // Find the part that overlaps with the start of this text
	      var part = (void 0)
	      for (var i = 0; i < order.length; i++) {
	        part = order[i]
	        if (part.to > start && part.from <= start) { break }
	      }
	      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }
	      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css)
	      startStyle = null
	      text = text.slice(part.to - start)
	      start = part.to
	    }
	  }
	}
	
	function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
	  var widget = !ignoreWidget && marker.widgetNode
	  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget) }
	  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
	    if (!widget)
	      { widget = builder.content.appendChild(document.createElement("span")) }
	    widget.setAttribute("cm-marker", marker.id)
	  }
	  if (widget) {
	    builder.cm.display.input.setUneditable(widget)
	    builder.content.appendChild(widget)
	  }
	  builder.pos += size
	  builder.trailingSpace = false
	}
	
	// Outputs a number of spans to make up a line, taking highlighting
	// and marked text into account.
	function insertLineContent(line, builder, styles) {
	  var spans = line.markedSpans, allText = line.text, at = 0
	  if (!spans) {
	    for (var i$1 = 1; i$1 < styles.length; i$1+=2)
	      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)) }
	    return
	  }
	
	  var len = allText.length, pos = 0, i = 1, text = "", style, css
	  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed
	  for (;;) {
	    if (nextChange == pos) { // Update current marker set
	      spanStyle = spanEndStyle = spanStartStyle = title = css = ""
	      collapsed = null; nextChange = Infinity
	      var foundBookmarks = [], endStyles = (void 0)
	      for (var j = 0; j < spans.length; ++j) {
	        var sp = spans[j], m = sp.marker
	        if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
	          foundBookmarks.push(m)
	        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
	          if (sp.to != null && sp.to != pos && nextChange > sp.to) {
	            nextChange = sp.to
	            spanEndStyle = ""
	          }
	          if (m.className) { spanStyle += " " + m.className }
	          if (m.css) { css = (css ? css + ";" : "") + m.css }
	          if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle }
	          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to) }
	          if (m.title && !title) { title = m.title }
	          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
	            { collapsed = sp }
	        } else if (sp.from > pos && nextChange > sp.from) {
	          nextChange = sp.from
	        }
	      }
	      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
	        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1] } } }
	
	      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
	        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]) } }
	      if (collapsed && (collapsed.from || 0) == pos) {
	        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
	                           collapsed.marker, collapsed.from == null)
	        if (collapsed.to == null) { return }
	        if (collapsed.to == pos) { collapsed = false }
	      }
	    }
	    if (pos >= len) { break }
	
	    var upto = Math.min(len, nextChange)
	    while (true) {
	      if (text) {
	        var end = pos + text.length
	        if (!collapsed) {
	          var tokenText = end > upto ? text.slice(0, upto - pos) : text
	          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
	                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css)
	        }
	        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
	        pos = end
	        spanStartStyle = ""
	      }
	      text = allText.slice(at, at = styles[i++])
	      style = interpretTokenStyle(styles[i++], builder.cm.options)
	    }
	  }
	}
	
	
	// These objects are used to represent the visible (currently drawn)
	// part of the document. A LineView may correspond to multiple
	// logical lines, if those are connected by collapsed ranges.
	function LineView(doc, line, lineN) {
	  // The starting line
	  this.line = line
	  // Continuing lines, if any
	  this.rest = visualLineContinued(line)
	  // Number of logical lines in this visual line
	  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1
	  this.node = this.text = null
	  this.hidden = lineIsHidden(doc, line)
	}
	
	// Create a range of LineView objects for the given lines.
	function buildViewArray(cm, from, to) {
	  var array = [], nextPos
	  for (var pos = from; pos < to; pos = nextPos) {
	    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos)
	    nextPos = pos + view.size
	    array.push(view)
	  }
	  return array
	}
	
	var operationGroup = null
	
	function pushOperation(op) {
	  if (operationGroup) {
	    operationGroup.ops.push(op)
	  } else {
	    op.ownsGroup = operationGroup = {
	      ops: [op],
	      delayedCallbacks: []
	    }
	  }
	}
	
	function fireCallbacksForOps(group) {
	  // Calls delayed callbacks and cursorActivity handlers until no
	  // new ones appear
	  var callbacks = group.delayedCallbacks, i = 0
	  do {
	    for (; i < callbacks.length; i++)
	      { callbacks[i].call(null) }
	    for (var j = 0; j < group.ops.length; j++) {
	      var op = group.ops[j]
	      if (op.cursorActivityHandlers)
	        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
	          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm) } }
	    }
	  } while (i < callbacks.length)
	}
	
	function finishOperation(op, endCb) {
	  var group = op.ownsGroup
	  if (!group) { return }
	
	  try { fireCallbacksForOps(group) }
	  finally {
	    operationGroup = null
	    endCb(group)
	  }
	}
	
	var orphanDelayedCallbacks = null
	
	// Often, we want to signal events at a point where we are in the
	// middle of some work, but don't want the handler to start calling
	// other methods on the editor, which might be in an inconsistent
	// state or simply not expect any other events to happen.
	// signalLater looks whether there are any handlers, and schedules
	// them to be executed when the last operation ends, or, if no
	// operation is active, when a timeout fires.
	function signalLater(emitter, type /*, values...*/) {
	  var arr = getHandlers(emitter, type)
	  if (!arr.length) { return }
	  var args = Array.prototype.slice.call(arguments, 2), list
	  if (operationGroup) {
	    list = operationGroup.delayedCallbacks
	  } else if (orphanDelayedCallbacks) {
	    list = orphanDelayedCallbacks
	  } else {
	    list = orphanDelayedCallbacks = []
	    setTimeout(fireOrphanDelayed, 0)
	  }
	  var loop = function ( i ) {
	    list.push(function () { return arr[i].apply(null, args); })
	  };
	
	  for (var i = 0; i < arr.length; ++i)
	    loop( i );
	}
	
	function fireOrphanDelayed() {
	  var delayed = orphanDelayedCallbacks
	  orphanDelayedCallbacks = null
	  for (var i = 0; i < delayed.length; ++i) { delayed[i]() }
	}
	
	// When an aspect of a line changes, a string is added to
	// lineView.changes. This updates the relevant part of the line's
	// DOM structure.
	function updateLineForChanges(cm, lineView, lineN, dims) {
	  for (var j = 0; j < lineView.changes.length; j++) {
	    var type = lineView.changes[j]
	    if (type == "text") { updateLineText(cm, lineView) }
	    else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims) }
	    else if (type == "class") { updateLineClasses(lineView) }
	    else if (type == "widget") { updateLineWidgets(cm, lineView, dims) }
	  }
	  lineView.changes = null
	}
	
	// Lines with gutter elements, widgets or a background class need to
	// be wrapped, and have the extra elements added to the wrapper div
	function ensureLineWrapped(lineView) {
	  if (lineView.node == lineView.text) {
	    lineView.node = elt("div", null, null, "position: relative")
	    if (lineView.text.parentNode)
	      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text) }
	    lineView.node.appendChild(lineView.text)
	    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2 }
	  }
	  return lineView.node
	}
	
	function updateLineBackground(lineView) {
	  var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass
	  if (cls) { cls += " CodeMirror-linebackground" }
	  if (lineView.background) {
	    if (cls) { lineView.background.className = cls }
	    else { lineView.background.remove(); lineView.background = null }
	  } else if (cls) {
	    var wrap = ensureLineWrapped(lineView)
	    lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild)
	  }
	}
	
	// Wrapper around buildLineContent which will reuse the structure
	// in display.externalMeasured when possible.
	function getLineContent(cm, lineView) {
	  var ext = cm.display.externalMeasured
	  if (ext && ext.line == lineView.line) {
	    cm.display.externalMeasured = null
	    lineView.measure = ext.measure
	    return ext.built
	  }
	  return buildLineContent(cm, lineView)
	}
	
	// Redraw the line's text. Interacts with the background and text
	// classes because the mode may output tokens that influence these
	// classes.
	function updateLineText(cm, lineView) {
	  var cls = lineView.text.className
	  var built = getLineContent(cm, lineView)
	  if (lineView.text == lineView.node) { lineView.node = built.pre }
	  lineView.text.parentNode.replaceChild(built.pre, lineView.text)
	  lineView.text = built.pre
	  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
	    lineView.bgClass = built.bgClass
	    lineView.textClass = built.textClass
	    updateLineClasses(lineView)
	  } else if (cls) {
	    lineView.text.className = cls
	  }
	}
	
	function updateLineClasses(lineView) {
	  updateLineBackground(lineView)
	  if (lineView.line.wrapClass)
	    { ensureLineWrapped(lineView).className = lineView.line.wrapClass }
	  else if (lineView.node != lineView.text)
	    { lineView.node.className = "" }
	  var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass
	  lineView.text.className = textClass || ""
	}
	
	function updateLineGutter(cm, lineView, lineN, dims) {
	  if (lineView.gutter) {
	    lineView.node.removeChild(lineView.gutter)
	    lineView.gutter = null
	  }
	  if (lineView.gutterBackground) {
	    lineView.node.removeChild(lineView.gutterBackground)
	    lineView.gutterBackground = null
	  }
	  if (lineView.line.gutterClass) {
	    var wrap = ensureLineWrapped(lineView)
	    lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
	                                    ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"))
	    wrap.insertBefore(lineView.gutterBackground, lineView.text)
	  }
	  var markers = lineView.line.gutterMarkers
	  if (cm.options.lineNumbers || markers) {
	    var wrap$1 = ensureLineWrapped(lineView)
	    var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"))
	    cm.display.input.setUneditable(gutterWrap)
	    wrap$1.insertBefore(gutterWrap, lineView.text)
	    if (lineView.line.gutterClass)
	      { gutterWrap.className += " " + lineView.line.gutterClass }
	    if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
	      { lineView.lineNumber = gutterWrap.appendChild(
	        elt("div", lineNumberFor(cm.options, lineN),
	            "CodeMirror-linenumber CodeMirror-gutter-elt",
	            ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))) }
	    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {
	      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id]
	      if (found)
	        { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
	                                   ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))) }
	    } }
	  }
	}
	
	function updateLineWidgets(cm, lineView, dims) {
	  if (lineView.alignable) { lineView.alignable = null }
	  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
	    next = node.nextSibling
	    if (node.className == "CodeMirror-linewidget")
	      { lineView.node.removeChild(node) }
	  }
	  insertLineWidgets(cm, lineView, dims)
	}
	
	// Build a line's DOM representation from scratch
	function buildLineElement(cm, lineView, lineN, dims) {
	  var built = getLineContent(cm, lineView)
	  lineView.text = lineView.node = built.pre
	  if (built.bgClass) { lineView.bgClass = built.bgClass }
	  if (built.textClass) { lineView.textClass = built.textClass }
	
	  updateLineClasses(lineView)
	  updateLineGutter(cm, lineView, lineN, dims)
	  insertLineWidgets(cm, lineView, dims)
	  return lineView.node
	}
	
	// A lineView may contain multiple logical lines (when merged by
	// collapsed spans). The widgets for all of them need to be drawn.
	function insertLineWidgets(cm, lineView, dims) {
	  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true)
	  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
	    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false) } }
	}
	
	function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
	  if (!line.widgets) { return }
	  var wrap = ensureLineWrapped(lineView)
	  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
	    var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget")
	    if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true") }
	    positionLineWidget(widget, node, lineView, dims)
	    cm.display.input.setUneditable(node)
	    if (allowAbove && widget.above)
	      { wrap.insertBefore(node, lineView.gutter || lineView.text) }
	    else
	      { wrap.appendChild(node) }
	    signalLater(widget, "redraw")
	  }
	}
	
	function positionLineWidget(widget, node, lineView, dims) {
	  if (widget.noHScroll) {
	    ;(lineView.alignable || (lineView.alignable = [])).push(node)
	    var width = dims.wrapperWidth
	    node.style.left = dims.fixedPos + "px"
	    if (!widget.coverGutter) {
	      width -= dims.gutterTotalWidth
	      node.style.paddingLeft = dims.gutterTotalWidth + "px"
	    }
	    node.style.width = width + "px"
	  }
	  if (widget.coverGutter) {
	    node.style.zIndex = 5
	    node.style.position = "relative"
	    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px" }
	  }
	}
	
	function widgetHeight(widget) {
	  if (widget.height != null) { return widget.height }
	  var cm = widget.doc.cm
	  if (!cm) { return 0 }
	  if (!contains(document.body, widget.node)) {
	    var parentStyle = "position: relative;"
	    if (widget.coverGutter)
	      { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;" }
	    if (widget.noHScroll)
	      { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;" }
	    removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle))
	  }
	  return widget.height = widget.node.parentNode.offsetHeight
	}
	
	// Return true when the given mouse event happened in a widget
	function eventInWidget(display, e) {
	  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
	    if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
	        (n.parentNode == display.sizer && n != display.mover))
	      { return true }
	  }
	}
	
	// POSITION MEASUREMENT
	
	function paddingTop(display) {return display.lineSpace.offsetTop}
	function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
	function paddingH(display) {
	  if (display.cachedPaddingH) { return display.cachedPaddingH }
	  var e = removeChildrenAndAdd(display.measure, elt("pre", "x"))
	  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle
	  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)}
	  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data }
	  return data
	}
	
	function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
	function displayWidth(cm) {
	  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
	}
	function displayHeight(cm) {
	  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
	}
	
	// Ensure the lineView.wrapping.heights array is populated. This is
	// an array of bottom offsets for the lines that make up a drawn
	// line. When lineWrapping is on, there might be more than one
	// height.
	function ensureLineHeights(cm, lineView, rect) {
	  var wrapping = cm.options.lineWrapping
	  var curWidth = wrapping && displayWidth(cm)
	  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
	    var heights = lineView.measure.heights = []
	    if (wrapping) {
	      lineView.measure.width = curWidth
	      var rects = lineView.text.firstChild.getClientRects()
	      for (var i = 0; i < rects.length - 1; i++) {
	        var cur = rects[i], next = rects[i + 1]
	        if (Math.abs(cur.bottom - next.bottom) > 2)
	          { heights.push((cur.bottom + next.top) / 2 - rect.top) }
	      }
	    }
	    heights.push(rect.bottom - rect.top)
	  }
	}
	
	// Find a line map (mapping character offsets to text nodes) and a
	// measurement cache for the given line number. (A line view might
	// contain multiple lines when collapsed ranges are present.)
	function mapFromLineView(lineView, line, lineN) {
	  if (lineView.line == line)
	    { return {map: lineView.measure.map, cache: lineView.measure.cache} }
	  for (var i = 0; i < lineView.rest.length; i++)
	    { if (lineView.rest[i] == line)
	      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
	  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
	    { if (lineNo(lineView.rest[i$1]) > lineN)
	      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
	}
	
	// Render a line into the hidden node display.externalMeasured. Used
	// when measurement is needed for a line that's not in the viewport.
	function updateExternalMeasurement(cm, line) {
	  line = visualLine(line)
	  var lineN = lineNo(line)
	  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN)
	  view.lineN = lineN
	  var built = view.built = buildLineContent(cm, view)
	  view.text = built.pre
	  removeChildrenAndAdd(cm.display.lineMeasure, built.pre)
	  return view
	}
	
	// Get a {top, bottom, left, right} box (in line-local coordinates)
	// for a given character.
	function measureChar(cm, line, ch, bias) {
	  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
	}
	
	// Find a line view that corresponds to the given line number.
	function findViewForLine(cm, lineN) {
	  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
	    { return cm.display.view[findViewIndex(cm, lineN)] }
	  var ext = cm.display.externalMeasured
	  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
	    { return ext }
	}
	
	// Measurement can be split in two steps, the set-up work that
	// applies to the whole line, and the measurement of the actual
	// character. Functions like coordsChar, that need to do a lot of
	// measurements in a row, can thus ensure that the set-up work is
	// only done once.
	function prepareMeasureForLine(cm, line) {
	  var lineN = lineNo(line)
	  var view = findViewForLine(cm, lineN)
	  if (view && !view.text) {
	    view = null
	  } else if (view && view.changes) {
	    updateLineForChanges(cm, view, lineN, getDimensions(cm))
	    cm.curOp.forceUpdate = true
	  }
	  if (!view)
	    { view = updateExternalMeasurement(cm, line) }
	
	  var info = mapFromLineView(view, line, lineN)
	  return {
	    line: line, view: view, rect: null,
	    map: info.map, cache: info.cache, before: info.before,
	    hasHeights: false
	  }
	}
	
	// Given a prepared measurement object, measures the position of an
	// actual character (or fetches it from the cache).
	function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
	  if (prepared.before) { ch = -1 }
	  var key = ch + (bias || ""), found
	  if (prepared.cache.hasOwnProperty(key)) {
	    found = prepared.cache[key]
	  } else {
	    if (!prepared.rect)
	      { prepared.rect = prepared.view.text.getBoundingClientRect() }
	    if (!prepared.hasHeights) {
	      ensureLineHeights(cm, prepared.view, prepared.rect)
	      prepared.hasHeights = true
	    }
	    found = measureCharInner(cm, prepared, ch, bias)
	    if (!found.bogus) { prepared.cache[key] = found }
	  }
	  return {left: found.left, right: found.right,
	          top: varHeight ? found.rtop : found.top,
	          bottom: varHeight ? found.rbottom : found.bottom}
	}
	
	var nullRect = {left: 0, right: 0, top: 0, bottom: 0}
	
	function nodeAndOffsetInLineMap(map, ch, bias) {
	  var node, start, end, collapse, mStart, mEnd
	  // First, search the line map for the text node corresponding to,
	  // or closest to, the target character.
	  for (var i = 0; i < map.length; i += 3) {
	    mStart = map[i]
	    mEnd = map[i + 1]
	    if (ch < mStart) {
	      start = 0; end = 1
	      collapse = "left"
	    } else if (ch < mEnd) {
	      start = ch - mStart
	      end = start + 1
	    } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
	      end = mEnd - mStart
	      start = end - 1
	      if (ch >= mEnd) { collapse = "right" }
	    }
	    if (start != null) {
	      node = map[i + 2]
	      if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
	        { collapse = bias }
	      if (bias == "left" && start == 0)
	        { while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
	          node = map[(i -= 3) + 2]
	          collapse = "left"
	        } }
	      if (bias == "right" && start == mEnd - mStart)
	        { while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
	          node = map[(i += 3) + 2]
	          collapse = "right"
	        } }
	      break
	    }
	  }
	  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
	}
	
	function getUsefulRect(rects, bias) {
	  var rect = nullRect
	  if (bias == "left") { for (var i = 0; i < rects.length; i++) {
	    if ((rect = rects[i]).left != rect.right) { break }
	  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
	    if ((rect = rects[i$1]).left != rect.right) { break }
	  } }
	  return rect
	}
	
	function measureCharInner(cm, prepared, ch, bias) {
	  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias)
	  var node = place.node, start = place.start, end = place.end, collapse = place.collapse
	
	  var rect
	  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
	    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
	      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start }
	      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end }
	      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
	        { rect = node.parentNode.getBoundingClientRect() }
	      else
	        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias) }
	      if (rect.left || rect.right || start == 0) { break }
	      end = start
	      start = start - 1
	      collapse = "right"
	    }
	    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect) }
	  } else { // If it is a widget, simply get the box for the whole widget.
	    if (start > 0) { collapse = bias = "right" }
	    var rects
	    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
	      { rect = rects[bias == "right" ? rects.length - 1 : 0] }
	    else
	      { rect = node.getBoundingClientRect() }
	  }
	  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
	    var rSpan = node.parentNode.getClientRects()[0]
	    if (rSpan)
	      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom} }
	    else
	      { rect = nullRect }
	  }
	
	  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top
	  var mid = (rtop + rbot) / 2
	  var heights = prepared.view.measure.heights
	  var i = 0
	  for (; i < heights.length - 1; i++)
	    { if (mid < heights[i]) { break } }
	  var top = i ? heights[i - 1] : 0, bot = heights[i]
	  var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
	                right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
	                top: top, bottom: bot}
	  if (!rect.left && !rect.right) { result.bogus = true }
	  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot }
	
	  return result
	}
	
	// Work around problem with bounding client rects on ranges being
	// returned incorrectly when zoomed on IE10 and below.
	function maybeUpdateRectForZooming(measure, rect) {
	  if (!window.screen || screen.logicalXDPI == null ||
	      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
	    { return rect }
	  var scaleX = screen.logicalXDPI / screen.deviceXDPI
	  var scaleY = screen.logicalYDPI / screen.deviceYDPI
	  return {left: rect.left * scaleX, right: rect.right * scaleX,
	          top: rect.top * scaleY, bottom: rect.bottom * scaleY}
	}
	
	function clearLineMeasurementCacheFor(lineView) {
	  if (lineView.measure) {
	    lineView.measure.cache = {}
	    lineView.measure.heights = null
	    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
	      { lineView.measure.caches[i] = {} } }
	  }
	}
	
	function clearLineMeasurementCache(cm) {
	  cm.display.externalMeasure = null
	  removeChildren(cm.display.lineMeasure)
	  for (var i = 0; i < cm.display.view.length; i++)
	    { clearLineMeasurementCacheFor(cm.display.view[i]) }
	}
	
	function clearCaches(cm) {
	  clearLineMeasurementCache(cm)
	  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null
	  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true }
	  cm.display.lineNumChars = null
	}
	
	function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft }
	function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop }
	
	// Converts a {top, bottom, left, right} box from line-local
	// coordinates into another coordinate system. Context may be one of
	// "line", "div" (display.lineDiv), "local"./null (editor), "window",
	// or "page".
	function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
	  if (!includeWidgets && lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above) {
	    var size = widgetHeight(lineObj.widgets[i])
	    rect.top += size; rect.bottom += size
	  } } }
	  if (context == "line") { return rect }
	  if (!context) { context = "local" }
	  var yOff = heightAtLine(lineObj)
	  if (context == "local") { yOff += paddingTop(cm.display) }
	  else { yOff -= cm.display.viewOffset }
	  if (context == "page" || context == "window") {
	    var lOff = cm.display.lineSpace.getBoundingClientRect()
	    yOff += lOff.top + (context == "window" ? 0 : pageScrollY())
	    var xOff = lOff.left + (context == "window" ? 0 : pageScrollX())
	    rect.left += xOff; rect.right += xOff
	  }
	  rect.top += yOff; rect.bottom += yOff
	  return rect
	}
	
	// Coverts a box from "div" coords to another coordinate system.
	// Context may be "window", "page", "div", or "local"./null.
	function fromCoordSystem(cm, coords, context) {
	  if (context == "div") { return coords }
	  var left = coords.left, top = coords.top
	  // First move into "page" coordinate system
	  if (context == "page") {
	    left -= pageScrollX()
	    top -= pageScrollY()
	  } else if (context == "local" || !context) {
	    var localBox = cm.display.sizer.getBoundingClientRect()
	    left += localBox.left
	    top += localBox.top
	  }
	
	  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect()
	  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
	}
	
	function charCoords(cm, pos, context, lineObj, bias) {
	  if (!lineObj) { lineObj = getLine(cm.doc, pos.line) }
	  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
	}
	
	// Returns a box for a given cursor position, which may have an
	// 'other' property containing the position of the secondary cursor
	// on a bidi boundary.
	function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
	  lineObj = lineObj || getLine(cm.doc, pos.line)
	  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj) }
	  function get(ch, right) {
	    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight)
	    if (right) { m.left = m.right; } else { m.right = m.left }
	    return intoCoordSystem(cm, lineObj, m, context)
	  }
	  function getBidi(ch, partPos) {
	    var part = order[partPos], right = part.level % 2
	    if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
	      part = order[--partPos]
	      ch = bidiRight(part) - (part.level % 2 ? 0 : 1)
	      right = true
	    } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
	      part = order[++partPos]
	      ch = bidiLeft(part) - part.level % 2
	      right = false
	    }
	    if (right && ch == part.to && ch > part.from) { return get(ch - 1) }
	    return get(ch, right)
	  }
	  var order = getOrder(lineObj), ch = pos.ch
	  if (!order) { return get(ch) }
	  var partPos = getBidiPartAt(order, ch)
	  var val = getBidi(ch, partPos)
	  if (bidiOther != null) { val.other = getBidi(ch, bidiOther) }
	  return val
	}
	
	// Used to cheaply estimate the coordinates for a position. Used for
	// intermediate scroll updates.
	function estimateCoords(cm, pos) {
	  var left = 0
	  pos = clipPos(cm.doc, pos)
	  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch }
	  var lineObj = getLine(cm.doc, pos.line)
	  var top = heightAtLine(lineObj) + paddingTop(cm.display)
	  return {left: left, right: left, top: top, bottom: top + lineObj.height}
	}
	
	// Positions returned by coordsChar contain some extra information.
	// xRel is the relative x position of the input coordinates compared
	// to the found position (so xRel > 0 means the coordinates are to
	// the right of the character position, for example). When outside
	// is true, that means the coordinates lie outside the line's
	// vertical range.
	function PosWithInfo(line, ch, outside, xRel) {
	  var pos = Pos(line, ch)
	  pos.xRel = xRel
	  if (outside) { pos.outside = true }
	  return pos
	}
	
	// Compute the character position closest to the given coordinates.
	// Input must be lineSpace-local ("div" coordinate system).
	function coordsChar(cm, x, y) {
	  var doc = cm.doc
	  y += cm.display.viewOffset
	  if (y < 0) { return PosWithInfo(doc.first, 0, true, -1) }
	  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1
	  if (lineN > last)
	    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1) }
	  if (x < 0) { x = 0 }
	
	  var lineObj = getLine(doc, lineN)
	  for (;;) {
	    var found = coordsCharInner(cm, lineObj, lineN, x, y)
	    var merged = collapsedSpanAtEnd(lineObj)
	    var mergedPos = merged && merged.find(0, true)
	    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
	      { lineN = lineNo(lineObj = mergedPos.to.line) }
	    else
	      { return found }
	  }
	}
	
	function coordsCharInner(cm, lineObj, lineNo, x, y) {
	  var innerOff = y - heightAtLine(lineObj)
	  var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth
	  var preparedMeasure = prepareMeasureForLine(cm, lineObj)
	
	  function getX(ch) {
	    var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure)
	    wrongLine = true
	    if (innerOff > sp.bottom) { return sp.left - adjust }
	    else if (innerOff < sp.top) { return sp.left + adjust }
	    else { wrongLine = false }
	    return sp.left
	  }
	
	  var bidi = getOrder(lineObj), dist = lineObj.text.length
	  var from = lineLeft(lineObj), to = lineRight(lineObj)
	  var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine
	
	  if (x > toX) { return PosWithInfo(lineNo, to, toOutside, 1) }
	  // Do a binary search between these bounds.
	  for (;;) {
	    if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
	      var ch = x < fromX || x - fromX <= toX - x ? from : to
	      var outside = ch == from ? fromOutside : toOutside
	      var xDiff = x - (ch == from ? fromX : toX)
	      // This is a kludge to handle the case where the coordinates
	      // are after a line-wrapped line. We should replace it with a
	      // more general handling of cursor positions around line
	      // breaks. (Issue #4078)
	      if (toOutside && !bidi && !/\s/.test(lineObj.text.charAt(ch)) && xDiff > 0 &&
	          ch < lineObj.text.length && preparedMeasure.view.measure.heights.length > 1) {
	        var charSize = measureCharPrepared(cm, preparedMeasure, ch, "right")
	        if (innerOff <= charSize.bottom && innerOff >= charSize.top && Math.abs(x - charSize.right) < xDiff) {
	          outside = false
	          ch++
	          xDiff = x - charSize.right
	        }
	      }
	      while (isExtendingChar(lineObj.text.charAt(ch))) { ++ch }
	      var pos = PosWithInfo(lineNo, ch, outside, xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0)
	      return pos
	    }
	    var step = Math.ceil(dist / 2), middle = from + step
	    if (bidi) {
	      middle = from
	      for (var i = 0; i < step; ++i) { middle = moveVisually(lineObj, middle, 1) }
	    }
	    var middleX = getX(middle)
	    if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) { toX += 1000; } dist = step}
	    else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step}
	  }
	}
	
	var measureText
	// Compute the default text height.
	function textHeight(display) {
	  if (display.cachedTextHeight != null) { return display.cachedTextHeight }
	  if (measureText == null) {
	    measureText = elt("pre")
	    // Measure a bunch of lines, for browsers that compute
	    // fractional heights.
	    for (var i = 0; i < 49; ++i) {
	      measureText.appendChild(document.createTextNode("x"))
	      measureText.appendChild(elt("br"))
	    }
	    measureText.appendChild(document.createTextNode("x"))
	  }
	  removeChildrenAndAdd(display.measure, measureText)
	  var height = measureText.offsetHeight / 50
	  if (height > 3) { display.cachedTextHeight = height }
	  removeChildren(display.measure)
	  return height || 1
	}
	
	// Compute the default character width.
	function charWidth(display) {
	  if (display.cachedCharWidth != null) { return display.cachedCharWidth }
	  var anchor = elt("span", "xxxxxxxxxx")
	  var pre = elt("pre", [anchor])
	  removeChildrenAndAdd(display.measure, pre)
	  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10
	  if (width > 2) { display.cachedCharWidth = width }
	  return width || 10
	}
	
	// Do a bulk-read of the DOM positions and sizes needed to draw the
	// view, so that we don't interleave reading and writing to the DOM.
	function getDimensions(cm) {
	  var d = cm.display, left = {}, width = {}
	  var gutterLeft = d.gutters.clientLeft
	  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
	    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft
	    width[cm.options.gutters[i]] = n.clientWidth
	  }
	  return {fixedPos: compensateForHScroll(d),
	          gutterTotalWidth: d.gutters.offsetWidth,
	          gutterLeft: left,
	          gutterWidth: width,
	          wrapperWidth: d.wrapper.clientWidth}
	}
	
	// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
	// but using getBoundingClientRect to get a sub-pixel-accurate
	// result.
	function compensateForHScroll(display) {
	  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
	}
	
	// Returns a function that estimates the height of a line, to use as
	// first approximation until the line becomes visible (and is thus
	// properly measurable).
	function estimateHeight(cm) {
	  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping
	  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3)
	  return function (line) {
	    if (lineIsHidden(cm.doc, line)) { return 0 }
	
	    var widgetsHeight = 0
	    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
	      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height }
	    } }
	
	    if (wrapping)
	      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
	    else
	      { return widgetsHeight + th }
	  }
	}
	
	function estimateLineHeights(cm) {
	  var doc = cm.doc, est = estimateHeight(cm)
	  doc.iter(function (line) {
	    var estHeight = est(line)
	    if (estHeight != line.height) { updateLineHeight(line, estHeight) }
	  })
	}
	
	// Given a mouse event, find the corresponding position. If liberal
	// is false, it checks whether a gutter or scrollbar was clicked,
	// and returns null if it was. forRect is used by rectangular
	// selections, and tries to estimate a character position even for
	// coordinates beyond the right of the text.
	function posFromMouse(cm, e, liberal, forRect) {
	  var display = cm.display
	  if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }
	
	  var x, y, space = display.lineSpace.getBoundingClientRect()
	  // Fails unpredictably on IE[67] when mouse is dragged around quickly.
	  try { x = e.clientX - space.left; y = e.clientY - space.top }
	  catch (e) { return null }
	  var coords = coordsChar(cm, x, y), line
	  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
	    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length
	    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff))
	  }
	  return coords
	}
	
	// Find the view element corresponding to a given line. Return null
	// when the line isn't visible.
	function findViewIndex(cm, n) {
	  if (n >= cm.display.viewTo) { return null }
	  n -= cm.display.viewFrom
	  if (n < 0) { return null }
	  var view = cm.display.view
	  for (var i = 0; i < view.length; i++) {
	    n -= view[i].size
	    if (n < 0) { return i }
	  }
	}
	
	function updateSelection(cm) {
	  cm.display.input.showSelection(cm.display.input.prepareSelection())
	}
	
	function prepareSelection(cm, primary) {
	  var doc = cm.doc, result = {}
	  var curFragment = result.cursors = document.createDocumentFragment()
	  var selFragment = result.selection = document.createDocumentFragment()
	
	  for (var i = 0; i < doc.sel.ranges.length; i++) {
	    if (primary === false && i == doc.sel.primIndex) { continue }
	    var range = doc.sel.ranges[i]
	    if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) { continue }
	    var collapsed = range.empty()
	    if (collapsed || cm.options.showCursorWhenSelecting)
	      { drawSelectionCursor(cm, range.head, curFragment) }
	    if (!collapsed)
	      { drawSelectionRange(cm, range, selFragment) }
	  }
	  return result
	}
	
	// Draws a cursor for the given range
	function drawSelectionCursor(cm, head, output) {
	  var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine)
	
	  var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"))
	  cursor.style.left = pos.left + "px"
	  cursor.style.top = pos.top + "px"
	  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px"
	
	  if (pos.other) {
	    // Secondary cursor, shown when on a 'jump' in bi-directional text
	    var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"))
	    otherCursor.style.display = ""
	    otherCursor.style.left = pos.other.left + "px"
	    otherCursor.style.top = pos.other.top + "px"
	    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px"
	  }
	}
	
	// Draws the given range as a highlighted selection
	function drawSelectionRange(cm, range, output) {
	  var display = cm.display, doc = cm.doc
	  var fragment = document.createDocumentFragment()
	  var padding = paddingH(cm.display), leftSide = padding.left
	  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right
	
	  function add(left, top, width, bottom) {
	    if (top < 0) { top = 0 }
	    top = Math.round(top)
	    bottom = Math.round(bottom)
	    fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")))
	  }
	
	  function drawForLine(line, fromArg, toArg) {
	    var lineObj = getLine(doc, line)
	    var lineLen = lineObj.text.length
	    var start, end
	    function coords(ch, bias) {
	      return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
	    }
	
	    iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {
	      var leftPos = coords(from, "left"), rightPos, left, right
	      if (from == to) {
	        rightPos = leftPos
	        left = right = leftPos.left
	      } else {
	        rightPos = coords(to - 1, "right")
	        if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp }
	        left = leftPos.left
	        right = rightPos.right
	      }
	      if (fromArg == null && from == 0) { left = leftSide }
	      if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part
	        add(left, leftPos.top, null, leftPos.bottom)
	        left = leftSide
	        if (leftPos.bottom < rightPos.top) { add(left, leftPos.bottom, null, rightPos.top) }
	      }
	      if (toArg == null && to == lineLen) { right = rightSide }
	      if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
	        { start = leftPos }
	      if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
	        { end = rightPos }
	      if (left < leftSide + 1) { left = leftSide }
	      add(left, rightPos.top, right - left, rightPos.bottom)
	    })
	    return {start: start, end: end}
	  }
	
	  var sFrom = range.from(), sTo = range.to()
	  if (sFrom.line == sTo.line) {
	    drawForLine(sFrom.line, sFrom.ch, sTo.ch)
	  } else {
	    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line)
	    var singleVLine = visualLine(fromLine) == visualLine(toLine)
	    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end
	    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start
	    if (singleVLine) {
	      if (leftEnd.top < rightStart.top - 2) {
	        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom)
	        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom)
	      } else {
	        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom)
	      }
	    }
	    if (leftEnd.bottom < rightStart.top)
	      { add(leftSide, leftEnd.bottom, null, rightStart.top) }
	  }
	
	  output.appendChild(fragment)
	}
	
	// Cursor-blinking
	function restartBlink(cm) {
	  if (!cm.state.focused) { return }
	  var display = cm.display
	  clearInterval(display.blinker)
	  var on = true
	  display.cursorDiv.style.visibility = ""
	  if (cm.options.cursorBlinkRate > 0)
	    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden"; },
	      cm.options.cursorBlinkRate) }
	  else if (cm.options.cursorBlinkRate < 0)
	    { display.cursorDiv.style.visibility = "hidden" }
	}
	
	function ensureFocus(cm) {
	  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm) }
	}
	
	function delayBlurEvent(cm) {
	  cm.state.delayingBlurEvent = true
	  setTimeout(function () { if (cm.state.delayingBlurEvent) {
	    cm.state.delayingBlurEvent = false
	    onBlur(cm)
	  } }, 100)
	}
	
	function onFocus(cm, e) {
	  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false }
	
	  if (cm.options.readOnly == "nocursor") { return }
	  if (!cm.state.focused) {
	    signal(cm, "focus", cm, e)
	    cm.state.focused = true
	    addClass(cm.display.wrapper, "CodeMirror-focused")
	    // This test prevents this from firing when a context
	    // menu is closed (since the input reset would kill the
	    // select-all detection hack)
	    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
	      cm.display.input.reset()
	      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20) } // Issue #1730
	    }
	    cm.display.input.receivedFocus()
	  }
	  restartBlink(cm)
	}
	function onBlur(cm, e) {
	  if (cm.state.delayingBlurEvent) { return }
	
	  if (cm.state.focused) {
	    signal(cm, "blur", cm, e)
	    cm.state.focused = false
	    rmClass(cm.display.wrapper, "CodeMirror-focused")
	  }
	  clearInterval(cm.display.blinker)
	  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false } }, 150)
	}
	
	// Re-align line numbers and gutter marks to compensate for
	// horizontal scrolling.
	function alignHorizontally(cm) {
	  var display = cm.display, view = display.view
	  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
	  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft
	  var gutterW = display.gutters.offsetWidth, left = comp + "px"
	  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
	    if (cm.options.fixedGutter) {
	      if (view[i].gutter)
	        { view[i].gutter.style.left = left }
	      if (view[i].gutterBackground)
	        { view[i].gutterBackground.style.left = left }
	    }
	    var align = view[i].alignable
	    if (align) { for (var j = 0; j < align.length; j++)
	      { align[j].style.left = left } }
	  } }
	  if (cm.options.fixedGutter)
	    { display.gutters.style.left = (comp + gutterW) + "px" }
	}
	
	// Used to ensure that the line number gutter is still the right
	// size for the current document size. Returns true when an update
	// is needed.
	function maybeUpdateLineNumberWidth(cm) {
	  if (!cm.options.lineNumbers) { return false }
	  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display
	  if (last.length != display.lineNumChars) {
	    var test = display.measure.appendChild(elt("div", [elt("div", last)],
	                                               "CodeMirror-linenumber CodeMirror-gutter-elt"))
	    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW
	    display.lineGutter.style.width = ""
	    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1
	    display.lineNumWidth = display.lineNumInnerWidth + padding
	    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1
	    display.lineGutter.style.width = display.lineNumWidth + "px"
	    updateGutterSpace(cm)
	    return true
	  }
	  return false
	}
	
	// Read the actual heights of the rendered lines, and update their
	// stored heights to match.
	function updateHeightsInViewport(cm) {
	  var display = cm.display
	  var prevBottom = display.lineDiv.offsetTop
	  for (var i = 0; i < display.view.length; i++) {
	    var cur = display.view[i], height = (void 0)
	    if (cur.hidden) { continue }
	    if (ie && ie_version < 8) {
	      var bot = cur.node.offsetTop + cur.node.offsetHeight
	      height = bot - prevBottom
	      prevBottom = bot
	    } else {
	      var box = cur.node.getBoundingClientRect()
	      height = box.bottom - box.top
	    }
	    var diff = cur.line.height - height
	    if (height < 2) { height = textHeight(display) }
	    if (diff > .001 || diff < -.001) {
	      updateLineHeight(cur.line, height)
	      updateWidgetHeight(cur.line)
	      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
	        { updateWidgetHeight(cur.rest[j]) } }
	    }
	  }
	}
	
	// Read and store the height of line widgets associated with the
	// given line.
	function updateWidgetHeight(line) {
	  if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i)
	    { line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight } }
	}
	
	// Compute the lines that are visible in a given viewport (defaults
	// the the current scroll position). viewport may contain top,
	// height, and ensure (see op.scrollToPos) properties.
	function visibleLines(display, doc, viewport) {
	  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop
	  top = Math.floor(top - paddingTop(display))
	  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight
	
	  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom)
	  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
	  // forces those lines into the viewport (if possible).
	  if (viewport && viewport.ensure) {
	    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line
	    if (ensureFrom < from) {
	      from = ensureFrom
	      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)
	    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
	      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight)
	      to = ensureTo
	    }
	  }
	  return {from: from, to: Math.max(to, from + 1)}
	}
	
	// Sync the scrollable area and scrollbars, ensure the viewport
	// covers the visible area.
	function setScrollTop(cm, val) {
	  if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
	  cm.doc.scrollTop = val
	  if (!gecko) { updateDisplaySimple(cm, {top: val}) }
	  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val }
	  cm.display.scrollbars.setScrollTop(val)
	  if (gecko) { updateDisplaySimple(cm) }
	  startWorker(cm, 100)
	}
	// Sync scroller and scrollbar, ensure the gutter elements are
	// aligned.
	function setScrollLeft(cm, val, isScroller) {
	  if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) { return }
	  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth)
	  cm.doc.scrollLeft = val
	  alignHorizontally(cm)
	  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val }
	  cm.display.scrollbars.setScrollLeft(val)
	}
	
	// Since the delta values reported on mouse wheel events are
	// unstandardized between browsers and even browser versions, and
	// generally horribly unpredictable, this code starts by measuring
	// the scroll effect that the first few mouse wheel events have,
	// and, from that, detects the way it can convert deltas to pixel
	// offsets afterwards.
	//
	// The reason we want to know the amount a wheel event will scroll
	// is that it gives us a chance to update the display before the
	// actual scrolling happens, reducing flickering.
	
	var wheelSamples = 0;
	var wheelPixelsPerUnit = null;
	// Fill in a browser-detected starting value on browsers where we
	// know one. These don't have to be accurate -- the result of them
	// being wrong would just be a slight flicker on the first wheel
	// scroll (if it is large enough).
	if (ie) { wheelPixelsPerUnit = -.53 }
	else if (gecko) { wheelPixelsPerUnit = 15 }
	else if (chrome) { wheelPixelsPerUnit = -.7 }
	else if (safari) { wheelPixelsPerUnit = -1/3 }
	
	function wheelEventDelta(e) {
	  var dx = e.wheelDeltaX, dy = e.wheelDeltaY
	  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail }
	  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail }
	  else if (dy == null) { dy = e.wheelDelta }
	  return {x: dx, y: dy}
	}
	function wheelEventPixels(e) {
	  var delta = wheelEventDelta(e)
	  delta.x *= wheelPixelsPerUnit
	  delta.y *= wheelPixelsPerUnit
	  return delta
	}
	
	function onScrollWheel(cm, e) {
	  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y
	
	  var display = cm.display, scroll = display.scroller
	  // Quit if there's nothing to scroll here
	  var canScrollX = scroll.scrollWidth > scroll.clientWidth
	  var canScrollY = scroll.scrollHeight > scroll.clientHeight
	  if (!(dx && canScrollX || dy && canScrollY)) { return }
	
	  // Webkit browsers on OS X abort momentum scrolls when the target
	  // of the scroll event is removed from the scrollable element.
	  // This hack (see related code in patchDisplay) makes sure the
	  // element is kept around.
	  if (dy && mac && webkit) {
	    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
	      for (var i = 0; i < view.length; i++) {
	        if (view[i].node == cur) {
	          cm.display.currentWheelTarget = cur
	          break outer
	        }
	      }
	    }
	  }
	
	  // On some browsers, horizontal scrolling will cause redraws to
	  // happen before the gutter has been realigned, causing it to
	  // wriggle around in a most unseemly way. When we have an
	  // estimated pixels/delta value, we just handle horizontal
	  // scrolling entirely here. It'll be slightly off from native, but
	  // better than glitching out.
	  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
	    if (dy && canScrollY)
	      { setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight))) }
	    setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)))
	    // Only prevent default scrolling if vertical scrolling is
	    // actually possible. Otherwise, it causes vertical scroll
	    // jitter on OSX trackpads when deltaX is small and deltaY
	    // is large (issue #3579)
	    if (!dy || (dy && canScrollY))
	      { e_preventDefault(e) }
	    display.wheelStartX = null // Abort measurement, if in progress
	    return
	  }
	
	  // 'Project' the visible viewport to cover the area that is being
	  // scrolled into view (if we know enough to estimate it).
	  if (dy && wheelPixelsPerUnit != null) {
	    var pixels = dy * wheelPixelsPerUnit
	    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight
	    if (pixels < 0) { top = Math.max(0, top + pixels - 50) }
	    else { bot = Math.min(cm.doc.height, bot + pixels + 50) }
	    updateDisplaySimple(cm, {top: top, bottom: bot})
	  }
	
	  if (wheelSamples < 20) {
	    if (display.wheelStartX == null) {
	      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop
	      display.wheelDX = dx; display.wheelDY = dy
	      setTimeout(function () {
	        if (display.wheelStartX == null) { return }
	        var movedX = scroll.scrollLeft - display.wheelStartX
	        var movedY = scroll.scrollTop - display.wheelStartY
	        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
	          (movedX && display.wheelDX && movedX / display.wheelDX)
	        display.wheelStartX = display.wheelStartY = null
	        if (!sample) { return }
	        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1)
	        ++wheelSamples
	      }, 200)
	    } else {
	      display.wheelDX += dx; display.wheelDY += dy
	    }
	  }
	}
	
	// SCROLLBARS
	
	// Prepare DOM reads needed to update the scrollbars. Done in one
	// shot to minimize update/measure roundtrips.
	function measureForScrollbars(cm) {
	  var d = cm.display, gutterW = d.gutters.offsetWidth
	  var docH = Math.round(cm.doc.height + paddingVert(cm.display))
	  return {
	    clientHeight: d.scroller.clientHeight,
	    viewHeight: d.wrapper.clientHeight,
	    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
	    viewWidth: d.wrapper.clientWidth,
	    barLeft: cm.options.fixedGutter ? gutterW : 0,
	    docHeight: docH,
	    scrollHeight: docH + scrollGap(cm) + d.barHeight,
	    nativeBarWidth: d.nativeBarWidth,
	    gutterWidth: gutterW
	  }
	}
	
	var NativeScrollbars = function(place, scroll, cm) {
	  this.cm = cm
	  var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar")
	  var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar")
	  place(vert); place(horiz)
	
	  on(vert, "scroll", function () {
	    if (vert.clientHeight) { scroll(vert.scrollTop, "vertical") }
	  })
	  on(horiz, "scroll", function () {
	    if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal") }
	  })
	
	  this.checkedZeroWidth = false
	  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
	  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px" }
	};
	
	NativeScrollbars.prototype.update = function (measure) {
	  var needsH = measure.scrollWidth > measure.clientWidth + 1
	  var needsV = measure.scrollHeight > measure.clientHeight + 1
	  var sWidth = measure.nativeBarWidth
	
	  if (needsV) {
	    this.vert.style.display = "block"
	    this.vert.style.bottom = needsH ? sWidth + "px" : "0"
	    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0)
	    // A bug in IE8 can cause this value to be negative, so guard it.
	    this.vert.firstChild.style.height =
	      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px"
	  } else {
	    this.vert.style.display = ""
	    this.vert.firstChild.style.height = "0"
	  }
	
	  if (needsH) {
	    this.horiz.style.display = "block"
	    this.horiz.style.right = needsV ? sWidth + "px" : "0"
	    this.horiz.style.left = measure.barLeft + "px"
	    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0)
	    this.horiz.firstChild.style.width =
	      (measure.scrollWidth - measure.clientWidth + totalWidth) + "px"
	  } else {
	    this.horiz.style.display = ""
	    this.horiz.firstChild.style.width = "0"
	  }
	
	  if (!this.checkedZeroWidth && measure.clientHeight > 0) {
	    if (sWidth == 0) { this.zeroWidthHack() }
	    this.checkedZeroWidth = true
	  }
	
	  return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
	};
	
	NativeScrollbars.prototype.setScrollLeft = function (pos) {
	  if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos }
	  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz) }
	};
	
	NativeScrollbars.prototype.setScrollTop = function (pos) {
	  if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos }
	  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert) }
	};
	
	NativeScrollbars.prototype.zeroWidthHack = function () {
	  var w = mac && !mac_geMountainLion ? "12px" : "18px"
	  this.horiz.style.height = this.vert.style.width = w
	  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none"
	  this.disableHoriz = new Delayed
	  this.disableVert = new Delayed
	};
	
	NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay) {
	  bar.style.pointerEvents = "auto"
	  function maybeDisable() {
	    // To find out whether the scrollbar is still visible, we
	    // check whether the element under the pixel in the bottom
	    // left corner of the scrollbar box is the scrollbar box
	    // itself (when the bar is still visible) or its filler child
	    // (when the bar is hidden). If it is still visible, we keep
	    // it enabled, if it's hidden, we disable pointer events.
	    var box = bar.getBoundingClientRect()
	    var elt = document.elementFromPoint(box.left + 1, box.bottom - 1)
	    if (elt != bar) { bar.style.pointerEvents = "none" }
	    else { delay.set(1000, maybeDisable) }
	  }
	  delay.set(1000, maybeDisable)
	};
	
	NativeScrollbars.prototype.clear = function () {
	  var parent = this.horiz.parentNode
	  parent.removeChild(this.horiz)
	  parent.removeChild(this.vert)
	};
	
	var NullScrollbars = function () {};
	
	NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
	NullScrollbars.prototype.setScrollLeft = function () {};
	NullScrollbars.prototype.setScrollTop = function () {};
	NullScrollbars.prototype.clear = function () {};
	
	function updateScrollbars(cm, measure) {
	  if (!measure) { measure = measureForScrollbars(cm) }
	  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight
	  updateScrollbarsInner(cm, measure)
	  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
	    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
	      { updateHeightsInViewport(cm) }
	    updateScrollbarsInner(cm, measureForScrollbars(cm))
	    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight
	  }
	}
	
	// Re-synchronize the fake scrollbars with the actual size of the
	// content.
	function updateScrollbarsInner(cm, measure) {
	  var d = cm.display
	  var sizes = d.scrollbars.update(measure)
	
	  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px"
	  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px"
	  d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent"
	
	  if (sizes.right && sizes.bottom) {
	    d.scrollbarFiller.style.display = "block"
	    d.scrollbarFiller.style.height = sizes.bottom + "px"
	    d.scrollbarFiller.style.width = sizes.right + "px"
	  } else { d.scrollbarFiller.style.display = "" }
	  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
	    d.gutterFiller.style.display = "block"
	    d.gutterFiller.style.height = sizes.bottom + "px"
	    d.gutterFiller.style.width = measure.gutterWidth + "px"
	  } else { d.gutterFiller.style.display = "" }
	}
	
	var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars}
	
	function initScrollbars(cm) {
	  if (cm.display.scrollbars) {
	    cm.display.scrollbars.clear()
	    if (cm.display.scrollbars.addClass)
	      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass) }
	  }
	
	  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
	    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller)
	    // Prevent clicks in the scrollbars from killing focus
	    on(node, "mousedown", function () {
	      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0) }
	    })
	    node.setAttribute("cm-not-content", "true")
	  }, function (pos, axis) {
	    if (axis == "horizontal") { setScrollLeft(cm, pos) }
	    else { setScrollTop(cm, pos) }
	  }, cm)
	  if (cm.display.scrollbars.addClass)
	    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass) }
	}
	
	// SCROLLING THINGS INTO VIEW
	
	// If an editor sits on the top or bottom of the window, partially
	// scrolled out of view, this ensures that the cursor is visible.
	function maybeScrollWindow(cm, coords) {
	  if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }
	
	  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null
	  if (coords.top + box.top < 0) { doScroll = true }
	  else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false }
	  if (doScroll != null && !phantom) {
	    var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (coords.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (coords.left) + "px; width: 2px;"))
	    cm.display.lineSpace.appendChild(scrollNode)
	    scrollNode.scrollIntoView(doScroll)
	    cm.display.lineSpace.removeChild(scrollNode)
	  }
	}
	
	// Scroll a given position into view (immediately), verifying that
	// it actually became visible (as line heights are accurately
	// measured, the position of something may 'drift' during drawing).
	function scrollPosIntoView(cm, pos, end, margin) {
	  if (margin == null) { margin = 0 }
	  var coords
	  for (var limit = 0; limit < 5; limit++) {
	    var changed = false
	    coords = cursorCoords(cm, pos)
	    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end)
	    var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),
	                                       Math.min(coords.top, endCoords.top) - margin,
	                                       Math.max(coords.left, endCoords.left),
	                                       Math.max(coords.bottom, endCoords.bottom) + margin)
	    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft
	    if (scrollPos.scrollTop != null) {
	      setScrollTop(cm, scrollPos.scrollTop)
	      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true }
	    }
	    if (scrollPos.scrollLeft != null) {
	      setScrollLeft(cm, scrollPos.scrollLeft)
	      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true }
	    }
	    if (!changed) { break }
	  }
	  return coords
	}
	
	// Scroll a given set of coordinates into view (immediately).
	function scrollIntoView(cm, x1, y1, x2, y2) {
	  var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2)
	  if (scrollPos.scrollTop != null) { setScrollTop(cm, scrollPos.scrollTop) }
	  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft) }
	}
	
	// Calculate a new scroll position needed to scroll the given
	// rectangle into view. Returns an object with scrollTop and
	// scrollLeft properties. When these are undefined, the
	// vertical/horizontal position does not need to be adjusted.
	function calculateScrollPos(cm, x1, y1, x2, y2) {
	  var display = cm.display, snapMargin = textHeight(cm.display)
	  if (y1 < 0) { y1 = 0 }
	  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop
	  var screen = displayHeight(cm), result = {}
	  if (y2 - y1 > screen) { y2 = y1 + screen }
	  var docBottom = cm.doc.height + paddingVert(display)
	  var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin
	  if (y1 < screentop) {
	    result.scrollTop = atTop ? 0 : y1
	  } else if (y2 > screentop + screen) {
	    var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen)
	    if (newTop != screentop) { result.scrollTop = newTop }
	  }
	
	  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft
	  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0)
	  var tooWide = x2 - x1 > screenw
	  if (tooWide) { x2 = x1 + screenw }
	  if (x1 < 10)
	    { result.scrollLeft = 0 }
	  else if (x1 < screenleft)
	    { result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10)) }
	  else if (x2 > screenw + screenleft - 3)
	    { result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw }
	  return result
	}
	
	// Store a relative adjustment to the scroll position in the current
	// operation (to be applied when the operation finishes).
	function addToScrollPos(cm, left, top) {
	  if (left != null || top != null) { resolveScrollToPos(cm) }
	  if (left != null)
	    { cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left }
	  if (top != null)
	    { cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top }
	}
	
	// Make sure that at the end of the operation the current cursor is
	// shown.
	function ensureCursorVisible(cm) {
	  resolveScrollToPos(cm)
	  var cur = cm.getCursor(), from = cur, to = cur
	  if (!cm.options.lineWrapping) {
	    from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur
	    to = Pos(cur.line, cur.ch + 1)
	  }
	  cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true}
	}
	
	// When an operation has its scrollToPos property set, and another
	// scroll action is applied before the end of the operation, this
	// 'simulates' scrolling that position into view in a cheap way, so
	// that the effect of intermediate scroll commands is not ignored.
	function resolveScrollToPos(cm) {
	  var range = cm.curOp.scrollToPos
	  if (range) {
	    cm.curOp.scrollToPos = null
	    var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to)
	    var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),
	                                  Math.min(from.top, to.top) - range.margin,
	                                  Math.max(from.right, to.right),
	                                  Math.max(from.bottom, to.bottom) + range.margin)
	    cm.scrollTo(sPos.scrollLeft, sPos.scrollTop)
	  }
	}
	
	// Operations are used to wrap a series of changes to the editor
	// state in such a way that each change won't have to update the
	// cursor and display (which would be awkward, slow, and
	// error-prone). Instead, display updates are batched and then all
	// combined and executed at once.
	
	var nextOpId = 0
	// Start a new operation.
	function startOperation(cm) {
	  cm.curOp = {
	    cm: cm,
	    viewChanged: false,      // Flag that indicates that lines might need to be redrawn
	    startHeight: cm.doc.height, // Used to detect need to update scrollbar
	    forceUpdate: false,      // Used to force a redraw
	    updateInput: null,       // Whether to reset the input textarea
	    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
	    changeObjs: null,        // Accumulated changes, for firing change events
	    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
	    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
	    selectionChanged: false, // Whether the selection needs to be redrawn
	    updateMaxLine: false,    // Set when the widest line needs to be determined anew
	    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
	    scrollToPos: null,       // Used to scroll to a specific position
	    focus: false,
	    id: ++nextOpId           // Unique ID
	  }
	  pushOperation(cm.curOp)
	}
	
	// Finish an operation, updating the display and signalling delayed events
	function endOperation(cm) {
	  var op = cm.curOp
	  finishOperation(op, function (group) {
	    for (var i = 0; i < group.ops.length; i++)
	      { group.ops[i].cm.curOp = null }
	    endOperations(group)
	  })
	}
	
	// The DOM updates done when an operation finishes are batched so
	// that the minimum number of relayouts are required.
	function endOperations(group) {
	  var ops = group.ops
	  for (var i = 0; i < ops.length; i++) // Read DOM
	    { endOperation_R1(ops[i]) }
	  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
	    { endOperation_W1(ops[i$1]) }
	  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
	    { endOperation_R2(ops[i$2]) }
	  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
	    { endOperation_W2(ops[i$3]) }
	  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
	    { endOperation_finish(ops[i$4]) }
	}
	
	function endOperation_R1(op) {
	  var cm = op.cm, display = cm.display
	  maybeClipScrollbars(cm)
	  if (op.updateMaxLine) { findMaxLine(cm) }
	
	  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
	    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
	                       op.scrollToPos.to.line >= display.viewTo) ||
	    display.maxLineChanged && cm.options.lineWrapping
	  op.update = op.mustUpdate &&
	    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate)
	}
	
	function endOperation_W1(op) {
	  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update)
	}
	
	function endOperation_R2(op) {
	  var cm = op.cm, display = cm.display
	  if (op.updatedDisplay) { updateHeightsInViewport(cm) }
	
	  op.barMeasure = measureForScrollbars(cm)
	
	  // If the max line changed since it was last measured, measure it,
	  // and ensure the document's width matches it.
	  // updateDisplay_W2 will use these properties to do the actual resizing
	  if (display.maxLineChanged && !cm.options.lineWrapping) {
	    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3
	    cm.display.sizerWidth = op.adjustWidthTo
	    op.barMeasure.scrollWidth =
	      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth)
	    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm))
	  }
	
	  if (op.updatedDisplay || op.selectionChanged)
	    { op.preparedSelection = display.input.prepareSelection(op.focus) }
	}
	
	function endOperation_W2(op) {
	  var cm = op.cm
	
	  if (op.adjustWidthTo != null) {
	    cm.display.sizer.style.minWidth = op.adjustWidthTo + "px"
	    if (op.maxScrollLeft < cm.doc.scrollLeft)
	      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true) }
	    cm.display.maxLineChanged = false
	  }
	
	  var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus())
	  if (op.preparedSelection)
	    { cm.display.input.showSelection(op.preparedSelection, takeFocus) }
	  if (op.updatedDisplay || op.startHeight != cm.doc.height)
	    { updateScrollbars(cm, op.barMeasure) }
	  if (op.updatedDisplay)
	    { setDocumentHeight(cm, op.barMeasure) }
	
	  if (op.selectionChanged) { restartBlink(cm) }
	
	  if (cm.state.focused && op.updateInput)
	    { cm.display.input.reset(op.typing) }
	  if (takeFocus) { ensureFocus(op.cm) }
	}
	
	function endOperation_finish(op) {
	  var cm = op.cm, display = cm.display, doc = cm.doc
	
	  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update) }
	
	  // Abort mouse wheel delta measurement, when scrolling explicitly
	  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
	    { display.wheelStartX = display.wheelStartY = null }
	
	  // Propagate the scroll position to the actual DOM scroller
	  if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {
	    doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop))
	    display.scrollbars.setScrollTop(doc.scrollTop)
	    display.scroller.scrollTop = doc.scrollTop
	  }
	  if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {
	    doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft))
	    display.scrollbars.setScrollLeft(doc.scrollLeft)
	    display.scroller.scrollLeft = doc.scrollLeft
	    alignHorizontally(cm)
	  }
	  // If we need to scroll a specific position into view, do so.
	  if (op.scrollToPos) {
	    var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
	                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin)
	    if (op.scrollToPos.isCursor && cm.state.focused) { maybeScrollWindow(cm, coords) }
	  }
	
	  // Fire events for markers that are hidden/unidden by editing or
	  // undoing
	  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers
	  if (hidden) { for (var i = 0; i < hidden.length; ++i)
	    { if (!hidden[i].lines.length) { signal(hidden[i], "hide") } } }
	  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
	    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide") } } }
	
	  if (display.wrapper.offsetHeight)
	    { doc.scrollTop = cm.display.scroller.scrollTop }
	
	  // Fire change events, and delayed event handlers
	  if (op.changeObjs)
	    { signal(cm, "changes", cm, op.changeObjs) }
	  if (op.update)
	    { op.update.finish() }
	}
	
	// Run the given function in an operation
	function runInOp(cm, f) {
	  if (cm.curOp) { return f() }
	  startOperation(cm)
	  try { return f() }
	  finally { endOperation(cm) }
	}
	// Wraps a function in an operation. Returns the wrapped function.
	function operation(cm, f) {
	  return function() {
	    if (cm.curOp) { return f.apply(cm, arguments) }
	    startOperation(cm)
	    try { return f.apply(cm, arguments) }
	    finally { endOperation(cm) }
	  }
	}
	// Used to add methods to editor and doc instances, wrapping them in
	// operations.
	function methodOp(f) {
	  return function() {
	    if (this.curOp) { return f.apply(this, arguments) }
	    startOperation(this)
	    try { return f.apply(this, arguments) }
	    finally { endOperation(this) }
	  }
	}
	function docMethodOp(f) {
	  return function() {
	    var cm = this.cm
	    if (!cm || cm.curOp) { return f.apply(this, arguments) }
	    startOperation(cm)
	    try { return f.apply(this, arguments) }
	    finally { endOperation(cm) }
	  }
	}
	
	// Updates the display.view data structure for a given change to the
	// document. From and to are in pre-change coordinates. Lendiff is
	// the amount of lines added or subtracted by the change. This is
	// used for changes that span multiple lines, or change the way
	// lines are divided into visual lines. regLineChange (below)
	// registers single-line changes.
	function regChange(cm, from, to, lendiff) {
	  if (from == null) { from = cm.doc.first }
	  if (to == null) { to = cm.doc.first + cm.doc.size }
	  if (!lendiff) { lendiff = 0 }
	
	  var display = cm.display
	  if (lendiff && to < display.viewTo &&
	      (display.updateLineNumbers == null || display.updateLineNumbers > from))
	    { display.updateLineNumbers = from }
	
	  cm.curOp.viewChanged = true
	
	  if (from >= display.viewTo) { // Change after
	    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
	      { resetView(cm) }
	  } else if (to <= display.viewFrom) { // Change before
	    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
	      resetView(cm)
	    } else {
	      display.viewFrom += lendiff
	      display.viewTo += lendiff
	    }
	  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
	    resetView(cm)
	  } else if (from <= display.viewFrom) { // Top overlap
	    var cut = viewCuttingPoint(cm, to, to + lendiff, 1)
	    if (cut) {
	      display.view = display.view.slice(cut.index)
	      display.viewFrom = cut.lineN
	      display.viewTo += lendiff
	    } else {
	      resetView(cm)
	    }
	  } else if (to >= display.viewTo) { // Bottom overlap
	    var cut$1 = viewCuttingPoint(cm, from, from, -1)
	    if (cut$1) {
	      display.view = display.view.slice(0, cut$1.index)
	      display.viewTo = cut$1.lineN
	    } else {
	      resetView(cm)
	    }
	  } else { // Gap in the middle
	    var cutTop = viewCuttingPoint(cm, from, from, -1)
	    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1)
	    if (cutTop && cutBot) {
	      display.view = display.view.slice(0, cutTop.index)
	        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
	        .concat(display.view.slice(cutBot.index))
	      display.viewTo += lendiff
	    } else {
	      resetView(cm)
	    }
	  }
	
	  var ext = display.externalMeasured
	  if (ext) {
	    if (to < ext.lineN)
	      { ext.lineN += lendiff }
	    else if (from < ext.lineN + ext.size)
	      { display.externalMeasured = null }
	  }
	}
	
	// Register a change to a single line. Type must be one of "text",
	// "gutter", "class", "widget"
	function regLineChange(cm, line, type) {
	  cm.curOp.viewChanged = true
	  var display = cm.display, ext = cm.display.externalMeasured
	  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
	    { display.externalMeasured = null }
	
	  if (line < display.viewFrom || line >= display.viewTo) { return }
	  var lineView = display.view[findViewIndex(cm, line)]
	  if (lineView.node == null) { return }
	  var arr = lineView.changes || (lineView.changes = [])
	  if (indexOf(arr, type) == -1) { arr.push(type) }
	}
	
	// Clear the view.
	function resetView(cm) {
	  cm.display.viewFrom = cm.display.viewTo = cm.doc.first
	  cm.display.view = []
	  cm.display.viewOffset = 0
	}
	
	function viewCuttingPoint(cm, oldN, newN, dir) {
	  var index = findViewIndex(cm, oldN), diff, view = cm.display.view
	  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
	    { return {index: index, lineN: newN} }
	  var n = cm.display.viewFrom
	  for (var i = 0; i < index; i++)
	    { n += view[i].size }
	  if (n != oldN) {
	    if (dir > 0) {
	      if (index == view.length - 1) { return null }
	      diff = (n + view[index].size) - oldN
	      index++
	    } else {
	      diff = n - oldN
	    }
	    oldN += diff; newN += diff
	  }
	  while (visualLineNo(cm.doc, newN) != newN) {
	    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
	    newN += dir * view[index - (dir < 0 ? 1 : 0)].size
	    index += dir
	  }
	  return {index: index, lineN: newN}
	}
	
	// Force the view to cover a given range, adding empty view element
	// or clipping off existing ones as needed.
	function adjustView(cm, from, to) {
	  var display = cm.display, view = display.view
	  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
	    display.view = buildViewArray(cm, from, to)
	    display.viewFrom = from
	  } else {
	    if (display.viewFrom > from)
	      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view) }
	    else if (display.viewFrom < from)
	      { display.view = display.view.slice(findViewIndex(cm, from)) }
	    display.viewFrom = from
	    if (display.viewTo < to)
	      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)) }
	    else if (display.viewTo > to)
	      { display.view = display.view.slice(0, findViewIndex(cm, to)) }
	  }
	  display.viewTo = to
	}
	
	// Count the number of lines in the view whose DOM representation is
	// out of date (or nonexistent).
	function countDirtyView(cm) {
	  var view = cm.display.view, dirty = 0
	  for (var i = 0; i < view.length; i++) {
	    var lineView = view[i]
	    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty }
	  }
	  return dirty
	}
	
	// HIGHLIGHT WORKER
	
	function startWorker(cm, time) {
	  if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
	    { cm.state.highlight.set(time, bind(highlightWorker, cm)) }
	}
	
	function highlightWorker(cm) {
	  var doc = cm.doc
	  if (doc.frontier < doc.first) { doc.frontier = doc.first }
	  if (doc.frontier >= cm.display.viewTo) { return }
	  var end = +new Date + cm.options.workTime
	  var state = copyState(doc.mode, getStateBefore(cm, doc.frontier))
	  var changedLines = []
	
	  doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
	    if (doc.frontier >= cm.display.viewFrom) { // Visible
	      var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength
	      var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true)
	      line.styles = highlighted.styles
	      var oldCls = line.styleClasses, newCls = highlighted.classes
	      if (newCls) { line.styleClasses = newCls }
	      else if (oldCls) { line.styleClasses = null }
	      var ischange = !oldStyles || oldStyles.length != line.styles.length ||
	        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass)
	      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i] }
	      if (ischange) { changedLines.push(doc.frontier) }
	      line.stateAfter = tooLong ? state : copyState(doc.mode, state)
	    } else {
	      if (line.text.length <= cm.options.maxHighlightLength)
	        { processLine(cm, line.text, state) }
	      line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null
	    }
	    ++doc.frontier
	    if (+new Date > end) {
	      startWorker(cm, cm.options.workDelay)
	      return true
	    }
	  })
	  if (changedLines.length) { runInOp(cm, function () {
	    for (var i = 0; i < changedLines.length; i++)
	      { regLineChange(cm, changedLines[i], "text") }
	  }) }
	}
	
	// DISPLAY DRAWING
	
	var DisplayUpdate = function(cm, viewport, force) {
	  var display = cm.display
	
	  this.viewport = viewport
	  // Store some values that we'll need later (but don't want to force a relayout for)
	  this.visible = visibleLines(display, cm.doc, viewport)
	  this.editorIsHidden = !display.wrapper.offsetWidth
	  this.wrapperHeight = display.wrapper.clientHeight
	  this.wrapperWidth = display.wrapper.clientWidth
	  this.oldDisplayWidth = displayWidth(cm)
	  this.force = force
	  this.dims = getDimensions(cm)
	  this.events = []
	};
	
	DisplayUpdate.prototype.signal = function (emitter, type) {
	  if (hasHandler(emitter, type))
	    { this.events.push(arguments) }
	};
	DisplayUpdate.prototype.finish = function () {
	    var this$1 = this;
	
	  for (var i = 0; i < this.events.length; i++)
	    { signal.apply(null, this$1.events[i]) }
	};
	
	function maybeClipScrollbars(cm) {
	  var display = cm.display
	  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
	    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth
	    display.heightForcer.style.height = scrollGap(cm) + "px"
	    display.sizer.style.marginBottom = -display.nativeBarWidth + "px"
	    display.sizer.style.borderRightWidth = scrollGap(cm) + "px"
	    display.scrollbarsClipped = true
	  }
	}
	
	// Does the actual updating of the line display. Bails out
	// (returning false) when there is nothing to be done and forced is
	// false.
	function updateDisplayIfNeeded(cm, update) {
	  var display = cm.display, doc = cm.doc
	
	  if (update.editorIsHidden) {
	    resetView(cm)
	    return false
	  }
	
	  // Bail out if the visible area is already rendered and nothing changed.
	  if (!update.force &&
	      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
	      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
	      display.renderedView == display.view && countDirtyView(cm) == 0)
	    { return false }
	
	  if (maybeUpdateLineNumberWidth(cm)) {
	    resetView(cm)
	    update.dims = getDimensions(cm)
	  }
	
	  // Compute a suitable new viewport (from & to)
	  var end = doc.first + doc.size
	  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first)
	  var to = Math.min(end, update.visible.to + cm.options.viewportMargin)
	  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom) }
	  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo) }
	  if (sawCollapsedSpans) {
	    from = visualLineNo(cm.doc, from)
	    to = visualLineEndNo(cm.doc, to)
	  }
	
	  var different = from != display.viewFrom || to != display.viewTo ||
	    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth
	  adjustView(cm, from, to)
	
	  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom))
	  // Position the mover div to align with the current scroll position
	  cm.display.mover.style.top = display.viewOffset + "px"
	
	  var toUpdate = countDirtyView(cm)
	  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
	      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
	    { return false }
	
	  // For big changes, we hide the enclosing element during the
	  // update, since that speeds up the operations on most browsers.
	  var focused = activeElt()
	  if (toUpdate > 4) { display.lineDiv.style.display = "none" }
	  patchDisplay(cm, display.updateLineNumbers, update.dims)
	  if (toUpdate > 4) { display.lineDiv.style.display = "" }
	  display.renderedView = display.view
	  // There might have been a widget with a focused element that got
	  // hidden or updated, if so re-focus it.
	  if (focused && activeElt() != focused && focused.offsetHeight) { focused.focus() }
	
	  // Prevent selection and cursors from interfering with the scroll
	  // width and height.
	  removeChildren(display.cursorDiv)
	  removeChildren(display.selectionDiv)
	  display.gutters.style.height = display.sizer.style.minHeight = 0
	
	  if (different) {
	    display.lastWrapHeight = update.wrapperHeight
	    display.lastWrapWidth = update.wrapperWidth
	    startWorker(cm, 400)
	  }
	
	  display.updateLineNumbers = null
	
	  return true
	}
	
	function postUpdateDisplay(cm, update) {
	  var viewport = update.viewport
	
	  for (var first = true;; first = false) {
	    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
	      // Clip forced viewport to actual scrollable area.
	      if (viewport && viewport.top != null)
	        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)} }
	      // Updated line heights might result in the drawn area not
	      // actually covering the viewport. Keep looping until it does.
	      update.visible = visibleLines(cm.display, cm.doc, viewport)
	      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
	        { break }
	    }
	    if (!updateDisplayIfNeeded(cm, update)) { break }
	    updateHeightsInViewport(cm)
	    var barMeasure = measureForScrollbars(cm)
	    updateSelection(cm)
	    updateScrollbars(cm, barMeasure)
	    setDocumentHeight(cm, barMeasure)
	  }
	
	  update.signal(cm, "update", cm)
	  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
	    update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo)
	    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo
	  }
	}
	
	function updateDisplaySimple(cm, viewport) {
	  var update = new DisplayUpdate(cm, viewport)
	  if (updateDisplayIfNeeded(cm, update)) {
	    updateHeightsInViewport(cm)
	    postUpdateDisplay(cm, update)
	    var barMeasure = measureForScrollbars(cm)
	    updateSelection(cm)
	    updateScrollbars(cm, barMeasure)
	    setDocumentHeight(cm, barMeasure)
	    update.finish()
	  }
	}
	
	// Sync the actual display DOM structure with display.view, removing
	// nodes for lines that are no longer in view, and creating the ones
	// that are not there yet, and updating the ones that are out of
	// date.
	function patchDisplay(cm, updateNumbersFrom, dims) {
	  var display = cm.display, lineNumbers = cm.options.lineNumbers
	  var container = display.lineDiv, cur = container.firstChild
	
	  function rm(node) {
	    var next = node.nextSibling
	    // Works around a throw-scroll bug in OS X Webkit
	    if (webkit && mac && cm.display.currentWheelTarget == node)
	      { node.style.display = "none" }
	    else
	      { node.remove() }
	    return next
	  }
	
	  var view = display.view, lineN = display.viewFrom
	  // Loop over the elements in the view, syncing cur (the DOM nodes
	  // in display.lineDiv) with the view as we go.
	  for (var i = 0; i < view.length; i++) {
	    var lineView = view[i]
	    if (lineView.hidden) {
	    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
	      var node = buildLineElement(cm, lineView, lineN, dims)
	      container.insertBefore(node, cur)
	    } else { // Already drawn
	      while (cur != lineView.node) { cur = rm(cur) }
	      var updateNumber = lineNumbers && updateNumbersFrom != null &&
	        updateNumbersFrom <= lineN && lineView.lineNumber
	      if (lineView.changes) {
	        if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false }
	        updateLineForChanges(cm, lineView, lineN, dims)
	      }
	      if (updateNumber) {
	        removeChildren(lineView.lineNumber)
	        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)))
	      }
	      cur = lineView.node.nextSibling
	    }
	    lineN += lineView.size
	  }
	  while (cur) { cur = rm(cur) }
	}
	
	function updateGutterSpace(cm) {
	  var width = cm.display.gutters.offsetWidth
	  cm.display.sizer.style.marginLeft = width + "px"
	}
	
	function setDocumentHeight(cm, measure) {
	  cm.display.sizer.style.minHeight = measure.docHeight + "px"
	  cm.display.heightForcer.style.top = measure.docHeight + "px"
	  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px"
	}
	
	// Rebuild the gutter elements, ensure the margin to the left of the
	// code matches their width.
	function updateGutters(cm) {
	  var gutters = cm.display.gutters, specs = cm.options.gutters
	  removeChildren(gutters)
	  var i = 0
	  for (; i < specs.length; ++i) {
	    var gutterClass = specs[i]
	    var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass))
	    if (gutterClass == "CodeMirror-linenumbers") {
	      cm.display.lineGutter = gElt
	      gElt.style.width = (cm.display.lineNumWidth || 1) + "px"
	    }
	  }
	  gutters.style.display = i ? "" : "none"
	  updateGutterSpace(cm)
	}
	
	// Make sure the gutters options contains the element
	// "CodeMirror-linenumbers" when the lineNumbers option is true.
	function setGuttersForLineNumbers(options) {
	  var found = indexOf(options.gutters, "CodeMirror-linenumbers")
	  if (found == -1 && options.lineNumbers) {
	    options.gutters = options.gutters.concat(["CodeMirror-linenumbers"])
	  } else if (found > -1 && !options.lineNumbers) {
	    options.gutters = options.gutters.slice(0)
	    options.gutters.splice(found, 1)
	  }
	}
	
	// Selection objects are immutable. A new one is created every time
	// the selection changes. A selection is one or more non-overlapping
	// (and non-touching) ranges, sorted, and an integer that indicates
	// which one is the primary selection (the one that's scrolled into
	// view, that getCursor returns, etc).
	function Selection(ranges, primIndex) {
	  this.ranges = ranges
	  this.primIndex = primIndex
	}
	
	Selection.prototype = {
	  primary: function() { return this.ranges[this.primIndex] },
	  equals: function(other) {
	    var this$1 = this;
	
	    if (other == this) { return true }
	    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
	    for (var i = 0; i < this.ranges.length; i++) {
	      var here = this$1.ranges[i], there = other.ranges[i]
	      if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) { return false }
	    }
	    return true
	  },
	  deepCopy: function() {
	    var this$1 = this;
	
	    var out = []
	    for (var i = 0; i < this.ranges.length; i++)
	      { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)) }
	    return new Selection(out, this.primIndex)
	  },
	  somethingSelected: function() {
	    var this$1 = this;
	
	    for (var i = 0; i < this.ranges.length; i++)
	      { if (!this$1.ranges[i].empty()) { return true } }
	    return false
	  },
	  contains: function(pos, end) {
	    var this$1 = this;
	
	    if (!end) { end = pos }
	    for (var i = 0; i < this.ranges.length; i++) {
	      var range = this$1.ranges[i]
	      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
	        { return i }
	    }
	    return -1
	  }
	}
	
	function Range(anchor, head) {
	  this.anchor = anchor; this.head = head
	}
	
	Range.prototype = {
	  from: function() { return minPos(this.anchor, this.head) },
	  to: function() { return maxPos(this.anchor, this.head) },
	  empty: function() {
	    return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch
	  }
	}
	
	// Take an unsorted, potentially overlapping set of ranges, and
	// build a selection out of it. 'Consumes' ranges array (modifying
	// it).
	function normalizeSelection(ranges, primIndex) {
	  var prim = ranges[primIndex]
	  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); })
	  primIndex = indexOf(ranges, prim)
	  for (var i = 1; i < ranges.length; i++) {
	    var cur = ranges[i], prev = ranges[i - 1]
	    if (cmp(prev.to(), cur.from()) >= 0) {
	      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to())
	      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head
	      if (i <= primIndex) { --primIndex }
	      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to))
	    }
	  }
	  return new Selection(ranges, primIndex)
	}
	
	function simpleSelection(anchor, head) {
	  return new Selection([new Range(anchor, head || anchor)], 0)
	}
	
	// Compute the position of the end of a change (its 'to' property
	// refers to the pre-change end).
	function changeEnd(change) {
	  if (!change.text) { return change.to }
	  return Pos(change.from.line + change.text.length - 1,
	             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
	}
	
	// Adjust a position to refer to the post-change position of the
	// same text, or the end of the change if the change covers it.
	function adjustForChange(pos, change) {
	  if (cmp(pos, change.from) < 0) { return pos }
	  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }
	
	  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch
	  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch }
	  return Pos(line, ch)
	}
	
	function computeSelAfterChange(doc, change) {
	  var out = []
	  for (var i = 0; i < doc.sel.ranges.length; i++) {
	    var range = doc.sel.ranges[i]
	    out.push(new Range(adjustForChange(range.anchor, change),
	                       adjustForChange(range.head, change)))
	  }
	  return normalizeSelection(out, doc.sel.primIndex)
	}
	
	function offsetPos(pos, old, nw) {
	  if (pos.line == old.line)
	    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
	  else
	    { return Pos(nw.line + (pos.line - old.line), pos.ch) }
	}
	
	// Used by replaceSelections to allow moving the selection to the
	// start or around the replaced test. Hint may be "start" or "around".
	function computeReplacedSel(doc, changes, hint) {
	  var out = []
	  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev
	  for (var i = 0; i < changes.length; i++) {
	    var change = changes[i]
	    var from = offsetPos(change.from, oldPrev, newPrev)
	    var to = offsetPos(changeEnd(change), oldPrev, newPrev)
	    oldPrev = change.to
	    newPrev = to
	    if (hint == "around") {
	      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0
	      out[i] = new Range(inv ? to : from, inv ? from : to)
	    } else {
	      out[i] = new Range(from, from)
	    }
	  }
	  return new Selection(out, doc.sel.primIndex)
	}
	
	// Used to get the editor into a consistent state again when options change.
	
	function loadMode(cm) {
	  cm.doc.mode = getMode(cm.options, cm.doc.modeOption)
	  resetModeState(cm)
	}
	
	function resetModeState(cm) {
	  cm.doc.iter(function (line) {
	    if (line.stateAfter) { line.stateAfter = null }
	    if (line.styles) { line.styles = null }
	  })
	  cm.doc.frontier = cm.doc.first
	  startWorker(cm, 100)
	  cm.state.modeGen++
	  if (cm.curOp) { regChange(cm) }
	}
	
	// DOCUMENT DATA STRUCTURE
	
	// By default, updates that start and end at the beginning of a line
	// are treated specially, in order to make the association of line
	// widgets and marker elements with the text behave more intuitive.
	function isWholeLineUpdate(doc, change) {
	  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
	    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
	}
	
	// Perform a change on the document data structure.
	function updateDoc(doc, change, markedSpans, estimateHeight) {
	  function spansFor(n) {return markedSpans ? markedSpans[n] : null}
	  function update(line, text, spans) {
	    updateLine(line, text, spans, estimateHeight)
	    signalLater(line, "change", line, change)
	  }
	  function linesFor(start, end) {
	    var result = []
	    for (var i = start; i < end; ++i)
	      { result.push(new Line(text[i], spansFor(i), estimateHeight)) }
	    return result
	  }
	
	  var from = change.from, to = change.to, text = change.text
	  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line)
	  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line
	
	  // Adjust the line structure
	  if (change.full) {
	    doc.insert(0, linesFor(0, text.length))
	    doc.remove(text.length, doc.size - text.length)
	  } else if (isWholeLineUpdate(doc, change)) {
	    // This is a whole-line replace. Treated specially to make
	    // sure line objects move the way they are supposed to.
	    var added = linesFor(0, text.length - 1)
	    update(lastLine, lastLine.text, lastSpans)
	    if (nlines) { doc.remove(from.line, nlines) }
	    if (added.length) { doc.insert(from.line, added) }
	  } else if (firstLine == lastLine) {
	    if (text.length == 1) {
	      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans)
	    } else {
	      var added$1 = linesFor(1, text.length - 1)
	      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight))
	      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0))
	      doc.insert(from.line + 1, added$1)
	    }
	  } else if (text.length == 1) {
	    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0))
	    doc.remove(from.line + 1, nlines)
	  } else {
	    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0))
	    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans)
	    var added$2 = linesFor(1, text.length - 1)
	    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1) }
	    doc.insert(from.line + 1, added$2)
	  }
	
	  signalLater(doc, "change", doc, change)
	}
	
	// Call f for all linked documents.
	function linkedDocs(doc, f, sharedHistOnly) {
	  function propagate(doc, skip, sharedHist) {
	    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
	      var rel = doc.linked[i]
	      if (rel.doc == skip) { continue }
	      var shared = sharedHist && rel.sharedHist
	      if (sharedHistOnly && !shared) { continue }
	      f(rel.doc, shared)
	      propagate(rel.doc, doc, shared)
	    } }
	  }
	  propagate(doc, null, true)
	}
	
	// Attach a document to an editor.
	function attachDoc(cm, doc) {
	  if (doc.cm) { throw new Error("This document is already in use.") }
	  cm.doc = doc
	  doc.cm = cm
	  estimateLineHeights(cm)
	  loadMode(cm)
	  if (!cm.options.lineWrapping) { findMaxLine(cm) }
	  cm.options.mode = doc.modeOption
	  regChange(cm)
	}
	
	function History(startGen) {
	  // Arrays of change events and selections. Doing something adds an
	  // event to done and clears undo. Undoing moves events from done
	  // to undone, redoing moves them in the other direction.
	  this.done = []; this.undone = []
	  this.undoDepth = Infinity
	  // Used to track when changes can be merged into a single undo
	  // event
	  this.lastModTime = this.lastSelTime = 0
	  this.lastOp = this.lastSelOp = null
	  this.lastOrigin = this.lastSelOrigin = null
	  // Used by the isClean() method
	  this.generation = this.maxGeneration = startGen || 1
	}
	
	// Create a history change event from an updateDoc-style change
	// object.
	function historyChangeFromChange(doc, change) {
	  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)}
	  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1)
	  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true)
	  return histChange
	}
	
	// Pop all selection events off the end of a history array. Stop at
	// a change event.
	function clearSelectionEvents(array) {
	  while (array.length) {
	    var last = lst(array)
	    if (last.ranges) { array.pop() }
	    else { break }
	  }
	}
	
	// Find the top change event in the history. Pop off selection
	// events that are in the way.
	function lastChangeEvent(hist, force) {
	  if (force) {
	    clearSelectionEvents(hist.done)
	    return lst(hist.done)
	  } else if (hist.done.length && !lst(hist.done).ranges) {
	    return lst(hist.done)
	  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
	    hist.done.pop()
	    return lst(hist.done)
	  }
	}
	
	// Register a change in the history. Merges changes that are within
	// a single operation, or are close together with an origin that
	// allows merging (starting with "+") into a single event.
	function addChangeToHistory(doc, change, selAfter, opId) {
	  var hist = doc.history
	  hist.undone.length = 0
	  var time = +new Date, cur
	  var last
	
	  if ((hist.lastOp == opId ||
	       hist.lastOrigin == change.origin && change.origin &&
	       ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||
	        change.origin.charAt(0) == "*")) &&
	      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
	    // Merge this change into the last event
	    last = lst(cur.changes)
	    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
	      // Optimized case for simple insertion -- don't want to add
	      // new changesets for every character typed
	      last.to = changeEnd(change)
	    } else {
	      // Add new sub-event
	      cur.changes.push(historyChangeFromChange(doc, change))
	    }
	  } else {
	    // Can not be merged, start a new event.
	    var before = lst(hist.done)
	    if (!before || !before.ranges)
	      { pushSelectionToHistory(doc.sel, hist.done) }
	    cur = {changes: [historyChangeFromChange(doc, change)],
	           generation: hist.generation}
	    hist.done.push(cur)
	    while (hist.done.length > hist.undoDepth) {
	      hist.done.shift()
	      if (!hist.done[0].ranges) { hist.done.shift() }
	    }
	  }
	  hist.done.push(selAfter)
	  hist.generation = ++hist.maxGeneration
	  hist.lastModTime = hist.lastSelTime = time
	  hist.lastOp = hist.lastSelOp = opId
	  hist.lastOrigin = hist.lastSelOrigin = change.origin
	
	  if (!last) { signal(doc, "historyAdded") }
	}
	
	function selectionEventCanBeMerged(doc, origin, prev, sel) {
	  var ch = origin.charAt(0)
	  return ch == "*" ||
	    ch == "+" &&
	    prev.ranges.length == sel.ranges.length &&
	    prev.somethingSelected() == sel.somethingSelected() &&
	    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
	}
	
	// Called whenever the selection changes, sets the new selection as
	// the pending selection in the history, and pushes the old pending
	// selection into the 'done' array when it was significantly
	// different (in number of selected ranges, emptiness, or time).
	function addSelectionToHistory(doc, sel, opId, options) {
	  var hist = doc.history, origin = options && options.origin
	
	  // A new event is started when the previous origin does not match
	  // the current, or the origins don't allow matching. Origins
	  // starting with * are always merged, those starting with + are
	  // merged when similar and close together in time.
	  if (opId == hist.lastSelOp ||
	      (origin && hist.lastSelOrigin == origin &&
	       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
	        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
	    { hist.done[hist.done.length - 1] = sel }
	  else
	    { pushSelectionToHistory(sel, hist.done) }
	
	  hist.lastSelTime = +new Date
	  hist.lastSelOrigin = origin
	  hist.lastSelOp = opId
	  if (options && options.clearRedo !== false)
	    { clearSelectionEvents(hist.undone) }
	}
	
	function pushSelectionToHistory(sel, dest) {
	  var top = lst(dest)
	  if (!(top && top.ranges && top.equals(sel)))
	    { dest.push(sel) }
	}
	
	// Used to store marked span information in the history.
	function attachLocalSpans(doc, change, from, to) {
	  var existing = change["spans_" + doc.id], n = 0
	  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
	    if (line.markedSpans)
	      { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans }
	    ++n
	  })
	}
	
	// When un/re-doing restores text containing marked spans, those
	// that have been explicitly cleared should not be restored.
	function removeClearedSpans(spans) {
	  if (!spans) { return null }
	  var out
	  for (var i = 0; i < spans.length; ++i) {
	    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i) } }
	    else if (out) { out.push(spans[i]) }
	  }
	  return !out ? spans : out.length ? out : null
	}
	
	// Retrieve and filter the old marked spans stored in a change event.
	function getOldSpans(doc, change) {
	  var found = change["spans_" + doc.id]
	  if (!found) { return null }
	  var nw = []
	  for (var i = 0; i < change.text.length; ++i)
	    { nw.push(removeClearedSpans(found[i])) }
	  return nw
	}
	
	// Used for un/re-doing changes from the history. Combines the
	// result of computing the existing spans with the set of spans that
	// existed in the history (so that deleting around a span and then
	// undoing brings back the span).
	function mergeOldSpans(doc, change) {
	  var old = getOldSpans(doc, change)
	  var stretched = stretchSpansOverChange(doc, change)
	  if (!old) { return stretched }
	  if (!stretched) { return old }
	
	  for (var i = 0; i < old.length; ++i) {
	    var oldCur = old[i], stretchCur = stretched[i]
	    if (oldCur && stretchCur) {
	      spans: for (var j = 0; j < stretchCur.length; ++j) {
	        var span = stretchCur[j]
	        for (var k = 0; k < oldCur.length; ++k)
	          { if (oldCur[k].marker == span.marker) { continue spans } }
	        oldCur.push(span)
	      }
	    } else if (stretchCur) {
	      old[i] = stretchCur
	    }
	  }
	  return old
	}
	
	// Used both to provide a JSON-safe object in .getHistory, and, when
	// detaching a document, to split the history in two
	function copyHistoryArray(events, newGroup, instantiateSel) {
	  var copy = []
	  for (var i = 0; i < events.length; ++i) {
	    var event = events[i]
	    if (event.ranges) {
	      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event)
	      continue
	    }
	    var changes = event.changes, newChanges = []
	    copy.push({changes: newChanges})
	    for (var j = 0; j < changes.length; ++j) {
	      var change = changes[j], m = (void 0)
	      newChanges.push({from: change.from, to: change.to, text: change.text})
	      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
	        if (indexOf(newGroup, Number(m[1])) > -1) {
	          lst(newChanges)[prop] = change[prop]
	          delete change[prop]
	        }
	      } } }
	    }
	  }
	  return copy
	}
	
	// The 'scroll' parameter given to many of these indicated whether
	// the new cursor position should be scrolled into view after
	// modifying the selection.
	
	// If shift is held or the extend flag is set, extends a range to
	// include a given position (and optionally a second position).
	// Otherwise, simply returns the range between the given positions.
	// Used for cursor motion and such.
	function extendRange(doc, range, head, other) {
	  if (doc.cm && doc.cm.display.shift || doc.extend) {
	    var anchor = range.anchor
	    if (other) {
	      var posBefore = cmp(head, anchor) < 0
	      if (posBefore != (cmp(other, anchor) < 0)) {
	        anchor = head
	        head = other
	      } else if (posBefore != (cmp(head, other) < 0)) {
	        head = other
	      }
	    }
	    return new Range(anchor, head)
	  } else {
	    return new Range(other || head, head)
	  }
	}
	
	// Extend the primary selection range, discard the rest.
	function extendSelection(doc, head, other, options) {
	  setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options)
	}
	
	// Extend all selections (pos is an array of selections with length
	// equal the number of selections)
	function extendSelections(doc, heads, options) {
	  var out = []
	  for (var i = 0; i < doc.sel.ranges.length; i++)
	    { out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null) }
	  var newSel = normalizeSelection(out, doc.sel.primIndex)
	  setSelection(doc, newSel, options)
	}
	
	// Updates a single range in the selection.
	function replaceOneSelection(doc, i, range, options) {
	  var ranges = doc.sel.ranges.slice(0)
	  ranges[i] = range
	  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options)
	}
	
	// Reset the selection to a single range.
	function setSimpleSelection(doc, anchor, head, options) {
	  setSelection(doc, simpleSelection(anchor, head), options)
	}
	
	// Give beforeSelectionChange handlers a change to influence a
	// selection update.
	function filterSelectionChange(doc, sel, options) {
	  var obj = {
	    ranges: sel.ranges,
	    update: function(ranges) {
	      var this$1 = this;
	
	      this.ranges = []
	      for (var i = 0; i < ranges.length; i++)
	        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
	                                   clipPos(doc, ranges[i].head)) }
	    },
	    origin: options && options.origin
	  }
	  signal(doc, "beforeSelectionChange", doc, obj)
	  if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj) }
	  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }
	  else { return sel }
	}
	
	function setSelectionReplaceHistory(doc, sel, options) {
	  var done = doc.history.done, last = lst(done)
	  if (last && last.ranges) {
	    done[done.length - 1] = sel
	    setSelectionNoUndo(doc, sel, options)
	  } else {
	    setSelection(doc, sel, options)
	  }
	}
	
	// Set a new selection.
	function setSelection(doc, sel, options) {
	  setSelectionNoUndo(doc, sel, options)
	  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options)
	}
	
	function setSelectionNoUndo(doc, sel, options) {
	  if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
	    { sel = filterSelectionChange(doc, sel, options) }
	
	  var bias = options && options.bias ||
	    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1)
	  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true))
	
	  if (!(options && options.scroll === false) && doc.cm)
	    { ensureCursorVisible(doc.cm) }
	}
	
	function setSelectionInner(doc, sel) {
	  if (sel.equals(doc.sel)) { return }
	
	  doc.sel = sel
	
	  if (doc.cm) {
	    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true
	    signalCursorActivity(doc.cm)
	  }
	  signalLater(doc, "cursorActivity", doc)
	}
	
	// Verify that the selection does not partially select any atomic
	// marked ranges.
	function reCheckSelection(doc) {
	  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll)
	}
	
	// Return a selection that does not partially select any atomic
	// ranges.
	function skipAtomicInSelection(doc, sel, bias, mayClear) {
	  var out
	  for (var i = 0; i < sel.ranges.length; i++) {
	    var range = sel.ranges[i]
	    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i]
	    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear)
	    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear)
	    if (out || newAnchor != range.anchor || newHead != range.head) {
	      if (!out) { out = sel.ranges.slice(0, i) }
	      out[i] = new Range(newAnchor, newHead)
	    }
	  }
	  return out ? normalizeSelection(out, sel.primIndex) : sel
	}
	
	function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
	  var line = getLine(doc, pos.line)
	  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
	    var sp = line.markedSpans[i], m = sp.marker
	    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
	        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
	      if (mayClear) {
	        signal(m, "beforeCursorEnter")
	        if (m.explicitlyCleared) {
	          if (!line.markedSpans) { break }
	          else {--i; continue}
	        }
	      }
	      if (!m.atomic) { continue }
	
	      if (oldPos) {
	        var near = m.find(dir < 0 ? 1 : -1), diff = (void 0)
	        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)
	          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null) }
	        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
	          { return skipAtomicInner(doc, near, pos, dir, mayClear) }
	      }
	
	      var far = m.find(dir < 0 ? -1 : 1)
	      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)
	        { far = movePos(doc, far, dir, far.line == pos.line ? line : null) }
	      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
	    }
	  } }
	  return pos
	}
	
	// Ensure a given position is not inside an atomic range.
	function skipAtomic(doc, pos, oldPos, bias, mayClear) {
	  var dir = bias || 1
	  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
	      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
	      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
	      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true))
	  if (!found) {
	    doc.cantEdit = true
	    return Pos(doc.first, 0)
	  }
	  return found
	}
	
	function movePos(doc, pos, dir, line) {
	  if (dir < 0 && pos.ch == 0) {
	    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
	    else { return null }
	  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
	    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
	    else { return null }
	  } else {
	    return new Pos(pos.line, pos.ch + dir)
	  }
	}
	
	function selectAll(cm) {
	  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll)
	}
	
	// UPDATING
	
	// Allow "beforeChange" event handlers to influence a change
	function filterChange(doc, change, update) {
	  var obj = {
	    canceled: false,
	    from: change.from,
	    to: change.to,
	    text: change.text,
	    origin: change.origin,
	    cancel: function () { return obj.canceled = true; }
	  }
	  if (update) { obj.update = function (from, to, text, origin) {
	    if (from) { obj.from = clipPos(doc, from) }
	    if (to) { obj.to = clipPos(doc, to) }
	    if (text) { obj.text = text }
	    if (origin !== undefined) { obj.origin = origin }
	  } }
	  signal(doc, "beforeChange", doc, obj)
	  if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj) }
	
	  if (obj.canceled) { return null }
	  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
	}
	
	// Apply a change to a document, and add it to the document's
	// history, and propagating it to all linked documents.
	function makeChange(doc, change, ignoreReadOnly) {
	  if (doc.cm) {
	    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
	    if (doc.cm.state.suppressEdits) { return }
	  }
	
	  if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
	    change = filterChange(doc, change, true)
	    if (!change) { return }
	  }
	
	  // Possibly split or suppress the update based on the presence
	  // of read-only spans in its range.
	  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to)
	  if (split) {
	    for (var i = split.length - 1; i >= 0; --i)
	      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text}) }
	  } else {
	    makeChangeInner(doc, change)
	  }
	}
	
	function makeChangeInner(doc, change) {
	  if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
	  var selAfter = computeSelAfterChange(doc, change)
	  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN)
	
	  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change))
	  var rebased = []
	
	  linkedDocs(doc, function (doc, sharedHist) {
	    if (!sharedHist && indexOf(rebased, doc.history) == -1) {
	      rebaseHist(doc.history, change)
	      rebased.push(doc.history)
	    }
	    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change))
	  })
	}
	
	// Revert a change stored in a document's history.
	function makeChangeFromHistory(doc, type, allowSelectionOnly) {
	  if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) { return }
	
	  var hist = doc.history, event, selAfter = doc.sel
	  var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done
	
	  // Verify that there is a useable event (so that ctrl-z won't
	  // needlessly clear selection events)
	  var i = 0
	  for (; i < source.length; i++) {
	    event = source[i]
	    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
	      { break }
	  }
	  if (i == source.length) { return }
	  hist.lastOrigin = hist.lastSelOrigin = null
	
	  for (;;) {
	    event = source.pop()
	    if (event.ranges) {
	      pushSelectionToHistory(event, dest)
	      if (allowSelectionOnly && !event.equals(doc.sel)) {
	        setSelection(doc, event, {clearRedo: false})
	        return
	      }
	      selAfter = event
	    }
	    else { break }
	  }
	
	  // Build up a reverse change object to add to the opposite history
	  // stack (redo when undoing, and vice versa).
	  var antiChanges = []
	  pushSelectionToHistory(selAfter, dest)
	  dest.push({changes: antiChanges, generation: hist.generation})
	  hist.generation = event.generation || ++hist.maxGeneration
	
	  var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")
	
	  var loop = function ( i ) {
	    var change = event.changes[i]
	    change.origin = type
	    if (filter && !filterChange(doc, change, false)) {
	      source.length = 0
	      return {}
	    }
	
	    antiChanges.push(historyChangeFromChange(doc, change))
	
	    var after = i ? computeSelAfterChange(doc, change) : lst(source)
	    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change))
	    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}) }
	    var rebased = []
	
	    // Propagate to the linked documents
	    linkedDocs(doc, function (doc, sharedHist) {
	      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
	        rebaseHist(doc.history, change)
	        rebased.push(doc.history)
	      }
	      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change))
	    })
	  };
	
	  for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
	    var returned = loop( i$1 );
	
	    if ( returned ) return returned.v;
	  }
	}
	
	// Sub-views need their line numbers shifted when text is added
	// above or below them in the parent document.
	function shiftDoc(doc, distance) {
	  if (distance == 0) { return }
	  doc.first += distance
	  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
	    Pos(range.anchor.line + distance, range.anchor.ch),
	    Pos(range.head.line + distance, range.head.ch)
	  ); }), doc.sel.primIndex)
	  if (doc.cm) {
	    regChange(doc.cm, doc.first, doc.first - distance, distance)
	    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
	      { regLineChange(doc.cm, l, "gutter") }
	  }
	}
	
	// More lower-level change function, handling only a single document
	// (not linked ones).
	function makeChangeSingleDoc(doc, change, selAfter, spans) {
	  if (doc.cm && !doc.cm.curOp)
	    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }
	
	  if (change.to.line < doc.first) {
	    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line))
	    return
	  }
	  if (change.from.line > doc.lastLine()) { return }
	
	  // Clip the change to the size of this doc
	  if (change.from.line < doc.first) {
	    var shift = change.text.length - 1 - (doc.first - change.from.line)
	    shiftDoc(doc, shift)
	    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
	              text: [lst(change.text)], origin: change.origin}
	  }
	  var last = doc.lastLine()
	  if (change.to.line > last) {
	    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
	              text: [change.text[0]], origin: change.origin}
	  }
	
	  change.removed = getBetween(doc, change.from, change.to)
	
	  if (!selAfter) { selAfter = computeSelAfterChange(doc, change) }
	  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans) }
	  else { updateDoc(doc, change, spans) }
	  setSelectionNoUndo(doc, selAfter, sel_dontScroll)
	}
	
	// Handle the interaction of a change to a document with the editor
	// that this document is part of.
	function makeChangeSingleDocInEditor(cm, change, spans) {
	  var doc = cm.doc, display = cm.display, from = change.from, to = change.to
	
	  var recomputeMaxLength = false, checkWidthStart = from.line
	  if (!cm.options.lineWrapping) {
	    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)))
	    doc.iter(checkWidthStart, to.line + 1, function (line) {
	      if (line == display.maxLine) {
	        recomputeMaxLength = true
	        return true
	      }
	    })
	  }
	
	  if (doc.sel.contains(change.from, change.to) > -1)
	    { signalCursorActivity(cm) }
	
	  updateDoc(doc, change, spans, estimateHeight(cm))
	
	  if (!cm.options.lineWrapping) {
	    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
	      var len = lineLength(line)
	      if (len > display.maxLineLength) {
	        display.maxLine = line
	        display.maxLineLength = len
	        display.maxLineChanged = true
	        recomputeMaxLength = false
	      }
	    })
	    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true }
	  }
	
	  // Adjust frontier, schedule worker
	  doc.frontier = Math.min(doc.frontier, from.line)
	  startWorker(cm, 400)
	
	  var lendiff = change.text.length - (to.line - from.line) - 1
	  // Remember that these lines changed, for updating the display
	  if (change.full)
	    { regChange(cm) }
	  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
	    { regLineChange(cm, from.line, "text") }
	  else
	    { regChange(cm, from.line, to.line + 1, lendiff) }
	
	  var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change")
	  if (changeHandler || changesHandler) {
	    var obj = {
	      from: from, to: to,
	      text: change.text,
	      removed: change.removed,
	      origin: change.origin
	    }
	    if (changeHandler) { signalLater(cm, "change", cm, obj) }
	    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj) }
	  }
	  cm.display.selForContextMenu = null
	}
	
	function replaceRange(doc, code, from, to, origin) {
	  if (!to) { to = from }
	  if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp }
	  if (typeof code == "string") { code = doc.splitLines(code) }
	  makeChange(doc, {from: from, to: to, text: code, origin: origin})
	}
	
	// Rebasing/resetting history to deal with externally-sourced changes
	
	function rebaseHistSelSingle(pos, from, to, diff) {
	  if (to < pos.line) {
	    pos.line += diff
	  } else if (from < pos.line) {
	    pos.line = from
	    pos.ch = 0
	  }
	}
	
	// Tries to rebase an array of history events given a change in the
	// document. If the change touches the same lines as the event, the
	// event, and everything 'behind' it, is discarded. If the change is
	// before the event, the event's positions are updated. Uses a
	// copy-on-write scheme for the positions, to avoid having to
	// reallocate them all on every rebase, but also avoid problems with
	// shared position objects being unsafely updated.
	function rebaseHistArray(array, from, to, diff) {
	  for (var i = 0; i < array.length; ++i) {
	    var sub = array[i], ok = true
	    if (sub.ranges) {
	      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true }
	      for (var j = 0; j < sub.ranges.length; j++) {
	        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff)
	        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff)
	      }
	      continue
	    }
	    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
	      var cur = sub.changes[j$1]
	      if (to < cur.from.line) {
	        cur.from = Pos(cur.from.line + diff, cur.from.ch)
	        cur.to = Pos(cur.to.line + diff, cur.to.ch)
	      } else if (from <= cur.to.line) {
	        ok = false
	        break
	      }
	    }
	    if (!ok) {
	      array.splice(0, i + 1)
	      i = 0
	    }
	  }
	}
	
	function rebaseHist(hist, change) {
	  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1
	  rebaseHistArray(hist.done, from, to, diff)
	  rebaseHistArray(hist.undone, from, to, diff)
	}
	
	// Utility for applying a change to a line by handle or number,
	// returning the number and optionally registering the line as
	// changed.
	function changeLine(doc, handle, changeType, op) {
	  var no = handle, line = handle
	  if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)) }
	  else { no = lineNo(handle) }
	  if (no == null) { return null }
	  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType) }
	  return line
	}
	
	// The document is represented as a BTree consisting of leaves, with
	// chunk of lines in them, and branches, with up to ten leaves or
	// other branch nodes below them. The top node is always a branch
	// node, and is the document object itself (meaning it has
	// additional methods and properties).
	//
	// All nodes have parent links. The tree is used both to go from
	// line numbers to line objects, and to go from objects to numbers.
	// It also indexes by height, and is used to convert between height
	// and line object, and to find the total height of the document.
	//
	// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html
	
	function LeafChunk(lines) {
	  var this$1 = this;
	
	  this.lines = lines
	  this.parent = null
	  var height = 0
	  for (var i = 0; i < lines.length; ++i) {
	    lines[i].parent = this$1
	    height += lines[i].height
	  }
	  this.height = height
	}
	
	LeafChunk.prototype = {
	  chunkSize: function() { return this.lines.length },
	  // Remove the n lines at offset 'at'.
	  removeInner: function(at, n) {
	    var this$1 = this;
	
	    for (var i = at, e = at + n; i < e; ++i) {
	      var line = this$1.lines[i]
	      this$1.height -= line.height
	      cleanUpLine(line)
	      signalLater(line, "delete")
	    }
	    this.lines.splice(at, n)
	  },
	  // Helper used to collapse a small branch into a single leaf.
	  collapse: function(lines) {
	    lines.push.apply(lines, this.lines)
	  },
	  // Insert the given array of lines at offset 'at', count them as
	  // having the given height.
	  insertInner: function(at, lines, height) {
	    var this$1 = this;
	
	    this.height += height
	    this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at))
	    for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1 }
	  },
	  // Used to iterate over a part of the tree.
	  iterN: function(at, n, op) {
	    var this$1 = this;
	
	    for (var e = at + n; at < e; ++at)
	      { if (op(this$1.lines[at])) { return true } }
	  }
	}
	
	function BranchChunk(children) {
	  var this$1 = this;
	
	  this.children = children
	  var size = 0, height = 0
	  for (var i = 0; i < children.length; ++i) {
	    var ch = children[i]
	    size += ch.chunkSize(); height += ch.height
	    ch.parent = this$1
	  }
	  this.size = size
	  this.height = height
	  this.parent = null
	}
	
	BranchChunk.prototype = {
	  chunkSize: function() { return this.size },
	  removeInner: function(at, n) {
	    var this$1 = this;
	
	    this.size -= n
	    for (var i = 0; i < this.children.length; ++i) {
	      var child = this$1.children[i], sz = child.chunkSize()
	      if (at < sz) {
	        var rm = Math.min(n, sz - at), oldHeight = child.height
	        child.removeInner(at, rm)
	        this$1.height -= oldHeight - child.height
	        if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null }
	        if ((n -= rm) == 0) { break }
	        at = 0
	      } else { at -= sz }
	    }
	    // If the result is smaller than 25 lines, ensure that it is a
	    // single leaf node.
	    if (this.size - n < 25 &&
	        (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
	      var lines = []
	      this.collapse(lines)
	      this.children = [new LeafChunk(lines)]
	      this.children[0].parent = this
	    }
	  },
	  collapse: function(lines) {
	    var this$1 = this;
	
	    for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines) }
	  },
	  insertInner: function(at, lines, height) {
	    var this$1 = this;
	
	    this.size += lines.length
	    this.height += height
	    for (var i = 0; i < this.children.length; ++i) {
	      var child = this$1.children[i], sz = child.chunkSize()
	      if (at <= sz) {
	        child.insertInner(at, lines, height)
	        if (child.lines && child.lines.length > 50) {
	          // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
	          // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
	          var remaining = child.lines.length % 25 + 25
	          for (var pos = remaining; pos < child.lines.length;) {
	            var leaf = new LeafChunk(child.lines.slice(pos, pos += 25))
	            child.height -= leaf.height
	            this$1.children.splice(++i, 0, leaf)
	            leaf.parent = this$1
	          }
	          child.lines = child.lines.slice(0, remaining)
	          this$1.maybeSpill()
	        }
	        break
	      }
	      at -= sz
	    }
	  },
	  // When a node has grown, check whether it should be split.
	  maybeSpill: function() {
	    if (this.children.length <= 10) { return }
	    var me = this
	    do {
	      var spilled = me.children.splice(me.children.length - 5, 5)
	      var sibling = new BranchChunk(spilled)
	      if (!me.parent) { // Become the parent node
	        var copy = new BranchChunk(me.children)
	        copy.parent = me
	        me.children = [copy, sibling]
	        me = copy
	     } else {
	        me.size -= sibling.size
	        me.height -= sibling.height
	        var myIndex = indexOf(me.parent.children, me)
	        me.parent.children.splice(myIndex + 1, 0, sibling)
	      }
	      sibling.parent = me.parent
	    } while (me.children.length > 10)
	    me.parent.maybeSpill()
	  },
	  iterN: function(at, n, op) {
	    var this$1 = this;
	
	    for (var i = 0; i < this.children.length; ++i) {
	      var child = this$1.children[i], sz = child.chunkSize()
	      if (at < sz) {
	        var used = Math.min(n, sz - at)
	        if (child.iterN(at, used, op)) { return true }
	        if ((n -= used) == 0) { break }
	        at = 0
	      } else { at -= sz }
	    }
	  }
	}
	
	// Line widgets are block elements displayed above or below a line.
	
	function LineWidget(doc, node, options) {
	  var this$1 = this;
	
	  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
	    { this$1[opt] = options[opt] } } }
	  this.doc = doc
	  this.node = node
	}
	eventMixin(LineWidget)
	
	function adjustScrollWhenAboveVisible(cm, line, diff) {
	  if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
	    { addToScrollPos(cm, null, diff) }
	}
	
	LineWidget.prototype.clear = function() {
	  var this$1 = this;
	
	  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line)
	  if (no == null || !ws) { return }
	  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1) } }
	  if (!ws.length) { line.widgets = null }
	  var height = widgetHeight(this)
	  updateLineHeight(line, Math.max(0, line.height - height))
	  if (cm) { runInOp(cm, function () {
	    adjustScrollWhenAboveVisible(cm, line, -height)
	    regLineChange(cm, no, "widget")
	  }) }
	}
	LineWidget.prototype.changed = function() {
	  var oldH = this.height, cm = this.doc.cm, line = this.line
	  this.height = null
	  var diff = widgetHeight(this) - oldH
	  if (!diff) { return }
	  updateLineHeight(line, line.height + diff)
	  if (cm) { runInOp(cm, function () {
	    cm.curOp.forceUpdate = true
	    adjustScrollWhenAboveVisible(cm, line, diff)
	  }) }
	}
	
	function addLineWidget(doc, handle, node, options) {
	  var widget = new LineWidget(doc, node, options)
	  var cm = doc.cm
	  if (cm && widget.noHScroll) { cm.display.alignWidgets = true }
	  changeLine(doc, handle, "widget", function (line) {
	    var widgets = line.widgets || (line.widgets = [])
	    if (widget.insertAt == null) { widgets.push(widget) }
	    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget) }
	    widget.line = line
	    if (cm && !lineIsHidden(doc, line)) {
	      var aboveVisible = heightAtLine(line) < doc.scrollTop
	      updateLineHeight(line, line.height + widgetHeight(widget))
	      if (aboveVisible) { addToScrollPos(cm, null, widget.height) }
	      cm.curOp.forceUpdate = true
	    }
	    return true
	  })
	  return widget
	}
	
	// TEXTMARKERS
	
	// Created with markText and setBookmark methods. A TextMarker is a
	// handle that can be used to clear or find a marked position in the
	// document. Line objects hold arrays (markedSpans) containing
	// {from, to, marker} object pointing to such marker objects, and
	// indicating that such a marker is present on that line. Multiple
	// lines may point to the same marker when it spans across lines.
	// The spans will have null for their from/to properties when the
	// marker continues beyond the start/end of the line. Markers have
	// links back to the lines they currently touch.
	
	// Collapsed markers have unique ids, in order to be able to order
	// them, which is needed for uniquely determining an outer marker
	// when they overlap (they may nest, but not partially overlap).
	var nextMarkerId = 0
	
	function TextMarker(doc, type) {
	  this.lines = []
	  this.type = type
	  this.doc = doc
	  this.id = ++nextMarkerId
	}
	eventMixin(TextMarker)
	
	// Clear the marker.
	TextMarker.prototype.clear = function() {
	  var this$1 = this;
	
	  if (this.explicitlyCleared) { return }
	  var cm = this.doc.cm, withOp = cm && !cm.curOp
	  if (withOp) { startOperation(cm) }
	  if (hasHandler(this, "clear")) {
	    var found = this.find()
	    if (found) { signalLater(this, "clear", found.from, found.to) }
	  }
	  var min = null, max = null
	  for (var i = 0; i < this.lines.length; ++i) {
	    var line = this$1.lines[i]
	    var span = getMarkedSpanFor(line.markedSpans, this$1)
	    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), "text") }
	    else if (cm) {
	      if (span.to != null) { max = lineNo(line) }
	      if (span.from != null) { min = lineNo(line) }
	    }
	    line.markedSpans = removeMarkedSpan(line.markedSpans, span)
	    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)
	      { updateLineHeight(line, textHeight(cm.display)) }
	  }
	  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
	    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual)
	    if (len > cm.display.maxLineLength) {
	      cm.display.maxLine = visual
	      cm.display.maxLineLength = len
	      cm.display.maxLineChanged = true
	    }
	  } }
	
	  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1) }
	  this.lines.length = 0
	  this.explicitlyCleared = true
	  if (this.atomic && this.doc.cantEdit) {
	    this.doc.cantEdit = false
	    if (cm) { reCheckSelection(cm.doc) }
	  }
	  if (cm) { signalLater(cm, "markerCleared", cm, this) }
	  if (withOp) { endOperation(cm) }
	  if (this.parent) { this.parent.clear() }
	}
	
	// Find the position of the marker in the document. Returns a {from,
	// to} object by default. Side can be passed to get a specific side
	// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
	// Pos objects returned contain a line object, rather than a line
	// number (used to prevent looking up the same line twice).
	TextMarker.prototype.find = function(side, lineObj) {
	  var this$1 = this;
	
	  if (side == null && this.type == "bookmark") { side = 1 }
	  var from, to
	  for (var i = 0; i < this.lines.length; ++i) {
	    var line = this$1.lines[i]
	    var span = getMarkedSpanFor(line.markedSpans, this$1)
	    if (span.from != null) {
	      from = Pos(lineObj ? line : lineNo(line), span.from)
	      if (side == -1) { return from }
	    }
	    if (span.to != null) {
	      to = Pos(lineObj ? line : lineNo(line), span.to)
	      if (side == 1) { return to }
	    }
	  }
	  return from && {from: from, to: to}
	}
	
	// Signals that the marker's widget changed, and surrounding layout
	// should be recomputed.
	TextMarker.prototype.changed = function() {
	  var pos = this.find(-1, true), widget = this, cm = this.doc.cm
	  if (!pos || !cm) { return }
	  runInOp(cm, function () {
	    var line = pos.line, lineN = lineNo(pos.line)
	    var view = findViewForLine(cm, lineN)
	    if (view) {
	      clearLineMeasurementCacheFor(view)
	      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true
	    }
	    cm.curOp.updateMaxLine = true
	    if (!lineIsHidden(widget.doc, line) && widget.height != null) {
	      var oldHeight = widget.height
	      widget.height = null
	      var dHeight = widgetHeight(widget) - oldHeight
	      if (dHeight)
	        { updateLineHeight(line, line.height + dHeight) }
	    }
	  })
	}
	
	TextMarker.prototype.attachLine = function(line) {
	  if (!this.lines.length && this.doc.cm) {
	    var op = this.doc.cm.curOp
	    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
	      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this) }
	  }
	  this.lines.push(line)
	}
	TextMarker.prototype.detachLine = function(line) {
	  this.lines.splice(indexOf(this.lines, line), 1)
	  if (!this.lines.length && this.doc.cm) {
	    var op = this.doc.cm.curOp
	    ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this)
	  }
	}
	
	// Create a marker, wire it up to the right lines, and
	function markText(doc, from, to, options, type) {
	  // Shared markers (across linked documents) are handled separately
	  // (markTextShared will call out to this again, once per
	  // document).
	  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
	  // Ensure we are in an operation.
	  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }
	
	  var marker = new TextMarker(doc, type), diff = cmp(from, to)
	  if (options) { copyObj(options, marker, false) }
	  // Don't connect empty markers unless clearWhenEmpty is false
	  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
	    { return marker }
	  if (marker.replacedWith) {
	    // Showing up as a widget implies collapsed (widget replaces text)
	    marker.collapsed = true
	    marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget")
	    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true") }
	    if (options.insertLeft) { marker.widgetNode.insertLeft = true }
	  }
	  if (marker.collapsed) {
	    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
	        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
	      { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
	    seeCollapsedSpans()
	  }
	
	  if (marker.addToHistory)
	    { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN) }
	
	  var curLine = from.line, cm = doc.cm, updateMaxLine
	  doc.iter(curLine, to.line + 1, function (line) {
	    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
	      { updateMaxLine = true }
	    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0) }
	    addMarkedSpan(line, new MarkedSpan(marker,
	                                       curLine == from.line ? from.ch : null,
	                                       curLine == to.line ? to.ch : null))
	    ++curLine
	  })
	  // lineIsHidden depends on the presence of the spans, so needs a second pass
	  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
	    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0) }
	  }) }
	
	  if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }) }
	
	  if (marker.readOnly) {
	    seeReadOnlySpans()
	    if (doc.history.done.length || doc.history.undone.length)
	      { doc.clearHistory() }
	  }
	  if (marker.collapsed) {
	    marker.id = ++nextMarkerId
	    marker.atomic = true
	  }
	  if (cm) {
	    // Sync editor state
	    if (updateMaxLine) { cm.curOp.updateMaxLine = true }
	    if (marker.collapsed)
	      { regChange(cm, from.line, to.line + 1) }
	    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
	      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text") } }
	    if (marker.atomic) { reCheckSelection(cm.doc) }
	    signalLater(cm, "markerAdded", cm, marker)
	  }
	  return marker
	}
	
	// SHARED TEXTMARKERS
	
	// A shared marker spans multiple linked documents. It is
	// implemented as a meta-marker-object controlling multiple normal
	// markers.
	function SharedTextMarker(markers, primary) {
	  var this$1 = this;
	
	  this.markers = markers
	  this.primary = primary
	  for (var i = 0; i < markers.length; ++i)
	    { markers[i].parent = this$1 }
	}
	eventMixin(SharedTextMarker)
	
	SharedTextMarker.prototype.clear = function() {
	  var this$1 = this;
	
	  if (this.explicitlyCleared) { return }
	  this.explicitlyCleared = true
	  for (var i = 0; i < this.markers.length; ++i)
	    { this$1.markers[i].clear() }
	  signalLater(this, "clear")
	}
	SharedTextMarker.prototype.find = function(side, lineObj) {
	  return this.primary.find(side, lineObj)
	}
	
	function markTextShared(doc, from, to, options, type) {
	  options = copyObj(options)
	  options.shared = false
	  var markers = [markText(doc, from, to, options, type)], primary = markers[0]
	  var widget = options.widgetNode
	  linkedDocs(doc, function (doc) {
	    if (widget) { options.widgetNode = widget.cloneNode(true) }
	    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type))
	    for (var i = 0; i < doc.linked.length; ++i)
	      { if (doc.linked[i].isParent) { return } }
	    primary = lst(markers)
	  })
	  return new SharedTextMarker(markers, primary)
	}
	
	function findSharedMarkers(doc) {
	  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
	}
	
	function copySharedMarkers(doc, markers) {
	  for (var i = 0; i < markers.length; i++) {
	    var marker = markers[i], pos = marker.find()
	    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to)
	    if (cmp(mFrom, mTo)) {
	      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type)
	      marker.markers.push(subMark)
	      subMark.parent = marker
	    }
	  }
	}
	
	function detachSharedMarkers(markers) {
	  var loop = function ( i ) {
	    var marker = markers[i], linked = [marker.primary.doc]
	    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); })
	    for (var j = 0; j < marker.markers.length; j++) {
	      var subMarker = marker.markers[j]
	      if (indexOf(linked, subMarker.doc) == -1) {
	        subMarker.parent = null
	        marker.markers.splice(j--, 1)
	      }
	    }
	  };
	
	  for (var i = 0; i < markers.length; i++) loop( i );
	}
	
	var nextDocId = 0
	var Doc = function(text, mode, firstLine, lineSep) {
	  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep) }
	  if (firstLine == null) { firstLine = 0 }
	
	  BranchChunk.call(this, [new LeafChunk([new Line("", null)])])
	  this.first = firstLine
	  this.scrollTop = this.scrollLeft = 0
	  this.cantEdit = false
	  this.cleanGeneration = 1
	  this.frontier = firstLine
	  var start = Pos(firstLine, 0)
	  this.sel = simpleSelection(start)
	  this.history = new History(null)
	  this.id = ++nextDocId
	  this.modeOption = mode
	  this.lineSep = lineSep
	  this.extend = false
	
	  if (typeof text == "string") { text = this.splitLines(text) }
	  updateDoc(this, {from: start, to: start, text: text})
	  setSelection(this, simpleSelection(start), sel_dontScroll)
	}
	
	Doc.prototype = createObj(BranchChunk.prototype, {
	  constructor: Doc,
	  // Iterate over the document. Supports two forms -- with only one
	  // argument, it calls that for each line in the document. With
	  // three, it iterates over the range given by the first two (with
	  // the second being non-inclusive).
	  iter: function(from, to, op) {
	    if (op) { this.iterN(from - this.first, to - from, op) }
	    else { this.iterN(this.first, this.first + this.size, from) }
	  },
	
	  // Non-public interface for adding and removing lines.
	  insert: function(at, lines) {
	    var height = 0
	    for (var i = 0; i < lines.length; ++i) { height += lines[i].height }
	    this.insertInner(at - this.first, lines, height)
	  },
	  remove: function(at, n) { this.removeInner(at - this.first, n) },
	
	  // From here, the methods are part of the public interface. Most
	  // are also available from CodeMirror (editor) instances.
	
	  getValue: function(lineSep) {
	    var lines = getLines(this, this.first, this.first + this.size)
	    if (lineSep === false) { return lines }
	    return lines.join(lineSep || this.lineSeparator())
	  },
	  setValue: docMethodOp(function(code) {
	    var top = Pos(this.first, 0), last = this.first + this.size - 1
	    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
	                      text: this.splitLines(code), origin: "setValue", full: true}, true)
	    setSelection(this, simpleSelection(top))
	  }),
	  replaceRange: function(code, from, to, origin) {
	    from = clipPos(this, from)
	    to = to ? clipPos(this, to) : from
	    replaceRange(this, code, from, to, origin)
	  },
	  getRange: function(from, to, lineSep) {
	    var lines = getBetween(this, clipPos(this, from), clipPos(this, to))
	    if (lineSep === false) { return lines }
	    return lines.join(lineSep || this.lineSeparator())
	  },
	
	  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},
	
	  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
	  getLineNumber: function(line) {return lineNo(line)},
	
	  getLineHandleVisualStart: function(line) {
	    if (typeof line == "number") { line = getLine(this, line) }
	    return visualLine(line)
	  },
	
	  lineCount: function() {return this.size},
	  firstLine: function() {return this.first},
	  lastLine: function() {return this.first + this.size - 1},
	
	  clipPos: function(pos) {return clipPos(this, pos)},
	
	  getCursor: function(start) {
	    var range = this.sel.primary(), pos
	    if (start == null || start == "head") { pos = range.head }
	    else if (start == "anchor") { pos = range.anchor }
	    else if (start == "end" || start == "to" || start === false) { pos = range.to() }
	    else { pos = range.from() }
	    return pos
	  },
	  listSelections: function() { return this.sel.ranges },
	  somethingSelected: function() {return this.sel.somethingSelected()},
	
	  setCursor: docMethodOp(function(line, ch, options) {
	    setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options)
	  }),
	  setSelection: docMethodOp(function(anchor, head, options) {
	    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options)
	  }),
	  extendSelection: docMethodOp(function(head, other, options) {
	    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options)
	  }),
	  extendSelections: docMethodOp(function(heads, options) {
	    extendSelections(this, clipPosArray(this, heads), options)
	  }),
	  extendSelectionsBy: docMethodOp(function(f, options) {
	    var heads = map(this.sel.ranges, f)
	    extendSelections(this, clipPosArray(this, heads), options)
	  }),
	  setSelections: docMethodOp(function(ranges, primary, options) {
	    var this$1 = this;
	
	    if (!ranges.length) { return }
	    var out = []
	    for (var i = 0; i < ranges.length; i++)
	      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),
	                         clipPos(this$1, ranges[i].head)) }
	    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex) }
	    setSelection(this, normalizeSelection(out, primary), options)
	  }),
	  addSelection: docMethodOp(function(anchor, head, options) {
	    var ranges = this.sel.ranges.slice(0)
	    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)))
	    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options)
	  }),
	
	  getSelection: function(lineSep) {
	    var this$1 = this;
	
	    var ranges = this.sel.ranges, lines
	    for (var i = 0; i < ranges.length; i++) {
	      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to())
	      lines = lines ? lines.concat(sel) : sel
	    }
	    if (lineSep === false) { return lines }
	    else { return lines.join(lineSep || this.lineSeparator()) }
	  },
	  getSelections: function(lineSep) {
	    var this$1 = this;
	
	    var parts = [], ranges = this.sel.ranges
	    for (var i = 0; i < ranges.length; i++) {
	      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to())
	      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()) }
	      parts[i] = sel
	    }
	    return parts
	  },
	  replaceSelection: function(code, collapse, origin) {
	    var dup = []
	    for (var i = 0; i < this.sel.ranges.length; i++)
	      { dup[i] = code }
	    this.replaceSelections(dup, collapse, origin || "+input")
	  },
	  replaceSelections: docMethodOp(function(code, collapse, origin) {
	    var this$1 = this;
	
	    var changes = [], sel = this.sel
	    for (var i = 0; i < sel.ranges.length; i++) {
	      var range = sel.ranges[i]
	      changes[i] = {from: range.from(), to: range.to(), text: this$1.splitLines(code[i]), origin: origin}
	    }
	    var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse)
	    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
	      { makeChange(this$1, changes[i$1]) }
	    if (newSel) { setSelectionReplaceHistory(this, newSel) }
	    else if (this.cm) { ensureCursorVisible(this.cm) }
	  }),
	  undo: docMethodOp(function() {makeChangeFromHistory(this, "undo")}),
	  redo: docMethodOp(function() {makeChangeFromHistory(this, "redo")}),
	  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true)}),
	  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true)}),
	
	  setExtending: function(val) {this.extend = val},
	  getExtending: function() {return this.extend},
	
	  historySize: function() {
	    var hist = this.history, done = 0, undone = 0
	    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done } }
	    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone } }
	    return {undo: done, redo: undone}
	  },
	  clearHistory: function() {this.history = new History(this.history.maxGeneration)},
	
	  markClean: function() {
	    this.cleanGeneration = this.changeGeneration(true)
	  },
	  changeGeneration: function(forceSplit) {
	    if (forceSplit)
	      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null }
	    return this.history.generation
	  },
	  isClean: function (gen) {
	    return this.history.generation == (gen || this.cleanGeneration)
	  },
	
	  getHistory: function() {
	    return {done: copyHistoryArray(this.history.done),
	            undone: copyHistoryArray(this.history.undone)}
	  },
	  setHistory: function(histData) {
	    var hist = this.history = new History(this.history.maxGeneration)
	    hist.done = copyHistoryArray(histData.done.slice(0), null, true)
	    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true)
	  },
	
	  setGutterMarker: docMethodOp(function(line, gutterID, value) {
	    return changeLine(this, line, "gutter", function (line) {
	      var markers = line.gutterMarkers || (line.gutterMarkers = {})
	      markers[gutterID] = value
	      if (!value && isEmpty(markers)) { line.gutterMarkers = null }
	      return true
	    })
	  }),
	
	  clearGutter: docMethodOp(function(gutterID) {
	    var this$1 = this;
	
	    var i = this.first
	    this.iter(function (line) {
	      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
	        changeLine(this$1, line, "gutter", function () {
	          line.gutterMarkers[gutterID] = null
	          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null }
	          return true
	        })
	      }
	      ++i
	    })
	  }),
	
	  lineInfo: function(line) {
	    var n
	    if (typeof line == "number") {
	      if (!isLine(this, line)) { return null }
	      n = line
	      line = getLine(this, line)
	      if (!line) { return null }
	    } else {
	      n = lineNo(line)
	      if (n == null) { return null }
	    }
	    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
	            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
	            widgets: line.widgets}
	  },
	
	  addLineClass: docMethodOp(function(handle, where, cls) {
	    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
	      var prop = where == "text" ? "textClass"
	               : where == "background" ? "bgClass"
	               : where == "gutter" ? "gutterClass" : "wrapClass"
	      if (!line[prop]) { line[prop] = cls }
	      else if (classTest(cls).test(line[prop])) { return false }
	      else { line[prop] += " " + cls }
	      return true
	    })
	  }),
	  removeLineClass: docMethodOp(function(handle, where, cls) {
	    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
	      var prop = where == "text" ? "textClass"
	               : where == "background" ? "bgClass"
	               : where == "gutter" ? "gutterClass" : "wrapClass"
	      var cur = line[prop]
	      if (!cur) { return false }
	      else if (cls == null) { line[prop] = null }
	      else {
	        var found = cur.match(classTest(cls))
	        if (!found) { return false }
	        var end = found.index + found[0].length
	        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null
	      }
	      return true
	    })
	  }),
	
	  addLineWidget: docMethodOp(function(handle, node, options) {
	    return addLineWidget(this, handle, node, options)
	  }),
	  removeLineWidget: function(widget) { widget.clear() },
	
	  markText: function(from, to, options) {
	    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
	  },
	  setBookmark: function(pos, options) {
	    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
	                    insertLeft: options && options.insertLeft,
	                    clearWhenEmpty: false, shared: options && options.shared,
	                    handleMouseEvents: options && options.handleMouseEvents}
	    pos = clipPos(this, pos)
	    return markText(this, pos, pos, realOpts, "bookmark")
	  },
	  findMarksAt: function(pos) {
	    pos = clipPos(this, pos)
	    var markers = [], spans = getLine(this, pos.line).markedSpans
	    if (spans) { for (var i = 0; i < spans.length; ++i) {
	      var span = spans[i]
	      if ((span.from == null || span.from <= pos.ch) &&
	          (span.to == null || span.to >= pos.ch))
	        { markers.push(span.marker.parent || span.marker) }
	    } }
	    return markers
	  },
	  findMarks: function(from, to, filter) {
	    from = clipPos(this, from); to = clipPos(this, to)
	    var found = [], lineNo = from.line
	    this.iter(from.line, to.line + 1, function (line) {
	      var spans = line.markedSpans
	      if (spans) { for (var i = 0; i < spans.length; i++) {
	        var span = spans[i]
	        if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||
	              span.from == null && lineNo != from.line ||
	              span.from != null && lineNo == to.line && span.from >= to.ch) &&
	            (!filter || filter(span.marker)))
	          { found.push(span.marker.parent || span.marker) }
	      } }
	      ++lineNo
	    })
	    return found
	  },
	  getAllMarks: function() {
	    var markers = []
	    this.iter(function (line) {
	      var sps = line.markedSpans
	      if (sps) { for (var i = 0; i < sps.length; ++i)
	        { if (sps[i].from != null) { markers.push(sps[i].marker) } } }
	    })
	    return markers
	  },
	
	  posFromIndex: function(off) {
	    var ch, lineNo = this.first, sepSize = this.lineSeparator().length
	    this.iter(function (line) {
	      var sz = line.text.length + sepSize
	      if (sz > off) { ch = off; return true }
	      off -= sz
	      ++lineNo
	    })
	    return clipPos(this, Pos(lineNo, ch))
	  },
	  indexFromPos: function (coords) {
	    coords = clipPos(this, coords)
	    var index = coords.ch
	    if (coords.line < this.first || coords.ch < 0) { return 0 }
	    var sepSize = this.lineSeparator().length
	    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
	      index += line.text.length + sepSize
	    })
	    return index
	  },
	
	  copy: function(copyHistory) {
	    var doc = new Doc(getLines(this, this.first, this.first + this.size),
	                      this.modeOption, this.first, this.lineSep)
	    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft
	    doc.sel = this.sel
	    doc.extend = false
	    if (copyHistory) {
	      doc.history.undoDepth = this.history.undoDepth
	      doc.setHistory(this.getHistory())
	    }
	    return doc
	  },
	
	  linkedDoc: function(options) {
	    if (!options) { options = {} }
	    var from = this.first, to = this.first + this.size
	    if (options.from != null && options.from > from) { from = options.from }
	    if (options.to != null && options.to < to) { to = options.to }
	    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep)
	    if (options.sharedHist) { copy.history = this.history
	    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist})
	    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}]
	    copySharedMarkers(copy, findSharedMarkers(this))
	    return copy
	  },
	  unlinkDoc: function(other) {
	    var this$1 = this;
	
	    if (other instanceof CodeMirror) { other = other.doc }
	    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
	      var link = this$1.linked[i]
	      if (link.doc != other) { continue }
	      this$1.linked.splice(i, 1)
	      other.unlinkDoc(this$1)
	      detachSharedMarkers(findSharedMarkers(this$1))
	      break
	    } }
	    // If the histories were shared, split them again
	    if (other.history == this.history) {
	      var splitIds = [other.id]
	      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true)
	      other.history = new History(null)
	      other.history.done = copyHistoryArray(this.history.done, splitIds)
	      other.history.undone = copyHistoryArray(this.history.undone, splitIds)
	    }
	  },
	  iterLinkedDocs: function(f) {linkedDocs(this, f)},
	
	  getMode: function() {return this.mode},
	  getEditor: function() {return this.cm},
	
	  splitLines: function(str) {
	    if (this.lineSep) { return str.split(this.lineSep) }
	    return splitLinesAuto(str)
	  },
	  lineSeparator: function() { return this.lineSep || "\n" }
	})
	
	// Public alias.
	Doc.prototype.eachLine = Doc.prototype.iter
	
	// Kludge to work around strange IE behavior where it'll sometimes
	// re-fire a series of drag-related events right after the drop (#1551)
	var lastDrop = 0
	
	function onDrop(e) {
	  var cm = this
	  clearDragCursor(cm)
	  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
	    { return }
	  e_preventDefault(e)
	  if (ie) { lastDrop = +new Date }
	  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files
	  if (!pos || cm.isReadOnly()) { return }
	  // Might be a file drop, in which case we simply extract the text
	  // and insert it.
	  if (files && files.length && window.FileReader && window.File) {
	    var n = files.length, text = Array(n), read = 0
	    var loadFile = function (file, i) {
	      if (cm.options.allowDropFileTypes &&
	          indexOf(cm.options.allowDropFileTypes, file.type) == -1)
	        { return }
	
	      var reader = new FileReader
	      reader.onload = operation(cm, function () {
	        var content = reader.result
	        if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) { content = "" }
	        text[i] = content
	        if (++read == n) {
	          pos = clipPos(cm.doc, pos)
	          var change = {from: pos, to: pos,
	                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
	                        origin: "paste"}
	          makeChange(cm.doc, change)
	          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)))
	        }
	      })
	      reader.readAsText(file)
	    }
	    for (var i = 0; i < n; ++i) { loadFile(files[i], i) }
	  } else { // Normal drop
	    // Don't do a replace if the drop happened inside of the selected text.
	    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
	      cm.state.draggingText(e)
	      // Ensure the editor is re-focused
	      setTimeout(function () { return cm.display.input.focus(); }, 20)
	      return
	    }
	    try {
	      var text$1 = e.dataTransfer.getData("Text")
	      if (text$1) {
	        var selected
	        if (cm.state.draggingText && !cm.state.draggingText.copy)
	          { selected = cm.listSelections() }
	        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos))
	        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
	          { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag") } }
	        cm.replaceSelection(text$1, "around", "paste")
	        cm.display.input.focus()
	      }
	    }
	    catch(e){}
	  }
	}
	
	function onDragStart(cm, e) {
	  if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
	  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }
	
	  e.dataTransfer.setData("Text", cm.getSelection())
	  e.dataTransfer.effectAllowed = "copyMove"
	
	  // Use dummy image instead of default browsers image.
	  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
	  if (e.dataTransfer.setDragImage && !safari) {
	    var img = elt("img", null, null, "position: fixed; left: 0; top: 0;")
	    img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
	    if (presto) {
	      img.width = img.height = 1
	      cm.display.wrapper.appendChild(img)
	      // Force a relayout, or Opera won't use our image for some obscure reason
	      img._top = img.offsetTop
	    }
	    e.dataTransfer.setDragImage(img, 0, 0)
	    if (presto) { img.remove() }
	  }
	}
	
	function onDragOver(cm, e) {
	  var pos = posFromMouse(cm, e)
	  if (!pos) { return }
	  var frag = document.createDocumentFragment()
	  drawSelectionCursor(cm, pos, frag)
	  if (!cm.display.dragCursor) {
	    cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors")
	    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv)
	  }
	  removeChildrenAndAdd(cm.display.dragCursor, frag)
	}
	
	function clearDragCursor(cm) {
	  if (cm.display.dragCursor) {
	    cm.display.lineSpace.removeChild(cm.display.dragCursor)
	    cm.display.dragCursor = null
	  }
	}
	
	// These must be handled carefully, because naively registering a
	// handler for each editor will cause the editors to never be
	// garbage collected.
	
	function forEachCodeMirror(f) {
	  if (!document.body.getElementsByClassName) { return }
	  var byClass = document.body.getElementsByClassName("CodeMirror")
	  for (var i = 0; i < byClass.length; i++) {
	    var cm = byClass[i].CodeMirror
	    if (cm) { f(cm) }
	  }
	}
	
	var globalsRegistered = false
	function ensureGlobalHandlers() {
	  if (globalsRegistered) { return }
	  registerGlobalHandlers()
	  globalsRegistered = true
	}
	function registerGlobalHandlers() {
	  // When the window resizes, we need to refresh active editors.
	  var resizeTimer
	  on(window, "resize", function () {
	    if (resizeTimer == null) { resizeTimer = setTimeout(function () {
	      resizeTimer = null
	      forEachCodeMirror(onResize)
	    }, 100) }
	  })
	  // When the window loses focus, we want to show the editor as blurred
	  on(window, "blur", function () { return forEachCodeMirror(onBlur); })
	}
	// Called when the window resizes
	function onResize(cm) {
	  var d = cm.display
	  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
	    { return }
	  // Might be a text scaling operation, clear size caches.
	  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null
	  d.scrollbarsClipped = false
	  cm.setSize()
	}
	
	var keyNames = {
	  3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
	  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
	  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
	  46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
	  106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 127: "Delete",
	  173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
	  221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
	  63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
	}
	
	// Number keys
	for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i) }
	// Alphabetic keys
	for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1) }
	// Function keys
	for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2 }
	
	var keyMap = {}
	
	keyMap.basic = {
	  "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
	  "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
	  "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
	  "Tab": "defaultTab", "Shift-Tab": "indentAuto",
	  "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
	  "Esc": "singleSelection"
	}
	// Note that the save and find-related commands aren't defined by
	// default. User code or addons can define them. Unknown commands
	// are simply ignored.
	keyMap.pcDefault = {
	  "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
	  "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
	  "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
	  "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
	  "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
	  "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
	  "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
	  fallthrough: "basic"
	}
	// Very basic readline/emacs-style bindings, which are standard on Mac.
	keyMap.emacsy = {
	  "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
	  "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
	  "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
	  "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
	  "Ctrl-O": "openLine"
	}
	keyMap.macDefault = {
	  "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
	  "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
	  "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
	  "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
	  "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
	  "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
	  "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
	  fallthrough: ["basic", "emacsy"]
	}
	keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault
	
	// KEYMAP DISPATCH
	
	function normalizeKeyName(name) {
	  var parts = name.split(/-(?!$)/)
	  name = parts[parts.length - 1]
	  var alt, ctrl, shift, cmd
	  for (var i = 0; i < parts.length - 1; i++) {
	    var mod = parts[i]
	    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true }
	    else if (/^a(lt)?$/i.test(mod)) { alt = true }
	    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true }
	    else if (/^s(hift)?$/i.test(mod)) { shift = true }
	    else { throw new Error("Unrecognized modifier name: " + mod) }
	  }
	  if (alt) { name = "Alt-" + name }
	  if (ctrl) { name = "Ctrl-" + name }
	  if (cmd) { name = "Cmd-" + name }
	  if (shift) { name = "Shift-" + name }
	  return name
	}
	
	// This is a kludge to keep keymaps mostly working as raw objects
	// (backwards compatibility) while at the same time support features
	// like normalization and multi-stroke key bindings. It compiles a
	// new normalized keymap, and then updates the old object to reflect
	// this.
	function normalizeKeyMap(keymap) {
	  var copy = {}
	  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
	    var value = keymap[keyname]
	    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
	    if (value == "...") { delete keymap[keyname]; continue }
	
	    var keys = map(keyname.split(" "), normalizeKeyName)
	    for (var i = 0; i < keys.length; i++) {
	      var val = (void 0), name = (void 0)
	      if (i == keys.length - 1) {
	        name = keys.join(" ")
	        val = value
	      } else {
	        name = keys.slice(0, i + 1).join(" ")
	        val = "..."
	      }
	      var prev = copy[name]
	      if (!prev) { copy[name] = val }
	      else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
	    }
	    delete keymap[keyname]
	  } }
	  for (var prop in copy) { keymap[prop] = copy[prop] }
	  return keymap
	}
	
	function lookupKey(key, map, handle, context) {
	  map = getKeyMap(map)
	  var found = map.call ? map.call(key, context) : map[key]
	  if (found === false) { return "nothing" }
	  if (found === "...") { return "multi" }
	  if (found != null && handle(found)) { return "handled" }
	
	  if (map.fallthrough) {
	    if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
	      { return lookupKey(key, map.fallthrough, handle, context) }
	    for (var i = 0; i < map.fallthrough.length; i++) {
	      var result = lookupKey(key, map.fallthrough[i], handle, context)
	      if (result) { return result }
	    }
	  }
	}
	
	// Modifier key presses don't count as 'real' key presses for the
	// purpose of keymap fallthrough.
	function isModifierKey(value) {
	  var name = typeof value == "string" ? value : keyNames[value.keyCode]
	  return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
	}
	
	// Look up the name of a key as indicated by an event object.
	function keyName(event, noShift) {
	  if (presto && event.keyCode == 34 && event["char"]) { return false }
	  var base = keyNames[event.keyCode], name = base
	  if (name == null || event.altGraphKey) { return false }
	  if (event.altKey && base != "Alt") { name = "Alt-" + name }
	  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name }
	  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") { name = "Cmd-" + name }
	  if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name }
	  return name
	}
	
	function getKeyMap(val) {
	  return typeof val == "string" ? keyMap[val] : val
	}
	
	// Helper for deleting text near the selection(s), used to implement
	// backspace, delete, and similar functionality.
	function deleteNearSelection(cm, compute) {
	  var ranges = cm.doc.sel.ranges, kill = []
	  // Build up a set of ranges to kill first, merging overlapping
	  // ranges.
	  for (var i = 0; i < ranges.length; i++) {
	    var toKill = compute(ranges[i])
	    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
	      var replaced = kill.pop()
	      if (cmp(replaced.from, toKill.from) < 0) {
	        toKill.from = replaced.from
	        break
	      }
	    }
	    kill.push(toKill)
	  }
	  // Next, remove those actual ranges.
	  runInOp(cm, function () {
	    for (var i = kill.length - 1; i >= 0; i--)
	      { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete") }
	    ensureCursorVisible(cm)
	  })
	}
	
	// Commands are parameter-less actions that can be performed on an
	// editor, mostly used for keybindings.
	var commands = {
	  selectAll: selectAll,
	  singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
	  killLine: function (cm) { return deleteNearSelection(cm, function (range) {
	    if (range.empty()) {
	      var len = getLine(cm.doc, range.head.line).text.length
	      if (range.head.ch == len && range.head.line < cm.lastLine())
	        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
	      else
	        { return {from: range.head, to: Pos(range.head.line, len)} }
	    } else {
	      return {from: range.from(), to: range.to()}
	    }
	  }); },
	  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
	    from: Pos(range.from().line, 0),
	    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
	  }); }); },
	  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
	    from: Pos(range.from().line, 0), to: range.from()
	  }); }); },
	  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
	    var top = cm.charCoords(range.head, "div").top + 5
	    var leftPos = cm.coordsChar({left: 0, top: top}, "div")
	    return {from: leftPos, to: range.from()}
	  }); },
	  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
	    var top = cm.charCoords(range.head, "div").top + 5
	    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
	    return {from: range.from(), to: rightPos }
	  }); },
	  undo: function (cm) { return cm.undo(); },
	  redo: function (cm) { return cm.redo(); },
	  undoSelection: function (cm) { return cm.undoSelection(); },
	  redoSelection: function (cm) { return cm.redoSelection(); },
	  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
	  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
	  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
	    {origin: "+move", bias: 1}
	  ); },
	  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
	    {origin: "+move", bias: 1}
	  ); },
	  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
	    {origin: "+move", bias: -1}
	  ); },
	  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
	    var top = cm.charCoords(range.head, "div").top + 5
	    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
	  }, sel_move); },
	  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
	    var top = cm.charCoords(range.head, "div").top + 5
	    return cm.coordsChar({left: 0, top: top}, "div")
	  }, sel_move); },
	  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
	    var top = cm.charCoords(range.head, "div").top + 5
	    var pos = cm.coordsChar({left: 0, top: top}, "div")
	    if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
	    return pos
	  }, sel_move); },
	  goLineUp: function (cm) { return cm.moveV(-1, "line"); },
	  goLineDown: function (cm) { return cm.moveV(1, "line"); },
	  goPageUp: function (cm) { return cm.moveV(-1, "page"); },
	  goPageDown: function (cm) { return cm.moveV(1, "page"); },
	  goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
	  goCharRight: function (cm) { return cm.moveH(1, "char"); },
	  goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
	  goColumnRight: function (cm) { return cm.moveH(1, "column"); },
	  goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
	  goGroupRight: function (cm) { return cm.moveH(1, "group"); },
	  goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
	  goWordRight: function (cm) { return cm.moveH(1, "word"); },
	  delCharBefore: function (cm) { return cm.deleteH(-1, "char"); },
	  delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
	  delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
	  delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
	  delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
	  delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
	  indentAuto: function (cm) { return cm.indentSelection("smart"); },
	  indentMore: function (cm) { return cm.indentSelection("add"); },
	  indentLess: function (cm) { return cm.indentSelection("subtract"); },
	  insertTab: function (cm) { return cm.replaceSelection("\t"); },
	  insertSoftTab: function (cm) {
	    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize
	    for (var i = 0; i < ranges.length; i++) {
	      var pos = ranges[i].from()
	      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize)
	      spaces.push(spaceStr(tabSize - col % tabSize))
	    }
	    cm.replaceSelections(spaces)
	  },
	  defaultTab: function (cm) {
	    if (cm.somethingSelected()) { cm.indentSelection("add") }
	    else { cm.execCommand("insertTab") }
	  },
	  // Swap the two chars left and right of each selection's head.
	  // Move cursor behind the two swapped characters afterwards.
	  //
	  // Doesn't consider line feeds a character.
	  // Doesn't scan more than one line above to find a character.
	  // Doesn't do anything on an empty line.
	  // Doesn't do anything with non-empty selections.
	  transposeChars: function (cm) { return runInOp(cm, function () {
	    var ranges = cm.listSelections(), newSel = []
	    for (var i = 0; i < ranges.length; i++) {
	      if (!ranges[i].empty()) { continue }
	      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text
	      if (line) {
	        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1) }
	        if (cur.ch > 0) {
	          cur = new Pos(cur.line, cur.ch + 1)
	          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
	                          Pos(cur.line, cur.ch - 2), cur, "+transpose")
	        } else if (cur.line > cm.doc.first) {
	          var prev = getLine(cm.doc, cur.line - 1).text
	          if (prev) {
	            cur = new Pos(cur.line, 1)
	            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
	                            prev.charAt(prev.length - 1),
	                            Pos(cur.line - 1, prev.length - 1), cur, "+transpose")
	          }
	        }
	      }
	      newSel.push(new Range(cur, cur))
	    }
	    cm.setSelections(newSel)
	  }); },
	  newlineAndIndent: function (cm) { return runInOp(cm, function () {
	    var sels = cm.listSelections()
	    for (var i = sels.length - 1; i >= 0; i--)
	      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input") }
	    sels = cm.listSelections()
	    for (var i$1 = 0; i$1 < sels.length; i$1++)
	      { cm.indentLine(sels[i$1].from().line, null, true) }
	    ensureCursorVisible(cm)
	  }); },
	  openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
	  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
	}
	
	
	function lineStart(cm, lineN) {
	  var line = getLine(cm.doc, lineN)
	  var visual = visualLine(line)
	  if (visual != line) { lineN = lineNo(visual) }
	  var order = getOrder(visual)
	  var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual)
	  return Pos(lineN, ch)
	}
	function lineEnd(cm, lineN) {
	  var merged, line = getLine(cm.doc, lineN)
	  while (merged = collapsedSpanAtEnd(line)) {
	    line = merged.find(1, true).line
	    lineN = null
	  }
	  var order = getOrder(line)
	  var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line)
	  return Pos(lineN == null ? lineNo(line) : lineN, ch)
	}
	function lineStartSmart(cm, pos) {
	  var start = lineStart(cm, pos.line)
	  var line = getLine(cm.doc, start.line)
	  var order = getOrder(line)
	  if (!order || order[0].level == 0) {
	    var firstNonWS = Math.max(0, line.text.search(/\S/))
	    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch
	    return Pos(start.line, inWS ? 0 : firstNonWS)
	  }
	  return start
	}
	
	// Run a handler that was bound to a key.
	function doHandleBinding(cm, bound, dropShift) {
	  if (typeof bound == "string") {
	    bound = commands[bound]
	    if (!bound) { return false }
	  }
	  // Ensure previous input has been read, so that the handler sees a
	  // consistent view of the document
	  cm.display.input.ensurePolled()
	  var prevShift = cm.display.shift, done = false
	  try {
	    if (cm.isReadOnly()) { cm.state.suppressEdits = true }
	    if (dropShift) { cm.display.shift = false }
	    done = bound(cm) != Pass
	  } finally {
	    cm.display.shift = prevShift
	    cm.state.suppressEdits = false
	  }
	  return done
	}
	
	function lookupKeyForEditor(cm, name, handle) {
	  for (var i = 0; i < cm.state.keyMaps.length; i++) {
	    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm)
	    if (result) { return result }
	  }
	  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
	    || lookupKey(name, cm.options.keyMap, handle, cm)
	}
	
	var stopSeq = new Delayed
	function dispatchKey(cm, name, e, handle) {
	  var seq = cm.state.keySeq
	  if (seq) {
	    if (isModifierKey(name)) { return "handled" }
	    stopSeq.set(50, function () {
	      if (cm.state.keySeq == seq) {
	        cm.state.keySeq = null
	        cm.display.input.reset()
	      }
	    })
	    name = seq + " " + name
	  }
	  var result = lookupKeyForEditor(cm, name, handle)
	
	  if (result == "multi")
	    { cm.state.keySeq = name }
	  if (result == "handled")
	    { signalLater(cm, "keyHandled", cm, name, e) }
	
	  if (result == "handled" || result == "multi") {
	    e_preventDefault(e)
	    restartBlink(cm)
	  }
	
	  if (seq && !result && /\'$/.test(name)) {
	    e_preventDefault(e)
	    return true
	  }
	  return !!result
	}
	
	// Handle a key from the keydown event.
	function handleKeyBinding(cm, e) {
	  var name = keyName(e, true)
	  if (!name) { return false }
	
	  if (e.shiftKey && !cm.state.keySeq) {
	    // First try to resolve full name (including 'Shift-'). Failing
	    // that, see if there is a cursor-motion command (starting with
	    // 'go') bound to the keyname without 'Shift-'.
	    return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
	        || dispatchKey(cm, name, e, function (b) {
	             if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
	               { return doHandleBinding(cm, b) }
	           })
	  } else {
	    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
	  }
	}
	
	// Handle a key from the keypress event
	function handleCharBinding(cm, e, ch) {
	  return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
	}
	
	var lastStoppedKey = null
	function onKeyDown(e) {
	  var cm = this
	  cm.curOp.focus = activeElt()
	  if (signalDOMEvent(cm, e)) { return }
	  // IE does strange things with escape.
	  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false }
	  var code = e.keyCode
	  cm.display.shift = code == 16 || e.shiftKey
	  var handled = handleKeyBinding(cm, e)
	  if (presto) {
	    lastStoppedKey = handled ? code : null
	    // Opera has no cut event... we try to at least catch the key combo
	    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
	      { cm.replaceSelection("", null, "cut") }
	  }
	
	  // Turn mouse into crosshair when Alt is held on Mac.
	  if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
	    { showCrossHair(cm) }
	}
	
	function showCrossHair(cm) {
	  var lineDiv = cm.display.lineDiv
	  addClass(lineDiv, "CodeMirror-crosshair")
	
	  function up(e) {
	    if (e.keyCode == 18 || !e.altKey) {
	      rmClass(lineDiv, "CodeMirror-crosshair")
	      off(document, "keyup", up)
	      off(document, "mouseover", up)
	    }
	  }
	  on(document, "keyup", up)
	  on(document, "mouseover", up)
	}
	
	function onKeyUp(e) {
	  if (e.keyCode == 16) { this.doc.sel.shift = false }
	  signalDOMEvent(this, e)
	}
	
	function onKeyPress(e) {
	  var cm = this
	  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
	  var keyCode = e.keyCode, charCode = e.charCode
	  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
	  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
	  var ch = String.fromCharCode(charCode == null ? keyCode : charCode)
	  // Some browsers fire keypress events for backspace
	  if (ch == "\x08") { return }
	  if (handleCharBinding(cm, e, ch)) { return }
	  cm.display.input.onKeyPress(e)
	}
	
	// A mouse down can be a single click, double click, triple click,
	// start of selection drag, start of text drag, new cursor
	// (ctrl-click), rectangle drag (alt-drag), or xwin
	// middle-click-paste. Or it might be a click on something we should
	// not interfere with, such as a scrollbar or widget.
	function onMouseDown(e) {
	  var cm = this, display = cm.display
	  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
	  display.input.ensurePolled()
	  display.shift = e.shiftKey
	
	  if (eventInWidget(display, e)) {
	    if (!webkit) {
	      // Briefly turn off draggability, to allow widgets to do
	      // normal dragging things.
	      display.scroller.draggable = false
	      setTimeout(function () { return display.scroller.draggable = true; }, 100)
	    }
	    return
	  }
	  if (clickInGutter(cm, e)) { return }
	  var start = posFromMouse(cm, e)
	  window.focus()
	
	  switch (e_button(e)) {
	  case 1:
	    // #3261: make sure, that we're not starting a second selection
	    if (cm.state.selectingText)
	      { cm.state.selectingText(e) }
	    else if (start)
	      { leftButtonDown(cm, e, start) }
	    else if (e_target(e) == display.scroller)
	      { e_preventDefault(e) }
	    break
	  case 2:
	    if (webkit) { cm.state.lastMiddleDown = +new Date }
	    if (start) { extendSelection(cm.doc, start) }
	    setTimeout(function () { return display.input.focus(); }, 20)
	    e_preventDefault(e)
	    break
	  case 3:
	    if (captureRightClick) { onContextMenu(cm, e) }
	    else { delayBlurEvent(cm) }
	    break
	  }
	}
	
	var lastClick;
	var lastDoubleClick;
	function leftButtonDown(cm, e, start) {
	  if (ie) { setTimeout(bind(ensureFocus, cm), 0) }
	  else { cm.curOp.focus = activeElt() }
	
	  var now = +new Date, type
	  if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
	    type = "triple"
	  } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
	    type = "double"
	    lastDoubleClick = {time: now, pos: start}
	  } else {
	    type = "single"
	    lastClick = {time: now, pos: start}
	  }
	
	  var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained
	  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
	      type == "single" && (contained = sel.contains(start)) > -1 &&
	      (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&
	      (cmp(contained.to(), start) > 0 || start.xRel < 0))
	    { leftButtonStartDrag(cm, e, start, modifier) }
	  else
	    { leftButtonSelect(cm, e, start, type, modifier) }
	}
	
	// Start a text drag. When it ends, see if any dragging actually
	// happen, and treat as a click if it didn't.
	function leftButtonStartDrag(cm, e, start, modifier) {
	  var display = cm.display, startTime = +new Date
	  var dragEnd = operation(cm, function (e2) {
	    if (webkit) { display.scroller.draggable = false }
	    cm.state.draggingText = false
	    off(document, "mouseup", dragEnd)
	    off(display.scroller, "drop", dragEnd)
	    if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
	      e_preventDefault(e2)
	      if (!modifier && +new Date - 200 < startTime)
	        { extendSelection(cm.doc, start) }
	      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
	      if (webkit || ie && ie_version == 9)
	        { setTimeout(function () {document.body.focus(); display.input.focus()}, 20) }
	      else
	        { display.input.focus() }
	    }
	  })
	  // Let the drag handler handle this.
	  if (webkit) { display.scroller.draggable = true }
	  cm.state.draggingText = dragEnd
	  dragEnd.copy = mac ? e.altKey : e.ctrlKey
	  // IE's approach to draggable
	  if (display.scroller.dragDrop) { display.scroller.dragDrop() }
	  on(document, "mouseup", dragEnd)
	  on(display.scroller, "drop", dragEnd)
	}
	
	// Normal selection, as opposed to text dragging.
	function leftButtonSelect(cm, e, start, type, addNew) {
	  var display = cm.display, doc = cm.doc
	  e_preventDefault(e)
	
	  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges
	  if (addNew && !e.shiftKey) {
	    ourIndex = doc.sel.contains(start)
	    if (ourIndex > -1)
	      { ourRange = ranges[ourIndex] }
	    else
	      { ourRange = new Range(start, start) }
	  } else {
	    ourRange = doc.sel.primary()
	    ourIndex = doc.sel.primIndex
	  }
	
	  if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {
	    type = "rect"
	    if (!addNew) { ourRange = new Range(start, start) }
	    start = posFromMouse(cm, e, true, true)
	    ourIndex = -1
	  } else if (type == "double") {
	    var word = cm.findWordAt(start)
	    if (cm.display.shift || doc.extend)
	      { ourRange = extendRange(doc, ourRange, word.anchor, word.head) }
	    else
	      { ourRange = word }
	  } else if (type == "triple") {
	    var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)))
	    if (cm.display.shift || doc.extend)
	      { ourRange = extendRange(doc, ourRange, line.anchor, line.head) }
	    else
	      { ourRange = line }
	  } else {
	    ourRange = extendRange(doc, ourRange, start)
	  }
	
	  if (!addNew) {
	    ourIndex = 0
	    setSelection(doc, new Selection([ourRange], 0), sel_mouse)
	    startSel = doc.sel
	  } else if (ourIndex == -1) {
	    ourIndex = ranges.length
	    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
	                 {scroll: false, origin: "*mouse"})
	  } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == "single" && !e.shiftKey) {
	    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
	                 {scroll: false, origin: "*mouse"})
	    startSel = doc.sel
	  } else {
	    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse)
	  }
	
	  var lastPos = start
	  function extendTo(pos) {
	    if (cmp(lastPos, pos) == 0) { return }
	    lastPos = pos
	
	    if (type == "rect") {
	      var ranges = [], tabSize = cm.options.tabSize
	      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize)
	      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize)
	      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol)
	      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
	           line <= end; line++) {
	        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize)
	        if (left == right)
	          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))) }
	        else if (text.length > leftPos)
	          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))) }
	      }
	      if (!ranges.length) { ranges.push(new Range(start, start)) }
	      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
	                   {origin: "*mouse", scroll: false})
	      cm.scrollIntoView(pos)
	    } else {
	      var oldRange = ourRange
	      var anchor = oldRange.anchor, head = pos
	      if (type != "single") {
	        var range
	        if (type == "double")
	          { range = cm.findWordAt(pos) }
	        else
	          { range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0))) }
	        if (cmp(range.anchor, anchor) > 0) {
	          head = range.head
	          anchor = minPos(oldRange.from(), range.anchor)
	        } else {
	          head = range.anchor
	          anchor = maxPos(oldRange.to(), range.head)
	        }
	      }
	      var ranges$1 = startSel.ranges.slice(0)
	      ranges$1[ourIndex] = new Range(clipPos(doc, anchor), head)
	      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse)
	    }
	  }
	
	  var editorSize = display.wrapper.getBoundingClientRect()
	  // Used to ensure timeout re-tries don't fire when another extend
	  // happened in the meantime (clearTimeout isn't reliable -- at
	  // least on Chrome, the timeouts still happen even when cleared,
	  // if the clear happens after their scheduled firing time).
	  var counter = 0
	
	  function extend(e) {
	    var curCount = ++counter
	    var cur = posFromMouse(cm, e, true, type == "rect")
	    if (!cur) { return }
	    if (cmp(cur, lastPos) != 0) {
	      cm.curOp.focus = activeElt()
	      extendTo(cur)
	      var visible = visibleLines(display, doc)
	      if (cur.line >= visible.to || cur.line < visible.from)
	        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e) }}), 150) }
	    } else {
	      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0
	      if (outside) { setTimeout(operation(cm, function () {
	        if (counter != curCount) { return }
	        display.scroller.scrollTop += outside
	        extend(e)
	      }), 50) }
	    }
	  }
	
	  function done(e) {
	    cm.state.selectingText = false
	    counter = Infinity
	    e_preventDefault(e)
	    display.input.focus()
	    off(document, "mousemove", move)
	    off(document, "mouseup", up)
	    doc.history.lastSelOrigin = null
	  }
	
	  var move = operation(cm, function (e) {
	    if (!e_button(e)) { done(e) }
	    else { extend(e) }
	  })
	  var up = operation(cm, done)
	  cm.state.selectingText = up
	  on(document, "mousemove", move)
	  on(document, "mouseup", up)
	}
	
	
	// Determines whether an event happened in the gutter, and fires the
	// handlers for the corresponding event.
	function gutterEvent(cm, e, type, prevent) {
	  var mX, mY
	  try { mX = e.clientX; mY = e.clientY }
	  catch(e) { return false }
	  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
	  if (prevent) { e_preventDefault(e) }
	
	  var display = cm.display
	  var lineBox = display.lineDiv.getBoundingClientRect()
	
	  if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
	  mY -= lineBox.top - display.viewOffset
	
	  for (var i = 0; i < cm.options.gutters.length; ++i) {
	    var g = display.gutters.childNodes[i]
	    if (g && g.getBoundingClientRect().right >= mX) {
	      var line = lineAtHeight(cm.doc, mY)
	      var gutter = cm.options.gutters[i]
	      signal(cm, type, cm, line, gutter, e)
	      return e_defaultPrevented(e)
	    }
	  }
	}
	
	function clickInGutter(cm, e) {
	  return gutterEvent(cm, e, "gutterClick", true)
	}
	
	// CONTEXT MENU HANDLING
	
	// To make the context menu work, we need to briefly unhide the
	// textarea (making it as unobtrusive as possible) to let the
	// right-click take effect on it.
	function onContextMenu(cm, e) {
	  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
	  if (signalDOMEvent(cm, e, "contextmenu")) { return }
	  cm.display.input.onContextMenu(e)
	}
	
	function contextMenuInGutter(cm, e) {
	  if (!hasHandler(cm, "gutterContextMenu")) { return false }
	  return gutterEvent(cm, e, "gutterContextMenu", false)
	}
	
	function themeChanged(cm) {
	  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
	    cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-")
	  clearCaches(cm)
	}
	
	var Init = {toString: function(){return "CodeMirror.Init"}}
	
	var defaults = {}
	var optionHandlers = {}
	
	function defineOptions(CodeMirror) {
	  var optionHandlers = CodeMirror.optionHandlers
	
	  function option(name, deflt, handle, notOnInit) {
	    CodeMirror.defaults[name] = deflt
	    if (handle) { optionHandlers[name] =
	      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old) }} : handle }
	  }
	
	  CodeMirror.defineOption = option
	
	  // Passed to option handlers when there is no old value.
	  CodeMirror.Init = Init
	
	  // These two are, on init, called from the constructor because they
	  // have to be initialized before the editor can start at all.
	  option("value", "", function (cm, val) { return cm.setValue(val); }, true)
	  option("mode", null, function (cm, val) {
	    cm.doc.modeOption = val
	    loadMode(cm)
	  }, true)
	
	  option("indentUnit", 2, loadMode, true)
	  option("indentWithTabs", false)
	  option("smartIndent", true)
	  option("tabSize", 4, function (cm) {
	    resetModeState(cm)
	    clearCaches(cm)
	    regChange(cm)
	  }, true)
	  option("lineSeparator", null, function (cm, val) {
	    cm.doc.lineSep = val
	    if (!val) { return }
	    var newBreaks = [], lineNo = cm.doc.first
	    cm.doc.iter(function (line) {
	      for (var pos = 0;;) {
	        var found = line.text.indexOf(val, pos)
	        if (found == -1) { break }
	        pos = found + val.length
	        newBreaks.push(Pos(lineNo, found))
	      }
	      lineNo++
	    })
	    for (var i = newBreaks.length - 1; i >= 0; i--)
	      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)) }
	  })
	  option("specialChars", /[\u0000-\u001f\u007f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function (cm, val, old) {
	    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g")
	    if (old != Init) { cm.refresh() }
	  })
	  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true)
	  option("electricChars", true)
	  option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
	    throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
	  }, true)
	  option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true)
	  option("rtlMoveVisually", !windows)
	  option("wholeLineUpdateBefore", true)
	
	  option("theme", "default", function (cm) {
	    themeChanged(cm)
	    guttersChanged(cm)
	  }, true)
	  option("keyMap", "default", function (cm, val, old) {
	    var next = getKeyMap(val)
	    var prev = old != Init && getKeyMap(old)
	    if (prev && prev.detach) { prev.detach(cm, next) }
	    if (next.attach) { next.attach(cm, prev || null) }
	  })
	  option("extraKeys", null)
	
	  option("lineWrapping", false, wrappingChanged, true)
	  option("gutters", [], function (cm) {
	    setGuttersForLineNumbers(cm.options)
	    guttersChanged(cm)
	  }, true)
	  option("fixedGutter", true, function (cm, val) {
	    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0"
	    cm.refresh()
	  }, true)
	  option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true)
	  option("scrollbarStyle", "native", function (cm) {
	    initScrollbars(cm)
	    updateScrollbars(cm)
	    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop)
	    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft)
	  }, true)
	  option("lineNumbers", false, function (cm) {
	    setGuttersForLineNumbers(cm.options)
	    guttersChanged(cm)
	  }, true)
	  option("firstLineNumber", 1, guttersChanged, true)
	  option("lineNumberFormatter", function (integer) { return integer; }, guttersChanged, true)
	  option("showCursorWhenSelecting", false, updateSelection, true)
	
	  option("resetSelectionOnContextMenu", true)
	  option("lineWiseCopyCut", true)
	
	  option("readOnly", false, function (cm, val) {
	    if (val == "nocursor") {
	      onBlur(cm)
	      cm.display.input.blur()
	      cm.display.disabled = true
	    } else {
	      cm.display.disabled = false
	    }
	    cm.display.input.readOnlyChanged(val)
	  })
	  option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset() }}, true)
	  option("dragDrop", true, dragDropChanged)
	  option("allowDropFileTypes", null)
	
	  option("cursorBlinkRate", 530)
	  option("cursorScrollMargin", 0)
	  option("cursorHeight", 1, updateSelection, true)
	  option("singleCursorHeightPerLine", true, updateSelection, true)
	  option("workTime", 100)
	  option("workDelay", 100)
	  option("flattenSpans", true, resetModeState, true)
	  option("addModeClass", false, resetModeState, true)
	  option("pollInterval", 100)
	  option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; })
	  option("historyEventDelay", 1250)
	  option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true)
	  option("maxHighlightLength", 10000, resetModeState, true)
	  option("moveInputWithCursor", true, function (cm, val) {
	    if (!val) { cm.display.input.resetPosition() }
	  })
	
	  option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; })
	  option("autofocus", null)
	}
	
	function guttersChanged(cm) {
	  updateGutters(cm)
	  regChange(cm)
	  alignHorizontally(cm)
	}
	
	function dragDropChanged(cm, value, old) {
	  var wasOn = old && old != Init
	  if (!value != !wasOn) {
	    var funcs = cm.display.dragFunctions
	    var toggle = value ? on : off
	    toggle(cm.display.scroller, "dragstart", funcs.start)
	    toggle(cm.display.scroller, "dragenter", funcs.enter)
	    toggle(cm.display.scroller, "dragover", funcs.over)
	    toggle(cm.display.scroller, "dragleave", funcs.leave)
	    toggle(cm.display.scroller, "drop", funcs.drop)
	  }
	}
	
	function wrappingChanged(cm) {
	  if (cm.options.lineWrapping) {
	    addClass(cm.display.wrapper, "CodeMirror-wrap")
	    cm.display.sizer.style.minWidth = ""
	    cm.display.sizerWidth = null
	  } else {
	    rmClass(cm.display.wrapper, "CodeMirror-wrap")
	    findMaxLine(cm)
	  }
	  estimateLineHeights(cm)
	  regChange(cm)
	  clearCaches(cm)
	  setTimeout(function () { return updateScrollbars(cm); }, 100)
	}
	
	// A CodeMirror instance represents an editor. This is the object
	// that user code is usually dealing with.
	
	function CodeMirror(place, options) {
	  var this$1 = this;
	
	  if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }
	
	  this.options = options = options ? copyObj(options) : {}
	  // Determine effective options based on given values and defaults.
	  copyObj(defaults, options, false)
	  setGuttersForLineNumbers(options)
	
	  var doc = options.value
	  if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator) }
	  this.doc = doc
	
	  var input = new CodeMirror.inputStyles[options.inputStyle](this)
	  var display = this.display = new Display(place, doc, input)
	  display.wrapper.CodeMirror = this
	  updateGutters(this)
	  themeChanged(this)
	  if (options.lineWrapping)
	    { this.display.wrapper.className += " CodeMirror-wrap" }
	  initScrollbars(this)
	
	  this.state = {
	    keyMaps: [],  // stores maps added by addKeyMap
	    overlays: [], // highlighting overlays, as added by addOverlay
	    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
	    overwrite: false,
	    delayingBlurEvent: false,
	    focused: false,
	    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
	    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll
	    selectingText: false,
	    draggingText: false,
	    highlight: new Delayed(), // stores highlight worker timeout
	    keySeq: null,  // Unfinished key sequence
	    specialChars: null
	  }
	
	  if (options.autofocus && !mobile) { display.input.focus() }
	
	  // Override magic textarea content restore that IE sometimes does
	  // on our hidden textarea on reload
	  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20) }
	
	  registerEventHandlers(this)
	  ensureGlobalHandlers()
	
	  startOperation(this)
	  this.curOp.forceUpdate = true
	  attachDoc(this, doc)
	
	  if ((options.autofocus && !mobile) || this.hasFocus())
	    { setTimeout(bind(onFocus, this), 20) }
	  else
	    { onBlur(this) }
	
	  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
	    { optionHandlers[opt](this$1, options[opt], Init) } }
	  maybeUpdateLineNumberWidth(this)
	  if (options.finishInit) { options.finishInit(this) }
	  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1) }
	  endOperation(this)
	  // Suppress optimizelegibility in Webkit, since it breaks text
	  // measuring on line wrapping boundaries.
	  if (webkit && options.lineWrapping &&
	      getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
	    { display.lineDiv.style.textRendering = "auto" }
	}
	
	// The default configuration options.
	CodeMirror.defaults = defaults
	// Functions to run when options are changed.
	CodeMirror.optionHandlers = optionHandlers
	
	// Attach the necessary event handlers when initializing the editor
	function registerEventHandlers(cm) {
	  var d = cm.display
	  on(d.scroller, "mousedown", operation(cm, onMouseDown))
	  // Older IE's will not fire a second mousedown for a double click
	  if (ie && ie_version < 11)
	    { on(d.scroller, "dblclick", operation(cm, function (e) {
	      if (signalDOMEvent(cm, e)) { return }
	      var pos = posFromMouse(cm, e)
	      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
	      e_preventDefault(e)
	      var word = cm.findWordAt(pos)
	      extendSelection(cm.doc, word.anchor, word.head)
	    })) }
	  else
	    { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }) }
	  // Some browsers fire contextmenu *after* opening the menu, at
	  // which point we can't mess with it anymore. Context menu is
	  // handled in onMouseDown for these browsers.
	  if (!captureRightClick) { on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); }) }
	
	  // Used to suppress mouse event handling when a touch happens
	  var touchFinished, prevTouch = {end: 0}
	  function finishTouch() {
	    if (d.activeTouch) {
	      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000)
	      prevTouch = d.activeTouch
	      prevTouch.end = +new Date
	    }
	  }
	  function isMouseLikeTouchEvent(e) {
	    if (e.touches.length != 1) { return false }
	    var touch = e.touches[0]
	    return touch.radiusX <= 1 && touch.radiusY <= 1
	  }
	  function farAway(touch, other) {
	    if (other.left == null) { return true }
	    var dx = other.left - touch.left, dy = other.top - touch.top
	    return dx * dx + dy * dy > 20 * 20
	  }
	  on(d.scroller, "touchstart", function (e) {
	    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {
	      d.input.ensurePolled()
	      clearTimeout(touchFinished)
	      var now = +new Date
	      d.activeTouch = {start: now, moved: false,
	                       prev: now - prevTouch.end <= 300 ? prevTouch : null}
	      if (e.touches.length == 1) {
	        d.activeTouch.left = e.touches[0].pageX
	        d.activeTouch.top = e.touches[0].pageY
	      }
	    }
	  })
	  on(d.scroller, "touchmove", function () {
	    if (d.activeTouch) { d.activeTouch.moved = true }
	  })
	  on(d.scroller, "touchend", function (e) {
	    var touch = d.activeTouch
	    if (touch && !eventInWidget(d, e) && touch.left != null &&
	        !touch.moved && new Date - touch.start < 300) {
	      var pos = cm.coordsChar(d.activeTouch, "page"), range
	      if (!touch.prev || farAway(touch, touch.prev)) // Single tap
	        { range = new Range(pos, pos) }
	      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
	        { range = cm.findWordAt(pos) }
	      else // Triple tap
	        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
	      cm.setSelection(range.anchor, range.head)
	      cm.focus()
	      e_preventDefault(e)
	    }
	    finishTouch()
	  })
	  on(d.scroller, "touchcancel", finishTouch)
	
	  // Sync scrolling between fake scrollbars and real scrollable
	  // area, ensure viewport is updated when scrolling.
	  on(d.scroller, "scroll", function () {
	    if (d.scroller.clientHeight) {
	      setScrollTop(cm, d.scroller.scrollTop)
	      setScrollLeft(cm, d.scroller.scrollLeft, true)
	      signal(cm, "scroll", cm)
	    }
	  })
	
	  // Listen to wheel events in order to try and update the viewport on time.
	  on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); })
	  on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); })
	
	  // Prevent wrapper from ever scrolling
	  on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; })
	
	  d.dragFunctions = {
	    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e) }},
	    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e) }},
	    start: function (e) { return onDragStart(cm, e); },
	    drop: operation(cm, onDrop),
	    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm) }}
	  }
	
	  var inp = d.input.getField()
	  on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); })
	  on(inp, "keydown", operation(cm, onKeyDown))
	  on(inp, "keypress", operation(cm, onKeyPress))
	  on(inp, "focus", function (e) { return onFocus(cm, e); })
	  on(inp, "blur", function (e) { return onBlur(cm, e); })
	}
	
	var initHooks = []
	CodeMirror.defineInitHook = function (f) { return initHooks.push(f); }
	
	// Indent the given line. The how parameter can be "smart",
	// "add"/null, "subtract", or "prev". When aggressive is false
	// (typically set to true for forced single-line indents), empty
	// lines are not indented, and places where the mode returns Pass
	// are left alone.
	function indentLine(cm, n, how, aggressive) {
	  var doc = cm.doc, state
	  if (how == null) { how = "add" }
	  if (how == "smart") {
	    // Fall back to "prev" when the mode doesn't have an indentation
	    // method.
	    if (!doc.mode.indent) { how = "prev" }
	    else { state = getStateBefore(cm, n) }
	  }
	
	  var tabSize = cm.options.tabSize
	  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize)
	  if (line.stateAfter) { line.stateAfter = null }
	  var curSpaceString = line.text.match(/^\s*/)[0], indentation
	  if (!aggressive && !/\S/.test(line.text)) {
	    indentation = 0
	    how = "not"
	  } else if (how == "smart") {
	    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text)
	    if (indentation == Pass || indentation > 150) {
	      if (!aggressive) { return }
	      how = "prev"
	    }
	  }
	  if (how == "prev") {
	    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize) }
	    else { indentation = 0 }
	  } else if (how == "add") {
	    indentation = curSpace + cm.options.indentUnit
	  } else if (how == "subtract") {
	    indentation = curSpace - cm.options.indentUnit
	  } else if (typeof how == "number") {
	    indentation = curSpace + how
	  }
	  indentation = Math.max(0, indentation)
	
	  var indentString = "", pos = 0
	  if (cm.options.indentWithTabs)
	    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t"} }
	  if (pos < indentation) { indentString += spaceStr(indentation - pos) }
	
	  if (indentString != curSpaceString) {
	    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input")
	    line.stateAfter = null
	    return true
	  } else {
	    // Ensure that, if the cursor was in the whitespace at the start
	    // of the line, it is moved to the end of that space.
	    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
	      var range = doc.sel.ranges[i$1]
	      if (range.head.line == n && range.head.ch < curSpaceString.length) {
	        var pos$1 = Pos(n, curSpaceString.length)
	        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1))
	        break
	      }
	    }
	  }
	}
	
	// This will be set to a {lineWise: bool, text: [string]} object, so
	// that, when pasting, we know what kind of selections the copied
	// text was made out of.
	var lastCopied = null
	
	function setLastCopied(newLastCopied) {
	  lastCopied = newLastCopied
	}
	
	function applyTextInput(cm, inserted, deleted, sel, origin) {
	  var doc = cm.doc
	  cm.display.shift = false
	  if (!sel) { sel = doc.sel }
	
	  var paste = cm.state.pasteIncoming || origin == "paste"
	  var textLines = splitLinesAuto(inserted), multiPaste = null
	  // When pasing N lines into N selections, insert one line per selection
	  if (paste && sel.ranges.length > 1) {
	    if (lastCopied && lastCopied.text.join("\n") == inserted) {
	      if (sel.ranges.length % lastCopied.text.length == 0) {
	        multiPaste = []
	        for (var i = 0; i < lastCopied.text.length; i++)
	          { multiPaste.push(doc.splitLines(lastCopied.text[i])) }
	      }
	    } else if (textLines.length == sel.ranges.length) {
	      multiPaste = map(textLines, function (l) { return [l]; })
	    }
	  }
	
	  var updateInput
	  // Normal behavior is to insert the new text into every selection
	  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
	    var range = sel.ranges[i$1]
	    var from = range.from(), to = range.to()
	    if (range.empty()) {
	      if (deleted && deleted > 0) // Handle deletion
	        { from = Pos(from.line, from.ch - deleted) }
	      else if (cm.state.overwrite && !paste) // Handle overwrite
	        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)) }
	      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted)
	        { from = to = Pos(from.line, 0) }
	    }
	    updateInput = cm.curOp.updateInput
	    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
	                       origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")}
	    makeChange(cm.doc, changeEvent)
	    signalLater(cm, "inputRead", cm, changeEvent)
	  }
	  if (inserted && !paste)
	    { triggerElectric(cm, inserted) }
	
	  ensureCursorVisible(cm)
	  cm.curOp.updateInput = updateInput
	  cm.curOp.typing = true
	  cm.state.pasteIncoming = cm.state.cutIncoming = false
	}
	
	function handlePaste(e, cm) {
	  var pasted = e.clipboardData && e.clipboardData.getData("Text")
	  if (pasted) {
	    e.preventDefault()
	    if (!cm.isReadOnly() && !cm.options.disableInput)
	      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }) }
	    return true
	  }
	}
	
	function triggerElectric(cm, inserted) {
	  // When an 'electric' character is inserted, immediately trigger a reindent
	  if (!cm.options.electricChars || !cm.options.smartIndent) { return }
	  var sel = cm.doc.sel
	
	  for (var i = sel.ranges.length - 1; i >= 0; i--) {
	    var range = sel.ranges[i]
	    if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) { continue }
	    var mode = cm.getModeAt(range.head)
	    var indented = false
	    if (mode.electricChars) {
	      for (var j = 0; j < mode.electricChars.length; j++)
	        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
	          indented = indentLine(cm, range.head.line, "smart")
	          break
	        } }
	    } else if (mode.electricInput) {
	      if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))
	        { indented = indentLine(cm, range.head.line, "smart") }
	    }
	    if (indented) { signalLater(cm, "electricInput", cm, range.head.line) }
	  }
	}
	
	function copyableRanges(cm) {
	  var text = [], ranges = []
	  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
	    var line = cm.doc.sel.ranges[i].head.line
	    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)}
	    ranges.push(lineRange)
	    text.push(cm.getRange(lineRange.anchor, lineRange.head))
	  }
	  return {text: text, ranges: ranges}
	}
	
	function disableBrowserMagic(field, spellcheck) {
	  field.setAttribute("autocorrect", "off")
	  field.setAttribute("autocapitalize", "off")
	  field.setAttribute("spellcheck", !!spellcheck)
	}
	
	function hiddenTextarea() {
	  var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none")
	  var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;")
	  // The textarea is kept positioned near the cursor to prevent the
	  // fact that it'll be scrolled into view on input from scrolling
	  // our fake cursor out of view. On webkit, when wrap=off, paste is
	  // very slow. So make the area wide instead.
	  if (webkit) { te.style.width = "1000px" }
	  else { te.setAttribute("wrap", "off") }
	  // If border: 0; -- iOS fails to open keyboard (issue #1287)
	  if (ios) { te.style.border = "1px solid black" }
	  disableBrowserMagic(te)
	  return div
	}
	
	// The publicly visible API. Note that methodOp(f) means
	// 'wrap f in an operation, performed on its `this` parameter'.
	
	// This is not the complete set of editor methods. Most of the
	// methods defined on the Doc type are also injected into
	// CodeMirror.prototype, for backwards compatibility and
	// convenience.
	
	function addEditorMethods(CodeMirror) {
	  var optionHandlers = CodeMirror.optionHandlers
	
	  var helpers = CodeMirror.helpers = {}
	
	  CodeMirror.prototype = {
	    constructor: CodeMirror,
	    focus: function(){window.focus(); this.display.input.focus()},
	
	    setOption: function(option, value) {
	      var options = this.options, old = options[option]
	      if (options[option] == value && option != "mode") { return }
	      options[option] = value
	      if (optionHandlers.hasOwnProperty(option))
	        { operation(this, optionHandlers[option])(this, value, old) }
	      signal(this, "optionChange", this, option)
	    },
	
	    getOption: function(option) {return this.options[option]},
	    getDoc: function() {return this.doc},
	
	    addKeyMap: function(map, bottom) {
	      this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map))
	    },
	    removeKeyMap: function(map) {
	      var maps = this.state.keyMaps
	      for (var i = 0; i < maps.length; ++i)
	        { if (maps[i] == map || maps[i].name == map) {
	          maps.splice(i, 1)
	          return true
	        } }
	    },
	
	    addOverlay: methodOp(function(spec, options) {
	      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec)
	      if (mode.startState) { throw new Error("Overlays may not be stateful.") }
	      insertSorted(this.state.overlays,
	                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,
	                    priority: (options && options.priority) || 0},
	                   function (overlay) { return overlay.priority; })
	      this.state.modeGen++
	      regChange(this)
	    }),
	    removeOverlay: methodOp(function(spec) {
	      var this$1 = this;
	
	      var overlays = this.state.overlays
	      for (var i = 0; i < overlays.length; ++i) {
	        var cur = overlays[i].modeSpec
	        if (cur == spec || typeof spec == "string" && cur.name == spec) {
	          overlays.splice(i, 1)
	          this$1.state.modeGen++
	          regChange(this$1)
	          return
	        }
	      }
	    }),
	
	    indentLine: methodOp(function(n, dir, aggressive) {
	      if (typeof dir != "string" && typeof dir != "number") {
	        if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev" }
	        else { dir = dir ? "add" : "subtract" }
	      }
	      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive) }
	    }),
	    indentSelection: methodOp(function(how) {
	      var this$1 = this;
	
	      var ranges = this.doc.sel.ranges, end = -1
	      for (var i = 0; i < ranges.length; i++) {
	        var range = ranges[i]
	        if (!range.empty()) {
	          var from = range.from(), to = range.to()
	          var start = Math.max(end, from.line)
	          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1
	          for (var j = start; j < end; ++j)
	            { indentLine(this$1, j, how) }
	          var newRanges = this$1.doc.sel.ranges
	          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
	            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll) }
	        } else if (range.head.line > end) {
	          indentLine(this$1, range.head.line, how, true)
	          end = range.head.line
	          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1) }
	        }
	      }
	    }),
	
	    // Fetch the parser token for a given character. Useful for hacks
	    // that want to inspect the mode state (say, for completion).
	    getTokenAt: function(pos, precise) {
	      return takeToken(this, pos, precise)
	    },
	
	    getLineTokens: function(line, precise) {
	      return takeToken(this, Pos(line), precise, true)
	    },
	
	    getTokenTypeAt: function(pos) {
	      pos = clipPos(this.doc, pos)
	      var styles = getLineStyles(this, getLine(this.doc, pos.line))
	      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch
	      var type
	      if (ch == 0) { type = styles[2] }
	      else { for (;;) {
	        var mid = (before + after) >> 1
	        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid }
	        else if (styles[mid * 2 + 1] < ch) { before = mid + 1 }
	        else { type = styles[mid * 2 + 2]; break }
	      } }
	      var cut = type ? type.indexOf("overlay ") : -1
	      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
	    },
	
	    getModeAt: function(pos) {
	      var mode = this.doc.mode
	      if (!mode.innerMode) { return mode }
	      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
	    },
	
	    getHelper: function(pos, type) {
	      return this.getHelpers(pos, type)[0]
	    },
	
	    getHelpers: function(pos, type) {
	      var this$1 = this;
	
	      var found = []
	      if (!helpers.hasOwnProperty(type)) { return found }
	      var help = helpers[type], mode = this.getModeAt(pos)
	      if (typeof mode[type] == "string") {
	        if (help[mode[type]]) { found.push(help[mode[type]]) }
	      } else if (mode[type]) {
	        for (var i = 0; i < mode[type].length; i++) {
	          var val = help[mode[type][i]]
	          if (val) { found.push(val) }
	        }
	      } else if (mode.helperType && help[mode.helperType]) {
	        found.push(help[mode.helperType])
	      } else if (help[mode.name]) {
	        found.push(help[mode.name])
	      }
	      for (var i$1 = 0; i$1 < help._global.length; i$1++) {
	        var cur = help._global[i$1]
	        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)
	          { found.push(cur.val) }
	      }
	      return found
	    },
	
	    getStateAfter: function(line, precise) {
	      var doc = this.doc
	      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line)
	      return getStateBefore(this, line + 1, precise)
	    },
	
	    cursorCoords: function(start, mode) {
	      var pos, range = this.doc.sel.primary()
	      if (start == null) { pos = range.head }
	      else if (typeof start == "object") { pos = clipPos(this.doc, start) }
	      else { pos = start ? range.from() : range.to() }
	      return cursorCoords(this, pos, mode || "page")
	    },
	
	    charCoords: function(pos, mode) {
	      return charCoords(this, clipPos(this.doc, pos), mode || "page")
	    },
	
	    coordsChar: function(coords, mode) {
	      coords = fromCoordSystem(this, coords, mode || "page")
	      return coordsChar(this, coords.left, coords.top)
	    },
	
	    lineAtHeight: function(height, mode) {
	      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top
	      return lineAtHeight(this.doc, height + this.display.viewOffset)
	    },
	    heightAtLine: function(line, mode, includeWidgets) {
	      var end = false, lineObj
	      if (typeof line == "number") {
	        var last = this.doc.first + this.doc.size - 1
	        if (line < this.doc.first) { line = this.doc.first }
	        else if (line > last) { line = last; end = true }
	        lineObj = getLine(this.doc, line)
	      } else {
	        lineObj = line
	      }
	      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets).top +
	        (end ? this.doc.height - heightAtLine(lineObj) : 0)
	    },
	
	    defaultTextHeight: function() { return textHeight(this.display) },
	    defaultCharWidth: function() { return charWidth(this.display) },
	
	    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},
	
	    addWidget: function(pos, node, scroll, vert, horiz) {
	      var display = this.display
	      pos = cursorCoords(this, clipPos(this.doc, pos))
	      var top = pos.bottom, left = pos.left
	      node.style.position = "absolute"
	      node.setAttribute("cm-ignore-events", "true")
	      this.display.input.setUneditable(node)
	      display.sizer.appendChild(node)
	      if (vert == "over") {
	        top = pos.top
	      } else if (vert == "above" || vert == "near") {
	        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
	        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth)
	        // Default to positioning above (if specified and possible); otherwise default to positioning below
	        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
	          { top = pos.top - node.offsetHeight }
	        else if (pos.bottom + node.offsetHeight <= vspace)
	          { top = pos.bottom }
	        if (left + node.offsetWidth > hspace)
	          { left = hspace - node.offsetWidth }
	      }
	      node.style.top = top + "px"
	      node.style.left = node.style.right = ""
	      if (horiz == "right") {
	        left = display.sizer.clientWidth - node.offsetWidth
	        node.style.right = "0px"
	      } else {
	        if (horiz == "left") { left = 0 }
	        else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2 }
	        node.style.left = left + "px"
	      }
	      if (scroll)
	        { scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight) }
	    },
	
	    triggerOnKeyDown: methodOp(onKeyDown),
	    triggerOnKeyPress: methodOp(onKeyPress),
	    triggerOnKeyUp: onKeyUp,
	
	    execCommand: function(cmd) {
	      if (commands.hasOwnProperty(cmd))
	        { return commands[cmd].call(null, this) }
	    },
	
	    triggerElectric: methodOp(function(text) { triggerElectric(this, text) }),
	
	    findPosH: function(from, amount, unit, visually) {
	      var this$1 = this;
	
	      var dir = 1
	      if (amount < 0) { dir = -1; amount = -amount }
	      var cur = clipPos(this.doc, from)
	      for (var i = 0; i < amount; ++i) {
	        cur = findPosH(this$1.doc, cur, dir, unit, visually)
	        if (cur.hitSide) { break }
	      }
	      return cur
	    },
	
	    moveH: methodOp(function(dir, unit) {
	      var this$1 = this;
	
	      this.extendSelectionsBy(function (range) {
	        if (this$1.display.shift || this$1.doc.extend || range.empty())
	          { return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) }
	        else
	          { return dir < 0 ? range.from() : range.to() }
	      }, sel_move)
	    }),
	
	    deleteH: methodOp(function(dir, unit) {
	      var sel = this.doc.sel, doc = this.doc
	      if (sel.somethingSelected())
	        { doc.replaceSelection("", null, "+delete") }
	      else
	        { deleteNearSelection(this, function (range) {
	          var other = findPosH(doc, range.head, dir, unit, false)
	          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other}
	        }) }
	    }),
	
	    findPosV: function(from, amount, unit, goalColumn) {
	      var this$1 = this;
	
	      var dir = 1, x = goalColumn
	      if (amount < 0) { dir = -1; amount = -amount }
	      var cur = clipPos(this.doc, from)
	      for (var i = 0; i < amount; ++i) {
	        var coords = cursorCoords(this$1, cur, "div")
	        if (x == null) { x = coords.left }
	        else { coords.left = x }
	        cur = findPosV(this$1, coords, dir, unit)
	        if (cur.hitSide) { break }
	      }
	      return cur
	    },
	
	    moveV: methodOp(function(dir, unit) {
	      var this$1 = this;
	
	      var doc = this.doc, goals = []
	      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected()
	      doc.extendSelectionsBy(function (range) {
	        if (collapse)
	          { return dir < 0 ? range.from() : range.to() }
	        var headPos = cursorCoords(this$1, range.head, "div")
	        if (range.goalColumn != null) { headPos.left = range.goalColumn }
	        goals.push(headPos.left)
	        var pos = findPosV(this$1, headPos, dir, unit)
	        if (unit == "page" && range == doc.sel.primary())
	          { addToScrollPos(this$1, null, charCoords(this$1, pos, "div").top - headPos.top) }
	        return pos
	      }, sel_move)
	      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
	        { doc.sel.ranges[i].goalColumn = goals[i] } }
	    }),
	
	    // Find the word at the given position (as returned by coordsChar).
	    findWordAt: function(pos) {
	      var doc = this.doc, line = getLine(doc, pos.line).text
	      var start = pos.ch, end = pos.ch
	      if (line) {
	        var helper = this.getHelper(pos, "wordChars")
	        if ((pos.xRel < 0 || end == line.length) && start) { --start; } else { ++end }
	        var startChar = line.charAt(start)
	        var check = isWordChar(startChar, helper)
	          ? function (ch) { return isWordChar(ch, helper); }
	          : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
	          : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); }
	        while (start > 0 && check(line.charAt(start - 1))) { --start }
	        while (end < line.length && check(line.charAt(end))) { ++end }
	      }
	      return new Range(Pos(pos.line, start), Pos(pos.line, end))
	    },
	
	    toggleOverwrite: function(value) {
	      if (value != null && value == this.state.overwrite) { return }
	      if (this.state.overwrite = !this.state.overwrite)
	        { addClass(this.display.cursorDiv, "CodeMirror-overwrite") }
	      else
	        { rmClass(this.display.cursorDiv, "CodeMirror-overwrite") }
	
	      signal(this, "overwriteToggle", this, this.state.overwrite)
	    },
	    hasFocus: function() { return this.display.input.getField() == activeElt() },
	    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },
	
	    scrollTo: methodOp(function(x, y) {
	      if (x != null || y != null) { resolveScrollToPos(this) }
	      if (x != null) { this.curOp.scrollLeft = x }
	      if (y != null) { this.curOp.scrollTop = y }
	    }),
	    getScrollInfo: function() {
	      var scroller = this.display.scroller
	      return {left: scroller.scrollLeft, top: scroller.scrollTop,
	              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
	              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
	              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
	    },
	
	    scrollIntoView: methodOp(function(range, margin) {
	      if (range == null) {
	        range = {from: this.doc.sel.primary().head, to: null}
	        if (margin == null) { margin = this.options.cursorScrollMargin }
	      } else if (typeof range == "number") {
	        range = {from: Pos(range, 0), to: null}
	      } else if (range.from == null) {
	        range = {from: range, to: null}
	      }
	      if (!range.to) { range.to = range.from }
	      range.margin = margin || 0
	
	      if (range.from.line != null) {
	        resolveScrollToPos(this)
	        this.curOp.scrollToPos = range
	      } else {
	        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),
	                                      Math.min(range.from.top, range.to.top) - range.margin,
	                                      Math.max(range.from.right, range.to.right),
	                                      Math.max(range.from.bottom, range.to.bottom) + range.margin)
	        this.scrollTo(sPos.scrollLeft, sPos.scrollTop)
	      }
	    }),
	
	    setSize: methodOp(function(width, height) {
	      var this$1 = this;
	
	      var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; }
	      if (width != null) { this.display.wrapper.style.width = interpret(width) }
	      if (height != null) { this.display.wrapper.style.height = interpret(height) }
	      if (this.options.lineWrapping) { clearLineMeasurementCache(this) }
	      var lineNo = this.display.viewFrom
	      this.doc.iter(lineNo, this.display.viewTo, function (line) {
	        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
	          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo, "widget"); break } } }
	        ++lineNo
	      })
	      this.curOp.forceUpdate = true
	      signal(this, "refresh", this)
	    }),
	
	    operation: function(f){return runInOp(this, f)},
	
	    refresh: methodOp(function() {
	      var oldHeight = this.display.cachedTextHeight
	      regChange(this)
	      this.curOp.forceUpdate = true
	      clearCaches(this)
	      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop)
	      updateGutterSpace(this)
	      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
	        { estimateLineHeights(this) }
	      signal(this, "refresh", this)
	    }),
	
	    swapDoc: methodOp(function(doc) {
	      var old = this.doc
	      old.cm = null
	      attachDoc(this, doc)
	      clearCaches(this)
	      this.display.input.reset()
	      this.scrollTo(doc.scrollLeft, doc.scrollTop)
	      this.curOp.forceScroll = true
	      signalLater(this, "swapDoc", this, old)
	      return old
	    }),
	
	    getInputField: function(){return this.display.input.getField()},
	    getWrapperElement: function(){return this.display.wrapper},
	    getScrollerElement: function(){return this.display.scroller},
	    getGutterElement: function(){return this.display.gutters}
	  }
	  eventMixin(CodeMirror)
	
	  CodeMirror.registerHelper = function(type, name, value) {
	    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []} }
	    helpers[type][name] = value
	  }
	  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
	    CodeMirror.registerHelper(type, name, value)
	    helpers[type]._global.push({pred: predicate, val: value})
	  }
	}
	
	// Used for horizontal relative motion. Dir is -1 or 1 (left or
	// right), unit can be "char", "column" (like char, but doesn't
	// cross line boundaries), "word" (across next word), or "group" (to
	// the start of next group of word or non-word-non-whitespace
	// chars). The visually param controls whether, in right-to-left
	// text, direction 1 means to move towards the next index in the
	// string, or towards the character to the right of the current
	// position. The resulting position will have a hitSide=true
	// property if it reached the end of the document.
	function findPosH(doc, pos, dir, unit, visually) {
	  var line = pos.line, ch = pos.ch, origDir = dir
	  var lineObj = getLine(doc, line)
	  function findNextLine() {
	    var l = line + dir
	    if (l < doc.first || l >= doc.first + doc.size) { return false }
	    line = l
	    return lineObj = getLine(doc, l)
	  }
	  function moveOnce(boundToLine) {
	    var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true)
	    if (next == null) {
	      if (!boundToLine && findNextLine()) {
	        if (visually) { ch = (dir < 0 ? lineRight : lineLeft)(lineObj) }
	        else { ch = dir < 0 ? lineObj.text.length : 0 }
	      } else { return false }
	    } else { ch = next }
	    return true
	  }
	
	  if (unit == "char") {
	    moveOnce()
	  } else if (unit == "column") {
	    moveOnce(true)
	  } else if (unit == "word" || unit == "group") {
	    var sawType = null, group = unit == "group"
	    var helper = doc.cm && doc.cm.getHelper(pos, "wordChars")
	    for (var first = true;; first = false) {
	      if (dir < 0 && !moveOnce(!first)) { break }
	      var cur = lineObj.text.charAt(ch) || "\n"
	      var type = isWordChar(cur, helper) ? "w"
	        : group && cur == "\n" ? "n"
	        : !group || /\s/.test(cur) ? null
	        : "p"
	      if (group && !first && !type) { type = "s" }
	      if (sawType && sawType != type) {
	        if (dir < 0) {dir = 1; moveOnce()}
	        break
	      }
	
	      if (type) { sawType = type }
	      if (dir > 0 && !moveOnce(!first)) { break }
	    }
	  }
	  var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true)
	  if (!cmp(pos, result)) { result.hitSide = true }
	  return result
	}
	
	// For relative vertical movement. Dir may be -1 or 1. Unit can be
	// "page" or "line". The resulting position will have a hitSide=true
	// property if it reached the end of the document.
	function findPosV(cm, pos, dir, unit) {
	  var doc = cm.doc, x = pos.left, y
	  if (unit == "page") {
	    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight)
	    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3)
	    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount
	
	  } else if (unit == "line") {
	    y = dir > 0 ? pos.bottom + 3 : pos.top - 3
	  }
	  var target
	  for (;;) {
	    target = coordsChar(cm, x, y)
	    if (!target.outside) { break }
	    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
	    y += dir * 5
	  }
	  return target
	}
	
	// CONTENTEDITABLE INPUT STYLE
	
	var ContentEditableInput = function(cm) {
	  this.cm = cm
	  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null
	  this.polling = new Delayed()
	  this.composing = null
	  this.gracePeriod = false
	  this.readDOMTimeout = null
	};
	
	ContentEditableInput.prototype.init = function (display) {
	    var this$1 = this;
	
	  var input = this, cm = input.cm
	  var div = input.div = display.lineDiv
	  disableBrowserMagic(div, cm.options.spellcheck)
	
	  on(div, "paste", function (e) {
	    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
	    // IE doesn't fire input events, so we schedule a read for the pasted content in this way
	    if (ie_version <= 11) { setTimeout(operation(cm, function () {
	      if (!input.pollContent()) { regChange(cm) }
	    }), 20) }
	  })
	
	  on(div, "compositionstart", function (e) {
	    this$1.composing = {data: e.data, done: false}
	  })
	  on(div, "compositionupdate", function (e) {
	    if (!this$1.composing) { this$1.composing = {data: e.data, done: false} }
	  })
	  on(div, "compositionend", function (e) {
	    if (this$1.composing) {
	      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon() }
	      this$1.composing.done = true
	    }
	  })
	
	  on(div, "touchstart", function () { return input.forceCompositionEnd(); })
	
	  on(div, "input", function () {
	    if (!this$1.composing) { this$1.readFromDOMSoon() }
	  })
	
	  function onCopyCut(e) {
	    if (signalDOMEvent(cm, e)) { return }
	    if (cm.somethingSelected()) {
	      setLastCopied({lineWise: false, text: cm.getSelections()})
	      if (e.type == "cut") { cm.replaceSelection("", null, "cut") }
	    } else if (!cm.options.lineWiseCopyCut) {
	      return
	    } else {
	      var ranges = copyableRanges(cm)
	      setLastCopied({lineWise: true, text: ranges.text})
	      if (e.type == "cut") {
	        cm.operation(function () {
	          cm.setSelections(ranges.ranges, 0, sel_dontScroll)
	          cm.replaceSelection("", null, "cut")
	        })
	      }
	    }
	    if (e.clipboardData) {
	      e.clipboardData.clearData()
	      var content = lastCopied.text.join("\n")
	      // iOS exposes the clipboard API, but seems to discard content inserted into it
	      e.clipboardData.setData("Text", content)
	      if (e.clipboardData.getData("Text") == content) {
	        e.preventDefault()
	        return
	      }
	    }
	    // Old-fashioned briefly-focus-a-textarea hack
	    var kludge = hiddenTextarea(), te = kludge.firstChild
	    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild)
	    te.value = lastCopied.text.join("\n")
	    var hadFocus = document.activeElement
	    selectInput(te)
	    setTimeout(function () {
	      cm.display.lineSpace.removeChild(kludge)
	      hadFocus.focus()
	      if (hadFocus == div) { input.showPrimarySelection() }
	    }, 50)
	  }
	  on(div, "copy", onCopyCut)
	  on(div, "cut", onCopyCut)
	};
	
	ContentEditableInput.prototype.prepareSelection = function () {
	  var result = prepareSelection(this.cm, false)
	  result.focus = this.cm.state.focused
	  return result
	};
	
	ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
	  if (!info || !this.cm.display.view.length) { return }
	  if (info.focus || takeFocus) { this.showPrimarySelection() }
	  this.showMultipleSelections(info)
	};
	
	ContentEditableInput.prototype.showPrimarySelection = function () {
	  var sel = window.getSelection(), prim = this.cm.doc.sel.primary()
	  var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset)
	  var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset)
	  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
	      cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&
	      cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)
	    { return }
	
	  var start = posToDOM(this.cm, prim.from())
	  var end = posToDOM(this.cm, prim.to())
	  if (!start && !end) { return }
	
	  var view = this.cm.display.view
	  var old = sel.rangeCount && sel.getRangeAt(0)
	  if (!start) {
	    start = {node: view[0].measure.map[2], offset: 0}
	  } else if (!end) { // FIXME dangerously hacky
	    var measure = view[view.length - 1].measure
	    var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map
	    end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]}
	  }
	
	  var rng
	  try { rng = range(start.node, start.offset, end.offset, end.node) }
	  catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
	  if (rng) {
	    if (!gecko && this.cm.state.focused) {
	      sel.collapse(start.node, start.offset)
	      if (!rng.collapsed) {
	        sel.removeAllRanges()
	        sel.addRange(rng)
	      }
	    } else {
	      sel.removeAllRanges()
	      sel.addRange(rng)
	    }
	    if (old && sel.anchorNode == null) { sel.addRange(old) }
	    else if (gecko) { this.startGracePeriod() }
	  }
	  this.rememberSelection()
	};
	
	ContentEditableInput.prototype.startGracePeriod = function () {
	    var this$1 = this;
	
	  clearTimeout(this.gracePeriod)
	  this.gracePeriod = setTimeout(function () {
	    this$1.gracePeriod = false
	    if (this$1.selectionChanged())
	      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }) }
	  }, 20)
	};
	
	ContentEditableInput.prototype.showMultipleSelections = function (info) {
	  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors)
	  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection)
	};
	
	ContentEditableInput.prototype.rememberSelection = function () {
	  var sel = window.getSelection()
	  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset
	  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset
	};
	
	ContentEditableInput.prototype.selectionInEditor = function () {
	  var sel = window.getSelection()
	  if (!sel.rangeCount) { return false }
	  var node = sel.getRangeAt(0).commonAncestorContainer
	  return contains(this.div, node)
	};
	
	ContentEditableInput.prototype.focus = function () {
	  if (this.cm.options.readOnly != "nocursor") {
	    if (!this.selectionInEditor())
	      { this.showSelection(this.prepareSelection(), true) }
	    this.div.focus()
	  }
	};
	ContentEditableInput.prototype.blur = function () { this.div.blur() };
	ContentEditableInput.prototype.getField = function () { return this.div };
	
	ContentEditableInput.prototype.supportsTouch = function () { return true };
	
	ContentEditableInput.prototype.receivedFocus = function () {
	  var input = this
	  if (this.selectionInEditor())
	    { this.pollSelection() }
	  else
	    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }) }
	
	  function poll() {
	    if (input.cm.state.focused) {
	      input.pollSelection()
	      input.polling.set(input.cm.options.pollInterval, poll)
	    }
	  }
	  this.polling.set(this.cm.options.pollInterval, poll)
	};
	
	ContentEditableInput.prototype.selectionChanged = function () {
	  var sel = window.getSelection()
	  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
	    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
	};
	
	ContentEditableInput.prototype.pollSelection = function () {
	  if (!this.composing && this.readDOMTimeout == null && !this.gracePeriod && this.selectionChanged()) {
	    var sel = window.getSelection(), cm = this.cm
	    this.rememberSelection()
	    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset)
	    var head = domToPos(cm, sel.focusNode, sel.focusOffset)
	    if (anchor && head) { runInOp(cm, function () {
	      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll)
	      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true }
	    }) }
	  }
	};
	
	ContentEditableInput.prototype.pollContent = function () {
	  if (this.readDOMTimeout != null) {
	    clearTimeout(this.readDOMTimeout)
	    this.readDOMTimeout = null
	  }
	
	  var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary()
	  var from = sel.from(), to = sel.to()
	  if (from.ch == 0 && from.line > cm.firstLine())
	    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length) }
	  if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
	    { to = Pos(to.line + 1, 0) }
	  if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }
	
	  var fromIndex, fromLine, fromNode
	  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
	    fromLine = lineNo(display.view[0].line)
	    fromNode = display.view[0].node
	  } else {
	    fromLine = lineNo(display.view[fromIndex].line)
	    fromNode = display.view[fromIndex - 1].node.nextSibling
	  }
	  var toIndex = findViewIndex(cm, to.line)
	  var toLine, toNode
	  if (toIndex == display.view.length - 1) {
	    toLine = display.viewTo - 1
	    toNode = display.lineDiv.lastChild
	  } else {
	    toLine = lineNo(display.view[toIndex + 1].line) - 1
	    toNode = display.view[toIndex + 1].node.previousSibling
	  }
	
	  if (!fromNode) { return false }
	  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine))
	  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length))
	  while (newText.length > 1 && oldText.length > 1) {
	    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine-- }
	    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++ }
	    else { break }
	  }
	
	  var cutFront = 0, cutEnd = 0
	  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length)
	  while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
	    { ++cutFront }
	  var newBot = lst(newText), oldBot = lst(oldText)
	  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
	                           oldBot.length - (oldText.length == 1 ? cutFront : 0))
	  while (cutEnd < maxCutEnd &&
	         newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
	    { ++cutEnd }
	
	  newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "")
	  newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "")
	
	  var chFrom = Pos(fromLine, cutFront)
	  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0)
	  if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
	    replaceRange(cm.doc, newText, chFrom, chTo, "+input")
	    return true
	  }
	};
	
	ContentEditableInput.prototype.ensurePolled = function () {
	  this.forceCompositionEnd()
	};
	ContentEditableInput.prototype.reset = function () {
	  this.forceCompositionEnd()
	};
	ContentEditableInput.prototype.forceCompositionEnd = function () {
	  if (!this.composing) { return }
	  clearTimeout(this.readDOMTimeout)
	  this.composing = null
	  if (!this.pollContent()) { regChange(this.cm) }
	  this.div.blur()
	  this.div.focus()
	};
	ContentEditableInput.prototype.readFromDOMSoon = function () {
	    var this$1 = this;
	
	  if (this.readDOMTimeout != null) { return }
	  this.readDOMTimeout = setTimeout(function () {
	    this$1.readDOMTimeout = null
	    if (this$1.composing) {
	      if (this$1.composing.done) { this$1.composing = null }
	      else { return }
	    }
	    if (this$1.cm.isReadOnly() || !this$1.pollContent())
	      { runInOp(this$1.cm, function () { return regChange(this$1.cm); }) }
	  }, 80)
	};
	
	ContentEditableInput.prototype.setUneditable = function (node) {
	  node.contentEditable = "false"
	};
	
	ContentEditableInput.prototype.onKeyPress = function (e) {
	  e.preventDefault()
	  if (!this.cm.isReadOnly())
	    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0) }
	};
	
	ContentEditableInput.prototype.readOnlyChanged = function (val) {
	  this.div.contentEditable = String(val != "nocursor")
	};
	
	ContentEditableInput.prototype.onContextMenu = function () {};
	ContentEditableInput.prototype.resetPosition = function () {};
	
	ContentEditableInput.prototype.needsContentAttribute = true
	
	function posToDOM(cm, pos) {
	  var view = findViewForLine(cm, pos.line)
	  if (!view || view.hidden) { return null }
	  var line = getLine(cm.doc, pos.line)
	  var info = mapFromLineView(view, line, pos.line)
	
	  var order = getOrder(line), side = "left"
	  if (order) {
	    var partPos = getBidiPartAt(order, pos.ch)
	    side = partPos % 2 ? "right" : "left"
	  }
	  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side)
	  result.offset = result.collapse == "right" ? result.end : result.start
	  return result
	}
	
	function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }
	
	function domTextBetween(cm, from, to, fromLine, toLine) {
	  var text = "", closing = false, lineSep = cm.doc.lineSeparator()
	  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
	  function walk(node) {
	    if (node.nodeType == 1) {
	      var cmText = node.getAttribute("cm-text")
	      if (cmText != null) {
	        if (cmText == "") { text += node.textContent.replace(/\u200b/g, "") }
	        else { text += cmText }
	        return
	      }
	      var markerID = node.getAttribute("cm-marker"), range
	      if (markerID) {
	        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID))
	        if (found.length && (range = found[0].find()))
	          { text += getBetween(cm.doc, range.from, range.to).join(lineSep) }
	        return
	      }
	      if (node.getAttribute("contenteditable") == "false") { return }
	      for (var i = 0; i < node.childNodes.length; i++)
	        { walk(node.childNodes[i]) }
	      if (/^(pre|div|p)$/i.test(node.nodeName))
	        { closing = true }
	    } else if (node.nodeType == 3) {
	      var val = node.nodeValue
	      if (!val) { return }
	      if (closing) {
	        text += lineSep
	        closing = false
	      }
	      text += val
	    }
	  }
	  for (;;) {
	    walk(from)
	    if (from == to) { break }
	    from = from.nextSibling
	  }
	  return text
	}
	
	function domToPos(cm, node, offset) {
	  var lineNode
	  if (node == cm.display.lineDiv) {
	    lineNode = cm.display.lineDiv.childNodes[offset]
	    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
	    node = null; offset = 0
	  } else {
	    for (lineNode = node;; lineNode = lineNode.parentNode) {
	      if (!lineNode || lineNode == cm.display.lineDiv) { return null }
	      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
	    }
	  }
	  for (var i = 0; i < cm.display.view.length; i++) {
	    var lineView = cm.display.view[i]
	    if (lineView.node == lineNode)
	      { return locateNodeInLineView(lineView, node, offset) }
	  }
	}
	
	function locateNodeInLineView(lineView, node, offset) {
	  var wrapper = lineView.text.firstChild, bad = false
	  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
	  if (node == wrapper) {
	    bad = true
	    node = wrapper.childNodes[offset]
	    offset = 0
	    if (!node) {
	      var line = lineView.rest ? lst(lineView.rest) : lineView.line
	      return badPos(Pos(lineNo(line), line.text.length), bad)
	    }
	  }
	
	  var textNode = node.nodeType == 3 ? node : null, topNode = node
	  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
	    textNode = node.firstChild
	    if (offset) { offset = textNode.nodeValue.length }
	  }
	  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode }
	  var measure = lineView.measure, maps = measure.maps
	
	  function find(textNode, topNode, offset) {
	    for (var i = -1; i < (maps ? maps.length : 0); i++) {
	      var map = i < 0 ? measure.map : maps[i]
	      for (var j = 0; j < map.length; j += 3) {
	        var curNode = map[j + 2]
	        if (curNode == textNode || curNode == topNode) {
	          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i])
	          var ch = map[j] + offset
	          if (offset < 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)] }
	          return Pos(line, ch)
	        }
	      }
	    }
	  }
	  var found = find(textNode, topNode, offset)
	  if (found) { return badPos(found, bad) }
	
	  // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
	  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
	    found = find(after, after.firstChild, 0)
	    if (found)
	      { return badPos(Pos(found.line, found.ch - dist), bad) }
	    else
	      { dist += after.textContent.length }
	  }
	  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
	    found = find(before, before.firstChild, -1)
	    if (found)
	      { return badPos(Pos(found.line, found.ch + dist$1), bad) }
	    else
	      { dist$1 += before.textContent.length }
	  }
	}
	
	// TEXTAREA INPUT STYLE
	
	var TextareaInput = function(cm) {
	  this.cm = cm
	  // See input.poll and input.reset
	  this.prevInput = ""
	
	  // Flag that indicates whether we expect input to appear real soon
	  // now (after some event like 'keypress' or 'input') and are
	  // polling intensively.
	  this.pollingFast = false
	  // Self-resetting timeout for the poller
	  this.polling = new Delayed()
	  // Tracks when input.reset has punted to just putting a short
	  // string into the textarea instead of the full selection.
	  this.inaccurateSelection = false
	  // Used to work around IE issue with selection being forgotten when focus moves away from textarea
	  this.hasSelection = false
	  this.composing = null
	};
	
	TextareaInput.prototype.init = function (display) {
	    var this$1 = this;
	
	  var input = this, cm = this.cm
	
	  // Wraps and hides input textarea
	  var div = this.wrapper = hiddenTextarea()
	  // The semihidden textarea that is focused when the editor is
	  // focused, and receives input.
	  var te = this.textarea = div.firstChild
	  display.wrapper.insertBefore(div, display.wrapper.firstChild)
	
	  // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
	  if (ios) { te.style.width = "0px" }
	
	  on(te, "input", function () {
	    if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null }
	    input.poll()
	  })
	
	  on(te, "paste", function (e) {
	    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
	
	    cm.state.pasteIncoming = true
	    input.fastPoll()
	  })
	
	  function prepareCopyCut(e) {
	    if (signalDOMEvent(cm, e)) { return }
	    if (cm.somethingSelected()) {
	      setLastCopied({lineWise: false, text: cm.getSelections()})
	      if (input.inaccurateSelection) {
	        input.prevInput = ""
	        input.inaccurateSelection = false
	        te.value = lastCopied.text.join("\n")
	        selectInput(te)
	      }
	    } else if (!cm.options.lineWiseCopyCut) {
	      return
	    } else {
	      var ranges = copyableRanges(cm)
	      setLastCopied({lineWise: true, text: ranges.text})
	      if (e.type == "cut") {
	        cm.setSelections(ranges.ranges, null, sel_dontScroll)
	      } else {
	        input.prevInput = ""
	        te.value = ranges.text.join("\n")
	        selectInput(te)
	      }
	    }
	    if (e.type == "cut") { cm.state.cutIncoming = true }
	  }
	  on(te, "cut", prepareCopyCut)
	  on(te, "copy", prepareCopyCut)
	
	  on(display.scroller, "paste", function (e) {
	    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
	    cm.state.pasteIncoming = true
	    input.focus()
	  })
	
	  // Prevent normal selection in the editor (we handle our own)
	  on(display.lineSpace, "selectstart", function (e) {
	    if (!eventInWidget(display, e)) { e_preventDefault(e) }
	  })
	
	  on(te, "compositionstart", function () {
	    var start = cm.getCursor("from")
	    if (input.composing) { input.composing.range.clear() }
	    input.composing = {
	      start: start,
	      range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
	    }
	  })
	  on(te, "compositionend", function () {
	    if (input.composing) {
	      input.poll()
	      input.composing.range.clear()
	      input.composing = null
	    }
	  })
	};
	
	TextareaInput.prototype.prepareSelection = function () {
	  // Redraw the selection and/or cursor
	  var cm = this.cm, display = cm.display, doc = cm.doc
	  var result = prepareSelection(cm)
	
	  // Move the hidden textarea near the cursor to prevent scrolling artifacts
	  if (cm.options.moveInputWithCursor) {
	    var headPos = cursorCoords(cm, doc.sel.primary().head, "div")
	    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect()
	    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
	                                        headPos.top + lineOff.top - wrapOff.top))
	    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
	                                         headPos.left + lineOff.left - wrapOff.left))
	  }
	
	  return result
	};
	
	TextareaInput.prototype.showSelection = function (drawn) {
	  var cm = this.cm, display = cm.display
	  removeChildrenAndAdd(display.cursorDiv, drawn.cursors)
	  removeChildrenAndAdd(display.selectionDiv, drawn.selection)
	  if (drawn.teTop != null) {
	    this.wrapper.style.top = drawn.teTop + "px"
	    this.wrapper.style.left = drawn.teLeft + "px"
	  }
	};
	
	// Reset the input to correspond to the selection (or to be empty,
	// when not typing and nothing is selected)
	TextareaInput.prototype.reset = function (typing) {
	  if (this.contextMenuPending) { return }
	  var minimal, selected, cm = this.cm, doc = cm.doc
	  if (cm.somethingSelected()) {
	    this.prevInput = ""
	    var range = doc.sel.primary()
	    minimal = hasCopyEvent &&
	      (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000)
	    var content = minimal ? "-" : selected || cm.getSelection()
	    this.textarea.value = content
	    if (cm.state.focused) { selectInput(this.textarea) }
	    if (ie && ie_version >= 9) { this.hasSelection = content }
	  } else if (!typing) {
	    this.prevInput = this.textarea.value = ""
	    if (ie && ie_version >= 9) { this.hasSelection = null }
	  }
	  this.inaccurateSelection = minimal
	};
	
	TextareaInput.prototype.getField = function () { return this.textarea };
	
	TextareaInput.prototype.supportsTouch = function () { return false };
	
	TextareaInput.prototype.focus = function () {
	  if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
	    try { this.textarea.focus() }
	    catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
	  }
	};
	
	TextareaInput.prototype.blur = function () { this.textarea.blur() };
	
	TextareaInput.prototype.resetPosition = function () {
	  this.wrapper.style.top = this.wrapper.style.left = 0
	};
	
	TextareaInput.prototype.receivedFocus = function () { this.slowPoll() };
	
	// Poll for input changes, using the normal rate of polling. This
	// runs as long as the editor is focused.
	TextareaInput.prototype.slowPoll = function () {
	    var this$1 = this;
	
	  if (this.pollingFast) { return }
	  this.polling.set(this.cm.options.pollInterval, function () {
	    this$1.poll()
	    if (this$1.cm.state.focused) { this$1.slowPoll() }
	  })
	};
	
	// When an event has just come in that is likely to add or change
	// something in the input textarea, we poll faster, to ensure that
	// the change appears on the screen quickly.
	TextareaInput.prototype.fastPoll = function () {
	  var missed = false, input = this
	  input.pollingFast = true
	  function p() {
	    var changed = input.poll()
	    if (!changed && !missed) {missed = true; input.polling.set(60, p)}
	    else {input.pollingFast = false; input.slowPoll()}
	  }
	  input.polling.set(20, p)
	};
	
	// Read input from the textarea, and update the document to match.
	// When something is selected, it is present in the textarea, and
	// selected (unless it is huge, in which case a placeholder is
	// used). When nothing is selected, the cursor sits after previously
	// seen text (can be empty), which is stored in prevInput (we must
	// not reset the textarea when typing, because that breaks IME).
	TextareaInput.prototype.poll = function () {
	    var this$1 = this;
	
	  var cm = this.cm, input = this.textarea, prevInput = this.prevInput
	  // Since this is called a *lot*, try to bail out as cheaply as
	  // possible when it is clear that nothing happened. hasSelection
	  // will be the case when there is a lot of text in the textarea,
	  // in which case reading its value would be expensive.
	  if (this.contextMenuPending || !cm.state.focused ||
	      (hasSelection(input) && !prevInput && !this.composing) ||
	      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
	    { return false }
	
	  var text = input.value
	  // If nothing changed, bail.
	  if (text == prevInput && !cm.somethingSelected()) { return false }
	  // Work around nonsensical selection resetting in IE9/10, and
	  // inexplicable appearance of private area unicode characters on
	  // some key combos in Mac (#2689).
	  if (ie && ie_version >= 9 && this.hasSelection === text ||
	      mac && /[\uf700-\uf7ff]/.test(text)) {
	    cm.display.input.reset()
	    return false
	  }
	
	  if (cm.doc.sel == cm.display.selForContextMenu) {
	    var first = text.charCodeAt(0)
	    if (first == 0x200b && !prevInput) { prevInput = "\u200b" }
	    if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
	  }
	  // Find the part of the input that is actually new
	  var same = 0, l = Math.min(prevInput.length, text.length)
	  while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same }
	
	  runInOp(cm, function () {
	    applyTextInput(cm, text.slice(same), prevInput.length - same,
	                   null, this$1.composing ? "*compose" : null)
	
	    // Don't leave long text in the textarea, since it makes further polling slow
	    if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = "" }
	    else { this$1.prevInput = text }
	
	    if (this$1.composing) {
	      this$1.composing.range.clear()
	      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
	                                         {className: "CodeMirror-composing"})
	    }
	  })
	  return true
	};
	
	TextareaInput.prototype.ensurePolled = function () {
	  if (this.pollingFast && this.poll()) { this.pollingFast = false }
	};
	
	TextareaInput.prototype.onKeyPress = function () {
	  if (ie && ie_version >= 9) { this.hasSelection = null }
	  this.fastPoll()
	};
	
	TextareaInput.prototype.onContextMenu = function (e) {
	  var input = this, cm = input.cm, display = cm.display, te = input.textarea
	  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop
	  if (!pos || presto) { return } // Opera is difficult.
	
	  // Reset the current text selection only if the click is done outside of the selection
	  // and 'resetSelectionOnContextMenu' option is true.
	  var reset = cm.options.resetSelectionOnContextMenu
	  if (reset && cm.doc.sel.contains(pos) == -1)
	    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll) }
	
	  var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText
	  input.wrapper.style.cssText = "position: absolute"
	  var wrapperBox = input.wrapper.getBoundingClientRect()
	  te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);"
	  var oldScrollY
	  if (webkit) { oldScrollY = window.scrollY } // Work around Chrome issue (#2712)
	  display.input.focus()
	  if (webkit) { window.scrollTo(null, oldScrollY) }
	  display.input.reset()
	  // Adds "Select all" to context menu in FF
	  if (!cm.somethingSelected()) { te.value = input.prevInput = " " }
	  input.contextMenuPending = true
	  display.selForContextMenu = cm.doc.sel
	  clearTimeout(display.detectingSelectAll)
	
	  // Select-all will be greyed out if there's nothing to select, so
	  // this adds a zero-width space so that we can later check whether
	  // it got selected.
	  function prepareSelectAllHack() {
	    if (te.selectionStart != null) {
	      var selected = cm.somethingSelected()
	      var extval = "\u200b" + (selected ? te.value : "")
	      te.value = "\u21da" // Used to catch context-menu undo
	      te.value = extval
	      input.prevInput = selected ? "" : "\u200b"
	      te.selectionStart = 1; te.selectionEnd = extval.length
	      // Re-set this, in case some other handler touched the
	      // selection in the meantime.
	      display.selForContextMenu = cm.doc.sel
	    }
	  }
	  function rehide() {
	    input.contextMenuPending = false
	    input.wrapper.style.cssText = oldWrapperCSS
	    te.style.cssText = oldCSS
	    if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos) }
	
	    // Try to detect the user choosing select-all
	    if (te.selectionStart != null) {
	      if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack() }
	      var i = 0, poll = function () {
	        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
	            te.selectionEnd > 0 && input.prevInput == "\u200b")
	          { operation(cm, selectAll)(cm) }
	        else if (i++ < 10) { display.detectingSelectAll = setTimeout(poll, 500) }
	        else { display.input.reset() }
	      }
	      display.detectingSelectAll = setTimeout(poll, 200)
	    }
	  }
	
	  if (ie && ie_version >= 9) { prepareSelectAllHack() }
	  if (captureRightClick) {
	    e_stop(e)
	    var mouseup = function () {
	      off(window, "mouseup", mouseup)
	      setTimeout(rehide, 20)
	    }
	    on(window, "mouseup", mouseup)
	  } else {
	    setTimeout(rehide, 50)
	  }
	};
	
	TextareaInput.prototype.readOnlyChanged = function (val) {
	  if (!val) { this.reset() }
	};
	
	TextareaInput.prototype.setUneditable = function () {};
	
	TextareaInput.prototype.needsContentAttribute = false
	
	function fromTextArea(textarea, options) {
	  options = options ? copyObj(options) : {}
	  options.value = textarea.value
	  if (!options.tabindex && textarea.tabIndex)
	    { options.tabindex = textarea.tabIndex }
	  if (!options.placeholder && textarea.placeholder)
	    { options.placeholder = textarea.placeholder }
	  // Set autofocus to true if this textarea is focused, or if it has
	  // autofocus and no other element is focused.
	  if (options.autofocus == null) {
	    var hasFocus = activeElt()
	    options.autofocus = hasFocus == textarea ||
	      textarea.getAttribute("autofocus") != null && hasFocus == document.body
	  }
	
	  function save() {textarea.value = cm.getValue()}
	
	  var realSubmit
	  if (textarea.form) {
	    on(textarea.form, "submit", save)
	    // Deplorable hack to make the submit method do the right thing.
	    if (!options.leaveSubmitMethodAlone) {
	      var form = textarea.form
	      realSubmit = form.submit
	      try {
	        var wrappedSubmit = form.submit = function () {
	          save()
	          form.submit = realSubmit
	          form.submit()
	          form.submit = wrappedSubmit
	        }
	      } catch(e) {}
	    }
	  }
	
	  options.finishInit = function (cm) {
	    cm.save = save
	    cm.getTextArea = function () { return textarea; }
	    cm.toTextArea = function () {
	      cm.toTextArea = isNaN // Prevent this from being ran twice
	      save()
	      textarea.parentNode.removeChild(cm.getWrapperElement())
	      textarea.style.display = ""
	      if (textarea.form) {
	        off(textarea.form, "submit", save)
	        if (typeof textarea.form.submit == "function")
	          { textarea.form.submit = realSubmit }
	      }
	    }
	  }
	
	  textarea.style.display = "none"
	  var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
	    options)
	  return cm
	}
	
	function addLegacyProps(CodeMirror) {
	  CodeMirror.off = off
	  CodeMirror.on = on
	  CodeMirror.wheelEventPixels = wheelEventPixels
	  CodeMirror.Doc = Doc
	  CodeMirror.splitLines = splitLinesAuto
	  CodeMirror.countColumn = countColumn
	  CodeMirror.findColumn = findColumn
	  CodeMirror.isWordChar = isWordCharBasic
	  CodeMirror.Pass = Pass
	  CodeMirror.signal = signal
	  CodeMirror.Line = Line
	  CodeMirror.changeEnd = changeEnd
	  CodeMirror.scrollbarModel = scrollbarModel
	  CodeMirror.Pos = Pos
	  CodeMirror.cmpPos = cmp
	  CodeMirror.modes = modes
	  CodeMirror.mimeModes = mimeModes
	  CodeMirror.resolveMode = resolveMode
	  CodeMirror.getMode = getMode
	  CodeMirror.modeExtensions = modeExtensions
	  CodeMirror.extendMode = extendMode
	  CodeMirror.copyState = copyState
	  CodeMirror.startState = startState
	  CodeMirror.innerMode = innerMode
	  CodeMirror.commands = commands
	  CodeMirror.keyMap = keyMap
	  CodeMirror.keyName = keyName
	  CodeMirror.isModifierKey = isModifierKey
	  CodeMirror.lookupKey = lookupKey
	  CodeMirror.normalizeKeyMap = normalizeKeyMap
	  CodeMirror.StringStream = StringStream
	  CodeMirror.SharedTextMarker = SharedTextMarker
	  CodeMirror.TextMarker = TextMarker
	  CodeMirror.LineWidget = LineWidget
	  CodeMirror.e_preventDefault = e_preventDefault
	  CodeMirror.e_stopPropagation = e_stopPropagation
	  CodeMirror.e_stop = e_stop
	  CodeMirror.addClass = addClass
	  CodeMirror.contains = contains
	  CodeMirror.rmClass = rmClass
	  CodeMirror.keyNames = keyNames
	}
	
	// EDITOR CONSTRUCTOR
	
	defineOptions(CodeMirror)
	
	addEditorMethods(CodeMirror)
	
	// Set up methods on CodeMirror's prototype to redirect to the editor's document.
	var dontDelegate = "iter insert remove copy getEditor constructor".split(" ")
	for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
	  { CodeMirror.prototype[prop] = (function(method) {
	    return function() {return method.apply(this.doc, arguments)}
	  })(Doc.prototype[prop]) } }
	
	eventMixin(Doc)
	
	// INPUT HANDLING
	
	CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput}
	
	// MODE DEFINITION AND QUERYING
	
	// Extra arguments are stored as the mode's dependencies, which is
	// used by (legacy) mechanisms like loadmode.js to automatically
	// load a mode. (Preferred mechanism is the require/define calls.)
	CodeMirror.defineMode = function(name/*, mode, …*/) {
	  if (!CodeMirror.defaults.mode && name != "null") { CodeMirror.defaults.mode = name }
	  defineMode.apply(this, arguments)
	}
	
	CodeMirror.defineMIME = defineMIME
	
	// Minimal default mode.
	CodeMirror.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); })
	CodeMirror.defineMIME("text/plain", "null")
	
	// EXTENSIONS
	
	CodeMirror.defineExtension = function (name, func) {
	  CodeMirror.prototype[name] = func
	}
	CodeMirror.defineDocExtension = function (name, func) {
	  Doc.prototype[name] = func
	}
	
	CodeMirror.fromTextArea = fromTextArea
	
	addLegacyProps(CodeMirror)
	
	CodeMirror.version = "5.22.0"
	
	return CodeMirror;
	
	})));

/***/ },
/* 514 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 515 */,
/* 516 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(513));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	"use strict";
	
	function expressionAllowed(stream, state, backUp) {
	  return /^(?:operator|sof|keyword c|case|new|export|default|[\[{}\(,;:]|=>)$/.test(state.lastType) ||
	    (state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))
	}
	
	CodeMirror.defineMode("javascript", function(config, parserConfig) {
	  var indentUnit = config.indentUnit;
	  var statementIndent = parserConfig.statementIndent;
	  var jsonldMode = parserConfig.jsonld;
	  var jsonMode = parserConfig.json || jsonldMode;
	  var isTS = parserConfig.typescript;
	  var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;
	
	  // Tokenizer
	
	  var keywords = function(){
	    function kw(type) {return {type: type, style: "keyword"};}
	    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");
	    var operator = kw("operator"), atom = {type: "atom", style: "atom"};
	
	    var jsKeywords = {
	      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
	      "return": C, "break": C, "continue": C, "new": kw("new"), "delete": C, "throw": C, "debugger": C,
	      "var": kw("var"), "const": kw("var"), "let": kw("var"),
	      "function": kw("function"), "catch": kw("catch"),
	      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
	      "in": operator, "typeof": operator, "instanceof": operator,
	      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
	      "this": kw("this"), "class": kw("class"), "super": kw("atom"),
	      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C,
	      "await": C, "async": kw("async")
	    };
	
	    // Extend the 'normal' keywords with the TypeScript language extensions
	    if (isTS) {
	      var type = {type: "variable", style: "variable-3"};
	      var tsKeywords = {
	        // object-like things
	        "interface": kw("class"),
	        "implements": C,
	        "namespace": C,
	        "module": kw("module"),
	        "enum": kw("module"),
	        "type": kw("type"),
	
	        // scope modifiers
	        "public": kw("modifier"),
	        "private": kw("modifier"),
	        "protected": kw("modifier"),
	        "abstract": kw("modifier"),
	
	        // operators
	        "as": operator,
	
	        // types
	        "string": type, "number": type, "boolean": type, "any": type
	      };
	
	      for (var attr in tsKeywords) {
	        jsKeywords[attr] = tsKeywords[attr];
	      }
	    }
	
	    return jsKeywords;
	  }();
	
	  var isOperatorChar = /[+\-*&%=<>!?|~^]/;
	  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
	
	  function readRegexp(stream) {
	    var escaped = false, next, inSet = false;
	    while ((next = stream.next()) != null) {
	      if (!escaped) {
	        if (next == "/" && !inSet) return;
	        if (next == "[") inSet = true;
	        else if (inSet && next == "]") inSet = false;
	      }
	      escaped = !escaped && next == "\\";
	    }
	  }
	
	  // Used as scratch variables to communicate multiple values without
	  // consing up tons of objects.
	  var type, content;
	  function ret(tp, style, cont) {
	    type = tp; content = cont;
	    return style;
	  }
	  function tokenBase(stream, state) {
	    var ch = stream.next();
	    if (ch == '"' || ch == "'") {
	      state.tokenize = tokenString(ch);
	      return state.tokenize(stream, state);
	    } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
	      return ret("number", "number");
	    } else if (ch == "." && stream.match("..")) {
	      return ret("spread", "meta");
	    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
	      return ret(ch);
	    } else if (ch == "=" && stream.eat(">")) {
	      return ret("=>", "operator");
	    } else if (ch == "0" && stream.eat(/x/i)) {
	      stream.eatWhile(/[\da-f]/i);
	      return ret("number", "number");
	    } else if (ch == "0" && stream.eat(/o/i)) {
	      stream.eatWhile(/[0-7]/i);
	      return ret("number", "number");
	    } else if (ch == "0" && stream.eat(/b/i)) {
	      stream.eatWhile(/[01]/i);
	      return ret("number", "number");
	    } else if (/\d/.test(ch)) {
	      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
	      return ret("number", "number");
	    } else if (ch == "/") {
	      if (stream.eat("*")) {
	        state.tokenize = tokenComment;
	        return tokenComment(stream, state);
	      } else if (stream.eat("/")) {
	        stream.skipToEnd();
	        return ret("comment", "comment");
	      } else if (expressionAllowed(stream, state, 1)) {
	        readRegexp(stream);
	        stream.match(/^\b(([gimyu])(?![gimyu]*\2))+\b/);
	        return ret("regexp", "string-2");
	      } else {
	        stream.eatWhile(isOperatorChar);
	        return ret("operator", "operator", stream.current());
	      }
	    } else if (ch == "`") {
	      state.tokenize = tokenQuasi;
	      return tokenQuasi(stream, state);
	    } else if (ch == "#") {
	      stream.skipToEnd();
	      return ret("error", "error");
	    } else if (isOperatorChar.test(ch)) {
	      if (ch != ">" || !state.lexical || state.lexical.type != ">")
	        stream.eatWhile(isOperatorChar);
	      return ret("operator", "operator", stream.current());
	    } else if (wordRE.test(ch)) {
	      stream.eatWhile(wordRE);
	      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
	      return (known && state.lastType != ".") ? ret(known.type, known.style, word) :
	                     ret("variable", "variable", word);
	    }
	  }
	
	  function tokenString(quote) {
	    return function(stream, state) {
	      var escaped = false, next;
	      if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
	        state.tokenize = tokenBase;
	        return ret("jsonld-keyword", "meta");
	      }
	      while ((next = stream.next()) != null) {
	        if (next == quote && !escaped) break;
	        escaped = !escaped && next == "\\";
	      }
	      if (!escaped) state.tokenize = tokenBase;
	      return ret("string", "string");
	    };
	  }
	
	  function tokenComment(stream, state) {
	    var maybeEnd = false, ch;
	    while (ch = stream.next()) {
	      if (ch == "/" && maybeEnd) {
	        state.tokenize = tokenBase;
	        break;
	      }
	      maybeEnd = (ch == "*");
	    }
	    return ret("comment", "comment");
	  }
	
	  function tokenQuasi(stream, state) {
	    var escaped = false, next;
	    while ((next = stream.next()) != null) {
	      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
	        state.tokenize = tokenBase;
	        break;
	      }
	      escaped = !escaped && next == "\\";
	    }
	    return ret("quasi", "string-2", stream.current());
	  }
	
	  var brackets = "([{}])";
	  // This is a crude lookahead trick to try and notice that we're
	  // parsing the argument patterns for a fat-arrow function before we
	  // actually hit the arrow token. It only works if the arrow is on
	  // the same line as the arguments and there's no strange noise
	  // (comments) in between. Fallback is to only notice when we hit the
	  // arrow, and not declare the arguments as locals for the arrow
	  // body.
	  function findFatArrow(stream, state) {
	    if (state.fatArrowAt) state.fatArrowAt = null;
	    var arrow = stream.string.indexOf("=>", stream.start);
	    if (arrow < 0) return;
	
	    if (isTS) { // Try to skip TypeScript return type declarations after the arguments
	      var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow))
	      if (m) arrow = m.index
	    }
	
	    var depth = 0, sawSomething = false;
	    for (var pos = arrow - 1; pos >= 0; --pos) {
	      var ch = stream.string.charAt(pos);
	      var bracket = brackets.indexOf(ch);
	      if (bracket >= 0 && bracket < 3) {
	        if (!depth) { ++pos; break; }
	        if (--depth == 0) { if (ch == "(") sawSomething = true; break; }
	      } else if (bracket >= 3 && bracket < 6) {
	        ++depth;
	      } else if (wordRE.test(ch)) {
	        sawSomething = true;
	      } else if (/["'\/]/.test(ch)) {
	        return;
	      } else if (sawSomething && !depth) {
	        ++pos;
	        break;
	      }
	    }
	    if (sawSomething && !depth) state.fatArrowAt = pos;
	  }
	
	  // Parser
	
	  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true};
	
	  function JSLexical(indented, column, type, align, prev, info) {
	    this.indented = indented;
	    this.column = column;
	    this.type = type;
	    this.prev = prev;
	    this.info = info;
	    if (align != null) this.align = align;
	  }
	
	  function inScope(state, varname) {
	    for (var v = state.localVars; v; v = v.next)
	      if (v.name == varname) return true;
	    for (var cx = state.context; cx; cx = cx.prev) {
	      for (var v = cx.vars; v; v = v.next)
	        if (v.name == varname) return true;
	    }
	  }
	
	  function parseJS(state, style, type, content, stream) {
	    var cc = state.cc;
	    // Communicate our context to the combinators.
	    // (Less wasteful than consing up a hundred closures on every call.)
	    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;
	
	    if (!state.lexical.hasOwnProperty("align"))
	      state.lexical.align = true;
	
	    while(true) {
	      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
	      if (combinator(type, content)) {
	        while(cc.length && cc[cc.length - 1].lex)
	          cc.pop()();
	        if (cx.marked) return cx.marked;
	        if (type == "variable" && inScope(state, content)) return "variable-2";
	        return style;
	      }
	    }
	  }
	
	  // Combinator utils
	
	  var cx = {state: null, column: null, marked: null, cc: null};
	  function pass() {
	    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
	  }
	  function cont() {
	    pass.apply(null, arguments);
	    return true;
	  }
	  function register(varname) {
	    function inList(list) {
	      for (var v = list; v; v = v.next)
	        if (v.name == varname) return true;
	      return false;
	    }
	    var state = cx.state;
	    cx.marked = "def";
	    if (state.context) {
	      if (inList(state.localVars)) return;
	      state.localVars = {name: varname, next: state.localVars};
	    } else {
	      if (inList(state.globalVars)) return;
	      if (parserConfig.globalVars)
	        state.globalVars = {name: varname, next: state.globalVars};
	    }
	  }
	
	  // Combinators
	
	  var defaultVars = {name: "this", next: {name: "arguments"}};
	  function pushcontext() {
	    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
	    cx.state.localVars = defaultVars;
	  }
	  function popcontext() {
	    cx.state.localVars = cx.state.context.vars;
	    cx.state.context = cx.state.context.prev;
	  }
	  function pushlex(type, info) {
	    var result = function() {
	      var state = cx.state, indent = state.indented;
	      if (state.lexical.type == "stat") indent = state.lexical.indented;
	      else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
	        indent = outer.indented;
	      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
	    };
	    result.lex = true;
	    return result;
	  }
	  function poplex() {
	    var state = cx.state;
	    if (state.lexical.prev) {
	      if (state.lexical.type == ")")
	        state.indented = state.lexical.indented;
	      state.lexical = state.lexical.prev;
	    }
	  }
	  poplex.lex = true;
	
	  function expect(wanted) {
	    function exp(type) {
	      if (type == wanted) return cont();
	      else if (wanted == ";") return pass();
	      else return cont(exp);
	    };
	    return exp;
	  }
	
	  function statement(type, value) {
	    if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);
	    if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
	    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
	    if (type == "{") return cont(pushlex("}"), block, poplex);
	    if (type == ";") return cont();
	    if (type == "if") {
	      if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
	        cx.state.cc.pop()();
	      return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
	    }
	    if (type == "function") return cont(functiondef);
	    if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
	    if (type == "variable") return cont(pushlex("stat"), maybelabel);
	    if (type == "switch") return cont(pushlex("form"), parenExpr, pushlex("}", "switch"), expect("{"),
	                                      block, poplex, poplex);
	    if (type == "case") return cont(expression, expect(":"));
	    if (type == "default") return cont(expect(":"));
	    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
	                                     statement, poplex, popcontext);
	    if (type == "class") return cont(pushlex("form"), className, poplex);
	    if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
	    if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
	    if (type == "module") return cont(pushlex("form"), pattern, pushlex("}"), expect("{"), block, poplex, poplex)
	    if (type == "type") return cont(typeexpr, expect("operator"), typeexpr, expect(";"));
	    if (type == "async") return cont(statement)
	    return pass(pushlex("stat"), expression, expect(";"), poplex);
	  }
	  function expression(type) {
	    return expressionInner(type, false);
	  }
	  function expressionNoComma(type) {
	    return expressionInner(type, true);
	  }
	  function parenExpr(type) {
	    if (type != "(") return pass()
	    return cont(pushlex(")"), expression, expect(")"), poplex)
	  }
	  function expressionInner(type, noComma) {
	    if (cx.state.fatArrowAt == cx.stream.start) {
	      var body = noComma ? arrowBodyNoComma : arrowBody;
	      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(pattern, ")"), poplex, expect("=>"), body, popcontext);
	      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
	    }
	
	    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
	    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
	    if (type == "function") return cont(functiondef, maybeop);
	    if (type == "class") return cont(pushlex("form"), classExpression, poplex);
	    if (type == "keyword c" || type == "async") return cont(noComma ? maybeexpressionNoComma : maybeexpression);
	    if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
	    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
	    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
	    if (type == "{") return contCommasep(objprop, "}", null, maybeop);
	    if (type == "quasi") return pass(quasi, maybeop);
	    if (type == "new") return cont(maybeTarget(noComma));
	    return cont();
	  }
	  function maybeexpression(type) {
	    if (type.match(/[;\}\)\],]/)) return pass();
	    return pass(expression);
	  }
	  function maybeexpressionNoComma(type) {
	    if (type.match(/[;\}\)\],]/)) return pass();
	    return pass(expressionNoComma);
	  }
	
	  function maybeoperatorComma(type, value) {
	    if (type == ",") return cont(expression);
	    return maybeoperatorNoComma(type, value, false);
	  }
	  function maybeoperatorNoComma(type, value, noComma) {
	    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
	    var expr = noComma == false ? expression : expressionNoComma;
	    if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
	    if (type == "operator") {
	      if (/\+\+|--/.test(value)) return cont(me);
	      if (value == "?") return cont(expression, expect(":"), expr);
	      return cont(expr);
	    }
	    if (type == "quasi") { return pass(quasi, me); }
	    if (type == ";") return;
	    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
	    if (type == ".") return cont(property, me);
	    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
	  }
	  function quasi(type, value) {
	    if (type != "quasi") return pass();
	    if (value.slice(value.length - 2) != "${") return cont(quasi);
	    return cont(expression, continueQuasi);
	  }
	  function continueQuasi(type) {
	    if (type == "}") {
	      cx.marked = "string-2";
	      cx.state.tokenize = tokenQuasi;
	      return cont(quasi);
	    }
	  }
	  function arrowBody(type) {
	    findFatArrow(cx.stream, cx.state);
	    return pass(type == "{" ? statement : expression);
	  }
	  function arrowBodyNoComma(type) {
	    findFatArrow(cx.stream, cx.state);
	    return pass(type == "{" ? statement : expressionNoComma);
	  }
	  function maybeTarget(noComma) {
	    return function(type) {
	      if (type == ".") return cont(noComma ? targetNoComma : target);
	      else return pass(noComma ? expressionNoComma : expression);
	    };
	  }
	  function target(_, value) {
	    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorComma); }
	  }
	  function targetNoComma(_, value) {
	    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorNoComma); }
	  }
	  function maybelabel(type) {
	    if (type == ":") return cont(poplex, statement);
	    return pass(maybeoperatorComma, expect(";"), poplex);
	  }
	  function property(type) {
	    if (type == "variable") {cx.marked = "property"; return cont();}
	  }
	  function objprop(type, value) {
	    if (type == "async") {
	      cx.marked = "property";
	      return cont(objprop);
	    } else if (type == "variable" || cx.style == "keyword") {
	      cx.marked = "property";
	      if (value == "get" || value == "set") return cont(getterSetter);
	      return cont(afterprop);
	    } else if (type == "number" || type == "string") {
	      cx.marked = jsonldMode ? "property" : (cx.style + " property");
	      return cont(afterprop);
	    } else if (type == "jsonld-keyword") {
	      return cont(afterprop);
	    } else if (type == "modifier") {
	      return cont(objprop)
	    } else if (type == "[") {
	      return cont(expression, expect("]"), afterprop);
	    } else if (type == "spread") {
	      return cont(expression);
	    } else if (type == ":") {
	      return pass(afterprop)
	    }
	  }
	  function getterSetter(type) {
	    if (type != "variable") return pass(afterprop);
	    cx.marked = "property";
	    return cont(functiondef);
	  }
	  function afterprop(type) {
	    if (type == ":") return cont(expressionNoComma);
	    if (type == "(") return pass(functiondef);
	  }
	  function commasep(what, end) {
	    function proceed(type, value) {
	      if (type == ",") {
	        var lex = cx.state.lexical;
	        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
	        return cont(function(type, value) {
	          if (type == end || value == end) return pass()
	          return pass(what)
	        }, proceed);
	      }
	      if (type == end || value == end) return cont();
	      return cont(expect(end));
	    }
	    return function(type, value) {
	      if (type == end || value == end) return cont();
	      return pass(what, proceed);
	    };
	  }
	  function contCommasep(what, end, info) {
	    for (var i = 3; i < arguments.length; i++)
	      cx.cc.push(arguments[i]);
	    return cont(pushlex(end, info), commasep(what, end), poplex);
	  }
	  function block(type) {
	    if (type == "}") return cont();
	    return pass(statement, block);
	  }
	  function maybetype(type, value) {
	    if (isTS) {
	      if (type == ":") return cont(typeexpr);
	      if (value == "?") return cont(maybetype);
	    }
	  }
	  function typeexpr(type) {
	    if (type == "variable") {cx.marked = "variable-3"; return cont(afterType);}
	    if (type == "string" || type == "number" || type == "atom") return cont(afterType);
	    if (type == "{") return cont(commasep(typeprop, "}"))
	    if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType)
	  }
	  function maybeReturnType(type) {
	    if (type == "=>") return cont(typeexpr)
	  }
	  function typeprop(type) {
	    if (type == "variable" || cx.style == "keyword") {
	      cx.marked = "property"
	      return cont(typeprop)
	    } else if (type == ":") {
	      return cont(typeexpr)
	    }
	  }
	  function typearg(type) {
	    if (type == "variable") return cont(typearg)
	    else if (type == ":") return cont(typeexpr)
	  }
	  function afterType(type, value) {
	    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
	    if (value == "|" || type == ".") return cont(typeexpr)
	    if (type == "[") return cont(expect("]"), afterType)
	  }
	  function vardef() {
	    return pass(pattern, maybetype, maybeAssign, vardefCont);
	  }
	  function pattern(type, value) {
	    if (type == "modifier") return cont(pattern)
	    if (type == "variable") { register(value); return cont(); }
	    if (type == "spread") return cont(pattern);
	    if (type == "[") return contCommasep(pattern, "]");
	    if (type == "{") return contCommasep(proppattern, "}");
	  }
	  function proppattern(type, value) {
	    if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
	      register(value);
	      return cont(maybeAssign);
	    }
	    if (type == "variable") cx.marked = "property";
	    if (type == "spread") return cont(pattern);
	    if (type == "}") return pass();
	    return cont(expect(":"), pattern, maybeAssign);
	  }
	  function maybeAssign(_type, value) {
	    if (value == "=") return cont(expressionNoComma);
	  }
	  function vardefCont(type) {
	    if (type == ",") return cont(vardef);
	  }
	  function maybeelse(type, value) {
	    if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
	  }
	  function forspec(type) {
	    if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex);
	  }
	  function forspec1(type) {
	    if (type == "var") return cont(vardef, expect(";"), forspec2);
	    if (type == ";") return cont(forspec2);
	    if (type == "variable") return cont(formaybeinof);
	    return pass(expression, expect(";"), forspec2);
	  }
	  function formaybeinof(_type, value) {
	    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
	    return cont(maybeoperatorComma, forspec2);
	  }
	  function forspec2(type, value) {
	    if (type == ";") return cont(forspec3);
	    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
	    return pass(expression, expect(";"), forspec3);
	  }
	  function forspec3(type) {
	    if (type != ")") cont(expression);
	  }
	  function functiondef(type, value) {
	    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
	    if (type == "variable") {register(value); return cont(functiondef);}
	    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, maybetype, statement, popcontext);
	  }
	  function funarg(type) {
	    if (type == "spread") return cont(funarg);
	    return pass(pattern, maybetype, maybeAssign);
	  }
	  function classExpression(type, value) {
	    // Class expressions may have an optional name.
	    if (type == "variable") return className(type, value);
	    return classNameAfter(type, value);
	  }
	  function className(type, value) {
	    if (type == "variable") {register(value); return cont(classNameAfter);}
	  }
	  function classNameAfter(type, value) {
	    if (value == "extends" || value == "implements") return cont(isTS ? typeexpr : expression, classNameAfter);
	    if (type == "{") return cont(pushlex("}"), classBody, poplex);
	  }
	  function classBody(type, value) {
	    if (type == "variable" || cx.style == "keyword") {
	      if ((value == "static" || value == "get" || value == "set" ||
	           (isTS && (value == "public" || value == "private" || value == "protected" || value == "readonly" || value == "abstract"))) &&
	          cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false)) {
	        cx.marked = "keyword";
	        return cont(classBody);
	      }
	      cx.marked = "property";
	      return cont(isTS ? classfield : functiondef, classBody);
	    }
	    if (value == "*") {
	      cx.marked = "keyword";
	      return cont(classBody);
	    }
	    if (type == ";") return cont(classBody);
	    if (type == "}") return cont();
	  }
	  function classfield(type, value) {
	    if (value == "?") return cont(classfield)
	    if (type == ":") return cont(typeexpr, maybeAssign)
	    return pass(functiondef)
	  }
	  function afterExport(type, value) {
	    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
	    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
	    if (type == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
	    return pass(statement);
	  }
	  function exportField(type, value) {
	    if (value == "as") { cx.marked = "keyword"; return cont(expect("variable")); }
	    if (type == "variable") return pass(expressionNoComma, exportField);
	  }
	  function afterImport(type) {
	    if (type == "string") return cont();
	    return pass(importSpec, maybeMoreImports, maybeFrom);
	  }
	  function importSpec(type, value) {
	    if (type == "{") return contCommasep(importSpec, "}");
	    if (type == "variable") register(value);
	    if (value == "*") cx.marked = "keyword";
	    return cont(maybeAs);
	  }
	  function maybeMoreImports(type) {
	    if (type == ",") return cont(importSpec, maybeMoreImports)
	  }
	  function maybeAs(_type, value) {
	    if (value == "as") { cx.marked = "keyword"; return cont(importSpec); }
	  }
	  function maybeFrom(_type, value) {
	    if (value == "from") { cx.marked = "keyword"; return cont(expression); }
	  }
	  function arrayLiteral(type) {
	    if (type == "]") return cont();
	    return pass(commasep(expressionNoComma, "]"));
	  }
	
	  function isContinuedStatement(state, textAfter) {
	    return state.lastType == "operator" || state.lastType == "," ||
	      isOperatorChar.test(textAfter.charAt(0)) ||
	      /[,.]/.test(textAfter.charAt(0));
	  }
	
	  // Interface
	
	  return {
	    startState: function(basecolumn) {
	      var state = {
	        tokenize: tokenBase,
	        lastType: "sof",
	        cc: [],
	        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
	        localVars: parserConfig.localVars,
	        context: parserConfig.localVars && {vars: parserConfig.localVars},
	        indented: basecolumn || 0
	      };
	      if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
	        state.globalVars = parserConfig.globalVars;
	      return state;
	    },
	
	    token: function(stream, state) {
	      if (stream.sol()) {
	        if (!state.lexical.hasOwnProperty("align"))
	          state.lexical.align = false;
	        state.indented = stream.indentation();
	        findFatArrow(stream, state);
	      }
	      if (state.tokenize != tokenComment && stream.eatSpace()) return null;
	      var style = state.tokenize(stream, state);
	      if (type == "comment") return style;
	      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
	      return parseJS(state, style, type, content, stream);
	    },
	
	    indent: function(state, textAfter) {
	      if (state.tokenize == tokenComment) return CodeMirror.Pass;
	      if (state.tokenize != tokenBase) return 0;
	      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top
	      // Kludge to prevent 'maybelse' from blocking lexical scope pops
	      if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
	        var c = state.cc[i];
	        if (c == poplex) lexical = lexical.prev;
	        else if (c != maybeelse) break;
	      }
	      while ((lexical.type == "stat" || lexical.type == "form") &&
	             (firstChar == "}" || ((top = state.cc[state.cc.length - 1]) &&
	                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&
	                                   !/^[,\.=+\-*:?[\(]/.test(textAfter))))
	        lexical = lexical.prev;
	      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
	        lexical = lexical.prev;
	      var type = lexical.type, closing = firstChar == type;
	
	      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);
	      else if (type == "form" && firstChar == "{") return lexical.indented;
	      else if (type == "form") return lexical.indented + indentUnit;
	      else if (type == "stat")
	        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
	      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
	        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
	      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
	      else return lexical.indented + (closing ? 0 : indentUnit);
	    },
	
	    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
	    blockCommentStart: jsonMode ? null : "/*",
	    blockCommentEnd: jsonMode ? null : "*/",
	    lineComment: jsonMode ? null : "//",
	    fold: "brace",
	    closeBrackets: "()[]{}''\"\"``",
	
	    helperType: jsonMode ? "json" : "javascript",
	    jsonldMode: jsonldMode,
	    jsonMode: jsonMode,
	
	    expressionAllowed: expressionAllowed,
	    skipExpression: function(state) {
	      var top = state.cc[state.cc.length - 1]
	      if (top == expression || top == expressionNoComma) state.cc.pop()
	    }
	  };
	});
	
	CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);
	
	CodeMirror.defineMIME("text/javascript", "javascript");
	CodeMirror.defineMIME("text/ecmascript", "javascript");
	CodeMirror.defineMIME("application/javascript", "javascript");
	CodeMirror.defineMIME("application/x-javascript", "javascript");
	CodeMirror.defineMIME("application/ecmascript", "javascript");
	CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
	CodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});
	CodeMirror.defineMIME("application/ld+json", {name: "javascript", jsonld: true});
	CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
	CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });
	
	});


/***/ },
/* 517 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(513), __webpack_require__(518), __webpack_require__(516), __webpack_require__(519));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror", "../xml/xml", "../javascript/javascript", "../css/css"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";
	
	  var defaultTags = {
	    script: [
	      ["lang", /(javascript|babel)/i, "javascript"],
	      ["type", /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^$/i, "javascript"],
	      ["type", /./, "text/plain"],
	      [null, null, "javascript"]
	    ],
	    style:  [
	      ["lang", /^css$/i, "css"],
	      ["type", /^(text\/)?(x-)?(stylesheet|css)$/i, "css"],
	      ["type", /./, "text/plain"],
	      [null, null, "css"]
	    ]
	  };
	
	  function maybeBackup(stream, pat, style) {
	    var cur = stream.current(), close = cur.search(pat);
	    if (close > -1) {
	      stream.backUp(cur.length - close);
	    } else if (cur.match(/<\/?$/)) {
	      stream.backUp(cur.length);
	      if (!stream.match(pat, false)) stream.match(cur);
	    }
	    return style;
	  }
	
	  var attrRegexpCache = {};
	  function getAttrRegexp(attr) {
	    var regexp = attrRegexpCache[attr];
	    if (regexp) return regexp;
	    return attrRegexpCache[attr] = new RegExp("\\s+" + attr + "\\s*=\\s*('|\")?([^'\"]+)('|\")?\\s*");
	  }
	
	  function getAttrValue(text, attr) {
	    var match = text.match(getAttrRegexp(attr))
	    return match ? /^\s*(.*?)\s*$/.exec(match[2])[1] : ""
	  }
	
	  function getTagRegexp(tagName, anchored) {
	    return new RegExp((anchored ? "^" : "") + "<\/\s*" + tagName + "\s*>", "i");
	  }
	
	  function addTags(from, to) {
	    for (var tag in from) {
	      var dest = to[tag] || (to[tag] = []);
	      var source = from[tag];
	      for (var i = source.length - 1; i >= 0; i--)
	        dest.unshift(source[i])
	    }
	  }
	
	  function findMatchingMode(tagInfo, tagText) {
	    for (var i = 0; i < tagInfo.length; i++) {
	      var spec = tagInfo[i];
	      if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2];
	    }
	  }
	
	  CodeMirror.defineMode("htmlmixed", function (config, parserConfig) {
	    var htmlMode = CodeMirror.getMode(config, {
	      name: "xml",
	      htmlMode: true,
	      multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,
	      multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag
	    });
	
	    var tags = {};
	    var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;
	    addTags(defaultTags, tags);
	    if (configTags) addTags(configTags, tags);
	    if (configScript) for (var i = configScript.length - 1; i >= 0; i--)
	      tags.script.unshift(["type", configScript[i].matches, configScript[i].mode])
	
	    function html(stream, state) {
	      var style = htmlMode.token(stream, state.htmlState), tag = /\btag\b/.test(style), tagName
	      if (tag && !/[<>\s\/]/.test(stream.current()) &&
	          (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) &&
	          tags.hasOwnProperty(tagName)) {
	        state.inTag = tagName + " "
	      } else if (state.inTag && tag && />$/.test(stream.current())) {
	        var inTag = /^([\S]+) (.*)/.exec(state.inTag)
	        state.inTag = null
	        var modeSpec = stream.current() == ">" && findMatchingMode(tags[inTag[1]], inTag[2])
	        var mode = CodeMirror.getMode(config, modeSpec)
	        var endTagA = getTagRegexp(inTag[1], true), endTag = getTagRegexp(inTag[1], false);
	        state.token = function (stream, state) {
	          if (stream.match(endTagA, false)) {
	            state.token = html;
	            state.localState = state.localMode = null;
	            return null;
	          }
	          return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));
	        };
	        state.localMode = mode;
	        state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, ""));
	      } else if (state.inTag) {
	        state.inTag += stream.current()
	        if (stream.eol()) state.inTag += " "
	      }
	      return style;
	    };
	
	    return {
	      startState: function () {
	        var state = CodeMirror.startState(htmlMode);
	        return {token: html, inTag: null, localMode: null, localState: null, htmlState: state};
	      },
	
	      copyState: function (state) {
	        var local;
	        if (state.localState) {
	          local = CodeMirror.copyState(state.localMode, state.localState);
	        }
	        return {token: state.token, inTag: state.inTag,
	                localMode: state.localMode, localState: local,
	                htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};
	      },
	
	      token: function (stream, state) {
	        return state.token(stream, state);
	      },
	
	      indent: function (state, textAfter) {
	        if (!state.localMode || /^\s*<\//.test(textAfter))
	          return htmlMode.indent(state.htmlState, textAfter);
	        else if (state.localMode.indent)
	          return state.localMode.indent(state.localState, textAfter);
	        else
	          return CodeMirror.Pass;
	      },
	
	      innerMode: function (state) {
	        return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};
	      }
	    };
	  }, "xml", "javascript", "css");
	
	  CodeMirror.defineMIME("text/html", "htmlmixed");
	});


/***/ },
/* 518 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(513));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	"use strict";
	
	var htmlConfig = {
	  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
	                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
	                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
	                    'track': true, 'wbr': true, 'menuitem': true},
	  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
	                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
	                     'th': true, 'tr': true},
	  contextGrabbers: {
	    'dd': {'dd': true, 'dt': true},
	    'dt': {'dd': true, 'dt': true},
	    'li': {'li': true},
	    'option': {'option': true, 'optgroup': true},
	    'optgroup': {'optgroup': true},
	    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
	          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
	          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
	          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
	          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},
	    'rp': {'rp': true, 'rt': true},
	    'rt': {'rp': true, 'rt': true},
	    'tbody': {'tbody': true, 'tfoot': true},
	    'td': {'td': true, 'th': true},
	    'tfoot': {'tbody': true},
	    'th': {'td': true, 'th': true},
	    'thead': {'tbody': true, 'tfoot': true},
	    'tr': {'tr': true}
	  },
	  doNotIndent: {"pre": true},
	  allowUnquoted: true,
	  allowMissing: true,
	  caseFold: true
	}
	
	var xmlConfig = {
	  autoSelfClosers: {},
	  implicitlyClosed: {},
	  contextGrabbers: {},
	  doNotIndent: {},
	  allowUnquoted: false,
	  allowMissing: false,
	  caseFold: false
	}
	
	CodeMirror.defineMode("xml", function(editorConf, config_) {
	  var indentUnit = editorConf.indentUnit
	  var config = {}
	  var defaults = config_.htmlMode ? htmlConfig : xmlConfig
	  for (var prop in defaults) config[prop] = defaults[prop]
	  for (var prop in config_) config[prop] = config_[prop]
	
	  // Return variables for tokenizers
	  var type, setStyle;
	
	  function inText(stream, state) {
	    function chain(parser) {
	      state.tokenize = parser;
	      return parser(stream, state);
	    }
	
	    var ch = stream.next();
	    if (ch == "<") {
	      if (stream.eat("!")) {
	        if (stream.eat("[")) {
	          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
	          else return null;
	        } else if (stream.match("--")) {
	          return chain(inBlock("comment", "-->"));
	        } else if (stream.match("DOCTYPE", true, true)) {
	          stream.eatWhile(/[\w\._\-]/);
	          return chain(doctype(1));
	        } else {
	          return null;
	        }
	      } else if (stream.eat("?")) {
	        stream.eatWhile(/[\w\._\-]/);
	        state.tokenize = inBlock("meta", "?>");
	        return "meta";
	      } else {
	        type = stream.eat("/") ? "closeTag" : "openTag";
	        state.tokenize = inTag;
	        return "tag bracket";
	      }
	    } else if (ch == "&") {
	      var ok;
	      if (stream.eat("#")) {
	        if (stream.eat("x")) {
	          ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
	        } else {
	          ok = stream.eatWhile(/[\d]/) && stream.eat(";");
	        }
	      } else {
	        ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
	      }
	      return ok ? "atom" : "error";
	    } else {
	      stream.eatWhile(/[^&<]/);
	      return null;
	    }
	  }
	  inText.isInText = true;
	
	  function inTag(stream, state) {
	    var ch = stream.next();
	    if (ch == ">" || (ch == "/" && stream.eat(">"))) {
	      state.tokenize = inText;
	      type = ch == ">" ? "endTag" : "selfcloseTag";
	      return "tag bracket";
	    } else if (ch == "=") {
	      type = "equals";
	      return null;
	    } else if (ch == "<") {
	      state.tokenize = inText;
	      state.state = baseState;
	      state.tagName = state.tagStart = null;
	      var next = state.tokenize(stream, state);
	      return next ? next + " tag error" : "tag error";
	    } else if (/[\'\"]/.test(ch)) {
	      state.tokenize = inAttribute(ch);
	      state.stringStartCol = stream.column();
	      return state.tokenize(stream, state);
	    } else {
	      stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
	      return "word";
	    }
	  }
	
	  function inAttribute(quote) {
	    var closure = function(stream, state) {
	      while (!stream.eol()) {
	        if (stream.next() == quote) {
	          state.tokenize = inTag;
	          break;
	        }
	      }
	      return "string";
	    };
	    closure.isInAttribute = true;
	    return closure;
	  }
	
	  function inBlock(style, terminator) {
	    return function(stream, state) {
	      while (!stream.eol()) {
	        if (stream.match(terminator)) {
	          state.tokenize = inText;
	          break;
	        }
	        stream.next();
	      }
	      return style;
	    };
	  }
	  function doctype(depth) {
	    return function(stream, state) {
	      var ch;
	      while ((ch = stream.next()) != null) {
	        if (ch == "<") {
	          state.tokenize = doctype(depth + 1);
	          return state.tokenize(stream, state);
	        } else if (ch == ">") {
	          if (depth == 1) {
	            state.tokenize = inText;
	            break;
	          } else {
	            state.tokenize = doctype(depth - 1);
	            return state.tokenize(stream, state);
	          }
	        }
	      }
	      return "meta";
	    };
	  }
	
	  function Context(state, tagName, startOfLine) {
	    this.prev = state.context;
	    this.tagName = tagName;
	    this.indent = state.indented;
	    this.startOfLine = startOfLine;
	    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))
	      this.noIndent = true;
	  }
	  function popContext(state) {
	    if (state.context) state.context = state.context.prev;
	  }
	  function maybePopContext(state, nextTagName) {
	    var parentTagName;
	    while (true) {
	      if (!state.context) {
	        return;
	      }
	      parentTagName = state.context.tagName;
	      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||
	          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
	        return;
	      }
	      popContext(state);
	    }
	  }
	
	  function baseState(type, stream, state) {
	    if (type == "openTag") {
	      state.tagStart = stream.column();
	      return tagNameState;
	    } else if (type == "closeTag") {
	      return closeTagNameState;
	    } else {
	      return baseState;
	    }
	  }
	  function tagNameState(type, stream, state) {
	    if (type == "word") {
	      state.tagName = stream.current();
	      setStyle = "tag";
	      return attrState;
	    } else {
	      setStyle = "error";
	      return tagNameState;
	    }
	  }
	  function closeTagNameState(type, stream, state) {
	    if (type == "word") {
	      var tagName = stream.current();
	      if (state.context && state.context.tagName != tagName &&
	          config.implicitlyClosed.hasOwnProperty(state.context.tagName))
	        popContext(state);
	      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {
	        setStyle = "tag";
	        return closeState;
	      } else {
	        setStyle = "tag error";
	        return closeStateErr;
	      }
	    } else {
	      setStyle = "error";
	      return closeStateErr;
	    }
	  }
	
	  function closeState(type, _stream, state) {
	    if (type != "endTag") {
	      setStyle = "error";
	      return closeState;
	    }
	    popContext(state);
	    return baseState;
	  }
	  function closeStateErr(type, stream, state) {
	    setStyle = "error";
	    return closeState(type, stream, state);
	  }
	
	  function attrState(type, _stream, state) {
	    if (type == "word") {
	      setStyle = "attribute";
	      return attrEqState;
	    } else if (type == "endTag" || type == "selfcloseTag") {
	      var tagName = state.tagName, tagStart = state.tagStart;
	      state.tagName = state.tagStart = null;
	      if (type == "selfcloseTag" ||
	          config.autoSelfClosers.hasOwnProperty(tagName)) {
	        maybePopContext(state, tagName);
	      } else {
	        maybePopContext(state, tagName);
	        state.context = new Context(state, tagName, tagStart == state.indented);
	      }
	      return baseState;
	    }
	    setStyle = "error";
	    return attrState;
	  }
	  function attrEqState(type, stream, state) {
	    if (type == "equals") return attrValueState;
	    if (!config.allowMissing) setStyle = "error";
	    return attrState(type, stream, state);
	  }
	  function attrValueState(type, stream, state) {
	    if (type == "string") return attrContinuedState;
	    if (type == "word" && config.allowUnquoted) {setStyle = "string"; return attrState;}
	    setStyle = "error";
	    return attrState(type, stream, state);
	  }
	  function attrContinuedState(type, stream, state) {
	    if (type == "string") return attrContinuedState;
	    return attrState(type, stream, state);
	  }
	
	  return {
	    startState: function(baseIndent) {
	      var state = {tokenize: inText,
	                   state: baseState,
	                   indented: baseIndent || 0,
	                   tagName: null, tagStart: null,
	                   context: null}
	      if (baseIndent != null) state.baseIndent = baseIndent
	      return state
	    },
	
	    token: function(stream, state) {
	      if (!state.tagName && stream.sol())
	        state.indented = stream.indentation();
	
	      if (stream.eatSpace()) return null;
	      type = null;
	      var style = state.tokenize(stream, state);
	      if ((style || type) && style != "comment") {
	        setStyle = null;
	        state.state = state.state(type || style, stream, state);
	        if (setStyle)
	          style = setStyle == "error" ? style + " error" : setStyle;
	      }
	      return style;
	    },
	
	    indent: function(state, textAfter, fullLine) {
	      var context = state.context;
	      // Indent multi-line strings (e.g. css).
	      if (state.tokenize.isInAttribute) {
	        if (state.tagStart == state.indented)
	          return state.stringStartCol + 1;
	        else
	          return state.indented + indentUnit;
	      }
	      if (context && context.noIndent) return CodeMirror.Pass;
	      if (state.tokenize != inTag && state.tokenize != inText)
	        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
	      // Indent the starts of attribute names.
	      if (state.tagName) {
	        if (config.multilineTagIndentPastTag !== false)
	          return state.tagStart + state.tagName.length + 2;
	        else
	          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
	      }
	      if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
	      var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
	      if (tagAfter && tagAfter[1]) { // Closing tag spotted
	        while (context) {
	          if (context.tagName == tagAfter[2]) {
	            context = context.prev;
	            break;
	          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {
	            context = context.prev;
	          } else {
	            break;
	          }
	        }
	      } else if (tagAfter) { // Opening tag spotted
	        while (context) {
	          var grabbers = config.contextGrabbers[context.tagName];
	          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))
	            context = context.prev;
	          else
	            break;
	        }
	      }
	      while (context && context.prev && !context.startOfLine)
	        context = context.prev;
	      if (context) return context.indent + indentUnit;
	      else return state.baseIndent || 0;
	    },
	
	    electricInput: /<\/[\s\w:]+>$/,
	    blockCommentStart: "<!--",
	    blockCommentEnd: "-->",
	
	    configuration: config.htmlMode ? "html" : "xml",
	    helperType: config.htmlMode ? "html" : "xml",
	
	    skipAttribute: function(state) {
	      if (state.state == attrValueState)
	        state.state = attrState
	    }
	  };
	});
	
	CodeMirror.defineMIME("text/xml", "xml");
	CodeMirror.defineMIME("application/xml", "xml");
	if (!CodeMirror.mimeModes.hasOwnProperty("text/html"))
	  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});
	
	});


/***/ },
/* 519 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(513));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	"use strict";
	
	CodeMirror.defineMode("css", function(config, parserConfig) {
	  var inline = parserConfig.inline
	  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");
	
	  var indentUnit = config.indentUnit,
	      tokenHooks = parserConfig.tokenHooks,
	      documentTypes = parserConfig.documentTypes || {},
	      mediaTypes = parserConfig.mediaTypes || {},
	      mediaFeatures = parserConfig.mediaFeatures || {},
	      mediaValueKeywords = parserConfig.mediaValueKeywords || {},
	      propertyKeywords = parserConfig.propertyKeywords || {},
	      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},
	      fontProperties = parserConfig.fontProperties || {},
	      counterDescriptors = parserConfig.counterDescriptors || {},
	      colorKeywords = parserConfig.colorKeywords || {},
	      valueKeywords = parserConfig.valueKeywords || {},
	      allowNested = parserConfig.allowNested,
	      supportsAtComponent = parserConfig.supportsAtComponent === true;
	
	  var type, override;
	  function ret(style, tp) { type = tp; return style; }
	
	  // Tokenizers
	
	  function tokenBase(stream, state) {
	    var ch = stream.next();
	    if (tokenHooks[ch]) {
	      var result = tokenHooks[ch](stream, state);
	      if (result !== false) return result;
	    }
	    if (ch == "@") {
	      stream.eatWhile(/[\w\\\-]/);
	      return ret("def", stream.current());
	    } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
	      return ret(null, "compare");
	    } else if (ch == "\"" || ch == "'") {
	      state.tokenize = tokenString(ch);
	      return state.tokenize(stream, state);
	    } else if (ch == "#") {
	      stream.eatWhile(/[\w\\\-]/);
	      return ret("atom", "hash");
	    } else if (ch == "!") {
	      stream.match(/^\s*\w*/);
	      return ret("keyword", "important");
	    } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
	      stream.eatWhile(/[\w.%]/);
	      return ret("number", "unit");
	    } else if (ch === "-") {
	      if (/[\d.]/.test(stream.peek())) {
	        stream.eatWhile(/[\w.%]/);
	        return ret("number", "unit");
	      } else if (stream.match(/^-[\w\\\-]+/)) {
	        stream.eatWhile(/[\w\\\-]/);
	        if (stream.match(/^\s*:/, false))
	          return ret("variable-2", "variable-definition");
	        return ret("variable-2", "variable");
	      } else if (stream.match(/^\w+-/)) {
	        return ret("meta", "meta");
	      }
	    } else if (/[,+>*\/]/.test(ch)) {
	      return ret(null, "select-op");
	    } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
	      return ret("qualifier", "qualifier");
	    } else if (/[:;{}\[\]\(\)]/.test(ch)) {
	      return ret(null, ch);
	    } else if ((ch == "u" && stream.match(/rl(-prefix)?\(/)) ||
	               (ch == "d" && stream.match("omain(")) ||
	               (ch == "r" && stream.match("egexp("))) {
	      stream.backUp(1);
	      state.tokenize = tokenParenthesized;
	      return ret("property", "word");
	    } else if (/[\w\\\-]/.test(ch)) {
	      stream.eatWhile(/[\w\\\-]/);
	      return ret("property", "word");
	    } else {
	      return ret(null, null);
	    }
	  }
	
	  function tokenString(quote) {
	    return function(stream, state) {
	      var escaped = false, ch;
	      while ((ch = stream.next()) != null) {
	        if (ch == quote && !escaped) {
	          if (quote == ")") stream.backUp(1);
	          break;
	        }
	        escaped = !escaped && ch == "\\";
	      }
	      if (ch == quote || !escaped && quote != ")") state.tokenize = null;
	      return ret("string", "string");
	    };
	  }
	
	  function tokenParenthesized(stream, state) {
	    stream.next(); // Must be '('
	    if (!stream.match(/\s*[\"\')]/, false))
	      state.tokenize = tokenString(")");
	    else
	      state.tokenize = null;
	    return ret(null, "(");
	  }
	
	  // Context management
	
	  function Context(type, indent, prev) {
	    this.type = type;
	    this.indent = indent;
	    this.prev = prev;
	  }
	
	  function pushContext(state, stream, type, indent) {
	    state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);
	    return type;
	  }
	
	  function popContext(state) {
	    if (state.context.prev)
	      state.context = state.context.prev;
	    return state.context.type;
	  }
	
	  function pass(type, stream, state) {
	    return states[state.context.type](type, stream, state);
	  }
	  function popAndPass(type, stream, state, n) {
	    for (var i = n || 1; i > 0; i--)
	      state.context = state.context.prev;
	    return pass(type, stream, state);
	  }
	
	  // Parser
	
	  function wordAsValue(stream) {
	    var word = stream.current().toLowerCase();
	    if (valueKeywords.hasOwnProperty(word))
	      override = "atom";
	    else if (colorKeywords.hasOwnProperty(word))
	      override = "keyword";
	    else
	      override = "variable";
	  }
	
	  var states = {};
	
	  states.top = function(type, stream, state) {
	    if (type == "{") {
	      return pushContext(state, stream, "block");
	    } else if (type == "}" && state.context.prev) {
	      return popContext(state);
	    } else if (supportsAtComponent && /@component/.test(type)) {
	      return pushContext(state, stream, "atComponentBlock");
	    } else if (/^@(-moz-)?document$/.test(type)) {
	      return pushContext(state, stream, "documentTypes");
	    } else if (/^@(media|supports|(-moz-)?document|import)$/.test(type)) {
	      return pushContext(state, stream, "atBlock");
	    } else if (/^@(font-face|counter-style)/.test(type)) {
	      state.stateArg = type;
	      return "restricted_atBlock_before";
	    } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/.test(type)) {
	      return "keyframes";
	    } else if (type && type.charAt(0) == "@") {
	      return pushContext(state, stream, "at");
	    } else if (type == "hash") {
	      override = "builtin";
	    } else if (type == "word") {
	      override = "tag";
	    } else if (type == "variable-definition") {
	      return "maybeprop";
	    } else if (type == "interpolation") {
	      return pushContext(state, stream, "interpolation");
	    } else if (type == ":") {
	      return "pseudo";
	    } else if (allowNested && type == "(") {
	      return pushContext(state, stream, "parens");
	    }
	    return state.context.type;
	  };
	
	  states.block = function(type, stream, state) {
	    if (type == "word") {
	      var word = stream.current().toLowerCase();
	      if (propertyKeywords.hasOwnProperty(word)) {
	        override = "property";
	        return "maybeprop";
	      } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {
	        override = "string-2";
	        return "maybeprop";
	      } else if (allowNested) {
	        override = stream.match(/^\s*:(?:\s|$)/, false) ? "property" : "tag";
	        return "block";
	      } else {
	        override += " error";
	        return "maybeprop";
	      }
	    } else if (type == "meta") {
	      return "block";
	    } else if (!allowNested && (type == "hash" || type == "qualifier")) {
	      override = "error";
	      return "block";
	    } else {
	      return states.top(type, stream, state);
	    }
	  };
	
	  states.maybeprop = function(type, stream, state) {
	    if (type == ":") return pushContext(state, stream, "prop");
	    return pass(type, stream, state);
	  };
	
	  states.prop = function(type, stream, state) {
	    if (type == ";") return popContext(state);
	    if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");
	    if (type == "}" || type == "{") return popAndPass(type, stream, state);
	    if (type == "(") return pushContext(state, stream, "parens");
	
	    if (type == "hash" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {
	      override += " error";
	    } else if (type == "word") {
	      wordAsValue(stream);
	    } else if (type == "interpolation") {
	      return pushContext(state, stream, "interpolation");
	    }
	    return "prop";
	  };
	
	  states.propBlock = function(type, _stream, state) {
	    if (type == "}") return popContext(state);
	    if (type == "word") { override = "property"; return "maybeprop"; }
	    return state.context.type;
	  };
	
	  states.parens = function(type, stream, state) {
	    if (type == "{" || type == "}") return popAndPass(type, stream, state);
	    if (type == ")") return popContext(state);
	    if (type == "(") return pushContext(state, stream, "parens");
	    if (type == "interpolation") return pushContext(state, stream, "interpolation");
	    if (type == "word") wordAsValue(stream);
	    return "parens";
	  };
	
	  states.pseudo = function(type, stream, state) {
	    if (type == "word") {
	      override = "variable-3";
	      return state.context.type;
	    }
	    return pass(type, stream, state);
	  };
	
	  states.documentTypes = function(type, stream, state) {
	    if (type == "word" && documentTypes.hasOwnProperty(stream.current())) {
	      override = "tag";
	      return state.context.type;
	    } else {
	      return states.atBlock(type, stream, state);
	    }
	  };
	
	  states.atBlock = function(type, stream, state) {
	    if (type == "(") return pushContext(state, stream, "atBlock_parens");
	    if (type == "}" || type == ";") return popAndPass(type, stream, state);
	    if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");
	
	    if (type == "interpolation") return pushContext(state, stream, "interpolation");
	
	    if (type == "word") {
	      var word = stream.current().toLowerCase();
	      if (word == "only" || word == "not" || word == "and" || word == "or")
	        override = "keyword";
	      else if (mediaTypes.hasOwnProperty(word))
	        override = "attribute";
	      else if (mediaFeatures.hasOwnProperty(word))
	        override = "property";
	      else if (mediaValueKeywords.hasOwnProperty(word))
	        override = "keyword";
	      else if (propertyKeywords.hasOwnProperty(word))
	        override = "property";
	      else if (nonStandardPropertyKeywords.hasOwnProperty(word))
	        override = "string-2";
	      else if (valueKeywords.hasOwnProperty(word))
	        override = "atom";
	      else if (colorKeywords.hasOwnProperty(word))
	        override = "keyword";
	      else
	        override = "error";
	    }
	    return state.context.type;
	  };
	
	  states.atComponentBlock = function(type, stream, state) {
	    if (type == "}")
	      return popAndPass(type, stream, state);
	    if (type == "{")
	      return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", false);
	    if (type == "word")
	      override = "error";
	    return state.context.type;
	  };
	
	  states.atBlock_parens = function(type, stream, state) {
	    if (type == ")") return popContext(state);
	    if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);
	    return states.atBlock(type, stream, state);
	  };
	
	  states.restricted_atBlock_before = function(type, stream, state) {
	    if (type == "{")
	      return pushContext(state, stream, "restricted_atBlock");
	    if (type == "word" && state.stateArg == "@counter-style") {
	      override = "variable";
	      return "restricted_atBlock_before";
	    }
	    return pass(type, stream, state);
	  };
	
	  states.restricted_atBlock = function(type, stream, state) {
	    if (type == "}") {
	      state.stateArg = null;
	      return popContext(state);
	    }
	    if (type == "word") {
	      if ((state.stateArg == "@font-face" && !fontProperties.hasOwnProperty(stream.current().toLowerCase())) ||
	          (state.stateArg == "@counter-style" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())))
	        override = "error";
	      else
	        override = "property";
	      return "maybeprop";
	    }
	    return "restricted_atBlock";
	  };
	
	  states.keyframes = function(type, stream, state) {
	    if (type == "word") { override = "variable"; return "keyframes"; }
	    if (type == "{") return pushContext(state, stream, "top");
	    return pass(type, stream, state);
	  };
	
	  states.at = function(type, stream, state) {
	    if (type == ";") return popContext(state);
	    if (type == "{" || type == "}") return popAndPass(type, stream, state);
	    if (type == "word") override = "tag";
	    else if (type == "hash") override = "builtin";
	    return "at";
	  };
	
	  states.interpolation = function(type, stream, state) {
	    if (type == "}") return popContext(state);
	    if (type == "{" || type == ";") return popAndPass(type, stream, state);
	    if (type == "word") override = "variable";
	    else if (type != "variable" && type != "(" && type != ")") override = "error";
	    return "interpolation";
	  };
	
	  return {
	    startState: function(base) {
	      return {tokenize: null,
	              state: inline ? "block" : "top",
	              stateArg: null,
	              context: new Context(inline ? "block" : "top", base || 0, null)};
	    },
	
	    token: function(stream, state) {
	      if (!state.tokenize && stream.eatSpace()) return null;
	      var style = (state.tokenize || tokenBase)(stream, state);
	      if (style && typeof style == "object") {
	        type = style[1];
	        style = style[0];
	      }
	      override = style;
	      state.state = states[state.state](type, stream, state);
	      return override;
	    },
	
	    indent: function(state, textAfter) {
	      var cx = state.context, ch = textAfter && textAfter.charAt(0);
	      var indent = cx.indent;
	      if (cx.type == "prop" && (ch == "}" || ch == ")")) cx = cx.prev;
	      if (cx.prev) {
	        if (ch == "}" && (cx.type == "block" || cx.type == "top" ||
	                          cx.type == "interpolation" || cx.type == "restricted_atBlock")) {
	          // Resume indentation from parent context.
	          cx = cx.prev;
	          indent = cx.indent;
	        } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") ||
	            ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {
	          // Dedent relative to current context.
	          indent = Math.max(0, cx.indent - indentUnit);
	          cx = cx.prev;
	        }
	      }
	      return indent;
	    },
	
	    electricChars: "}",
	    blockCommentStart: "/*",
	    blockCommentEnd: "*/",
	    fold: "brace"
	  };
	});
	
	  function keySet(array) {
	    var keys = {};
	    for (var i = 0; i < array.length; ++i) {
	      keys[array[i].toLowerCase()] = true;
	    }
	    return keys;
	  }
	
	  var documentTypes_ = [
	    "domain", "regexp", "url", "url-prefix"
	  ], documentTypes = keySet(documentTypes_);
	
	  var mediaTypes_ = [
	    "all", "aural", "braille", "handheld", "print", "projection", "screen",
	    "tty", "tv", "embossed"
	  ], mediaTypes = keySet(mediaTypes_);
	
	  var mediaFeatures_ = [
	    "width", "min-width", "max-width", "height", "min-height", "max-height",
	    "device-width", "min-device-width", "max-device-width", "device-height",
	    "min-device-height", "max-device-height", "aspect-ratio",
	    "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",
	    "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",
	    "max-color", "color-index", "min-color-index", "max-color-index",
	    "monochrome", "min-monochrome", "max-monochrome", "resolution",
	    "min-resolution", "max-resolution", "scan", "grid", "orientation",
	    "device-pixel-ratio", "min-device-pixel-ratio", "max-device-pixel-ratio",
	    "pointer", "any-pointer", "hover", "any-hover"
	  ], mediaFeatures = keySet(mediaFeatures_);
	
	  var mediaValueKeywords_ = [
	    "landscape", "portrait", "none", "coarse", "fine", "on-demand", "hover",
	    "interlace", "progressive"
	  ], mediaValueKeywords = keySet(mediaValueKeywords_);
	
	  var propertyKeywords_ = [
	    "align-content", "align-items", "align-self", "alignment-adjust",
	    "alignment-baseline", "anchor-point", "animation", "animation-delay",
	    "animation-direction", "animation-duration", "animation-fill-mode",
	    "animation-iteration-count", "animation-name", "animation-play-state",
	    "animation-timing-function", "appearance", "azimuth", "backface-visibility",
	    "background", "background-attachment", "background-blend-mode", "background-clip",
	    "background-color", "background-image", "background-origin", "background-position",
	    "background-repeat", "background-size", "baseline-shift", "binding",
	    "bleed", "bookmark-label", "bookmark-level", "bookmark-state",
	    "bookmark-target", "border", "border-bottom", "border-bottom-color",
	    "border-bottom-left-radius", "border-bottom-right-radius",
	    "border-bottom-style", "border-bottom-width", "border-collapse",
	    "border-color", "border-image", "border-image-outset",
	    "border-image-repeat", "border-image-slice", "border-image-source",
	    "border-image-width", "border-left", "border-left-color",
	    "border-left-style", "border-left-width", "border-radius", "border-right",
	    "border-right-color", "border-right-style", "border-right-width",
	    "border-spacing", "border-style", "border-top", "border-top-color",
	    "border-top-left-radius", "border-top-right-radius", "border-top-style",
	    "border-top-width", "border-width", "bottom", "box-decoration-break",
	    "box-shadow", "box-sizing", "break-after", "break-before", "break-inside",
	    "caption-side", "clear", "clip", "color", "color-profile", "column-count",
	    "column-fill", "column-gap", "column-rule", "column-rule-color",
	    "column-rule-style", "column-rule-width", "column-span", "column-width",
	    "columns", "content", "counter-increment", "counter-reset", "crop", "cue",
	    "cue-after", "cue-before", "cursor", "direction", "display",
	    "dominant-baseline", "drop-initial-after-adjust",
	    "drop-initial-after-align", "drop-initial-before-adjust",
	    "drop-initial-before-align", "drop-initial-size", "drop-initial-value",
	    "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis",
	    "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap",
	    "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings",
	    "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust",
	    "font-stretch", "font-style", "font-synthesis", "font-variant",
	    "font-variant-alternates", "font-variant-caps", "font-variant-east-asian",
	    "font-variant-ligatures", "font-variant-numeric", "font-variant-position",
	    "font-weight", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow",
	    "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-gap",
	    "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-gap",
	    "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns",
	    "grid-template-rows", "hanging-punctuation", "height", "hyphens",
	    "icon", "image-orientation", "image-rendering", "image-resolution",
	    "inline-box-align", "justify-content", "left", "letter-spacing",
	    "line-break", "line-height", "line-stacking", "line-stacking-ruby",
	    "line-stacking-shift", "line-stacking-strategy", "list-style",
	    "list-style-image", "list-style-position", "list-style-type", "margin",
	    "margin-bottom", "margin-left", "margin-right", "margin-top",
	    "marks", "marquee-direction", "marquee-loop",
	    "marquee-play-count", "marquee-speed", "marquee-style", "max-height",
	    "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index",
	    "nav-left", "nav-right", "nav-up", "object-fit", "object-position",
	    "opacity", "order", "orphans", "outline",
	    "outline-color", "outline-offset", "outline-style", "outline-width",
	    "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y",
	    "padding", "padding-bottom", "padding-left", "padding-right", "padding-top",
	    "page", "page-break-after", "page-break-before", "page-break-inside",
	    "page-policy", "pause", "pause-after", "pause-before", "perspective",
	    "perspective-origin", "pitch", "pitch-range", "play-during", "position",
	    "presentation-level", "punctuation-trim", "quotes", "region-break-after",
	    "region-break-before", "region-break-inside", "region-fragment",
	    "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness",
	    "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang",
	    "ruby-position", "ruby-span", "shape-image-threshold", "shape-inside", "shape-margin",
	    "shape-outside", "size", "speak", "speak-as", "speak-header",
	    "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set",
	    "tab-size", "table-layout", "target", "target-name", "target-new",
	    "target-position", "text-align", "text-align-last", "text-decoration",
	    "text-decoration-color", "text-decoration-line", "text-decoration-skip",
	    "text-decoration-style", "text-emphasis", "text-emphasis-color",
	    "text-emphasis-position", "text-emphasis-style", "text-height",
	    "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow",
	    "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position",
	    "text-wrap", "top", "transform", "transform-origin", "transform-style",
	    "transition", "transition-delay", "transition-duration",
	    "transition-property", "transition-timing-function", "unicode-bidi",
	    "user-select", "vertical-align", "visibility", "voice-balance", "voice-duration",
	    "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress",
	    "voice-volume", "volume", "white-space", "widows", "width", "will-change", "word-break",
	    "word-spacing", "word-wrap", "z-index",
	    // SVG-specific
	    "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color",
	    "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events",
	    "color-interpolation", "color-interpolation-filters",
	    "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering",
	    "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke",
	    "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin",
	    "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering",
	    "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal",
	    "glyph-orientation-vertical", "text-anchor", "writing-mode"
	  ], propertyKeywords = keySet(propertyKeywords_);
	
	  var nonStandardPropertyKeywords_ = [
	    "scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color",
	    "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color",
	    "scrollbar-3d-light-color", "scrollbar-track-color", "shape-inside",
	    "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button",
	    "searchfield-results-decoration", "zoom"
	  ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);
	
	  var fontProperties_ = [
	    "font-family", "src", "unicode-range", "font-variant", "font-feature-settings",
	    "font-stretch", "font-weight", "font-style"
	  ], fontProperties = keySet(fontProperties_);
	
	  var counterDescriptors_ = [
	    "additive-symbols", "fallback", "negative", "pad", "prefix", "range",
	    "speak-as", "suffix", "symbols", "system"
	  ], counterDescriptors = keySet(counterDescriptors_);
	
	  var colorKeywords_ = [
	    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",
	    "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",
	    "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",
	    "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",
	    "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen",
	    "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",
	    "darkslateblue", "darkslategray", "darkturquoise", "darkviolet",
	    "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick",
	    "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",
	    "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew",
	    "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",
	    "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",
	    "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink",
	    "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray",
	    "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",
	    "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",
	    "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",
	    "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",
	    "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",
	    "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",
	    "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",
	    "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown",
	    "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",
	    "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan",
	    "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",
	    "whitesmoke", "yellow", "yellowgreen"
	  ], colorKeywords = keySet(colorKeywords_);
	
	  var valueKeywords_ = [
	    "above", "absolute", "activeborder", "additive", "activecaption", "afar",
	    "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate",
	    "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",
	    "arabic-indic", "armenian", "asterisks", "attr", "auto", "avoid", "avoid-column", "avoid-page",
	    "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary",
	    "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",
	    "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel",
	    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "cambodian",
	    "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",
	    "cell", "center", "checkbox", "circle", "cjk-decimal", "cjk-earthly-branch",
	    "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",
	    "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse",
	    "compact", "condensed", "contain", "content", "contents",
	    "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop",
	    "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal",
	    "decimal-leading-zero", "default", "default-button", "dense", "destination-atop",
	    "destination-in", "destination-out", "destination-over", "devanagari", "difference",
	    "disc", "discard", "disclosure-closed", "disclosure-open", "document",
	    "dot-dash", "dot-dot-dash",
	    "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",
	    "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",
	    "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",
	    "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",
	    "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",
	    "ethiopic-halehame-gez", "ethiopic-halehame-om-et",
	    "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",
	    "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig",
	    "ethiopic-numeric", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed",
	    "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes",
	    "forwards", "from", "geometricPrecision", "georgian", "graytext", "grid", "groove",
	    "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hard-light", "hebrew",
	    "help", "hidden", "hide", "higher", "highlight", "highlighttext",
	    "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "hue", "icon", "ignore",
	    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",
	    "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",
	    "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert",
	    "italic", "japanese-formal", "japanese-informal", "justify", "kannada",
	    "katakana", "katakana-iroha", "keep-all", "khmer",
	    "korean-hangul-formal", "korean-hanja-formal", "korean-hanja-informal",
	    "landscape", "lao", "large", "larger", "left", "level", "lighter", "lighten",
	    "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem",
	    "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",
	    "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",
	    "lower-roman", "lowercase", "ltr", "luminosity", "malayalam", "match", "matrix", "matrix3d",
	    "media-controls-background", "media-current-time-display",
	    "media-fullscreen-button", "media-mute-button", "media-play-button",
	    "media-return-to-realtime-button", "media-rewind-button",
	    "media-seek-back-button", "media-seek-forward-button", "media-slider",
	    "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",
	    "media-volume-slider-container", "media-volume-sliderthumb", "medium",
	    "menu", "menulist", "menulist-button", "menulist-text",
	    "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",
	    "mix", "mongolian", "monospace", "move", "multiple", "multiply", "myanmar", "n-resize",
	    "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",
	    "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",
	    "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "octal", "opacity", "open-quote",
	    "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",
	    "outside", "outside-shape", "overlay", "overline", "padding", "padding-box",
	    "painted", "page", "paused", "persian", "perspective", "plus-darker", "plus-lighter",
	    "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d",
	    "progress", "push-button", "radial-gradient", "radio", "read-only",
	    "read-write", "read-write-plaintext-only", "rectangle", "region",
	    "relative", "repeat", "repeating-linear-gradient",
	    "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse",
	    "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY",
	    "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running",
	    "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen",
	    "scroll", "scrollbar", "scroll-position", "se-resize", "searchfield",
	    "searchfield-cancel-button", "searchfield-decoration",
	    "searchfield-results-button", "searchfield-results-decoration",
	    "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama",
	    "simp-chinese-formal", "simp-chinese-informal", "single",
	    "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal",
	    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",
	    "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "somali",
	    "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "spell-out", "square",
	    "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub",
	    "subpixel-antialiased", "super", "sw-resize", "symbolic", "symbols", "table",
	    "table-caption", "table-cell", "table-column", "table-column-group",
	    "table-footer-group", "table-header-group", "table-row", "table-row-group",
	    "tamil",
	    "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",
	    "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",
	    "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",
	    "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",
	    "trad-chinese-formal", "trad-chinese-informal", "transform",
	    "translate", "translate3d", "translateX", "translateY", "translateZ",
	    "transparent", "ultra-condensed", "ultra-expanded", "underline", "unset", "up",
	    "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",
	    "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",
	    "var", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted",
	    "visibleStroke", "visual", "w-resize", "wait", "wave", "wider",
	    "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor",
	    "xx-large", "xx-small"
	  ], valueKeywords = keySet(valueKeywords_);
	
	  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_)
	    .concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_)
	    .concat(valueKeywords_);
	  CodeMirror.registerHelper("hintWords", "css", allWords);
	
	  function tokenCComment(stream, state) {
	    var maybeEnd = false, ch;
	    while ((ch = stream.next()) != null) {
	      if (maybeEnd && ch == "/") {
	        state.tokenize = null;
	        break;
	      }
	      maybeEnd = (ch == "*");
	    }
	    return ["comment", "comment"];
	  }
	
	  CodeMirror.defineMIME("text/css", {
	    documentTypes: documentTypes,
	    mediaTypes: mediaTypes,
	    mediaFeatures: mediaFeatures,
	    mediaValueKeywords: mediaValueKeywords,
	    propertyKeywords: propertyKeywords,
	    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
	    fontProperties: fontProperties,
	    counterDescriptors: counterDescriptors,
	    colorKeywords: colorKeywords,
	    valueKeywords: valueKeywords,
	    tokenHooks: {
	      "/": function(stream, state) {
	        if (!stream.eat("*")) return false;
	        state.tokenize = tokenCComment;
	        return tokenCComment(stream, state);
	      }
	    },
	    name: "css"
	  });
	
	  CodeMirror.defineMIME("text/x-scss", {
	    mediaTypes: mediaTypes,
	    mediaFeatures: mediaFeatures,
	    mediaValueKeywords: mediaValueKeywords,
	    propertyKeywords: propertyKeywords,
	    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
	    colorKeywords: colorKeywords,
	    valueKeywords: valueKeywords,
	    fontProperties: fontProperties,
	    allowNested: true,
	    tokenHooks: {
	      "/": function(stream, state) {
	        if (stream.eat("/")) {
	          stream.skipToEnd();
	          return ["comment", "comment"];
	        } else if (stream.eat("*")) {
	          state.tokenize = tokenCComment;
	          return tokenCComment(stream, state);
	        } else {
	          return ["operator", "operator"];
	        }
	      },
	      ":": function(stream) {
	        if (stream.match(/\s*\{/))
	          return [null, "{"];
	        return false;
	      },
	      "$": function(stream) {
	        stream.match(/^[\w-]+/);
	        if (stream.match(/^\s*:/, false))
	          return ["variable-2", "variable-definition"];
	        return ["variable-2", "variable"];
	      },
	      "#": function(stream) {
	        if (!stream.eat("{")) return false;
	        return [null, "interpolation"];
	      }
	    },
	    name: "css",
	    helperType: "scss"
	  });
	
	  CodeMirror.defineMIME("text/x-less", {
	    mediaTypes: mediaTypes,
	    mediaFeatures: mediaFeatures,
	    mediaValueKeywords: mediaValueKeywords,
	    propertyKeywords: propertyKeywords,
	    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
	    colorKeywords: colorKeywords,
	    valueKeywords: valueKeywords,
	    fontProperties: fontProperties,
	    allowNested: true,
	    tokenHooks: {
	      "/": function(stream, state) {
	        if (stream.eat("/")) {
	          stream.skipToEnd();
	          return ["comment", "comment"];
	        } else if (stream.eat("*")) {
	          state.tokenize = tokenCComment;
	          return tokenCComment(stream, state);
	        } else {
	          return ["operator", "operator"];
	        }
	      },
	      "@": function(stream) {
	        if (stream.eat("{")) return [null, "interpolation"];
	        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/, false)) return false;
	        stream.eatWhile(/[\w\\\-]/);
	        if (stream.match(/^\s*:/, false))
	          return ["variable-2", "variable-definition"];
	        return ["variable-2", "variable"];
	      },
	      "&": function() {
	        return ["atom", "atom"];
	      }
	    },
	    name: "css",
	    helperType: "less"
	  });
	
	  CodeMirror.defineMIME("text/x-gss", {
	    documentTypes: documentTypes,
	    mediaTypes: mediaTypes,
	    mediaFeatures: mediaFeatures,
	    propertyKeywords: propertyKeywords,
	    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
	    fontProperties: fontProperties,
	    counterDescriptors: counterDescriptors,
	    colorKeywords: colorKeywords,
	    valueKeywords: valueKeywords,
	    supportsAtComponent: true,
	    tokenHooks: {
	      "/": function(stream, state) {
	        if (!stream.eat("*")) return false;
	        state.tokenize = tokenCComment;
	        return tokenCComment(stream, state);
	      }
	    },
	    name: "css",
	    helperType: "gss"
	  });
	
	});


/***/ },
/* 520 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	/**
	 * Link to the project's GitHub page:
	 * https://github.com/pickhardt/coffeescript-codemirror-mode
	 */
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(513));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	"use strict";
	
	CodeMirror.defineMode("coffeescript", function(conf, parserConf) {
	  var ERRORCLASS = "error";
	
	  function wordRegexp(words) {
	    return new RegExp("^((" + words.join(")|(") + "))\\b");
	  }
	
	  var operators = /^(?:->|=>|\+[+=]?|-[\-=]?|\*[\*=]?|\/[\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\|=?|\^=?|\~|!|\?|(or|and|\|\||&&|\?)=)/;
	  var delimiters = /^(?:[()\[\]{},:`=;]|\.\.?\.?)/;
	  var identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;
	  var atProp = /^@[_A-Za-z$][_A-Za-z$0-9]*/;
	
	  var wordOperators = wordRegexp(["and", "or", "not",
	                                  "is", "isnt", "in",
	                                  "instanceof", "typeof"]);
	  var indentKeywords = ["for", "while", "loop", "if", "unless", "else",
	                        "switch", "try", "catch", "finally", "class"];
	  var commonKeywords = ["break", "by", "continue", "debugger", "delete",
	                        "do", "in", "of", "new", "return", "then",
	                        "this", "@", "throw", "when", "until", "extends"];
	
	  var keywords = wordRegexp(indentKeywords.concat(commonKeywords));
	
	  indentKeywords = wordRegexp(indentKeywords);
	
	
	  var stringPrefixes = /^('{3}|\"{3}|['\"])/;
	  var regexPrefixes = /^(\/{3}|\/)/;
	  var commonConstants = ["Infinity", "NaN", "undefined", "null", "true", "false", "on", "off", "yes", "no"];
	  var constants = wordRegexp(commonConstants);
	
	  // Tokenizers
	  function tokenBase(stream, state) {
	    // Handle scope changes
	    if (stream.sol()) {
	      if (state.scope.align === null) state.scope.align = false;
	      var scopeOffset = state.scope.offset;
	      if (stream.eatSpace()) {
	        var lineOffset = stream.indentation();
	        if (lineOffset > scopeOffset && state.scope.type == "coffee") {
	          return "indent";
	        } else if (lineOffset < scopeOffset) {
	          return "dedent";
	        }
	        return null;
	      } else {
	        if (scopeOffset > 0) {
	          dedent(stream, state);
	        }
	      }
	    }
	    if (stream.eatSpace()) {
	      return null;
	    }
	
	    var ch = stream.peek();
	
	    // Handle docco title comment (single line)
	    if (stream.match("####")) {
	      stream.skipToEnd();
	      return "comment";
	    }
	
	    // Handle multi line comments
	    if (stream.match("###")) {
	      state.tokenize = longComment;
	      return state.tokenize(stream, state);
	    }
	
	    // Single line comment
	    if (ch === "#") {
	      stream.skipToEnd();
	      return "comment";
	    }
	
	    // Handle number literals
	    if (stream.match(/^-?[0-9\.]/, false)) {
	      var floatLiteral = false;
	      // Floats
	      if (stream.match(/^-?\d*\.\d+(e[\+\-]?\d+)?/i)) {
	        floatLiteral = true;
	      }
	      if (stream.match(/^-?\d+\.\d*/)) {
	        floatLiteral = true;
	      }
	      if (stream.match(/^-?\.\d+/)) {
	        floatLiteral = true;
	      }
	
	      if (floatLiteral) {
	        // prevent from getting extra . on 1..
	        if (stream.peek() == "."){
	          stream.backUp(1);
	        }
	        return "number";
	      }
	      // Integers
	      var intLiteral = false;
	      // Hex
	      if (stream.match(/^-?0x[0-9a-f]+/i)) {
	        intLiteral = true;
	      }
	      // Decimal
	      if (stream.match(/^-?[1-9]\d*(e[\+\-]?\d+)?/)) {
	        intLiteral = true;
	      }
	      // Zero by itself with no other piece of number.
	      if (stream.match(/^-?0(?![\dx])/i)) {
	        intLiteral = true;
	      }
	      if (intLiteral) {
	        return "number";
	      }
	    }
	
	    // Handle strings
	    if (stream.match(stringPrefixes)) {
	      state.tokenize = tokenFactory(stream.current(), false, "string");
	      return state.tokenize(stream, state);
	    }
	    // Handle regex literals
	    if (stream.match(regexPrefixes)) {
	      if (stream.current() != "/" || stream.match(/^.*\//, false)) { // prevent highlight of division
	        state.tokenize = tokenFactory(stream.current(), true, "string-2");
	        return state.tokenize(stream, state);
	      } else {
	        stream.backUp(1);
	      }
	    }
	
	
	
	    // Handle operators and delimiters
	    if (stream.match(operators) || stream.match(wordOperators)) {
	      return "operator";
	    }
	    if (stream.match(delimiters)) {
	      return "punctuation";
	    }
	
	    if (stream.match(constants)) {
	      return "atom";
	    }
	
	    if (stream.match(atProp) || state.prop && stream.match(identifiers)) {
	      return "property";
	    }
	
	    if (stream.match(keywords)) {
	      return "keyword";
	    }
	
	    if (stream.match(identifiers)) {
	      return "variable";
	    }
	
	    // Handle non-detected items
	    stream.next();
	    return ERRORCLASS;
	  }
	
	  function tokenFactory(delimiter, singleline, outclass) {
	    return function(stream, state) {
	      while (!stream.eol()) {
	        stream.eatWhile(/[^'"\/\\]/);
	        if (stream.eat("\\")) {
	          stream.next();
	          if (singleline && stream.eol()) {
	            return outclass;
	          }
	        } else if (stream.match(delimiter)) {
	          state.tokenize = tokenBase;
	          return outclass;
	        } else {
	          stream.eat(/['"\/]/);
	        }
	      }
	      if (singleline) {
	        if (parserConf.singleLineStringErrors) {
	          outclass = ERRORCLASS;
	        } else {
	          state.tokenize = tokenBase;
	        }
	      }
	      return outclass;
	    };
	  }
	
	  function longComment(stream, state) {
	    while (!stream.eol()) {
	      stream.eatWhile(/[^#]/);
	      if (stream.match("###")) {
	        state.tokenize = tokenBase;
	        break;
	      }
	      stream.eatWhile("#");
	    }
	    return "comment";
	  }
	
	  function indent(stream, state, type) {
	    type = type || "coffee";
	    var offset = 0, align = false, alignOffset = null;
	    for (var scope = state.scope; scope; scope = scope.prev) {
	      if (scope.type === "coffee" || scope.type == "}") {
	        offset = scope.offset + conf.indentUnit;
	        break;
	      }
	    }
	    if (type !== "coffee") {
	      align = null;
	      alignOffset = stream.column() + stream.current().length;
	    } else if (state.scope.align) {
	      state.scope.align = false;
	    }
	    state.scope = {
	      offset: offset,
	      type: type,
	      prev: state.scope,
	      align: align,
	      alignOffset: alignOffset
	    };
	  }
	
	  function dedent(stream, state) {
	    if (!state.scope.prev) return;
	    if (state.scope.type === "coffee") {
	      var _indent = stream.indentation();
	      var matched = false;
	      for (var scope = state.scope; scope; scope = scope.prev) {
	        if (_indent === scope.offset) {
	          matched = true;
	          break;
	        }
	      }
	      if (!matched) {
	        return true;
	      }
	      while (state.scope.prev && state.scope.offset !== _indent) {
	        state.scope = state.scope.prev;
	      }
	      return false;
	    } else {
	      state.scope = state.scope.prev;
	      return false;
	    }
	  }
	
	  function tokenLexer(stream, state) {
	    var style = state.tokenize(stream, state);
	    var current = stream.current();
	
	    // Handle scope changes.
	    if (current === "return") {
	      state.dedent = true;
	    }
	    if (((current === "->" || current === "=>") && stream.eol())
	        || style === "indent") {
	      indent(stream, state);
	    }
	    var delimiter_index = "[({".indexOf(current);
	    if (delimiter_index !== -1) {
	      indent(stream, state, "])}".slice(delimiter_index, delimiter_index+1));
	    }
	    if (indentKeywords.exec(current)){
	      indent(stream, state);
	    }
	    if (current == "then"){
	      dedent(stream, state);
	    }
	
	
	    if (style === "dedent") {
	      if (dedent(stream, state)) {
	        return ERRORCLASS;
	      }
	    }
	    delimiter_index = "])}".indexOf(current);
	    if (delimiter_index !== -1) {
	      while (state.scope.type == "coffee" && state.scope.prev)
	        state.scope = state.scope.prev;
	      if (state.scope.type == current)
	        state.scope = state.scope.prev;
	    }
	    if (state.dedent && stream.eol()) {
	      if (state.scope.type == "coffee" && state.scope.prev)
	        state.scope = state.scope.prev;
	      state.dedent = false;
	    }
	
	    return style;
	  }
	
	  var external = {
	    startState: function(basecolumn) {
	      return {
	        tokenize: tokenBase,
	        scope: {offset:basecolumn || 0, type:"coffee", prev: null, align: false},
	        prop: false,
	        dedent: 0
	      };
	    },
	
	    token: function(stream, state) {
	      var fillAlign = state.scope.align === null && state.scope;
	      if (fillAlign && stream.sol()) fillAlign.align = false;
	
	      var style = tokenLexer(stream, state);
	      if (style && style != "comment") {
	        if (fillAlign) fillAlign.align = true;
	        state.prop = style == "punctuation" && stream.current() == "."
	      }
	
	      return style;
	    },
	
	    indent: function(state, text) {
	      if (state.tokenize != tokenBase) return 0;
	      var scope = state.scope;
	      var closer = text && "])}".indexOf(text.charAt(0)) > -1;
	      if (closer) while (scope.type == "coffee" && scope.prev) scope = scope.prev;
	      var closes = closer && scope.type === text.charAt(0);
	      if (scope.align)
	        return scope.alignOffset - (closes ? 1 : 0);
	      else
	        return (closes ? scope.prev : scope).offset;
	    },
	
	    lineComment: "#",
	    fold: "indent"
	  };
	  return external;
	});
	
	CodeMirror.defineMIME("text/x-coffeescript", "coffeescript");
	CodeMirror.defineMIME("text/coffeescript", "coffeescript");
	
	});


/***/ },
/* 521 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(513), __webpack_require__(518), __webpack_require__(516))
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror", "../xml/xml", "../javascript/javascript"], mod)
	  else // Plain browser env
	    mod(CodeMirror)
	})(function(CodeMirror) {
	  "use strict"
	
	  // Depth means the amount of open braces in JS context, in XML
	  // context 0 means not in tag, 1 means in tag, and 2 means in tag
	  // and js block comment.
	  function Context(state, mode, depth, prev) {
	    this.state = state; this.mode = mode; this.depth = depth; this.prev = prev
	  }
	
	  function copyContext(context) {
	    return new Context(CodeMirror.copyState(context.mode, context.state),
	                       context.mode,
	                       context.depth,
	                       context.prev && copyContext(context.prev))
	  }
	
	  CodeMirror.defineMode("jsx", function(config, modeConfig) {
	    var xmlMode = CodeMirror.getMode(config, {name: "xml", allowMissing: true, multilineTagIndentPastTag: false})
	    var jsMode = CodeMirror.getMode(config, modeConfig && modeConfig.base || "javascript")
	
	    function flatXMLIndent(state) {
	      var tagName = state.tagName
	      state.tagName = null
	      var result = xmlMode.indent(state, "")
	      state.tagName = tagName
	      return result
	    }
	
	    function token(stream, state) {
	      if (state.context.mode == xmlMode)
	        return xmlToken(stream, state, state.context)
	      else
	        return jsToken(stream, state, state.context)
	    }
	
	    function xmlToken(stream, state, cx) {
	      if (cx.depth == 2) { // Inside a JS /* */ comment
	        if (stream.match(/^.*?\*\//)) cx.depth = 1
	        else stream.skipToEnd()
	        return "comment"
	      }
	
	      if (stream.peek() == "{") {
	        xmlMode.skipAttribute(cx.state)
	
	        var indent = flatXMLIndent(cx.state), xmlContext = cx.state.context
	        // If JS starts on same line as tag
	        if (xmlContext && stream.match(/^[^>]*>\s*$/, false)) {
	          while (xmlContext.prev && !xmlContext.startOfLine)
	            xmlContext = xmlContext.prev
	          // If tag starts the line, use XML indentation level
	          if (xmlContext.startOfLine) indent -= config.indentUnit
	          // Else use JS indentation level
	          else if (cx.prev.state.lexical) indent = cx.prev.state.lexical.indented
	        // Else if inside of tag
	        } else if (cx.depth == 1) {
	          indent += config.indentUnit
	        }
	
	        state.context = new Context(CodeMirror.startState(jsMode, indent),
	                                    jsMode, 0, state.context)
	        return null
	      }
	
	      if (cx.depth == 1) { // Inside of tag
	        if (stream.peek() == "<") { // Tag inside of tag
	          xmlMode.skipAttribute(cx.state)
	          state.context = new Context(CodeMirror.startState(xmlMode, flatXMLIndent(cx.state)),
	                                      xmlMode, 0, state.context)
	          return null
	        } else if (stream.match("//")) {
	          stream.skipToEnd()
	          return "comment"
	        } else if (stream.match("/*")) {
	          cx.depth = 2
	          return token(stream, state)
	        }
	      }
	
	      var style = xmlMode.token(stream, cx.state), cur = stream.current(), stop
	      if (/\btag\b/.test(style)) {
	        if (/>$/.test(cur)) {
	          if (cx.state.context) cx.depth = 0
	          else state.context = state.context.prev
	        } else if (/^</.test(cur)) {
	          cx.depth = 1
	        }
	      } else if (!style && (stop = cur.indexOf("{")) > -1) {
	        stream.backUp(cur.length - stop)
	      }
	      return style
	    }
	
	    function jsToken(stream, state, cx) {
	      if (stream.peek() == "<" && jsMode.expressionAllowed(stream, cx.state)) {
	        jsMode.skipExpression(cx.state)
	        state.context = new Context(CodeMirror.startState(xmlMode, jsMode.indent(cx.state, "")),
	                                    xmlMode, 0, state.context)
	        return null
	      }
	
	      var style = jsMode.token(stream, cx.state)
	      if (!style && cx.depth != null) {
	        var cur = stream.current()
	        if (cur == "{") {
	          cx.depth++
	        } else if (cur == "}") {
	          if (--cx.depth == 0) state.context = state.context.prev
	        }
	      }
	      return style
	    }
	
	    return {
	      startState: function() {
	        return {context: new Context(CodeMirror.startState(jsMode), jsMode)}
	      },
	
	      copyState: function(state) {
	        return {context: copyContext(state.context)}
	      },
	
	      token: token,
	
	      indent: function(state, textAfter, fullLine) {
	        return state.context.mode.indent(state.context.state, textAfter, fullLine)
	      },
	
	      innerMode: function(state) {
	        return state.context
	      }
	    }
	  }, "xml", "javascript")
	
	  CodeMirror.defineMIME("text/jsx", "jsx")
	  CodeMirror.defineMIME("text/typescript-jsx", {name: "jsx", base: {name: "javascript", typescript: true}})
	});


/***/ },
/* 522 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(513));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";
	
	  CodeMirror.defineMode("elm", function() {
	
	    function switchState(source, setState, f) {
	      setState(f);
	      return f(source, setState);
	    }
	
	    // These should all be Unicode extended, as per the Haskell 2010 report
	    var smallRE = /[a-z_]/;
	    var largeRE = /[A-Z]/;
	    var digitRE = /[0-9]/;
	    var hexitRE = /[0-9A-Fa-f]/;
	    var octitRE = /[0-7]/;
	    var idRE = /[a-z_A-Z0-9\']/;
	    var symbolRE = /[-!#$%&*+.\/<=>?@\\^|~:\u03BB\u2192]/;
	    var specialRE = /[(),;[\]`{}]/;
	    var whiteCharRE = /[ \t\v\f]/; // newlines are handled in tokenizer
	
	    function normal() {
	      return function (source, setState) {
	        if (source.eatWhile(whiteCharRE)) {
	          return null;
	        }
	
	        var ch = source.next();
	        if (specialRE.test(ch)) {
	          if (ch == '{' && source.eat('-')) {
	            var t = "comment";
	            if (source.eat('#')) t = "meta";
	            return switchState(source, setState, ncomment(t, 1));
	          }
	          return null;
	        }
	
	        if (ch == '\'') {
	          if (source.eat('\\'))
	            source.next();  // should handle other escapes here
	          else
	            source.next();
	
	          if (source.eat('\''))
	            return "string";
	          return "error";
	        }
	
	        if (ch == '"') {
	          return switchState(source, setState, stringLiteral);
	        }
	
	        if (largeRE.test(ch)) {
	          source.eatWhile(idRE);
	          if (source.eat('.'))
	            return "qualifier";
	          return "variable-2";
	        }
	
	        if (smallRE.test(ch)) {
	          var isDef = source.pos === 1;
	          source.eatWhile(idRE);
	          return isDef ? "variable-3" : "variable";
	        }
	
	        if (digitRE.test(ch)) {
	          if (ch == '0') {
	            if (source.eat(/[xX]/)) {
	              source.eatWhile(hexitRE); // should require at least 1
	              return "integer";
	            }
	            if (source.eat(/[oO]/)) {
	              source.eatWhile(octitRE); // should require at least 1
	              return "number";
	            }
	          }
	          source.eatWhile(digitRE);
	          var t = "number";
	          if (source.eat('.')) {
	            t = "number";
	            source.eatWhile(digitRE); // should require at least 1
	          }
	          if (source.eat(/[eE]/)) {
	            t = "number";
	            source.eat(/[-+]/);
	            source.eatWhile(digitRE); // should require at least 1
	          }
	          return t;
	        }
	
	        if (symbolRE.test(ch)) {
	          if (ch == '-' && source.eat(/-/)) {
	            source.eatWhile(/-/);
	            if (!source.eat(symbolRE)) {
	              source.skipToEnd();
	              return "comment";
	            }
	          }
	          source.eatWhile(symbolRE);
	          return "builtin";
	        }
	
	        return "error";
	      }
	    }
	
	    function ncomment(type, nest) {
	      if (nest == 0) {
	        return normal();
	      }
	      return function(source, setState) {
	        var currNest = nest;
	        while (!source.eol()) {
	          var ch = source.next();
	          if (ch == '{' && source.eat('-')) {
	            ++currNest;
	          } else if (ch == '-' && source.eat('}')) {
	            --currNest;
	            if (currNest == 0) {
	              setState(normal());
	              return type;
	            }
	          }
	        }
	        setState(ncomment(type, currNest));
	        return type;
	      }
	    }
	
	    function stringLiteral(source, setState) {
	      while (!source.eol()) {
	        var ch = source.next();
	        if (ch == '"') {
	          setState(normal());
	          return "string";
	        }
	        if (ch == '\\') {
	          if (source.eol() || source.eat(whiteCharRE)) {
	            setState(stringGap);
	            return "string";
	          }
	          if (!source.eat('&')) source.next(); // should handle other escapes here
	        }
	      }
	      setState(normal());
	      return "error";
	    }
	
	    function stringGap(source, setState) {
	      if (source.eat('\\')) {
	        return switchState(source, setState, stringLiteral);
	      }
	      source.next();
	      setState(normal());
	      return "error";
	    }
	
	
	    var wellKnownWords = (function() {
	      var wkw = {};
	
	      var keywords = [
	        "case", "of", "as",
	        "if", "then", "else",
	        "let", "in",
	        "infix", "infixl", "infixr",
	        "type", "alias",
	        "input", "output", "foreign", "loopback",
	        "module", "where", "import", "exposing",
	        "_", "..", "|", ":", "=", "\\", "\"", "->", "<-"
	      ];
	
	      for (var i = keywords.length; i--;)
	        wkw[keywords[i]] = "keyword";
	
	      return wkw;
	    })();
	
	
	
	    return {
	      startState: function ()  { return { f: normal() }; },
	      copyState:  function (s) { return { f: s.f }; },
	
	      token: function(stream, state) {
	        var t = state.f(stream, function(s) { state.f = s; });
	        var w = stream.current();
	        return (wellKnownWords.hasOwnProperty(w)) ? wellKnownWords[w] : t;
	      }
	    };
	
	  });
	
	  CodeMirror.defineMIME("text/x-elm", "elm");
	});


/***/ },
/* 523 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 524 */,
/* 525 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(513));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";
	  var Pos = CodeMirror.Pos;
	
	  function SearchCursor(doc, query, pos, caseFold) {
	    this.atOccurrence = false; this.doc = doc;
	    if (caseFold == null && typeof query == "string") caseFold = false;
	
	    pos = pos ? doc.clipPos(pos) : Pos(0, 0);
	    this.pos = {from: pos, to: pos};
	
	    // The matches method is filled in based on the type of query.
	    // It takes a position and a direction, and returns an object
	    // describing the next occurrence of the query, or null if no
	    // more matches were found.
	    if (typeof query != "string") { // Regexp match
	      if (!query.global) query = new RegExp(query.source, query.ignoreCase ? "ig" : "g");
	      this.matches = function(reverse, pos) {
	        if (reverse) {
	          query.lastIndex = 0;
	          var line = doc.getLine(pos.line).slice(0, pos.ch), cutOff = 0, match, start;
	          for (;;) {
	            query.lastIndex = cutOff;
	            var newMatch = query.exec(line);
	            if (!newMatch) break;
	            match = newMatch;
	            start = match.index;
	            cutOff = match.index + (match[0].length || 1);
	            if (cutOff == line.length) break;
	          }
	          var matchLen = (match && match[0].length) || 0;
	          if (!matchLen) {
	            if (start == 0 && line.length == 0) {match = undefined;}
	            else if (start != doc.getLine(pos.line).length) {
	              matchLen++;
	            }
	          }
	        } else {
	          query.lastIndex = pos.ch;
	          var line = doc.getLine(pos.line), match = query.exec(line);
	          var matchLen = (match && match[0].length) || 0;
	          var start = match && match.index;
	          if (start + matchLen != line.length && !matchLen) matchLen = 1;
	        }
	        if (match && matchLen)
	          return {from: Pos(pos.line, start),
	                  to: Pos(pos.line, start + matchLen),
	                  match: match};
	      };
	    } else { // String query
	      var origQuery = query;
	      if (caseFold) query = query.toLowerCase();
	      var fold = caseFold ? function(str){return str.toLowerCase();} : function(str){return str;};
	      var target = query.split("\n");
	      // Different methods for single-line and multi-line queries
	      if (target.length == 1) {
	        if (!query.length) {
	          // Empty string would match anything and never progress, so
	          // we define it to match nothing instead.
	          this.matches = function() {};
	        } else {
	          this.matches = function(reverse, pos) {
	            if (reverse) {
	              var orig = doc.getLine(pos.line).slice(0, pos.ch), line = fold(orig);
	              var match = line.lastIndexOf(query);
	              if (match > -1) {
	                match = adjustPos(orig, line, match);
	                return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};
	              }
	             } else {
	               var orig = doc.getLine(pos.line).slice(pos.ch), line = fold(orig);
	               var match = line.indexOf(query);
	               if (match > -1) {
	                 match = adjustPos(orig, line, match) + pos.ch;
	                 return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};
	               }
	            }
	          };
	        }
	      } else {
	        var origTarget = origQuery.split("\n");
	        this.matches = function(reverse, pos) {
	          var last = target.length - 1;
	          if (reverse) {
	            if (pos.line - (target.length - 1) < doc.firstLine()) return;
	            if (fold(doc.getLine(pos.line).slice(0, origTarget[last].length)) != target[target.length - 1]) return;
	            var to = Pos(pos.line, origTarget[last].length);
	            for (var ln = pos.line - 1, i = last - 1; i >= 1; --i, --ln)
	              if (target[i] != fold(doc.getLine(ln))) return;
	            var line = doc.getLine(ln), cut = line.length - origTarget[0].length;
	            if (fold(line.slice(cut)) != target[0]) return;
	            return {from: Pos(ln, cut), to: to};
	          } else {
	            if (pos.line + (target.length - 1) > doc.lastLine()) return;
	            var line = doc.getLine(pos.line), cut = line.length - origTarget[0].length;
	            if (fold(line.slice(cut)) != target[0]) return;
	            var from = Pos(pos.line, cut);
	            for (var ln = pos.line + 1, i = 1; i < last; ++i, ++ln)
	              if (target[i] != fold(doc.getLine(ln))) return;
	            if (fold(doc.getLine(ln).slice(0, origTarget[last].length)) != target[last]) return;
	            return {from: from, to: Pos(ln, origTarget[last].length)};
	          }
	        };
	      }
	    }
	  }
	
	  SearchCursor.prototype = {
	    findNext: function() {return this.find(false);},
	    findPrevious: function() {return this.find(true);},
	
	    find: function(reverse) {
	      var self = this, pos = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);
	      function savePosAndFail(line) {
	        var pos = Pos(line, 0);
	        self.pos = {from: pos, to: pos};
	        self.atOccurrence = false;
	        return false;
	      }
	
	      for (;;) {
	        if (this.pos = this.matches(reverse, pos)) {
	          this.atOccurrence = true;
	          return this.pos.match || true;
	        }
	        if (reverse) {
	          if (!pos.line) return savePosAndFail(0);
	          pos = Pos(pos.line-1, this.doc.getLine(pos.line-1).length);
	        }
	        else {
	          var maxLine = this.doc.lineCount();
	          if (pos.line == maxLine - 1) return savePosAndFail(maxLine);
	          pos = Pos(pos.line + 1, 0);
	        }
	      }
	    },
	
	    from: function() {if (this.atOccurrence) return this.pos.from;},
	    to: function() {if (this.atOccurrence) return this.pos.to;},
	
	    replace: function(newText, origin) {
	      if (!this.atOccurrence) return;
	      var lines = CodeMirror.splitLines(newText);
	      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);
	      this.pos.to = Pos(this.pos.from.line + lines.length - 1,
	                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));
	    }
	  };
	
	  // Maps a position in a case-folded line back to a position in the original line
	  // (compensating for codepoints increasing in number during folding)
	  function adjustPos(orig, folded, pos) {
	    if (orig.length == folded.length) return pos;
	    for (var pos1 = Math.min(pos, orig.length);;) {
	      var len1 = orig.slice(0, pos1).toLowerCase().length;
	      if (len1 < pos) ++pos1;
	      else if (len1 > pos) --pos1;
	      else return pos1;
	    }
	  }
	
	  CodeMirror.defineExtension("getSearchCursor", function(query, pos, caseFold) {
	    return new SearchCursor(this.doc, query, pos, caseFold);
	  });
	  CodeMirror.defineDocExtension("getSearchCursor", function(query, pos, caseFold) {
	    return new SearchCursor(this, query, pos, caseFold);
	  });
	
	  CodeMirror.defineExtension("selectMatches", function(query, caseFold) {
	    var ranges = [];
	    var cur = this.getSearchCursor(query, this.getCursor("from"), caseFold);
	    while (cur.findNext()) {
	      if (CodeMirror.cmpPos(cur.to(), this.getCursor("to")) > 0) break;
	      ranges.push({anchor: cur.from(), head: cur.to()});
	    }
	    if (ranges.length)
	      this.setSelections(ranges, 0);
	  });
	});


/***/ },
/* 526 */
/***/ function(module, exports, __webpack_require__) {

	var escapeRegExp = __webpack_require__(527);
	/**
	 * These functions implement search within the debugger. Since
	 * search in the debugger is different from other components,
	 * we can't use search.js CodeMirror addon. This is a slightly
	 * modified version of that addon. Depends on searchcursor.js.
	 * @module utils/source-search
	 */
	
	/**
	 * @memberof utils/source-search
	 * @static
	 */
	function SearchState() {
	  this.posFrom = this.posTo = this.query = null;
	  this.overlay = null;
	}
	
	/**
	 * @memberof utils/source-search
	 * @static
	 */
	function getSearchState(cm) {
	  return cm.state.search || (cm.state.search = new SearchState());
	}
	
	/**
	 * @memberof utils/source-search
	 * @static
	 */
	function getSearchCursor(cm, query, pos) {
	  // If the query string is all lowercase, do a case insensitive search.
	  return cm.getSearchCursor(query, pos, typeof query == "string" && query == query.toLowerCase());
	}
	
	/**
	 * Ignore doing outline matches for less than 3 whitespaces
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function ignoreWhiteSpace(str) {
	  return (/^\s{0,2}$/.test(str) ? "(?!\s*.*)" : str
	  );
	}
	
	/**
	 * This returns a mode object used by CoeMirror's addOverlay function
	 * to parse and style tokens in the file.
	 * The mode object contains a tokenizer function (token) which takes
	 * a character stream as input, advances it a character at a time,
	 * and returns style(s) for that token. For more details see
	 * https://codemirror.net/doc/manual.html#modeapi
	 *
	 * Also the token function code is mainly based of work done
	 * by the chrome devtools team. Thanks guys! :)
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function searchOverlay(query) {
	  query = new RegExp(escapeRegExp(ignoreWhiteSpace(query)));
	  var matchLength = null;
	  return {
	    token: function (stream) {
	      if (stream.column() === 0) {
	        matchLength = null;
	      }
	      if (matchLength !== null) {
	        if (matchLength > 2) {
	          for (var i = 0; i < matchLength - 2; ++i) {
	            stream.next();
	          }
	          matchLength = 1;
	          return "highlight";
	        }
	        stream.next();
	        matchLength = null;
	        return "highlight highlight-end";
	      }
	
	      var match = stream.match(query, false);
	      if (match) {
	        stream.next();
	        var len = match[0].length;
	        if (len === 1) {
	          return "highlight highlight-full";
	        }
	        matchLength = len;
	        return "highlight highlight-start";
	      }
	      while (!stream.match(query, false) && stream.peek()) {
	        stream.next();
	      }
	    }
	  };
	}
	
	/**
	 * @memberof utils/source-search
	 * @static
	 */
	function startSearch(cm, state, query) {
	  cm.removeOverlay(state.overlay);
	  state.overlay = searchOverlay(query);
	  cm.addOverlay(state.overlay, { opaque: false });
	}
	
	/**
	 * If there's a saved search, selects the next results.
	 * Otherwise, creates a new search and selects the first
	 * result.
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function doSearch(ctx, rev, query, keepSelection) {
	  var cm = ctx.cm;
	
	  var state = getSearchState(cm);
	
	  if (state.query) {
	    searchNext(ctx, rev);
	    return;
	  }
	
	  cm.operation(function () {
	    if (state.query) {
	      return;
	    }
	    startSearch(cm, state, query);
	    state.query = query;
	    if (keepSelection) {
	      state.posTo = cm.getCursor("anchor");
	      state.posFrom = cm.getCursor("head");
	    } else {
	      state.posFrom = state.posTo = { line: 0, ch: 0 };
	    }
	    searchNext(ctx, rev);
	  });
	}
	
	/**
	 * Selects the next result of a saved search.
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function searchNext(ctx, rev) {
	  var cm = ctx.cm,
	      ed = ctx.ed;
	
	  cm.operation(function () {
	    var state = getSearchState(cm);
	    var cursor = getSearchCursor(cm, state.query, rev ? state.posFrom : state.posTo);
	
	    if (!cursor.find(rev)) {
	      cursor = getSearchCursor(cm, state.query, rev ? { line: cm.lastLine(), ch: null } : { line: cm.firstLine(), ch: 0 });
	      if (!cursor.find(rev)) {
	        return;
	      }
	    }
	
	    ed.alignLine(cursor.from().line, "center");
	    cm.setSelection(cursor.from(), cursor.to());
	    state.posFrom = cursor.from();
	    state.posTo = cursor.to();
	  });
	}
	
	/**
	 * Remove overlay.
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function removeOverlay(ctx) {
	  var state = getSearchState(ctx.cm);
	  ctx.cm.removeOverlay(state.overlay);
	}
	
	/**
	 * Clears the currently saved search.
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function clearSearch(cm) {
	  var state = getSearchState(cm);
	
	  if (!state.query) {
	    return;
	  }
	  cm.removeOverlay(state.overlay);
	  state.query = null;
	}
	
	/**
	 * Starts a new search.
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function find(ctx, query, keepSelection) {
	  clearSearch(ctx.cm);
	  doSearch(ctx, false, query, keepSelection);
	}
	
	/**
	 * Finds the next item based on the currently saved search.
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function findNext(ctx, query) {
	  doSearch(ctx, false, query);
	}
	
	/**
	 * Finds the previous item based on the currently saved search.
	 *
	 * @memberof utils/source-search
	 * @static
	 */
	function findPrev(ctx, query) {
	  doSearch(ctx, true, query);
	}
	
	module.exports = { find, findNext, findPrev, removeOverlay };

/***/ },
/* 527 */
/***/ function(module, exports, __webpack_require__) {

	var toString = __webpack_require__(240);
	
	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
	    reHasRegExpChar = RegExp(reRegExpChar.source);
	
	/**
	 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
	 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to escape.
	 * @returns {string} Returns the escaped string.
	 * @example
	 *
	 * _.escapeRegExp('[lodash](https://lodash.com/)');
	 * // => '\[lodash\]\(https://lodash\.com/\)'
	 */
	function escapeRegExp(string) {
	  string = toString(string);
	  return (string && reHasRegExpChar.test(string))
	    ? string.replace(reRegExpChar, '\\$&')
	    : string;
	}
	
	module.exports = escapeRegExp;


/***/ },
/* 528 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	var dom = React.DOM,
	    PropTypes = React.PropTypes;
	
	var _require = __webpack_require__(305),
	    connect = _require.connect;
	
	var _require2 = __webpack_require__(3),
	    bindActionCreators = _require2.bindActionCreators;
	
	var actions = __webpack_require__(314);
	
	var _require3 = __webpack_require__(303),
	    getSelectedSource = _require3.getSelectedSource,
	    getSourceText = _require3.getSourceText,
	    getPrettySource = _require3.getPrettySource,
	    getPaneCollapse = _require3.getPaneCollapse;
	
	var Svg = __webpack_require__(414);
	var ImPropTypes = __webpack_require__(450);
	var classnames = __webpack_require__(413);
	
	var _require4 = __webpack_require__(197),
	    isEnabled = _require4.isEnabled;
	
	var _require5 = __webpack_require__(295),
	    isPretty = _require5.isPretty;
	
	var _require6 = __webpack_require__(529),
	    shouldShowFooter = _require6.shouldShowFooter,
	    shouldShowPrettyPrint = _require6.shouldShowPrettyPrint;
	
	var PaneToggleButton = React.createFactory(__webpack_require__(530));
	
	__webpack_require__(533);
	
	function debugBtn(onClick, type) {
	  var className = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "active";
	  var tooltip = arguments[3];
	
	  className = `${ type } ${ className } action`;
	  return dom.button({ onClick, className, key: type }, Svg(type, { title: tooltip, "aria-label": tooltip }));
	}
	
	var SourceFooter = React.createClass({
	  propTypes: {
	    selectedSource: ImPropTypes.map,
	    togglePrettyPrint: PropTypes.func,
	    recordCoverage: PropTypes.func,
	    sourceText: ImPropTypes.map,
	    selectSource: PropTypes.func,
	    prettySource: ImPropTypes.map,
	    editor: PropTypes.object,
	    endPanelCollapsed: PropTypes.bool,
	    togglePaneCollapse: PropTypes.func,
	    horizontal: PropTypes.bool
	  },
	
	  displayName: "SourceFooter",
	
	  onClickPrettyPrint() {
	    this.props.togglePrettyPrint(this.props.selectedSource.get("id"));
	  },
	
	  prettyPrintButton() {
	    var _props = this.props,
	        selectedSource = _props.selectedSource,
	        sourceText = _props.sourceText;
	
	    var sourceLoaded = selectedSource && sourceText && !sourceText.get("loading");
	
	    if (!shouldShowPrettyPrint(selectedSource)) {
	      return;
	    }
	
	    return debugBtn(this.onClickPrettyPrint, "prettyPrint", classnames({
	      active: sourceLoaded,
	      pretty: isPretty(selectedSource.toJS())
	    }), L10N.getStr("sourceFooter.debugBtnTooltip"));
	  },
	
	  coverageButton() {
	    var recordCoverage = this.props.recordCoverage;
	
	
	    if (!isEnabled("codeCoverage")) {
	      return;
	    }
	
	    return dom.button({
	      className: "coverage",
	      title: "Code Coverage",
	      onClick: () => recordCoverage()
	    }, "C");
	  },
	
	  renderToggleButton() {
	    if (this.props.horizontal) {
	      return;
	    }
	
	    return PaneToggleButton({
	      position: "end",
	      collapsed: !this.props.endPanelCollapsed,
	      horizontal: this.props.horizontal,
	      handleClick: this.props.togglePaneCollapse
	    });
	  },
	
	  renderCommands() {
	    var selectedSource = this.props.selectedSource;
	
	
	    if (!shouldShowPrettyPrint(selectedSource)) {
	      return null;
	    }
	
	    return dom.div({ className: "commands" }, this.prettyPrintButton(), this.coverageButton());
	  },
	
	  render() {
	    var _props2 = this.props,
	        selectedSource = _props2.selectedSource,
	        horizontal = _props2.horizontal;
	
	
	    if (!shouldShowFooter(selectedSource, horizontal)) {
	      return null;
	    }
	
	    return dom.div({ className: "source-footer" }, this.renderCommands(), this.renderToggleButton());
	  }
	});
	
	module.exports = connect(state => {
	  var selectedSource = getSelectedSource(state);
	  var selectedId = selectedSource && selectedSource.get("id");
	  return {
	    selectedSource,
	    sourceText: getSourceText(state, selectedId),
	    prettySource: getPrettySource(state, selectedId),
	    endPanelCollapsed: getPaneCollapse(state, "end")
	  };
	}, dispatch => bindActionCreators(actions, dispatch))(SourceFooter);

/***/ },
/* 529 */
/***/ function(module, exports, __webpack_require__) {

	var _require = __webpack_require__(295),
	    isPretty = _require.isPretty,
	    isJavaScript = _require.isJavaScript;
	
	var _require2 = __webpack_require__(316),
	    isOriginalId = _require2.isOriginalId;
	
	function shouldShowPrettyPrint(selectedSource) {
	  if (!selectedSource) {
	    return false;
	  }
	
	  selectedSource = selectedSource.toJS();
	  var _isPretty = isPretty(selectedSource);
	  var _isJavaScript = isJavaScript(selectedSource.url);
	  var isOriginal = isOriginalId(selectedSource.id);
	  var hasSourceMap = selectedSource.sourceMapURL;
	
	  if (_isPretty || isOriginal || hasSourceMap || !_isJavaScript) {
	    return false;
	  }
	
	  return true;
	}
	
	function onKeyDown(codeMirror, e) {
	  var key = e.key,
	      target = e.target;
	
	  var codeWrapper = codeMirror.getWrapperElement();
	  var textArea = codeWrapper.querySelector("textArea");
	
	  if (key === "Escape" && target == textArea) {
	    e.stopPropagation();
	    e.preventDefault();
	    codeWrapper.focus();
	  } else if (key === "Enter" && target == codeWrapper) {
	    e.preventDefault();
	    // Focus into editor's text area
	    textArea.focus();
	  }
	}
	
	function shouldShowFooter(selectedSource, horizontal) {
	  if (!horizontal) {
	    return true;
	  }
	
	  return shouldShowPrettyPrint(selectedSource);
	}
	
	function forEachLine(codeMirror, iter) {
	  codeMirror.doc.iter(0, codeMirror.lineCount(), iter);
	}
	
	function removeLineClass(codeMirror, line, className) {
	  codeMirror.removeLineClass(line, "line", className);
	}
	
	function clearLineClass(codeMirror, className) {
	  forEachLine(codeMirror, line => {
	    removeLineClass(codeMirror, line, className);
	  });
	}
	
	module.exports = {
	  shouldShowPrettyPrint,
	  shouldShowFooter,
	  clearLineClass,
	  onKeyDown
	};

/***/ },
/* 530 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	var dom = React.DOM,
	    PropTypes = React.PropTypes;
	
	var classnames = __webpack_require__(413);
	var Svg = __webpack_require__(414);
	
	__webpack_require__(531);
	
	var PaneToggleButton = React.createClass({
	  propTypes: {
	    position: PropTypes.string.isRequired,
	    collapsed: PropTypes.bool.isRequired,
	    horizontal: PropTypes.bool,
	    handleClick: PropTypes.func.isRequired
	  },
	
	  displayName: "PaneToggleButton",
	
	  shouldComponentUpdate(nextProps, nextState) {
	    var _props = this.props,
	        collapsed = _props.collapsed,
	        horizontal = _props.horizontal;
	
	
	    return horizontal !== nextProps.horizontal || collapsed !== nextProps.collapsed;
	  },
	
	  render() {
	    var _props2 = this.props,
	        position = _props2.position,
	        collapsed = _props2.collapsed,
	        horizontal = _props2.horizontal,
	        handleClick = _props2.handleClick;
	
	    var title = !collapsed ? L10N.getStr("expandPanes") : L10N.getStr("collapsePanes");
	
	    return dom.div({
	      className: classnames(`toggle-button-${ position }`, {
	        collapsed,
	        vertical: horizontal != null ? !horizontal : false
	      }),
	      onClick: () => handleClick(position, collapsed),
	      title
	    }, Svg("togglePanes"));
	  }
	});
	
	module.exports = PaneToggleButton;

/***/ },
/* 531 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 532 */,
/* 533 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 534 */,
/* 535 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	var dom = React.DOM,
	    PropTypes = React.PropTypes;
	
	var _require = __webpack_require__(22),
	    findDOMNode = _require.findDOMNode;
	
	var Svg = __webpack_require__(414);
	
	var _require2 = __webpack_require__(526),
	    find = _require2.find,
	    findNext = _require2.findNext,
	    findPrev = _require2.findPrev,
	    removeOverlay = _require2.removeOverlay;
	
	var classnames = __webpack_require__(413);
	var escapeRegExp = __webpack_require__(527);
	var debounce = __webpack_require__(536);
	var CloseButton = __webpack_require__(444);
	var ImPropTypes = __webpack_require__(450);
	
	__webpack_require__(539);
	
	function countMatches(query, text) {
	  var re = new RegExp(escapeRegExp(query), "g");
	  var match = text.match(re);
	  return match ? match.length : 0;
	}
	
	var SearchBar = React.createClass({
	
	  propTypes: {
	    editor: PropTypes.object,
	    sourceText: ImPropTypes.map,
	    selectedSource: ImPropTypes.map
	  },
	
	  displayName: "SearchBar",
	
	  getInitialState() {
	    return {
	      enabled: false,
	      query: "",
	      count: 0,
	      index: 0
	    };
	  },
	
	  contextTypes: {
	    shortcuts: PropTypes.object
	  },
	
	  componentWillUnmount() {
	    var shortcuts = this.context.shortcuts;
	    var searchAgainKey = L10N.getStr("sourceSearch.search.again.key");
	    shortcuts.off(`CmdOrCtrl+${ L10N.getStr("sourceSearch.search.key") }`);
	    shortcuts.off("Escape");
	    shortcuts.off(`CmdOrCtrl+Shift+${ searchAgainKey }`);
	    shortcuts.off(`CmdOrCtrl+${ searchAgainKey }`);
	  },
	
	  componentDidMount() {
	    var shortcuts = this.context.shortcuts;
	    var searchAgainKey = L10N.getStr("sourceSearch.search.again.key");
	    shortcuts.on(`CmdOrCtrl+${ L10N.getStr("sourceSearch.search.key") }`, (_, e) => this.toggleSearch(e));
	    shortcuts.on("Escape", (_, e) => this.onEscape(e));
	    shortcuts.on(`CmdOrCtrl+Shift+${ searchAgainKey }`, (_, e) => this.traverseResultsPrev(e));
	    shortcuts.on(`CmdOrCtrl+${ searchAgainKey }`, (_, e) => this.traverseResultsNext(e));
	  },
	
	  componentDidUpdate(prevProps) {
	    var _props = this.props,
	        sourceText = _props.sourceText,
	        selectedSource = _props.selectedSource;
	
	
	    if (this.searchInput()) {
	      this.searchInput().focus();
	    }
	
	    var hasLoaded = sourceText && !sourceText.get("loading");
	    var wasLoading = prevProps.sourceText && prevProps.sourceText.get("loading");
	
	    var doneLoading = wasLoading && hasLoaded;
	    var changedFiles = selectedSource != prevProps.selectedSource && hasLoaded;
	
	    if (doneLoading || changedFiles) {
	      this.doSearch(this.state.query);
	    }
	  },
	
	  onEscape(e) {
	    this.closeSearch(e);
	  },
	
	  closeSearch(e) {
	    var ed = this.props.editor;
	
	    if (this.state.enabled && ed) {
	      this.setState({ enabled: false });
	      var ctx = { ed, cm: ed.codeMirror };
	      removeOverlay(ctx);
	      e.stopPropagation();
	      e.preventDefault();
	    }
	  },
	
	  toggleSearch(e) {
	    e.stopPropagation();
	    e.preventDefault();
	    var editor = this.props.editor;
	
	
	    this.setState({ enabled: !this.state.enabled });
	
	    if (this.state.enabled && editor) {
	      var selection = editor.codeMirror.getSelection();
	      this.setSearchValue(selection);
	      this.doSearch(selection);
	      this.selectSearchInput();
	    }
	  },
	
	  setSearchValue(value) {
	    if (value == "") {
	      return;
	    }
	
	    this.searchInput().value = value;
	  },
	
	  selectSearchInput() {
	    var node = this.searchInput();
	    if (node) {
	      node.setSelectionRange(0, node.value.length);
	    }
	  },
	
	  searchInput() {
	    return findDOMNode(this).querySelector("input");
	  },
	
	  doSearch(query) {
	    var sourceText = this.props.sourceText;
	    if (!sourceText) {
	      return;
	    }
	
	    var count = countMatches(query, sourceText.get("text"));
	    // eslint-disable-next-line react/no-did-update-set-state
	    this.setState({ query, count, index: 0 });
	    this.search(query);
	  },
	
	  onChange(e) {
	    return this.doSearch(e.target.value);
	  },
	
	  traverseResultsPrev(e) {
	    e.stopPropagation();
	    e.preventDefault();
	
	    var ed = this.props.editor;
	
	    if (!ed) {
	      return;
	    }
	
	    var ctx = { ed, cm: ed.codeMirror };
	    var _state = this.state,
	        query = _state.query,
	        index = _state.index,
	        count = _state.count;
	
	
	    if (query == "") {
	      this.setState({ enabled: true });
	    }
	
	    findPrev(ctx, query);
	    var nextIndex = index == 0 ? count - 1 : index - 1;
	    this.setState({ index: nextIndex });
	  },
	
	  traverseResultsNext(e) {
	    e.stopPropagation();
	    e.preventDefault();
	
	    var ed = this.props.editor;
	
	    if (!ed) {
	      return;
	    }
	
	    var ctx = { ed, cm: ed.codeMirror };
	    var _state2 = this.state,
	        query = _state2.query,
	        index = _state2.index,
	        count = _state2.count;
	
	
	    if (query == "") {
	      this.setState({ enabled: true });
	    }
	
	    findNext(ctx, query);
	    var nextIndex = index == count - 1 ? 0 : index + 1;
	    this.setState({ index: nextIndex });
	  },
	
	  onKeyUp(e) {
	    if (e.key != "Enter") {
	      return;
	    }
	
	    if (e.shiftKey) {
	      this.traverseResultsPrev(e);
	    } else {
	      this.traverseResultsNext(e);
	    }
	  },
	
	  search: debounce(function (query) {
	    var sourceText = this.props.sourceText;
	
	    if (!sourceText || !sourceText.get("text")) {
	      return;
	    }
	
	    var ed = this.props.editor;
	    var ctx = { ed, cm: ed.codeMirror };
	
	    find(ctx, query);
	  }, 100),
	
	  renderSummary() {
	    var _state3 = this.state,
	        count = _state3.count,
	        index = _state3.index,
	        query = _state3.query;
	
	
	    if (query.trim() == "") {
	      return dom.div({});
	    } else if (count == 0) {
	      return dom.div({ className: "summary" }, L10N.getStr("editor.noResults"));
	    }
	
	    return dom.div({ className: "summary" }, L10N.getFormatStr("editor.searchResults", index + 1, count));
	  },
	
	  renderSvg() {
	    var _state4 = this.state,
	        count = _state4.count,
	        query = _state4.query;
	
	
	    if (count == 0 && query.trim() != "") {
	      return Svg("sad-face");
	    }
	
	    return Svg("magnifying-glass");
	  },
	
	  render() {
	    if (!this.state.enabled) {
	      return dom.div();
	    }
	
	    var _state5 = this.state,
	        count = _state5.count,
	        query = _state5.query;
	
	
	    return dom.div({ className: "search-bar" }, this.renderSvg(), dom.input({
	      className: classnames({
	        empty: count == 0 && query.trim() != ""
	      }),
	      onChange: this.onChange,
	      onKeyUp: this.onKeyUp,
	      placeholder: "Search in file...",
	      value: this.state.query,
	      spellCheck: false
	    }), this.renderSummary(), CloseButton({
	      handleClick: this.closeSearch,
	      buttonClass: "big"
	    }));
	  }
	});
	
	module.exports = SearchBar;

/***/ },
/* 536 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(216),
	    now = __webpack_require__(537),
	    toNumber = __webpack_require__(538);
	
	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max,
	    nativeMin = Math.min;
	
	/**
	 * Creates a debounced function that delays invoking `func` until after `wait`
	 * milliseconds have elapsed since the last time the debounced function was
	 * invoked. The debounced function comes with a `cancel` method to cancel
	 * delayed `func` invocations and a `flush` method to immediately invoke them.
	 * Provide `options` to indicate whether `func` should be invoked on the
	 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	 * with the last arguments provided to the debounced function. Subsequent
	 * calls to the debounced function return the result of the last `func`
	 * invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the debounced function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.debounce` and `_.throttle`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to debounce.
	 * @param {number} [wait=0] The number of milliseconds to delay.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=false]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {number} [options.maxWait]
	 *  The maximum time `func` is allowed to be delayed before it's invoked.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new debounced function.
	 * @example
	 *
	 * // Avoid costly calculations while the window size is in flux.
	 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	 *
	 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	 * jQuery(element).on('click', _.debounce(sendMail, 300, {
	 *   'leading': true,
	 *   'trailing': false
	 * }));
	 *
	 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	 * var source = new EventSource('/stream');
	 * jQuery(source).on('message', debounced);
	 *
	 * // Cancel the trailing debounced invocation.
	 * jQuery(window).on('popstate', debounced.cancel);
	 */
	function debounce(func, wait, options) {
	  var lastArgs,
	      lastThis,
	      maxWait,
	      result,
	      timerId,
	      lastCallTime,
	      lastInvokeTime = 0,
	      leading = false,
	      maxing = false,
	      trailing = true;
	
	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  wait = toNumber(wait) || 0;
	  if (isObject(options)) {
	    leading = !!options.leading;
	    maxing = 'maxWait' in options;
	    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }
	
	  function invokeFunc(time) {
	    var args = lastArgs,
	        thisArg = lastThis;
	
	    lastArgs = lastThis = undefined;
	    lastInvokeTime = time;
	    result = func.apply(thisArg, args);
	    return result;
	  }
	
	  function leadingEdge(time) {
	    // Reset any `maxWait` timer.
	    lastInvokeTime = time;
	    // Start the timer for the trailing edge.
	    timerId = setTimeout(timerExpired, wait);
	    // Invoke the leading edge.
	    return leading ? invokeFunc(time) : result;
	  }
	
	  function remainingWait(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime,
	        result = wait - timeSinceLastCall;
	
	    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
	  }
	
	  function shouldInvoke(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime;
	
	    // Either this is the first call, activity has stopped and we're at the
	    // trailing edge, the system time has gone backwards and we're treating
	    // it as the trailing edge, or we've hit the `maxWait` limit.
	    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
	      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	  }
	
	  function timerExpired() {
	    var time = now();
	    if (shouldInvoke(time)) {
	      return trailingEdge(time);
	    }
	    // Restart the timer.
	    timerId = setTimeout(timerExpired, remainingWait(time));
	  }
	
	  function trailingEdge(time) {
	    timerId = undefined;
	
	    // Only invoke if we have `lastArgs` which means `func` has been
	    // debounced at least once.
	    if (trailing && lastArgs) {
	      return invokeFunc(time);
	    }
	    lastArgs = lastThis = undefined;
	    return result;
	  }
	
	  function cancel() {
	    if (timerId !== undefined) {
	      clearTimeout(timerId);
	    }
	    lastInvokeTime = 0;
	    lastArgs = lastCallTime = lastThis = timerId = undefined;
	  }
	
	  function flush() {
	    return timerId === undefined ? result : trailingEdge(now());
	  }
	
	  function debounced() {
	    var time = now(),
	        isInvoking = shouldInvoke(time);
	
	    lastArgs = arguments;
	    lastThis = this;
	    lastCallTime = time;
	
	    if (isInvoking) {
	      if (timerId === undefined) {
	        return leadingEdge(lastCallTime);
	      }
	      if (maxing) {
	        // Handle invocations in a tight loop.
	        timerId = setTimeout(timerExpired, wait);
	        return invokeFunc(lastCallTime);
	      }
	    }
	    if (timerId === undefined) {
	      timerId = setTimeout(timerExpired, wait);
	    }
	    return result;
	  }
	  debounced.cancel = cancel;
	  debounced.flush = flush;
	  return debounced;
	}
	
	module.exports = debounce;


/***/ },
/* 537 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(8);
	
	/**
	 * Gets the timestamp of the number of milliseconds that have elapsed since
	 * the Unix epoch (1 January 1970 00:00:00 UTC).
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Date
	 * @returns {number} Returns the timestamp.
	 * @example
	 *
	 * _.defer(function(stamp) {
	 *   console.log(_.now() - stamp);
	 * }, _.now());
	 * // => Logs the number of milliseconds it took for the deferred invocation.
	 */
	var now = function() {
	  return root.Date.now();
	};
	
	module.exports = now;


/***/ },
/* 538 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(216),
	    isSymbol = __webpack_require__(204);
	
	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;
	
	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;
	
	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
	
	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;
	
	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;
	
	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;
	
	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}
	
	module.exports = toNumber;


/***/ },
/* 539 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 540 */,
/* 541 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	var dom = React.DOM;
	
	
	var ReactDOM = __webpack_require__(22);
	
	function renderConditionalPanel(_ref) {
	  var condition = _ref.condition,
	      closePanel = _ref.closePanel,
	      setBreakpoint = _ref.setBreakpoint;
	
	  var panel = document.createElement("div");
	
	  function onKey(e) {
	    if (e.key != "Enter") {
	      return;
	    }
	
	    setBreakpoint(e.target.value);
	    closePanel();
	  }
	
	  ReactDOM.render(dom.div({ className: "conditional-breakpoint-panel" }, dom.input({
	    defaultValue: condition,
	    placeholder: L10N.getStr("editor.conditionalPanel.placeholder"),
	    onKeyPress: onKey
	  })), panel);
	
	  return panel;
	}
	
	module.exports = {
	  renderConditionalPanel
	};

/***/ },
/* 542 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	var ReactDOM = __webpack_require__(22);
	
	var PropTypes = React.PropTypes;
	
	var classnames = __webpack_require__(413);
	var Svg = __webpack_require__(414);
	
	var breakpointSvg = document.createElement("div");
	ReactDOM.render(Svg("breakpoint"), breakpointSvg);
	
	function makeMarker(isDisabled) {
	  var bp = breakpointSvg.cloneNode(true);
	  bp.className = classnames("editor new-breakpoint", { "breakpoint-disabled": isDisabled });
	
	  return bp;
	}
	
	var Breakpoint = React.createClass({
	  propTypes: {
	    breakpoint: PropTypes.object,
	    editor: PropTypes.object
	  },
	
	  displayName: "Breakpoint",
	
	  addBreakpoint() {
	    var bp = this.props.breakpoint;
	    var line = bp.location.line - 1;
	
	    this.props.editor.setGutterMarker(line, "breakpoints", makeMarker(bp.disabled));
	    this.props.editor.addLineClass(line, "line", "new-breakpoint");
	    if (bp.condition) {
	      this.props.editor.addLineClass(line, "line", "has-condition");
	    }
	  },
	
	  shouldComponentUpdate(nextProps) {
	    return this.props.editor !== nextProps.editor || this.props.breakpoint.disabled !== nextProps.breakpoint.disabled || this.props.breakpoint.condition !== nextProps.breakpoint.condition;
	  },
	
	  componentDidMount() {
	    if (!this.props.editor) {
	      return;
	    }
	
	    this.addBreakpoint();
	  },
	
	  componentDidUpdate() {
	    this.addBreakpoint();
	  },
	
	  componentWillUnmount() {
	    if (!this.props.editor) {
	      return;
	    }
	
	    var bp = this.props.breakpoint;
	    var line = bp.location.line - 1;
	
	    this.props.editor.setGutterMarker(line, "breakpoints", null);
	    this.props.editor.removeLineClass(line, "line", "new-breakpoint");
	    this.props.editor.removeLineClass(line, "line", "has-condition");
	  },
	
	  render() {
	    return null;
	  }
	});
	
	module.exports = Breakpoint;

/***/ },
/* 543 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	var PropTypes = React.PropTypes;
	
	
	var markerEl = document.createElement("div");
	
	function makeMarker() {
	  var marker = markerEl.cloneNode(true);
	  marker.className = "editor hit-marker";
	  return marker;
	}
	
	var HitMarker = React.createClass({
	  propTypes: {
	    hitData: PropTypes.object,
	    editor: PropTypes.object
	  },
	
	  displayName: "HitMarker",
	
	  addMarker() {
	    var hitData = this.props.hitData;
	    var line = hitData.line - 1;
	
	    this.props.editor.setGutterMarker(line, "hit-markers", makeMarker());
	
	    this.props.editor.addLineClass(line, "line", "hit-marker");
	  },
	
	  shouldComponentUpdate(nextProps) {
	    return this.props.editor !== nextProps.editor || this.props.hitData !== nextProps.hitData;
	  },
	
	  componentDidMount() {
	    if (!this.props.editor) {
	      return;
	    }
	
	    this.addMarker();
	  },
	
	  componentDidUpdate() {
	    this.addMarker();
	  },
	
	  componentWillUnmount() {
	    if (!this.props.editor) {
	      return;
	    }
	
	    var hitData = this.props.hitData;
	    var line = hitData.line - 1;
	
	    this.props.editor.setGutterMarker(line, "hit-markers", null);
	    this.props.editor.removeLineClass(line, "line", "hit-marker");
	  },
	
	  render() {
	    return null;
	  }
	});
	
	module.exports = HitMarker;

/***/ },
/* 544 */
/***/ function(module, exports, __webpack_require__) {

	var _require = __webpack_require__(256),
	    Menu = _require.Menu,
	    MenuItem = _require.MenuItem;
	
	var _require2 = __webpack_require__(197),
	    isFirefoxPanel = _require2.isFirefoxPanel;
	
	function createPopup(doc) {
	  var popup = doc.createElement("menupopup");
	
	  if (popup.openPopupAtScreen) {
	    return popup;
	  }
	
	  function preventDefault(e) {
	    e.preventDefault();
	    e.returnValue = false;
	  }
	
	  var mask = document.querySelector("#contextmenu-mask");
	  if (!mask) {
	    mask = doc.createElement("div");
	    mask.id = "contextmenu-mask";
	    document.body.appendChild(mask);
	  }
	
	  mask.onclick = () => popup.hidePopup();
	
	  popup.openPopupAtScreen = function (clientX, clientY) {
	    this.style.setProperty("left", `${ clientX }px`);
	    this.style.setProperty("top", `${ clientY }px`);
	    mask = document.querySelector("#contextmenu-mask");
	    window.onwheel = preventDefault;
	    mask.classList.add("show");
	    this.dispatchEvent(new Event("popupshown"));
	    this.popupshown;
	  };
	
	  popup.hidePopup = function () {
	    this.remove();
	    mask = document.querySelector("#contextmenu-mask");
	    mask.classList.remove("show");
	    window.onwheel = null;
	  };
	
	  return popup;
	}
	
	if (!isFirefoxPanel()) {
	  Menu.prototype.createPopup = createPopup;
	}
	
	function onShown(menu, popup) {
	  popup.childNodes.forEach((menuitem, index) => {
	    var item = menu.items[index];
	
	    if (!item.disabled) {
	      menuitem.onclick = () => {
	        item.click();
	        popup.hidePopup();
	      };
	    }
	  });
	}
	
	function showMenu(e, items) {
	  var menu = new Menu();
	  items.forEach(item => menu.append(new MenuItem(item)));
	
	  if (isFirefoxPanel()) {
	    return menu.popup(e.screenX, e.screenY, { doc: window.parent.document });
	  }
	
	  menu.on("open", (_, popup) => onShown(menu, popup));
	  return menu.popup(e.clientX, e.clientY, { doc: document });
	}
	
	function buildMenu(items) {
	  return items.map(itm => {
	    var hide = typeof itm.hidden === "function" ? itm.hidden() : itm.hidden;
	    return hide ? null : itm.item;
	  }).filter(itm => itm !== null);
	}
	
	module.exports = {
	  showMenu,
	  buildMenu
	};

/***/ },
/* 545 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 546 */,
/* 547 */
/***/ function(module, exports, __webpack_require__) {

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	var React = __webpack_require__(2);
	var dom = React.DOM,
	    PropTypes = React.PropTypes,
	    createFactory = React.createFactory;
	
	var _require = __webpack_require__(305),
	    connect = _require.connect;
	
	var _require2 = __webpack_require__(3),
	    bindActionCreators = _require2.bindActionCreators;
	
	var _require3 = __webpack_require__(197),
	    isEnabled = _require3.isEnabled;
	
	var Svg = __webpack_require__(414);
	var ImPropTypes = __webpack_require__(450);
	
	var _require4 = __webpack_require__(303),
	    getPause = _require4.getPause,
	    getBreakpoints = _require4.getBreakpoints,
	    getBreakpointsDisabled = _require4.getBreakpointsDisabled,
	    getBreakpointsLoading = _require4.getBreakpointsLoading;
	
	var _require5 = __webpack_require__(255),
	    prefs = _require5.prefs;
	
	var actions = __webpack_require__(314);
	var WhyPaused = React.createFactory(__webpack_require__(548));
	var Breakpoints = React.createFactory(__webpack_require__(551));
	var Expressions = React.createFactory(__webpack_require__(554));
	
	var SplitBox = createFactory(__webpack_require__(28).SplitBox);
	var Scopes = isEnabled("chromeScopes") ? React.createFactory(__webpack_require__(596)) : React.createFactory(__webpack_require__(599));
	
	var Frames = React.createFactory(__webpack_require__(613));
	var EventListeners = React.createFactory(__webpack_require__(616));
	var Accordion = React.createFactory(__webpack_require__(619));
	var CommandBar = React.createFactory(__webpack_require__(622));
	__webpack_require__(625);
	
	function debugBtn(onClick, type, className, tooltip) {
	  className = `${ type } ${ className }`;
	  return dom.button({ onClick, className, key: type, title: tooltip }, Svg(type, { title: tooltip, "aria-label": tooltip }));
	}
	
	var SecondaryPanes = React.createClass({
	  propTypes: {
	    evaluateExpressions: PropTypes.func,
	    pauseData: ImPropTypes.map,
	    horizontal: PropTypes.bool,
	    breakpoints: ImPropTypes.map,
	    breakpointsDisabled: PropTypes.bool,
	    breakpointsLoading: PropTypes.bool,
	    toggleAllBreakpoints: PropTypes.func
	  },
	
	  contextTypes: {
	    shortcuts: PropTypes.object
	  },
	
	  displayName: "SecondaryPanes",
	
	  renderBreakpointsToggle() {
	    var _props = this.props,
	        toggleAllBreakpoints = _props.toggleAllBreakpoints,
	        breakpoints = _props.breakpoints,
	        breakpointsDisabled = _props.breakpointsDisabled,
	        breakpointsLoading = _props.breakpointsLoading;
	
	    var boxClassName = "breakpoints-toggle";
	    var isIndeterminate = !breakpointsDisabled && breakpoints.some(x => x.disabled);
	
	    if (breakpoints.size == 0) {
	      return null;
	    }
	
	    return dom.input({
	      type: "checkbox",
	      "aria-label": breakpointsDisabled ? L10N.getStr("breakpoints.enable") : L10N.getStr("breakpoints.disable"),
	      className: boxClassName,
	      disabled: breakpointsLoading,
	      onClick: () => toggleAllBreakpoints(!breakpointsDisabled),
	      checked: !breakpointsDisabled && !isIndeterminate,
	      ref: input => {
	        if (input) {
	          input.indeterminate = isIndeterminate;
	        }
	      },
	      title: breakpointsDisabled ? L10N.getStr("breakpoints.enable") : L10N.getStr("breakpoints.disable")
	    });
	  },
	
	  watchExpressionHeaderButtons() {
	    return [debugBtn(evt => {
	      evt.stopPropagation();
	      this.props.evaluateExpressions();
	    }, "refresh", "refresh", L10N.getStr("watchExpressions.refreshButton"))];
	  },
	
	  getScopeItem() {
	    var isPaused = () => !!this.props.pauseData;
	
	    return {
	      header: L10N.getStr("scopes.header"),
	      component: Scopes,
	      opened: prefs.scopesVisible,
	      onToggle: opened => {
	        prefs.scopesVisible = opened;
	      },
	      shouldOpen: isPaused
	    };
	  },
	
	  getWatchItem() {
	    return { header: L10N.getStr("watchExpressions.header"),
	      buttons: this.watchExpressionHeaderButtons(),
	      component: Expressions,
	      opened: true
	    };
	  },
	
	  getStartItems() {
	    var scopesContent = this.props.horizontal ? this.getScopeItem() : null;
	    var isPaused = () => !!this.props.pauseData;
	
	    var items = [{ header: L10N.getStr("breakpoints.header"),
	      buttons: this.renderBreakpointsToggle(),
	      component: Breakpoints,
	      opened: true }, { header: L10N.getStr("callStack.header"),
	      component: Frames,
	      opened: prefs.callStackVisible,
	      onToggle: opened => {
	        prefs.callStackVisible = opened;
	      },
	      shouldOpen: isPaused }, scopesContent];
	
	    if (isEnabled("eventListeners")) {
	      items.push({
	        header: L10N.getStr("eventListenersHeader"),
	        component: EventListeners
	      });
	    }
	
	    if (isEnabled("watchExpressions") && this.props.horizontal) {
	      items.unshift(this.getWatchItem());
	    }
	
	    return items.filter(item => item);
	  },
	
	  renderHorizontalLayout() {
	    return Accordion({
	      items: this.getItems()
	    });
	  },
	
	  getEndItems() {
	    var items = [];
	
	    if (!this.props.horizontal) {
	      items.unshift(this.getScopeItem());
	    }
	
	    if (isEnabled("watchExpressions") && !this.props.horizontal) {
	      items.unshift(this.getWatchItem());
	    }
	
	    return items;
	  },
	
	  getItems() {
	    return [].concat(_toConsumableArray(this.getStartItems()), _toConsumableArray(this.getEndItems()));
	  },
	
	  renderVerticalLayout() {
	    return SplitBox({
	      style: { width: "100vw" },
	      initialSize: "300px",
	      minSize: 10,
	      maxSize: "50%",
	      splitterSize: 1,
	      startPanel: Accordion({ items: this.getStartItems() }),
	      endPanel: Accordion({ items: this.getEndItems() })
	    });
	  },
	
	  render() {
	    return dom.div({ className: "secondary-panes",
	      style: { overflowX: "hidden" } }, CommandBar(), WhyPaused(), this.props.horizontal ? this.renderHorizontalLayout() : this.renderVerticalLayout());
	  }
	});
	
	module.exports = connect(state => ({
	  pauseData: getPause(state),
	  breakpoints: getBreakpoints(state),
	  breakpointsDisabled: getBreakpointsDisabled(state),
	  breakpointsLoading: getBreakpointsLoading(state)
	}), dispatch => bindActionCreators(actions, dispatch))(SecondaryPanes);

/***/ },
/* 548 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	
	var _require = __webpack_require__(3),
	    bindActionCreators = _require.bindActionCreators;
	
	var _require2 = __webpack_require__(305),
	    connect = _require2.connect;
	
	var ImPropTypes = __webpack_require__(450);
	var actions = __webpack_require__(314);
	
	var _require3 = __webpack_require__(303),
	    getPause = _require3.getPause;
	
	var dom = React.DOM;
	
	var _require4 = __webpack_require__(325),
	    getPauseReason = _require4.getPauseReason;
	
	__webpack_require__(549);
	
	var WhyPaused = React.createClass({
	  propTypes: {
	    pauseInfo: ImPropTypes.map
	  },
	
	  displayName: "WhyPaused",
	
	  render() {
	    var pauseInfo = this.props.pauseInfo;
	
	    var reason = getPauseReason(pauseInfo);
	    var message = pauseInfo ? pauseInfo.getIn(["why"]).get("message") : null;
	
	    // => here
	    return reason ? dom.div({ className: "pane why-paused" }, [dom.div(null, L10N.getStr(reason)), message ? dom.div(null, message) : null]) : null;
	  }
	});
	
	module.exports = connect(state => ({
	  pauseInfo: getPause(state)
	}), dispatch => bindActionCreators(actions, dispatch))(WhyPaused);

/***/ },
/* 549 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 550 */,
/* 551 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	
	var _require = __webpack_require__(305),
	    connect = _require.connect;
	
	var _require2 = __webpack_require__(3),
	    bindActionCreators = _require2.bindActionCreators;
	
	var ImPropTypes = __webpack_require__(450);
	var classnames = __webpack_require__(413);
	var actions = __webpack_require__(314);
	
	var _require3 = __webpack_require__(303),
	    getSource = _require3.getSource,
	    getPause = _require3.getPause,
	    getBreakpoints = _require3.getBreakpoints;
	
	var _require4 = __webpack_require__(297),
	    makeLocationId = _require4.makeLocationId;
	
	var _require5 = __webpack_require__(250),
	    truncateStr = _require5.truncateStr;
	
	var dom = React.DOM,
	    PropTypes = React.PropTypes;
	
	var _require6 = __webpack_require__(250),
	    endTruncateStr = _require6.endTruncateStr;
	
	var _require7 = __webpack_require__(296),
	    basename = _require7.basename;
	
	var CloseButton = __webpack_require__(444);
	
	__webpack_require__(552);
	
	function isCurrentlyPausedAtBreakpoint(state, breakpoint) {
	  var pause = getPause(state);
	  if (!pause || pause.get("isInterrupted")) {
	    return false;
	  }
	
	  var bpId = makeLocationId(breakpoint.location);
	  var pausedId = makeLocationId(pause.getIn(["frame", "location"]).toJS());
	
	  return bpId === pausedId;
	}
	
	function renderSourceLocation(source, line) {
	  var url = source.get("url") ? basename(source.get("url")) : null;
	  // const line = url !== "" ? `: ${line}` : "";
	  return url ? dom.div({ className: "location" }, `${ endTruncateStr(url, 30) }: ${ line }`) : null;
	}
	
	var Breakpoints = React.createClass({
	  propTypes: {
	    breakpoints: ImPropTypes.map.isRequired,
	    enableBreakpoint: PropTypes.func.isRequired,
	    disableBreakpoint: PropTypes.func.isRequired,
	    selectSource: PropTypes.func.isRequired,
	    removeBreakpoint: PropTypes.func.isRequired
	  },
	
	  displayName: "Breakpoints",
	
	  shouldComponentUpdate(nextProps, nextState) {
	    var breakpoints = this.props.breakpoints;
	
	    return breakpoints !== nextProps.breakpoints;
	  },
	
	  handleCheckbox(breakpoint) {
	    if (breakpoint.loading) {
	      return;
	    }
	
	    if (breakpoint.disabled) {
	      this.props.enableBreakpoint(breakpoint.location);
	    } else {
	      this.props.disableBreakpoint(breakpoint.location);
	    }
	  },
	
	  selectBreakpoint(breakpoint) {
	    var sourceId = breakpoint.location.sourceId;
	    var line = breakpoint.location.line;
	    this.props.selectSource(sourceId, { line });
	  },
	
	  removeBreakpoint(event, breakpoint) {
	    event.stopPropagation();
	    this.props.removeBreakpoint(breakpoint.location);
	  },
	
	  renderBreakpoint(breakpoint) {
	    var snippet = breakpoint.text || "";
	    var locationId = breakpoint.locationId;
	    var line = breakpoint.location.line;
	    var isCurrentlyPaused = breakpoint.isCurrentlyPaused;
	    var isDisabled = breakpoint.disabled;
	    var isConditional = breakpoint.condition !== null;
	
	    return dom.div({
	      className: classnames({
	        breakpoint,
	        paused: isCurrentlyPaused,
	        disabled: isDisabled,
	        "is-conditional": isConditional
	      }),
	      key: locationId,
	      onClick: () => this.selectBreakpoint(breakpoint)
	    }, dom.input({
	      type: "checkbox",
	      className: "breakpoint-checkbox",
	      checked: !isDisabled,
	      onChange: () => this.handleCheckbox(breakpoint),
	      // Prevent clicking on the checkbox from triggering the onClick of
	      // the surrounding div
	      onClick: ev => ev.stopPropagation()
	    }), dom.div({ className: "breakpoint-label", title: breakpoint.text }, dom.div({}, renderSourceLocation(breakpoint.location.source, line))), dom.div({ className: "breakpoint-snippet" }, snippet), CloseButton({
	      handleClick: ev => this.removeBreakpoint(ev, breakpoint),
	      tooltip: L10N.getStr("breakpoints.removeBreakpointTooltip")
	    }));
	  },
	
	  render() {
	    var breakpoints = this.props.breakpoints;
	
	    return dom.div({ className: "pane breakpoints-list" }, breakpoints.size === 0 ? dom.div({ className: "pane-info" }, L10N.getStr("breakpoints.none")) : breakpoints.valueSeq().map(bp => {
	      return this.renderBreakpoint(bp);
	    }));
	  }
	});
	
	function _getBreakpoints(state) {
	  return getBreakpoints(state).map(bp => {
	    var source = getSource(state, bp.location.sourceId);
	    var isCurrentlyPaused = isCurrentlyPausedAtBreakpoint(state, bp);
	    var locationId = makeLocationId(bp.location);
	
	    bp = Object.assign({}, bp);
	    bp.location.source = source;
	    bp.locationId = locationId;
	    bp.isCurrentlyPaused = isCurrentlyPaused;
	    return bp;
	  }).filter(bp => bp.location.source);
	}
	
	module.exports = connect((state, props) => ({
	  breakpoints: _getBreakpoints(state)
	}), dispatch => bindActionCreators(actions, dispatch))(Breakpoints);

/***/ },
/* 552 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 553 */,
/* 554 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	
	var _require = __webpack_require__(305),
	    connect = _require.connect;
	
	var _require2 = __webpack_require__(3),
	    bindActionCreators = _require2.bindActionCreators;
	
	var ImPropTypes = __webpack_require__(450);
	var actions = __webpack_require__(314);
	
	var _require3 = __webpack_require__(303),
	    getExpressions = _require3.getExpressions,
	    getLoadedObjects = _require3.getLoadedObjects,
	    getPause = _require3.getPause;
	
	var CloseButton = React.createFactory(__webpack_require__(444));
	var ObjectInspector = React.createFactory(__webpack_require__(555));
	var dom = React.DOM,
	    PropTypes = React.PropTypes;
	
	
	__webpack_require__(594);
	
	function getValue(expression) {
	  var value = expression.value;
	  if (!value) {
	    return {
	      path: expression.from,
	      value: "<not available>"
	    };
	  }
	
	  if (value.exception) {
	    return {
	      path: expression.from,
	      value: value.exception
	    };
	  }
	
	  if (typeof value.result == "object") {
	    return {
	      path: value.result.actor,
	      value: value.result
	    };
	  }
	
	  return {
	    path: value.input,
	    value: value.result
	  };
	}
	
	var Expressions = React.createClass({
	  propTypes: {
	    expressions: ImPropTypes.list,
	    addExpression: PropTypes.func,
	    updateExpression: PropTypes.func,
	    deleteExpression: PropTypes.func,
	    loadObjectProperties: PropTypes.func,
	    loadedObjects: ImPropTypes.map
	  },
	
	  displayName: "Expressions",
	
	  shouldComponentUpdate(nextProps, nextState) {
	    var _props = this.props,
	        expressions = _props.expressions,
	        loadedObjects = _props.loadedObjects;
	
	    return expressions !== nextProps.expressions || loadedObjects !== nextProps.loadedObjects;
	  },
	
	  inputKeyPress(e, _ref) {
	    var id = _ref.id;
	
	    if (e.key !== "Enter") {
	      return;
	    }
	    var addExpression = this.props.addExpression;
	
	    var expression = {
	      input: e.target.value,
	      id
	    };
	
	    e.target.value = "";
	    addExpression(expression);
	  },
	
	  updateExpression(expression, _ref2) {
	    var depth = _ref2.depth;
	
	    if (depth > 0) {
	      return;
	    }
	
	    this.props.updateExpression({
	      id: expression.id,
	      input: expression.input
	    });
	  },
	
	  deleteExpression(e, expression) {
	    e.stopPropagation();
	    var deleteExpression = this.props.deleteExpression;
	
	    deleteExpression(expression);
	  },
	
	  renderExpressionUpdating(expression) {
	    return dom.span({ className: "expression-input-container" }, dom.input({ type: "text",
	      className: "input-expression",
	      onKeyPress: e => this.inputKeyPress(e, expression),
	      defaultValue: expression.input,
	      ref: c => {
	        this._input = c;
	      }
	    }));
	  },
	
	  renderExpression(expression) {
	    var _props2 = this.props,
	        loadObjectProperties = _props2.loadObjectProperties,
	        loadedObjects = _props2.loadedObjects;
	
	
	    if (expression.updating) {
	      return this.renderExpressionUpdating(expression);
	    }
	
	    var _getValue = getValue(expression),
	        value = _getValue.value,
	        path = _getValue.path;
	
	    var root = {
	      name: expression.input,
	      path,
	      contents: { value }
	    };
	
	    return dom.div({
	      className: "expression-container",
	      key: path
	    }, ObjectInspector({
	      roots: [root],
	      getObjectProperties: id => loadedObjects.get(id),
	      autoExpandDepth: 0,
	      onLabelClick: (item, options) => this.updateExpression(expression, options),
	      loadObjectProperties
	    }), CloseButton({ handleClick: e => this.deleteExpression(e, expression) }));
	  },
	
	  componentDidUpdate() {
	    if (this._input) {
	      this._input.focus();
	    }
	  },
	
	  render() {
	    var expressions = this.props.expressions;
	
	    return dom.span({ className: "pane expressions-list" }, expressions.toSeq().map(this.renderExpression), dom.input({ type: "text",
	      className: "input-expression",
	      placeholder: L10N.getStr("expressions.placeholder"),
	      onKeyPress: e => this.inputKeyPress(e, {}) }));
	  }
	});
	
	module.exports = connect(state => ({
	  pauseInfo: getPause(state),
	  expressions: getExpressions(state),
	  loadedObjects: getLoadedObjects(state)
	}), dispatch => bindActionCreators(actions, dispatch))(Expressions);

/***/ },
/* 555 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	var classnames = __webpack_require__(413);
	var ManagedTree = React.createFactory(__webpack_require__(506));
	var Svg = __webpack_require__(414);
	var Rep = __webpack_require__(556);
	
	var _require = __webpack_require__(557),
	    MODE = _require.MODE;
	
	var dom = React.DOM,
	    PropTypes = React.PropTypes;
	
	
	var WINDOW_PROPERTIES = Object.getOwnPropertyNames(window);
	
	__webpack_require__(592);
	
	// This implements a component that renders an interactive inspector
	// for looking at JavaScript objects. It expects descriptions of
	// objects from the protocol, and will dynamically fetch child
	// properties as objects are expanded.
	//
	// If you want to inspect a single object, pass the name and the
	// protocol descriptor of it:
	//
	//  ObjectInspector({
	//    name: "foo",
	//    desc: { writable: true, ..., { value: { actor: "1", ... }}},
	//    ...
	//  })
	//
	// If you want multiple top-level objects (like scopes), you can pass
	// an array of manually constructed nodes as `roots`:
	//
	//  ObjectInspector({
	//    roots: [{ name: ... }, ...],
	//    ...
	//  });
	
	// There are 3 types of nodes: a simple node with a children array, an
	// object that has properties that should be children when they are
	// fetched, and a primitive value that should be displayed with no
	// children.
	
	function nodeHasChildren(item) {
	  return Array.isArray(item.contents);
	}
	
	function nodeIsOptimizedOut(item) {
	  return !nodeHasChildren(item) && item.contents.value.optimizedOut === true;
	}
	
	function nodeIsMissingArguments(item) {
	  return !nodeHasChildren(item) && item.contents.value.missingArguments === true;
	}
	
	function nodeHasProperties(item) {
	  return !nodeHasChildren(item) && item.contents.value.type === "object";
	}
	
	function nodeIsPrimitive(item) {
	  return !nodeHasChildren(item) && !nodeHasProperties(item);
	}
	
	function isDefault(item) {
	  return WINDOW_PROPERTIES.includes(item.name);
	}
	
	function makeNodesForProperties(objProps, parentPath) {
	  var ownProperties = objProps.ownProperties,
	      prototype = objProps.prototype;
	
	
	  var nodes = Object.keys(ownProperties).sort().filter(name => {
	    // Ignore non-concrete values like getters and setters
	    // for now by making sure we have a value.
	    return "value" in ownProperties[name];
	  }).map(name => {
	    return createNode(name, `${ parentPath }/${ name }`, ownProperties[name]);
	  });
	
	  // Add the prototype if it exists and is not null
	  if (prototype && prototype.type !== "null") {
	    nodes.push(createNode("__proto__", `${ parentPath }/__proto__`, { value: prototype }));
	  }
	
	  return nodes;
	}
	
	function createNode(name, path, contents) {
	  // The path is important to uniquely identify the item in the entire
	  // tree. This helps debugging & optimizes React's rendering of large
	  // lists. The path will be separated by property name,
	  // i.e. `{ foo: { bar: { baz: 5 }}}` will have a path of `foo/bar/baz`
	  // for the inner object.
	  return { name, path, contents };
	}
	
	var ObjectInspector = React.createClass({
	  propTypes: {
	    autoExpandDepth: PropTypes.number,
	    name: PropTypes.string,
	    desc: PropTypes.object,
	    roots: PropTypes.array,
	    getObjectProperties: PropTypes.func.isRequired,
	    loadObjectProperties: PropTypes.func.isRequired,
	    onLabelClick: PropTypes.func
	  },
	
	  displayName: "ObjectInspector",
	
	  getInitialState() {
	    // Cache of dynamically built nodes. We shouldn't need to clear
	    // this out ever, since we don't ever "switch out" the object
	    // being inspected.
	    this.actorCache = {};
	    return {};
	  },
	
	  getDefaultProps() {
	    return {
	      onLabelClick: () => {},
	      autoExpandDepth: 1
	    };
	  },
	
	  getChildren(item) {
	    var getObjectProperties = this.props.getObjectProperties;
	
	    var obj = item.contents;
	
	    // Nodes can either have children already, or be an object with
	    // properties that we need to go and fetch.
	    if (nodeHasChildren(item)) {
	      return item.contents;
	    }
	
	    if (nodeHasProperties(item)) {
	      var actor = obj.value.actor;
	
	      // Because we are dynamically creating the tree as the user
	      // expands it (not precalcuated tree structure), we cache child
	      // arrays. This not only helps performance, but is necessary
	      // because the expanded state depends on instances of nodes
	      // being the same across renders. If we didn't do this, each
	      // node would be a new instance every render.
	      var key = item.path;
	      if (this.actorCache[key]) {
	        return this.actorCache[key];
	      }
	
	      var loadedProps = getObjectProperties(actor);
	
	      var _ref = loadedProps || {},
	          ownProperties = _ref.ownProperties,
	          prototype = _ref.prototype;
	
	      if (!ownProperties && !prototype) {
	        return [];
	      }
	
	      var children = makeNodesForProperties(loadedProps, item.path);
	      this.actorCache[actor] = children;
	      return children;
	    }
	
	    return [];
	  },
	
	  renderItem(item, depth, focused, _, expanded, _ref2) {
	    var setExpanded = _ref2.setExpanded;
	
	    var objectValue = void 0;
	    if (nodeIsOptimizedOut(item)) {
	      objectValue = dom.span({ className: "unavailable" }, "(optimized away)");
	    } else if (nodeIsMissingArguments(item)) {
	      objectValue = dom.span({ className: "unavailable" }, "(unavailable)");
	    } else if (nodeHasProperties(item) || nodeIsPrimitive(item)) {
	      var object = item.contents.value;
	      objectValue = Rep({ object, mode: MODE.TINY });
	    }
	
	    return dom.div({
	      className: classnames("node object-node", {
	        focused,
	        "default-property": isDefault(item)
	      }),
	      style: { marginLeft: depth * 15 },
	      onClick: e => {
	        e.stopPropagation();
	        setExpanded(item, !expanded);
	      }
	    }, Svg("arrow", {
	      className: classnames({
	        expanded: expanded,
	        hidden: nodeIsPrimitive(item)
	      })
	    }), dom.span({
	      className: "object-label",
	      onClick: event => {
	        event.stopPropagation();
	        this.props.onLabelClick(item, { depth, focused, expanded });
	      }
	    }, item.name), dom.span({ className: "object-delimiter" }, objectValue ? ": " : ""), dom.span({ className: "object-value" }, objectValue || ""));
	  },
	
	  render() {
	    var _props = this.props,
	        name = _props.name,
	        desc = _props.desc,
	        loadObjectProperties = _props.loadObjectProperties,
	        autoExpandDepth = _props.autoExpandDepth;
	
	
	    var roots = this.props.roots;
	    if (!roots) {
	      roots = [createNode(name, name, desc)];
	    }
	
	    return ManagedTree({
	      itemHeight: 20,
	      getParent: item => null,
	      getChildren: this.getChildren,
	      getRoots: () => roots,
	      getKey: item => item.path,
	      autoExpand: 0,
	      autoExpandDepth,
	      autoExpandAll: false,
	      disabledFocus: true,
	      onExpand: item => {
	        if (nodeHasProperties(item)) {
	          loadObjectProperties(item.contents.value);
	        }
	      },
	
	      renderItem: this.renderItem
	    });
	  }
	});
	
	module.exports = ObjectInspector;

/***/ },
/* 556 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	
	var _require = __webpack_require__(557),
	    Rep = _require.Rep,
	    Grip = _require.Grip;
	
	Rep = React.createFactory(Rep);
	
	function renderRep(_ref) {
	  var object = _ref.object,
	      mode = _ref.mode;
	
	  return Rep({ object, defaultRep: Grip, mode });
	}
	
	module.exports = renderRep;

/***/ },
/* 557 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	
	const { MODE } = __webpack_require__(558);
	const Rep = React.createFactory(__webpack_require__(559));
	const Grip = __webpack_require__(570);
	
	module.exports = {
	  Rep,
	  Grip,
	  MODE
	};


/***/ },
/* 558 */
/***/ function(module, exports) {

	module.exports = {
	  MODE: {
	    TINY: Symbol("TINY"),
	    SHORT: Symbol("SHORT"),
	    LONG: Symbol("LONG"),
	  }
	};


/***/ },
/* 559 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	
	const { isGrip } = __webpack_require__(560);
	const { MODE } = __webpack_require__(558);
	
	// Load all existing rep templates
	const Undefined = __webpack_require__(561);
	const Null = __webpack_require__(562);
	const StringRep = __webpack_require__(563);
	const LongStringRep = __webpack_require__(564);
	const Number = __webpack_require__(565);
	const ArrayRep = __webpack_require__(566);
	const Obj = __webpack_require__(568);
	const SymbolRep = __webpack_require__(571);
	const InfinityRep = __webpack_require__(572);
	const NaNRep = __webpack_require__(573);
	
	// DOM types (grips)
	const Attribute = __webpack_require__(574);
	const DateTime = __webpack_require__(575);
	const Document = __webpack_require__(576);
	const Event = __webpack_require__(577);
	const Func = __webpack_require__(578);
	const PromiseRep = __webpack_require__(579);
	const RegExp = __webpack_require__(580);
	const StyleSheet = __webpack_require__(581);
	const CommentNode = __webpack_require__(582);
	const ElementNode = __webpack_require__(584);
	const TextNode = __webpack_require__(585);
	const ErrorRep = __webpack_require__(586);
	const Window = __webpack_require__(587);
	const ObjectWithText = __webpack_require__(588);
	const ObjectWithURL = __webpack_require__(589);
	const GripArray = __webpack_require__(590);
	const GripMap = __webpack_require__(591);
	const Grip = __webpack_require__(570);
	
	// List of all registered template.
	// XXX there should be a way for extensions to register a new
	// or modify an existing rep.
	let reps = [
	  RegExp,
	  StyleSheet,
	  Event,
	  DateTime,
	  CommentNode,
	  ElementNode,
	  TextNode,
	  Attribute,
	  LongStringRep,
	  Func,
	  PromiseRep,
	  ArrayRep,
	  Document,
	  Window,
	  ObjectWithText,
	  ObjectWithURL,
	  ErrorRep,
	  GripArray,
	  GripMap,
	  Grip,
	  Undefined,
	  Null,
	  StringRep,
	  Number,
	  SymbolRep,
	  InfinityRep,
	  NaNRep,
	];
	
	/**
	 * Generic rep that is using for rendering native JS types or an object.
	 * The right template used for rendering is picked automatically according
	 * to the current value type. The value must be passed is as 'object'
	 * property.
	 */
	const Rep = React.createClass({
	  displayName: "Rep",
	
	  propTypes: {
	    object: React.PropTypes.any,
	    defaultRep: React.PropTypes.object,
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	  },
	
	  render: function () {
	    let rep = getRep(this.props.object, this.props.defaultRep);
	    return rep(this.props);
	  },
	});
	
	// Helpers
	
	/**
	 * Return a rep object that is responsible for rendering given
	 * object.
	 *
	 * @param object {Object} Object to be rendered in the UI. This
	 * can be generic JS object as well as a grip (handle to a remote
	 * debuggee object).
	 *
	 * @param defaultObject {React.Component} The default template
	 * that should be used to render given object if none is found.
	 */
	function getRep(object, defaultRep = Obj) {
	  let type = typeof object;
	  if (type == "object" && object instanceof String) {
	    type = "string";
	  } else if (object && type == "object" && object.type) {
	    type = object.type;
	  }
	
	  if (isGrip(object)) {
	    type = object.class;
	  }
	
	  for (let i = 0; i < reps.length; i++) {
	    let rep = reps[i];
	    try {
	      // supportsObject could return weight (not only true/false
	      // but a number), which would allow to priorities templates and
	      // support better extensibility.
	      if (rep.supportsObject(object, type)) {
	        return React.createFactory(rep.rep);
	      }
	    } catch (err) {
	      console.error(err);
	    }
	  }
	
	  return React.createFactory(defaultRep.rep);
	}
	
	module.exports = Rep;


/***/ },
/* 560 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	
	/**
	 * Create React factories for given arguments.
	 * Example:
	 *   const { Rep } = createFactories(require("./rep"));
	 */
	function createFactories(args) {
	  let result = {};
	  for (let p in args) {
	    result[p] = React.createFactory(args[p]);
	  }
	  return result;
	}
	
	/**
	 * Returns true if the given object is a grip (see RDP protocol)
	 */
	function isGrip(object) {
	  return object && object.actor;
	}
	
	function escapeNewLines(value) {
	  return value.replace(/\r/gm, "\\r").replace(/\n/gm, "\\n");
	}
	
	function cropMultipleLines(text, limit) {
	  return escapeNewLines(cropString(text, limit));
	}
	
	function cropString(text, limit, alternativeText) {
	  if (!alternativeText) {
	    alternativeText = "\u2026";
	  }
	
	  // Make sure it's a string and sanitize it.
	  text = sanitizeString(text + "");
	
	  // Crop the string only if a limit is actually specified.
	  if (!limit || limit <= 0) {
	    return text;
	  }
	
	  // Set the limit at least to the length of the alternative text
	  // plus one character of the original text.
	  if (limit <= alternativeText.length) {
	    limit = alternativeText.length + 1;
	  }
	
	  let halfLimit = (limit - alternativeText.length) / 2;
	
	  if (text.length > limit) {
	    return text.substr(0, Math.ceil(halfLimit)) + alternativeText +
	      text.substr(text.length - Math.floor(halfLimit));
	  }
	
	  return text;
	}
	
	function sanitizeString(text) {
	  // Replace all non-printable characters, except of
	  // (horizontal) tab (HT: \x09) and newline (LF: \x0A, CR: \x0D),
	  // with unicode replacement character (u+fffd).
	  // eslint-disable-next-line no-control-regex
	  let re = new RegExp("[\x00-\x08\x0B\x0C\x0E-\x1F\x80-\x9F]", "g");
	  return text.replace(re, "\ufffd");
	}
	
	function parseURLParams(url) {
	  url = new URL(url);
	  return parseURLEncodedText(url.searchParams);
	}
	
	function parseURLEncodedText(text) {
	  let params = [];
	
	  // In case the text is empty just return the empty parameters
	  if (text == "") {
	    return params;
	  }
	
	  let searchParams = new URLSearchParams(text);
	  let entries = [...searchParams.entries()];
	  return entries.map(entry => {
	    return {
	      name: entry[0],
	      value: entry[1]
	    };
	  });
	}
	
	function getFileName(url) {
	  let split = splitURLBase(url);
	  return split.name;
	}
	
	function splitURLBase(url) {
	  if (!isDataURL(url)) {
	    return splitURLTrue(url);
	  }
	  return {};
	}
	
	function getURLDisplayString(url) {
	  return cropString(url);
	}
	
	function isDataURL(url) {
	  return (url && url.substr(0, 5) == "data:");
	}
	
	function splitURLTrue(url) {
	  const reSplitFile = /(.*?):\/{2,3}([^\/]*)(.*?)([^\/]*?)($|\?.*)/;
	  let m = reSplitFile.exec(url);
	
	  if (!m) {
	    return {
	      name: url,
	      path: url
	    };
	  } else if (m[4] == "" && m[5] == "") {
	    return {
	      protocol: m[1],
	      domain: m[2],
	      path: m[3],
	      name: m[3] != "/" ? m[3] : m[2]
	    };
	  }
	
	  return {
	    protocol: m[1],
	    domain: m[2],
	    path: m[2] + m[3],
	    name: m[4] + m[5]
	  };
	}
	
	module.exports = {
	  createFactories,
	  isGrip,
	  cropString,
	  sanitizeString,
	  cropMultipleLines,
	  parseURLParams,
	  parseURLEncodedText,
	  getFileName,
	  getURLDisplayString
	};


/***/ },
/* 561 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	
	// Shortcuts
	const { span } = React.DOM;
	
	/**
	 * Renders undefined value
	 */
	const Undefined = React.createClass({
	  displayName: "UndefinedRep",
	
	  render: function () {
	    return (
	      span({className: "objectBox objectBox-undefined"},
	        "undefined"
	      )
	    );
	  },
	});
	
	function supportsObject(object, type) {
	  if (object && object.type && object.type == "undefined") {
	    return true;
	  }
	
	  return (type == "undefined");
	}
	
	module.exports = {
	  rep: Undefined,
	  supportsObject: supportsObject
	};


/***/ },
/* 562 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	
	// Shortcuts
	const { span } = React.DOM;
	
	/**
	 * Renders null value
	 */
	const Null = React.createClass({
	  displayName: "NullRep",
	
	  render: function () {
	    return (
	      span({className: "objectBox objectBox-null"},
	        "null"
	      )
	    );
	  },
	});
	
	function supportsObject(object, type) {
	  if (object && object.type && object.type == "null") {
	    return true;
	  }
	
	  return (object == null);
	}
	
	module.exports = {
	  rep: Null,
	  supportsObject: supportsObject
	};


/***/ },
/* 563 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	const { cropString } = __webpack_require__(560);
	
	// Shortcuts
	const { span } = React.DOM;
	
	/**
	 * Renders a string. String value is enclosed within quotes.
	 */
	const StringRep = React.createClass({
	  displayName: "StringRep",
	
	  propTypes: {
	    useQuotes: React.PropTypes.bool,
	    style: React.PropTypes.object,
	  },
	
	  getDefaultProps: function () {
	    return {
	      useQuotes: true,
	    };
	  },
	
	  render: function () {
	    let text = this.props.object;
	    let member = this.props.member;
	    let style = this.props.style;
	
	    let config = {className: "objectBox objectBox-string"};
	    if (style) {
	      config.style = style;
	    }
	
	    if (member && member.open) {
	      return span(config, "\"" + text + "\"");
	    }
	
	    let croppedString = this.props.cropLimit ?
	      cropString(text, this.props.cropLimit) : cropString(text);
	
	    let formattedString = this.props.useQuotes ?
	      "\"" + croppedString + "\"" : croppedString;
	
	    return span(config, formattedString);
	  },
	});
	
	function supportsObject(object, type) {
	  return (type == "string");
	}
	
	module.exports = {
	  rep: StringRep,
	  supportsObject: supportsObject,
	};


/***/ },
/* 564 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	const { sanitizeString, isGrip } = __webpack_require__(560);
	// Shortcuts
	const { span } = React.DOM;
	
	/**
	 * Renders a long string grip.
	 */
	const LongStringRep = React.createClass({
	  displayName: "LongStringRep",
	
	  propTypes: {
	    useQuotes: React.PropTypes.bool,
	    style: React.PropTypes.object,
	  },
	
	  getDefaultProps: function () {
	    return {
	      useQuotes: true,
	    };
	  },
	
	  render: function () {
	    let {
	      cropLimit,
	      member,
	      object,
	      style,
	      useQuotes
	    } = this.props;
	    let {fullText, initial, length} = object;
	
	    let config = {className: "objectBox objectBox-string"};
	    if (style) {
	      config.style = style;
	    }
	
	    let string = member && member.open
	      ? fullText || initial
	      : initial.substring(0, cropLimit);
	
	    if (string.length < length) {
	      string += "\u2026";
	    }
	    let formattedString = useQuotes ? `"${string}"` : string;
	    return span(config, sanitizeString(formattedString));
	  },
	});
	
	function supportsObject(object, type) {
	  if (!isGrip(object)) {
	    return false;
	  }
	  return object.type === "longString";
	}
	
	module.exports = {
	  rep: LongStringRep,
	  supportsObject: supportsObject,
	};


/***/ },
/* 565 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	
	// Shortcuts
	const { span } = React.DOM;
	
	/**
	 * Renders a number
	 */
	const Number = React.createClass({
	  displayName: "Number",
	
	  stringify: function (object) {
	    let isNegativeZero = Object.is(object, -0) ||
	      (object.type && object.type == "-0");
	
	    return (isNegativeZero ? "-0" : String(object));
	  },
	
	  render: function () {
	    let value = this.props.object;
	
	    return (
	      span({className: "objectBox objectBox-number"},
	        this.stringify(value)
	      )
	    );
	  }
	});
	
	function supportsObject(object, type) {
	  return ["boolean", "number", "-0"].includes(type);
	}
	
	module.exports = {
	  rep: Number,
	  supportsObject: supportsObject
	};


/***/ },
/* 566 */
/***/ function(module, exports, __webpack_require__) {

	
	const React = __webpack_require__(2);
	const Caption = React.createFactory(__webpack_require__(567));
	const { MODE } = __webpack_require__(558);
	
	// Shortcuts
	const DOM = React.DOM;
	
	/**
	 * Renders an array. The array is enclosed by left and right bracket
	 * and the max number of rendered items depends on the current mode.
	 */
	let ArrayRep = React.createClass({
	  displayName: "ArrayRep",
	
	  propTypes: {
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	  },
	
	  getTitle: function (object, context) {
	    return "[" + object.length + "]";
	  },
	
	  arrayIterator: function (array, max) {
	    let items = [];
	    let delim;
	
	    for (let i = 0; i < array.length && i < max; i++) {
	      try {
	        let value = array[i];
	
	        delim = (i == array.length - 1 ? "" : ", ");
	
	        items.push(ItemRep({
	          object: value,
	          // Hardcode tiny mode to avoid recursive handling.
	          mode: MODE.TINY,
	          delim: delim
	        }));
	      } catch (exc) {
	        items.push(ItemRep({
	          object: exc,
	          mode: MODE.TINY,
	          delim: delim
	        }));
	      }
	    }
	
	    if (array.length > max) {
	      let objectLink = this.props.objectLink || DOM.span;
	      items.push(Caption({
	        object: objectLink({
	          object: this.props.object
	        }, (array.length - max) + " more…")
	      }));
	    }
	
	    return items;
	  },
	
	  /**
	   * Returns true if the passed object is an array with additional (custom)
	   * properties, otherwise returns false. Custom properties should be
	   * displayed in extra expandable section.
	   *
	   * Example array with a custom property.
	   * let arr = [0, 1];
	   * arr.myProp = "Hello";
	   *
	   * @param {Array} array The array object.
	   */
	  hasSpecialProperties: function (array) {
	    function isInteger(x) {
	      let y = parseInt(x, 10);
	      if (isNaN(y)) {
	        return false;
	      }
	      return x === y.toString();
	    }
	
	    let props = Object.getOwnPropertyNames(array);
	    for (let i = 0; i < props.length; i++) {
	      let p = props[i];
	
	      // Valid indexes are skipped
	      if (isInteger(p)) {
	        continue;
	      }
	
	      // Ignore standard 'length' property, anything else is custom.
	      if (p != "length") {
	        return true;
	      }
	    }
	
	    return false;
	  },
	
	  // Event Handlers
	
	  onToggleProperties: function (event) {
	  },
	
	  onClickBracket: function (event) {
	  },
	
	  render: function () {
	    let {
	      object,
	      mode = MODE.SHORT,
	    } = this.props;
	
	    let items;
	    let brackets;
	    let needSpace = function (space) {
	      return space ? { left: "[ ", right: " ]"} : { left: "[", right: "]"};
	    };
	
	    if (mode === MODE.TINY) {
	      let isEmpty = object.length === 0;
	      items = [DOM.span({className: "length"}, isEmpty ? "" : object.length)];
	      brackets = needSpace(false);
	    } else {
	      let max = (mode === MODE.SHORT) ? 3 : 10;
	      items = this.arrayIterator(object, max);
	      brackets = needSpace(items.length > 0);
	    }
	
	    let objectLink = this.props.objectLink || DOM.span;
	
	    return (
	      DOM.span({
	        className: "objectBox objectBox-array"},
	        objectLink({
	          className: "arrayLeftBracket",
	          object: object
	        }, brackets.left),
	        ...items,
	        objectLink({
	          className: "arrayRightBracket",
	          object: object
	        }, brackets.right),
	        DOM.span({
	          className: "arrayProperties",
	          role: "group"}
	        )
	      )
	    );
	  },
	});
	
	/**
	 * Renders array item. Individual values are separated by a comma.
	 */
	let ItemRep = React.createFactory(React.createClass({
	  displayName: "ItemRep",
	
	  render: function () {
	    const Rep = React.createFactory(__webpack_require__(559));
	
	    let object = this.props.object;
	    let delim = this.props.delim;
	    let mode = this.props.mode;
	    return (
	      DOM.span({},
	        Rep({object: object, mode: mode}),
	        delim
	      )
	    );
	  }
	}));
	
	function supportsObject(object, type) {
	  return Array.isArray(object) ||
	    Object.prototype.toString.call(object) === "[object Arguments]";
	}
	
	module.exports = {
	  rep: ArrayRep,
	  supportsObject: supportsObject
	};


/***/ },
/* 567 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	const DOM = React.DOM;
	
	/**
	 * Renders a caption. This template is used by other components
	 * that needs to distinguish between a simple text/value and a label.
	 */
	const Caption = React.createClass({
	  displayName: "Caption",
	
	  render: function () {
	    return (
	      DOM.span({"className": "caption"}, this.props.object)
	    );
	  },
	});
	
	module.exports = Caption;


/***/ },
/* 568 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	const Caption = React.createFactory(__webpack_require__(567));
	const PropRep = React.createFactory(__webpack_require__(569));
	const { MODE } = __webpack_require__(558);
	// Shortcuts
	const { span } = React.DOM;
	/**
	 * Renders an object. An object is represented by a list of its
	 * properties enclosed in curly brackets.
	 */
	const Obj = React.createClass({
	  displayName: "Obj",
	
	  propTypes: {
	    object: React.PropTypes.object,
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	  },
	
	  getTitle: function (object) {
	    let className = object && object.class ? object.class : "Object";
	    if (this.props.objectLink) {
	      return this.props.objectLink({
	        object: object
	      }, className);
	    }
	    return className;
	  },
	
	  safePropIterator: function (object, max) {
	    max = (typeof max === "undefined") ? 3 : max;
	    try {
	      return this.propIterator(object, max);
	    } catch (err) {
	      console.error(err);
	    }
	    return [];
	  },
	
	  propIterator: function (object, max) {
	    let isInterestingProp = (t, value) => {
	      // Do not pick objects, it could cause recursion.
	      return (t == "boolean" || t == "number" || (t == "string" && value));
	    };
	
	    // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=945377
	    if (Object.prototype.toString.call(object) === "[object Generator]") {
	      object = Object.getPrototypeOf(object);
	    }
	
	    // Object members with non-empty values are preferred since it gives the
	    // user a better overview of the object.
	    let props = this.getProps(object, max, isInterestingProp);
	
	    if (props.length <= max) {
	      // There are not enough props yet (or at least, not enough props to
	      // be able to know whether we should print "more…" or not).
	      // Let's display also empty members and functions.
	      props = props.concat(this.getProps(object, max, (t, value) => {
	        return !isInterestingProp(t, value);
	      }));
	    }
	
	    if (props.length > max) {
	      props.pop();
	      let objectLink = this.props.objectLink || span;
	
	      props.push(Caption({
	        object: objectLink({
	          object: object
	        }, (Object.keys(object).length - max) + " more…")
	      }));
	    } else if (props.length > 0) {
	      // Remove the last comma.
	      props[props.length - 1] = React.cloneElement(
	        props[props.length - 1], { delim: "" });
	    }
	
	    return props;
	  },
	
	  getProps: function (object, max, filter) {
	    let props = [];
	
	    max = max || 3;
	    if (!object) {
	      return props;
	    }
	
	    // Hardcode tiny mode to avoid recursive handling.
	    let mode = MODE.TINY;
	
	    try {
	      for (let name in object) {
	        if (props.length > max) {
	          return props;
	        }
	
	        let value;
	        try {
	          value = object[name];
	        } catch (exc) {
	          continue;
	        }
	
	        let t = typeof value;
	        if (filter(t, value)) {
	          props.push(PropRep({
	            mode: mode,
	            name: name,
	            object: value,
	            equal: ": ",
	            delim: ", ",
	          }));
	        }
	      }
	    } catch (err) {
	      console.error(err);
	    }
	
	    return props;
	  },
	
	  render: function () {
	    let object = this.props.object;
	    let props = this.safePropIterator(object);
	    let objectLink = this.props.objectLink || span;
	
	    if (this.props.mode === MODE.TINY || !props.length) {
	      return (
	        span({className: "objectBox objectBox-object"},
	          objectLink({className: "objectTitle"}, this.getTitle(object))
	        )
	      );
	    }
	
	    return (
	      span({className: "objectBox objectBox-object"},
	        this.getTitle(object),
	        objectLink({
	          className: "objectLeftBrace",
	          object: object
	        }, " { "),
	        ...props,
	        objectLink({
	          className: "objectRightBrace",
	          object: object
	        }, " }")
	      )
	    );
	  },
	});
	function supportsObject(object, type) {
	  return true;
	}
	
	module.exports = {
	  rep: Obj,
	  supportsObject: supportsObject
	};


/***/ },
/* 569 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	const { MODE } = __webpack_require__(558);
	// Shortcuts
	const { span } = React.DOM;
	
	/**
	 * Property for Obj (local JS objects), Grip (remote JS objects)
	 * and GripMap (remote JS maps and weakmaps) reps.
	 * It's used to render object properties.
	 */
	let PropRep = React.createFactory(React.createClass({
	  displayName: "PropRep",
	
	  propTypes: {
	    // Property name.
	    name: React.PropTypes.oneOfType([
	      React.PropTypes.string,
	      React.PropTypes.object,
	    ]).isRequired,
	    // Equal character rendered between property name and value.
	    equal: React.PropTypes.string,
	    // Delimiter character used to separate individual properties.
	    delim: React.PropTypes.string,
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	  },
	
	  render: function () {
	    const Grip = __webpack_require__(570);
	    let Rep = React.createFactory(__webpack_require__(559));
	
	    let key;
	    // The key can be a simple string, for plain objects,
	    // or another object for maps and weakmaps.
	    if (typeof this.props.name === "string") {
	      key = span({"className": "nodeName"}, this.props.name);
	    } else {
	      key = Rep({
	        object: this.props.name,
	        mode: this.props.mode || MODE.TINY,
	        defaultRep: Grip,
	        objectLink: this.props.objectLink,
	      });
	    }
	
	    return (
	      span({},
	        key,
	        span({
	          "className": "objectEqual"
	        }, this.props.equal),
	        Rep(this.props),
	        span({
	          "className": "objectComma"
	        }, this.props.delim)
	      )
	    );
	  }
	}));
	
	module.exports = PropRep;


/***/ },
/* 570 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	// Dependencies
	const { isGrip } = __webpack_require__(560);
	const Caption = React.createFactory(__webpack_require__(567));
	const PropRep = React.createFactory(__webpack_require__(569));
	const { MODE } = __webpack_require__(558);
	// Shortcuts
	const { span } = React.DOM;
	
	/**
	 * Renders generic grip. Grip is client representation
	 * of remote JS object and is used as an input object
	 * for this rep component.
	 */
	const GripRep = React.createClass({
	  displayName: "Grip",
	
	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	    isInterestingProp: React.PropTypes.func,
	    title: React.PropTypes.string,
	  },
	
	  getTitle: function (object) {
	    let title = this.props.title || object.class || "Object";
	    if (this.props.objectLink) {
	      return this.props.objectLink({
	        object: object
	      }, title);
	    }
	    return title;
	  },
	
	  safePropIterator: function (object, max) {
	    max = (typeof max === "undefined") ? 3 : max;
	    try {
	      return this.propIterator(object, max);
	    } catch (err) {
	      console.error(err);
	    }
	    return [];
	  },
	
	  propIterator: function (object, max) {
	    if (object.preview && Object.keys(object.preview).includes("wrappedValue")) {
	      const Rep = React.createFactory(__webpack_require__(559));
	
	      return [Rep({
	        object: object.preview.wrappedValue,
	        mode: this.props.mode || MODE.TINY,
	        defaultRep: Grip,
	      })];
	    }
	
	    // Property filter. Show only interesting properties to the user.
	    let isInterestingProp = this.props.isInterestingProp || ((type, value) => {
	      return (
	        type == "boolean" ||
	        type == "number" ||
	        (type == "string" && value.length != 0)
	      );
	    });
	
	    let properties = object.preview
	      ? object.preview.ownProperties
	      : {};
	    let propertiesLength = object.preview && object.preview.ownPropertiesLength
	      ? object.preview.ownPropertiesLength
	      : object.ownPropertyLength;
	
	    if (object.preview && object.preview.safeGetterValues) {
	      properties = Object.assign({}, properties, object.preview.safeGetterValues);
	      propertiesLength += Object.keys(object.preview.safeGetterValues).length;
	    }
	
	    let indexes = this.getPropIndexes(properties, max, isInterestingProp);
	    if (indexes.length < max && indexes.length < propertiesLength) {
	      // There are not enough props yet. Then add uninteresting props to display them.
	      indexes = indexes.concat(
	        this.getPropIndexes(properties, max - indexes.length, (t, value, name) => {
	          return !isInterestingProp(t, value, name);
	        })
	      );
	    }
	
	    const truncate = Object.keys(properties).length > max;
	    let props = this.getProps(properties, indexes, truncate);
	    if (truncate) {
	      // There are some undisplayed props. Then display "more...".
	      let objectLink = this.props.objectLink || span;
	
	      props.push(Caption({
	        object: objectLink({
	          object: object
	        }, `${object.ownPropertyLength - max} more…`)
	      }));
	    }
	
	    return props;
	  },
	
	  /**
	   * Get props ordered by index.
	   *
	   * @param {Object} properties Props object.
	   * @param {Array} indexes Indexes of props.
	   * @param {Boolean} truncate true if the grip will be truncated.
	   * @return {Array} Props.
	   */
	  getProps: function (properties, indexes, truncate) {
	    let props = [];
	
	    // Make indexes ordered by ascending.
	    indexes.sort(function (a, b) {
	      return a - b;
	    });
	
	    indexes.forEach((i) => {
	      let name = Object.keys(properties)[i];
	      let value = this.getPropValue(properties[name]);
	
	      props.push(PropRep(Object.assign({}, this.props, {
	        mode: MODE.TINY,
	        name: name,
	        object: value,
	        equal: ": ",
	        delim: i !== indexes.length - 1 || truncate ? ", " : "",
	        defaultRep: Grip
	      })));
	    });
	
	    return props;
	  },
	
	  /**
	   * Get the indexes of props in the object.
	   *
	   * @param {Object} properties Props object.
	   * @param {Number} max The maximum length of indexes array.
	   * @param {Function} filter Filter the props you want.
	   * @return {Array} Indexes of interesting props in the object.
	   */
	  getPropIndexes: function (properties, max, filter) {
	    let indexes = [];
	
	    try {
	      let i = 0;
	      for (let name in properties) {
	        if (indexes.length >= max) {
	          return indexes;
	        }
	
	        // Type is specified in grip's "class" field and for primitive
	        // values use typeof.
	        let value = this.getPropValue(properties[name]);
	        let type = (value.class || typeof value);
	        type = type.toLowerCase();
	
	        if (filter(type, value, name)) {
	          indexes.push(i);
	        }
	        i++;
	      }
	    } catch (err) {
	      console.error(err);
	    }
	    return indexes;
	  },
	
	  /**
	   * Get the actual value of a property.
	   *
	   * @param {Object} property
	   * @return {Object} Value of the property.
	   */
	  getPropValue: function (property) {
	    let value = property;
	    if (typeof property === "object") {
	      let keys = Object.keys(property);
	      if (keys.includes("value")) {
	        value = property.value;
	      } else if (keys.includes("getterValue")) {
	        value = property.getterValue;
	      }
	    }
	    return value;
	  },
	
	  render: function () {
	    let object = this.props.object;
	    let props = this.safePropIterator(object,
	      (this.props.mode === MODE.LONG) ? 10 : 3);
	
	    let objectLink = this.props.objectLink || span;
	    if (this.props.mode === MODE.TINY) {
	      return (
	        span({className: "objectBox objectBox-object"},
	          this.getTitle(object),
	          objectLink({
	            className: "objectLeftBrace",
	            object: object
	          }, "")
	        )
	      );
	    }
	
	    return (
	      span({className: "objectBox objectBox-object"},
	        this.getTitle(object),
	        objectLink({
	          className: "objectLeftBrace",
	          object: object
	        }, " { "),
	        ...props,
	        objectLink({
	          className: "objectRightBrace",
	          object: object
	        }, " }")
	      )
	    );
	  },
	});
	
	// Registration
	function supportsObject(object, type) {
	  if (!isGrip(object)) {
	    return false;
	  }
	  return (object.preview && object.preview.ownProperties);
	}
	
	let Grip = {
	  rep: GripRep,
	  supportsObject: supportsObject
	};
	
	module.exports = Grip;


/***/ },
/* 571 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	
	// Shortcuts
	const { span } = React.DOM;
	
	/**
	 * Renders a symbol.
	 */
	const SymbolRep = React.createClass({
	  displayName: "SymbolRep",
	
	  propTypes: {
	    object: React.PropTypes.object.isRequired
	  },
	
	  render: function () {
	    let {object} = this.props;
	    let {name} = object;
	
	    return (
	      span({className: "objectBox objectBox-symbol"},
	        `Symbol(${name || ""})`
	      )
	    );
	  },
	});
	
	function supportsObject(object, type) {
	  return (type == "symbol");
	}
	
	module.exports = {
	  rep: SymbolRep,
	  supportsObject: supportsObject,
	};


/***/ },
/* 572 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	
	// Shortcuts
	const { span } = React.DOM;
	
	/**
	 * Renders a Infinity object
	 */
	const InfinityRep = React.createClass({
	  displayName: "Infinity",
	
	  render: function () {
	    return (
	      span({className: "objectBox objectBox-number"},
	        this.props.object.type
	      )
	    );
	  }
	});
	
	function supportsObject(object, type) {
	  return type == "Infinity" || type == "-Infinity";
	}
	
	module.exports = {
	  rep: InfinityRep,
	  supportsObject: supportsObject
	};


/***/ },
/* 573 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	
	// Shortcuts
	const { span } = React.DOM;
	
	/**
	 * Renders a NaN object
	 */
	const NaNRep = React.createClass({
	  displayName: "NaN",
	
	  render: function () {
	    return (
	      span({className: "objectBox objectBox-nan"},
	        "NaN"
	      )
	    );
	  }
	});
	
	function supportsObject(object, type) {
	  return type == "NaN";
	}
	
	module.exports = {
	  rep: NaNRep,
	  supportsObject: supportsObject
	};


/***/ },
/* 574 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	
	// Reps
	const { isGrip } = __webpack_require__(560);
	const StringRep = React.createFactory(__webpack_require__(563).rep);
	
	// Shortcuts
	const { span } = React.DOM;
	
	/**
	 * Renders DOM attribute
	 */
	let Attribute = React.createClass({
	  displayName: "Attr",
	
	  propTypes: {
	    object: React.PropTypes.object.isRequired
	  },
	
	  getTitle: function (grip) {
	    return grip.preview.nodeName;
	  },
	
	  render: function () {
	    let object = this.props.object;
	    let value = object.preview.value;
	    let objectLink = this.props.objectLink || span;
	
	    return (
	      objectLink({className: "objectLink-Attr", object},
	        span({},
	          span({className: "attrTitle"},
	            this.getTitle(object)
	          ),
	          span({className: "attrEqual"},
	            "="
	          ),
	          StringRep({object: value})
	        )
	      )
	    );
	  },
	});
	
	// Registration
	
	function supportsObject(grip, type) {
	  if (!isGrip(grip)) {
	    return false;
	  }
	
	  return (type == "Attr" && grip.preview);
	}
	
	module.exports = {
	  rep: Attribute,
	  supportsObject: supportsObject
	};


/***/ },
/* 575 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	
	// Reps
	const { isGrip } = __webpack_require__(560);
	
	// Shortcuts
	const { span } = React.DOM;
	
	/**
	 * Used to render JS built-in Date() object.
	 */
	let DateTime = React.createClass({
	  displayName: "Date",
	
	  propTypes: {
	    object: React.PropTypes.object.isRequired
	  },
	
	  getTitle: function (grip) {
	    if (this.props.objectLink) {
	      return this.props.objectLink({
	        object: grip
	      }, grip.class + " ");
	    }
	    return "";
	  },
	
	  render: function () {
	    let grip = this.props.object;
	    let date;
	    try {
	      date = span({className: "objectBox"},
	        this.getTitle(grip),
	        span({className: "Date"},
	          new Date(grip.preview.timestamp).toISOString()
	        )
	      );
	    } catch (e) {
	      date = span({className: "objectBox"}, "Invalid Date");
	    }
	    return date;
	  },
	});
	
	// Registration
	
	function supportsObject(grip, type) {
	  if (!isGrip(grip)) {
	    return false;
	  }
	
	  return (type == "Date" && grip.preview);
	}
	
	module.exports = {
	  rep: DateTime,
	  supportsObject: supportsObject
	};


/***/ },
/* 576 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	
	// Reps
	const { isGrip, getURLDisplayString } = __webpack_require__(560);
	
	// Shortcuts
	const { span } = React.DOM;
	
	/**
	 * Renders DOM document object.
	 */
	let Document = React.createClass({
	  displayName: "Document",
	
	  propTypes: {
	    object: React.PropTypes.object.isRequired
	  },
	
	  getLocation: function (grip) {
	    let location = grip.preview.location;
	    return location ? getURLDisplayString(location) : "";
	  },
	
	  getTitle: function (grip) {
	    if (this.props.objectLink) {
	      return span({className: "objectBox"},
	        this.props.objectLink({
	          object: grip
	        }, grip.class + " ")
	      );
	    }
	    return "";
	  },
	
	  getTooltip: function (doc) {
	    return doc.location.href;
	  },
	
	  render: function () {
	    let grip = this.props.object;
	
	    return (
	      span({className: "objectBox objectBox-object"},
	        this.getTitle(grip),
	        span({className: "objectPropValue"},
	          this.getLocation(grip)
	        )
	      )
	    );
	  },
	});
	
	// Registration
	
	function supportsObject(object, type) {
	  if (!isGrip(object)) {
	    return false;
	  }
	
	  return (object.preview && type == "HTMLDocument");
	}
	
	module.exports = {
	  rep: Document,
	  supportsObject: supportsObject
	};


/***/ },
/* 577 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	
	// Reps
	const { isGrip } = __webpack_require__(560);
	const rep = React.createFactory(__webpack_require__(570).rep);
	
	/**
	 * Renders DOM event objects.
	 */
	let Event = React.createClass({
	  displayName: "event",
	
	  propTypes: {
	    object: React.PropTypes.object.isRequired
	  },
	
	  getTitle: function (props) {
	    let preview = props.object.preview;
	    let title = preview.type;
	
	    if (preview.eventKind == "key" && preview.modifiers && preview.modifiers.length) {
	      title = `${title} ${preview.modifiers.join("-")}`;
	    }
	    return title;
	  },
	
	  render: function () {
	    // Use `Object.assign` to keep `this.props` without changes because:
	    // 1. JSON.stringify/JSON.parse is slow.
	    // 2. Immutable.js is planned for the future.
	    let props = Object.assign({
	      title: this.getTitle(this.props)
	    }, this.props);
	    props.object = Object.assign({}, this.props.object);
	    props.object.preview = Object.assign({}, this.props.object.preview);
	
	    props.object.preview.ownProperties = {};
	    if (props.object.preview.target) {
	      Object.assign(props.object.preview.ownProperties, {
	        target: props.object.preview.target
	      });
	    }
	    Object.assign(props.object.preview.ownProperties, props.object.preview.properties);
	
	    delete props.object.preview.properties;
	    props.object.ownPropertyLength =
	      Object.keys(props.object.preview.ownProperties).length;
	
	    switch (props.object.class) {
	      case "MouseEvent":
	        props.isInterestingProp = (type, value, name) => {
	          return ["target", "clientX", "clientY", "layerX", "layerY"].includes(name);
	        };
	        break;
	      case "KeyboardEvent":
	        props.isInterestingProp = (type, value, name) => {
	          return ["target", "key", "charCode", "keyCode"].includes(name);
	        };
	        break;
	      case "MessageEvent":
	        props.isInterestingProp = (type, value, name) => {
	          return ["target", "isTrusted", "data"].includes(name);
	        };
	        break;
	      default:
	        props.isInterestingProp = (type, value, name) => {
	          // We want to show the properties in the order they are declared.
	          return Object.keys(props.object.preview.ownProperties).includes(name);
	        };
	    }
	
	    return rep(props);
	  }
	});
	
	// Registration
	function supportsObject(grip, type) {
	  if (!isGrip(grip)) {
	    return false;
	  }
	
	  return (grip.preview && grip.preview.kind == "DOMEvent");
	}
	
	module.exports = {
	  rep: Event,
	  supportsObject: supportsObject
	};


/***/ },
/* 578 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	
	// Reps
	const { isGrip, cropString } = __webpack_require__(560);
	
	// Shortcuts
	const { span } = React.DOM;
	
	/**
	 * This component represents a template for Function objects.
	 */
	let Func = React.createClass({
	  displayName: "Func",
	
	  propTypes: {
	    object: React.PropTypes.object.isRequired
	  },
	
	  getTitle: function (grip) {
	    if (this.props.objectLink) {
	      return this.props.objectLink({
	        object: grip
	      }, "function ");
	    }
	    return "";
	  },
	
	  summarizeFunction: function (grip) {
	    let name = grip.userDisplayName || grip.displayName || grip.name || "function";
	    return cropString(name + "()", 100);
	  },
	
	  render: function () {
	    let grip = this.props.object;
	
	    return (
	      // Set dir="ltr" to prevent function parentheses from
	      // appearing in the wrong direction
	      span({dir: "ltr", className: "objectBox objectBox-function"},
	        this.getTitle(grip),
	        this.summarizeFunction(grip)
	      )
	    );
	  },
	});
	
	// Registration
	
	function supportsObject(grip, type) {
	  if (!isGrip(grip)) {
	    return (type == "function");
	  }
	
	  return (type == "Function");
	}
	
	module.exports = {
	  rep: Func,
	  supportsObject: supportsObject
	};


/***/ },
/* 579 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	// Dependencies
	const { isGrip } = __webpack_require__(560);
	const PropRep = React.createFactory(__webpack_require__(569));
	const { MODE } = __webpack_require__(558);
	// Shortcuts
	const { span } = React.DOM;
	
	/**
	 * Renders a DOM Promise object.
	 */
	const PromiseRep = React.createClass({
	  displayName: "Promise",
	
	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	  },
	
	  getTitle: function (object) {
	    const title = object.class;
	    if (this.props.objectLink) {
	      return this.props.objectLink({
	        object: object
	      }, title);
	    }
	    return title;
	  },
	
	  getProps: function (promiseState) {
	    const keys = ["state"];
	    if (Object.keys(promiseState).includes("value")) {
	      keys.push("value");
	    }
	
	    return keys.map((key, i) => {
	      return PropRep(Object.assign({}, this.props, {
	        mode: MODE.TINY,
	        name: `<${key}>`,
	        object: promiseState[key],
	        equal: ": ",
	        delim: i < keys.length - 1 ? ", " : ""
	      }));
	    });
	  },
	
	  render: function () {
	    const object = this.props.object;
	    const {promiseState} = object;
	    let objectLink = this.props.objectLink || span;
	
	    if (this.props.mode === MODE.TINY) {
	      let Rep = React.createFactory(__webpack_require__(559));
	
	      return (
	        span({className: "objectBox objectBox-object"},
	          this.getTitle(object),
	          objectLink({
	            className: "objectLeftBrace",
	            object: object
	          }, " { "),
	          Rep({object: promiseState.state}),
	          objectLink({
	            className: "objectRightBrace",
	            object: object
	          }, " }")
	        )
	      );
	    }
	
	    const props = this.getProps(promiseState);
	    return (
	      span({className: "objectBox objectBox-object"},
	        this.getTitle(object),
	        objectLink({
	          className: "objectLeftBrace",
	          object: object
	        }, " { "),
	        ...props,
	        objectLink({
	          className: "objectRightBrace",
	          object: object
	        }, " }")
	      )
	    );
	  },
	});
	
	// Registration
	function supportsObject(object, type) {
	  if (!isGrip(object)) {
	    return false;
	  }
	  return type === "Promise";
	}
	
	module.exports = {
	  rep: PromiseRep,
	  supportsObject: supportsObject
	};


/***/ },
/* 580 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	
	// Reps
	const { isGrip } = __webpack_require__(560);
	
	// Shortcuts
	const { span } = React.DOM;
	
	/**
	 * Renders a grip object with regular expression.
	 */
	let RegExp = React.createClass({
	  displayName: "regexp",
	
	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	  },
	
	  getSource: function (grip) {
	    return grip.displayString;
	  },
	
	  render: function () {
	    let grip = this.props.object;
	    let objectLink = this.props.objectLink || span;
	
	    return (
	      span({className: "objectBox objectBox-regexp"},
	        objectLink({
	          object: grip,
	          className: "regexpSource"
	        }, this.getSource(grip))
	      )
	    );
	  },
	});
	
	// Registration
	
	function supportsObject(object, type) {
	  if (!isGrip(object)) {
	    return false;
	  }
	
	  return (type == "RegExp");
	}
	
	module.exports = {
	  rep: RegExp,
	  supportsObject: supportsObject
	};


/***/ },
/* 581 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	
	// Reps
	const { isGrip, getURLDisplayString } = __webpack_require__(560);
	
	// Shortcuts
	const DOM = React.DOM;
	
	/**
	 * Renders a grip representing CSSStyleSheet
	 */
	let StyleSheet = React.createClass({
	  displayName: "object",
	
	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	  },
	
	  getTitle: function (grip) {
	    let title = "StyleSheet ";
	    if (this.props.objectLink) {
	      return DOM.span({className: "objectBox"},
	        this.props.objectLink({
	          object: grip
	        }, title)
	      );
	    }
	    return title;
	  },
	
	  getLocation: function (grip) {
	    // Embedded stylesheets don't have URL and so, no preview.
	    let url = grip.preview ? grip.preview.url : "";
	    return url ? getURLDisplayString(url) : "";
	  },
	
	  render: function () {
	    let grip = this.props.object;
	
	    return (
	      DOM.span({className: "objectBox objectBox-object"},
	        this.getTitle(grip),
	        DOM.span({className: "objectPropValue"},
	          this.getLocation(grip)
	        )
	      )
	    );
	  },
	});
	
	// Registration
	
	function supportsObject(object, type) {
	  if (!isGrip(object)) {
	    return false;
	  }
	
	  return (type == "CSSStyleSheet");
	}
	
	module.exports = {
	  rep: StyleSheet,
	  supportsObject: supportsObject
	};


/***/ },
/* 582 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	const { isGrip, cropString, cropMultipleLines } = __webpack_require__(560);
	const { MODE } = __webpack_require__(558);
	const nodeConstants = __webpack_require__(583);
	
	// Shortcuts
	const { span } = React.DOM;
	
	/**
	 * Renders DOM comment node.
	 */
	const CommentNode = React.createClass({
	  displayName: "CommentNode",
	
	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	  },
	
	  render: function () {
	    let {
	      object,
	      mode = MODE.SHORT
	    } = this.props;
	
	    let {textContent} = object.preview;
	    if (mode === MODE.TINY) {
	      textContent = cropMultipleLines(textContent, 30);
	    } else if (mode === MODE.SHORT) {
	      textContent = cropString(textContent, 50);
	    }
	
	    return span({className: "objectBox theme-comment"}, `<!-- ${textContent} -->`);
	  },
	});
	
	// Registration
	function supportsObject(object, type) {
	  if (!isGrip(object)) {
	    return false;
	  }
	  return object.preview && object.preview.nodeType === nodeConstants.COMMENT_NODE;
	}
	
	module.exports = {
	  rep: CommentNode,
	  supportsObject: supportsObject
	};


/***/ },
/* 583 */
/***/ function(module, exports) {

	module.exports = {
	  ELEMENT_NODE: 1,
	  ATTRIBUTE_NODE: 2,
	  TEXT_NODE: 3,
	  CDATA_SECTION_NODE: 4,
	  ENTITY_REFERENCE_NODE: 5,
	  ENTITY_NODE: 6,
	  PROCESSING_INSTRUCTION_NODE: 7,
	  COMMENT_NODE: 8,
	  DOCUMENT_NODE: 9,
	  DOCUMENT_TYPE_NODE: 10,
	  DOCUMENT_FRAGMENT_NODE: 11,
	  NOTATION_NODE: 12,
	
	  // DocumentPosition
	  DOCUMENT_POSITION_DISCONNECTED: 0x01,
	  DOCUMENT_POSITION_PRECEDING: 0x02,
	  DOCUMENT_POSITION_FOLLOWING: 0x04,
	  DOCUMENT_POSITION_CONTAINS: 0x08,
	  DOCUMENT_POSITION_CONTAINED_BY: 0x10,
	  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 0x20
	};


/***/ },
/* 584 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	
	// Utils
	const { isGrip } = __webpack_require__(560);
	const { MODE } = __webpack_require__(558);
	const nodeConstants = __webpack_require__(583);
	
	// Shortcuts
	const { span } = React.DOM;
	
	/**
	 * Renders DOM element node.
	 */
	const ElementNode = React.createClass({
	  displayName: "ElementNode",
	
	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	  },
	
	  getElements: function (grip, mode) {
	    let {attributes, nodeName} = grip.preview;
	    const nodeNameElement = span({
	      className: "tag-name theme-fg-color3"
	    }, nodeName);
	
	    if (mode === MODE.TINY) {
	      let elements = [nodeNameElement];
	      if (attributes.id) {
	        elements.push(
	          span({className: "attr-name theme-fg-color2"}, `#${attributes.id}`));
	      }
	      if (attributes.class) {
	        elements.push(
	          span({className: "attr-name theme-fg-color2"},
	            attributes.class
	              .replace(/(^\s+)|(\s+$)/g, "")
	              .split(" ")
	              .map(cls => `.${cls}`)
	              .join("")
	          )
	        );
	      }
	      return elements;
	    }
	    let attributeElements = Object.keys(attributes)
	      .sort(function getIdAndClassFirst(a1, a2) {
	        if ([a1, a2].includes("id")) {
	          return 3 * (a1 === "id" ? -1 : 1);
	        }
	        if ([a1, a2].includes("class")) {
	          return 2 * (a1 === "class" ? -1 : 1);
	        }
	
	        // `id` and `class` excepted,
	        // we want to keep the same order that in `attributes`.
	        return 0;
	      })
	      .reduce((arr, name, i, keys) => {
	        let value = attributes[name];
	        let attribute = span({},
	          span({className: "attr-name theme-fg-color2"}, `${name}`),
	          `="`,
	          span({className: "attr-value theme-fg-color6"}, `${value}`),
	          `"`
	        );
	
	        return arr.concat([" ", attribute]);
	      }, []);
	
	    return [
	      "<",
	      nodeNameElement,
	      ...attributeElements,
	      ">",
	    ];
	  },
	
	  render: function () {
	    let {
	      object,
	      mode,
	      onDOMNodeMouseOver,
	      onDOMNodeMouseOut
	    } = this.props;
	    let elements = this.getElements(object, mode);
	    let objectLink = this.props.objectLink || span;
	
	    let baseConfig = {className: "objectBox objectBox-node"};
	    if (onDOMNodeMouseOver) {
	      Object.assign(baseConfig, {
	        onMouseOver: _ => onDOMNodeMouseOver(object)
	      });
	    }
	
	    if (onDOMNodeMouseOut) {
	      Object.assign(baseConfig, {
	        onMouseOut: onDOMNodeMouseOut
	      });
	    }
	
	    return objectLink({object},
	      span(baseConfig, ...elements)
	    );
	  },
	});
	
	// Registration
	function supportsObject(object, type) {
	  if (!isGrip(object)) {
	    return false;
	  }
	  return object.preview && object.preview.nodeType === nodeConstants.ELEMENT_NODE;
	}
	
	module.exports = {
	  rep: ElementNode,
	  supportsObject: supportsObject
	};


/***/ },
/* 585 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	
	// Reps
	const { isGrip, cropString } = __webpack_require__(560);
	const { MODE } = __webpack_require__(558);
	
	// Shortcuts
	const DOM = React.DOM;
	
	/**
	 * Renders DOM #text node.
	 */
	let TextNode = React.createClass({
	  displayName: "TextNode",
	
	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	  },
	
	  getTextContent: function (grip) {
	    return cropString(grip.preview.textContent);
	  },
	
	  getTitle: function (grip) {
	    const title = "#text";
	    if (this.props.objectLink) {
	      return this.props.objectLink({
	        object: grip
	      }, title);
	    }
	    return title;
	  },
	
	  render: function () {
	    let {
	      object: grip,
	      mode = MODE.SHORT,
	    } = this.props;
	
	    let baseConfig = {className: "objectBox objectBox-textNode"};
	    if (this.props.onDOMNodeMouseOver) {
	      Object.assign(baseConfig, {
	        onMouseOver: _ => this.props.onDOMNodeMouseOver(grip)
	      });
	    }
	
	    if (this.props.onDOMNodeMouseOut) {
	      Object.assign(baseConfig, {
	        onMouseOut: this.props.onDOMNodeMouseOut
	      });
	    }
	
	    if (mode === MODE.TINY) {
	      return DOM.span(baseConfig, this.getTitle(grip));
	    }
	
	    return (
	      DOM.span(baseConfig,
	        this.getTitle(grip),
	        DOM.span({className: "nodeValue"},
	          " ",
	          `"${this.getTextContent(grip)}"`
	        )
	      )
	    );
	  },
	});
	
	// Registration
	
	function supportsObject(grip, type) {
	  if (!isGrip(grip)) {
	    return false;
	  }
	
	  return (grip.preview && grip.class == "Text");
	}
	
	module.exports = {
	  rep: TextNode,
	  supportsObject: supportsObject
	};


/***/ },
/* 586 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	// Utils
	const { isGrip } = __webpack_require__(560);
	const { MODE } = __webpack_require__(558);
	// Shortcuts
	const { span } = React.DOM;
	
	/**
	 * Renders Error objects.
	 */
	const ErrorRep = React.createClass({
	  displayName: "Error",
	
	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	  },
	
	  render: function () {
	    let object = this.props.object;
	    let preview = object.preview;
	    let name = preview && preview.name
	      ? preview.name
	      : "Error";
	
	    let content = this.props.mode === MODE.TINY
	      ? name
	      : `${name}: ${preview.message}`;
	
	    if (preview.stack && this.props.mode !== MODE.TINY) {
	      /*
	       * Since Reps are used in the JSON Viewer, we can't localize
	       * the "Stack trace" label (defined in debugger.properties as
	       * "variablesViewErrorStacktrace" property), until Bug 1317038 lands.
	       */
	      content = `${content}\nStack trace:\n${preview.stack}`;
	    }
	
	    let objectLink = this.props.objectLink || span;
	    return (
	      objectLink({object, className: "objectBox-stackTrace"},
	        span({}, content)
	      )
	    );
	  },
	});
	
	// Registration
	function supportsObject(object, type) {
	  if (!isGrip(object)) {
	    return false;
	  }
	  return (object.preview && type === "Error");
	}
	
	module.exports = {
	  rep: ErrorRep,
	  supportsObject: supportsObject
	};


/***/ },
/* 587 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	const { MODE } = __webpack_require__(558);
	
	// Reps
	const { isGrip, getURLDisplayString } = __webpack_require__(560);
	
	// Shortcuts
	const DOM = React.DOM;
	
	/**
	 * Renders a grip representing a window.
	 */
	let Window = React.createClass({
	  displayName: "Window",
	
	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	  },
	
	  getTitle: function (grip) {
	    if (this.props.objectLink) {
	      return DOM.span({className: "objectBox"},
	        this.props.objectLink({
	          object: grip
	        }, grip.class + " ")
	      );
	    }
	    return "";
	  },
	
	  getLocation: function (grip) {
	    return getURLDisplayString(grip.preview.url);
	  },
	
	  getDisplayValue: function (grip) {
	    if (this.props.mode === MODE.TINY) {
	      return grip.isGlobal ? "Global" : "Window";
	    }
	
	    return this.getLocation(grip);
	  },
	
	  render: function () {
	    let grip = this.props.object;
	
	    return (
	      DOM.span({className: "objectBox objectBox-Window"},
	        this.getTitle(grip),
	        DOM.span({className: "objectPropValue"},
	          this.getDisplayValue(grip)
	        )
	      )
	    );
	  },
	});
	
	// Registration
	
	function supportsObject(object, type) {
	  if (!isGrip(object)) {
	    return false;
	  }
	
	  return (object.preview && type == "Window");
	}
	
	module.exports = {
	  rep: Window,
	  supportsObject: supportsObject
	};


/***/ },
/* 588 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	
	// Reps
	const { isGrip } = __webpack_require__(560);
	
	// Shortcuts
	const { span } = React.DOM;
	
	/**
	 * Renders a grip object with textual data.
	 */
	let ObjectWithText = React.createClass({
	  displayName: "ObjectWithText",
	
	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	  },
	
	  getTitle: function (grip) {
	    if (this.props.objectLink) {
	      return span({className: "objectBox"},
	        this.props.objectLink({
	          object: grip
	        }, this.getType(grip) + " ")
	      );
	    }
	    return "";
	  },
	
	  getType: function (grip) {
	    return grip.class;
	  },
	
	  getDescription: function (grip) {
	    return "\"" + grip.preview.text + "\"";
	  },
	
	  render: function () {
	    let grip = this.props.object;
	    return (
	      span({className: "objectBox objectBox-" + this.getType(grip)},
	        this.getTitle(grip),
	        span({className: "objectPropValue"},
	          this.getDescription(grip)
	        )
	      )
	    );
	  },
	});
	
	// Registration
	
	function supportsObject(grip, type) {
	  if (!isGrip(grip)) {
	    return false;
	  }
	
	  return (grip.preview && grip.preview.kind == "ObjectWithText");
	}
	
	module.exports = {
	  rep: ObjectWithText,
	  supportsObject: supportsObject
	};


/***/ },
/* 589 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	
	// Reps
	const { isGrip, getURLDisplayString } = __webpack_require__(560);
	
	// Shortcuts
	const { span } = React.DOM;
	
	/**
	 * Renders a grip object with URL data.
	 */
	let ObjectWithURL = React.createClass({
	  displayName: "ObjectWithURL",
	
	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	  },
	
	  getTitle: function (grip) {
	    if (this.props.objectLink) {
	      return span({className: "objectBox"},
	        this.props.objectLink({
	          object: grip
	        }, this.getType(grip) + " ")
	      );
	    }
	    return "";
	  },
	
	  getType: function (grip) {
	    return grip.class;
	  },
	
	  getDescription: function (grip) {
	    return getURLDisplayString(grip.preview.url);
	  },
	
	  render: function () {
	    let grip = this.props.object;
	    return (
	      span({className: "objectBox objectBox-" + this.getType(grip)},
	        this.getTitle(grip),
	        span({className: "objectPropValue"},
	          this.getDescription(grip)
	        )
	      )
	    );
	  },
	});
	
	// Registration
	
	function supportsObject(grip, type) {
	  if (!isGrip(grip)) {
	    return false;
	  }
	
	  return (grip.preview && grip.preview.kind == "ObjectWithURL");
	}
	
	module.exports = {
	  rep: ObjectWithURL,
	  supportsObject: supportsObject
	};


/***/ },
/* 590 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	const { isGrip } = __webpack_require__(560);
	const Caption = React.createFactory(__webpack_require__(567));
	const { MODE } = __webpack_require__(558);
	
	// Shortcuts
	const { span } = React.DOM;
	
	/**
	 * Renders an array. The array is enclosed by left and right bracket
	 * and the max number of rendered items depends on the current mode.
	 */
	let GripArray = React.createClass({
	  displayName: "GripArray",
	
	  propTypes: {
	    object: React.PropTypes.object.isRequired,
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	    provider: React.PropTypes.object,
	  },
	
	  getLength: function (grip) {
	    if (!grip.preview) {
	      return 0;
	    }
	
	    return grip.preview.length || grip.preview.childNodesLength || 0;
	  },
	
	  getTitle: function (object, context) {
	    let objectLink = this.props.objectLink || span;
	    if (this.props.mode !== MODE.TINY) {
	      return objectLink({
	        object: object
	      }, object.class + " ");
	    }
	    return "";
	  },
	
	  getPreviewItems: function (grip) {
	    if (!grip.preview) {
	      return null;
	    }
	
	    return grip.preview.items || grip.preview.childNodes || null;
	  },
	
	  arrayIterator: function (grip, max) {
	    let items = [];
	    const gripLength = this.getLength(grip);
	
	    if (!gripLength) {
	      return items;
	    }
	
	    const previewItems = this.getPreviewItems(grip);
	    if (!previewItems) {
	      return items;
	    }
	
	    let delim;
	    // number of grip preview items is limited to 10, but we may have more
	    // items in grip-array.
	    let delimMax = gripLength > previewItems.length ?
	      previewItems.length : previewItems.length - 1;
	    let provider = this.props.provider;
	
	    for (let i = 0; i < previewItems.length && i < max; i++) {
	      try {
	        let itemGrip = previewItems[i];
	        let value = provider ? provider.getValue(itemGrip) : itemGrip;
	
	        delim = (i == delimMax ? "" : ", ");
	
	        items.push(GripArrayItem(Object.assign({}, this.props, {
	          object: value,
	          delim: delim
	        })));
	      } catch (exc) {
	        items.push(GripArrayItem(Object.assign({}, this.props, {
	          object: exc,
	          delim: delim
	        })));
	      }
	    }
	    if (previewItems.length > max || gripLength > previewItems.length) {
	      let objectLink = this.props.objectLink || span;
	      let leftItemNum = gripLength - max > 0 ?
	        gripLength - max : gripLength - previewItems.length;
	      items.push(Caption({
	        object: objectLink({
	          object: this.props.object
	        }, leftItemNum + " more…")
	      }));
	    }
	
	    return items;
	  },
	
	  render: function () {
	    let {
	      object,
	      mode = MODE.SHORT
	    } = this.props;
	
	    let items;
	    let brackets;
	    let needSpace = function (space) {
	      return space ? { left: "[ ", right: " ]"} : { left: "[", right: "]"};
	    };
	
	    if (mode === MODE.TINY) {
	      let objectLength = this.getLength(object);
	      let isEmpty = objectLength === 0;
	      items = [span({className: "length"}, isEmpty ? "" : objectLength)];
	      brackets = needSpace(false);
	    } else {
	      let max = (mode === MODE.SHORT) ? 3 : 10;
	      items = this.arrayIterator(object, max);
	      brackets = needSpace(items.length > 0);
	    }
	
	    let objectLink = this.props.objectLink || span;
	    let title = this.getTitle(object);
	
	    return (
	      span({
	        className: "objectBox objectBox-array"},
	        title,
	        objectLink({
	          className: "arrayLeftBracket",
	          object: object
	        }, brackets.left),
	        ...items,
	        objectLink({
	          className: "arrayRightBracket",
	          object: object
	        }, brackets.right),
	        span({
	          className: "arrayProperties",
	          role: "group"}
	        )
	      )
	    );
	  },
	});
	
	/**
	 * Renders array item. Individual values are separated by
	 * a delimiter (a comma by default).
	 */
	let GripArrayItem = React.createFactory(React.createClass({
	  displayName: "GripArrayItem",
	
	  propTypes: {
	    delim: React.PropTypes.string,
	  },
	
	  render: function () {
	    let Rep = React.createFactory(__webpack_require__(559));
	
	    return (
	      span({},
	        Rep(Object.assign({}, this.props, {
	          mode: MODE.TINY
	        })),
	        this.props.delim
	      )
	    );
	  }
	}));
	
	function supportsObject(grip, type) {
	  if (!isGrip(grip)) {
	    return false;
	  }
	
	  return (grip.preview && (
	      grip.preview.kind == "ArrayLike" ||
	      type === "DocumentFragment"
	    )
	  );
	}
	
	module.exports = {
	  rep: GripArray,
	  supportsObject: supportsObject
	};


/***/ },
/* 591 */
/***/ function(module, exports, __webpack_require__) {

	const React = __webpack_require__(2);
	const { isGrip } = __webpack_require__(560);
	const Caption = React.createFactory(__webpack_require__(567));
	const PropRep = React.createFactory(__webpack_require__(569));
	const { MODE } = __webpack_require__(558);
	// Shortcuts
	const { span } = React.DOM;
	/**
	 * Renders an map. A map is represented by a list of its
	 * entries enclosed in curly brackets.
	 */
	const GripMap = React.createClass({
	  displayName: "GripMap",
	
	  propTypes: {
	    object: React.PropTypes.object,
	    // @TODO Change this to Object.values once it's supported in Node's version of V8
	    mode: React.PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
	  },
	
	  getTitle: function (object) {
	    let title = object && object.class ? object.class : "Map";
	    if (this.props.objectLink) {
	      return this.props.objectLink({
	        object: object
	      }, title);
	    }
	    return title;
	  },
	
	  safeEntriesIterator: function (object, max) {
	    max = (typeof max === "undefined") ? 3 : max;
	    try {
	      return this.entriesIterator(object, max);
	    } catch (err) {
	      console.error(err);
	    }
	    return [];
	  },
	
	  entriesIterator: function (object, max) {
	    // Entry filter. Show only interesting entries to the user.
	    let isInterestingEntry = this.props.isInterestingEntry || ((type, value) => {
	      return (
	        type == "boolean" ||
	        type == "number" ||
	        (type == "string" && value.length != 0)
	      );
	    });
	
	    let mapEntries = object.preview && object.preview.entries
	      ? object.preview.entries : [];
	
	    let indexes = this.getEntriesIndexes(mapEntries, max, isInterestingEntry);
	    if (indexes.length < max && indexes.length < mapEntries.length) {
	      // There are not enough entries yet, so we add uninteresting entries.
	      indexes = indexes.concat(
	        this.getEntriesIndexes(mapEntries, max - indexes.length, (t, value, name) => {
	          return !isInterestingEntry(t, value, name);
	        })
	      );
	    }
	
	    let entries = this.getEntries(mapEntries, indexes);
	    if (entries.length < mapEntries.length) {
	      // There are some undisplayed entries. Then display "more…".
	      let objectLink = this.props.objectLink || span;
	
	      entries.push(Caption({
	        key: "more",
	        object: objectLink({
	          object: object
	        }, `${mapEntries.length - max} more…`)
	      }));
	    }
	
	    return entries;
	  },
	
	  /**
	   * Get entries ordered by index.
	   *
	   * @param {Array} entries Entries array.
	   * @param {Array} indexes Indexes of entries.
	   * @return {Array} Array of PropRep.
	   */
	  getEntries: function (entries, indexes) {
	    // Make indexes ordered by ascending.
	    indexes.sort(function (a, b) {
	      return a - b;
	    });
	
	    return indexes.map((index, i) => {
	      let [key, entryValue] = entries[index];
	      let value = entryValue.value !== undefined ? entryValue.value : entryValue;
	
	      return PropRep({
	        // key,
	        name: key,
	        equal: ": ",
	        object: value,
	        // Do not add a trailing comma on the last entry
	        // if there won't be a "more..." item.
	        delim: (i < indexes.length - 1 || indexes.length < entries.length) ? ", " : "",
	        mode: MODE.TINY,
	        objectLink: this.props.objectLink,
	      });
	    });
	  },
	
	  /**
	   * Get the indexes of entries in the map.
	   *
	   * @param {Array} entries Entries array.
	   * @param {Number} max The maximum length of indexes array.
	   * @param {Function} filter Filter the entry you want.
	   * @return {Array} Indexes of filtered entries in the map.
	   */
	  getEntriesIndexes: function (entries, max, filter) {
	    return entries
	      .reduce((indexes, [key, entry], i) => {
	        if (indexes.length < max) {
	          let value = (entry && entry.value !== undefined) ? entry.value : entry;
	          // Type is specified in grip's "class" field and for primitive
	          // values use typeof.
	          let type = (value && value.class ? value.class : typeof value).toLowerCase();
	
	          if (filter(type, value, key)) {
	            indexes.push(i);
	          }
	        }
	
	        return indexes;
	      }, []);
	  },
	
	  render: function () {
	    let object = this.props.object;
	    let props = this.safeEntriesIterator(object,
	      (this.props.mode === MODE.LONG) ? 10 : 3);
	
	    let objectLink = this.props.objectLink || span;
	    if (this.props.mode === MODE.TINY) {
	      return (
	        span({className: "objectBox objectBox-object"},
	          this.getTitle(object),
	          objectLink({
	            className: "objectLeftBrace",
	            object: object
	          }, "")
	        )
	      );
	    }
	
	    return (
	      span({className: "objectBox objectBox-object"},
	        this.getTitle(object),
	        objectLink({
	          className: "objectLeftBrace",
	          object: object
	        }, " { "),
	        props,
	        objectLink({
	          className: "objectRightBrace",
	          object: object
	        }, " }")
	      )
	    );
	  },
	});
	
	function supportsObject(grip, type) {
	  if (!isGrip(grip)) {
	    return false;
	  }
	  return (grip.preview && grip.preview.kind == "MapLike");
	}
	
	module.exports = {
	  rep: GripMap,
	  supportsObject: supportsObject
	};


/***/ },
/* 592 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 593 */,
/* 594 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 595 */,
/* 596 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	
	var _require = __webpack_require__(3),
	    bindActionCreators = _require.bindActionCreators;
	
	var _require2 = __webpack_require__(305),
	    connect = _require2.connect;
	
	var actions = __webpack_require__(314);
	
	var _require3 = __webpack_require__(303),
	    getChromeScopes = _require3.getChromeScopes;
	
	var dom = React.DOM,
	    PropTypes = React.PropTypes;
	
	var classnames = __webpack_require__(413);
	var Svg = __webpack_require__(414);
	
	__webpack_require__(597);
	
	var Scopes = React.createClass({
	  propTypes: {
	    scopes: PropTypes.array
	  },
	
	  displayName: "Scopes",
	
	  renderScopes() {
	    var scopes = this.props.scopes;
	
	
	    if (!scopes) {
	      return dom.div({ className: "pane-info" }, L10N.getStr("scopes.notAvailable"));
	    }
	
	    return scopes.map(scope => dom.div({}, this.renderItem(scope.name || scope.type)));
	  },
	
	  renderItem(name) {
	    return dom.div({ className: classnames("node"),
	      style: { marginLeft: 15 }
	    }, Svg("arrow", {
	      className: classnames({
	        expanded: false
	      })
	    }), dom.span({ className: "object-label" }, name));
	  },
	
	  render() {
	    return dom.div({ className: "pane scopes-list" }, this.renderScopes());
	  }
	});
	
	module.exports = connect(state => ({
	  scopes: getChromeScopes(state)
	}), dispatch => bindActionCreators(actions, dispatch))(Scopes);

/***/ },
/* 597 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 598 */,
/* 599 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	
	var _require = __webpack_require__(3),
	    bindActionCreators = _require.bindActionCreators;
	
	var _require2 = __webpack_require__(305),
	    connect = _require2.connect;
	
	var ImPropTypes = __webpack_require__(450);
	var actions = __webpack_require__(314);
	
	var _require3 = __webpack_require__(303),
	    getSelectedFrame = _require3.getSelectedFrame,
	    getLoadedObjects = _require3.getLoadedObjects,
	    getPause = _require3.getPause;
	
	var ObjectInspector = React.createFactory(__webpack_require__(555));
	var dom = React.DOM,
	    PropTypes = React.PropTypes;
	
	var toPairs = __webpack_require__(600);
	
	__webpack_require__(597);
	
	function info(text) {
	  return dom.div({ className: "pane-info" }, text);
	}
	
	// Create the tree nodes representing all the variables and arguments
	// for the bindings from a scope.
	function getBindingVariables(bindings, parentName) {
	  var args = bindings.arguments.map(arg => toPairs(arg)[0]);
	  var variables = toPairs(bindings.variables);
	
	  return args.concat(variables).map(binding => ({
	    name: binding[0],
	    path: `${ parentName }/${ binding[0] }`,
	    contents: binding[1]
	  }));
	}
	
	function getSpecialVariables(pauseInfo, path) {
	  var thrown = pauseInfo.getIn(["why", "frameFinished", "throw"]);
	  var returned = pauseInfo.getIn(["why", "frameFinished", "return"]);
	  var vars = [];
	
	  if (thrown) {
	    // handle dehydrating exception strings and errors.
	    thrown = thrown.toJS ? thrown.toJS() : thrown;
	
	    vars.push({
	      name: "<exception>",
	      path: `${ path }/<exception>`,
	      contents: { value: thrown }
	    });
	  }
	
	  if (returned) {
	    var value = returned.toJS ? returned.toJS() : returned;
	    vars.push({
	      name: "<return>",
	      path: `${ path }/<return>`,
	      contents: { value }
	    });
	  }
	
	  return vars;
	}
	
	function getThisVariable(frame, path) {
	  var this_ = frame.this;
	
	  if (!this_) {
	    return null;
	  }
	
	  return {
	    name: "<this>",
	    path: `${ path }/<this>`,
	    contents: { value: this_ }
	  };
	}
	
	function getScopes(pauseInfo, selectedFrame) {
	  if (!pauseInfo || !selectedFrame) {
	    return null;
	  }
	
	  var selectedScope = selectedFrame.scope;
	
	  if (!selectedScope) {
	    return null;
	  }
	
	  var scopes = [];
	
	  var scope = selectedScope;
	  var pausedScopeActor = pauseInfo.getIn(["frame", "scope"]).get("actor");
	
	  do {
	    var type = scope.type;
	    var key = scope.actor;
	    if (type === "function" || type === "block") {
	      var bindings = scope.bindings;
	      var title = void 0;
	      if (type === "function") {
	        title = scope.function.displayName || "(anonymous)";
	      } else {
	        title = L10N.getStr("scopes.block");
	      }
	
	      var vars = getBindingVariables(bindings, title);
	
	      // show exception, return, and this variables in innermost scope
	      if (scope.actor === pausedScopeActor) {
	        vars = vars.concat(getSpecialVariables(pauseInfo, key));
	      }
	
	      if (scope.actor === selectedScope.actor) {
	        var this_ = getThisVariable(selectedFrame, key);
	
	        if (this_) {
	          vars.push(this_);
	        }
	      }
	
	      if (vars && vars.length) {
	        vars.sort((a, b) => a.name.localeCompare(b.name));
	        scopes.push({ name: title, path: key, contents: vars });
	      }
	    } else if (type === "object") {
	      var value = scope.object;
	      // If this is the global window scope, mark it as such so that it will
	      // preview Window: Global instead of Window: Window
	      if (value.class === "Window") {
	        value = Object.assign({}, scope.object, { isGlobal: true });
	      }
	      scopes.push({
	        name: scope.object.class,
	        path: key,
	        contents: { value }
	      });
	    }
	  } while (scope = scope.parent); // eslint-disable-line no-cond-assign
	
	  return scopes;
	}
	
	var Scopes = React.createClass({
	  propTypes: {
	    pauseInfo: ImPropTypes.map,
	    loadedObjects: ImPropTypes.map,
	    loadObjectProperties: PropTypes.func,
	    selectedFrame: PropTypes.object
	  },
	
	  displayName: "Scopes",
	
	  shouldComponentUpdate(nextProps, nextState) {
	    var _props = this.props,
	        pauseInfo = _props.pauseInfo,
	        selectedFrame = _props.selectedFrame,
	        loadedObjects = _props.loadedObjects;
	
	    return pauseInfo !== nextProps.pauseInfo || selectedFrame !== nextProps.selectedFrame || loadedObjects !== nextProps.loadedObjects;
	  },
	
	  getInitialState() {
	    var _props2 = this.props,
	        pauseInfo = _props2.pauseInfo,
	        selectedFrame = _props2.selectedFrame;
	
	    return { scopes: getScopes(pauseInfo, selectedFrame) };
	  },
	
	  componentWillReceiveProps(nextProps) {
	    var _props3 = this.props,
	        pauseInfo = _props3.pauseInfo,
	        selectedFrame = _props3.selectedFrame;
	
	    var pauseInfoChanged = pauseInfo !== nextProps.pauseInfo;
	    var selectedFrameChange = selectedFrame !== nextProps.selectedFrame;
	
	    if (pauseInfoChanged || selectedFrameChange) {
	      this.setState({
	        scopes: getScopes(nextProps.pauseInfo, nextProps.selectedFrame)
	      });
	    }
	  },
	
	  render() {
	    var _props4 = this.props,
	        pauseInfo = _props4.pauseInfo,
	        loadObjectProperties = _props4.loadObjectProperties,
	        loadedObjects = _props4.loadedObjects;
	    var scopes = this.state.scopes;
	
	
	    var scopeInspector = info(L10N.getStr("scopes.notAvailable"));
	    if (scopes) {
	      scopeInspector = ObjectInspector({
	        roots: scopes,
	        getObjectProperties: id => loadedObjects.get(id),
	        loadObjectProperties: loadObjectProperties
	      });
	    }
	
	    return dom.div({ className: "pane scopes-list" }, pauseInfo ? scopeInspector : info(L10N.getStr("scopes.notPaused")));
	  }
	});
	
	module.exports = connect(state => ({
	  pauseInfo: getPause(state),
	  selectedFrame: getSelectedFrame(state),
	  loadedObjects: getLoadedObjects(state)
	}), dispatch => bindActionCreators(actions, dispatch))(Scopes);

/***/ },
/* 600 */
/***/ function(module, exports, __webpack_require__) {

	var createToPairs = __webpack_require__(601),
	    keys = __webpack_require__(610);
	
	/**
	 * Creates an array of own enumerable string keyed-value pairs for `object`
	 * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
	 * entries are returned.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @alias entries
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the key-value pairs.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.toPairs(new Foo);
	 * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
	 */
	var toPairs = createToPairs(keys);
	
	module.exports = toPairs;


/***/ },
/* 601 */
/***/ function(module, exports, __webpack_require__) {

	var baseToPairs = __webpack_require__(602),
	    getTag = __webpack_require__(603),
	    mapToArray = __webpack_require__(608),
	    setToPairs = __webpack_require__(609);
	
	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    setTag = '[object Set]';
	
	/**
	 * Creates a `_.toPairs` or `_.toPairsIn` function.
	 *
	 * @private
	 * @param {Function} keysFunc The function to get the keys of a given object.
	 * @returns {Function} Returns the new pairs function.
	 */
	function createToPairs(keysFunc) {
	  return function(object) {
	    var tag = getTag(object);
	    if (tag == mapTag) {
	      return mapToArray(object);
	    }
	    if (tag == setTag) {
	      return setToPairs(object);
	    }
	    return baseToPairs(object, keysFunc(object));
	  };
	}
	
	module.exports = createToPairs;


/***/ },
/* 602 */
/***/ function(module, exports, __webpack_require__) {

	var arrayMap = __webpack_require__(242);
	
	/**
	 * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
	 * of key-value pairs for `object` corresponding to the property names of `props`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} props The property names to get values for.
	 * @returns {Object} Returns the key-value pairs.
	 */
	function baseToPairs(object, props) {
	  return arrayMap(props, function(key) {
	    return [key, object[key]];
	  });
	}
	
	module.exports = baseToPairs;


/***/ },
/* 603 */
/***/ function(module, exports, __webpack_require__) {

	var DataView = __webpack_require__(604),
	    Map = __webpack_require__(233),
	    Promise = __webpack_require__(605),
	    Set = __webpack_require__(606),
	    WeakMap = __webpack_require__(607),
	    baseGetTag = __webpack_require__(6),
	    toSource = __webpack_require__(219);
	
	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag = '[object Set]',
	    weakMapTag = '[object WeakMap]';
	
	var dataViewTag = '[object DataView]';
	
	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);
	
	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;
	
	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = baseGetTag(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';
	
	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}
	
	module.exports = getTag;


/***/ },
/* 604 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(213),
	    root = __webpack_require__(8);
	
	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView');
	
	module.exports = DataView;


/***/ },
/* 605 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(213),
	    root = __webpack_require__(8);
	
	/* Built-in method references that are verified to be native. */
	var Promise = getNative(root, 'Promise');
	
	module.exports = Promise;


/***/ },
/* 606 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(213),
	    root = __webpack_require__(8);
	
	/* Built-in method references that are verified to be native. */
	var Set = getNative(root, 'Set');
	
	module.exports = Set;


/***/ },
/* 607 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(213),
	    root = __webpack_require__(8);
	
	/* Built-in method references that are verified to be native. */
	var WeakMap = getNative(root, 'WeakMap');
	
	module.exports = WeakMap;


/***/ },
/* 608 */
/***/ function(module, exports) {

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);
	
	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}
	
	module.exports = mapToArray;


/***/ },
/* 609 */
/***/ function(module, exports) {

	/**
	 * Converts `set` to its value-value pairs.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the value-value pairs.
	 */
	function setToPairs(set) {
	  var index = -1,
	      result = Array(set.size);
	
	  set.forEach(function(value) {
	    result[++index] = [value, value];
	  });
	  return result;
	}
	
	module.exports = setToPairs;


/***/ },
/* 610 */
/***/ function(module, exports, __webpack_require__) {

	var arrayLikeKeys = __webpack_require__(491),
	    baseKeys = __webpack_require__(611),
	    isArrayLike = __webpack_require__(479);
	
	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}
	
	module.exports = keys;


/***/ },
/* 611 */
/***/ function(module, exports, __webpack_require__) {

	var isPrototype = __webpack_require__(475),
	    nativeKeys = __webpack_require__(612);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	module.exports = baseKeys;


/***/ },
/* 612 */
/***/ function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(13);
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);
	
	module.exports = nativeKeys;


/***/ },
/* 613 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	var dom = React.DOM,
	    PropTypes = React.PropTypes;
	var div = dom.div;
	
	var _require = __webpack_require__(3),
	    bindActionCreators = _require.bindActionCreators;
	
	var _require2 = __webpack_require__(305),
	    connect = _require2.connect;
	
	var ImPropTypes = __webpack_require__(450);
	var actions = __webpack_require__(314);
	
	var _require3 = __webpack_require__(250),
	    endTruncateStr = _require3.endTruncateStr;
	
	var _require4 = __webpack_require__(295),
	    getFilename = _require4.getFilename;
	
	var _require5 = __webpack_require__(303),
	    getFrames = _require5.getFrames,
	    getSelectedFrame = _require5.getSelectedFrame,
	    getSource = _require5.getSource;
	
	var classNames = __webpack_require__(413);
	
	if (typeof window == "object") {
	  __webpack_require__(614);
	}
	
	var NUM_FRAMES_SHOWN = 7;
	
	function renderFrameTitle(_ref) {
	  var displayName = _ref.displayName;
	
	  return div({ className: "title" }, endTruncateStr(displayName, 40));
	}
	
	function renderFrameLocation(_ref2) {
	  var source = _ref2.source,
	      location = _ref2.location;
	
	  var thisSource = source;
	  if (thisSource == null) {
	    return;
	  }
	
	  var filename = getFilename(thisSource);
	  return div({ className: "location" }, `${ filename }: ${ location.line }`);
	}
	
	var Frames = React.createClass({
	  propTypes: {
	    frames: ImPropTypes.list,
	    selectedFrame: PropTypes.object,
	    selectFrame: PropTypes.func.isRequired
	  },
	
	  displayName: "Frames",
	
	  shouldComponentUpdate(nextProps, nextState) {
	    var _props = this.props,
	        frames = _props.frames,
	        selectedFrame = _props.selectedFrame;
	    var showAllFrames = this.state.showAllFrames;
	
	    return frames !== nextProps.frames || selectedFrame !== nextProps.selectedFrame || showAllFrames !== nextState.showAllFrames;
	  },
	
	  getInitialState() {
	    return { showAllFrames: false };
	  },
	
	  toggleFramesDisplay() {
	    this.setState({
	      showAllFrames: !this.state.showAllFrames
	    });
	  },
	
	  renderFrame(frame) {
	    var _props2 = this.props,
	        selectedFrame = _props2.selectedFrame,
	        selectFrame = _props2.selectFrame;
	
	
	    return dom.li({ key: frame.id,
	      className: classNames("frame", {
	        "selected": selectedFrame && selectedFrame.id === frame.id
	      }),
	      onMouseDown: () => selectFrame(frame),
	      tabIndex: 0
	    }, renderFrameTitle(frame), renderFrameLocation(frame));
	  },
	
	  renderFrames(frames) {
	    var numFramesToShow = this.state.showAllFrames ? frames.size : NUM_FRAMES_SHOWN;
	    var framesToShow = frames.slice(0, numFramesToShow);
	
	    return dom.ul({}, framesToShow.map(this.renderFrame));
	  },
	
	  renderToggleButton(frames) {
	    var buttonMessage = this.state.showAllFrames ? L10N.getStr("callStack.collapse") : L10N.getStr("callStack.expand");
	
	    if (frames.size < NUM_FRAMES_SHOWN) {
	      return null;
	    }
	
	    return dom.div({ className: "show-more", onClick: this.toggleFramesDisplay }, buttonMessage);
	  },
	
	  render() {
	    var frames = this.props.frames;
	
	
	    if (!frames) {
	      return div({ className: "pane frames" }, div({ className: "pane-info empty" }, L10N.getStr("callStack.notPaused")));
	    }
	
	    return div({ className: "pane frames" }, this.renderFrames(frames), this.renderToggleButton(frames));
	  }
	});
	
	function getAndProcessFrames(state) {
	  var frames = getFrames(state);
	  if (!frames) {
	    return null;
	  }
	  return frames.filter(frame => getSource(state, frame.location.sourceId)).map(frame => Object.assign({}, frame, {
	    source: getSource(state, frame.location.sourceId).toJS()
	  }));
	}
	
	module.exports = connect(state => ({
	  frames: getAndProcessFrames(state),
	  selectedFrame: getSelectedFrame(state)
	}), dispatch => bindActionCreators(actions, dispatch))(Frames);

/***/ },
/* 614 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 615 */,
/* 616 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	var dom = React.DOM,
	    PropTypes = React.PropTypes;
	
	var _require = __webpack_require__(3),
	    bindActionCreators = _require.bindActionCreators;
	
	var _require2 = __webpack_require__(305),
	    connect = _require2.connect;
	
	var actions = __webpack_require__(314);
	
	var _require3 = __webpack_require__(303),
	    getEventListeners = _require3.getEventListeners,
	    getBreakpoint = _require3.getBreakpoint;
	
	var CloseButton = __webpack_require__(444);
	
	__webpack_require__(617);
	
	var EventListeners = React.createClass({
	  propTypes: {
	    listeners: PropTypes.array,
	    selectSource: PropTypes.func,
	    addBreakpoint: PropTypes.func,
	    enableBreakpoint: PropTypes.func,
	    disableBreakpoint: PropTypes.func,
	    removeBreakpoint: PropTypes.func
	  },
	
	  displayName: "EventListeners",
	
	  renderListener(_ref) {
	    var type = _ref.type,
	        selector = _ref.selector,
	        line = _ref.line,
	        sourceId = _ref.sourceId,
	        breakpoint = _ref.breakpoint;
	
	    var checked = breakpoint && !breakpoint.disabled;
	    var location = { sourceId, line };
	
	    return dom.div({
	      className: "listener",
	      onClick: () => this.props.selectSource(sourceId, { line }),
	      key: `${ type }.${ selector }.${ sourceId }.${ line }`
	    }, dom.input({
	      type: "checkbox",
	      className: "listener-checkbox",
	      checked,
	      onChange: () => this.handleCheckbox(breakpoint, location)
	    }), dom.span({ className: "type" }, type), dom.span({ className: "selector" }, selector), breakpoint ? CloseButton({
	      handleClick: ev => this.removeBreakpoint(ev, breakpoint)
	    }) : "");
	  },
	
	  handleCheckbox(breakpoint, location) {
	    if (!breakpoint) {
	      return this.props.addBreakpoint(location);
	    }
	
	    if (breakpoint.loading) {
	      return;
	    }
	
	    if (breakpoint.disabled) {
	      this.props.enableBreakpoint(breakpoint.location);
	    } else {
	      this.props.disableBreakpoint(breakpoint.location);
	    }
	  },
	
	  removeBreakpoint(event, breakpoint) {
	    event.stopPropagation();
	    this.props.removeBreakpoint(breakpoint.location);
	  },
	
	  render() {
	    var listeners = this.props.listeners;
	
	    return dom.div({
	      className: "pane event-listeners"
	    }, listeners.map(this.renderListener));
	  }
	});
	
	module.exports = connect(state => {
	  var listeners = getEventListeners(state).map(l => Object.assign({}, l, {
	    breakpoint: getBreakpoint(state, { sourceId: l.sourceId, line: l.line })
	  }));
	
	  return { listeners };
	}, dispatch => bindActionCreators(actions, dispatch))(EventListeners);

/***/ },
/* 617 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 618 */,
/* 619 */
/***/ function(module, exports, __webpack_require__) {

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	var React = __webpack_require__(2);
	var dom = React.DOM,
	    PropTypes = React.PropTypes;
	var div = dom.div;
	
	var Svg = __webpack_require__(414);
	
	__webpack_require__(620);
	
	var Accordion = React.createClass({
	  propTypes: {
	    items: PropTypes.array
	  },
	
	  displayName: "Accordion",
	
	  getInitialState: function () {
	    return { opened: this.props.items.map(item => item.opened),
	      created: [] };
	  },
	
	  componentWillReceiveProps: function (nextProps) {
	    var newOpened = this.state.opened.map((isOpen, i) => {
	      var shouldOpen = nextProps.items[i].shouldOpen;
	
	
	      return isOpen || shouldOpen && shouldOpen();
	    });
	
	    this.setState({ opened: newOpened });
	  },
	
	  handleHeaderClick: function (i) {
	    var opened = [].concat(_toConsumableArray(this.state.opened));
	    var created = [].concat(_toConsumableArray(this.state.created));
	    var item = this.props.items[i];
	
	    opened[i] = !opened[i];
	    created[i] = true;
	
	    if (opened[i] && item.onOpened) {
	      item.onOpened();
	    }
	
	    if (item.onToggle) {
	      item.onToggle(opened[i]);
	    }
	
	    this.setState({ opened, created });
	  },
	
	  renderContainer: function (item, i) {
	    var _state = this.state,
	        opened = _state.opened,
	        created = _state.created;
	
	    var containerClassName = `${ item.header.toLowerCase().replace(/\s/g, "-") }-pane`;
	
	    return div({ className: containerClassName, key: i }, div({ className: "_header",
	      onClick: () => this.handleHeaderClick(i) }, Svg("arrow", { className: opened[i] ? "expanded" : "" }), item.header, item.buttons ? dom.div({ className: "header-buttons" }, item.buttons) : null), created[i] || opened[i] ? div({ className: "_content",
	      style: { display: opened[i] ? "block" : "none" }
	    }, React.createElement(item.component, item.componentProps || {})) : null);
	  },
	
	  render: function () {
	    return div({ className: "accordion" }, this.props.items.map(this.renderContainer));
	  }
	});
	
	module.exports = Accordion;

/***/ },
/* 620 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 621 */,
/* 622 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	var dom = React.DOM,
	    PropTypes = React.PropTypes;
	
	var _require = __webpack_require__(22),
	    findDOMNode = _require.findDOMNode;
	
	var _require2 = __webpack_require__(305),
	    connect = _require2.connect;
	
	var _require3 = __webpack_require__(3),
	    bindActionCreators = _require3.bindActionCreators;
	
	var _require4 = __webpack_require__(303),
	    getPause = _require4.getPause,
	    getIsWaitingOnBreak = _require4.getIsWaitingOnBreak,
	    getShouldPauseOnExceptions = _require4.getShouldPauseOnExceptions,
	    getShouldIgnoreCaughtExceptions = _require4.getShouldIgnoreCaughtExceptions;
	
	var Svg = __webpack_require__(414);
	var ImPropTypes = __webpack_require__(450);
	
	var _require5 = __webpack_require__(451),
	    formatKeyShortcut = _require5.formatKeyShortcut;
	
	var _require6 = __webpack_require__(28),
	    appinfo = _require6.Services.appinfo;
	
	var actions = __webpack_require__(314);
	__webpack_require__(623);
	
	var isMacOS = appinfo.OS === "Darwin";
	
	var COMMANDS = ["resume", "stepOver", "stepIn", "stepOut"];
	
	var KEYS = {
	  "WINNT": {
	    "resume": "F8",
	    "pause": "F8",
	    "stepOver": "F10",
	    "stepIn": "F11",
	    "stepOut": "Shift+F11"
	  },
	  "Darwin": {
	    "resume": "Cmd+\\",
	    "pause": "Cmd+\\",
	    "stepOver": "Cmd+'",
	    "stepIn": "Cmd+;",
	    "stepOut": "Cmd+Shift+:",
	    "stepOutDisplay": "Cmd+Shift+;"
	  },
	  "Linux": {
	    "resume": "F8",
	    "pause": "F8",
	    "stepOver": "F10",
	    "stepIn": "Ctrl+F11",
	    "stepOut": "Ctrl+Shift+F11"
	  }
	};
	
	function getKey(action) {
	  return getKeyForOS(appinfo.OS, action);
	}
	
	function getKeyForOS(os, action) {
	  return KEYS[os][action];
	}
	
	function formatKey(action) {
	  var key = getKey(`${ action }Display`) || getKey(action);
	  if (isMacOS) {
	    var winKey = getKeyForOS("WINNT", `${ action }Display`) || getKeyForOS("WINNT", action);
	    // display both Windows type and Mac specific keys
	    return formatKeyShortcut([key, winKey].join(" "));
	  }
	  return formatKeyShortcut(key);
	}
	
	function handlePressAnimation(button) {
	  if (!button) {
	    return;
	  }
	
	  button.style.opacity = "0";
	  button.style.transform = "scale(1.3)";
	  setTimeout(() => {
	    button.style.opacity = "1";
	    button.style.transform = "none";
	  }, 200);
	}
	
	function debugBtn(onClick, type, className, tooltip) {
	  className = `${ type } ${ className }`;
	  return dom.span({
	    onClick,
	    className,
	    key: type
	  }, Svg(type, { title: tooltip }));
	}
	
	var CommandBar = React.createClass({
	  propTypes: {
	    sources: PropTypes.object,
	    selectedSource: PropTypes.object,
	    resume: PropTypes.func,
	    stepIn: PropTypes.func,
	    stepOut: PropTypes.func,
	    stepOver: PropTypes.func,
	    breakOnNext: PropTypes.func,
	    pause: ImPropTypes.map,
	    pauseOnExceptions: PropTypes.func,
	    shouldPauseOnExceptions: PropTypes.bool,
	    shouldIgnoreCaughtExceptions: PropTypes.bool,
	    isWaitingOnBreak: PropTypes.bool
	  },
	
	  contextTypes: {
	    shortcuts: PropTypes.object
	  },
	
	  displayName: "CommandBar",
	
	  componentWillUnmount() {
	    var shortcuts = this.context.shortcuts;
	    COMMANDS.forEach(action => shortcuts.off(getKey(action)));
	    if (isMacOS) {
	      COMMANDS.forEach(action => shortcuts.off(getKeyForOS("WINNT", action)));
	    }
	  },
	
	  componentDidMount() {
	    var shortcuts = this.context.shortcuts;
	
	    COMMANDS.forEach(action => shortcuts.on(getKey(action), (_, e) => this.handleEvent(e, action)));
	
	    if (isMacOS) {
	      // The Mac supports both the Windows Function keys
	      // as well as the Mac non-Function keys
	      COMMANDS.forEach(action => shortcuts.on(getKeyForOS("WINNT", action), (_, e) => this.handleEvent(e, action)));
	    }
	  },
	
	  handleEvent(e, action) {
	    e.preventDefault();
	    e.stopPropagation();
	
	    this.props[action]();
	    var button = findDOMNode(this).querySelector(`.${ action }`);
	    handlePressAnimation(button);
	  },
	
	  renderStepButtons() {
	    var className = this.props.pause ? "active" : "disabled";
	    return [debugBtn(this.props.stepOver, "stepOver", className, L10N.getFormatStr("stepOverTooltip", formatKey("stepOver"))), debugBtn(this.props.stepIn, "stepIn", className, L10N.getFormatStr("stepInTooltip", formatKey("stepIn"))), debugBtn(this.props.stepOut, "stepOut", className, L10N.getFormatStr("stepOutTooltip", formatKey("stepOut")))];
	  },
	
	  renderPauseButton() {
	    var _props = this.props,
	        pause = _props.pause,
	        breakOnNext = _props.breakOnNext,
	        isWaitingOnBreak = _props.isWaitingOnBreak;
	
	
	    if (pause) {
	      return debugBtn(this.props.resume, "resume", "active", L10N.getFormatStr("resumeButtonTooltip", formatKey("resume")));
	    }
	
	    if (isWaitingOnBreak) {
	      return debugBtn(null, "pause", "disabled", L10N.getStr("pausePendingButtonTooltip"));
	    }
	
	    return debugBtn(breakOnNext, "pause", "active", L10N.getFormatStr("pauseButtonTooltip", formatKey("pause")));
	  },
	
	  /*
	   * The pause on exception button has three states in this order:
	   *  1. don't pause on exceptions      [false, false]
	   *  2. pause on uncaught exceptions   [true, true]
	   *  3. pause on all exceptions        [true, false]
	  */
	  renderPauseOnExceptions() {
	    var _props2 = this.props,
	        shouldPauseOnExceptions = _props2.shouldPauseOnExceptions,
	        shouldIgnoreCaughtExceptions = _props2.shouldIgnoreCaughtExceptions,
	        pauseOnExceptions = _props2.pauseOnExceptions;
	
	
	    if (!shouldPauseOnExceptions && !shouldIgnoreCaughtExceptions) {
	      return debugBtn(() => pauseOnExceptions(true, true), "pause-exceptions", "enabled", L10N.getStr("ignoreExceptions"));
	    }
	
	    if (shouldPauseOnExceptions && shouldIgnoreCaughtExceptions) {
	      return debugBtn(() => pauseOnExceptions(true, false), "pause-exceptions", "uncaught enabled", L10N.getStr("pauseOnUncaughtExceptions"));
	    }
	
	    return debugBtn(() => pauseOnExceptions(false, false), "pause-exceptions", "all enabled", L10N.getStr("pauseOnExceptions"));
	  },
	
	  render() {
	    return dom.div({ className: "command-bar" }, this.renderPauseButton(), this.renderStepButtons(), this.renderPauseOnExceptions());
	  }
	});
	
	module.exports = connect(state => {
	  return {
	    pause: getPause(state),
	    isWaitingOnBreak: getIsWaitingOnBreak(state),
	    shouldPauseOnExceptions: getShouldPauseOnExceptions(state),
	    shouldIgnoreCaughtExceptions: getShouldIgnoreCaughtExceptions(state)
	  };
	}, dispatch => bindActionCreators(actions, dispatch))(CommandBar);

/***/ },
/* 623 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 624 */,
/* 625 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 626 */,
/* 627 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	var dom = React.DOM,
	    PropTypes = React.PropTypes,
	    createFactory = React.createFactory;
	
	var _require = __webpack_require__(305),
	    connect = _require.connect;
	
	var _require2 = __webpack_require__(3),
	    bindActionCreators = _require2.bindActionCreators;
	
	var actions = __webpack_require__(314);
	
	var _require3 = __webpack_require__(303),
	    getPaneCollapse = _require3.getPaneCollapse;
	
	var _require4 = __webpack_require__(451),
	    formatKeyShortcut = _require4.formatKeyShortcut;
	
	var PaneToggleButton = createFactory(__webpack_require__(530));
	
	__webpack_require__(628);
	
	var WelcomeBox = React.createClass({
	  propTypes: {
	    horizontal: PropTypes.bool,
	    togglePaneCollapse: PropTypes.func,
	    endPanelCollapsed: PropTypes.bool
	  },
	
	  displayName: "WelcomeBox",
	
	  renderToggleButton() {
	    if (this.props.horizontal) {
	      return;
	    }
	
	    return PaneToggleButton({
	      position: "end",
	      collapsed: !this.props.endPanelCollapsed,
	      horizontal: this.props.horizontal,
	      handleClick: this.props.togglePaneCollapse
	    });
	  },
	
	  render() {
	    var searchLabel = L10N.getFormatStr("welcome.search", formatKeyShortcut(`CmdOrCtrl+${ L10N.getStr("sources.search.key") }`));
	    return dom.div({ className: "welcomebox" }, searchLabel, this.renderToggleButton());
	  }
	});
	
	module.exports = connect(state => ({
	  endPanelCollapsed: getPaneCollapse(state, "end")
	}), dispatch => bindActionCreators(actions, dispatch))(WelcomeBox);

/***/ },
/* 628 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 629 */,
/* 630 */
/***/ function(module, exports, __webpack_require__) {

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	var React = __webpack_require__(2);
	var dom = React.DOM,
	    PropTypes = React.PropTypes;
	
	var ImPropTypes = __webpack_require__(450);
	
	var _require = __webpack_require__(305),
	    connect = _require.connect;
	
	var _require2 = __webpack_require__(3),
	    bindActionCreators = _require2.bindActionCreators;
	
	var _require3 = __webpack_require__(303),
	    getSelectedSource = _require3.getSelectedSource,
	    getSourceTabs = _require3.getSourceTabs,
	    getFileSearchState = _require3.getFileSearchState,
	    getSourceByURL = _require3.getSourceByURL;
	
	var _require4 = __webpack_require__(295),
	    getFilename = _require4.getFilename,
	    isPretty = _require4.isPretty;
	
	var classnames = __webpack_require__(413);
	var actions = __webpack_require__(314);
	var CloseButton = __webpack_require__(444);
	var PaneToggleButton = React.createFactory(__webpack_require__(530));
	var Svg = __webpack_require__(414);
	var Dropdown = React.createFactory(__webpack_require__(631));
	
	var _require5 = __webpack_require__(544),
	    showMenu = _require5.showMenu,
	    buildMenu = _require5.buildMenu;
	
	var debounce = __webpack_require__(536);
	
	var _require6 = __webpack_require__(451),
	    formatKeyShortcut = _require6.formatKeyShortcut;
	
	__webpack_require__(634);
	
	/*
	 * Finds the hidden tabs by comparing the tabs' top offset.
	 * hidden tabs will have a great top offset.
	 *
	 * @param sourceTabs Immutable.list
	 * @param sourceTabEls HTMLCollection
	 *
	 * @returns Immutable.list
	 */
	function getHiddenTabs(sourceTabs, sourceTabEls) {
	  sourceTabEls = [].slice.call(sourceTabEls);
	  function getTopOffset() {
	    var topOffsets = sourceTabEls.map(t => t.getBoundingClientRect().top);
	    return Math.min.apply(Math, _toConsumableArray(topOffsets));
	  }
	
	  var tabTopOffset = getTopOffset();
	  return sourceTabs.filter((tab, index) => {
	    return sourceTabEls[index].getBoundingClientRect().top > tabTopOffset;
	  });
	}
	
	/**
	 * Clipboard function taken from
	 * https://dxr.mozilla.org/mozilla-central/source/devtools/shared/platform/content/clipboard.js
	 */
	function copyToTheClipboard(string) {
	  var doCopy = function (e) {
	    e.clipboardData.setData("text/plain", string);
	    e.preventDefault();
	  };
	
	  document.addEventListener("copy", doCopy);
	  document.execCommand("copy", false, null);
	  document.removeEventListener("copy", doCopy);
	}
	
	var SourceTabs = React.createClass({
	  propTypes: {
	    sourceTabs: ImPropTypes.list,
	    selectedSource: ImPropTypes.map,
	    selectSource: PropTypes.func.isRequired,
	    closeTab: PropTypes.func.isRequired,
	    closeTabs: PropTypes.func.isRequired,
	    toggleFileSearch: PropTypes.func.isRequired,
	    togglePrettyPrint: PropTypes.func.isRequired,
	    togglePaneCollapse: PropTypes.func.isRequired,
	    showSource: PropTypes.func.isRequired,
	    horizontal: PropTypes.bool.isRequired,
	    startPanelCollapsed: PropTypes.bool.isRequired,
	    endPanelCollapsed: PropTypes.bool.isRequired
	  },
	
	  displayName: "SourceTabs",
	
	  getInitialState() {
	    return {
	      dropdownShown: false,
	      hiddenSourceTabs: null
	    };
	  },
	
	  componentDidUpdate(prevProps) {
	    if (!(prevProps === this.props)) {
	      this.updateHiddenSourceTabs();
	    }
	  },
	
	  componentDidMount() {
	    this.updateHiddenSourceTabs();
	    window.addEventListener("resize", this.onResize);
	  },
	
	  componentWillUnmount() {
	    window.removeEventListener("resize", this.onResize);
	  },
	
	  onTabContextMenu(event, tab) {
	    event.preventDefault();
	    this.showContextMenu(event, tab);
	  },
	
	  showContextMenu(e, tab) {
	    var _props = this.props,
	        closeTab = _props.closeTab,
	        closeTabs = _props.closeTabs,
	        sourceTabs = _props.sourceTabs,
	        showSource = _props.showSource,
	        togglePrettyPrint = _props.togglePrettyPrint;
	
	
	    var closeTabLabel = L10N.getStr("sourceTabs.closeTab");
	    var closeOtherTabsLabel = L10N.getStr("sourceTabs.closeOtherTabs");
	    var closeTabsToRightLabel = L10N.getStr("sourceTabs.closeTabsToRight");
	    var closeAllTabsLabel = L10N.getStr("sourceTabs.closeAllTabs");
	
	    var tabs = sourceTabs.map(t => t.get("id"));
	    var otherTabs = sourceTabs.filter(t => t.get("id") !== tab);
	    var sourceTab = sourceTabs.find(t => t.get("id") == tab);
	    var tabURLs = sourceTabs.map(thisTab => thisTab.get("url"));
	    var otherTabURLs = otherTabs.map(thisTab => thisTab.get("url"));
	    var isPrettySource = isPretty({ url: sourceTab.get("url") });
	
	    var closeTabMenuItem = {
	      id: "node-menu-close-tab",
	      label: closeTabLabel,
	      accesskey: "C",
	      disabled: false,
	      click: () => closeTab(sourceTab.get("url"))
	    };
	
	    var closeOtherTabsMenuItem = {
	      id: "node-menu-close-other-tabs",
	      label: closeOtherTabsLabel,
	      accesskey: "O",
	      disabled: false,
	      click: () => closeTabs(otherTabURLs)
	    };
	
	    var closeTabsToRightMenuItem = {
	      id: "node-menu-close-tabs-to-right",
	      label: closeTabsToRightLabel,
	      accesskey: "R",
	      disabled: false,
	      click: () => {
	        var tabIndex = tabs.findIndex(t => t == tab);
	        closeTabs(tabURLs.filter((t, i) => i > tabIndex));
	      }
	    };
	
	    var closeAllTabsMenuItem = {
	      id: "node-menu-close-all-tabs",
	      label: closeAllTabsLabel,
	      accesskey: "A",
	      disabled: false,
	      click: () => closeTabs(tabURLs)
	    };
	
	    var showSourceMenuItem = {
	      id: "node-menu-show-source",
	      label: "Reveal in Tree",
	      accesskey: "s",
	      disabled: false,
	      click: () => showSource(tab)
	    };
	
	    var copySourceUrl = {
	      id: "node-menu-close-tabs-to-right",
	      label: "Copy Link Address",
	      accesskey: "X",
	      disabled: false,
	      click: () => copyToTheClipboard(sourceTab.get("url"))
	    };
	
	    var prettyPrint = {
	      id: "node-menu-pretty-print",
	      label: "Pretty Print Source",
	      accesskey: "Z",
	      disabled: false,
	      click: () => togglePrettyPrint(sourceTab.get("id"))
	    };
	
	    var items = [{ item: closeTabMenuItem }, { item: closeOtherTabsMenuItem, hidden: () => tabs.size === 1 }, { item: closeTabsToRightMenuItem, hidden: () => tabs.some((t, i) => t === tab && tabs.size - 1 === i) }, { item: closeAllTabsMenuItem }, { item: { type: "separator" } }, { item: copySourceUrl }, { item: showSourceMenuItem }];
	
	    if (!isPrettySource) {
	      items.push({ item: prettyPrint });
	    }
	
	    showMenu(e, buildMenu(items));
	  },
	
	  onResize: debounce(function () {
	    this.updateHiddenSourceTabs();
	  }),
	
	  /*
	   * Updates the hiddenSourceTabs state, by
	   * finding the source tabs who have wrapped and are not on the top row.
	   */
	  updateHiddenSourceTabs() {
	    if (!this.refs.sourceTabs) {
	      return;
	    }
	
	    var sourceTabs = this.props.sourceTabs;
	    var sourceTabEls = this.refs.sourceTabs.children;
	    var hiddenSourceTabs = getHiddenTabs(sourceTabs, sourceTabEls);
	
	    this.setState({ hiddenSourceTabs });
	  },
	
	  toggleSourcesDropdown(e) {
	    this.setState({
	      dropdownShown: !this.state.dropdownShown
	    });
	  },
	
	  renderDropdownSource(source) {
	    var selectSource = this.props.selectSource;
	
	    var filename = getFilename(source.toJS());
	
	    return dom.li({
	      key: source.get("id"),
	      onClick: () => {
	        // const tabIndex = getLastVisibleTabIndex(sourceTabs, sourceTabEls);
	        var tabIndex = 0;
	        selectSource(source.get("id"), { tabIndex });
	      }
	    }, filename);
	  },
	
	  renderTabs() {
	    var sourceTabs = this.props.sourceTabs;
	    return dom.div({ className: "source-tabs", ref: "sourceTabs" }, sourceTabs.map(this.renderTab));
	  },
	
	  renderTab(source) {
	    var _props2 = this.props,
	        selectedSource = _props2.selectedSource,
	        selectSource = _props2.selectSource,
	        closeTab = _props2.closeTab;
	
	    var filename = getFilename(source.toJS());
	    var active = source.get("id") == selectedSource.get("id");
	    var isPrettyCode = isPretty({ url: source.get("url") });
	
	    function onClickClose(ev) {
	      ev.stopPropagation();
	      closeTab(source.get("url"));
	    }
	
	    return dom.div({
	      className: classnames("source-tab", {
	        active,
	        pretty: isPretty({ url: source.get("url") })
	      }),
	      key: source.get("id"),
	      onClick: () => selectSource(source.get("id")),
	      onContextMenu: e => this.onTabContextMenu(e, source.get("id")),
	      title: getFilename(source.toJS())
	    }, isPrettyCode ? Svg("prettyPrint") : null, dom.div({ className: "filename" }, filename), CloseButton({
	      handleClick: onClickClose,
	      tooltip: L10N.getStr("sourceTabs.closeTabButtonTooltip")
	    }));
	  },
	
	  renderNewButton() {
	    var newTabTooltip = L10N.getFormatStr("sourceTabs.newTabButtonTooltip", formatKeyShortcut(`CmdOrCtrl+${ L10N.getStr("sources.search.key") }`));
	    return dom.div({
	      className: "new-tab-btn",
	      onClick: () => this.props.toggleFileSearch(true),
	      title: newTabTooltip
	    }, Svg("plus"));
	  },
	
	  renderDropdown() {
	    var hiddenSourceTabs = this.state.hiddenSourceTabs;
	    if (!hiddenSourceTabs || hiddenSourceTabs.size == 0) {
	      return dom.div({});
	    }
	
	    return Dropdown({
	      panel: dom.ul({}, this.state.hiddenSourceTabs.map(this.renderDropdownSource))
	    });
	  },
	
	  renderStartPanelToggleButton() {
	    return PaneToggleButton({
	      position: "start",
	      collapsed: !this.props.startPanelCollapsed,
	      handleClick: this.props.togglePaneCollapse
	    });
	  },
	
	  renderEndPanelToggleButton() {
	    if (!this.props.horizontal) {
	      return;
	    }
	
	    return PaneToggleButton({
	      position: "end",
	      collapsed: !this.props.endPanelCollapsed,
	      handleClick: this.props.togglePaneCollapse,
	      horizontal: this.props.horizontal
	    });
	  },
	
	  render() {
	    return dom.div({ className: "source-header" }, this.renderStartPanelToggleButton(), this.renderTabs(), this.renderNewButton(), this.renderDropdown(), this.renderEndPanelToggleButton());
	  }
	});
	
	function getTabs(state) {
	  return getSourceTabs(state).map(url => getSourceByURL(state, url));
	}
	
	module.exports = connect(state => {
	  return {
	    selectedSource: getSelectedSource(state),
	    sourceTabs: getTabs(state),
	    searchOn: getFileSearchState(state)
	  };
	}, dispatch => bindActionCreators(actions, dispatch))(SourceTabs);

/***/ },
/* 631 */
/***/ function(module, exports, __webpack_require__) {

	var React = __webpack_require__(2);
	var dom = React.DOM,
	    PropTypes = React.PropTypes;
	
	__webpack_require__(632);
	
	var Dropdown = React.createClass({
	  propTypes: {
	    panel: PropTypes.object
	  },
	
	  displayName: "Dropdown",
	
	  getInitialState() {
	    return {
	      dropdownShown: false
	    };
	  },
	
	  toggleDropdown(e) {
	    this.setState({
	      dropdownShown: !this.state.dropdownShown
	    });
	  },
	
	  renderPanel() {
	    return dom.div({
	      className: "dropdown",
	      onClick: this.toggleDropdown,
	      style: { display: this.state.dropdownShown ? "block" : "none" }
	    }, this.props.panel);
	  },
	
	  renderButton() {
	    return dom.button({
	      className: "dropdown-button",
	      onClick: this.toggleDropdown
	    }, "»");
	  },
	
	  renderMask() {
	    return dom.div({
	      className: "dropdown-mask",
	      onClick: this.toggleDropdown,
	      style: { display: this.state.dropdownShown ? "block" : "none" }
	    });
	  },
	
	  render() {
	    return dom.div({}, this.renderPanel(), this.renderButton(), this.renderMask());
	  }
	
	});
	
	module.exports = Dropdown;

/***/ },
/* 632 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 633 */,
/* 634 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 635 */,
/* 636 */
/***/ function(module, exports) {

	module.exports = {
		"breakpoints.header": "Breakpoints",
		"breakpoints.none": "No Breakpoints",
		"breakpoints.enable": "Enable Breakpoints",
		"breakpoints.disable": "Disable Breakpoints",
		"breakpoints.removeBreakpointTooltip": "Remove Breakpoint",
		"callStack.header": "Call Stack",
		"callStack.notPaused": "Not Paused",
		"callStack.collapse": "Collapse Rows",
		"callStack.expand": "Expand Rows",
		"editor.searchResults": "%d of %d results",
		"editor.noResults": "no results",
		"editor.addBreakpoint": "Add Breakpoint",
		"editor.disableBreakpoint": "Disable Breakpoint",
		"editor.enableBreakpoint": "Enable Breakpoint",
		"editor.removeBreakpoint": "Remove Breakpoint",
		"editor.editBreakpoint": "Edit Breakpoint",
		"editor.addConditionalBreakpoint": "Add Conditional Breakpoint",
		"editor.conditionalPanel.placeholder": "This breakpoint will pause when the expression is true",
		"editor.jumpToMappedLocation1": "Jump to %S location",
		"generated": "generated",
		"original": "original",
		"eventListenersHeader": "Event Listeners",
		"expressions.placeholder": "Add Watch Expression",
		"scopes.header": "Scopes",
		"scopes.notAvailable": "Scopes Unavailable",
		"scopes.block": "Block",
		"scopes.notPaused": "Not Paused",
		"sources.header": "Sources",
		"sources.search": "%S to search",
		"sources.search.key": "P",
		"watchExpressions.header": "Watch Expressions",
		"watchExpressions.refreshButton": "Refresh",
		"welcome.search": "%S to search for sources",
		"sourceSearch.search": "Search Sources...",
		"sourceSearch.search.key": "F",
		"sourceSearch.search.again.key": "G",
		"sourceSearch.resultsSummary": "%d instances of \"%S\"",
		"sourceSearch.noResults": "No files matching %S found",
		"sourceFooter.debugBtnTooltip": "Prettify Source",
		"ignoreExceptions": "Ignore exceptions. Click to pause on uncaught exceptions",
		"pauseOnUncaughtExceptions": "Pause on uncaught exceptions. Click to pause on all exceptions",
		"pauseOnExceptions": "Pause on all exceptions. Click to ignore exceptions",
		"stepOutTooltip": "Step Out %S",
		"stepInTooltip": "Step In %S",
		"stepOverTooltip": "Step Over %S",
		"resumeButtonTooltip": "Resume %S",
		"pausePendingButtonTooltip": "Waiting for next execution",
		"pauseButtonTooltip": "Pause %S",
		"sourceTabs.closeTab": "Close tab",
		"sourceTabs.closeOtherTabs": "Close others",
		"sourceTabs.closeTabsToRight": "Close tabs to the right",
		"sourceTabs.closeAllTabs": "Close all tabs",
		"sourceTabs.closeTabButtonTooltip": "Close tab",
		"sourceTabs.newTabButtonTooltip": "Search for sources (%S)",
		"loadingText": "Loading…",
		"whyPaused.debuggerStatement": "Paused on debugger statement",
		"whyPaused.breakpoint": "Paused on breakpoint",
		"whyPaused.exception": "Paused on exception",
		"whyPaused.resumeLimit": "Paused while stepping",
		"whyPaused.pauseOnDOMEvents": "Paused on event listener",
		"whyPaused.breakpointConditionThrown": "Error with conditional breakpoint",
		"whyPaused.xhr": "Paused on XMLHttpRequest",
		"whyPaused.promiseRejection": "Paused on promise rejection",
		"whyPaused.assert": "Paused on assertion",
		"whyPaused.debugCommand": "Paused on debugged function",
		"whyPaused.other": "Debugger paused",
		"collapsePanes": "Collapse panes",
		"expandPanes": "Expand panes"
	};

/***/ }
/******/ ]);
//# sourceMappingURL=debugger.js.map
