(function (factory) {
    typeof define === 'function' && define.amd ? define(factory) :
    factory();
})((function () { 'use strict';

    (function() {
        const env = {"NODE_ENV":"production"};
        try {
            if (process) {
                process.env = Object.assign({}, process.env);
                Object.assign(process.env, env);
                return;
            }
        } catch (e) {} // avoid ReferenceError: process is not defined
        globalThis.process = { env:env };
    })();

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    var lib$4 = {};

    var isReactComponent$1 = {};

    var buildMatchMemberExpression = {};

    var matchesPattern = {};

    var generated$3 = {};

    var shallowEqual = {};

    var hasRequiredShallowEqual;

    function requireShallowEqual () {
    	if (hasRequiredShallowEqual) return shallowEqual;
    	hasRequiredShallowEqual = 1;

    	Object.defineProperty(shallowEqual, "__esModule", {
    	  value: true
    	});
    	shallowEqual.default = shallowEqual$1;
    	function shallowEqual$1(actual, expected) {
    	  const keys = Object.keys(expected);
    	  for (const key of keys) {
    	    if (actual[key] !== expected[key]) {
    	      return false;
    	    }
    	  }
    	  return true;
    	}

    	
    	return shallowEqual;
    }

    var deprecationWarning = {};

    var hasRequiredDeprecationWarning;

    function requireDeprecationWarning () {
    	if (hasRequiredDeprecationWarning) return deprecationWarning;
    	hasRequiredDeprecationWarning = 1;

    	Object.defineProperty(deprecationWarning, "__esModule", {
    	  value: true
    	});
    	deprecationWarning.default = deprecationWarning$1;
    	const warnings = new Set();
    	function deprecationWarning$1(oldName, newName, prefix = "") {
    	  if (warnings.has(oldName)) return;
    	  warnings.add(oldName);
    	  const {
    	    internal,
    	    trace
    	  } = captureShortStackTrace(1, 2);
    	  if (internal) {
    	    return;
    	  }
    	  console.warn(`${prefix}\`${oldName}\` has been deprecated, please migrate to \`${newName}\`\n${trace}`);
    	}
    	function captureShortStackTrace(skip, length) {
    	  const {
    	    stackTraceLimit,
    	    prepareStackTrace
    	  } = Error;
    	  let stackTrace;
    	  Error.stackTraceLimit = 1 + skip + length;
    	  Error.prepareStackTrace = function (err, stack) {
    	    stackTrace = stack;
    	  };
    	  new Error().stack;
    	  Error.stackTraceLimit = stackTraceLimit;
    	  Error.prepareStackTrace = prepareStackTrace;
    	  if (!stackTrace) return {
    	    internal: false,
    	    trace: ""
    	  };
    	  const shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);
    	  return {
    	    internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
    	    trace: shortStackTrace.map(frame => `    at ${frame}`).join("\n")
    	  };
    	}

    	
    	return deprecationWarning;
    }

    var hasRequiredGenerated$3;

    function requireGenerated$3 () {
    	if (hasRequiredGenerated$3) return generated$3;
    	hasRequiredGenerated$3 = 1;

    	Object.defineProperty(generated$3, "__esModule", {
    	  value: true
    	});
    	generated$3.isAccessor = isAccessor;
    	generated$3.isAnyTypeAnnotation = isAnyTypeAnnotation;
    	generated$3.isArgumentPlaceholder = isArgumentPlaceholder;
    	generated$3.isArrayExpression = isArrayExpression;
    	generated$3.isArrayPattern = isArrayPattern;
    	generated$3.isArrayTypeAnnotation = isArrayTypeAnnotation;
    	generated$3.isArrowFunctionExpression = isArrowFunctionExpression;
    	generated$3.isAssignmentExpression = isAssignmentExpression;
    	generated$3.isAssignmentPattern = isAssignmentPattern;
    	generated$3.isAwaitExpression = isAwaitExpression;
    	generated$3.isBigIntLiteral = isBigIntLiteral;
    	generated$3.isBinary = isBinary;
    	generated$3.isBinaryExpression = isBinaryExpression;
    	generated$3.isBindExpression = isBindExpression;
    	generated$3.isBlock = isBlock;
    	generated$3.isBlockParent = isBlockParent;
    	generated$3.isBlockStatement = isBlockStatement;
    	generated$3.isBooleanLiteral = isBooleanLiteral;
    	generated$3.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
    	generated$3.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
    	generated$3.isBreakStatement = isBreakStatement;
    	generated$3.isCallExpression = isCallExpression;
    	generated$3.isCatchClause = isCatchClause;
    	generated$3.isClass = isClass;
    	generated$3.isClassAccessorProperty = isClassAccessorProperty;
    	generated$3.isClassBody = isClassBody;
    	generated$3.isClassDeclaration = isClassDeclaration;
    	generated$3.isClassExpression = isClassExpression;
    	generated$3.isClassImplements = isClassImplements;
    	generated$3.isClassMethod = isClassMethod;
    	generated$3.isClassPrivateMethod = isClassPrivateMethod;
    	generated$3.isClassPrivateProperty = isClassPrivateProperty;
    	generated$3.isClassProperty = isClassProperty;
    	generated$3.isCompletionStatement = isCompletionStatement;
    	generated$3.isConditional = isConditional;
    	generated$3.isConditionalExpression = isConditionalExpression;
    	generated$3.isContinueStatement = isContinueStatement;
    	generated$3.isDebuggerStatement = isDebuggerStatement;
    	generated$3.isDecimalLiteral = isDecimalLiteral;
    	generated$3.isDeclaration = isDeclaration;
    	generated$3.isDeclareClass = isDeclareClass;
    	generated$3.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
    	generated$3.isDeclareExportDeclaration = isDeclareExportDeclaration;
    	generated$3.isDeclareFunction = isDeclareFunction;
    	generated$3.isDeclareInterface = isDeclareInterface;
    	generated$3.isDeclareModule = isDeclareModule;
    	generated$3.isDeclareModuleExports = isDeclareModuleExports;
    	generated$3.isDeclareOpaqueType = isDeclareOpaqueType;
    	generated$3.isDeclareTypeAlias = isDeclareTypeAlias;
    	generated$3.isDeclareVariable = isDeclareVariable;
    	generated$3.isDeclaredPredicate = isDeclaredPredicate;
    	generated$3.isDecorator = isDecorator;
    	generated$3.isDirective = isDirective;
    	generated$3.isDirectiveLiteral = isDirectiveLiteral;
    	generated$3.isDoExpression = isDoExpression;
    	generated$3.isDoWhileStatement = isDoWhileStatement;
    	generated$3.isEmptyStatement = isEmptyStatement;
    	generated$3.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
    	generated$3.isEnumBody = isEnumBody;
    	generated$3.isEnumBooleanBody = isEnumBooleanBody;
    	generated$3.isEnumBooleanMember = isEnumBooleanMember;
    	generated$3.isEnumDeclaration = isEnumDeclaration;
    	generated$3.isEnumDefaultedMember = isEnumDefaultedMember;
    	generated$3.isEnumMember = isEnumMember;
    	generated$3.isEnumNumberBody = isEnumNumberBody;
    	generated$3.isEnumNumberMember = isEnumNumberMember;
    	generated$3.isEnumStringBody = isEnumStringBody;
    	generated$3.isEnumStringMember = isEnumStringMember;
    	generated$3.isEnumSymbolBody = isEnumSymbolBody;
    	generated$3.isExistsTypeAnnotation = isExistsTypeAnnotation;
    	generated$3.isExportAllDeclaration = isExportAllDeclaration;
    	generated$3.isExportDeclaration = isExportDeclaration;
    	generated$3.isExportDefaultDeclaration = isExportDefaultDeclaration;
    	generated$3.isExportDefaultSpecifier = isExportDefaultSpecifier;
    	generated$3.isExportNamedDeclaration = isExportNamedDeclaration;
    	generated$3.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
    	generated$3.isExportSpecifier = isExportSpecifier;
    	generated$3.isExpression = isExpression;
    	generated$3.isExpressionStatement = isExpressionStatement;
    	generated$3.isExpressionWrapper = isExpressionWrapper;
    	generated$3.isFile = isFile;
    	generated$3.isFlow = isFlow;
    	generated$3.isFlowBaseAnnotation = isFlowBaseAnnotation;
    	generated$3.isFlowDeclaration = isFlowDeclaration;
    	generated$3.isFlowPredicate = isFlowPredicate;
    	generated$3.isFlowType = isFlowType;
    	generated$3.isFor = isFor;
    	generated$3.isForInStatement = isForInStatement;
    	generated$3.isForOfStatement = isForOfStatement;
    	generated$3.isForStatement = isForStatement;
    	generated$3.isForXStatement = isForXStatement;
    	generated$3.isFunction = isFunction;
    	generated$3.isFunctionDeclaration = isFunctionDeclaration;
    	generated$3.isFunctionExpression = isFunctionExpression;
    	generated$3.isFunctionParent = isFunctionParent;
    	generated$3.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
    	generated$3.isFunctionTypeParam = isFunctionTypeParam;
    	generated$3.isGenericTypeAnnotation = isGenericTypeAnnotation;
    	generated$3.isIdentifier = isIdentifier;
    	generated$3.isIfStatement = isIfStatement;
    	generated$3.isImmutable = isImmutable;
    	generated$3.isImport = isImport;
    	generated$3.isImportAttribute = isImportAttribute;
    	generated$3.isImportDeclaration = isImportDeclaration;
    	generated$3.isImportDefaultSpecifier = isImportDefaultSpecifier;
    	generated$3.isImportExpression = isImportExpression;
    	generated$3.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
    	generated$3.isImportOrExportDeclaration = isImportOrExportDeclaration;
    	generated$3.isImportSpecifier = isImportSpecifier;
    	generated$3.isIndexedAccessType = isIndexedAccessType;
    	generated$3.isInferredPredicate = isInferredPredicate;
    	generated$3.isInterfaceDeclaration = isInterfaceDeclaration;
    	generated$3.isInterfaceExtends = isInterfaceExtends;
    	generated$3.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
    	generated$3.isInterpreterDirective = isInterpreterDirective;
    	generated$3.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
    	generated$3.isJSX = isJSX;
    	generated$3.isJSXAttribute = isJSXAttribute;
    	generated$3.isJSXClosingElement = isJSXClosingElement;
    	generated$3.isJSXClosingFragment = isJSXClosingFragment;
    	generated$3.isJSXElement = isJSXElement;
    	generated$3.isJSXEmptyExpression = isJSXEmptyExpression;
    	generated$3.isJSXExpressionContainer = isJSXExpressionContainer;
    	generated$3.isJSXFragment = isJSXFragment;
    	generated$3.isJSXIdentifier = isJSXIdentifier;
    	generated$3.isJSXMemberExpression = isJSXMemberExpression;
    	generated$3.isJSXNamespacedName = isJSXNamespacedName;
    	generated$3.isJSXOpeningElement = isJSXOpeningElement;
    	generated$3.isJSXOpeningFragment = isJSXOpeningFragment;
    	generated$3.isJSXSpreadAttribute = isJSXSpreadAttribute;
    	generated$3.isJSXSpreadChild = isJSXSpreadChild;
    	generated$3.isJSXText = isJSXText;
    	generated$3.isLVal = isLVal;
    	generated$3.isLabeledStatement = isLabeledStatement;
    	generated$3.isLiteral = isLiteral;
    	generated$3.isLogicalExpression = isLogicalExpression;
    	generated$3.isLoop = isLoop;
    	generated$3.isMemberExpression = isMemberExpression;
    	generated$3.isMetaProperty = isMetaProperty;
    	generated$3.isMethod = isMethod;
    	generated$3.isMiscellaneous = isMiscellaneous;
    	generated$3.isMixedTypeAnnotation = isMixedTypeAnnotation;
    	generated$3.isModuleDeclaration = isModuleDeclaration;
    	generated$3.isModuleExpression = isModuleExpression;
    	generated$3.isModuleSpecifier = isModuleSpecifier;
    	generated$3.isNewExpression = isNewExpression;
    	generated$3.isNoop = isNoop;
    	generated$3.isNullLiteral = isNullLiteral;
    	generated$3.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
    	generated$3.isNullableTypeAnnotation = isNullableTypeAnnotation;
    	generated$3.isNumberLiteral = isNumberLiteral;
    	generated$3.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
    	generated$3.isNumberTypeAnnotation = isNumberTypeAnnotation;
    	generated$3.isNumericLiteral = isNumericLiteral;
    	generated$3.isObjectExpression = isObjectExpression;
    	generated$3.isObjectMember = isObjectMember;
    	generated$3.isObjectMethod = isObjectMethod;
    	generated$3.isObjectPattern = isObjectPattern;
    	generated$3.isObjectProperty = isObjectProperty;
    	generated$3.isObjectTypeAnnotation = isObjectTypeAnnotation;
    	generated$3.isObjectTypeCallProperty = isObjectTypeCallProperty;
    	generated$3.isObjectTypeIndexer = isObjectTypeIndexer;
    	generated$3.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
    	generated$3.isObjectTypeProperty = isObjectTypeProperty;
    	generated$3.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
    	generated$3.isOpaqueType = isOpaqueType;
    	generated$3.isOptionalCallExpression = isOptionalCallExpression;
    	generated$3.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
    	generated$3.isOptionalMemberExpression = isOptionalMemberExpression;
    	generated$3.isParenthesizedExpression = isParenthesizedExpression;
    	generated$3.isPattern = isPattern;
    	generated$3.isPatternLike = isPatternLike;
    	generated$3.isPipelineBareFunction = isPipelineBareFunction;
    	generated$3.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
    	generated$3.isPipelineTopicExpression = isPipelineTopicExpression;
    	generated$3.isPlaceholder = isPlaceholder;
    	generated$3.isPrivate = isPrivate;
    	generated$3.isPrivateName = isPrivateName;
    	generated$3.isProgram = isProgram;
    	generated$3.isProperty = isProperty;
    	generated$3.isPureish = isPureish;
    	generated$3.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
    	generated$3.isRecordExpression = isRecordExpression;
    	generated$3.isRegExpLiteral = isRegExpLiteral;
    	generated$3.isRegexLiteral = isRegexLiteral;
    	generated$3.isRestElement = isRestElement;
    	generated$3.isRestProperty = isRestProperty;
    	generated$3.isReturnStatement = isReturnStatement;
    	generated$3.isScopable = isScopable;
    	generated$3.isSequenceExpression = isSequenceExpression;
    	generated$3.isSpreadElement = isSpreadElement;
    	generated$3.isSpreadProperty = isSpreadProperty;
    	generated$3.isStandardized = isStandardized;
    	generated$3.isStatement = isStatement;
    	generated$3.isStaticBlock = isStaticBlock;
    	generated$3.isStringLiteral = isStringLiteral;
    	generated$3.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
    	generated$3.isStringTypeAnnotation = isStringTypeAnnotation;
    	generated$3.isSuper = isSuper;
    	generated$3.isSwitchCase = isSwitchCase;
    	generated$3.isSwitchStatement = isSwitchStatement;
    	generated$3.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
    	generated$3.isTSAnyKeyword = isTSAnyKeyword;
    	generated$3.isTSArrayType = isTSArrayType;
    	generated$3.isTSAsExpression = isTSAsExpression;
    	generated$3.isTSBaseType = isTSBaseType;
    	generated$3.isTSBigIntKeyword = isTSBigIntKeyword;
    	generated$3.isTSBooleanKeyword = isTSBooleanKeyword;
    	generated$3.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
    	generated$3.isTSConditionalType = isTSConditionalType;
    	generated$3.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
    	generated$3.isTSConstructorType = isTSConstructorType;
    	generated$3.isTSDeclareFunction = isTSDeclareFunction;
    	generated$3.isTSDeclareMethod = isTSDeclareMethod;
    	generated$3.isTSEntityName = isTSEntityName;
    	generated$3.isTSEnumDeclaration = isTSEnumDeclaration;
    	generated$3.isTSEnumMember = isTSEnumMember;
    	generated$3.isTSExportAssignment = isTSExportAssignment;
    	generated$3.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
    	generated$3.isTSExternalModuleReference = isTSExternalModuleReference;
    	generated$3.isTSFunctionType = isTSFunctionType;
    	generated$3.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
    	generated$3.isTSImportType = isTSImportType;
    	generated$3.isTSIndexSignature = isTSIndexSignature;
    	generated$3.isTSIndexedAccessType = isTSIndexedAccessType;
    	generated$3.isTSInferType = isTSInferType;
    	generated$3.isTSInstantiationExpression = isTSInstantiationExpression;
    	generated$3.isTSInterfaceBody = isTSInterfaceBody;
    	generated$3.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
    	generated$3.isTSIntersectionType = isTSIntersectionType;
    	generated$3.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
    	generated$3.isTSLiteralType = isTSLiteralType;
    	generated$3.isTSMappedType = isTSMappedType;
    	generated$3.isTSMethodSignature = isTSMethodSignature;
    	generated$3.isTSModuleBlock = isTSModuleBlock;
    	generated$3.isTSModuleDeclaration = isTSModuleDeclaration;
    	generated$3.isTSNamedTupleMember = isTSNamedTupleMember;
    	generated$3.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
    	generated$3.isTSNeverKeyword = isTSNeverKeyword;
    	generated$3.isTSNonNullExpression = isTSNonNullExpression;
    	generated$3.isTSNullKeyword = isTSNullKeyword;
    	generated$3.isTSNumberKeyword = isTSNumberKeyword;
    	generated$3.isTSObjectKeyword = isTSObjectKeyword;
    	generated$3.isTSOptionalType = isTSOptionalType;
    	generated$3.isTSParameterProperty = isTSParameterProperty;
    	generated$3.isTSParenthesizedType = isTSParenthesizedType;
    	generated$3.isTSPropertySignature = isTSPropertySignature;
    	generated$3.isTSQualifiedName = isTSQualifiedName;
    	generated$3.isTSRestType = isTSRestType;
    	generated$3.isTSSatisfiesExpression = isTSSatisfiesExpression;
    	generated$3.isTSStringKeyword = isTSStringKeyword;
    	generated$3.isTSSymbolKeyword = isTSSymbolKeyword;
    	generated$3.isTSThisType = isTSThisType;
    	generated$3.isTSTupleType = isTSTupleType;
    	generated$3.isTSType = isTSType;
    	generated$3.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
    	generated$3.isTSTypeAnnotation = isTSTypeAnnotation;
    	generated$3.isTSTypeAssertion = isTSTypeAssertion;
    	generated$3.isTSTypeElement = isTSTypeElement;
    	generated$3.isTSTypeLiteral = isTSTypeLiteral;
    	generated$3.isTSTypeOperator = isTSTypeOperator;
    	generated$3.isTSTypeParameter = isTSTypeParameter;
    	generated$3.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
    	generated$3.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
    	generated$3.isTSTypePredicate = isTSTypePredicate;
    	generated$3.isTSTypeQuery = isTSTypeQuery;
    	generated$3.isTSTypeReference = isTSTypeReference;
    	generated$3.isTSUndefinedKeyword = isTSUndefinedKeyword;
    	generated$3.isTSUnionType = isTSUnionType;
    	generated$3.isTSUnknownKeyword = isTSUnknownKeyword;
    	generated$3.isTSVoidKeyword = isTSVoidKeyword;
    	generated$3.isTaggedTemplateExpression = isTaggedTemplateExpression;
    	generated$3.isTemplateElement = isTemplateElement;
    	generated$3.isTemplateLiteral = isTemplateLiteral;
    	generated$3.isTerminatorless = isTerminatorless;
    	generated$3.isThisExpression = isThisExpression;
    	generated$3.isThisTypeAnnotation = isThisTypeAnnotation;
    	generated$3.isThrowStatement = isThrowStatement;
    	generated$3.isTopicReference = isTopicReference;
    	generated$3.isTryStatement = isTryStatement;
    	generated$3.isTupleExpression = isTupleExpression;
    	generated$3.isTupleTypeAnnotation = isTupleTypeAnnotation;
    	generated$3.isTypeAlias = isTypeAlias;
    	generated$3.isTypeAnnotation = isTypeAnnotation;
    	generated$3.isTypeCastExpression = isTypeCastExpression;
    	generated$3.isTypeParameter = isTypeParameter;
    	generated$3.isTypeParameterDeclaration = isTypeParameterDeclaration;
    	generated$3.isTypeParameterInstantiation = isTypeParameterInstantiation;
    	generated$3.isTypeScript = isTypeScript;
    	generated$3.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
    	generated$3.isUnaryExpression = isUnaryExpression;
    	generated$3.isUnaryLike = isUnaryLike;
    	generated$3.isUnionTypeAnnotation = isUnionTypeAnnotation;
    	generated$3.isUpdateExpression = isUpdateExpression;
    	generated$3.isUserWhitespacable = isUserWhitespacable;
    	generated$3.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
    	generated$3.isVariableDeclaration = isVariableDeclaration;
    	generated$3.isVariableDeclarator = isVariableDeclarator;
    	generated$3.isVariance = isVariance;
    	generated$3.isVoidTypeAnnotation = isVoidTypeAnnotation;
    	generated$3.isWhile = isWhile;
    	generated$3.isWhileStatement = isWhileStatement;
    	generated$3.isWithStatement = isWithStatement;
    	generated$3.isYieldExpression = isYieldExpression;
    	var _shallowEqual = requireShallowEqual();
    	var _deprecationWarning = requireDeprecationWarning();
    	function isArrayExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ArrayExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isAssignmentExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "AssignmentExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isBinaryExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "BinaryExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isInterpreterDirective(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "InterpreterDirective") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isDirective(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "Directive") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isDirectiveLiteral(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "DirectiveLiteral") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isBlockStatement(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "BlockStatement") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isBreakStatement(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "BreakStatement") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isCallExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "CallExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isCatchClause(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "CatchClause") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isConditionalExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ConditionalExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isContinueStatement(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ContinueStatement") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isDebuggerStatement(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "DebuggerStatement") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isDoWhileStatement(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "DoWhileStatement") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isEmptyStatement(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "EmptyStatement") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isExpressionStatement(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ExpressionStatement") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isFile(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "File") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isForInStatement(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ForInStatement") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isForStatement(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ForStatement") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isFunctionDeclaration(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "FunctionDeclaration") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isFunctionExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "FunctionExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isIdentifier(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "Identifier") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isIfStatement(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "IfStatement") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isLabeledStatement(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "LabeledStatement") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isStringLiteral(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "StringLiteral") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isNumericLiteral(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "NumericLiteral") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isNullLiteral(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "NullLiteral") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isBooleanLiteral(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "BooleanLiteral") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isRegExpLiteral(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "RegExpLiteral") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isLogicalExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "LogicalExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isMemberExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "MemberExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isNewExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "NewExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isProgram(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "Program") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isObjectExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ObjectExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isObjectMethod(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ObjectMethod") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isObjectProperty(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ObjectProperty") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isRestElement(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "RestElement") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isReturnStatement(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ReturnStatement") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isSequenceExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "SequenceExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isParenthesizedExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ParenthesizedExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isSwitchCase(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "SwitchCase") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isSwitchStatement(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "SwitchStatement") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isThisExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ThisExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isThrowStatement(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ThrowStatement") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTryStatement(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TryStatement") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isUnaryExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "UnaryExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isUpdateExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "UpdateExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isVariableDeclaration(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "VariableDeclaration") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isVariableDeclarator(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "VariableDeclarator") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isWhileStatement(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "WhileStatement") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isWithStatement(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "WithStatement") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isAssignmentPattern(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "AssignmentPattern") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isArrayPattern(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ArrayPattern") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isArrowFunctionExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ArrowFunctionExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isClassBody(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ClassBody") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isClassExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ClassExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isClassDeclaration(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ClassDeclaration") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isExportAllDeclaration(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ExportAllDeclaration") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isExportDefaultDeclaration(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ExportDefaultDeclaration") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isExportNamedDeclaration(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ExportNamedDeclaration") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isExportSpecifier(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ExportSpecifier") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isForOfStatement(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ForOfStatement") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isImportDeclaration(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ImportDeclaration") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isImportDefaultSpecifier(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ImportDefaultSpecifier") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isImportNamespaceSpecifier(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ImportNamespaceSpecifier") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isImportSpecifier(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ImportSpecifier") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isImportExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ImportExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isMetaProperty(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "MetaProperty") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isClassMethod(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ClassMethod") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isObjectPattern(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ObjectPattern") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isSpreadElement(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "SpreadElement") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isSuper(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "Super") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTaggedTemplateExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TaggedTemplateExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTemplateElement(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TemplateElement") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTemplateLiteral(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TemplateLiteral") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isYieldExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "YieldExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isAwaitExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "AwaitExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isImport(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "Import") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isBigIntLiteral(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "BigIntLiteral") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isExportNamespaceSpecifier(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ExportNamespaceSpecifier") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isOptionalMemberExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "OptionalMemberExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isOptionalCallExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "OptionalCallExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isClassProperty(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ClassProperty") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isClassAccessorProperty(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ClassAccessorProperty") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isClassPrivateProperty(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ClassPrivateProperty") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isClassPrivateMethod(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ClassPrivateMethod") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isPrivateName(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "PrivateName") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isStaticBlock(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "StaticBlock") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isAnyTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "AnyTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isArrayTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ArrayTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isBooleanTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "BooleanTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isBooleanLiteralTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "BooleanLiteralTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isNullLiteralTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "NullLiteralTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isClassImplements(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ClassImplements") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isDeclareClass(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "DeclareClass") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isDeclareFunction(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "DeclareFunction") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isDeclareInterface(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "DeclareInterface") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isDeclareModule(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "DeclareModule") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isDeclareModuleExports(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "DeclareModuleExports") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isDeclareTypeAlias(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "DeclareTypeAlias") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isDeclareOpaqueType(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "DeclareOpaqueType") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isDeclareVariable(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "DeclareVariable") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isDeclareExportDeclaration(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "DeclareExportDeclaration") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isDeclareExportAllDeclaration(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "DeclareExportAllDeclaration") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isDeclaredPredicate(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "DeclaredPredicate") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isExistsTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ExistsTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isFunctionTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "FunctionTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isFunctionTypeParam(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "FunctionTypeParam") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isGenericTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "GenericTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isInferredPredicate(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "InferredPredicate") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isInterfaceExtends(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "InterfaceExtends") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isInterfaceDeclaration(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "InterfaceDeclaration") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isInterfaceTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "InterfaceTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isIntersectionTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "IntersectionTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isMixedTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "MixedTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isEmptyTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "EmptyTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isNullableTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "NullableTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isNumberLiteralTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "NumberLiteralTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isNumberTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "NumberTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isObjectTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ObjectTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isObjectTypeInternalSlot(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ObjectTypeInternalSlot") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isObjectTypeCallProperty(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ObjectTypeCallProperty") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isObjectTypeIndexer(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ObjectTypeIndexer") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isObjectTypeProperty(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ObjectTypeProperty") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isObjectTypeSpreadProperty(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ObjectTypeSpreadProperty") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isOpaqueType(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "OpaqueType") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isQualifiedTypeIdentifier(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "QualifiedTypeIdentifier") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isStringLiteralTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "StringLiteralTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isStringTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "StringTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isSymbolTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "SymbolTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isThisTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ThisTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTupleTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TupleTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTypeofTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TypeofTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTypeAlias(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TypeAlias") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTypeCastExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TypeCastExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTypeParameter(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TypeParameter") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTypeParameterDeclaration(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TypeParameterDeclaration") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTypeParameterInstantiation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TypeParameterInstantiation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isUnionTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "UnionTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isVariance(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "Variance") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isVoidTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "VoidTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isEnumDeclaration(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "EnumDeclaration") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isEnumBooleanBody(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "EnumBooleanBody") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isEnumNumberBody(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "EnumNumberBody") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isEnumStringBody(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "EnumStringBody") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isEnumSymbolBody(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "EnumSymbolBody") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isEnumBooleanMember(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "EnumBooleanMember") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isEnumNumberMember(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "EnumNumberMember") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isEnumStringMember(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "EnumStringMember") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isEnumDefaultedMember(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "EnumDefaultedMember") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isIndexedAccessType(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "IndexedAccessType") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isOptionalIndexedAccessType(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "OptionalIndexedAccessType") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isJSXAttribute(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "JSXAttribute") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isJSXClosingElement(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "JSXClosingElement") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isJSXElement(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "JSXElement") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isJSXEmptyExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "JSXEmptyExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isJSXExpressionContainer(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "JSXExpressionContainer") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isJSXSpreadChild(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "JSXSpreadChild") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isJSXIdentifier(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "JSXIdentifier") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isJSXMemberExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "JSXMemberExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isJSXNamespacedName(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "JSXNamespacedName") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isJSXOpeningElement(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "JSXOpeningElement") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isJSXSpreadAttribute(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "JSXSpreadAttribute") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isJSXText(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "JSXText") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isJSXFragment(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "JSXFragment") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isJSXOpeningFragment(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "JSXOpeningFragment") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isJSXClosingFragment(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "JSXClosingFragment") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isNoop(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "Noop") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isPlaceholder(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "Placeholder") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isV8IntrinsicIdentifier(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "V8IntrinsicIdentifier") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isArgumentPlaceholder(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ArgumentPlaceholder") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isBindExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "BindExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isImportAttribute(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ImportAttribute") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isDecorator(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "Decorator") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isDoExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "DoExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isExportDefaultSpecifier(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ExportDefaultSpecifier") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isRecordExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "RecordExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTupleExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TupleExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isDecimalLiteral(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "DecimalLiteral") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isModuleExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "ModuleExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTopicReference(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TopicReference") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isPipelineTopicExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "PipelineTopicExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isPipelineBareFunction(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "PipelineBareFunction") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isPipelinePrimaryTopicReference(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "PipelinePrimaryTopicReference") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSParameterProperty(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSParameterProperty") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSDeclareFunction(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSDeclareFunction") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSDeclareMethod(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSDeclareMethod") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSQualifiedName(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSQualifiedName") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSCallSignatureDeclaration(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSCallSignatureDeclaration") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSConstructSignatureDeclaration(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSConstructSignatureDeclaration") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSPropertySignature(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSPropertySignature") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSMethodSignature(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSMethodSignature") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSIndexSignature(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSIndexSignature") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSAnyKeyword(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSAnyKeyword") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSBooleanKeyword(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSBooleanKeyword") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSBigIntKeyword(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSBigIntKeyword") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSIntrinsicKeyword(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSIntrinsicKeyword") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSNeverKeyword(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSNeverKeyword") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSNullKeyword(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSNullKeyword") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSNumberKeyword(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSNumberKeyword") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSObjectKeyword(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSObjectKeyword") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSStringKeyword(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSStringKeyword") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSSymbolKeyword(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSSymbolKeyword") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSUndefinedKeyword(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSUndefinedKeyword") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSUnknownKeyword(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSUnknownKeyword") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSVoidKeyword(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSVoidKeyword") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSThisType(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSThisType") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSFunctionType(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSFunctionType") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSConstructorType(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSConstructorType") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSTypeReference(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSTypeReference") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSTypePredicate(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSTypePredicate") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSTypeQuery(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSTypeQuery") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSTypeLiteral(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSTypeLiteral") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSArrayType(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSArrayType") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSTupleType(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSTupleType") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSOptionalType(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSOptionalType") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSRestType(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSRestType") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSNamedTupleMember(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSNamedTupleMember") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSUnionType(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSUnionType") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSIntersectionType(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSIntersectionType") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSConditionalType(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSConditionalType") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSInferType(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSInferType") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSParenthesizedType(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSParenthesizedType") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSTypeOperator(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSTypeOperator") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSIndexedAccessType(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSIndexedAccessType") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSMappedType(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSMappedType") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSLiteralType(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSLiteralType") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSExpressionWithTypeArguments(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSExpressionWithTypeArguments") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSInterfaceDeclaration(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSInterfaceDeclaration") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSInterfaceBody(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSInterfaceBody") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSTypeAliasDeclaration(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSTypeAliasDeclaration") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSInstantiationExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSInstantiationExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSAsExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSAsExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSSatisfiesExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSSatisfiesExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSTypeAssertion(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSTypeAssertion") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSEnumDeclaration(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSEnumDeclaration") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSEnumMember(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSEnumMember") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSModuleDeclaration(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSModuleDeclaration") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSModuleBlock(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSModuleBlock") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSImportType(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSImportType") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSImportEqualsDeclaration(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSImportEqualsDeclaration") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSExternalModuleReference(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSExternalModuleReference") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSNonNullExpression(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSNonNullExpression") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSExportAssignment(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSExportAssignment") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSNamespaceExportDeclaration(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSNamespaceExportDeclaration") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSTypeAnnotation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSTypeAnnotation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSTypeParameterInstantiation(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSTypeParameterInstantiation") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSTypeParameterDeclaration(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSTypeParameterDeclaration") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSTypeParameter(node, opts) {
    	  if (!node) return false;
    	  if (node.type !== "TSTypeParameter") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isStandardized(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "ArrayExpression":
    	    case "AssignmentExpression":
    	    case "BinaryExpression":
    	    case "InterpreterDirective":
    	    case "Directive":
    	    case "DirectiveLiteral":
    	    case "BlockStatement":
    	    case "BreakStatement":
    	    case "CallExpression":
    	    case "CatchClause":
    	    case "ConditionalExpression":
    	    case "ContinueStatement":
    	    case "DebuggerStatement":
    	    case "DoWhileStatement":
    	    case "EmptyStatement":
    	    case "ExpressionStatement":
    	    case "File":
    	    case "ForInStatement":
    	    case "ForStatement":
    	    case "FunctionDeclaration":
    	    case "FunctionExpression":
    	    case "Identifier":
    	    case "IfStatement":
    	    case "LabeledStatement":
    	    case "StringLiteral":
    	    case "NumericLiteral":
    	    case "NullLiteral":
    	    case "BooleanLiteral":
    	    case "RegExpLiteral":
    	    case "LogicalExpression":
    	    case "MemberExpression":
    	    case "NewExpression":
    	    case "Program":
    	    case "ObjectExpression":
    	    case "ObjectMethod":
    	    case "ObjectProperty":
    	    case "RestElement":
    	    case "ReturnStatement":
    	    case "SequenceExpression":
    	    case "ParenthesizedExpression":
    	    case "SwitchCase":
    	    case "SwitchStatement":
    	    case "ThisExpression":
    	    case "ThrowStatement":
    	    case "TryStatement":
    	    case "UnaryExpression":
    	    case "UpdateExpression":
    	    case "VariableDeclaration":
    	    case "VariableDeclarator":
    	    case "WhileStatement":
    	    case "WithStatement":
    	    case "AssignmentPattern":
    	    case "ArrayPattern":
    	    case "ArrowFunctionExpression":
    	    case "ClassBody":
    	    case "ClassExpression":
    	    case "ClassDeclaration":
    	    case "ExportAllDeclaration":
    	    case "ExportDefaultDeclaration":
    	    case "ExportNamedDeclaration":
    	    case "ExportSpecifier":
    	    case "ForOfStatement":
    	    case "ImportDeclaration":
    	    case "ImportDefaultSpecifier":
    	    case "ImportNamespaceSpecifier":
    	    case "ImportSpecifier":
    	    case "ImportExpression":
    	    case "MetaProperty":
    	    case "ClassMethod":
    	    case "ObjectPattern":
    	    case "SpreadElement":
    	    case "Super":
    	    case "TaggedTemplateExpression":
    	    case "TemplateElement":
    	    case "TemplateLiteral":
    	    case "YieldExpression":
    	    case "AwaitExpression":
    	    case "Import":
    	    case "BigIntLiteral":
    	    case "ExportNamespaceSpecifier":
    	    case "OptionalMemberExpression":
    	    case "OptionalCallExpression":
    	    case "ClassProperty":
    	    case "ClassAccessorProperty":
    	    case "ClassPrivateProperty":
    	    case "ClassPrivateMethod":
    	    case "PrivateName":
    	    case "StaticBlock":
    	      break;
    	    case "Placeholder":
    	      switch (node.expectedNode) {
    	        case "Identifier":
    	        case "StringLiteral":
    	        case "BlockStatement":
    	        case "ClassBody":
    	          break;
    	        default:
    	          return false;
    	      }
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isExpression(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "ArrayExpression":
    	    case "AssignmentExpression":
    	    case "BinaryExpression":
    	    case "CallExpression":
    	    case "ConditionalExpression":
    	    case "FunctionExpression":
    	    case "Identifier":
    	    case "StringLiteral":
    	    case "NumericLiteral":
    	    case "NullLiteral":
    	    case "BooleanLiteral":
    	    case "RegExpLiteral":
    	    case "LogicalExpression":
    	    case "MemberExpression":
    	    case "NewExpression":
    	    case "ObjectExpression":
    	    case "SequenceExpression":
    	    case "ParenthesizedExpression":
    	    case "ThisExpression":
    	    case "UnaryExpression":
    	    case "UpdateExpression":
    	    case "ArrowFunctionExpression":
    	    case "ClassExpression":
    	    case "ImportExpression":
    	    case "MetaProperty":
    	    case "Super":
    	    case "TaggedTemplateExpression":
    	    case "TemplateLiteral":
    	    case "YieldExpression":
    	    case "AwaitExpression":
    	    case "Import":
    	    case "BigIntLiteral":
    	    case "OptionalMemberExpression":
    	    case "OptionalCallExpression":
    	    case "TypeCastExpression":
    	    case "JSXElement":
    	    case "JSXFragment":
    	    case "BindExpression":
    	    case "DoExpression":
    	    case "RecordExpression":
    	    case "TupleExpression":
    	    case "DecimalLiteral":
    	    case "ModuleExpression":
    	    case "TopicReference":
    	    case "PipelineTopicExpression":
    	    case "PipelineBareFunction":
    	    case "PipelinePrimaryTopicReference":
    	    case "TSInstantiationExpression":
    	    case "TSAsExpression":
    	    case "TSSatisfiesExpression":
    	    case "TSTypeAssertion":
    	    case "TSNonNullExpression":
    	      break;
    	    case "Placeholder":
    	      switch (node.expectedNode) {
    	        case "Expression":
    	        case "Identifier":
    	        case "StringLiteral":
    	          break;
    	        default:
    	          return false;
    	      }
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isBinary(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "BinaryExpression":
    	    case "LogicalExpression":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isScopable(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "BlockStatement":
    	    case "CatchClause":
    	    case "DoWhileStatement":
    	    case "ForInStatement":
    	    case "ForStatement":
    	    case "FunctionDeclaration":
    	    case "FunctionExpression":
    	    case "Program":
    	    case "ObjectMethod":
    	    case "SwitchStatement":
    	    case "WhileStatement":
    	    case "ArrowFunctionExpression":
    	    case "ClassExpression":
    	    case "ClassDeclaration":
    	    case "ForOfStatement":
    	    case "ClassMethod":
    	    case "ClassPrivateMethod":
    	    case "StaticBlock":
    	    case "TSModuleBlock":
    	      break;
    	    case "Placeholder":
    	      if (node.expectedNode === "BlockStatement") break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isBlockParent(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "BlockStatement":
    	    case "CatchClause":
    	    case "DoWhileStatement":
    	    case "ForInStatement":
    	    case "ForStatement":
    	    case "FunctionDeclaration":
    	    case "FunctionExpression":
    	    case "Program":
    	    case "ObjectMethod":
    	    case "SwitchStatement":
    	    case "WhileStatement":
    	    case "ArrowFunctionExpression":
    	    case "ForOfStatement":
    	    case "ClassMethod":
    	    case "ClassPrivateMethod":
    	    case "StaticBlock":
    	    case "TSModuleBlock":
    	      break;
    	    case "Placeholder":
    	      if (node.expectedNode === "BlockStatement") break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isBlock(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "BlockStatement":
    	    case "Program":
    	    case "TSModuleBlock":
    	      break;
    	    case "Placeholder":
    	      if (node.expectedNode === "BlockStatement") break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isStatement(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "BlockStatement":
    	    case "BreakStatement":
    	    case "ContinueStatement":
    	    case "DebuggerStatement":
    	    case "DoWhileStatement":
    	    case "EmptyStatement":
    	    case "ExpressionStatement":
    	    case "ForInStatement":
    	    case "ForStatement":
    	    case "FunctionDeclaration":
    	    case "IfStatement":
    	    case "LabeledStatement":
    	    case "ReturnStatement":
    	    case "SwitchStatement":
    	    case "ThrowStatement":
    	    case "TryStatement":
    	    case "VariableDeclaration":
    	    case "WhileStatement":
    	    case "WithStatement":
    	    case "ClassDeclaration":
    	    case "ExportAllDeclaration":
    	    case "ExportDefaultDeclaration":
    	    case "ExportNamedDeclaration":
    	    case "ForOfStatement":
    	    case "ImportDeclaration":
    	    case "DeclareClass":
    	    case "DeclareFunction":
    	    case "DeclareInterface":
    	    case "DeclareModule":
    	    case "DeclareModuleExports":
    	    case "DeclareTypeAlias":
    	    case "DeclareOpaqueType":
    	    case "DeclareVariable":
    	    case "DeclareExportDeclaration":
    	    case "DeclareExportAllDeclaration":
    	    case "InterfaceDeclaration":
    	    case "OpaqueType":
    	    case "TypeAlias":
    	    case "EnumDeclaration":
    	    case "TSDeclareFunction":
    	    case "TSInterfaceDeclaration":
    	    case "TSTypeAliasDeclaration":
    	    case "TSEnumDeclaration":
    	    case "TSModuleDeclaration":
    	    case "TSImportEqualsDeclaration":
    	    case "TSExportAssignment":
    	    case "TSNamespaceExportDeclaration":
    	      break;
    	    case "Placeholder":
    	      switch (node.expectedNode) {
    	        case "Statement":
    	        case "Declaration":
    	        case "BlockStatement":
    	          break;
    	        default:
    	          return false;
    	      }
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTerminatorless(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "BreakStatement":
    	    case "ContinueStatement":
    	    case "ReturnStatement":
    	    case "ThrowStatement":
    	    case "YieldExpression":
    	    case "AwaitExpression":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isCompletionStatement(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "BreakStatement":
    	    case "ContinueStatement":
    	    case "ReturnStatement":
    	    case "ThrowStatement":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isConditional(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "ConditionalExpression":
    	    case "IfStatement":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isLoop(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "DoWhileStatement":
    	    case "ForInStatement":
    	    case "ForStatement":
    	    case "WhileStatement":
    	    case "ForOfStatement":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isWhile(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "DoWhileStatement":
    	    case "WhileStatement":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isExpressionWrapper(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "ExpressionStatement":
    	    case "ParenthesizedExpression":
    	    case "TypeCastExpression":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isFor(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "ForInStatement":
    	    case "ForStatement":
    	    case "ForOfStatement":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isForXStatement(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "ForInStatement":
    	    case "ForOfStatement":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isFunction(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "FunctionDeclaration":
    	    case "FunctionExpression":
    	    case "ObjectMethod":
    	    case "ArrowFunctionExpression":
    	    case "ClassMethod":
    	    case "ClassPrivateMethod":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isFunctionParent(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "FunctionDeclaration":
    	    case "FunctionExpression":
    	    case "ObjectMethod":
    	    case "ArrowFunctionExpression":
    	    case "ClassMethod":
    	    case "ClassPrivateMethod":
    	    case "StaticBlock":
    	    case "TSModuleBlock":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isPureish(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "FunctionDeclaration":
    	    case "FunctionExpression":
    	    case "StringLiteral":
    	    case "NumericLiteral":
    	    case "NullLiteral":
    	    case "BooleanLiteral":
    	    case "RegExpLiteral":
    	    case "ArrowFunctionExpression":
    	    case "BigIntLiteral":
    	    case "DecimalLiteral":
    	      break;
    	    case "Placeholder":
    	      if (node.expectedNode === "StringLiteral") break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isDeclaration(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "FunctionDeclaration":
    	    case "VariableDeclaration":
    	    case "ClassDeclaration":
    	    case "ExportAllDeclaration":
    	    case "ExportDefaultDeclaration":
    	    case "ExportNamedDeclaration":
    	    case "ImportDeclaration":
    	    case "DeclareClass":
    	    case "DeclareFunction":
    	    case "DeclareInterface":
    	    case "DeclareModule":
    	    case "DeclareModuleExports":
    	    case "DeclareTypeAlias":
    	    case "DeclareOpaqueType":
    	    case "DeclareVariable":
    	    case "DeclareExportDeclaration":
    	    case "DeclareExportAllDeclaration":
    	    case "InterfaceDeclaration":
    	    case "OpaqueType":
    	    case "TypeAlias":
    	    case "EnumDeclaration":
    	    case "TSDeclareFunction":
    	    case "TSInterfaceDeclaration":
    	    case "TSTypeAliasDeclaration":
    	    case "TSEnumDeclaration":
    	    case "TSModuleDeclaration":
    	      break;
    	    case "Placeholder":
    	      if (node.expectedNode === "Declaration") break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isPatternLike(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "Identifier":
    	    case "RestElement":
    	    case "AssignmentPattern":
    	    case "ArrayPattern":
    	    case "ObjectPattern":
    	    case "TSAsExpression":
    	    case "TSSatisfiesExpression":
    	    case "TSTypeAssertion":
    	    case "TSNonNullExpression":
    	      break;
    	    case "Placeholder":
    	      switch (node.expectedNode) {
    	        case "Pattern":
    	        case "Identifier":
    	          break;
    	        default:
    	          return false;
    	      }
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isLVal(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "Identifier":
    	    case "MemberExpression":
    	    case "RestElement":
    	    case "AssignmentPattern":
    	    case "ArrayPattern":
    	    case "ObjectPattern":
    	    case "TSParameterProperty":
    	    case "TSAsExpression":
    	    case "TSSatisfiesExpression":
    	    case "TSTypeAssertion":
    	    case "TSNonNullExpression":
    	      break;
    	    case "Placeholder":
    	      switch (node.expectedNode) {
    	        case "Pattern":
    	        case "Identifier":
    	          break;
    	        default:
    	          return false;
    	      }
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSEntityName(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "Identifier":
    	    case "TSQualifiedName":
    	      break;
    	    case "Placeholder":
    	      if (node.expectedNode === "Identifier") break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isLiteral(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "StringLiteral":
    	    case "NumericLiteral":
    	    case "NullLiteral":
    	    case "BooleanLiteral":
    	    case "RegExpLiteral":
    	    case "TemplateLiteral":
    	    case "BigIntLiteral":
    	    case "DecimalLiteral":
    	      break;
    	    case "Placeholder":
    	      if (node.expectedNode === "StringLiteral") break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isImmutable(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "StringLiteral":
    	    case "NumericLiteral":
    	    case "NullLiteral":
    	    case "BooleanLiteral":
    	    case "BigIntLiteral":
    	    case "JSXAttribute":
    	    case "JSXClosingElement":
    	    case "JSXElement":
    	    case "JSXExpressionContainer":
    	    case "JSXSpreadChild":
    	    case "JSXOpeningElement":
    	    case "JSXText":
    	    case "JSXFragment":
    	    case "JSXOpeningFragment":
    	    case "JSXClosingFragment":
    	    case "DecimalLiteral":
    	      break;
    	    case "Placeholder":
    	      if (node.expectedNode === "StringLiteral") break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isUserWhitespacable(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "ObjectMethod":
    	    case "ObjectProperty":
    	    case "ObjectTypeInternalSlot":
    	    case "ObjectTypeCallProperty":
    	    case "ObjectTypeIndexer":
    	    case "ObjectTypeProperty":
    	    case "ObjectTypeSpreadProperty":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isMethod(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "ObjectMethod":
    	    case "ClassMethod":
    	    case "ClassPrivateMethod":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isObjectMember(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "ObjectMethod":
    	    case "ObjectProperty":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isProperty(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "ObjectProperty":
    	    case "ClassProperty":
    	    case "ClassAccessorProperty":
    	    case "ClassPrivateProperty":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isUnaryLike(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "UnaryExpression":
    	    case "SpreadElement":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isPattern(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "AssignmentPattern":
    	    case "ArrayPattern":
    	    case "ObjectPattern":
    	      break;
    	    case "Placeholder":
    	      if (node.expectedNode === "Pattern") break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isClass(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "ClassExpression":
    	    case "ClassDeclaration":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isImportOrExportDeclaration(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "ExportAllDeclaration":
    	    case "ExportDefaultDeclaration":
    	    case "ExportNamedDeclaration":
    	    case "ImportDeclaration":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isExportDeclaration(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "ExportAllDeclaration":
    	    case "ExportDefaultDeclaration":
    	    case "ExportNamedDeclaration":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isModuleSpecifier(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "ExportSpecifier":
    	    case "ImportDefaultSpecifier":
    	    case "ImportNamespaceSpecifier":
    	    case "ImportSpecifier":
    	    case "ExportNamespaceSpecifier":
    	    case "ExportDefaultSpecifier":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isAccessor(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "ClassAccessorProperty":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isPrivate(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "ClassPrivateProperty":
    	    case "ClassPrivateMethod":
    	    case "PrivateName":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isFlow(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "AnyTypeAnnotation":
    	    case "ArrayTypeAnnotation":
    	    case "BooleanTypeAnnotation":
    	    case "BooleanLiteralTypeAnnotation":
    	    case "NullLiteralTypeAnnotation":
    	    case "ClassImplements":
    	    case "DeclareClass":
    	    case "DeclareFunction":
    	    case "DeclareInterface":
    	    case "DeclareModule":
    	    case "DeclareModuleExports":
    	    case "DeclareTypeAlias":
    	    case "DeclareOpaqueType":
    	    case "DeclareVariable":
    	    case "DeclareExportDeclaration":
    	    case "DeclareExportAllDeclaration":
    	    case "DeclaredPredicate":
    	    case "ExistsTypeAnnotation":
    	    case "FunctionTypeAnnotation":
    	    case "FunctionTypeParam":
    	    case "GenericTypeAnnotation":
    	    case "InferredPredicate":
    	    case "InterfaceExtends":
    	    case "InterfaceDeclaration":
    	    case "InterfaceTypeAnnotation":
    	    case "IntersectionTypeAnnotation":
    	    case "MixedTypeAnnotation":
    	    case "EmptyTypeAnnotation":
    	    case "NullableTypeAnnotation":
    	    case "NumberLiteralTypeAnnotation":
    	    case "NumberTypeAnnotation":
    	    case "ObjectTypeAnnotation":
    	    case "ObjectTypeInternalSlot":
    	    case "ObjectTypeCallProperty":
    	    case "ObjectTypeIndexer":
    	    case "ObjectTypeProperty":
    	    case "ObjectTypeSpreadProperty":
    	    case "OpaqueType":
    	    case "QualifiedTypeIdentifier":
    	    case "StringLiteralTypeAnnotation":
    	    case "StringTypeAnnotation":
    	    case "SymbolTypeAnnotation":
    	    case "ThisTypeAnnotation":
    	    case "TupleTypeAnnotation":
    	    case "TypeofTypeAnnotation":
    	    case "TypeAlias":
    	    case "TypeAnnotation":
    	    case "TypeCastExpression":
    	    case "TypeParameter":
    	    case "TypeParameterDeclaration":
    	    case "TypeParameterInstantiation":
    	    case "UnionTypeAnnotation":
    	    case "Variance":
    	    case "VoidTypeAnnotation":
    	    case "EnumDeclaration":
    	    case "EnumBooleanBody":
    	    case "EnumNumberBody":
    	    case "EnumStringBody":
    	    case "EnumSymbolBody":
    	    case "EnumBooleanMember":
    	    case "EnumNumberMember":
    	    case "EnumStringMember":
    	    case "EnumDefaultedMember":
    	    case "IndexedAccessType":
    	    case "OptionalIndexedAccessType":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isFlowType(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "AnyTypeAnnotation":
    	    case "ArrayTypeAnnotation":
    	    case "BooleanTypeAnnotation":
    	    case "BooleanLiteralTypeAnnotation":
    	    case "NullLiteralTypeAnnotation":
    	    case "ExistsTypeAnnotation":
    	    case "FunctionTypeAnnotation":
    	    case "GenericTypeAnnotation":
    	    case "InterfaceTypeAnnotation":
    	    case "IntersectionTypeAnnotation":
    	    case "MixedTypeAnnotation":
    	    case "EmptyTypeAnnotation":
    	    case "NullableTypeAnnotation":
    	    case "NumberLiteralTypeAnnotation":
    	    case "NumberTypeAnnotation":
    	    case "ObjectTypeAnnotation":
    	    case "StringLiteralTypeAnnotation":
    	    case "StringTypeAnnotation":
    	    case "SymbolTypeAnnotation":
    	    case "ThisTypeAnnotation":
    	    case "TupleTypeAnnotation":
    	    case "TypeofTypeAnnotation":
    	    case "UnionTypeAnnotation":
    	    case "VoidTypeAnnotation":
    	    case "IndexedAccessType":
    	    case "OptionalIndexedAccessType":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isFlowBaseAnnotation(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "AnyTypeAnnotation":
    	    case "BooleanTypeAnnotation":
    	    case "NullLiteralTypeAnnotation":
    	    case "MixedTypeAnnotation":
    	    case "EmptyTypeAnnotation":
    	    case "NumberTypeAnnotation":
    	    case "StringTypeAnnotation":
    	    case "SymbolTypeAnnotation":
    	    case "ThisTypeAnnotation":
    	    case "VoidTypeAnnotation":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isFlowDeclaration(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "DeclareClass":
    	    case "DeclareFunction":
    	    case "DeclareInterface":
    	    case "DeclareModule":
    	    case "DeclareModuleExports":
    	    case "DeclareTypeAlias":
    	    case "DeclareOpaqueType":
    	    case "DeclareVariable":
    	    case "DeclareExportDeclaration":
    	    case "DeclareExportAllDeclaration":
    	    case "InterfaceDeclaration":
    	    case "OpaqueType":
    	    case "TypeAlias":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isFlowPredicate(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "DeclaredPredicate":
    	    case "InferredPredicate":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isEnumBody(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "EnumBooleanBody":
    	    case "EnumNumberBody":
    	    case "EnumStringBody":
    	    case "EnumSymbolBody":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isEnumMember(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "EnumBooleanMember":
    	    case "EnumNumberMember":
    	    case "EnumStringMember":
    	    case "EnumDefaultedMember":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isJSX(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "JSXAttribute":
    	    case "JSXClosingElement":
    	    case "JSXElement":
    	    case "JSXEmptyExpression":
    	    case "JSXExpressionContainer":
    	    case "JSXSpreadChild":
    	    case "JSXIdentifier":
    	    case "JSXMemberExpression":
    	    case "JSXNamespacedName":
    	    case "JSXOpeningElement":
    	    case "JSXSpreadAttribute":
    	    case "JSXText":
    	    case "JSXFragment":
    	    case "JSXOpeningFragment":
    	    case "JSXClosingFragment":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isMiscellaneous(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "Noop":
    	    case "Placeholder":
    	    case "V8IntrinsicIdentifier":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTypeScript(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "TSParameterProperty":
    	    case "TSDeclareFunction":
    	    case "TSDeclareMethod":
    	    case "TSQualifiedName":
    	    case "TSCallSignatureDeclaration":
    	    case "TSConstructSignatureDeclaration":
    	    case "TSPropertySignature":
    	    case "TSMethodSignature":
    	    case "TSIndexSignature":
    	    case "TSAnyKeyword":
    	    case "TSBooleanKeyword":
    	    case "TSBigIntKeyword":
    	    case "TSIntrinsicKeyword":
    	    case "TSNeverKeyword":
    	    case "TSNullKeyword":
    	    case "TSNumberKeyword":
    	    case "TSObjectKeyword":
    	    case "TSStringKeyword":
    	    case "TSSymbolKeyword":
    	    case "TSUndefinedKeyword":
    	    case "TSUnknownKeyword":
    	    case "TSVoidKeyword":
    	    case "TSThisType":
    	    case "TSFunctionType":
    	    case "TSConstructorType":
    	    case "TSTypeReference":
    	    case "TSTypePredicate":
    	    case "TSTypeQuery":
    	    case "TSTypeLiteral":
    	    case "TSArrayType":
    	    case "TSTupleType":
    	    case "TSOptionalType":
    	    case "TSRestType":
    	    case "TSNamedTupleMember":
    	    case "TSUnionType":
    	    case "TSIntersectionType":
    	    case "TSConditionalType":
    	    case "TSInferType":
    	    case "TSParenthesizedType":
    	    case "TSTypeOperator":
    	    case "TSIndexedAccessType":
    	    case "TSMappedType":
    	    case "TSLiteralType":
    	    case "TSExpressionWithTypeArguments":
    	    case "TSInterfaceDeclaration":
    	    case "TSInterfaceBody":
    	    case "TSTypeAliasDeclaration":
    	    case "TSInstantiationExpression":
    	    case "TSAsExpression":
    	    case "TSSatisfiesExpression":
    	    case "TSTypeAssertion":
    	    case "TSEnumDeclaration":
    	    case "TSEnumMember":
    	    case "TSModuleDeclaration":
    	    case "TSModuleBlock":
    	    case "TSImportType":
    	    case "TSImportEqualsDeclaration":
    	    case "TSExternalModuleReference":
    	    case "TSNonNullExpression":
    	    case "TSExportAssignment":
    	    case "TSNamespaceExportDeclaration":
    	    case "TSTypeAnnotation":
    	    case "TSTypeParameterInstantiation":
    	    case "TSTypeParameterDeclaration":
    	    case "TSTypeParameter":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSTypeElement(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "TSCallSignatureDeclaration":
    	    case "TSConstructSignatureDeclaration":
    	    case "TSPropertySignature":
    	    case "TSMethodSignature":
    	    case "TSIndexSignature":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSType(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "TSAnyKeyword":
    	    case "TSBooleanKeyword":
    	    case "TSBigIntKeyword":
    	    case "TSIntrinsicKeyword":
    	    case "TSNeverKeyword":
    	    case "TSNullKeyword":
    	    case "TSNumberKeyword":
    	    case "TSObjectKeyword":
    	    case "TSStringKeyword":
    	    case "TSSymbolKeyword":
    	    case "TSUndefinedKeyword":
    	    case "TSUnknownKeyword":
    	    case "TSVoidKeyword":
    	    case "TSThisType":
    	    case "TSFunctionType":
    	    case "TSConstructorType":
    	    case "TSTypeReference":
    	    case "TSTypePredicate":
    	    case "TSTypeQuery":
    	    case "TSTypeLiteral":
    	    case "TSArrayType":
    	    case "TSTupleType":
    	    case "TSOptionalType":
    	    case "TSRestType":
    	    case "TSUnionType":
    	    case "TSIntersectionType":
    	    case "TSConditionalType":
    	    case "TSInferType":
    	    case "TSParenthesizedType":
    	    case "TSTypeOperator":
    	    case "TSIndexedAccessType":
    	    case "TSMappedType":
    	    case "TSLiteralType":
    	    case "TSExpressionWithTypeArguments":
    	    case "TSImportType":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isTSBaseType(node, opts) {
    	  if (!node) return false;
    	  switch (node.type) {
    	    case "TSAnyKeyword":
    	    case "TSBooleanKeyword":
    	    case "TSBigIntKeyword":
    	    case "TSIntrinsicKeyword":
    	    case "TSNeverKeyword":
    	    case "TSNullKeyword":
    	    case "TSNumberKeyword":
    	    case "TSObjectKeyword":
    	    case "TSStringKeyword":
    	    case "TSSymbolKeyword":
    	    case "TSUndefinedKeyword":
    	    case "TSUnknownKeyword":
    	    case "TSVoidKeyword":
    	    case "TSThisType":
    	    case "TSLiteralType":
    	      break;
    	    default:
    	      return false;
    	  }
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isNumberLiteral(node, opts) {
    	  (0, _deprecationWarning.default)("isNumberLiteral", "isNumericLiteral");
    	  if (!node) return false;
    	  if (node.type !== "NumberLiteral") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isRegexLiteral(node, opts) {
    	  (0, _deprecationWarning.default)("isRegexLiteral", "isRegExpLiteral");
    	  if (!node) return false;
    	  if (node.type !== "RegexLiteral") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isRestProperty(node, opts) {
    	  (0, _deprecationWarning.default)("isRestProperty", "isRestElement");
    	  if (!node) return false;
    	  if (node.type !== "RestProperty") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isSpreadProperty(node, opts) {
    	  (0, _deprecationWarning.default)("isSpreadProperty", "isSpreadElement");
    	  if (!node) return false;
    	  if (node.type !== "SpreadProperty") return false;
    	  return opts == null || (0, _shallowEqual.default)(node, opts);
    	}
    	function isModuleDeclaration(node, opts) {
    	  (0, _deprecationWarning.default)("isModuleDeclaration", "isImportOrExportDeclaration");
    	  return isImportOrExportDeclaration(node, opts);
    	}

    	
    	return generated$3;
    }

    var hasRequiredMatchesPattern;

    function requireMatchesPattern () {
    	if (hasRequiredMatchesPattern) return matchesPattern;
    	hasRequiredMatchesPattern = 1;

    	Object.defineProperty(matchesPattern, "__esModule", {
    	  value: true
    	});
    	matchesPattern.default = matchesPattern$1;
    	var _index = requireGenerated$3();
    	function matchesPattern$1(member, match, allowPartial) {
    	  if (!(0, _index.isMemberExpression)(member)) return false;
    	  const parts = Array.isArray(match) ? match : match.split(".");
    	  const nodes = [];
    	  let node;
    	  for (node = member; (0, _index.isMemberExpression)(node); node = node.object) {
    	    nodes.push(node.property);
    	  }
    	  nodes.push(node);
    	  if (nodes.length < parts.length) return false;
    	  if (!allowPartial && nodes.length > parts.length) return false;
    	  for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
    	    const node = nodes[j];
    	    let value;
    	    if ((0, _index.isIdentifier)(node)) {
    	      value = node.name;
    	    } else if ((0, _index.isStringLiteral)(node)) {
    	      value = node.value;
    	    } else if ((0, _index.isThisExpression)(node)) {
    	      value = "this";
    	    } else {
    	      return false;
    	    }
    	    if (parts[i] !== value) return false;
    	  }
    	  return true;
    	}

    	
    	return matchesPattern;
    }

    var hasRequiredBuildMatchMemberExpression;

    function requireBuildMatchMemberExpression () {
    	if (hasRequiredBuildMatchMemberExpression) return buildMatchMemberExpression;
    	hasRequiredBuildMatchMemberExpression = 1;

    	Object.defineProperty(buildMatchMemberExpression, "__esModule", {
    	  value: true
    	});
    	buildMatchMemberExpression.default = buildMatchMemberExpression$1;
    	var _matchesPattern = requireMatchesPattern();
    	function buildMatchMemberExpression$1(match, allowPartial) {
    	  const parts = match.split(".");
    	  return member => (0, _matchesPattern.default)(member, parts, allowPartial);
    	}

    	
    	return buildMatchMemberExpression;
    }

    var hasRequiredIsReactComponent;

    function requireIsReactComponent () {
    	if (hasRequiredIsReactComponent) return isReactComponent$1;
    	hasRequiredIsReactComponent = 1;

    	Object.defineProperty(isReactComponent$1, "__esModule", {
    	  value: true
    	});
    	isReactComponent$1.default = void 0;
    	var _buildMatchMemberExpression = requireBuildMatchMemberExpression();
    	const isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
    	var _default = isReactComponent;
    	isReactComponent$1.default = _default;

    	
    	return isReactComponent$1;
    }

    var isCompatTag = {};

    var hasRequiredIsCompatTag;

    function requireIsCompatTag () {
    	if (hasRequiredIsCompatTag) return isCompatTag;
    	hasRequiredIsCompatTag = 1;

    	Object.defineProperty(isCompatTag, "__esModule", {
    	  value: true
    	});
    	isCompatTag.default = isCompatTag$1;
    	function isCompatTag$1(tagName) {
    	  return !!tagName && /^[a-z]/.test(tagName);
    	}

    	
    	return isCompatTag;
    }

    var buildChildren = {};

    var cleanJSXElementLiteralChild = {};

    var generated$2 = {};

    var validateNode = {};

    var validate = {};

    var definitions = {};

    var toFastProperties;
    var hasRequiredToFastProperties;

    function requireToFastProperties () {
    	if (hasRequiredToFastProperties) return toFastProperties;
    	hasRequiredToFastProperties = 1;

    	let fastProto = null;

    	// Creates an object with permanently fast properties in V8. See Toon Verwaest's
    	// post https://medium.com/@tverwaes/setting-up-prototypes-in-v8-ec9c9491dfe2#5f62
    	// for more details. Use %HasFastProperties(object) and the Node.js flag
    	// --allow-natives-syntax to check whether an object has fast properties.
    	function FastObject(o) {
    		// A prototype object will have "fast properties" enabled once it is checked
    		// against the inline property cache of a function, e.g. fastProto.property:
    		// https://github.com/v8/v8/blob/6.0.122/test/mjsunit/fast-prototype.js#L48-L63
    		if (fastProto !== null && typeof fastProto.property) {
    			const result = fastProto;
    			fastProto = FastObject.prototype = null;
    			return result;
    		}
    		fastProto = FastObject.prototype = o == null ? Object.create(null) : o;
    		return new FastObject;
    	}

    	// Initialize the inline property cache of FastObject
    	FastObject();

    	toFastProperties = function toFastproperties(o) {
    		return FastObject(o);
    	};
    	return toFastProperties;
    }

    var global$1 = (typeof global !== "undefined" ? global :
      typeof self !== "undefined" ? self :
      typeof window !== "undefined" ? window : {});

    // shim for using process in browser
    // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout () {
        throw new Error('clearTimeout has not been defined');
    }
    var cachedSetTimeout = defaultSetTimout;
    var cachedClearTimeout = defaultClearTimeout;
    if (typeof global$1.setTimeout === 'function') {
        cachedSetTimeout = setTimeout;
    }
    if (typeof global$1.clearTimeout === 'function') {
        cachedClearTimeout = clearTimeout;
    }

    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch(e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch(e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }


    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }



    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }
    function nextTick(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    }
    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    var title = 'browser';
    var platform = 'browser';
    var browser = true;
    var env = {};
    var argv = [];
    var version = ''; // empty string to avoid regexp issues
    var versions = {};
    var release = {};
    var config = {};

    function noop() {}

    var on = noop;
    var addListener = noop;
    var once = noop;
    var off = noop;
    var removeListener = noop;
    var removeAllListeners = noop;
    var emit = noop;

    function binding(name) {
        throw new Error('process.binding is not supported');
    }

    function cwd () { return '/' }
    function chdir (dir) {
        throw new Error('process.chdir is not supported');
    }function umask() { return 0; }

    // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
    var performance = global$1.performance || {};
    var performanceNow =
      performance.now        ||
      performance.mozNow     ||
      performance.msNow      ||
      performance.oNow       ||
      performance.webkitNow  ||
      function(){ return (new Date()).getTime() };

    // generate timestamp or delta
    // see http://nodejs.org/api/process.html#process_process_hrtime
    function hrtime(previousTimestamp){
      var clocktime = performanceNow.call(performance)*1e-3;
      var seconds = Math.floor(clocktime);
      var nanoseconds = Math.floor((clocktime%1)*1e9);
      if (previousTimestamp) {
        seconds = seconds - previousTimestamp[0];
        nanoseconds = nanoseconds - previousTimestamp[1];
        if (nanoseconds<0) {
          seconds--;
          nanoseconds += 1e9;
        }
      }
      return [seconds,nanoseconds]
    }

    var startTime = new Date();
    function uptime() {
      var currentTime = new Date();
      var dif = currentTime - startTime;
      return dif / 1000;
    }

    var browser$1 = {
      nextTick: nextTick,
      title: title,
      browser: browser,
      env: env,
      argv: argv,
      version: version,
      versions: versions,
      on: on,
      addListener: addListener,
      once: once,
      off: off,
      removeListener: removeListener,
      removeAllListeners: removeAllListeners,
      emit: emit,
      binding: binding,
      cwd: cwd,
      chdir: chdir,
      umask: umask,
      hrtime: hrtime,
      platform: platform,
      release: release,
      config: config,
      uptime: uptime
    };

    var process$1 = browser$1;

    var core = {};

    var is = {};

    var isType = {};

    var hasRequiredIsType;

    function requireIsType () {
    	if (hasRequiredIsType) return isType;
    	hasRequiredIsType = 1;

    	Object.defineProperty(isType, "__esModule", {
    	  value: true
    	});
    	isType.default = isType$1;
    	var _index = requireDefinitions();
    	function isType$1(nodeType, targetType) {
    	  if (nodeType === targetType) return true;
    	  if (nodeType == null) return false;
    	  if (_index.ALIAS_KEYS[targetType]) return false;
    	  const aliases = _index.FLIPPED_ALIAS_KEYS[targetType];
    	  if (aliases) {
    	    if (aliases[0] === nodeType) return true;
    	    for (const alias of aliases) {
    	      if (nodeType === alias) return true;
    	    }
    	  }
    	  return false;
    	}

    	
    	return isType;
    }

    var isPlaceholderType = {};

    var hasRequiredIsPlaceholderType;

    function requireIsPlaceholderType () {
    	if (hasRequiredIsPlaceholderType) return isPlaceholderType;
    	hasRequiredIsPlaceholderType = 1;

    	Object.defineProperty(isPlaceholderType, "__esModule", {
    	  value: true
    	});
    	isPlaceholderType.default = isPlaceholderType$1;
    	var _index = requireDefinitions();
    	function isPlaceholderType$1(placeholderType, targetType) {
    	  if (placeholderType === targetType) return true;
    	  const aliases = _index.PLACEHOLDERS_ALIAS[placeholderType];
    	  if (aliases) {
    	    for (const alias of aliases) {
    	      if (targetType === alias) return true;
    	    }
    	  }
    	  return false;
    	}

    	
    	return isPlaceholderType;
    }

    var hasRequiredIs;

    function requireIs () {
    	if (hasRequiredIs) return is;
    	hasRequiredIs = 1;

    	Object.defineProperty(is, "__esModule", {
    	  value: true
    	});
    	is.default = is$1;
    	var _shallowEqual = requireShallowEqual();
    	var _isType = requireIsType();
    	var _isPlaceholderType = requireIsPlaceholderType();
    	var _index = requireDefinitions();
    	function is$1(type, node, opts) {
    	  if (!node) return false;
    	  const matches = (0, _isType.default)(node.type, type);
    	  if (!matches) {
    	    if (!opts && node.type === "Placeholder" && type in _index.FLIPPED_ALIAS_KEYS) {
    	      return (0, _isPlaceholderType.default)(node.expectedNode, type);
    	    }
    	    return false;
    	  }
    	  if (typeof opts === "undefined") {
    	    return true;
    	  } else {
    	    return (0, _shallowEqual.default)(node, opts);
    	  }
    	}

    	
    	return is;
    }

    var isValidIdentifier = {};

    var lib$3 = {};

    var identifier = {};

    var hasRequiredIdentifier;

    function requireIdentifier () {
    	if (hasRequiredIdentifier) return identifier;
    	hasRequiredIdentifier = 1;

    	Object.defineProperty(identifier, "__esModule", {
    	  value: true
    	});
    	identifier.isIdentifierChar = isIdentifierChar;
    	identifier.isIdentifierName = isIdentifierName;
    	identifier.isIdentifierStart = isIdentifierStart;
    	let nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ca\ua7d0\ua7d1\ua7d3\ua7d5-\ua7d9\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
    	let nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0898-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\u30fb\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f\uff65";
    	const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    	const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    	nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    	const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
    	const astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    	function isInAstralSet(code, set) {
    	  let pos = 0x10000;
    	  for (let i = 0, length = set.length; i < length; i += 2) {
    	    pos += set[i];
    	    if (pos > code) return false;
    	    pos += set[i + 1];
    	    if (pos >= code) return true;
    	  }
    	  return false;
    	}
    	function isIdentifierStart(code) {
    	  if (code < 65) return code === 36;
    	  if (code <= 90) return true;
    	  if (code < 97) return code === 95;
    	  if (code <= 122) return true;
    	  if (code <= 0xffff) {
    	    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
    	  }
    	  return isInAstralSet(code, astralIdentifierStartCodes);
    	}
    	function isIdentifierChar(code) {
    	  if (code < 48) return code === 36;
    	  if (code < 58) return true;
    	  if (code < 65) return false;
    	  if (code <= 90) return true;
    	  if (code < 97) return code === 95;
    	  if (code <= 122) return true;
    	  if (code <= 0xffff) {
    	    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
    	  }
    	  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    	}
    	function isIdentifierName(name) {
    	  let isFirst = true;
    	  for (let i = 0; i < name.length; i++) {
    	    let cp = name.charCodeAt(i);
    	    if ((cp & 0xfc00) === 0xd800 && i + 1 < name.length) {
    	      const trail = name.charCodeAt(++i);
    	      if ((trail & 0xfc00) === 0xdc00) {
    	        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);
    	      }
    	    }
    	    if (isFirst) {
    	      isFirst = false;
    	      if (!isIdentifierStart(cp)) {
    	        return false;
    	      }
    	    } else if (!isIdentifierChar(cp)) {
    	      return false;
    	    }
    	  }
    	  return !isFirst;
    	}

    	
    	return identifier;
    }

    var keyword = {};

    var hasRequiredKeyword;

    function requireKeyword () {
    	if (hasRequiredKeyword) return keyword;
    	hasRequiredKeyword = 1;

    	Object.defineProperty(keyword, "__esModule", {
    	  value: true
    	});
    	keyword.isKeyword = isKeyword;
    	keyword.isReservedWord = isReservedWord;
    	keyword.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
    	keyword.isStrictBindReservedWord = isStrictBindReservedWord;
    	keyword.isStrictReservedWord = isStrictReservedWord;
    	const reservedWords = {
    	  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    	  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    	  strictBind: ["eval", "arguments"]
    	};
    	const keywords = new Set(reservedWords.keyword);
    	const reservedWordsStrictSet = new Set(reservedWords.strict);
    	const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    	function isReservedWord(word, inModule) {
    	  return inModule && word === "await" || word === "enum";
    	}
    	function isStrictReservedWord(word, inModule) {
    	  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    	}
    	function isStrictBindOnlyReservedWord(word) {
    	  return reservedWordsStrictBindSet.has(word);
    	}
    	function isStrictBindReservedWord(word, inModule) {
    	  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    	}
    	function isKeyword(word) {
    	  return keywords.has(word);
    	}

    	
    	return keyword;
    }

    var hasRequiredLib$4;

    function requireLib$4 () {
    	if (hasRequiredLib$4) return lib$3;
    	hasRequiredLib$4 = 1;
    	(function (exports) {

    		Object.defineProperty(exports, "__esModule", {
    		  value: true
    		});
    		Object.defineProperty(exports, "isIdentifierChar", {
    		  enumerable: true,
    		  get: function () {
    		    return _identifier.isIdentifierChar;
    		  }
    		});
    		Object.defineProperty(exports, "isIdentifierName", {
    		  enumerable: true,
    		  get: function () {
    		    return _identifier.isIdentifierName;
    		  }
    		});
    		Object.defineProperty(exports, "isIdentifierStart", {
    		  enumerable: true,
    		  get: function () {
    		    return _identifier.isIdentifierStart;
    		  }
    		});
    		Object.defineProperty(exports, "isKeyword", {
    		  enumerable: true,
    		  get: function () {
    		    return _keyword.isKeyword;
    		  }
    		});
    		Object.defineProperty(exports, "isReservedWord", {
    		  enumerable: true,
    		  get: function () {
    		    return _keyword.isReservedWord;
    		  }
    		});
    		Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
    		  enumerable: true,
    		  get: function () {
    		    return _keyword.isStrictBindOnlyReservedWord;
    		  }
    		});
    		Object.defineProperty(exports, "isStrictBindReservedWord", {
    		  enumerable: true,
    		  get: function () {
    		    return _keyword.isStrictBindReservedWord;
    		  }
    		});
    		Object.defineProperty(exports, "isStrictReservedWord", {
    		  enumerable: true,
    		  get: function () {
    		    return _keyword.isStrictReservedWord;
    		  }
    		});
    		var _identifier = requireIdentifier();
    		var _keyword = requireKeyword();

    		
    	} (lib$3));
    	return lib$3;
    }

    var hasRequiredIsValidIdentifier;

    function requireIsValidIdentifier () {
    	if (hasRequiredIsValidIdentifier) return isValidIdentifier;
    	hasRequiredIsValidIdentifier = 1;

    	Object.defineProperty(isValidIdentifier, "__esModule", {
    	  value: true
    	});
    	isValidIdentifier.default = isValidIdentifier$1;
    	var _helperValidatorIdentifier = requireLib$4();
    	function isValidIdentifier$1(name, reserved = true) {
    	  if (typeof name !== "string") return false;
    	  if (reserved) {
    	    if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) {
    	      return false;
    	    }
    	  }
    	  return (0, _helperValidatorIdentifier.isIdentifierName)(name);
    	}

    	
    	return isValidIdentifier;
    }

    var lib$2 = {};

    var hasRequiredLib$3;

    function requireLib$3 () {
    	if (hasRequiredLib$3) return lib$2;
    	hasRequiredLib$3 = 1;

    	Object.defineProperty(lib$2, "__esModule", {
    	  value: true
    	});
    	lib$2.readCodePoint = readCodePoint;
    	lib$2.readInt = readInt;
    	lib$2.readStringContents = readStringContents;
    	var _isDigit = function isDigit(code) {
    	  return code >= 48 && code <= 57;
    	};
    	const forbiddenNumericSeparatorSiblings = {
    	  decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    	  hex: new Set([46, 88, 95, 120])
    	};
    	const isAllowedNumericSeparatorSibling = {
    	  bin: ch => ch === 48 || ch === 49,
    	  oct: ch => ch >= 48 && ch <= 55,
    	  dec: ch => ch >= 48 && ch <= 57,
    	  hex: ch => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
    	};
    	function readStringContents(type, input, pos, lineStart, curLine, errors) {
    	  const initialPos = pos;
    	  const initialLineStart = lineStart;
    	  const initialCurLine = curLine;
    	  let out = "";
    	  let firstInvalidLoc = null;
    	  let chunkStart = pos;
    	  const {
    	    length
    	  } = input;
    	  for (;;) {
    	    if (pos >= length) {
    	      errors.unterminated(initialPos, initialLineStart, initialCurLine);
    	      out += input.slice(chunkStart, pos);
    	      break;
    	    }
    	    const ch = input.charCodeAt(pos);
    	    if (isStringEnd(type, ch, input, pos)) {
    	      out += input.slice(chunkStart, pos);
    	      break;
    	    }
    	    if (ch === 92) {
    	      out += input.slice(chunkStart, pos);
    	      const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
    	      if (res.ch === null && !firstInvalidLoc) {
    	        firstInvalidLoc = {
    	          pos,
    	          lineStart,
    	          curLine
    	        };
    	      } else {
    	        out += res.ch;
    	      }
    	      ({
    	        pos,
    	        lineStart,
    	        curLine
    	      } = res);
    	      chunkStart = pos;
    	    } else if (ch === 8232 || ch === 8233) {
    	      ++pos;
    	      ++curLine;
    	      lineStart = pos;
    	    } else if (ch === 10 || ch === 13) {
    	      if (type === "template") {
    	        out += input.slice(chunkStart, pos) + "\n";
    	        ++pos;
    	        if (ch === 13 && input.charCodeAt(pos) === 10) {
    	          ++pos;
    	        }
    	        ++curLine;
    	        chunkStart = lineStart = pos;
    	      } else {
    	        errors.unterminated(initialPos, initialLineStart, initialCurLine);
    	      }
    	    } else {
    	      ++pos;
    	    }
    	  }
    	  return {
    	    pos,
    	    str: out,
    	    firstInvalidLoc,
    	    lineStart,
    	    curLine,
    	    containsInvalid: !!firstInvalidLoc
    	  };
    	}
    	function isStringEnd(type, ch, input, pos) {
    	  if (type === "template") {
    	    return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
    	  }
    	  return ch === (type === "double" ? 34 : 39);
    	}
    	function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
    	  const throwOnInvalid = !inTemplate;
    	  pos++;
    	  const res = ch => ({
    	    pos,
    	    ch,
    	    lineStart,
    	    curLine
    	  });
    	  const ch = input.charCodeAt(pos++);
    	  switch (ch) {
    	    case 110:
    	      return res("\n");
    	    case 114:
    	      return res("\r");
    	    case 120:
    	      {
    	        let code;
    	        ({
    	          code,
    	          pos
    	        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
    	        return res(code === null ? null : String.fromCharCode(code));
    	      }
    	    case 117:
    	      {
    	        let code;
    	        ({
    	          code,
    	          pos
    	        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
    	        return res(code === null ? null : String.fromCodePoint(code));
    	      }
    	    case 116:
    	      return res("\t");
    	    case 98:
    	      return res("\b");
    	    case 118:
    	      return res("\u000b");
    	    case 102:
    	      return res("\f");
    	    case 13:
    	      if (input.charCodeAt(pos) === 10) {
    	        ++pos;
    	      }
    	    case 10:
    	      lineStart = pos;
    	      ++curLine;
    	    case 8232:
    	    case 8233:
    	      return res("");
    	    case 56:
    	    case 57:
    	      if (inTemplate) {
    	        return res(null);
    	      } else {
    	        errors.strictNumericEscape(pos - 1, lineStart, curLine);
    	      }
    	    default:
    	      if (ch >= 48 && ch <= 55) {
    	        const startPos = pos - 1;
    	        const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
    	        let octalStr = match[0];
    	        let octal = parseInt(octalStr, 8);
    	        if (octal > 255) {
    	          octalStr = octalStr.slice(0, -1);
    	          octal = parseInt(octalStr, 8);
    	        }
    	        pos += octalStr.length - 1;
    	        const next = input.charCodeAt(pos);
    	        if (octalStr !== "0" || next === 56 || next === 57) {
    	          if (inTemplate) {
    	            return res(null);
    	          } else {
    	            errors.strictNumericEscape(startPos, lineStart, curLine);
    	          }
    	        }
    	        return res(String.fromCharCode(octal));
    	      }
    	      return res(String.fromCharCode(ch));
    	  }
    	}
    	function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
    	  const initialPos = pos;
    	  let n;
    	  ({
    	    n,
    	    pos
    	  } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
    	  if (n === null) {
    	    if (throwOnInvalid) {
    	      errors.invalidEscapeSequence(initialPos, lineStart, curLine);
    	    } else {
    	      pos = initialPos - 1;
    	    }
    	  }
    	  return {
    	    code: n,
    	    pos
    	  };
    	}
    	function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
    	  const start = pos;
    	  const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
    	  const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
    	  let invalid = false;
    	  let total = 0;
    	  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
    	    const code = input.charCodeAt(pos);
    	    let val;
    	    if (code === 95 && allowNumSeparator !== "bail") {
    	      const prev = input.charCodeAt(pos - 1);
    	      const next = input.charCodeAt(pos + 1);
    	      if (!allowNumSeparator) {
    	        if (bailOnError) return {
    	          n: null,
    	          pos
    	        };
    	        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
    	      } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
    	        if (bailOnError) return {
    	          n: null,
    	          pos
    	        };
    	        errors.unexpectedNumericSeparator(pos, lineStart, curLine);
    	      }
    	      ++pos;
    	      continue;
    	    }
    	    if (code >= 97) {
    	      val = code - 97 + 10;
    	    } else if (code >= 65) {
    	      val = code - 65 + 10;
    	    } else if (_isDigit(code)) {
    	      val = code - 48;
    	    } else {
    	      val = Infinity;
    	    }
    	    if (val >= radix) {
    	      if (val <= 9 && bailOnError) {
    	        return {
    	          n: null,
    	          pos
    	        };
    	      } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
    	        val = 0;
    	      } else if (forceLen) {
    	        val = 0;
    	        invalid = true;
    	      } else {
    	        break;
    	      }
    	    }
    	    ++pos;
    	    total = total * radix + val;
    	  }
    	  if (pos === start || len != null && pos - start !== len || invalid) {
    	    return {
    	      n: null,
    	      pos
    	    };
    	  }
    	  return {
    	    n: total,
    	    pos
    	  };
    	}
    	function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
    	  const ch = input.charCodeAt(pos);
    	  let code;
    	  if (ch === 123) {
    	    ++pos;
    	    ({
    	      code,
    	      pos
    	    } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
    	    ++pos;
    	    if (code !== null && code > 0x10ffff) {
    	      if (throwOnInvalid) {
    	        errors.invalidCodePoint(pos, lineStart, curLine);
    	      } else {
    	        return {
    	          code: null,
    	          pos
    	        };
    	      }
    	    }
    	  } else {
    	    ({
    	      code,
    	      pos
    	    } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
    	  }
    	  return {
    	    code,
    	    pos
    	  };
    	}

    	
    	return lib$2;
    }

    var constants = {};

    var hasRequiredConstants;

    function requireConstants () {
    	if (hasRequiredConstants) return constants;
    	hasRequiredConstants = 1;

    	Object.defineProperty(constants, "__esModule", {
    	  value: true
    	});
    	constants.UPDATE_OPERATORS = constants.UNARY_OPERATORS = constants.STRING_UNARY_OPERATORS = constants.STATEMENT_OR_BLOCK_KEYS = constants.NUMBER_UNARY_OPERATORS = constants.NUMBER_BINARY_OPERATORS = constants.NOT_LOCAL_BINDING = constants.LOGICAL_OPERATORS = constants.INHERIT_KEYS = constants.FOR_INIT_KEYS = constants.FLATTENABLE_KEYS = constants.EQUALITY_BINARY_OPERATORS = constants.COMPARISON_BINARY_OPERATORS = constants.COMMENT_KEYS = constants.BOOLEAN_UNARY_OPERATORS = constants.BOOLEAN_NUMBER_BINARY_OPERATORS = constants.BOOLEAN_BINARY_OPERATORS = constants.BLOCK_SCOPED_SYMBOL = constants.BINARY_OPERATORS = constants.ASSIGNMENT_OPERATORS = void 0;
    	const STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
    	constants.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
    	const FLATTENABLE_KEYS = ["body", "expressions"];
    	constants.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
    	const FOR_INIT_KEYS = ["left", "init"];
    	constants.FOR_INIT_KEYS = FOR_INIT_KEYS;
    	const COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
    	constants.COMMENT_KEYS = COMMENT_KEYS;
    	const LOGICAL_OPERATORS = ["||", "&&", "??"];
    	constants.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
    	const UPDATE_OPERATORS = ["++", "--"];
    	constants.UPDATE_OPERATORS = UPDATE_OPERATORS;
    	const BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
    	constants.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
    	const EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
    	constants.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
    	const COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
    	constants.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
    	const BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
    	constants.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
    	const NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
    	constants.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
    	const BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS, "|>"];
    	constants.BINARY_OPERATORS = BINARY_OPERATORS;
    	const ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map(op => op + "="), ...LOGICAL_OPERATORS.map(op => op + "=")];
    	constants.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;
    	const BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
    	constants.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
    	const NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
    	constants.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
    	const STRING_UNARY_OPERATORS = ["typeof"];
    	constants.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
    	const UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
    	constants.UNARY_OPERATORS = UNARY_OPERATORS;
    	const INHERIT_KEYS = {
    	  optional: ["typeAnnotation", "typeParameters", "returnType"],
    	  force: ["start", "loc", "end"]
    	};
    	constants.INHERIT_KEYS = INHERIT_KEYS;
    	const BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
    	constants.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
    	const NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
    	constants.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;

    	
    	return constants;
    }

    var utils = {};

    var hasRequiredUtils;

    function requireUtils () {
    	if (hasRequiredUtils) return utils;
    	hasRequiredUtils = 1;

    	Object.defineProperty(utils, "__esModule", {
    	  value: true
    	});
    	utils.VISITOR_KEYS = utils.NODE_PARENT_VALIDATIONS = utils.NODE_FIELDS = utils.FLIPPED_ALIAS_KEYS = utils.DEPRECATED_KEYS = utils.BUILDER_KEYS = utils.ALIAS_KEYS = void 0;
    	utils.arrayOf = arrayOf;
    	utils.arrayOfType = arrayOfType;
    	utils.assertEach = assertEach;
    	utils.assertNodeOrValueType = assertNodeOrValueType;
    	utils.assertNodeType = assertNodeType;
    	utils.assertOneOf = assertOneOf;
    	utils.assertOptionalChainStart = assertOptionalChainStart;
    	utils.assertShape = assertShape;
    	utils.assertValueType = assertValueType;
    	utils.chain = chain;
    	utils.default = defineType;
    	utils.defineAliasedType = defineAliasedType;
    	utils.typeIs = typeIs;
    	utils.validate = validate;
    	utils.validateArrayOfType = validateArrayOfType;
    	utils.validateOptional = validateOptional;
    	utils.validateOptionalType = validateOptionalType;
    	utils.validateType = validateType;
    	var _is = requireIs();
    	var _validate = requireValidate();
    	const VISITOR_KEYS = {};
    	utils.VISITOR_KEYS = VISITOR_KEYS;
    	const ALIAS_KEYS = {};
    	utils.ALIAS_KEYS = ALIAS_KEYS;
    	const FLIPPED_ALIAS_KEYS = {};
    	utils.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
    	const NODE_FIELDS = {};
    	utils.NODE_FIELDS = NODE_FIELDS;
    	const BUILDER_KEYS = {};
    	utils.BUILDER_KEYS = BUILDER_KEYS;
    	const DEPRECATED_KEYS = {};
    	utils.DEPRECATED_KEYS = DEPRECATED_KEYS;
    	const NODE_PARENT_VALIDATIONS = {};
    	utils.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;
    	function getType(val) {
    	  if (Array.isArray(val)) {
    	    return "array";
    	  } else if (val === null) {
    	    return "null";
    	  } else {
    	    return typeof val;
    	  }
    	}
    	function validate(validate) {
    	  return {
    	    validate
    	  };
    	}
    	function typeIs(typeName) {
    	  return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType(...typeName);
    	}
    	function validateType(typeName) {
    	  return validate(typeIs(typeName));
    	}
    	function validateOptional(validate) {
    	  return {
    	    validate,
    	    optional: true
    	  };
    	}
    	function validateOptionalType(typeName) {
    	  return {
    	    validate: typeIs(typeName),
    	    optional: true
    	  };
    	}
    	function arrayOf(elementType) {
    	  return chain(assertValueType("array"), assertEach(elementType));
    	}
    	function arrayOfType(typeName) {
    	  return arrayOf(typeIs(typeName));
    	}
    	function validateArrayOfType(typeName) {
    	  return validate(arrayOfType(typeName));
    	}
    	function assertEach(callback) {
    	  function validator(node, key, val) {
    	    if (!Array.isArray(val)) return;
    	    for (let i = 0; i < val.length; i++) {
    	      const subkey = `${key}[${i}]`;
    	      const v = val[i];
    	      callback(node, subkey, v);
    	      if (process$1.env.BABEL_TYPES_8_BREAKING) (0, _validate.validateChild)(node, subkey, v);
    	    }
    	  }
    	  validator.each = callback;
    	  return validator;
    	}
    	function assertOneOf(...values) {
    	  function validate(node, key, val) {
    	    if (values.indexOf(val) < 0) {
    	      throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
    	    }
    	  }
    	  validate.oneOf = values;
    	  return validate;
    	}
    	function assertNodeType(...types) {
    	  function validate(node, key, val) {
    	    for (const type of types) {
    	      if ((0, _is.default)(type, val)) {
    	        (0, _validate.validateChild)(node, key, val);
    	        return;
    	      }
    	    }
    	    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
    	  }
    	  validate.oneOfNodeTypes = types;
    	  return validate;
    	}
    	function assertNodeOrValueType(...types) {
    	  function validate(node, key, val) {
    	    for (const type of types) {
    	      if (getType(val) === type || (0, _is.default)(type, val)) {
    	        (0, _validate.validateChild)(node, key, val);
    	        return;
    	      }
    	    }
    	    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
    	  }
    	  validate.oneOfNodeOrValueTypes = types;
    	  return validate;
    	}
    	function assertValueType(type) {
    	  function validate(node, key, val) {
    	    const valid = getType(val) === type;
    	    if (!valid) {
    	      throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
    	    }
    	  }
    	  validate.type = type;
    	  return validate;
    	}
    	function assertShape(shape) {
    	  function validate(node, key, val) {
    	    const errors = [];
    	    for (const property of Object.keys(shape)) {
    	      try {
    	        (0, _validate.validateField)(node, property, val[property], shape[property]);
    	      } catch (error) {
    	        if (error instanceof TypeError) {
    	          errors.push(error.message);
    	          continue;
    	        }
    	        throw error;
    	      }
    	    }
    	    if (errors.length) {
    	      throw new TypeError(`Property ${key} of ${node.type} expected to have the following:\n${errors.join("\n")}`);
    	    }
    	  }
    	  validate.shapeOf = shape;
    	  return validate;
    	}
    	function assertOptionalChainStart() {
    	  function validate(node) {
    	    var _current;
    	    let current = node;
    	    while (node) {
    	      const {
    	        type
    	      } = current;
    	      if (type === "OptionalCallExpression") {
    	        if (current.optional) return;
    	        current = current.callee;
    	        continue;
    	      }
    	      if (type === "OptionalMemberExpression") {
    	        if (current.optional) return;
    	        current = current.object;
    	        continue;
    	      }
    	      break;
    	    }
    	    throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);
    	  }
    	  return validate;
    	}
    	function chain(...fns) {
    	  function validate(...args) {
    	    for (const fn of fns) {
    	      fn(...args);
    	    }
    	  }
    	  validate.chainOf = fns;
    	  if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {
    	    throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
    	  }
    	  return validate;
    	}
    	const validTypeOpts = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"];
    	const validFieldKeys = ["default", "optional", "deprecated", "validate"];
    	const store = {};
    	function defineAliasedType(...aliases) {
    	  return (type, opts = {}) => {
    	    let defined = opts.aliases;
    	    if (!defined) {
    	      var _store$opts$inherits$, _defined;
    	      if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();
    	      (_defined = defined) != null ? _defined : defined = [];
    	      opts.aliases = defined;
    	    }
    	    const additional = aliases.filter(a => !defined.includes(a));
    	    defined.unshift(...additional);
    	    defineType(type, opts);
    	  };
    	}
    	function defineType(type, opts = {}) {
    	  const inherits = opts.inherits && store[opts.inherits] || {};
    	  let fields = opts.fields;
    	  if (!fields) {
    	    fields = {};
    	    if (inherits.fields) {
    	      const keys = Object.getOwnPropertyNames(inherits.fields);
    	      for (const key of keys) {
    	        const field = inherits.fields[key];
    	        const def = field.default;
    	        if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") {
    	          throw new Error("field defaults can only be primitives or empty arrays currently");
    	        }
    	        fields[key] = {
    	          default: Array.isArray(def) ? [] : def,
    	          optional: field.optional,
    	          deprecated: field.deprecated,
    	          validate: field.validate
    	        };
    	      }
    	    }
    	  }
    	  const visitor = opts.visitor || inherits.visitor || [];
    	  const aliases = opts.aliases || inherits.aliases || [];
    	  const builder = opts.builder || inherits.builder || opts.visitor || [];
    	  for (const k of Object.keys(opts)) {
    	    if (validTypeOpts.indexOf(k) === -1) {
    	      throw new Error(`Unknown type option "${k}" on ${type}`);
    	    }
    	  }
    	  if (opts.deprecatedAlias) {
    	    DEPRECATED_KEYS[opts.deprecatedAlias] = type;
    	  }
    	  for (const key of visitor.concat(builder)) {
    	    fields[key] = fields[key] || {};
    	  }
    	  for (const key of Object.keys(fields)) {
    	    const field = fields[key];
    	    if (field.default !== undefined && builder.indexOf(key) === -1) {
    	      field.optional = true;
    	    }
    	    if (field.default === undefined) {
    	      field.default = null;
    	    } else if (!field.validate && field.default != null) {
    	      field.validate = assertValueType(getType(field.default));
    	    }
    	    for (const k of Object.keys(field)) {
    	      if (validFieldKeys.indexOf(k) === -1) {
    	        throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
    	      }
    	    }
    	  }
    	  VISITOR_KEYS[type] = opts.visitor = visitor;
    	  BUILDER_KEYS[type] = opts.builder = builder;
    	  NODE_FIELDS[type] = opts.fields = fields;
    	  ALIAS_KEYS[type] = opts.aliases = aliases;
    	  aliases.forEach(alias => {
    	    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
    	    FLIPPED_ALIAS_KEYS[alias].push(type);
    	  });
    	  if (opts.validate) {
    	    NODE_PARENT_VALIDATIONS[type] = opts.validate;
    	  }
    	  store[type] = opts;
    	}

    	
    	return utils;
    }

    var hasRequiredCore;

    function requireCore () {
    	if (hasRequiredCore) return core;
    	hasRequiredCore = 1;

    	Object.defineProperty(core, "__esModule", {
    	  value: true
    	});
    	core.patternLikeCommon = core.functionTypeAnnotationCommon = core.functionDeclarationCommon = core.functionCommon = core.classMethodOrPropertyCommon = core.classMethodOrDeclareMethodCommon = void 0;
    	var _is = requireIs();
    	var _isValidIdentifier = requireIsValidIdentifier();
    	var _helperValidatorIdentifier = requireLib$4();
    	var _helperStringParser = requireLib$3();
    	var _index = requireConstants();
    	var _utils = requireUtils();
    	const defineType = (0, _utils.defineAliasedType)("Standardized");
    	defineType("ArrayExpression", {
    	  fields: {
    	    elements: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
    	      default: !process$1.env.BABEL_TYPES_8_BREAKING ? [] : undefined
    	    }
    	  },
    	  visitor: ["elements"],
    	  aliases: ["Expression"]
    	});
    	defineType("AssignmentExpression", {
    	  fields: {
    	    operator: {
    	      validate: function () {
    	        if (!process$1.env.BABEL_TYPES_8_BREAKING) {
    	          return (0, _utils.assertValueType)("string");
    	        }
    	        const identifier = (0, _utils.assertOneOf)(..._index.ASSIGNMENT_OPERATORS);
    	        const pattern = (0, _utils.assertOneOf)("=");
    	        return function (node, key, val) {
    	          const validator = (0, _is.default)("Pattern", node.left) ? pattern : identifier;
    	          validator(node, key, val);
    	        };
    	      }()
    	    },
    	    left: {
    	      validate: !process$1.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal", "OptionalMemberExpression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
    	    },
    	    right: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    }
    	  },
    	  builder: ["operator", "left", "right"],
    	  visitor: ["left", "right"],
    	  aliases: ["Expression"]
    	});
    	defineType("BinaryExpression", {
    	  builder: ["operator", "left", "right"],
    	  fields: {
    	    operator: {
    	      validate: (0, _utils.assertOneOf)(..._index.BINARY_OPERATORS)
    	    },
    	    left: {
    	      validate: function () {
    	        const expression = (0, _utils.assertNodeType)("Expression");
    	        const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
    	        const validator = Object.assign(function (node, key, val) {
    	          const validator = node.operator === "in" ? inOp : expression;
    	          validator(node, key, val);
    	        }, {
    	          oneOfNodeTypes: ["Expression", "PrivateName"]
    	        });
    	        return validator;
    	      }()
    	    },
    	    right: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    }
    	  },
    	  visitor: ["left", "right"],
    	  aliases: ["Binary", "Expression"]
    	});
    	defineType("InterpreterDirective", {
    	  builder: ["value"],
    	  fields: {
    	    value: {
    	      validate: (0, _utils.assertValueType)("string")
    	    }
    	  }
    	});
    	defineType("Directive", {
    	  visitor: ["value"],
    	  fields: {
    	    value: {
    	      validate: (0, _utils.assertNodeType)("DirectiveLiteral")
    	    }
    	  }
    	});
    	defineType("DirectiveLiteral", {
    	  builder: ["value"],
    	  fields: {
    	    value: {
    	      validate: (0, _utils.assertValueType)("string")
    	    }
    	  }
    	});
    	defineType("BlockStatement", {
    	  builder: ["body", "directives"],
    	  visitor: ["directives", "body"],
    	  fields: {
    	    directives: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
    	      default: []
    	    },
    	    body: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
    	    }
    	  },
    	  aliases: ["Scopable", "BlockParent", "Block", "Statement"]
    	});
    	defineType("BreakStatement", {
    	  visitor: ["label"],
    	  fields: {
    	    label: {
    	      validate: (0, _utils.assertNodeType)("Identifier"),
    	      optional: true
    	    }
    	  },
    	  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    	});
    	defineType("CallExpression", {
    	  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    	  builder: ["callee", "arguments"],
    	  aliases: ["Expression"],
    	  fields: Object.assign({
    	    callee: {
    	      validate: (0, _utils.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
    	    },
    	    arguments: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
    	    }
    	  }, !process$1.env.BABEL_TYPES_8_BREAKING ? {
    	    optional: {
    	      validate: (0, _utils.assertOneOf)(true, false),
    	      optional: true
    	    }
    	  } : {}, {
    	    typeArguments: {
    	      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
    	      optional: true
    	    },
    	    typeParameters: {
    	      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
    	      optional: true
    	    }
    	  })
    	});
    	defineType("CatchClause", {
    	  visitor: ["param", "body"],
    	  fields: {
    	    param: {
    	      validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
    	      optional: true
    	    },
    	    body: {
    	      validate: (0, _utils.assertNodeType)("BlockStatement")
    	    }
    	  },
    	  aliases: ["Scopable", "BlockParent"]
    	});
    	defineType("ConditionalExpression", {
    	  visitor: ["test", "consequent", "alternate"],
    	  fields: {
    	    test: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    },
    	    consequent: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    },
    	    alternate: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    }
    	  },
    	  aliases: ["Expression", "Conditional"]
    	});
    	defineType("ContinueStatement", {
    	  visitor: ["label"],
    	  fields: {
    	    label: {
    	      validate: (0, _utils.assertNodeType)("Identifier"),
    	      optional: true
    	    }
    	  },
    	  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    	});
    	defineType("DebuggerStatement", {
    	  aliases: ["Statement"]
    	});
    	defineType("DoWhileStatement", {
    	  visitor: ["test", "body"],
    	  fields: {
    	    test: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    },
    	    body: {
    	      validate: (0, _utils.assertNodeType)("Statement")
    	    }
    	  },
    	  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
    	});
    	defineType("EmptyStatement", {
    	  aliases: ["Statement"]
    	});
    	defineType("ExpressionStatement", {
    	  visitor: ["expression"],
    	  fields: {
    	    expression: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    }
    	  },
    	  aliases: ["Statement", "ExpressionWrapper"]
    	});
    	defineType("File", {
    	  builder: ["program", "comments", "tokens"],
    	  visitor: ["program"],
    	  fields: {
    	    program: {
    	      validate: (0, _utils.assertNodeType)("Program")
    	    },
    	    comments: {
    	      validate: !process$1.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {
    	        each: {
    	          oneOfNodeTypes: ["CommentBlock", "CommentLine"]
    	        }
    	      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
    	      optional: true
    	    },
    	    tokens: {
    	      validate: (0, _utils.assertEach)(Object.assign(() => {}, {
    	        type: "any"
    	      })),
    	      optional: true
    	    }
    	  }
    	});
    	defineType("ForInStatement", {
    	  visitor: ["left", "right", "body"],
    	  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    	  fields: {
    	    left: {
    	      validate: !process$1.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
    	    },
    	    right: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    },
    	    body: {
    	      validate: (0, _utils.assertNodeType)("Statement")
    	    }
    	  }
    	});
    	defineType("ForStatement", {
    	  visitor: ["init", "test", "update", "body"],
    	  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    	  fields: {
    	    init: {
    	      validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
    	      optional: true
    	    },
    	    test: {
    	      validate: (0, _utils.assertNodeType)("Expression"),
    	      optional: true
    	    },
    	    update: {
    	      validate: (0, _utils.assertNodeType)("Expression"),
    	      optional: true
    	    },
    	    body: {
    	      validate: (0, _utils.assertNodeType)("Statement")
    	    }
    	  }
    	});
    	const functionCommon = () => ({
    	  params: {
    	    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement")))
    	  },
    	  generator: {
    	    default: false
    	  },
    	  async: {
    	    default: false
    	  }
    	});
    	core.functionCommon = functionCommon;
    	const functionTypeAnnotationCommon = () => ({
    	  returnType: {
    	    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
    	    optional: true
    	  },
    	  typeParameters: {
    	    validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
    	    optional: true
    	  }
    	});
    	core.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
    	const functionDeclarationCommon = () => Object.assign({}, functionCommon(), {
    	  declare: {
    	    validate: (0, _utils.assertValueType)("boolean"),
    	    optional: true
    	  },
    	  id: {
    	    validate: (0, _utils.assertNodeType)("Identifier"),
    	    optional: true
    	  }
    	});
    	core.functionDeclarationCommon = functionDeclarationCommon;
    	defineType("FunctionDeclaration", {
    	  builder: ["id", "params", "body", "generator", "async"],
    	  visitor: ["id", "params", "body", "returnType", "typeParameters"],
    	  fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
    	    body: {
    	      validate: (0, _utils.assertNodeType)("BlockStatement")
    	    },
    	    predicate: {
    	      validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
    	      optional: true
    	    }
    	  }),
    	  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    	  validate: function () {
    	    if (!process$1.env.BABEL_TYPES_8_BREAKING) return () => {};
    	    const identifier = (0, _utils.assertNodeType)("Identifier");
    	    return function (parent, key, node) {
    	      if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
    	        identifier(node, "id", node.id);
    	      }
    	    };
    	  }()
    	});
    	defineType("FunctionExpression", {
    	  inherits: "FunctionDeclaration",
    	  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    	  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
    	    id: {
    	      validate: (0, _utils.assertNodeType)("Identifier"),
    	      optional: true
    	    },
    	    body: {
    	      validate: (0, _utils.assertNodeType)("BlockStatement")
    	    },
    	    predicate: {
    	      validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
    	      optional: true
    	    }
    	  })
    	});
    	const patternLikeCommon = () => ({
    	  typeAnnotation: {
    	    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
    	    optional: true
    	  },
    	  optional: {
    	    validate: (0, _utils.assertValueType)("boolean"),
    	    optional: true
    	  },
    	  decorators: {
    	    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
    	    optional: true
    	  }
    	});
    	core.patternLikeCommon = patternLikeCommon;
    	defineType("Identifier", {
    	  builder: ["name"],
    	  visitor: ["typeAnnotation", "decorators"],
    	  aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    	  fields: Object.assign({}, patternLikeCommon(), {
    	    name: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function (node, key, val) {
    	        if (!process$1.env.BABEL_TYPES_8_BREAKING) return;
    	        if (!(0, _isValidIdentifier.default)(val, false)) {
    	          throw new TypeError(`"${val}" is not a valid identifier name`);
    	        }
    	      }, {
    	        type: "string"
    	      }))
    	    }
    	  }),
    	  validate(parent, key, node) {
    	    if (!process$1.env.BABEL_TYPES_8_BREAKING) return;
    	    const match = /\.(\w+)$/.exec(key);
    	    if (!match) return;
    	    const [, parentKey] = match;
    	    const nonComp = {
    	      computed: false
    	    };
    	    if (parentKey === "property") {
    	      if ((0, _is.default)("MemberExpression", parent, nonComp)) return;
    	      if ((0, _is.default)("OptionalMemberExpression", parent, nonComp)) return;
    	    } else if (parentKey === "key") {
    	      if ((0, _is.default)("Property", parent, nonComp)) return;
    	      if ((0, _is.default)("Method", parent, nonComp)) return;
    	    } else if (parentKey === "exported") {
    	      if ((0, _is.default)("ExportSpecifier", parent)) return;
    	    } else if (parentKey === "imported") {
    	      if ((0, _is.default)("ImportSpecifier", parent, {
    	        imported: node
    	      })) return;
    	    } else if (parentKey === "meta") {
    	      if ((0, _is.default)("MetaProperty", parent, {
    	        meta: node
    	      })) return;
    	    }
    	    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== "this") {
    	      throw new TypeError(`"${node.name}" is not a valid identifier`);
    	    }
    	  }
    	});
    	defineType("IfStatement", {
    	  visitor: ["test", "consequent", "alternate"],
    	  aliases: ["Statement", "Conditional"],
    	  fields: {
    	    test: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    },
    	    consequent: {
    	      validate: (0, _utils.assertNodeType)("Statement")
    	    },
    	    alternate: {
    	      optional: true,
    	      validate: (0, _utils.assertNodeType)("Statement")
    	    }
    	  }
    	});
    	defineType("LabeledStatement", {
    	  visitor: ["label", "body"],
    	  aliases: ["Statement"],
    	  fields: {
    	    label: {
    	      validate: (0, _utils.assertNodeType)("Identifier")
    	    },
    	    body: {
    	      validate: (0, _utils.assertNodeType)("Statement")
    	    }
    	  }
    	});
    	defineType("StringLiteral", {
    	  builder: ["value"],
    	  fields: {
    	    value: {
    	      validate: (0, _utils.assertValueType)("string")
    	    }
    	  },
    	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    	});
    	defineType("NumericLiteral", {
    	  builder: ["value"],
    	  deprecatedAlias: "NumberLiteral",
    	  fields: {
    	    value: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("number"), Object.assign(function (node, key, val) {
    	      }, {
    	        type: "number"
    	      }))
    	    }
    	  },
    	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    	});
    	defineType("NullLiteral", {
    	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    	});
    	defineType("BooleanLiteral", {
    	  builder: ["value"],
    	  fields: {
    	    value: {
    	      validate: (0, _utils.assertValueType)("boolean")
    	    }
    	  },
    	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    	});
    	defineType("RegExpLiteral", {
    	  builder: ["pattern", "flags"],
    	  deprecatedAlias: "RegexLiteral",
    	  aliases: ["Expression", "Pureish", "Literal"],
    	  fields: {
    	    pattern: {
    	      validate: (0, _utils.assertValueType)("string")
    	    },
    	    flags: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function (node, key, val) {
    	        if (!process$1.env.BABEL_TYPES_8_BREAKING) return;
    	        const invalid = /[^gimsuy]/.exec(val);
    	        if (invalid) {
    	          throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
    	        }
    	      }, {
    	        type: "string"
    	      })),
    	      default: ""
    	    }
    	  }
    	});
    	defineType("LogicalExpression", {
    	  builder: ["operator", "left", "right"],
    	  visitor: ["left", "right"],
    	  aliases: ["Binary", "Expression"],
    	  fields: {
    	    operator: {
    	      validate: (0, _utils.assertOneOf)(..._index.LOGICAL_OPERATORS)
    	    },
    	    left: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    },
    	    right: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    }
    	  }
    	});
    	defineType("MemberExpression", {
    	  builder: ["object", "property", "computed", ...(!process$1.env.BABEL_TYPES_8_BREAKING ? ["optional"] : [])],
    	  visitor: ["object", "property"],
    	  aliases: ["Expression", "LVal"],
    	  fields: Object.assign({
    	    object: {
    	      validate: (0, _utils.assertNodeType)("Expression", "Super")
    	    },
    	    property: {
    	      validate: function () {
    	        const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
    	        const computed = (0, _utils.assertNodeType)("Expression");
    	        const validator = function (node, key, val) {
    	          const validator = node.computed ? computed : normal;
    	          validator(node, key, val);
    	        };
    	        validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
    	        return validator;
    	      }()
    	    },
    	    computed: {
    	      default: false
    	    }
    	  }, !process$1.env.BABEL_TYPES_8_BREAKING ? {
    	    optional: {
    	      validate: (0, _utils.assertOneOf)(true, false),
    	      optional: true
    	    }
    	  } : {})
    	});
    	defineType("NewExpression", {
    	  inherits: "CallExpression"
    	});
    	defineType("Program", {
    	  visitor: ["directives", "body"],
    	  builder: ["body", "directives", "sourceType", "interpreter"],
    	  fields: {
    	    sourceFile: {
    	      validate: (0, _utils.assertValueType)("string")
    	    },
    	    sourceType: {
    	      validate: (0, _utils.assertOneOf)("script", "module"),
    	      default: "script"
    	    },
    	    interpreter: {
    	      validate: (0, _utils.assertNodeType)("InterpreterDirective"),
    	      default: null,
    	      optional: true
    	    },
    	    directives: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
    	      default: []
    	    },
    	    body: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
    	    }
    	  },
    	  aliases: ["Scopable", "BlockParent", "Block"]
    	});
    	defineType("ObjectExpression", {
    	  visitor: ["properties"],
    	  aliases: ["Expression"],
    	  fields: {
    	    properties: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
    	    }
    	  }
    	});
    	defineType("ObjectMethod", {
    	  builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    	  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
    	    kind: Object.assign({
    	      validate: (0, _utils.assertOneOf)("method", "get", "set")
    	    }, !process$1.env.BABEL_TYPES_8_BREAKING ? {
    	      default: "method"
    	    } : {}),
    	    computed: {
    	      default: false
    	    },
    	    key: {
    	      validate: function () {
    	        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
    	        const computed = (0, _utils.assertNodeType)("Expression");
    	        const validator = function (node, key, val) {
    	          const validator = node.computed ? computed : normal;
    	          validator(node, key, val);
    	        };
    	        validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"];
    	        return validator;
    	      }()
    	    },
    	    decorators: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
    	      optional: true
    	    },
    	    body: {
    	      validate: (0, _utils.assertNodeType)("BlockStatement")
    	    }
    	  }),
    	  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    	  aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
    	});
    	defineType("ObjectProperty", {
    	  builder: ["key", "value", "computed", "shorthand", ...(!process$1.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : [])],
    	  fields: {
    	    computed: {
    	      default: false
    	    },
    	    key: {
    	      validate: function () {
    	        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
    	        const computed = (0, _utils.assertNodeType)("Expression");
    	        const validator = Object.assign(function (node, key, val) {
    	          const validator = node.computed ? computed : normal;
    	          validator(node, key, val);
    	        }, {
    	          oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
    	        });
    	        return validator;
    	      }()
    	    },
    	    value: {
    	      validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
    	    },
    	    shorthand: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function (node, key, val) {
    	        if (!process$1.env.BABEL_TYPES_8_BREAKING) return;
    	        if (val && node.computed) {
    	          throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
    	        }
    	      }, {
    	        type: "boolean"
    	      }), function (node, key, val) {
    	        if (!process$1.env.BABEL_TYPES_8_BREAKING) return;
    	        if (val && !(0, _is.default)("Identifier", node.key)) {
    	          throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
    	        }
    	      }),
    	      default: false
    	    },
    	    decorators: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
    	      optional: true
    	    }
    	  },
    	  visitor: ["key", "value", "decorators"],
    	  aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    	  validate: function () {
    	    const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");
    	    const expression = (0, _utils.assertNodeType)("Expression");
    	    return function (parent, key, node) {
    	      if (!process$1.env.BABEL_TYPES_8_BREAKING) return;
    	      const validator = (0, _is.default)("ObjectPattern", parent) ? pattern : expression;
    	      validator(node, "value", node.value);
    	    };
    	  }()
    	});
    	defineType("RestElement", {
    	  visitor: ["argument", "typeAnnotation"],
    	  builder: ["argument"],
    	  aliases: ["LVal", "PatternLike"],
    	  deprecatedAlias: "RestProperty",
    	  fields: Object.assign({}, patternLikeCommon(), {
    	    argument: {
    	      validate: !process$1.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
    	    }
    	  }),
    	  validate(parent, key) {
    	    if (!process$1.env.BABEL_TYPES_8_BREAKING) return;
    	    const match = /(\w+)\[(\d+)\]/.exec(key);
    	    if (!match) throw new Error("Internal Babel error: malformed key.");
    	    const [, listKey, index] = match;
    	    if (parent[listKey].length > +index + 1) {
    	      throw new TypeError(`RestElement must be last element of ${listKey}`);
    	    }
    	  }
    	});
    	defineType("ReturnStatement", {
    	  visitor: ["argument"],
    	  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    	  fields: {
    	    argument: {
    	      validate: (0, _utils.assertNodeType)("Expression"),
    	      optional: true
    	    }
    	  }
    	});
    	defineType("SequenceExpression", {
    	  visitor: ["expressions"],
    	  fields: {
    	    expressions: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
    	    }
    	  },
    	  aliases: ["Expression"]
    	});
    	defineType("ParenthesizedExpression", {
    	  visitor: ["expression"],
    	  aliases: ["Expression", "ExpressionWrapper"],
    	  fields: {
    	    expression: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    }
    	  }
    	});
    	defineType("SwitchCase", {
    	  visitor: ["test", "consequent"],
    	  fields: {
    	    test: {
    	      validate: (0, _utils.assertNodeType)("Expression"),
    	      optional: true
    	    },
    	    consequent: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
    	    }
    	  }
    	});
    	defineType("SwitchStatement", {
    	  visitor: ["discriminant", "cases"],
    	  aliases: ["Statement", "BlockParent", "Scopable"],
    	  fields: {
    	    discriminant: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    },
    	    cases: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase")))
    	    }
    	  }
    	});
    	defineType("ThisExpression", {
    	  aliases: ["Expression"]
    	});
    	defineType("ThrowStatement", {
    	  visitor: ["argument"],
    	  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    	  fields: {
    	    argument: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    }
    	  }
    	});
    	defineType("TryStatement", {
    	  visitor: ["block", "handler", "finalizer"],
    	  aliases: ["Statement"],
    	  fields: {
    	    block: {
    	      validate: (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function (node) {
    	        if (!process$1.env.BABEL_TYPES_8_BREAKING) return;
    	        if (!node.handler && !node.finalizer) {
    	          throw new TypeError("TryStatement expects either a handler or finalizer, or both");
    	        }
    	      }, {
    	        oneOfNodeTypes: ["BlockStatement"]
    	      }))
    	    },
    	    handler: {
    	      optional: true,
    	      validate: (0, _utils.assertNodeType)("CatchClause")
    	    },
    	    finalizer: {
    	      optional: true,
    	      validate: (0, _utils.assertNodeType)("BlockStatement")
    	    }
    	  }
    	});
    	defineType("UnaryExpression", {
    	  builder: ["operator", "argument", "prefix"],
    	  fields: {
    	    prefix: {
    	      default: true
    	    },
    	    argument: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    },
    	    operator: {
    	      validate: (0, _utils.assertOneOf)(..._index.UNARY_OPERATORS)
    	    }
    	  },
    	  visitor: ["argument"],
    	  aliases: ["UnaryLike", "Expression"]
    	});
    	defineType("UpdateExpression", {
    	  builder: ["operator", "argument", "prefix"],
    	  fields: {
    	    prefix: {
    	      default: false
    	    },
    	    argument: {
    	      validate: !process$1.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")
    	    },
    	    operator: {
    	      validate: (0, _utils.assertOneOf)(..._index.UPDATE_OPERATORS)
    	    }
    	  },
    	  visitor: ["argument"],
    	  aliases: ["Expression"]
    	});
    	defineType("VariableDeclaration", {
    	  builder: ["kind", "declarations"],
    	  visitor: ["declarations"],
    	  aliases: ["Statement", "Declaration"],
    	  fields: {
    	    declare: {
    	      validate: (0, _utils.assertValueType)("boolean"),
    	      optional: true
    	    },
    	    kind: {
    	      validate: (0, _utils.assertOneOf)("var", "let", "const", "using", "await using")
    	    },
    	    declarations: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator")))
    	    }
    	  },
    	  validate(parent, key, node) {
    	    if (!process$1.env.BABEL_TYPES_8_BREAKING) return;
    	    if (!(0, _is.default)("ForXStatement", parent, {
    	      left: node
    	    })) return;
    	    if (node.declarations.length !== 1) {
    	      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
    	    }
    	  }
    	});
    	defineType("VariableDeclarator", {
    	  visitor: ["id", "init"],
    	  fields: {
    	    id: {
    	      validate: function () {
    	        if (!process$1.env.BABEL_TYPES_8_BREAKING) {
    	          return (0, _utils.assertNodeType)("LVal");
    	        }
    	        const normal = (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern");
    	        const without = (0, _utils.assertNodeType)("Identifier");
    	        return function (node, key, val) {
    	          const validator = node.init ? normal : without;
    	          validator(node, key, val);
    	        };
    	      }()
    	    },
    	    definite: {
    	      optional: true,
    	      validate: (0, _utils.assertValueType)("boolean")
    	    },
    	    init: {
    	      optional: true,
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    }
    	  }
    	});
    	defineType("WhileStatement", {
    	  visitor: ["test", "body"],
    	  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    	  fields: {
    	    test: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    },
    	    body: {
    	      validate: (0, _utils.assertNodeType)("Statement")
    	    }
    	  }
    	});
    	defineType("WithStatement", {
    	  visitor: ["object", "body"],
    	  aliases: ["Statement"],
    	  fields: {
    	    object: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    },
    	    body: {
    	      validate: (0, _utils.assertNodeType)("Statement")
    	    }
    	  }
    	});
    	defineType("AssignmentPattern", {
    	  visitor: ["left", "right", "decorators"],
    	  builder: ["left", "right"],
    	  aliases: ["Pattern", "PatternLike", "LVal"],
    	  fields: Object.assign({}, patternLikeCommon(), {
    	    left: {
    	      validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
    	    },
    	    right: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    },
    	    decorators: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
    	      optional: true
    	    }
    	  })
    	});
    	defineType("ArrayPattern", {
    	  visitor: ["elements", "typeAnnotation"],
    	  builder: ["elements"],
    	  aliases: ["Pattern", "PatternLike", "LVal"],
    	  fields: Object.assign({}, patternLikeCommon(), {
    	    elements: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike", "LVal")))
    	    }
    	  })
    	});
    	defineType("ArrowFunctionExpression", {
    	  builder: ["params", "body", "async"],
    	  visitor: ["params", "body", "returnType", "typeParameters"],
    	  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    	  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
    	    expression: {
    	      validate: (0, _utils.assertValueType)("boolean")
    	    },
    	    body: {
    	      validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
    	    },
    	    predicate: {
    	      validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
    	      optional: true
    	    }
    	  })
    	});
    	defineType("ClassBody", {
    	  visitor: ["body"],
    	  fields: {
    	    body: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
    	    }
    	  }
    	});
    	defineType("ClassExpression", {
    	  builder: ["id", "superClass", "body", "decorators"],
    	  visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
    	  aliases: ["Scopable", "Class", "Expression"],
    	  fields: {
    	    id: {
    	      validate: (0, _utils.assertNodeType)("Identifier"),
    	      optional: true
    	    },
    	    typeParameters: {
    	      validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
    	      optional: true
    	    },
    	    body: {
    	      validate: (0, _utils.assertNodeType)("ClassBody")
    	    },
    	    superClass: {
    	      optional: true,
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    },
    	    superTypeParameters: {
    	      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
    	      optional: true
    	    },
    	    implements: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
    	      optional: true
    	    },
    	    decorators: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
    	      optional: true
    	    },
    	    mixins: {
    	      validate: (0, _utils.assertNodeType)("InterfaceExtends"),
    	      optional: true
    	    }
    	  }
    	});
    	defineType("ClassDeclaration", {
    	  inherits: "ClassExpression",
    	  aliases: ["Scopable", "Class", "Statement", "Declaration"],
    	  fields: {
    	    id: {
    	      validate: (0, _utils.assertNodeType)("Identifier"),
    	      optional: true
    	    },
    	    typeParameters: {
    	      validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
    	      optional: true
    	    },
    	    body: {
    	      validate: (0, _utils.assertNodeType)("ClassBody")
    	    },
    	    superClass: {
    	      optional: true,
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    },
    	    superTypeParameters: {
    	      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
    	      optional: true
    	    },
    	    implements: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
    	      optional: true
    	    },
    	    decorators: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
    	      optional: true
    	    },
    	    mixins: {
    	      validate: (0, _utils.assertNodeType)("InterfaceExtends"),
    	      optional: true
    	    },
    	    declare: {
    	      validate: (0, _utils.assertValueType)("boolean"),
    	      optional: true
    	    },
    	    abstract: {
    	      validate: (0, _utils.assertValueType)("boolean"),
    	      optional: true
    	    }
    	  },
    	  validate: function () {
    	    const identifier = (0, _utils.assertNodeType)("Identifier");
    	    return function (parent, key, node) {
    	      if (!process$1.env.BABEL_TYPES_8_BREAKING) return;
    	      if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
    	        identifier(node, "id", node.id);
    	      }
    	    };
    	  }()
    	});
    	defineType("ExportAllDeclaration", {
    	  builder: ["source"],
    	  visitor: ["source", "attributes", "assertions"],
    	  aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    	  fields: {
    	    source: {
    	      validate: (0, _utils.assertNodeType)("StringLiteral")
    	    },
    	    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value")),
    	    attributes: {
    	      optional: true,
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
    	    },
    	    assertions: {
    	      optional: true,
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
    	    }
    	  }
    	});
    	defineType("ExportDefaultDeclaration", {
    	  visitor: ["declaration"],
    	  aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    	  fields: {
    	    declaration: {
    	      validate: (0, _utils.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
    	    },
    	    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
    	  }
    	});
    	defineType("ExportNamedDeclaration", {
    	  builder: ["declaration", "specifiers", "source"],
    	  visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
    	  aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    	  fields: {
    	    declaration: {
    	      optional: true,
    	      validate: (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function (node, key, val) {
    	        if (!process$1.env.BABEL_TYPES_8_BREAKING) return;
    	        if (val && node.specifiers.length) {
    	          throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
    	        }
    	      }, {
    	        oneOfNodeTypes: ["Declaration"]
    	      }), function (node, key, val) {
    	        if (!process$1.env.BABEL_TYPES_8_BREAKING) return;
    	        if (val && node.source) {
    	          throw new TypeError("Cannot export a declaration from a source");
    	        }
    	      })
    	    },
    	    attributes: {
    	      optional: true,
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
    	    },
    	    assertions: {
    	      optional: true,
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
    	    },
    	    specifiers: {
    	      default: [],
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)(function () {
    	        const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
    	        const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
    	        if (!process$1.env.BABEL_TYPES_8_BREAKING) return sourced;
    	        return function (node, key, val) {
    	          const validator = node.source ? sourced : sourceless;
    	          validator(node, key, val);
    	        };
    	      }()))
    	    },
    	    source: {
    	      validate: (0, _utils.assertNodeType)("StringLiteral"),
    	      optional: true
    	    },
    	    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    	  }
    	});
    	defineType("ExportSpecifier", {
    	  visitor: ["local", "exported"],
    	  aliases: ["ModuleSpecifier"],
    	  fields: {
    	    local: {
    	      validate: (0, _utils.assertNodeType)("Identifier")
    	    },
    	    exported: {
    	      validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
    	    },
    	    exportKind: {
    	      validate: (0, _utils.assertOneOf)("type", "value"),
    	      optional: true
    	    }
    	  }
    	});
    	defineType("ForOfStatement", {
    	  visitor: ["left", "right", "body"],
    	  builder: ["left", "right", "body", "await"],
    	  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    	  fields: {
    	    left: {
    	      validate: function () {
    	        if (!process$1.env.BABEL_TYPES_8_BREAKING) {
    	          return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
    	        }
    	        const declaration = (0, _utils.assertNodeType)("VariableDeclaration");
    	        const lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
    	        return function (node, key, val) {
    	          if ((0, _is.default)("VariableDeclaration", val)) {
    	            declaration(node, key, val);
    	          } else {
    	            lval(node, key, val);
    	          }
    	        };
    	      }()
    	    },
    	    right: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    },
    	    body: {
    	      validate: (0, _utils.assertNodeType)("Statement")
    	    },
    	    await: {
    	      default: false
    	    }
    	  }
    	});
    	defineType("ImportDeclaration", {
    	  builder: ["specifiers", "source"],
    	  visitor: ["specifiers", "source", "attributes", "assertions"],
    	  aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    	  fields: {
    	    attributes: {
    	      optional: true,
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
    	    },
    	    assertions: {
    	      optional: true,
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
    	    },
    	    module: {
    	      optional: true,
    	      validate: (0, _utils.assertValueType)("boolean")
    	    },
    	    phase: {
    	      default: null,
    	      validate: (0, _utils.assertOneOf)("source", "defer")
    	    },
    	    specifiers: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
    	    },
    	    source: {
    	      validate: (0, _utils.assertNodeType)("StringLiteral")
    	    },
    	    importKind: {
    	      validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
    	      optional: true
    	    }
    	  }
    	});
    	defineType("ImportDefaultSpecifier", {
    	  visitor: ["local"],
    	  aliases: ["ModuleSpecifier"],
    	  fields: {
    	    local: {
    	      validate: (0, _utils.assertNodeType)("Identifier")
    	    }
    	  }
    	});
    	defineType("ImportNamespaceSpecifier", {
    	  visitor: ["local"],
    	  aliases: ["ModuleSpecifier"],
    	  fields: {
    	    local: {
    	      validate: (0, _utils.assertNodeType)("Identifier")
    	    }
    	  }
    	});
    	defineType("ImportSpecifier", {
    	  visitor: ["local", "imported"],
    	  aliases: ["ModuleSpecifier"],
    	  fields: {
    	    local: {
    	      validate: (0, _utils.assertNodeType)("Identifier")
    	    },
    	    imported: {
    	      validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
    	    },
    	    importKind: {
    	      validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
    	      optional: true
    	    }
    	  }
    	});
    	defineType("ImportExpression", {
    	  visitor: ["source", "options"],
    	  aliases: ["Expression"],
    	  fields: {
    	    phase: {
    	      default: null,
    	      validate: (0, _utils.assertOneOf)("source", "defer")
    	    },
    	    source: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    },
    	    options: {
    	      validate: (0, _utils.assertNodeType)("Expression"),
    	      optional: true
    	    }
    	  }
    	});
    	defineType("MetaProperty", {
    	  visitor: ["meta", "property"],
    	  aliases: ["Expression"],
    	  fields: {
    	    meta: {
    	      validate: (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function (node, key, val) {
    	        if (!process$1.env.BABEL_TYPES_8_BREAKING) return;
    	        let property;
    	        switch (val.name) {
    	          case "function":
    	            property = "sent";
    	            break;
    	          case "new":
    	            property = "target";
    	            break;
    	          case "import":
    	            property = "meta";
    	            break;
    	        }
    	        if (!(0, _is.default)("Identifier", node.property, {
    	          name: property
    	        })) {
    	          throw new TypeError("Unrecognised MetaProperty");
    	        }
    	      }, {
    	        oneOfNodeTypes: ["Identifier"]
    	      }))
    	    },
    	    property: {
    	      validate: (0, _utils.assertNodeType)("Identifier")
    	    }
    	  }
    	});
    	const classMethodOrPropertyCommon = () => ({
    	  abstract: {
    	    validate: (0, _utils.assertValueType)("boolean"),
    	    optional: true
    	  },
    	  accessibility: {
    	    validate: (0, _utils.assertOneOf)("public", "private", "protected"),
    	    optional: true
    	  },
    	  static: {
    	    default: false
    	  },
    	  override: {
    	    default: false
    	  },
    	  computed: {
    	    default: false
    	  },
    	  optional: {
    	    validate: (0, _utils.assertValueType)("boolean"),
    	    optional: true
    	  },
    	  key: {
    	    validate: (0, _utils.chain)(function () {
    	      const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
    	      const computed = (0, _utils.assertNodeType)("Expression");
    	      return function (node, key, val) {
    	        const validator = node.computed ? computed : normal;
    	        validator(node, key, val);
    	      };
    	    }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    	  }
    	});
    	core.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
    	const classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
    	  params: {
    	    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
    	  },
    	  kind: {
    	    validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
    	    default: "method"
    	  },
    	  access: {
    	    validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
    	    optional: true
    	  },
    	  decorators: {
    	    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
    	    optional: true
    	  }
    	});
    	core.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
    	defineType("ClassMethod", {
    	  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    	  builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    	  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    	  fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
    	    body: {
    	      validate: (0, _utils.assertNodeType)("BlockStatement")
    	    }
    	  })
    	});
    	defineType("ObjectPattern", {
    	  visitor: ["properties", "typeAnnotation", "decorators"],
    	  builder: ["properties"],
    	  aliases: ["Pattern", "PatternLike", "LVal"],
    	  fields: Object.assign({}, patternLikeCommon(), {
    	    properties: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty")))
    	    }
    	  })
    	});
    	defineType("SpreadElement", {
    	  visitor: ["argument"],
    	  aliases: ["UnaryLike"],
    	  deprecatedAlias: "SpreadProperty",
    	  fields: {
    	    argument: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    }
    	  }
    	});
    	defineType("Super", {
    	  aliases: ["Expression"]
    	});
    	defineType("TaggedTemplateExpression", {
    	  visitor: ["tag", "quasi", "typeParameters"],
    	  builder: ["tag", "quasi"],
    	  aliases: ["Expression"],
    	  fields: {
    	    tag: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    },
    	    quasi: {
    	      validate: (0, _utils.assertNodeType)("TemplateLiteral")
    	    },
    	    typeParameters: {
    	      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
    	      optional: true
    	    }
    	  }
    	});
    	defineType("TemplateElement", {
    	  builder: ["value", "tail"],
    	  fields: {
    	    value: {
    	      validate: (0, _utils.chain)((0, _utils.assertShape)({
    	        raw: {
    	          validate: (0, _utils.assertValueType)("string")
    	        },
    	        cooked: {
    	          validate: (0, _utils.assertValueType)("string"),
    	          optional: true
    	        }
    	      }), function templateElementCookedValidator(node) {
    	        const raw = node.value.raw;
    	        let unterminatedCalled = false;
    	        const error = () => {
    	          throw new Error("Internal @babel/types error.");
    	        };
    	        const {
    	          str,
    	          firstInvalidLoc
    	        } = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, {
    	          unterminated() {
    	            unterminatedCalled = true;
    	          },
    	          strictNumericEscape: error,
    	          invalidEscapeSequence: error,
    	          numericSeparatorInEscapeSequence: error,
    	          unexpectedNumericSeparator: error,
    	          invalidDigit: error,
    	          invalidCodePoint: error
    	        });
    	        if (!unterminatedCalled) throw new Error("Invalid raw");
    	        node.value.cooked = firstInvalidLoc ? null : str;
    	      })
    	    },
    	    tail: {
    	      default: false
    	    }
    	  }
    	});
    	defineType("TemplateLiteral", {
    	  visitor: ["quasis", "expressions"],
    	  aliases: ["Expression", "Literal"],
    	  fields: {
    	    quasis: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement")))
    	    },
    	    expressions: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function (node, key, val) {
    	        if (node.quasis.length !== val.length + 1) {
    	          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);
    	        }
    	      })
    	    }
    	  }
    	});
    	defineType("YieldExpression", {
    	  builder: ["argument", "delegate"],
    	  visitor: ["argument"],
    	  aliases: ["Expression", "Terminatorless"],
    	  fields: {
    	    delegate: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function (node, key, val) {
    	        if (!process$1.env.BABEL_TYPES_8_BREAKING) return;
    	        if (val && !node.argument) {
    	          throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
    	        }
    	      }, {
    	        type: "boolean"
    	      })),
    	      default: false
    	    },
    	    argument: {
    	      optional: true,
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    }
    	  }
    	});
    	defineType("AwaitExpression", {
    	  builder: ["argument"],
    	  visitor: ["argument"],
    	  aliases: ["Expression", "Terminatorless"],
    	  fields: {
    	    argument: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    }
    	  }
    	});
    	defineType("Import", {
    	  aliases: ["Expression"]
    	});
    	defineType("BigIntLiteral", {
    	  builder: ["value"],
    	  fields: {
    	    value: {
    	      validate: (0, _utils.assertValueType)("string")
    	    }
    	  },
    	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    	});
    	defineType("ExportNamespaceSpecifier", {
    	  visitor: ["exported"],
    	  aliases: ["ModuleSpecifier"],
    	  fields: {
    	    exported: {
    	      validate: (0, _utils.assertNodeType)("Identifier")
    	    }
    	  }
    	});
    	defineType("OptionalMemberExpression", {
    	  builder: ["object", "property", "computed", "optional"],
    	  visitor: ["object", "property"],
    	  aliases: ["Expression"],
    	  fields: {
    	    object: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    },
    	    property: {
    	      validate: function () {
    	        const normal = (0, _utils.assertNodeType)("Identifier");
    	        const computed = (0, _utils.assertNodeType)("Expression");
    	        const validator = Object.assign(function (node, key, val) {
    	          const validator = node.computed ? computed : normal;
    	          validator(node, key, val);
    	        }, {
    	          oneOfNodeTypes: ["Expression", "Identifier"]
    	        });
    	        return validator;
    	      }()
    	    },
    	    computed: {
    	      default: false
    	    },
    	    optional: {
    	      validate: !process$1.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
    	    }
    	  }
    	});
    	defineType("OptionalCallExpression", {
    	  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    	  builder: ["callee", "arguments", "optional"],
    	  aliases: ["Expression"],
    	  fields: {
    	    callee: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    },
    	    arguments: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
    	    },
    	    optional: {
    	      validate: !process$1.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
    	    },
    	    typeArguments: {
    	      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
    	      optional: true
    	    },
    	    typeParameters: {
    	      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
    	      optional: true
    	    }
    	  }
    	});
    	defineType("ClassProperty", {
    	  visitor: ["key", "value", "typeAnnotation", "decorators"],
    	  builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    	  aliases: ["Property"],
    	  fields: Object.assign({}, classMethodOrPropertyCommon(), {
    	    value: {
    	      validate: (0, _utils.assertNodeType)("Expression"),
    	      optional: true
    	    },
    	    definite: {
    	      validate: (0, _utils.assertValueType)("boolean"),
    	      optional: true
    	    },
    	    typeAnnotation: {
    	      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
    	      optional: true
    	    },
    	    decorators: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
    	      optional: true
    	    },
    	    readonly: {
    	      validate: (0, _utils.assertValueType)("boolean"),
    	      optional: true
    	    },
    	    declare: {
    	      validate: (0, _utils.assertValueType)("boolean"),
    	      optional: true
    	    },
    	    variance: {
    	      validate: (0, _utils.assertNodeType)("Variance"),
    	      optional: true
    	    }
    	  })
    	});
    	defineType("ClassAccessorProperty", {
    	  visitor: ["key", "value", "typeAnnotation", "decorators"],
    	  builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    	  aliases: ["Property", "Accessor"],
    	  fields: Object.assign({}, classMethodOrPropertyCommon(), {
    	    key: {
    	      validate: (0, _utils.chain)(function () {
    	        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
    	        const computed = (0, _utils.assertNodeType)("Expression");
    	        return function (node, key, val) {
    	          const validator = node.computed ? computed : normal;
    	          validator(node, key, val);
    	        };
    	      }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
    	    },
    	    value: {
    	      validate: (0, _utils.assertNodeType)("Expression"),
    	      optional: true
    	    },
    	    definite: {
    	      validate: (0, _utils.assertValueType)("boolean"),
    	      optional: true
    	    },
    	    typeAnnotation: {
    	      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
    	      optional: true
    	    },
    	    decorators: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
    	      optional: true
    	    },
    	    readonly: {
    	      validate: (0, _utils.assertValueType)("boolean"),
    	      optional: true
    	    },
    	    declare: {
    	      validate: (0, _utils.assertValueType)("boolean"),
    	      optional: true
    	    },
    	    variance: {
    	      validate: (0, _utils.assertNodeType)("Variance"),
    	      optional: true
    	    }
    	  })
    	});
    	defineType("ClassPrivateProperty", {
    	  visitor: ["key", "value", "decorators", "typeAnnotation"],
    	  builder: ["key", "value", "decorators", "static"],
    	  aliases: ["Property", "Private"],
    	  fields: {
    	    key: {
    	      validate: (0, _utils.assertNodeType)("PrivateName")
    	    },
    	    value: {
    	      validate: (0, _utils.assertNodeType)("Expression"),
    	      optional: true
    	    },
    	    typeAnnotation: {
    	      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
    	      optional: true
    	    },
    	    decorators: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
    	      optional: true
    	    },
    	    static: {
    	      validate: (0, _utils.assertValueType)("boolean"),
    	      default: false
    	    },
    	    readonly: {
    	      validate: (0, _utils.assertValueType)("boolean"),
    	      optional: true
    	    },
    	    definite: {
    	      validate: (0, _utils.assertValueType)("boolean"),
    	      optional: true
    	    },
    	    variance: {
    	      validate: (0, _utils.assertNodeType)("Variance"),
    	      optional: true
    	    }
    	  }
    	});
    	defineType("ClassPrivateMethod", {
    	  builder: ["kind", "key", "params", "body", "static"],
    	  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    	  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    	  fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
    	    kind: {
    	      validate: (0, _utils.assertOneOf)("get", "set", "method"),
    	      default: "method"
    	    },
    	    key: {
    	      validate: (0, _utils.assertNodeType)("PrivateName")
    	    },
    	    body: {
    	      validate: (0, _utils.assertNodeType)("BlockStatement")
    	    }
    	  })
    	});
    	defineType("PrivateName", {
    	  visitor: ["id"],
    	  aliases: ["Private"],
    	  fields: {
    	    id: {
    	      validate: (0, _utils.assertNodeType)("Identifier")
    	    }
    	  }
    	});
    	defineType("StaticBlock", {
    	  visitor: ["body"],
    	  fields: {
    	    body: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
    	    }
    	  },
    	  aliases: ["Scopable", "BlockParent", "FunctionParent"]
    	});

    	
    	return core;
    }

    var flow$1 = {};

    var hasRequiredFlow$1;

    function requireFlow$1 () {
    	if (hasRequiredFlow$1) return flow$1;
    	hasRequiredFlow$1 = 1;

    	var _utils = requireUtils();
    	const defineType = (0, _utils.defineAliasedType)("Flow");
    	const defineInterfaceishType = name => {
    	  const isDeclareClass = name === "DeclareClass";
    	  defineType(name, {
    	    builder: ["id", "typeParameters", "extends", "body"],
    	    visitor: ["id", "typeParameters", "extends", ...(isDeclareClass ? ["mixins", "implements"] : []), "body"],
    	    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    	    fields: Object.assign({
    	      id: (0, _utils.validateType)("Identifier"),
    	      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    	      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends"))
    	    }, isDeclareClass ? {
    	      mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
    	      implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements"))
    	    } : {}, {
    	      body: (0, _utils.validateType)("ObjectTypeAnnotation")
    	    })
    	  });
    	};
    	defineType("AnyTypeAnnotation", {
    	  aliases: ["FlowType", "FlowBaseAnnotation"]
    	});
    	defineType("ArrayTypeAnnotation", {
    	  visitor: ["elementType"],
    	  aliases: ["FlowType"],
    	  fields: {
    	    elementType: (0, _utils.validateType)("FlowType")
    	  }
    	});
    	defineType("BooleanTypeAnnotation", {
    	  aliases: ["FlowType", "FlowBaseAnnotation"]
    	});
    	defineType("BooleanLiteralTypeAnnotation", {
    	  builder: ["value"],
    	  aliases: ["FlowType"],
    	  fields: {
    	    value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    	  }
    	});
    	defineType("NullLiteralTypeAnnotation", {
    	  aliases: ["FlowType", "FlowBaseAnnotation"]
    	});
    	defineType("ClassImplements", {
    	  visitor: ["id", "typeParameters"],
    	  fields: {
    	    id: (0, _utils.validateType)("Identifier"),
    	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    	  }
    	});
    	defineInterfaceishType("DeclareClass");
    	defineType("DeclareFunction", {
    	  visitor: ["id"],
    	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
    	  fields: {
    	    id: (0, _utils.validateType)("Identifier"),
    	    predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
    	  }
    	});
    	defineInterfaceishType("DeclareInterface");
    	defineType("DeclareModule", {
    	  builder: ["id", "body", "kind"],
    	  visitor: ["id", "body"],
    	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
    	  fields: {
    	    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
    	    body: (0, _utils.validateType)("BlockStatement"),
    	    kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
    	  }
    	});
    	defineType("DeclareModuleExports", {
    	  visitor: ["typeAnnotation"],
    	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
    	  fields: {
    	    typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
    	  }
    	});
    	defineType("DeclareTypeAlias", {
    	  visitor: ["id", "typeParameters", "right"],
    	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
    	  fields: {
    	    id: (0, _utils.validateType)("Identifier"),
    	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    	    right: (0, _utils.validateType)("FlowType")
    	  }
    	});
    	defineType("DeclareOpaqueType", {
    	  visitor: ["id", "typeParameters", "supertype"],
    	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
    	  fields: {
    	    id: (0, _utils.validateType)("Identifier"),
    	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    	    supertype: (0, _utils.validateOptionalType)("FlowType"),
    	    impltype: (0, _utils.validateOptionalType)("FlowType")
    	  }
    	});
    	defineType("DeclareVariable", {
    	  visitor: ["id"],
    	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
    	  fields: {
    	    id: (0, _utils.validateType)("Identifier")
    	  }
    	});
    	defineType("DeclareExportDeclaration", {
    	  visitor: ["declaration", "specifiers", "source"],
    	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
    	  fields: {
    	    declaration: (0, _utils.validateOptionalType)("Flow"),
    	    specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
    	    source: (0, _utils.validateOptionalType)("StringLiteral"),
    	    default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    	  }
    	});
    	defineType("DeclareExportAllDeclaration", {
    	  visitor: ["source"],
    	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
    	  fields: {
    	    source: (0, _utils.validateType)("StringLiteral"),
    	    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    	  }
    	});
    	defineType("DeclaredPredicate", {
    	  visitor: ["value"],
    	  aliases: ["FlowPredicate"],
    	  fields: {
    	    value: (0, _utils.validateType)("Flow")
    	  }
    	});
    	defineType("ExistsTypeAnnotation", {
    	  aliases: ["FlowType"]
    	});
    	defineType("FunctionTypeAnnotation", {
    	  visitor: ["typeParameters", "params", "rest", "returnType"],
    	  aliases: ["FlowType"],
    	  fields: {
    	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    	    params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),
    	    rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
    	    this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
    	    returnType: (0, _utils.validateType)("FlowType")
    	  }
    	});
    	defineType("FunctionTypeParam", {
    	  visitor: ["name", "typeAnnotation"],
    	  fields: {
    	    name: (0, _utils.validateOptionalType)("Identifier"),
    	    typeAnnotation: (0, _utils.validateType)("FlowType"),
    	    optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    	  }
    	});
    	defineType("GenericTypeAnnotation", {
    	  visitor: ["id", "typeParameters"],
    	  aliases: ["FlowType"],
    	  fields: {
    	    id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
    	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    	  }
    	});
    	defineType("InferredPredicate", {
    	  aliases: ["FlowPredicate"]
    	});
    	defineType("InterfaceExtends", {
    	  visitor: ["id", "typeParameters"],
    	  fields: {
    	    id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
    	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    	  }
    	});
    	defineInterfaceishType("InterfaceDeclaration");
    	defineType("InterfaceTypeAnnotation", {
    	  visitor: ["extends", "body"],
    	  aliases: ["FlowType"],
    	  fields: {
    	    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
    	    body: (0, _utils.validateType)("ObjectTypeAnnotation")
    	  }
    	});
    	defineType("IntersectionTypeAnnotation", {
    	  visitor: ["types"],
    	  aliases: ["FlowType"],
    	  fields: {
    	    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    	  }
    	});
    	defineType("MixedTypeAnnotation", {
    	  aliases: ["FlowType", "FlowBaseAnnotation"]
    	});
    	defineType("EmptyTypeAnnotation", {
    	  aliases: ["FlowType", "FlowBaseAnnotation"]
    	});
    	defineType("NullableTypeAnnotation", {
    	  visitor: ["typeAnnotation"],
    	  aliases: ["FlowType"],
    	  fields: {
    	    typeAnnotation: (0, _utils.validateType)("FlowType")
    	  }
    	});
    	defineType("NumberLiteralTypeAnnotation", {
    	  builder: ["value"],
    	  aliases: ["FlowType"],
    	  fields: {
    	    value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
    	  }
    	});
    	defineType("NumberTypeAnnotation", {
    	  aliases: ["FlowType", "FlowBaseAnnotation"]
    	});
    	defineType("ObjectTypeAnnotation", {
    	  visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    	  aliases: ["FlowType"],
    	  builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    	  fields: {
    	    properties: (0, _utils.validate)((0, _utils.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
    	    indexers: {
    	      validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),
    	      optional: true,
    	      default: []
    	    },
    	    callProperties: {
    	      validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),
    	      optional: true,
    	      default: []
    	    },
    	    internalSlots: {
    	      validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),
    	      optional: true,
    	      default: []
    	    },
    	    exact: {
    	      validate: (0, _utils.assertValueType)("boolean"),
    	      default: false
    	    },
    	    inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    	  }
    	});
    	defineType("ObjectTypeInternalSlot", {
    	  visitor: ["id", "value", "optional", "static", "method"],
    	  aliases: ["UserWhitespacable"],
    	  fields: {
    	    id: (0, _utils.validateType)("Identifier"),
    	    value: (0, _utils.validateType)("FlowType"),
    	    optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    	    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    	    method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    	  }
    	});
    	defineType("ObjectTypeCallProperty", {
    	  visitor: ["value"],
    	  aliases: ["UserWhitespacable"],
    	  fields: {
    	    value: (0, _utils.validateType)("FlowType"),
    	    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    	  }
    	});
    	defineType("ObjectTypeIndexer", {
    	  visitor: ["id", "key", "value", "variance"],
    	  aliases: ["UserWhitespacable"],
    	  fields: {
    	    id: (0, _utils.validateOptionalType)("Identifier"),
    	    key: (0, _utils.validateType)("FlowType"),
    	    value: (0, _utils.validateType)("FlowType"),
    	    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    	    variance: (0, _utils.validateOptionalType)("Variance")
    	  }
    	});
    	defineType("ObjectTypeProperty", {
    	  visitor: ["key", "value", "variance"],
    	  aliases: ["UserWhitespacable"],
    	  fields: {
    	    key: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
    	    value: (0, _utils.validateType)("FlowType"),
    	    kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
    	    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    	    proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    	    optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    	    variance: (0, _utils.validateOptionalType)("Variance"),
    	    method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    	  }
    	});
    	defineType("ObjectTypeSpreadProperty", {
    	  visitor: ["argument"],
    	  aliases: ["UserWhitespacable"],
    	  fields: {
    	    argument: (0, _utils.validateType)("FlowType")
    	  }
    	});
    	defineType("OpaqueType", {
    	  visitor: ["id", "typeParameters", "supertype", "impltype"],
    	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
    	  fields: {
    	    id: (0, _utils.validateType)("Identifier"),
    	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    	    supertype: (0, _utils.validateOptionalType)("FlowType"),
    	    impltype: (0, _utils.validateType)("FlowType")
    	  }
    	});
    	defineType("QualifiedTypeIdentifier", {
    	  visitor: ["id", "qualification"],
    	  fields: {
    	    id: (0, _utils.validateType)("Identifier"),
    	    qualification: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"])
    	  }
    	});
    	defineType("StringLiteralTypeAnnotation", {
    	  builder: ["value"],
    	  aliases: ["FlowType"],
    	  fields: {
    	    value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
    	  }
    	});
    	defineType("StringTypeAnnotation", {
    	  aliases: ["FlowType", "FlowBaseAnnotation"]
    	});
    	defineType("SymbolTypeAnnotation", {
    	  aliases: ["FlowType", "FlowBaseAnnotation"]
    	});
    	defineType("ThisTypeAnnotation", {
    	  aliases: ["FlowType", "FlowBaseAnnotation"]
    	});
    	defineType("TupleTypeAnnotation", {
    	  visitor: ["types"],
    	  aliases: ["FlowType"],
    	  fields: {
    	    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    	  }
    	});
    	defineType("TypeofTypeAnnotation", {
    	  visitor: ["argument"],
    	  aliases: ["FlowType"],
    	  fields: {
    	    argument: (0, _utils.validateType)("FlowType")
    	  }
    	});
    	defineType("TypeAlias", {
    	  visitor: ["id", "typeParameters", "right"],
    	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
    	  fields: {
    	    id: (0, _utils.validateType)("Identifier"),
    	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    	    right: (0, _utils.validateType)("FlowType")
    	  }
    	});
    	defineType("TypeAnnotation", {
    	  visitor: ["typeAnnotation"],
    	  fields: {
    	    typeAnnotation: (0, _utils.validateType)("FlowType")
    	  }
    	});
    	defineType("TypeCastExpression", {
    	  visitor: ["expression", "typeAnnotation"],
    	  aliases: ["ExpressionWrapper", "Expression"],
    	  fields: {
    	    expression: (0, _utils.validateType)("Expression"),
    	    typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
    	  }
    	});
    	defineType("TypeParameter", {
    	  visitor: ["bound", "default", "variance"],
    	  fields: {
    	    name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
    	    bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
    	    default: (0, _utils.validateOptionalType)("FlowType"),
    	    variance: (0, _utils.validateOptionalType)("Variance")
    	  }
    	});
    	defineType("TypeParameterDeclaration", {
    	  visitor: ["params"],
    	  fields: {
    	    params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
    	  }
    	});
    	defineType("TypeParameterInstantiation", {
    	  visitor: ["params"],
    	  fields: {
    	    params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    	  }
    	});
    	defineType("UnionTypeAnnotation", {
    	  visitor: ["types"],
    	  aliases: ["FlowType"],
    	  fields: {
    	    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    	  }
    	});
    	defineType("Variance", {
    	  builder: ["kind"],
    	  fields: {
    	    kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
    	  }
    	});
    	defineType("VoidTypeAnnotation", {
    	  aliases: ["FlowType", "FlowBaseAnnotation"]
    	});
    	defineType("EnumDeclaration", {
    	  aliases: ["Statement", "Declaration"],
    	  visitor: ["id", "body"],
    	  fields: {
    	    id: (0, _utils.validateType)("Identifier"),
    	    body: (0, _utils.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
    	  }
    	});
    	defineType("EnumBooleanBody", {
    	  aliases: ["EnumBody"],
    	  visitor: ["members"],
    	  fields: {
    	    explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    	    members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
    	    hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    	  }
    	});
    	defineType("EnumNumberBody", {
    	  aliases: ["EnumBody"],
    	  visitor: ["members"],
    	  fields: {
    	    explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    	    members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
    	    hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    	  }
    	});
    	defineType("EnumStringBody", {
    	  aliases: ["EnumBody"],
    	  visitor: ["members"],
    	  fields: {
    	    explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    	    members: (0, _utils.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
    	    hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    	  }
    	});
    	defineType("EnumSymbolBody", {
    	  aliases: ["EnumBody"],
    	  visitor: ["members"],
    	  fields: {
    	    members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
    	    hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    	  }
    	});
    	defineType("EnumBooleanMember", {
    	  aliases: ["EnumMember"],
    	  visitor: ["id"],
    	  fields: {
    	    id: (0, _utils.validateType)("Identifier"),
    	    init: (0, _utils.validateType)("BooleanLiteral")
    	  }
    	});
    	defineType("EnumNumberMember", {
    	  aliases: ["EnumMember"],
    	  visitor: ["id", "init"],
    	  fields: {
    	    id: (0, _utils.validateType)("Identifier"),
    	    init: (0, _utils.validateType)("NumericLiteral")
    	  }
    	});
    	defineType("EnumStringMember", {
    	  aliases: ["EnumMember"],
    	  visitor: ["id", "init"],
    	  fields: {
    	    id: (0, _utils.validateType)("Identifier"),
    	    init: (0, _utils.validateType)("StringLiteral")
    	  }
    	});
    	defineType("EnumDefaultedMember", {
    	  aliases: ["EnumMember"],
    	  visitor: ["id"],
    	  fields: {
    	    id: (0, _utils.validateType)("Identifier")
    	  }
    	});
    	defineType("IndexedAccessType", {
    	  visitor: ["objectType", "indexType"],
    	  aliases: ["FlowType"],
    	  fields: {
    	    objectType: (0, _utils.validateType)("FlowType"),
    	    indexType: (0, _utils.validateType)("FlowType")
    	  }
    	});
    	defineType("OptionalIndexedAccessType", {
    	  visitor: ["objectType", "indexType"],
    	  aliases: ["FlowType"],
    	  fields: {
    	    objectType: (0, _utils.validateType)("FlowType"),
    	    indexType: (0, _utils.validateType)("FlowType"),
    	    optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    	  }
    	});

    	
    	return flow$1;
    }

    var jsx$1 = {};

    var hasRequiredJsx$1;

    function requireJsx$1 () {
    	if (hasRequiredJsx$1) return jsx$1;
    	hasRequiredJsx$1 = 1;

    	var _utils = requireUtils();
    	const defineType = (0, _utils.defineAliasedType)("JSX");
    	defineType("JSXAttribute", {
    	  visitor: ["name", "value"],
    	  aliases: ["Immutable"],
    	  fields: {
    	    name: {
    	      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
    	    },
    	    value: {
    	      optional: true,
    	      validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
    	    }
    	  }
    	});
    	defineType("JSXClosingElement", {
    	  visitor: ["name"],
    	  aliases: ["Immutable"],
    	  fields: {
    	    name: {
    	      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
    	    }
    	  }
    	});
    	defineType("JSXElement", {
    	  builder: ["openingElement", "closingElement", "children", "selfClosing"],
    	  visitor: ["openingElement", "children", "closingElement"],
    	  aliases: ["Immutable", "Expression"],
    	  fields: Object.assign({
    	    openingElement: {
    	      validate: (0, _utils.assertNodeType)("JSXOpeningElement")
    	    },
    	    closingElement: {
    	      optional: true,
    	      validate: (0, _utils.assertNodeType)("JSXClosingElement")
    	    },
    	    children: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
    	    }
    	  }, {
    	    selfClosing: {
    	      validate: (0, _utils.assertValueType)("boolean"),
    	      optional: true
    	    }
    	  })
    	});
    	defineType("JSXEmptyExpression", {});
    	defineType("JSXExpressionContainer", {
    	  visitor: ["expression"],
    	  aliases: ["Immutable"],
    	  fields: {
    	    expression: {
    	      validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
    	    }
    	  }
    	});
    	defineType("JSXSpreadChild", {
    	  visitor: ["expression"],
    	  aliases: ["Immutable"],
    	  fields: {
    	    expression: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    }
    	  }
    	});
    	defineType("JSXIdentifier", {
    	  builder: ["name"],
    	  fields: {
    	    name: {
    	      validate: (0, _utils.assertValueType)("string")
    	    }
    	  }
    	});
    	defineType("JSXMemberExpression", {
    	  visitor: ["object", "property"],
    	  fields: {
    	    object: {
    	      validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
    	    },
    	    property: {
    	      validate: (0, _utils.assertNodeType)("JSXIdentifier")
    	    }
    	  }
    	});
    	defineType("JSXNamespacedName", {
    	  visitor: ["namespace", "name"],
    	  fields: {
    	    namespace: {
    	      validate: (0, _utils.assertNodeType)("JSXIdentifier")
    	    },
    	    name: {
    	      validate: (0, _utils.assertNodeType)("JSXIdentifier")
    	    }
    	  }
    	});
    	defineType("JSXOpeningElement", {
    	  builder: ["name", "attributes", "selfClosing"],
    	  visitor: ["name", "attributes"],
    	  aliases: ["Immutable"],
    	  fields: {
    	    name: {
    	      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
    	    },
    	    selfClosing: {
    	      default: false
    	    },
    	    attributes: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
    	    },
    	    typeParameters: {
    	      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
    	      optional: true
    	    }
    	  }
    	});
    	defineType("JSXSpreadAttribute", {
    	  visitor: ["argument"],
    	  fields: {
    	    argument: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    }
    	  }
    	});
    	defineType("JSXText", {
    	  aliases: ["Immutable"],
    	  builder: ["value"],
    	  fields: {
    	    value: {
    	      validate: (0, _utils.assertValueType)("string")
    	    }
    	  }
    	});
    	defineType("JSXFragment", {
    	  builder: ["openingFragment", "closingFragment", "children"],
    	  visitor: ["openingFragment", "children", "closingFragment"],
    	  aliases: ["Immutable", "Expression"],
    	  fields: {
    	    openingFragment: {
    	      validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
    	    },
    	    closingFragment: {
    	      validate: (0, _utils.assertNodeType)("JSXClosingFragment")
    	    },
    	    children: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
    	    }
    	  }
    	});
    	defineType("JSXOpeningFragment", {
    	  aliases: ["Immutable"]
    	});
    	defineType("JSXClosingFragment", {
    	  aliases: ["Immutable"]
    	});

    	
    	return jsx$1;
    }

    var misc = {};

    var placeholders = {};

    var hasRequiredPlaceholders;

    function requirePlaceholders () {
    	if (hasRequiredPlaceholders) return placeholders;
    	hasRequiredPlaceholders = 1;

    	Object.defineProperty(placeholders, "__esModule", {
    	  value: true
    	});
    	placeholders.PLACEHOLDERS_FLIPPED_ALIAS = placeholders.PLACEHOLDERS_ALIAS = placeholders.PLACEHOLDERS = void 0;
    	var _utils = requireUtils();
    	const PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
    	placeholders.PLACEHOLDERS = PLACEHOLDERS;
    	const PLACEHOLDERS_ALIAS = {
    	  Declaration: ["Statement"],
    	  Pattern: ["PatternLike", "LVal"]
    	};
    	placeholders.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;
    	for (const type of PLACEHOLDERS) {
    	  const alias = _utils.ALIAS_KEYS[type];
    	  if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type] = alias;
    	}
    	const PLACEHOLDERS_FLIPPED_ALIAS = {};
    	placeholders.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS;
    	Object.keys(PLACEHOLDERS_ALIAS).forEach(type => {
    	  PLACEHOLDERS_ALIAS[type].forEach(alias => {
    	    if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
    	      PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
    	    }
    	    PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
    	  });
    	});

    	
    	return placeholders;
    }

    var hasRequiredMisc;

    function requireMisc () {
    	if (hasRequiredMisc) return misc;
    	hasRequiredMisc = 1;

    	var _utils = requireUtils();
    	var _placeholders = requirePlaceholders();
    	const defineType = (0, _utils.defineAliasedType)("Miscellaneous");
    	{
    	  defineType("Noop", {
    	    visitor: []
    	  });
    	}
    	defineType("Placeholder", {
    	  visitor: [],
    	  builder: ["expectedNode", "name"],
    	  fields: {
    	    name: {
    	      validate: (0, _utils.assertNodeType)("Identifier")
    	    },
    	    expectedNode: {
    	      validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
    	    }
    	  }
    	});
    	defineType("V8IntrinsicIdentifier", {
    	  builder: ["name"],
    	  fields: {
    	    name: {
    	      validate: (0, _utils.assertValueType)("string")
    	    }
    	  }
    	});

    	
    	return misc;
    }

    var experimental = {};

    var hasRequiredExperimental;

    function requireExperimental () {
    	if (hasRequiredExperimental) return experimental;
    	hasRequiredExperimental = 1;

    	var _utils = requireUtils();
    	(0, _utils.default)("ArgumentPlaceholder", {});
    	(0, _utils.default)("BindExpression", {
    	  visitor: ["object", "callee"],
    	  aliases: ["Expression"],
    	  fields: !process$1.env.BABEL_TYPES_8_BREAKING ? {
    	    object: {
    	      validate: Object.assign(() => {}, {
    	        oneOfNodeTypes: ["Expression"]
    	      })
    	    },
    	    callee: {
    	      validate: Object.assign(() => {}, {
    	        oneOfNodeTypes: ["Expression"]
    	      })
    	    }
    	  } : {
    	    object: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    },
    	    callee: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    }
    	  }
    	});
    	(0, _utils.default)("ImportAttribute", {
    	  visitor: ["key", "value"],
    	  fields: {
    	    key: {
    	      validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
    	    },
    	    value: {
    	      validate: (0, _utils.assertNodeType)("StringLiteral")
    	    }
    	  }
    	});
    	(0, _utils.default)("Decorator", {
    	  visitor: ["expression"],
    	  fields: {
    	    expression: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    }
    	  }
    	});
    	(0, _utils.default)("DoExpression", {
    	  visitor: ["body"],
    	  builder: ["body", "async"],
    	  aliases: ["Expression"],
    	  fields: {
    	    body: {
    	      validate: (0, _utils.assertNodeType)("BlockStatement")
    	    },
    	    async: {
    	      validate: (0, _utils.assertValueType)("boolean"),
    	      default: false
    	    }
    	  }
    	});
    	(0, _utils.default)("ExportDefaultSpecifier", {
    	  visitor: ["exported"],
    	  aliases: ["ModuleSpecifier"],
    	  fields: {
    	    exported: {
    	      validate: (0, _utils.assertNodeType)("Identifier")
    	    }
    	  }
    	});
    	(0, _utils.default)("RecordExpression", {
    	  visitor: ["properties"],
    	  aliases: ["Expression"],
    	  fields: {
    	    properties: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectProperty", "SpreadElement")))
    	    }
    	  }
    	});
    	(0, _utils.default)("TupleExpression", {
    	  fields: {
    	    elements: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement"))),
    	      default: []
    	    }
    	  },
    	  visitor: ["elements"],
    	  aliases: ["Expression"]
    	});
    	(0, _utils.default)("DecimalLiteral", {
    	  builder: ["value"],
    	  fields: {
    	    value: {
    	      validate: (0, _utils.assertValueType)("string")
    	    }
    	  },
    	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    	});
    	(0, _utils.default)("ModuleExpression", {
    	  visitor: ["body"],
    	  fields: {
    	    body: {
    	      validate: (0, _utils.assertNodeType)("Program")
    	    }
    	  },
    	  aliases: ["Expression"]
    	});
    	(0, _utils.default)("TopicReference", {
    	  aliases: ["Expression"]
    	});
    	(0, _utils.default)("PipelineTopicExpression", {
    	  builder: ["expression"],
    	  visitor: ["expression"],
    	  fields: {
    	    expression: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    }
    	  },
    	  aliases: ["Expression"]
    	});
    	(0, _utils.default)("PipelineBareFunction", {
    	  builder: ["callee"],
    	  visitor: ["callee"],
    	  fields: {
    	    callee: {
    	      validate: (0, _utils.assertNodeType)("Expression")
    	    }
    	  },
    	  aliases: ["Expression"]
    	});
    	(0, _utils.default)("PipelinePrimaryTopicReference", {
    	  aliases: ["Expression"]
    	});

    	
    	return experimental;
    }

    var typescript$1 = {};

    var hasRequiredTypescript$1;

    function requireTypescript$1 () {
    	if (hasRequiredTypescript$1) return typescript$1;
    	hasRequiredTypescript$1 = 1;

    	var _utils = requireUtils();
    	var _core = requireCore();
    	var _is = requireIs();
    	const defineType = (0, _utils.defineAliasedType)("TypeScript");
    	const bool = (0, _utils.assertValueType)("boolean");
    	const tSFunctionTypeAnnotationCommon = () => ({
    	  returnType: {
    	    validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
    	    optional: true
    	  },
    	  typeParameters: {
    	    validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
    	    optional: true
    	  }
    	});
    	defineType("TSParameterProperty", {
    	  aliases: ["LVal"],
    	  visitor: ["parameter"],
    	  fields: {
    	    accessibility: {
    	      validate: (0, _utils.assertOneOf)("public", "private", "protected"),
    	      optional: true
    	    },
    	    readonly: {
    	      validate: (0, _utils.assertValueType)("boolean"),
    	      optional: true
    	    },
    	    parameter: {
    	      validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
    	    },
    	    override: {
    	      validate: (0, _utils.assertValueType)("boolean"),
    	      optional: true
    	    },
    	    decorators: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
    	      optional: true
    	    }
    	  }
    	});
    	defineType("TSDeclareFunction", {
    	  aliases: ["Statement", "Declaration"],
    	  visitor: ["id", "typeParameters", "params", "returnType"],
    	  fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())
    	});
    	defineType("TSDeclareMethod", {
    	  visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    	  fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())
    	});
    	defineType("TSQualifiedName", {
    	  aliases: ["TSEntityName"],
    	  visitor: ["left", "right"],
    	  fields: {
    	    left: (0, _utils.validateType)("TSEntityName"),
    	    right: (0, _utils.validateType)("Identifier")
    	  }
    	});
    	const signatureDeclarationCommon = () => ({
    	  typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
    	  ["parameters"]: (0, _utils.validateArrayOfType)(["ArrayPattern", "Identifier", "ObjectPattern", "RestElement"]),
    	  ["typeAnnotation"]: (0, _utils.validateOptionalType)("TSTypeAnnotation")
    	});
    	const callConstructSignatureDeclaration = {
    	  aliases: ["TSTypeElement"],
    	  visitor: ["typeParameters", "parameters", "typeAnnotation"],
    	  fields: signatureDeclarationCommon()
    	};
    	defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
    	defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
    	const namedTypeElementCommon = () => ({
    	  key: (0, _utils.validateType)("Expression"),
    	  computed: {
    	    default: false
    	  },
    	  optional: (0, _utils.validateOptional)(bool)
    	});
    	defineType("TSPropertySignature", {
    	  aliases: ["TSTypeElement"],
    	  visitor: ["key", "typeAnnotation", "initializer"],
    	  fields: Object.assign({}, namedTypeElementCommon(), {
    	    readonly: (0, _utils.validateOptional)(bool),
    	    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
    	    initializer: (0, _utils.validateOptionalType)("Expression"),
    	    kind: {
    	      validate: (0, _utils.assertOneOf)("get", "set")
    	    }
    	  })
    	});
    	defineType("TSMethodSignature", {
    	  aliases: ["TSTypeElement"],
    	  visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    	  fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
    	    kind: {
    	      validate: (0, _utils.assertOneOf)("method", "get", "set")
    	    }
    	  })
    	});
    	defineType("TSIndexSignature", {
    	  aliases: ["TSTypeElement"],
    	  visitor: ["parameters", "typeAnnotation"],
    	  fields: {
    	    readonly: (0, _utils.validateOptional)(bool),
    	    static: (0, _utils.validateOptional)(bool),
    	    parameters: (0, _utils.validateArrayOfType)("Identifier"),
    	    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
    	  }
    	});
    	const tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
    	for (const type of tsKeywordTypes) {
    	  defineType(type, {
    	    aliases: ["TSType", "TSBaseType"],
    	    visitor: [],
    	    fields: {}
    	  });
    	}
    	defineType("TSThisType", {
    	  aliases: ["TSType", "TSBaseType"],
    	  visitor: [],
    	  fields: {}
    	});
    	const fnOrCtrBase = {
    	  aliases: ["TSType"],
    	  visitor: ["typeParameters", "parameters", "typeAnnotation"]
    	};
    	defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
    	  fields: signatureDeclarationCommon()
    	}));
    	defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
    	  fields: Object.assign({}, signatureDeclarationCommon(), {
    	    abstract: (0, _utils.validateOptional)(bool)
    	  })
    	}));
    	defineType("TSTypeReference", {
    	  aliases: ["TSType"],
    	  visitor: ["typeName", "typeParameters"],
    	  fields: {
    	    typeName: (0, _utils.validateType)("TSEntityName"),
    	    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    	  }
    	});
    	defineType("TSTypePredicate", {
    	  aliases: ["TSType"],
    	  visitor: ["parameterName", "typeAnnotation"],
    	  builder: ["parameterName", "typeAnnotation", "asserts"],
    	  fields: {
    	    parameterName: (0, _utils.validateType)(["Identifier", "TSThisType"]),
    	    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
    	    asserts: (0, _utils.validateOptional)(bool)
    	  }
    	});
    	defineType("TSTypeQuery", {
    	  aliases: ["TSType"],
    	  visitor: ["exprName", "typeParameters"],
    	  fields: {
    	    exprName: (0, _utils.validateType)(["TSEntityName", "TSImportType"]),
    	    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    	  }
    	});
    	defineType("TSTypeLiteral", {
    	  aliases: ["TSType"],
    	  visitor: ["members"],
    	  fields: {
    	    members: (0, _utils.validateArrayOfType)("TSTypeElement")
    	  }
    	});
    	defineType("TSArrayType", {
    	  aliases: ["TSType"],
    	  visitor: ["elementType"],
    	  fields: {
    	    elementType: (0, _utils.validateType)("TSType")
    	  }
    	});
    	defineType("TSTupleType", {
    	  aliases: ["TSType"],
    	  visitor: ["elementTypes"],
    	  fields: {
    	    elementTypes: (0, _utils.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
    	  }
    	});
    	defineType("TSOptionalType", {
    	  aliases: ["TSType"],
    	  visitor: ["typeAnnotation"],
    	  fields: {
    	    typeAnnotation: (0, _utils.validateType)("TSType")
    	  }
    	});
    	defineType("TSRestType", {
    	  aliases: ["TSType"],
    	  visitor: ["typeAnnotation"],
    	  fields: {
    	    typeAnnotation: (0, _utils.validateType)("TSType")
    	  }
    	});
    	defineType("TSNamedTupleMember", {
    	  visitor: ["label", "elementType"],
    	  builder: ["label", "elementType", "optional"],
    	  fields: {
    	    label: (0, _utils.validateType)("Identifier"),
    	    optional: {
    	      validate: bool,
    	      default: false
    	    },
    	    elementType: (0, _utils.validateType)("TSType")
    	  }
    	});
    	const unionOrIntersection = {
    	  aliases: ["TSType"],
    	  visitor: ["types"],
    	  fields: {
    	    types: (0, _utils.validateArrayOfType)("TSType")
    	  }
    	};
    	defineType("TSUnionType", unionOrIntersection);
    	defineType("TSIntersectionType", unionOrIntersection);
    	defineType("TSConditionalType", {
    	  aliases: ["TSType"],
    	  visitor: ["checkType", "extendsType", "trueType", "falseType"],
    	  fields: {
    	    checkType: (0, _utils.validateType)("TSType"),
    	    extendsType: (0, _utils.validateType)("TSType"),
    	    trueType: (0, _utils.validateType)("TSType"),
    	    falseType: (0, _utils.validateType)("TSType")
    	  }
    	});
    	defineType("TSInferType", {
    	  aliases: ["TSType"],
    	  visitor: ["typeParameter"],
    	  fields: {
    	    typeParameter: (0, _utils.validateType)("TSTypeParameter")
    	  }
    	});
    	defineType("TSParenthesizedType", {
    	  aliases: ["TSType"],
    	  visitor: ["typeAnnotation"],
    	  fields: {
    	    typeAnnotation: (0, _utils.validateType)("TSType")
    	  }
    	});
    	defineType("TSTypeOperator", {
    	  aliases: ["TSType"],
    	  visitor: ["typeAnnotation"],
    	  fields: {
    	    operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
    	    typeAnnotation: (0, _utils.validateType)("TSType")
    	  }
    	});
    	defineType("TSIndexedAccessType", {
    	  aliases: ["TSType"],
    	  visitor: ["objectType", "indexType"],
    	  fields: {
    	    objectType: (0, _utils.validateType)("TSType"),
    	    indexType: (0, _utils.validateType)("TSType")
    	  }
    	});
    	defineType("TSMappedType", {
    	  aliases: ["TSType"],
    	  visitor: ["typeParameter", "typeAnnotation", "nameType"],
    	  fields: {
    	    readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
    	    typeParameter: (0, _utils.validateType)("TSTypeParameter"),
    	    optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
    	    typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
    	    nameType: (0, _utils.validateOptionalType)("TSType")
    	  }
    	});
    	defineType("TSLiteralType", {
    	  aliases: ["TSType", "TSBaseType"],
    	  visitor: ["literal"],
    	  fields: {
    	    literal: {
    	      validate: function () {
    	        const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral");
    	        const unaryOperator = (0, _utils.assertOneOf)("-");
    	        const literal = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
    	        function validator(parent, key, node) {
    	          if ((0, _is.default)("UnaryExpression", node)) {
    	            unaryOperator(node, "operator", node.operator);
    	            unaryExpression(node, "argument", node.argument);
    	          } else {
    	            literal(parent, key, node);
    	          }
    	        }
    	        validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"];
    	        return validator;
    	      }()
    	    }
    	  }
    	});
    	defineType("TSExpressionWithTypeArguments", {
    	  aliases: ["TSType"],
    	  visitor: ["expression", "typeParameters"],
    	  fields: {
    	    expression: (0, _utils.validateType)("TSEntityName"),
    	    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    	  }
    	});
    	defineType("TSInterfaceDeclaration", {
    	  aliases: ["Statement", "Declaration"],
    	  visitor: ["id", "typeParameters", "extends", "body"],
    	  fields: {
    	    declare: (0, _utils.validateOptional)(bool),
    	    id: (0, _utils.validateType)("Identifier"),
    	    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
    	    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
    	    body: (0, _utils.validateType)("TSInterfaceBody")
    	  }
    	});
    	defineType("TSInterfaceBody", {
    	  visitor: ["body"],
    	  fields: {
    	    body: (0, _utils.validateArrayOfType)("TSTypeElement")
    	  }
    	});
    	defineType("TSTypeAliasDeclaration", {
    	  aliases: ["Statement", "Declaration"],
    	  visitor: ["id", "typeParameters", "typeAnnotation"],
    	  fields: {
    	    declare: (0, _utils.validateOptional)(bool),
    	    id: (0, _utils.validateType)("Identifier"),
    	    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
    	    typeAnnotation: (0, _utils.validateType)("TSType")
    	  }
    	});
    	defineType("TSInstantiationExpression", {
    	  aliases: ["Expression"],
    	  visitor: ["expression", "typeParameters"],
    	  fields: {
    	    expression: (0, _utils.validateType)("Expression"),
    	    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    	  }
    	});
    	const TSTypeExpression = {
    	  aliases: ["Expression", "LVal", "PatternLike"],
    	  visitor: ["expression", "typeAnnotation"],
    	  fields: {
    	    expression: (0, _utils.validateType)("Expression"),
    	    typeAnnotation: (0, _utils.validateType)("TSType")
    	  }
    	};
    	defineType("TSAsExpression", TSTypeExpression);
    	defineType("TSSatisfiesExpression", TSTypeExpression);
    	defineType("TSTypeAssertion", {
    	  aliases: ["Expression", "LVal", "PatternLike"],
    	  visitor: ["typeAnnotation", "expression"],
    	  fields: {
    	    typeAnnotation: (0, _utils.validateType)("TSType"),
    	    expression: (0, _utils.validateType)("Expression")
    	  }
    	});
    	defineType("TSEnumDeclaration", {
    	  aliases: ["Statement", "Declaration"],
    	  visitor: ["id", "members"],
    	  fields: {
    	    declare: (0, _utils.validateOptional)(bool),
    	    const: (0, _utils.validateOptional)(bool),
    	    id: (0, _utils.validateType)("Identifier"),
    	    members: (0, _utils.validateArrayOfType)("TSEnumMember"),
    	    initializer: (0, _utils.validateOptionalType)("Expression")
    	  }
    	});
    	defineType("TSEnumMember", {
    	  visitor: ["id", "initializer"],
    	  fields: {
    	    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
    	    initializer: (0, _utils.validateOptionalType)("Expression")
    	  }
    	});
    	defineType("TSModuleDeclaration", {
    	  aliases: ["Statement", "Declaration"],
    	  visitor: ["id", "body"],
    	  fields: {
    	    declare: (0, _utils.validateOptional)(bool),
    	    global: (0, _utils.validateOptional)(bool),
    	    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
    	    body: (0, _utils.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
    	  }
    	});
    	defineType("TSModuleBlock", {
    	  aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    	  visitor: ["body"],
    	  fields: {
    	    body: (0, _utils.validateArrayOfType)("Statement")
    	  }
    	});
    	defineType("TSImportType", {
    	  aliases: ["TSType"],
    	  visitor: ["argument", "qualifier", "typeParameters"],
    	  fields: {
    	    argument: (0, _utils.validateType)("StringLiteral"),
    	    qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
    	    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    	  }
    	});
    	defineType("TSImportEqualsDeclaration", {
    	  aliases: ["Statement"],
    	  visitor: ["id", "moduleReference"],
    	  fields: {
    	    isExport: (0, _utils.validate)(bool),
    	    id: (0, _utils.validateType)("Identifier"),
    	    moduleReference: (0, _utils.validateType)(["TSEntityName", "TSExternalModuleReference"]),
    	    importKind: {
    	      validate: (0, _utils.assertOneOf)("type", "value"),
    	      optional: true
    	    }
    	  }
    	});
    	defineType("TSExternalModuleReference", {
    	  visitor: ["expression"],
    	  fields: {
    	    expression: (0, _utils.validateType)("StringLiteral")
    	  }
    	});
    	defineType("TSNonNullExpression", {
    	  aliases: ["Expression", "LVal", "PatternLike"],
    	  visitor: ["expression"],
    	  fields: {
    	    expression: (0, _utils.validateType)("Expression")
    	  }
    	});
    	defineType("TSExportAssignment", {
    	  aliases: ["Statement"],
    	  visitor: ["expression"],
    	  fields: {
    	    expression: (0, _utils.validateType)("Expression")
    	  }
    	});
    	defineType("TSNamespaceExportDeclaration", {
    	  aliases: ["Statement"],
    	  visitor: ["id"],
    	  fields: {
    	    id: (0, _utils.validateType)("Identifier")
    	  }
    	});
    	defineType("TSTypeAnnotation", {
    	  visitor: ["typeAnnotation"],
    	  fields: {
    	    typeAnnotation: {
    	      validate: (0, _utils.assertNodeType)("TSType")
    	    }
    	  }
    	});
    	defineType("TSTypeParameterInstantiation", {
    	  visitor: ["params"],
    	  fields: {
    	    params: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")))
    	    }
    	  }
    	});
    	defineType("TSTypeParameterDeclaration", {
    	  visitor: ["params"],
    	  fields: {
    	    params: {
    	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter")))
    	    }
    	  }
    	});
    	defineType("TSTypeParameter", {
    	  builder: ["constraint", "default", "name"],
    	  visitor: ["constraint", "default"],
    	  fields: {
    	    name: {
    	      validate: (0, _utils.assertValueType)("string")
    	    },
    	    in: {
    	      validate: (0, _utils.assertValueType)("boolean"),
    	      optional: true
    	    },
    	    out: {
    	      validate: (0, _utils.assertValueType)("boolean"),
    	      optional: true
    	    },
    	    const: {
    	      validate: (0, _utils.assertValueType)("boolean"),
    	      optional: true
    	    },
    	    constraint: {
    	      validate: (0, _utils.assertNodeType)("TSType"),
    	      optional: true
    	    },
    	    default: {
    	      validate: (0, _utils.assertNodeType)("TSType"),
    	      optional: true
    	    }
    	  }
    	});

    	
    	return typescript$1;
    }

    var deprecatedAliases = {};

    var hasRequiredDeprecatedAliases;

    function requireDeprecatedAliases () {
    	if (hasRequiredDeprecatedAliases) return deprecatedAliases;
    	hasRequiredDeprecatedAliases = 1;

    	Object.defineProperty(deprecatedAliases, "__esModule", {
    	  value: true
    	});
    	deprecatedAliases.DEPRECATED_ALIASES = void 0;
    	const DEPRECATED_ALIASES = {
    	  ModuleDeclaration: "ImportOrExportDeclaration"
    	};
    	deprecatedAliases.DEPRECATED_ALIASES = DEPRECATED_ALIASES;

    	
    	return deprecatedAliases;
    }

    var hasRequiredDefinitions;

    function requireDefinitions () {
    	if (hasRequiredDefinitions) return definitions;
    	hasRequiredDefinitions = 1;
    	(function (exports) {

    		Object.defineProperty(exports, "__esModule", {
    		  value: true
    		});
    		Object.defineProperty(exports, "ALIAS_KEYS", {
    		  enumerable: true,
    		  get: function () {
    		    return _utils.ALIAS_KEYS;
    		  }
    		});
    		Object.defineProperty(exports, "BUILDER_KEYS", {
    		  enumerable: true,
    		  get: function () {
    		    return _utils.BUILDER_KEYS;
    		  }
    		});
    		Object.defineProperty(exports, "DEPRECATED_ALIASES", {
    		  enumerable: true,
    		  get: function () {
    		    return _deprecatedAliases.DEPRECATED_ALIASES;
    		  }
    		});
    		Object.defineProperty(exports, "DEPRECATED_KEYS", {
    		  enumerable: true,
    		  get: function () {
    		    return _utils.DEPRECATED_KEYS;
    		  }
    		});
    		Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
    		  enumerable: true,
    		  get: function () {
    		    return _utils.FLIPPED_ALIAS_KEYS;
    		  }
    		});
    		Object.defineProperty(exports, "NODE_FIELDS", {
    		  enumerable: true,
    		  get: function () {
    		    return _utils.NODE_FIELDS;
    		  }
    		});
    		Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
    		  enumerable: true,
    		  get: function () {
    		    return _utils.NODE_PARENT_VALIDATIONS;
    		  }
    		});
    		Object.defineProperty(exports, "PLACEHOLDERS", {
    		  enumerable: true,
    		  get: function () {
    		    return _placeholders.PLACEHOLDERS;
    		  }
    		});
    		Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
    		  enumerable: true,
    		  get: function () {
    		    return _placeholders.PLACEHOLDERS_ALIAS;
    		  }
    		});
    		Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
    		  enumerable: true,
    		  get: function () {
    		    return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
    		  }
    		});
    		exports.TYPES = void 0;
    		Object.defineProperty(exports, "VISITOR_KEYS", {
    		  enumerable: true,
    		  get: function () {
    		    return _utils.VISITOR_KEYS;
    		  }
    		});
    		var _toFastProperties = requireToFastProperties();
    		requireCore();
    		requireFlow$1();
    		requireJsx$1();
    		requireMisc();
    		requireExperimental();
    		requireTypescript$1();
    		var _utils = requireUtils();
    		var _placeholders = requirePlaceholders();
    		var _deprecatedAliases = requireDeprecatedAliases();
    		Object.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach(deprecatedAlias => {
    		  _utils.FLIPPED_ALIAS_KEYS[deprecatedAlias] = _utils.FLIPPED_ALIAS_KEYS[_deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]];
    		});
    		_toFastProperties(_utils.VISITOR_KEYS);
    		_toFastProperties(_utils.ALIAS_KEYS);
    		_toFastProperties(_utils.FLIPPED_ALIAS_KEYS);
    		_toFastProperties(_utils.NODE_FIELDS);
    		_toFastProperties(_utils.BUILDER_KEYS);
    		_toFastProperties(_utils.DEPRECATED_KEYS);
    		_toFastProperties(_placeholders.PLACEHOLDERS_ALIAS);
    		_toFastProperties(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);
    		const TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
    		exports.TYPES = TYPES;

    		
    	} (definitions));
    	return definitions;
    }

    var hasRequiredValidate;

    function requireValidate () {
    	if (hasRequiredValidate) return validate;
    	hasRequiredValidate = 1;

    	Object.defineProperty(validate, "__esModule", {
    	  value: true
    	});
    	validate.default = validate$1;
    	validate.validateChild = validateChild;
    	validate.validateField = validateField;
    	var _index = requireDefinitions();
    	function validate$1(node, key, val) {
    	  if (!node) return;
    	  const fields = _index.NODE_FIELDS[node.type];
    	  if (!fields) return;
    	  const field = fields[key];
    	  validateField(node, key, val, field);
    	  validateChild(node, key, val);
    	}
    	function validateField(node, key, val, field) {
    	  if (!(field != null && field.validate)) return;
    	  if (field.optional && val == null) return;
    	  field.validate(node, key, val);
    	}
    	function validateChild(node, key, val) {
    	  if (val == null) return;
    	  const validate = _index.NODE_PARENT_VALIDATIONS[val.type];
    	  if (!validate) return;
    	  validate(node, key, val);
    	}

    	
    	return validate;
    }

    var hasRequiredValidateNode;

    function requireValidateNode () {
    	if (hasRequiredValidateNode) return validateNode;
    	hasRequiredValidateNode = 1;

    	Object.defineProperty(validateNode, "__esModule", {
    	  value: true
    	});
    	validateNode.default = validateNode$1;
    	var _validate = requireValidate();
    	var _index = requireLib$2();
    	function validateNode$1(node) {
    	  const keys = _index.BUILDER_KEYS[node.type];
    	  for (const key of keys) {
    	    (0, _validate.default)(node, key, node[key]);
    	  }
    	  return node;
    	}

    	
    	return validateNode;
    }

    var hasRequiredGenerated$2;

    function requireGenerated$2 () {
    	if (hasRequiredGenerated$2) return generated$2;
    	hasRequiredGenerated$2 = 1;

    	Object.defineProperty(generated$2, "__esModule", {
    	  value: true
    	});
    	generated$2.anyTypeAnnotation = anyTypeAnnotation;
    	generated$2.argumentPlaceholder = argumentPlaceholder;
    	generated$2.arrayExpression = arrayExpression;
    	generated$2.arrayPattern = arrayPattern;
    	generated$2.arrayTypeAnnotation = arrayTypeAnnotation;
    	generated$2.arrowFunctionExpression = arrowFunctionExpression;
    	generated$2.assignmentExpression = assignmentExpression;
    	generated$2.assignmentPattern = assignmentPattern;
    	generated$2.awaitExpression = awaitExpression;
    	generated$2.bigIntLiteral = bigIntLiteral;
    	generated$2.binaryExpression = binaryExpression;
    	generated$2.bindExpression = bindExpression;
    	generated$2.blockStatement = blockStatement;
    	generated$2.booleanLiteral = booleanLiteral;
    	generated$2.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
    	generated$2.booleanTypeAnnotation = booleanTypeAnnotation;
    	generated$2.breakStatement = breakStatement;
    	generated$2.callExpression = callExpression;
    	generated$2.catchClause = catchClause;
    	generated$2.classAccessorProperty = classAccessorProperty;
    	generated$2.classBody = classBody;
    	generated$2.classDeclaration = classDeclaration;
    	generated$2.classExpression = classExpression;
    	generated$2.classImplements = classImplements;
    	generated$2.classMethod = classMethod;
    	generated$2.classPrivateMethod = classPrivateMethod;
    	generated$2.classPrivateProperty = classPrivateProperty;
    	generated$2.classProperty = classProperty;
    	generated$2.conditionalExpression = conditionalExpression;
    	generated$2.continueStatement = continueStatement;
    	generated$2.debuggerStatement = debuggerStatement;
    	generated$2.decimalLiteral = decimalLiteral;
    	generated$2.declareClass = declareClass;
    	generated$2.declareExportAllDeclaration = declareExportAllDeclaration;
    	generated$2.declareExportDeclaration = declareExportDeclaration;
    	generated$2.declareFunction = declareFunction;
    	generated$2.declareInterface = declareInterface;
    	generated$2.declareModule = declareModule;
    	generated$2.declareModuleExports = declareModuleExports;
    	generated$2.declareOpaqueType = declareOpaqueType;
    	generated$2.declareTypeAlias = declareTypeAlias;
    	generated$2.declareVariable = declareVariable;
    	generated$2.declaredPredicate = declaredPredicate;
    	generated$2.decorator = decorator;
    	generated$2.directive = directive;
    	generated$2.directiveLiteral = directiveLiteral;
    	generated$2.doExpression = doExpression;
    	generated$2.doWhileStatement = doWhileStatement;
    	generated$2.emptyStatement = emptyStatement;
    	generated$2.emptyTypeAnnotation = emptyTypeAnnotation;
    	generated$2.enumBooleanBody = enumBooleanBody;
    	generated$2.enumBooleanMember = enumBooleanMember;
    	generated$2.enumDeclaration = enumDeclaration;
    	generated$2.enumDefaultedMember = enumDefaultedMember;
    	generated$2.enumNumberBody = enumNumberBody;
    	generated$2.enumNumberMember = enumNumberMember;
    	generated$2.enumStringBody = enumStringBody;
    	generated$2.enumStringMember = enumStringMember;
    	generated$2.enumSymbolBody = enumSymbolBody;
    	generated$2.existsTypeAnnotation = existsTypeAnnotation;
    	generated$2.exportAllDeclaration = exportAllDeclaration;
    	generated$2.exportDefaultDeclaration = exportDefaultDeclaration;
    	generated$2.exportDefaultSpecifier = exportDefaultSpecifier;
    	generated$2.exportNamedDeclaration = exportNamedDeclaration;
    	generated$2.exportNamespaceSpecifier = exportNamespaceSpecifier;
    	generated$2.exportSpecifier = exportSpecifier;
    	generated$2.expressionStatement = expressionStatement;
    	generated$2.file = file;
    	generated$2.forInStatement = forInStatement;
    	generated$2.forOfStatement = forOfStatement;
    	generated$2.forStatement = forStatement;
    	generated$2.functionDeclaration = functionDeclaration;
    	generated$2.functionExpression = functionExpression;
    	generated$2.functionTypeAnnotation = functionTypeAnnotation;
    	generated$2.functionTypeParam = functionTypeParam;
    	generated$2.genericTypeAnnotation = genericTypeAnnotation;
    	generated$2.identifier = identifier;
    	generated$2.ifStatement = ifStatement;
    	generated$2.import = _import;
    	generated$2.importAttribute = importAttribute;
    	generated$2.importDeclaration = importDeclaration;
    	generated$2.importDefaultSpecifier = importDefaultSpecifier;
    	generated$2.importExpression = importExpression;
    	generated$2.importNamespaceSpecifier = importNamespaceSpecifier;
    	generated$2.importSpecifier = importSpecifier;
    	generated$2.indexedAccessType = indexedAccessType;
    	generated$2.inferredPredicate = inferredPredicate;
    	generated$2.interfaceDeclaration = interfaceDeclaration;
    	generated$2.interfaceExtends = interfaceExtends;
    	generated$2.interfaceTypeAnnotation = interfaceTypeAnnotation;
    	generated$2.interpreterDirective = interpreterDirective;
    	generated$2.intersectionTypeAnnotation = intersectionTypeAnnotation;
    	generated$2.jSXAttribute = generated$2.jsxAttribute = jsxAttribute;
    	generated$2.jSXClosingElement = generated$2.jsxClosingElement = jsxClosingElement;
    	generated$2.jSXClosingFragment = generated$2.jsxClosingFragment = jsxClosingFragment;
    	generated$2.jSXElement = generated$2.jsxElement = jsxElement;
    	generated$2.jSXEmptyExpression = generated$2.jsxEmptyExpression = jsxEmptyExpression;
    	generated$2.jSXExpressionContainer = generated$2.jsxExpressionContainer = jsxExpressionContainer;
    	generated$2.jSXFragment = generated$2.jsxFragment = jsxFragment;
    	generated$2.jSXIdentifier = generated$2.jsxIdentifier = jsxIdentifier;
    	generated$2.jSXMemberExpression = generated$2.jsxMemberExpression = jsxMemberExpression;
    	generated$2.jSXNamespacedName = generated$2.jsxNamespacedName = jsxNamespacedName;
    	generated$2.jSXOpeningElement = generated$2.jsxOpeningElement = jsxOpeningElement;
    	generated$2.jSXOpeningFragment = generated$2.jsxOpeningFragment = jsxOpeningFragment;
    	generated$2.jSXSpreadAttribute = generated$2.jsxSpreadAttribute = jsxSpreadAttribute;
    	generated$2.jSXSpreadChild = generated$2.jsxSpreadChild = jsxSpreadChild;
    	generated$2.jSXText = generated$2.jsxText = jsxText;
    	generated$2.labeledStatement = labeledStatement;
    	generated$2.logicalExpression = logicalExpression;
    	generated$2.memberExpression = memberExpression;
    	generated$2.metaProperty = metaProperty;
    	generated$2.mixedTypeAnnotation = mixedTypeAnnotation;
    	generated$2.moduleExpression = moduleExpression;
    	generated$2.newExpression = newExpression;
    	generated$2.noop = noop;
    	generated$2.nullLiteral = nullLiteral;
    	generated$2.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
    	generated$2.nullableTypeAnnotation = nullableTypeAnnotation;
    	generated$2.numberLiteral = NumberLiteral;
    	generated$2.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
    	generated$2.numberTypeAnnotation = numberTypeAnnotation;
    	generated$2.numericLiteral = numericLiteral;
    	generated$2.objectExpression = objectExpression;
    	generated$2.objectMethod = objectMethod;
    	generated$2.objectPattern = objectPattern;
    	generated$2.objectProperty = objectProperty;
    	generated$2.objectTypeAnnotation = objectTypeAnnotation;
    	generated$2.objectTypeCallProperty = objectTypeCallProperty;
    	generated$2.objectTypeIndexer = objectTypeIndexer;
    	generated$2.objectTypeInternalSlot = objectTypeInternalSlot;
    	generated$2.objectTypeProperty = objectTypeProperty;
    	generated$2.objectTypeSpreadProperty = objectTypeSpreadProperty;
    	generated$2.opaqueType = opaqueType;
    	generated$2.optionalCallExpression = optionalCallExpression;
    	generated$2.optionalIndexedAccessType = optionalIndexedAccessType;
    	generated$2.optionalMemberExpression = optionalMemberExpression;
    	generated$2.parenthesizedExpression = parenthesizedExpression;
    	generated$2.pipelineBareFunction = pipelineBareFunction;
    	generated$2.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
    	generated$2.pipelineTopicExpression = pipelineTopicExpression;
    	generated$2.placeholder = placeholder;
    	generated$2.privateName = privateName;
    	generated$2.program = program;
    	generated$2.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
    	generated$2.recordExpression = recordExpression;
    	generated$2.regExpLiteral = regExpLiteral;
    	generated$2.regexLiteral = RegexLiteral;
    	generated$2.restElement = restElement;
    	generated$2.restProperty = RestProperty;
    	generated$2.returnStatement = returnStatement;
    	generated$2.sequenceExpression = sequenceExpression;
    	generated$2.spreadElement = spreadElement;
    	generated$2.spreadProperty = SpreadProperty;
    	generated$2.staticBlock = staticBlock;
    	generated$2.stringLiteral = stringLiteral;
    	generated$2.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
    	generated$2.stringTypeAnnotation = stringTypeAnnotation;
    	generated$2.super = _super;
    	generated$2.switchCase = switchCase;
    	generated$2.switchStatement = switchStatement;
    	generated$2.symbolTypeAnnotation = symbolTypeAnnotation;
    	generated$2.taggedTemplateExpression = taggedTemplateExpression;
    	generated$2.templateElement = templateElement;
    	generated$2.templateLiteral = templateLiteral;
    	generated$2.thisExpression = thisExpression;
    	generated$2.thisTypeAnnotation = thisTypeAnnotation;
    	generated$2.throwStatement = throwStatement;
    	generated$2.topicReference = topicReference;
    	generated$2.tryStatement = tryStatement;
    	generated$2.tSAnyKeyword = generated$2.tsAnyKeyword = tsAnyKeyword;
    	generated$2.tSArrayType = generated$2.tsArrayType = tsArrayType;
    	generated$2.tSAsExpression = generated$2.tsAsExpression = tsAsExpression;
    	generated$2.tSBigIntKeyword = generated$2.tsBigIntKeyword = tsBigIntKeyword;
    	generated$2.tSBooleanKeyword = generated$2.tsBooleanKeyword = tsBooleanKeyword;
    	generated$2.tSCallSignatureDeclaration = generated$2.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
    	generated$2.tSConditionalType = generated$2.tsConditionalType = tsConditionalType;
    	generated$2.tSConstructSignatureDeclaration = generated$2.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
    	generated$2.tSConstructorType = generated$2.tsConstructorType = tsConstructorType;
    	generated$2.tSDeclareFunction = generated$2.tsDeclareFunction = tsDeclareFunction;
    	generated$2.tSDeclareMethod = generated$2.tsDeclareMethod = tsDeclareMethod;
    	generated$2.tSEnumDeclaration = generated$2.tsEnumDeclaration = tsEnumDeclaration;
    	generated$2.tSEnumMember = generated$2.tsEnumMember = tsEnumMember;
    	generated$2.tSExportAssignment = generated$2.tsExportAssignment = tsExportAssignment;
    	generated$2.tSExpressionWithTypeArguments = generated$2.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
    	generated$2.tSExternalModuleReference = generated$2.tsExternalModuleReference = tsExternalModuleReference;
    	generated$2.tSFunctionType = generated$2.tsFunctionType = tsFunctionType;
    	generated$2.tSImportEqualsDeclaration = generated$2.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
    	generated$2.tSImportType = generated$2.tsImportType = tsImportType;
    	generated$2.tSIndexSignature = generated$2.tsIndexSignature = tsIndexSignature;
    	generated$2.tSIndexedAccessType = generated$2.tsIndexedAccessType = tsIndexedAccessType;
    	generated$2.tSInferType = generated$2.tsInferType = tsInferType;
    	generated$2.tSInstantiationExpression = generated$2.tsInstantiationExpression = tsInstantiationExpression;
    	generated$2.tSInterfaceBody = generated$2.tsInterfaceBody = tsInterfaceBody;
    	generated$2.tSInterfaceDeclaration = generated$2.tsInterfaceDeclaration = tsInterfaceDeclaration;
    	generated$2.tSIntersectionType = generated$2.tsIntersectionType = tsIntersectionType;
    	generated$2.tSIntrinsicKeyword = generated$2.tsIntrinsicKeyword = tsIntrinsicKeyword;
    	generated$2.tSLiteralType = generated$2.tsLiteralType = tsLiteralType;
    	generated$2.tSMappedType = generated$2.tsMappedType = tsMappedType;
    	generated$2.tSMethodSignature = generated$2.tsMethodSignature = tsMethodSignature;
    	generated$2.tSModuleBlock = generated$2.tsModuleBlock = tsModuleBlock;
    	generated$2.tSModuleDeclaration = generated$2.tsModuleDeclaration = tsModuleDeclaration;
    	generated$2.tSNamedTupleMember = generated$2.tsNamedTupleMember = tsNamedTupleMember;
    	generated$2.tSNamespaceExportDeclaration = generated$2.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
    	generated$2.tSNeverKeyword = generated$2.tsNeverKeyword = tsNeverKeyword;
    	generated$2.tSNonNullExpression = generated$2.tsNonNullExpression = tsNonNullExpression;
    	generated$2.tSNullKeyword = generated$2.tsNullKeyword = tsNullKeyword;
    	generated$2.tSNumberKeyword = generated$2.tsNumberKeyword = tsNumberKeyword;
    	generated$2.tSObjectKeyword = generated$2.tsObjectKeyword = tsObjectKeyword;
    	generated$2.tSOptionalType = generated$2.tsOptionalType = tsOptionalType;
    	generated$2.tSParameterProperty = generated$2.tsParameterProperty = tsParameterProperty;
    	generated$2.tSParenthesizedType = generated$2.tsParenthesizedType = tsParenthesizedType;
    	generated$2.tSPropertySignature = generated$2.tsPropertySignature = tsPropertySignature;
    	generated$2.tSQualifiedName = generated$2.tsQualifiedName = tsQualifiedName;
    	generated$2.tSRestType = generated$2.tsRestType = tsRestType;
    	generated$2.tSSatisfiesExpression = generated$2.tsSatisfiesExpression = tsSatisfiesExpression;
    	generated$2.tSStringKeyword = generated$2.tsStringKeyword = tsStringKeyword;
    	generated$2.tSSymbolKeyword = generated$2.tsSymbolKeyword = tsSymbolKeyword;
    	generated$2.tSThisType = generated$2.tsThisType = tsThisType;
    	generated$2.tSTupleType = generated$2.tsTupleType = tsTupleType;
    	generated$2.tSTypeAliasDeclaration = generated$2.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
    	generated$2.tSTypeAnnotation = generated$2.tsTypeAnnotation = tsTypeAnnotation;
    	generated$2.tSTypeAssertion = generated$2.tsTypeAssertion = tsTypeAssertion;
    	generated$2.tSTypeLiteral = generated$2.tsTypeLiteral = tsTypeLiteral;
    	generated$2.tSTypeOperator = generated$2.tsTypeOperator = tsTypeOperator;
    	generated$2.tSTypeParameter = generated$2.tsTypeParameter = tsTypeParameter;
    	generated$2.tSTypeParameterDeclaration = generated$2.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
    	generated$2.tSTypeParameterInstantiation = generated$2.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
    	generated$2.tSTypePredicate = generated$2.tsTypePredicate = tsTypePredicate;
    	generated$2.tSTypeQuery = generated$2.tsTypeQuery = tsTypeQuery;
    	generated$2.tSTypeReference = generated$2.tsTypeReference = tsTypeReference;
    	generated$2.tSUndefinedKeyword = generated$2.tsUndefinedKeyword = tsUndefinedKeyword;
    	generated$2.tSUnionType = generated$2.tsUnionType = tsUnionType;
    	generated$2.tSUnknownKeyword = generated$2.tsUnknownKeyword = tsUnknownKeyword;
    	generated$2.tSVoidKeyword = generated$2.tsVoidKeyword = tsVoidKeyword;
    	generated$2.tupleExpression = tupleExpression;
    	generated$2.tupleTypeAnnotation = tupleTypeAnnotation;
    	generated$2.typeAlias = typeAlias;
    	generated$2.typeAnnotation = typeAnnotation;
    	generated$2.typeCastExpression = typeCastExpression;
    	generated$2.typeParameter = typeParameter;
    	generated$2.typeParameterDeclaration = typeParameterDeclaration;
    	generated$2.typeParameterInstantiation = typeParameterInstantiation;
    	generated$2.typeofTypeAnnotation = typeofTypeAnnotation;
    	generated$2.unaryExpression = unaryExpression;
    	generated$2.unionTypeAnnotation = unionTypeAnnotation;
    	generated$2.updateExpression = updateExpression;
    	generated$2.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
    	generated$2.variableDeclaration = variableDeclaration;
    	generated$2.variableDeclarator = variableDeclarator;
    	generated$2.variance = variance;
    	generated$2.voidTypeAnnotation = voidTypeAnnotation;
    	generated$2.whileStatement = whileStatement;
    	generated$2.withStatement = withStatement;
    	generated$2.yieldExpression = yieldExpression;
    	var _validateNode = requireValidateNode();
    	var _deprecationWarning = requireDeprecationWarning();
    	function arrayExpression(elements = []) {
    	  return (0, _validateNode.default)({
    	    type: "ArrayExpression",
    	    elements
    	  });
    	}
    	function assignmentExpression(operator, left, right) {
    	  return (0, _validateNode.default)({
    	    type: "AssignmentExpression",
    	    operator,
    	    left,
    	    right
    	  });
    	}
    	function binaryExpression(operator, left, right) {
    	  return (0, _validateNode.default)({
    	    type: "BinaryExpression",
    	    operator,
    	    left,
    	    right
    	  });
    	}
    	function interpreterDirective(value) {
    	  return (0, _validateNode.default)({
    	    type: "InterpreterDirective",
    	    value
    	  });
    	}
    	function directive(value) {
    	  return (0, _validateNode.default)({
    	    type: "Directive",
    	    value
    	  });
    	}
    	function directiveLiteral(value) {
    	  return (0, _validateNode.default)({
    	    type: "DirectiveLiteral",
    	    value
    	  });
    	}
    	function blockStatement(body, directives = []) {
    	  return (0, _validateNode.default)({
    	    type: "BlockStatement",
    	    body,
    	    directives
    	  });
    	}
    	function breakStatement(label = null) {
    	  return (0, _validateNode.default)({
    	    type: "BreakStatement",
    	    label
    	  });
    	}
    	function callExpression(callee, _arguments) {
    	  return (0, _validateNode.default)({
    	    type: "CallExpression",
    	    callee,
    	    arguments: _arguments
    	  });
    	}
    	function catchClause(param = null, body) {
    	  return (0, _validateNode.default)({
    	    type: "CatchClause",
    	    param,
    	    body
    	  });
    	}
    	function conditionalExpression(test, consequent, alternate) {
    	  return (0, _validateNode.default)({
    	    type: "ConditionalExpression",
    	    test,
    	    consequent,
    	    alternate
    	  });
    	}
    	function continueStatement(label = null) {
    	  return (0, _validateNode.default)({
    	    type: "ContinueStatement",
    	    label
    	  });
    	}
    	function debuggerStatement() {
    	  return {
    	    type: "DebuggerStatement"
    	  };
    	}
    	function doWhileStatement(test, body) {
    	  return (0, _validateNode.default)({
    	    type: "DoWhileStatement",
    	    test,
    	    body
    	  });
    	}
    	function emptyStatement() {
    	  return {
    	    type: "EmptyStatement"
    	  };
    	}
    	function expressionStatement(expression) {
    	  return (0, _validateNode.default)({
    	    type: "ExpressionStatement",
    	    expression
    	  });
    	}
    	function file(program, comments = null, tokens = null) {
    	  return (0, _validateNode.default)({
    	    type: "File",
    	    program,
    	    comments,
    	    tokens
    	  });
    	}
    	function forInStatement(left, right, body) {
    	  return (0, _validateNode.default)({
    	    type: "ForInStatement",
    	    left,
    	    right,
    	    body
    	  });
    	}
    	function forStatement(init = null, test = null, update = null, body) {
    	  return (0, _validateNode.default)({
    	    type: "ForStatement",
    	    init,
    	    test,
    	    update,
    	    body
    	  });
    	}
    	function functionDeclaration(id = null, params, body, generator = false, async = false) {
    	  return (0, _validateNode.default)({
    	    type: "FunctionDeclaration",
    	    id,
    	    params,
    	    body,
    	    generator,
    	    async
    	  });
    	}
    	function functionExpression(id = null, params, body, generator = false, async = false) {
    	  return (0, _validateNode.default)({
    	    type: "FunctionExpression",
    	    id,
    	    params,
    	    body,
    	    generator,
    	    async
    	  });
    	}
    	function identifier(name) {
    	  return (0, _validateNode.default)({
    	    type: "Identifier",
    	    name
    	  });
    	}
    	function ifStatement(test, consequent, alternate = null) {
    	  return (0, _validateNode.default)({
    	    type: "IfStatement",
    	    test,
    	    consequent,
    	    alternate
    	  });
    	}
    	function labeledStatement(label, body) {
    	  return (0, _validateNode.default)({
    	    type: "LabeledStatement",
    	    label,
    	    body
    	  });
    	}
    	function stringLiteral(value) {
    	  return (0, _validateNode.default)({
    	    type: "StringLiteral",
    	    value
    	  });
    	}
    	function numericLiteral(value) {
    	  return (0, _validateNode.default)({
    	    type: "NumericLiteral",
    	    value
    	  });
    	}
    	function nullLiteral() {
    	  return {
    	    type: "NullLiteral"
    	  };
    	}
    	function booleanLiteral(value) {
    	  return (0, _validateNode.default)({
    	    type: "BooleanLiteral",
    	    value
    	  });
    	}
    	function regExpLiteral(pattern, flags = "") {
    	  return (0, _validateNode.default)({
    	    type: "RegExpLiteral",
    	    pattern,
    	    flags
    	  });
    	}
    	function logicalExpression(operator, left, right) {
    	  return (0, _validateNode.default)({
    	    type: "LogicalExpression",
    	    operator,
    	    left,
    	    right
    	  });
    	}
    	function memberExpression(object, property, computed = false, optional = null) {
    	  return (0, _validateNode.default)({
    	    type: "MemberExpression",
    	    object,
    	    property,
    	    computed,
    	    optional
    	  });
    	}
    	function newExpression(callee, _arguments) {
    	  return (0, _validateNode.default)({
    	    type: "NewExpression",
    	    callee,
    	    arguments: _arguments
    	  });
    	}
    	function program(body, directives = [], sourceType = "script", interpreter = null) {
    	  return (0, _validateNode.default)({
    	    type: "Program",
    	    body,
    	    directives,
    	    sourceType,
    	    interpreter,
    	    sourceFile: null
    	  });
    	}
    	function objectExpression(properties) {
    	  return (0, _validateNode.default)({
    	    type: "ObjectExpression",
    	    properties
    	  });
    	}
    	function objectMethod(kind = "method", key, params, body, computed = false, generator = false, async = false) {
    	  return (0, _validateNode.default)({
    	    type: "ObjectMethod",
    	    kind,
    	    key,
    	    params,
    	    body,
    	    computed,
    	    generator,
    	    async
    	  });
    	}
    	function objectProperty(key, value, computed = false, shorthand = false, decorators = null) {
    	  return (0, _validateNode.default)({
    	    type: "ObjectProperty",
    	    key,
    	    value,
    	    computed,
    	    shorthand,
    	    decorators
    	  });
    	}
    	function restElement(argument) {
    	  return (0, _validateNode.default)({
    	    type: "RestElement",
    	    argument
    	  });
    	}
    	function returnStatement(argument = null) {
    	  return (0, _validateNode.default)({
    	    type: "ReturnStatement",
    	    argument
    	  });
    	}
    	function sequenceExpression(expressions) {
    	  return (0, _validateNode.default)({
    	    type: "SequenceExpression",
    	    expressions
    	  });
    	}
    	function parenthesizedExpression(expression) {
    	  return (0, _validateNode.default)({
    	    type: "ParenthesizedExpression",
    	    expression
    	  });
    	}
    	function switchCase(test = null, consequent) {
    	  return (0, _validateNode.default)({
    	    type: "SwitchCase",
    	    test,
    	    consequent
    	  });
    	}
    	function switchStatement(discriminant, cases) {
    	  return (0, _validateNode.default)({
    	    type: "SwitchStatement",
    	    discriminant,
    	    cases
    	  });
    	}
    	function thisExpression() {
    	  return {
    	    type: "ThisExpression"
    	  };
    	}
    	function throwStatement(argument) {
    	  return (0, _validateNode.default)({
    	    type: "ThrowStatement",
    	    argument
    	  });
    	}
    	function tryStatement(block, handler = null, finalizer = null) {
    	  return (0, _validateNode.default)({
    	    type: "TryStatement",
    	    block,
    	    handler,
    	    finalizer
    	  });
    	}
    	function unaryExpression(operator, argument, prefix = true) {
    	  return (0, _validateNode.default)({
    	    type: "UnaryExpression",
    	    operator,
    	    argument,
    	    prefix
    	  });
    	}
    	function updateExpression(operator, argument, prefix = false) {
    	  return (0, _validateNode.default)({
    	    type: "UpdateExpression",
    	    operator,
    	    argument,
    	    prefix
    	  });
    	}
    	function variableDeclaration(kind, declarations) {
    	  return (0, _validateNode.default)({
    	    type: "VariableDeclaration",
    	    kind,
    	    declarations
    	  });
    	}
    	function variableDeclarator(id, init = null) {
    	  return (0, _validateNode.default)({
    	    type: "VariableDeclarator",
    	    id,
    	    init
    	  });
    	}
    	function whileStatement(test, body) {
    	  return (0, _validateNode.default)({
    	    type: "WhileStatement",
    	    test,
    	    body
    	  });
    	}
    	function withStatement(object, body) {
    	  return (0, _validateNode.default)({
    	    type: "WithStatement",
    	    object,
    	    body
    	  });
    	}
    	function assignmentPattern(left, right) {
    	  return (0, _validateNode.default)({
    	    type: "AssignmentPattern",
    	    left,
    	    right
    	  });
    	}
    	function arrayPattern(elements) {
    	  return (0, _validateNode.default)({
    	    type: "ArrayPattern",
    	    elements
    	  });
    	}
    	function arrowFunctionExpression(params, body, async = false) {
    	  return (0, _validateNode.default)({
    	    type: "ArrowFunctionExpression",
    	    params,
    	    body,
    	    async,
    	    expression: null
    	  });
    	}
    	function classBody(body) {
    	  return (0, _validateNode.default)({
    	    type: "ClassBody",
    	    body
    	  });
    	}
    	function classExpression(id = null, superClass = null, body, decorators = null) {
    	  return (0, _validateNode.default)({
    	    type: "ClassExpression",
    	    id,
    	    superClass,
    	    body,
    	    decorators
    	  });
    	}
    	function classDeclaration(id = null, superClass = null, body, decorators = null) {
    	  return (0, _validateNode.default)({
    	    type: "ClassDeclaration",
    	    id,
    	    superClass,
    	    body,
    	    decorators
    	  });
    	}
    	function exportAllDeclaration(source) {
    	  return (0, _validateNode.default)({
    	    type: "ExportAllDeclaration",
    	    source
    	  });
    	}
    	function exportDefaultDeclaration(declaration) {
    	  return (0, _validateNode.default)({
    	    type: "ExportDefaultDeclaration",
    	    declaration
    	  });
    	}
    	function exportNamedDeclaration(declaration = null, specifiers = [], source = null) {
    	  return (0, _validateNode.default)({
    	    type: "ExportNamedDeclaration",
    	    declaration,
    	    specifiers,
    	    source
    	  });
    	}
    	function exportSpecifier(local, exported) {
    	  return (0, _validateNode.default)({
    	    type: "ExportSpecifier",
    	    local,
    	    exported
    	  });
    	}
    	function forOfStatement(left, right, body, _await = false) {
    	  return (0, _validateNode.default)({
    	    type: "ForOfStatement",
    	    left,
    	    right,
    	    body,
    	    await: _await
    	  });
    	}
    	function importDeclaration(specifiers, source) {
    	  return (0, _validateNode.default)({
    	    type: "ImportDeclaration",
    	    specifiers,
    	    source
    	  });
    	}
    	function importDefaultSpecifier(local) {
    	  return (0, _validateNode.default)({
    	    type: "ImportDefaultSpecifier",
    	    local
    	  });
    	}
    	function importNamespaceSpecifier(local) {
    	  return (0, _validateNode.default)({
    	    type: "ImportNamespaceSpecifier",
    	    local
    	  });
    	}
    	function importSpecifier(local, imported) {
    	  return (0, _validateNode.default)({
    	    type: "ImportSpecifier",
    	    local,
    	    imported
    	  });
    	}
    	function importExpression(source, options = null) {
    	  return (0, _validateNode.default)({
    	    type: "ImportExpression",
    	    source,
    	    options
    	  });
    	}
    	function metaProperty(meta, property) {
    	  return (0, _validateNode.default)({
    	    type: "MetaProperty",
    	    meta,
    	    property
    	  });
    	}
    	function classMethod(kind = "method", key, params, body, computed = false, _static = false, generator = false, async = false) {
    	  return (0, _validateNode.default)({
    	    type: "ClassMethod",
    	    kind,
    	    key,
    	    params,
    	    body,
    	    computed,
    	    static: _static,
    	    generator,
    	    async
    	  });
    	}
    	function objectPattern(properties) {
    	  return (0, _validateNode.default)({
    	    type: "ObjectPattern",
    	    properties
    	  });
    	}
    	function spreadElement(argument) {
    	  return (0, _validateNode.default)({
    	    type: "SpreadElement",
    	    argument
    	  });
    	}
    	function _super() {
    	  return {
    	    type: "Super"
    	  };
    	}
    	function taggedTemplateExpression(tag, quasi) {
    	  return (0, _validateNode.default)({
    	    type: "TaggedTemplateExpression",
    	    tag,
    	    quasi
    	  });
    	}
    	function templateElement(value, tail = false) {
    	  return (0, _validateNode.default)({
    	    type: "TemplateElement",
    	    value,
    	    tail
    	  });
    	}
    	function templateLiteral(quasis, expressions) {
    	  return (0, _validateNode.default)({
    	    type: "TemplateLiteral",
    	    quasis,
    	    expressions
    	  });
    	}
    	function yieldExpression(argument = null, delegate = false) {
    	  return (0, _validateNode.default)({
    	    type: "YieldExpression",
    	    argument,
    	    delegate
    	  });
    	}
    	function awaitExpression(argument) {
    	  return (0, _validateNode.default)({
    	    type: "AwaitExpression",
    	    argument
    	  });
    	}
    	function _import() {
    	  return {
    	    type: "Import"
    	  };
    	}
    	function bigIntLiteral(value) {
    	  return (0, _validateNode.default)({
    	    type: "BigIntLiteral",
    	    value
    	  });
    	}
    	function exportNamespaceSpecifier(exported) {
    	  return (0, _validateNode.default)({
    	    type: "ExportNamespaceSpecifier",
    	    exported
    	  });
    	}
    	function optionalMemberExpression(object, property, computed = false, optional) {
    	  return (0, _validateNode.default)({
    	    type: "OptionalMemberExpression",
    	    object,
    	    property,
    	    computed,
    	    optional
    	  });
    	}
    	function optionalCallExpression(callee, _arguments, optional) {
    	  return (0, _validateNode.default)({
    	    type: "OptionalCallExpression",
    	    callee,
    	    arguments: _arguments,
    	    optional
    	  });
    	}
    	function classProperty(key, value = null, typeAnnotation = null, decorators = null, computed = false, _static = false) {
    	  return (0, _validateNode.default)({
    	    type: "ClassProperty",
    	    key,
    	    value,
    	    typeAnnotation,
    	    decorators,
    	    computed,
    	    static: _static
    	  });
    	}
    	function classAccessorProperty(key, value = null, typeAnnotation = null, decorators = null, computed = false, _static = false) {
    	  return (0, _validateNode.default)({
    	    type: "ClassAccessorProperty",
    	    key,
    	    value,
    	    typeAnnotation,
    	    decorators,
    	    computed,
    	    static: _static
    	  });
    	}
    	function classPrivateProperty(key, value = null, decorators = null, _static = false) {
    	  return (0, _validateNode.default)({
    	    type: "ClassPrivateProperty",
    	    key,
    	    value,
    	    decorators,
    	    static: _static
    	  });
    	}
    	function classPrivateMethod(kind = "method", key, params, body, _static = false) {
    	  return (0, _validateNode.default)({
    	    type: "ClassPrivateMethod",
    	    kind,
    	    key,
    	    params,
    	    body,
    	    static: _static
    	  });
    	}
    	function privateName(id) {
    	  return (0, _validateNode.default)({
    	    type: "PrivateName",
    	    id
    	  });
    	}
    	function staticBlock(body) {
    	  return (0, _validateNode.default)({
    	    type: "StaticBlock",
    	    body
    	  });
    	}
    	function anyTypeAnnotation() {
    	  return {
    	    type: "AnyTypeAnnotation"
    	  };
    	}
    	function arrayTypeAnnotation(elementType) {
    	  return (0, _validateNode.default)({
    	    type: "ArrayTypeAnnotation",
    	    elementType
    	  });
    	}
    	function booleanTypeAnnotation() {
    	  return {
    	    type: "BooleanTypeAnnotation"
    	  };
    	}
    	function booleanLiteralTypeAnnotation(value) {
    	  return (0, _validateNode.default)({
    	    type: "BooleanLiteralTypeAnnotation",
    	    value
    	  });
    	}
    	function nullLiteralTypeAnnotation() {
    	  return {
    	    type: "NullLiteralTypeAnnotation"
    	  };
    	}
    	function classImplements(id, typeParameters = null) {
    	  return (0, _validateNode.default)({
    	    type: "ClassImplements",
    	    id,
    	    typeParameters
    	  });
    	}
    	function declareClass(id, typeParameters = null, _extends = null, body) {
    	  return (0, _validateNode.default)({
    	    type: "DeclareClass",
    	    id,
    	    typeParameters,
    	    extends: _extends,
    	    body
    	  });
    	}
    	function declareFunction(id) {
    	  return (0, _validateNode.default)({
    	    type: "DeclareFunction",
    	    id
    	  });
    	}
    	function declareInterface(id, typeParameters = null, _extends = null, body) {
    	  return (0, _validateNode.default)({
    	    type: "DeclareInterface",
    	    id,
    	    typeParameters,
    	    extends: _extends,
    	    body
    	  });
    	}
    	function declareModule(id, body, kind = null) {
    	  return (0, _validateNode.default)({
    	    type: "DeclareModule",
    	    id,
    	    body,
    	    kind
    	  });
    	}
    	function declareModuleExports(typeAnnotation) {
    	  return (0, _validateNode.default)({
    	    type: "DeclareModuleExports",
    	    typeAnnotation
    	  });
    	}
    	function declareTypeAlias(id, typeParameters = null, right) {
    	  return (0, _validateNode.default)({
    	    type: "DeclareTypeAlias",
    	    id,
    	    typeParameters,
    	    right
    	  });
    	}
    	function declareOpaqueType(id, typeParameters = null, supertype = null) {
    	  return (0, _validateNode.default)({
    	    type: "DeclareOpaqueType",
    	    id,
    	    typeParameters,
    	    supertype
    	  });
    	}
    	function declareVariable(id) {
    	  return (0, _validateNode.default)({
    	    type: "DeclareVariable",
    	    id
    	  });
    	}
    	function declareExportDeclaration(declaration = null, specifiers = null, source = null) {
    	  return (0, _validateNode.default)({
    	    type: "DeclareExportDeclaration",
    	    declaration,
    	    specifiers,
    	    source
    	  });
    	}
    	function declareExportAllDeclaration(source) {
    	  return (0, _validateNode.default)({
    	    type: "DeclareExportAllDeclaration",
    	    source
    	  });
    	}
    	function declaredPredicate(value) {
    	  return (0, _validateNode.default)({
    	    type: "DeclaredPredicate",
    	    value
    	  });
    	}
    	function existsTypeAnnotation() {
    	  return {
    	    type: "ExistsTypeAnnotation"
    	  };
    	}
    	function functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {
    	  return (0, _validateNode.default)({
    	    type: "FunctionTypeAnnotation",
    	    typeParameters,
    	    params,
    	    rest,
    	    returnType
    	  });
    	}
    	function functionTypeParam(name = null, typeAnnotation) {
    	  return (0, _validateNode.default)({
    	    type: "FunctionTypeParam",
    	    name,
    	    typeAnnotation
    	  });
    	}
    	function genericTypeAnnotation(id, typeParameters = null) {
    	  return (0, _validateNode.default)({
    	    type: "GenericTypeAnnotation",
    	    id,
    	    typeParameters
    	  });
    	}
    	function inferredPredicate() {
    	  return {
    	    type: "InferredPredicate"
    	  };
    	}
    	function interfaceExtends(id, typeParameters = null) {
    	  return (0, _validateNode.default)({
    	    type: "InterfaceExtends",
    	    id,
    	    typeParameters
    	  });
    	}
    	function interfaceDeclaration(id, typeParameters = null, _extends = null, body) {
    	  return (0, _validateNode.default)({
    	    type: "InterfaceDeclaration",
    	    id,
    	    typeParameters,
    	    extends: _extends,
    	    body
    	  });
    	}
    	function interfaceTypeAnnotation(_extends = null, body) {
    	  return (0, _validateNode.default)({
    	    type: "InterfaceTypeAnnotation",
    	    extends: _extends,
    	    body
    	  });
    	}
    	function intersectionTypeAnnotation(types) {
    	  return (0, _validateNode.default)({
    	    type: "IntersectionTypeAnnotation",
    	    types
    	  });
    	}
    	function mixedTypeAnnotation() {
    	  return {
    	    type: "MixedTypeAnnotation"
    	  };
    	}
    	function emptyTypeAnnotation() {
    	  return {
    	    type: "EmptyTypeAnnotation"
    	  };
    	}
    	function nullableTypeAnnotation(typeAnnotation) {
    	  return (0, _validateNode.default)({
    	    type: "NullableTypeAnnotation",
    	    typeAnnotation
    	  });
    	}
    	function numberLiteralTypeAnnotation(value) {
    	  return (0, _validateNode.default)({
    	    type: "NumberLiteralTypeAnnotation",
    	    value
    	  });
    	}
    	function numberTypeAnnotation() {
    	  return {
    	    type: "NumberTypeAnnotation"
    	  };
    	}
    	function objectTypeAnnotation(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {
    	  return (0, _validateNode.default)({
    	    type: "ObjectTypeAnnotation",
    	    properties,
    	    indexers,
    	    callProperties,
    	    internalSlots,
    	    exact
    	  });
    	}
    	function objectTypeInternalSlot(id, value, optional, _static, method) {
    	  return (0, _validateNode.default)({
    	    type: "ObjectTypeInternalSlot",
    	    id,
    	    value,
    	    optional,
    	    static: _static,
    	    method
    	  });
    	}
    	function objectTypeCallProperty(value) {
    	  return (0, _validateNode.default)({
    	    type: "ObjectTypeCallProperty",
    	    value,
    	    static: null
    	  });
    	}
    	function objectTypeIndexer(id = null, key, value, variance = null) {
    	  return (0, _validateNode.default)({
    	    type: "ObjectTypeIndexer",
    	    id,
    	    key,
    	    value,
    	    variance,
    	    static: null
    	  });
    	}
    	function objectTypeProperty(key, value, variance = null) {
    	  return (0, _validateNode.default)({
    	    type: "ObjectTypeProperty",
    	    key,
    	    value,
    	    variance,
    	    kind: null,
    	    method: null,
    	    optional: null,
    	    proto: null,
    	    static: null
    	  });
    	}
    	function objectTypeSpreadProperty(argument) {
    	  return (0, _validateNode.default)({
    	    type: "ObjectTypeSpreadProperty",
    	    argument
    	  });
    	}
    	function opaqueType(id, typeParameters = null, supertype = null, impltype) {
    	  return (0, _validateNode.default)({
    	    type: "OpaqueType",
    	    id,
    	    typeParameters,
    	    supertype,
    	    impltype
    	  });
    	}
    	function qualifiedTypeIdentifier(id, qualification) {
    	  return (0, _validateNode.default)({
    	    type: "QualifiedTypeIdentifier",
    	    id,
    	    qualification
    	  });
    	}
    	function stringLiteralTypeAnnotation(value) {
    	  return (0, _validateNode.default)({
    	    type: "StringLiteralTypeAnnotation",
    	    value
    	  });
    	}
    	function stringTypeAnnotation() {
    	  return {
    	    type: "StringTypeAnnotation"
    	  };
    	}
    	function symbolTypeAnnotation() {
    	  return {
    	    type: "SymbolTypeAnnotation"
    	  };
    	}
    	function thisTypeAnnotation() {
    	  return {
    	    type: "ThisTypeAnnotation"
    	  };
    	}
    	function tupleTypeAnnotation(types) {
    	  return (0, _validateNode.default)({
    	    type: "TupleTypeAnnotation",
    	    types
    	  });
    	}
    	function typeofTypeAnnotation(argument) {
    	  return (0, _validateNode.default)({
    	    type: "TypeofTypeAnnotation",
    	    argument
    	  });
    	}
    	function typeAlias(id, typeParameters = null, right) {
    	  return (0, _validateNode.default)({
    	    type: "TypeAlias",
    	    id,
    	    typeParameters,
    	    right
    	  });
    	}
    	function typeAnnotation(typeAnnotation) {
    	  return (0, _validateNode.default)({
    	    type: "TypeAnnotation",
    	    typeAnnotation
    	  });
    	}
    	function typeCastExpression(expression, typeAnnotation) {
    	  return (0, _validateNode.default)({
    	    type: "TypeCastExpression",
    	    expression,
    	    typeAnnotation
    	  });
    	}
    	function typeParameter(bound = null, _default = null, variance = null) {
    	  return (0, _validateNode.default)({
    	    type: "TypeParameter",
    	    bound,
    	    default: _default,
    	    variance,
    	    name: null
    	  });
    	}
    	function typeParameterDeclaration(params) {
    	  return (0, _validateNode.default)({
    	    type: "TypeParameterDeclaration",
    	    params
    	  });
    	}
    	function typeParameterInstantiation(params) {
    	  return (0, _validateNode.default)({
    	    type: "TypeParameterInstantiation",
    	    params
    	  });
    	}
    	function unionTypeAnnotation(types) {
    	  return (0, _validateNode.default)({
    	    type: "UnionTypeAnnotation",
    	    types
    	  });
    	}
    	function variance(kind) {
    	  return (0, _validateNode.default)({
    	    type: "Variance",
    	    kind
    	  });
    	}
    	function voidTypeAnnotation() {
    	  return {
    	    type: "VoidTypeAnnotation"
    	  };
    	}
    	function enumDeclaration(id, body) {
    	  return (0, _validateNode.default)({
    	    type: "EnumDeclaration",
    	    id,
    	    body
    	  });
    	}
    	function enumBooleanBody(members) {
    	  return (0, _validateNode.default)({
    	    type: "EnumBooleanBody",
    	    members,
    	    explicitType: null,
    	    hasUnknownMembers: null
    	  });
    	}
    	function enumNumberBody(members) {
    	  return (0, _validateNode.default)({
    	    type: "EnumNumberBody",
    	    members,
    	    explicitType: null,
    	    hasUnknownMembers: null
    	  });
    	}
    	function enumStringBody(members) {
    	  return (0, _validateNode.default)({
    	    type: "EnumStringBody",
    	    members,
    	    explicitType: null,
    	    hasUnknownMembers: null
    	  });
    	}
    	function enumSymbolBody(members) {
    	  return (0, _validateNode.default)({
    	    type: "EnumSymbolBody",
    	    members,
    	    hasUnknownMembers: null
    	  });
    	}
    	function enumBooleanMember(id) {
    	  return (0, _validateNode.default)({
    	    type: "EnumBooleanMember",
    	    id,
    	    init: null
    	  });
    	}
    	function enumNumberMember(id, init) {
    	  return (0, _validateNode.default)({
    	    type: "EnumNumberMember",
    	    id,
    	    init
    	  });
    	}
    	function enumStringMember(id, init) {
    	  return (0, _validateNode.default)({
    	    type: "EnumStringMember",
    	    id,
    	    init
    	  });
    	}
    	function enumDefaultedMember(id) {
    	  return (0, _validateNode.default)({
    	    type: "EnumDefaultedMember",
    	    id
    	  });
    	}
    	function indexedAccessType(objectType, indexType) {
    	  return (0, _validateNode.default)({
    	    type: "IndexedAccessType",
    	    objectType,
    	    indexType
    	  });
    	}
    	function optionalIndexedAccessType(objectType, indexType) {
    	  return (0, _validateNode.default)({
    	    type: "OptionalIndexedAccessType",
    	    objectType,
    	    indexType,
    	    optional: null
    	  });
    	}
    	function jsxAttribute(name, value = null) {
    	  return (0, _validateNode.default)({
    	    type: "JSXAttribute",
    	    name,
    	    value
    	  });
    	}
    	function jsxClosingElement(name) {
    	  return (0, _validateNode.default)({
    	    type: "JSXClosingElement",
    	    name
    	  });
    	}
    	function jsxElement(openingElement, closingElement = null, children, selfClosing = null) {
    	  return (0, _validateNode.default)({
    	    type: "JSXElement",
    	    openingElement,
    	    closingElement,
    	    children,
    	    selfClosing
    	  });
    	}
    	function jsxEmptyExpression() {
    	  return {
    	    type: "JSXEmptyExpression"
    	  };
    	}
    	function jsxExpressionContainer(expression) {
    	  return (0, _validateNode.default)({
    	    type: "JSXExpressionContainer",
    	    expression
    	  });
    	}
    	function jsxSpreadChild(expression) {
    	  return (0, _validateNode.default)({
    	    type: "JSXSpreadChild",
    	    expression
    	  });
    	}
    	function jsxIdentifier(name) {
    	  return (0, _validateNode.default)({
    	    type: "JSXIdentifier",
    	    name
    	  });
    	}
    	function jsxMemberExpression(object, property) {
    	  return (0, _validateNode.default)({
    	    type: "JSXMemberExpression",
    	    object,
    	    property
    	  });
    	}
    	function jsxNamespacedName(namespace, name) {
    	  return (0, _validateNode.default)({
    	    type: "JSXNamespacedName",
    	    namespace,
    	    name
    	  });
    	}
    	function jsxOpeningElement(name, attributes, selfClosing = false) {
    	  return (0, _validateNode.default)({
    	    type: "JSXOpeningElement",
    	    name,
    	    attributes,
    	    selfClosing
    	  });
    	}
    	function jsxSpreadAttribute(argument) {
    	  return (0, _validateNode.default)({
    	    type: "JSXSpreadAttribute",
    	    argument
    	  });
    	}
    	function jsxText(value) {
    	  return (0, _validateNode.default)({
    	    type: "JSXText",
    	    value
    	  });
    	}
    	function jsxFragment(openingFragment, closingFragment, children) {
    	  return (0, _validateNode.default)({
    	    type: "JSXFragment",
    	    openingFragment,
    	    closingFragment,
    	    children
    	  });
    	}
    	function jsxOpeningFragment() {
    	  return {
    	    type: "JSXOpeningFragment"
    	  };
    	}
    	function jsxClosingFragment() {
    	  return {
    	    type: "JSXClosingFragment"
    	  };
    	}
    	function noop() {
    	  return {
    	    type: "Noop"
    	  };
    	}
    	function placeholder(expectedNode, name) {
    	  return (0, _validateNode.default)({
    	    type: "Placeholder",
    	    expectedNode,
    	    name
    	  });
    	}
    	function v8IntrinsicIdentifier(name) {
    	  return (0, _validateNode.default)({
    	    type: "V8IntrinsicIdentifier",
    	    name
    	  });
    	}
    	function argumentPlaceholder() {
    	  return {
    	    type: "ArgumentPlaceholder"
    	  };
    	}
    	function bindExpression(object, callee) {
    	  return (0, _validateNode.default)({
    	    type: "BindExpression",
    	    object,
    	    callee
    	  });
    	}
    	function importAttribute(key, value) {
    	  return (0, _validateNode.default)({
    	    type: "ImportAttribute",
    	    key,
    	    value
    	  });
    	}
    	function decorator(expression) {
    	  return (0, _validateNode.default)({
    	    type: "Decorator",
    	    expression
    	  });
    	}
    	function doExpression(body, async = false) {
    	  return (0, _validateNode.default)({
    	    type: "DoExpression",
    	    body,
    	    async
    	  });
    	}
    	function exportDefaultSpecifier(exported) {
    	  return (0, _validateNode.default)({
    	    type: "ExportDefaultSpecifier",
    	    exported
    	  });
    	}
    	function recordExpression(properties) {
    	  return (0, _validateNode.default)({
    	    type: "RecordExpression",
    	    properties
    	  });
    	}
    	function tupleExpression(elements = []) {
    	  return (0, _validateNode.default)({
    	    type: "TupleExpression",
    	    elements
    	  });
    	}
    	function decimalLiteral(value) {
    	  return (0, _validateNode.default)({
    	    type: "DecimalLiteral",
    	    value
    	  });
    	}
    	function moduleExpression(body) {
    	  return (0, _validateNode.default)({
    	    type: "ModuleExpression",
    	    body
    	  });
    	}
    	function topicReference() {
    	  return {
    	    type: "TopicReference"
    	  };
    	}
    	function pipelineTopicExpression(expression) {
    	  return (0, _validateNode.default)({
    	    type: "PipelineTopicExpression",
    	    expression
    	  });
    	}
    	function pipelineBareFunction(callee) {
    	  return (0, _validateNode.default)({
    	    type: "PipelineBareFunction",
    	    callee
    	  });
    	}
    	function pipelinePrimaryTopicReference() {
    	  return {
    	    type: "PipelinePrimaryTopicReference"
    	  };
    	}
    	function tsParameterProperty(parameter) {
    	  return (0, _validateNode.default)({
    	    type: "TSParameterProperty",
    	    parameter
    	  });
    	}
    	function tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {
    	  return (0, _validateNode.default)({
    	    type: "TSDeclareFunction",
    	    id,
    	    typeParameters,
    	    params,
    	    returnType
    	  });
    	}
    	function tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {
    	  return (0, _validateNode.default)({
    	    type: "TSDeclareMethod",
    	    decorators,
    	    key,
    	    typeParameters,
    	    params,
    	    returnType
    	  });
    	}
    	function tsQualifiedName(left, right) {
    	  return (0, _validateNode.default)({
    	    type: "TSQualifiedName",
    	    left,
    	    right
    	  });
    	}
    	function tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation = null) {
    	  return (0, _validateNode.default)({
    	    type: "TSCallSignatureDeclaration",
    	    typeParameters,
    	    parameters,
    	    typeAnnotation
    	  });
    	}
    	function tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation = null) {
    	  return (0, _validateNode.default)({
    	    type: "TSConstructSignatureDeclaration",
    	    typeParameters,
    	    parameters,
    	    typeAnnotation
    	  });
    	}
    	function tsPropertySignature(key, typeAnnotation = null, initializer = null) {
    	  return (0, _validateNode.default)({
    	    type: "TSPropertySignature",
    	    key,
    	    typeAnnotation,
    	    initializer,
    	    kind: null
    	  });
    	}
    	function tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation = null) {
    	  return (0, _validateNode.default)({
    	    type: "TSMethodSignature",
    	    key,
    	    typeParameters,
    	    parameters,
    	    typeAnnotation,
    	    kind: null
    	  });
    	}
    	function tsIndexSignature(parameters, typeAnnotation = null) {
    	  return (0, _validateNode.default)({
    	    type: "TSIndexSignature",
    	    parameters,
    	    typeAnnotation
    	  });
    	}
    	function tsAnyKeyword() {
    	  return {
    	    type: "TSAnyKeyword"
    	  };
    	}
    	function tsBooleanKeyword() {
    	  return {
    	    type: "TSBooleanKeyword"
    	  };
    	}
    	function tsBigIntKeyword() {
    	  return {
    	    type: "TSBigIntKeyword"
    	  };
    	}
    	function tsIntrinsicKeyword() {
    	  return {
    	    type: "TSIntrinsicKeyword"
    	  };
    	}
    	function tsNeverKeyword() {
    	  return {
    	    type: "TSNeverKeyword"
    	  };
    	}
    	function tsNullKeyword() {
    	  return {
    	    type: "TSNullKeyword"
    	  };
    	}
    	function tsNumberKeyword() {
    	  return {
    	    type: "TSNumberKeyword"
    	  };
    	}
    	function tsObjectKeyword() {
    	  return {
    	    type: "TSObjectKeyword"
    	  };
    	}
    	function tsStringKeyword() {
    	  return {
    	    type: "TSStringKeyword"
    	  };
    	}
    	function tsSymbolKeyword() {
    	  return {
    	    type: "TSSymbolKeyword"
    	  };
    	}
    	function tsUndefinedKeyword() {
    	  return {
    	    type: "TSUndefinedKeyword"
    	  };
    	}
    	function tsUnknownKeyword() {
    	  return {
    	    type: "TSUnknownKeyword"
    	  };
    	}
    	function tsVoidKeyword() {
    	  return {
    	    type: "TSVoidKeyword"
    	  };
    	}
    	function tsThisType() {
    	  return {
    	    type: "TSThisType"
    	  };
    	}
    	function tsFunctionType(typeParameters = null, parameters, typeAnnotation = null) {
    	  return (0, _validateNode.default)({
    	    type: "TSFunctionType",
    	    typeParameters,
    	    parameters,
    	    typeAnnotation
    	  });
    	}
    	function tsConstructorType(typeParameters = null, parameters, typeAnnotation = null) {
    	  return (0, _validateNode.default)({
    	    type: "TSConstructorType",
    	    typeParameters,
    	    parameters,
    	    typeAnnotation
    	  });
    	}
    	function tsTypeReference(typeName, typeParameters = null) {
    	  return (0, _validateNode.default)({
    	    type: "TSTypeReference",
    	    typeName,
    	    typeParameters
    	  });
    	}
    	function tsTypePredicate(parameterName, typeAnnotation = null, asserts = null) {
    	  return (0, _validateNode.default)({
    	    type: "TSTypePredicate",
    	    parameterName,
    	    typeAnnotation,
    	    asserts
    	  });
    	}
    	function tsTypeQuery(exprName, typeParameters = null) {
    	  return (0, _validateNode.default)({
    	    type: "TSTypeQuery",
    	    exprName,
    	    typeParameters
    	  });
    	}
    	function tsTypeLiteral(members) {
    	  return (0, _validateNode.default)({
    	    type: "TSTypeLiteral",
    	    members
    	  });
    	}
    	function tsArrayType(elementType) {
    	  return (0, _validateNode.default)({
    	    type: "TSArrayType",
    	    elementType
    	  });
    	}
    	function tsTupleType(elementTypes) {
    	  return (0, _validateNode.default)({
    	    type: "TSTupleType",
    	    elementTypes
    	  });
    	}
    	function tsOptionalType(typeAnnotation) {
    	  return (0, _validateNode.default)({
    	    type: "TSOptionalType",
    	    typeAnnotation
    	  });
    	}
    	function tsRestType(typeAnnotation) {
    	  return (0, _validateNode.default)({
    	    type: "TSRestType",
    	    typeAnnotation
    	  });
    	}
    	function tsNamedTupleMember(label, elementType, optional = false) {
    	  return (0, _validateNode.default)({
    	    type: "TSNamedTupleMember",
    	    label,
    	    elementType,
    	    optional
    	  });
    	}
    	function tsUnionType(types) {
    	  return (0, _validateNode.default)({
    	    type: "TSUnionType",
    	    types
    	  });
    	}
    	function tsIntersectionType(types) {
    	  return (0, _validateNode.default)({
    	    type: "TSIntersectionType",
    	    types
    	  });
    	}
    	function tsConditionalType(checkType, extendsType, trueType, falseType) {
    	  return (0, _validateNode.default)({
    	    type: "TSConditionalType",
    	    checkType,
    	    extendsType,
    	    trueType,
    	    falseType
    	  });
    	}
    	function tsInferType(typeParameter) {
    	  return (0, _validateNode.default)({
    	    type: "TSInferType",
    	    typeParameter
    	  });
    	}
    	function tsParenthesizedType(typeAnnotation) {
    	  return (0, _validateNode.default)({
    	    type: "TSParenthesizedType",
    	    typeAnnotation
    	  });
    	}
    	function tsTypeOperator(typeAnnotation) {
    	  return (0, _validateNode.default)({
    	    type: "TSTypeOperator",
    	    typeAnnotation,
    	    operator: null
    	  });
    	}
    	function tsIndexedAccessType(objectType, indexType) {
    	  return (0, _validateNode.default)({
    	    type: "TSIndexedAccessType",
    	    objectType,
    	    indexType
    	  });
    	}
    	function tsMappedType(typeParameter, typeAnnotation = null, nameType = null) {
    	  return (0, _validateNode.default)({
    	    type: "TSMappedType",
    	    typeParameter,
    	    typeAnnotation,
    	    nameType
    	  });
    	}
    	function tsLiteralType(literal) {
    	  return (0, _validateNode.default)({
    	    type: "TSLiteralType",
    	    literal
    	  });
    	}
    	function tsExpressionWithTypeArguments(expression, typeParameters = null) {
    	  return (0, _validateNode.default)({
    	    type: "TSExpressionWithTypeArguments",
    	    expression,
    	    typeParameters
    	  });
    	}
    	function tsInterfaceDeclaration(id, typeParameters = null, _extends = null, body) {
    	  return (0, _validateNode.default)({
    	    type: "TSInterfaceDeclaration",
    	    id,
    	    typeParameters,
    	    extends: _extends,
    	    body
    	  });
    	}
    	function tsInterfaceBody(body) {
    	  return (0, _validateNode.default)({
    	    type: "TSInterfaceBody",
    	    body
    	  });
    	}
    	function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation) {
    	  return (0, _validateNode.default)({
    	    type: "TSTypeAliasDeclaration",
    	    id,
    	    typeParameters,
    	    typeAnnotation
    	  });
    	}
    	function tsInstantiationExpression(expression, typeParameters = null) {
    	  return (0, _validateNode.default)({
    	    type: "TSInstantiationExpression",
    	    expression,
    	    typeParameters
    	  });
    	}
    	function tsAsExpression(expression, typeAnnotation) {
    	  return (0, _validateNode.default)({
    	    type: "TSAsExpression",
    	    expression,
    	    typeAnnotation
    	  });
    	}
    	function tsSatisfiesExpression(expression, typeAnnotation) {
    	  return (0, _validateNode.default)({
    	    type: "TSSatisfiesExpression",
    	    expression,
    	    typeAnnotation
    	  });
    	}
    	function tsTypeAssertion(typeAnnotation, expression) {
    	  return (0, _validateNode.default)({
    	    type: "TSTypeAssertion",
    	    typeAnnotation,
    	    expression
    	  });
    	}
    	function tsEnumDeclaration(id, members) {
    	  return (0, _validateNode.default)({
    	    type: "TSEnumDeclaration",
    	    id,
    	    members
    	  });
    	}
    	function tsEnumMember(id, initializer = null) {
    	  return (0, _validateNode.default)({
    	    type: "TSEnumMember",
    	    id,
    	    initializer
    	  });
    	}
    	function tsModuleDeclaration(id, body) {
    	  return (0, _validateNode.default)({
    	    type: "TSModuleDeclaration",
    	    id,
    	    body
    	  });
    	}
    	function tsModuleBlock(body) {
    	  return (0, _validateNode.default)({
    	    type: "TSModuleBlock",
    	    body
    	  });
    	}
    	function tsImportType(argument, qualifier = null, typeParameters = null) {
    	  return (0, _validateNode.default)({
    	    type: "TSImportType",
    	    argument,
    	    qualifier,
    	    typeParameters
    	  });
    	}
    	function tsImportEqualsDeclaration(id, moduleReference) {
    	  return (0, _validateNode.default)({
    	    type: "TSImportEqualsDeclaration",
    	    id,
    	    moduleReference,
    	    isExport: null
    	  });
    	}
    	function tsExternalModuleReference(expression) {
    	  return (0, _validateNode.default)({
    	    type: "TSExternalModuleReference",
    	    expression
    	  });
    	}
    	function tsNonNullExpression(expression) {
    	  return (0, _validateNode.default)({
    	    type: "TSNonNullExpression",
    	    expression
    	  });
    	}
    	function tsExportAssignment(expression) {
    	  return (0, _validateNode.default)({
    	    type: "TSExportAssignment",
    	    expression
    	  });
    	}
    	function tsNamespaceExportDeclaration(id) {
    	  return (0, _validateNode.default)({
    	    type: "TSNamespaceExportDeclaration",
    	    id
    	  });
    	}
    	function tsTypeAnnotation(typeAnnotation) {
    	  return (0, _validateNode.default)({
    	    type: "TSTypeAnnotation",
    	    typeAnnotation
    	  });
    	}
    	function tsTypeParameterInstantiation(params) {
    	  return (0, _validateNode.default)({
    	    type: "TSTypeParameterInstantiation",
    	    params
    	  });
    	}
    	function tsTypeParameterDeclaration(params) {
    	  return (0, _validateNode.default)({
    	    type: "TSTypeParameterDeclaration",
    	    params
    	  });
    	}
    	function tsTypeParameter(constraint = null, _default = null, name) {
    	  return (0, _validateNode.default)({
    	    type: "TSTypeParameter",
    	    constraint,
    	    default: _default,
    	    name
    	  });
    	}
    	function NumberLiteral(value) {
    	  (0, _deprecationWarning.default)("NumberLiteral", "NumericLiteral", "The node type ");
    	  return numericLiteral(value);
    	}
    	function RegexLiteral(pattern, flags = "") {
    	  (0, _deprecationWarning.default)("RegexLiteral", "RegExpLiteral", "The node type ");
    	  return regExpLiteral(pattern, flags);
    	}
    	function RestProperty(argument) {
    	  (0, _deprecationWarning.default)("RestProperty", "RestElement", "The node type ");
    	  return restElement(argument);
    	}
    	function SpreadProperty(argument) {
    	  (0, _deprecationWarning.default)("SpreadProperty", "SpreadElement", "The node type ");
    	  return spreadElement(argument);
    	}

    	
    	return generated$2;
    }

    var hasRequiredCleanJSXElementLiteralChild;

    function requireCleanJSXElementLiteralChild () {
    	if (hasRequiredCleanJSXElementLiteralChild) return cleanJSXElementLiteralChild;
    	hasRequiredCleanJSXElementLiteralChild = 1;

    	Object.defineProperty(cleanJSXElementLiteralChild, "__esModule", {
    	  value: true
    	});
    	cleanJSXElementLiteralChild.default = cleanJSXElementLiteralChild$1;
    	var _index = requireGenerated$2();
    	var _index2 = requireLib$2();
    	function cleanJSXElementLiteralChild$1(child, args) {
    	  const lines = child.value.split(/\r\n|\n|\r/);
    	  let lastNonEmptyLine = 0;
    	  for (let i = 0; i < lines.length; i++) {
    	    if (lines[i].match(/[^ \t]/)) {
    	      lastNonEmptyLine = i;
    	    }
    	  }
    	  let str = "";
    	  for (let i = 0; i < lines.length; i++) {
    	    const line = lines[i];
    	    const isFirstLine = i === 0;
    	    const isLastLine = i === lines.length - 1;
    	    const isLastNonEmptyLine = i === lastNonEmptyLine;
    	    let trimmedLine = line.replace(/\t/g, " ");
    	    if (!isFirstLine) {
    	      trimmedLine = trimmedLine.replace(/^[ ]+/, "");
    	    }
    	    if (!isLastLine) {
    	      trimmedLine = trimmedLine.replace(/[ ]+$/, "");
    	    }
    	    if (trimmedLine) {
    	      if (!isLastNonEmptyLine) {
    	        trimmedLine += " ";
    	      }
    	      str += trimmedLine;
    	    }
    	  }
    	  if (str) args.push((0, _index2.inherits)((0, _index.stringLiteral)(str), child));
    	}

    	
    	return cleanJSXElementLiteralChild;
    }

    var hasRequiredBuildChildren;

    function requireBuildChildren () {
    	if (hasRequiredBuildChildren) return buildChildren;
    	hasRequiredBuildChildren = 1;

    	Object.defineProperty(buildChildren, "__esModule", {
    	  value: true
    	});
    	buildChildren.default = buildChildren$1;
    	var _index = requireGenerated$3();
    	var _cleanJSXElementLiteralChild = requireCleanJSXElementLiteralChild();
    	function buildChildren$1(node) {
    	  const elements = [];
    	  for (let i = 0; i < node.children.length; i++) {
    	    let child = node.children[i];
    	    if ((0, _index.isJSXText)(child)) {
    	      (0, _cleanJSXElementLiteralChild.default)(child, elements);
    	      continue;
    	    }
    	    if ((0, _index.isJSXExpressionContainer)(child)) child = child.expression;
    	    if ((0, _index.isJSXEmptyExpression)(child)) continue;
    	    elements.push(child);
    	  }
    	  return elements;
    	}

    	
    	return buildChildren;
    }

    var assertNode = {};

    var isNode$1 = {};

    var hasRequiredIsNode;

    function requireIsNode () {
    	if (hasRequiredIsNode) return isNode$1;
    	hasRequiredIsNode = 1;

    	Object.defineProperty(isNode$1, "__esModule", {
    	  value: true
    	});
    	isNode$1.default = isNode;
    	var _index = requireDefinitions();
    	function isNode(node) {
    	  return !!(node && _index.VISITOR_KEYS[node.type]);
    	}

    	
    	return isNode$1;
    }

    var hasRequiredAssertNode;

    function requireAssertNode () {
    	if (hasRequiredAssertNode) return assertNode;
    	hasRequiredAssertNode = 1;

    	Object.defineProperty(assertNode, "__esModule", {
    	  value: true
    	});
    	assertNode.default = assertNode$1;
    	var _isNode = requireIsNode();
    	function assertNode$1(node) {
    	  if (!(0, _isNode.default)(node)) {
    	    var _node$type;
    	    const type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
    	    throw new TypeError(`Not a valid node of type "${type}"`);
    	  }
    	}

    	
    	return assertNode;
    }

    var generated$1 = {};

    var hasRequiredGenerated$1;

    function requireGenerated$1 () {
    	if (hasRequiredGenerated$1) return generated$1;
    	hasRequiredGenerated$1 = 1;

    	Object.defineProperty(generated$1, "__esModule", {
    	  value: true
    	});
    	generated$1.assertAccessor = assertAccessor;
    	generated$1.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
    	generated$1.assertArgumentPlaceholder = assertArgumentPlaceholder;
    	generated$1.assertArrayExpression = assertArrayExpression;
    	generated$1.assertArrayPattern = assertArrayPattern;
    	generated$1.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
    	generated$1.assertArrowFunctionExpression = assertArrowFunctionExpression;
    	generated$1.assertAssignmentExpression = assertAssignmentExpression;
    	generated$1.assertAssignmentPattern = assertAssignmentPattern;
    	generated$1.assertAwaitExpression = assertAwaitExpression;
    	generated$1.assertBigIntLiteral = assertBigIntLiteral;
    	generated$1.assertBinary = assertBinary;
    	generated$1.assertBinaryExpression = assertBinaryExpression;
    	generated$1.assertBindExpression = assertBindExpression;
    	generated$1.assertBlock = assertBlock;
    	generated$1.assertBlockParent = assertBlockParent;
    	generated$1.assertBlockStatement = assertBlockStatement;
    	generated$1.assertBooleanLiteral = assertBooleanLiteral;
    	generated$1.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
    	generated$1.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
    	generated$1.assertBreakStatement = assertBreakStatement;
    	generated$1.assertCallExpression = assertCallExpression;
    	generated$1.assertCatchClause = assertCatchClause;
    	generated$1.assertClass = assertClass;
    	generated$1.assertClassAccessorProperty = assertClassAccessorProperty;
    	generated$1.assertClassBody = assertClassBody;
    	generated$1.assertClassDeclaration = assertClassDeclaration;
    	generated$1.assertClassExpression = assertClassExpression;
    	generated$1.assertClassImplements = assertClassImplements;
    	generated$1.assertClassMethod = assertClassMethod;
    	generated$1.assertClassPrivateMethod = assertClassPrivateMethod;
    	generated$1.assertClassPrivateProperty = assertClassPrivateProperty;
    	generated$1.assertClassProperty = assertClassProperty;
    	generated$1.assertCompletionStatement = assertCompletionStatement;
    	generated$1.assertConditional = assertConditional;
    	generated$1.assertConditionalExpression = assertConditionalExpression;
    	generated$1.assertContinueStatement = assertContinueStatement;
    	generated$1.assertDebuggerStatement = assertDebuggerStatement;
    	generated$1.assertDecimalLiteral = assertDecimalLiteral;
    	generated$1.assertDeclaration = assertDeclaration;
    	generated$1.assertDeclareClass = assertDeclareClass;
    	generated$1.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
    	generated$1.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
    	generated$1.assertDeclareFunction = assertDeclareFunction;
    	generated$1.assertDeclareInterface = assertDeclareInterface;
    	generated$1.assertDeclareModule = assertDeclareModule;
    	generated$1.assertDeclareModuleExports = assertDeclareModuleExports;
    	generated$1.assertDeclareOpaqueType = assertDeclareOpaqueType;
    	generated$1.assertDeclareTypeAlias = assertDeclareTypeAlias;
    	generated$1.assertDeclareVariable = assertDeclareVariable;
    	generated$1.assertDeclaredPredicate = assertDeclaredPredicate;
    	generated$1.assertDecorator = assertDecorator;
    	generated$1.assertDirective = assertDirective;
    	generated$1.assertDirectiveLiteral = assertDirectiveLiteral;
    	generated$1.assertDoExpression = assertDoExpression;
    	generated$1.assertDoWhileStatement = assertDoWhileStatement;
    	generated$1.assertEmptyStatement = assertEmptyStatement;
    	generated$1.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
    	generated$1.assertEnumBody = assertEnumBody;
    	generated$1.assertEnumBooleanBody = assertEnumBooleanBody;
    	generated$1.assertEnumBooleanMember = assertEnumBooleanMember;
    	generated$1.assertEnumDeclaration = assertEnumDeclaration;
    	generated$1.assertEnumDefaultedMember = assertEnumDefaultedMember;
    	generated$1.assertEnumMember = assertEnumMember;
    	generated$1.assertEnumNumberBody = assertEnumNumberBody;
    	generated$1.assertEnumNumberMember = assertEnumNumberMember;
    	generated$1.assertEnumStringBody = assertEnumStringBody;
    	generated$1.assertEnumStringMember = assertEnumStringMember;
    	generated$1.assertEnumSymbolBody = assertEnumSymbolBody;
    	generated$1.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
    	generated$1.assertExportAllDeclaration = assertExportAllDeclaration;
    	generated$1.assertExportDeclaration = assertExportDeclaration;
    	generated$1.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
    	generated$1.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
    	generated$1.assertExportNamedDeclaration = assertExportNamedDeclaration;
    	generated$1.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
    	generated$1.assertExportSpecifier = assertExportSpecifier;
    	generated$1.assertExpression = assertExpression;
    	generated$1.assertExpressionStatement = assertExpressionStatement;
    	generated$1.assertExpressionWrapper = assertExpressionWrapper;
    	generated$1.assertFile = assertFile;
    	generated$1.assertFlow = assertFlow;
    	generated$1.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
    	generated$1.assertFlowDeclaration = assertFlowDeclaration;
    	generated$1.assertFlowPredicate = assertFlowPredicate;
    	generated$1.assertFlowType = assertFlowType;
    	generated$1.assertFor = assertFor;
    	generated$1.assertForInStatement = assertForInStatement;
    	generated$1.assertForOfStatement = assertForOfStatement;
    	generated$1.assertForStatement = assertForStatement;
    	generated$1.assertForXStatement = assertForXStatement;
    	generated$1.assertFunction = assertFunction;
    	generated$1.assertFunctionDeclaration = assertFunctionDeclaration;
    	generated$1.assertFunctionExpression = assertFunctionExpression;
    	generated$1.assertFunctionParent = assertFunctionParent;
    	generated$1.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
    	generated$1.assertFunctionTypeParam = assertFunctionTypeParam;
    	generated$1.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
    	generated$1.assertIdentifier = assertIdentifier;
    	generated$1.assertIfStatement = assertIfStatement;
    	generated$1.assertImmutable = assertImmutable;
    	generated$1.assertImport = assertImport;
    	generated$1.assertImportAttribute = assertImportAttribute;
    	generated$1.assertImportDeclaration = assertImportDeclaration;
    	generated$1.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
    	generated$1.assertImportExpression = assertImportExpression;
    	generated$1.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
    	generated$1.assertImportOrExportDeclaration = assertImportOrExportDeclaration;
    	generated$1.assertImportSpecifier = assertImportSpecifier;
    	generated$1.assertIndexedAccessType = assertIndexedAccessType;
    	generated$1.assertInferredPredicate = assertInferredPredicate;
    	generated$1.assertInterfaceDeclaration = assertInterfaceDeclaration;
    	generated$1.assertInterfaceExtends = assertInterfaceExtends;
    	generated$1.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
    	generated$1.assertInterpreterDirective = assertInterpreterDirective;
    	generated$1.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
    	generated$1.assertJSX = assertJSX;
    	generated$1.assertJSXAttribute = assertJSXAttribute;
    	generated$1.assertJSXClosingElement = assertJSXClosingElement;
    	generated$1.assertJSXClosingFragment = assertJSXClosingFragment;
    	generated$1.assertJSXElement = assertJSXElement;
    	generated$1.assertJSXEmptyExpression = assertJSXEmptyExpression;
    	generated$1.assertJSXExpressionContainer = assertJSXExpressionContainer;
    	generated$1.assertJSXFragment = assertJSXFragment;
    	generated$1.assertJSXIdentifier = assertJSXIdentifier;
    	generated$1.assertJSXMemberExpression = assertJSXMemberExpression;
    	generated$1.assertJSXNamespacedName = assertJSXNamespacedName;
    	generated$1.assertJSXOpeningElement = assertJSXOpeningElement;
    	generated$1.assertJSXOpeningFragment = assertJSXOpeningFragment;
    	generated$1.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
    	generated$1.assertJSXSpreadChild = assertJSXSpreadChild;
    	generated$1.assertJSXText = assertJSXText;
    	generated$1.assertLVal = assertLVal;
    	generated$1.assertLabeledStatement = assertLabeledStatement;
    	generated$1.assertLiteral = assertLiteral;
    	generated$1.assertLogicalExpression = assertLogicalExpression;
    	generated$1.assertLoop = assertLoop;
    	generated$1.assertMemberExpression = assertMemberExpression;
    	generated$1.assertMetaProperty = assertMetaProperty;
    	generated$1.assertMethod = assertMethod;
    	generated$1.assertMiscellaneous = assertMiscellaneous;
    	generated$1.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
    	generated$1.assertModuleDeclaration = assertModuleDeclaration;
    	generated$1.assertModuleExpression = assertModuleExpression;
    	generated$1.assertModuleSpecifier = assertModuleSpecifier;
    	generated$1.assertNewExpression = assertNewExpression;
    	generated$1.assertNoop = assertNoop;
    	generated$1.assertNullLiteral = assertNullLiteral;
    	generated$1.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
    	generated$1.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
    	generated$1.assertNumberLiteral = assertNumberLiteral;
    	generated$1.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
    	generated$1.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
    	generated$1.assertNumericLiteral = assertNumericLiteral;
    	generated$1.assertObjectExpression = assertObjectExpression;
    	generated$1.assertObjectMember = assertObjectMember;
    	generated$1.assertObjectMethod = assertObjectMethod;
    	generated$1.assertObjectPattern = assertObjectPattern;
    	generated$1.assertObjectProperty = assertObjectProperty;
    	generated$1.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
    	generated$1.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
    	generated$1.assertObjectTypeIndexer = assertObjectTypeIndexer;
    	generated$1.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
    	generated$1.assertObjectTypeProperty = assertObjectTypeProperty;
    	generated$1.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
    	generated$1.assertOpaqueType = assertOpaqueType;
    	generated$1.assertOptionalCallExpression = assertOptionalCallExpression;
    	generated$1.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
    	generated$1.assertOptionalMemberExpression = assertOptionalMemberExpression;
    	generated$1.assertParenthesizedExpression = assertParenthesizedExpression;
    	generated$1.assertPattern = assertPattern;
    	generated$1.assertPatternLike = assertPatternLike;
    	generated$1.assertPipelineBareFunction = assertPipelineBareFunction;
    	generated$1.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
    	generated$1.assertPipelineTopicExpression = assertPipelineTopicExpression;
    	generated$1.assertPlaceholder = assertPlaceholder;
    	generated$1.assertPrivate = assertPrivate;
    	generated$1.assertPrivateName = assertPrivateName;
    	generated$1.assertProgram = assertProgram;
    	generated$1.assertProperty = assertProperty;
    	generated$1.assertPureish = assertPureish;
    	generated$1.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
    	generated$1.assertRecordExpression = assertRecordExpression;
    	generated$1.assertRegExpLiteral = assertRegExpLiteral;
    	generated$1.assertRegexLiteral = assertRegexLiteral;
    	generated$1.assertRestElement = assertRestElement;
    	generated$1.assertRestProperty = assertRestProperty;
    	generated$1.assertReturnStatement = assertReturnStatement;
    	generated$1.assertScopable = assertScopable;
    	generated$1.assertSequenceExpression = assertSequenceExpression;
    	generated$1.assertSpreadElement = assertSpreadElement;
    	generated$1.assertSpreadProperty = assertSpreadProperty;
    	generated$1.assertStandardized = assertStandardized;
    	generated$1.assertStatement = assertStatement;
    	generated$1.assertStaticBlock = assertStaticBlock;
    	generated$1.assertStringLiteral = assertStringLiteral;
    	generated$1.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
    	generated$1.assertStringTypeAnnotation = assertStringTypeAnnotation;
    	generated$1.assertSuper = assertSuper;
    	generated$1.assertSwitchCase = assertSwitchCase;
    	generated$1.assertSwitchStatement = assertSwitchStatement;
    	generated$1.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
    	generated$1.assertTSAnyKeyword = assertTSAnyKeyword;
    	generated$1.assertTSArrayType = assertTSArrayType;
    	generated$1.assertTSAsExpression = assertTSAsExpression;
    	generated$1.assertTSBaseType = assertTSBaseType;
    	generated$1.assertTSBigIntKeyword = assertTSBigIntKeyword;
    	generated$1.assertTSBooleanKeyword = assertTSBooleanKeyword;
    	generated$1.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
    	generated$1.assertTSConditionalType = assertTSConditionalType;
    	generated$1.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
    	generated$1.assertTSConstructorType = assertTSConstructorType;
    	generated$1.assertTSDeclareFunction = assertTSDeclareFunction;
    	generated$1.assertTSDeclareMethod = assertTSDeclareMethod;
    	generated$1.assertTSEntityName = assertTSEntityName;
    	generated$1.assertTSEnumDeclaration = assertTSEnumDeclaration;
    	generated$1.assertTSEnumMember = assertTSEnumMember;
    	generated$1.assertTSExportAssignment = assertTSExportAssignment;
    	generated$1.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
    	generated$1.assertTSExternalModuleReference = assertTSExternalModuleReference;
    	generated$1.assertTSFunctionType = assertTSFunctionType;
    	generated$1.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
    	generated$1.assertTSImportType = assertTSImportType;
    	generated$1.assertTSIndexSignature = assertTSIndexSignature;
    	generated$1.assertTSIndexedAccessType = assertTSIndexedAccessType;
    	generated$1.assertTSInferType = assertTSInferType;
    	generated$1.assertTSInstantiationExpression = assertTSInstantiationExpression;
    	generated$1.assertTSInterfaceBody = assertTSInterfaceBody;
    	generated$1.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
    	generated$1.assertTSIntersectionType = assertTSIntersectionType;
    	generated$1.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
    	generated$1.assertTSLiteralType = assertTSLiteralType;
    	generated$1.assertTSMappedType = assertTSMappedType;
    	generated$1.assertTSMethodSignature = assertTSMethodSignature;
    	generated$1.assertTSModuleBlock = assertTSModuleBlock;
    	generated$1.assertTSModuleDeclaration = assertTSModuleDeclaration;
    	generated$1.assertTSNamedTupleMember = assertTSNamedTupleMember;
    	generated$1.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
    	generated$1.assertTSNeverKeyword = assertTSNeverKeyword;
    	generated$1.assertTSNonNullExpression = assertTSNonNullExpression;
    	generated$1.assertTSNullKeyword = assertTSNullKeyword;
    	generated$1.assertTSNumberKeyword = assertTSNumberKeyword;
    	generated$1.assertTSObjectKeyword = assertTSObjectKeyword;
    	generated$1.assertTSOptionalType = assertTSOptionalType;
    	generated$1.assertTSParameterProperty = assertTSParameterProperty;
    	generated$1.assertTSParenthesizedType = assertTSParenthesizedType;
    	generated$1.assertTSPropertySignature = assertTSPropertySignature;
    	generated$1.assertTSQualifiedName = assertTSQualifiedName;
    	generated$1.assertTSRestType = assertTSRestType;
    	generated$1.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
    	generated$1.assertTSStringKeyword = assertTSStringKeyword;
    	generated$1.assertTSSymbolKeyword = assertTSSymbolKeyword;
    	generated$1.assertTSThisType = assertTSThisType;
    	generated$1.assertTSTupleType = assertTSTupleType;
    	generated$1.assertTSType = assertTSType;
    	generated$1.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
    	generated$1.assertTSTypeAnnotation = assertTSTypeAnnotation;
    	generated$1.assertTSTypeAssertion = assertTSTypeAssertion;
    	generated$1.assertTSTypeElement = assertTSTypeElement;
    	generated$1.assertTSTypeLiteral = assertTSTypeLiteral;
    	generated$1.assertTSTypeOperator = assertTSTypeOperator;
    	generated$1.assertTSTypeParameter = assertTSTypeParameter;
    	generated$1.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
    	generated$1.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
    	generated$1.assertTSTypePredicate = assertTSTypePredicate;
    	generated$1.assertTSTypeQuery = assertTSTypeQuery;
    	generated$1.assertTSTypeReference = assertTSTypeReference;
    	generated$1.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
    	generated$1.assertTSUnionType = assertTSUnionType;
    	generated$1.assertTSUnknownKeyword = assertTSUnknownKeyword;
    	generated$1.assertTSVoidKeyword = assertTSVoidKeyword;
    	generated$1.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
    	generated$1.assertTemplateElement = assertTemplateElement;
    	generated$1.assertTemplateLiteral = assertTemplateLiteral;
    	generated$1.assertTerminatorless = assertTerminatorless;
    	generated$1.assertThisExpression = assertThisExpression;
    	generated$1.assertThisTypeAnnotation = assertThisTypeAnnotation;
    	generated$1.assertThrowStatement = assertThrowStatement;
    	generated$1.assertTopicReference = assertTopicReference;
    	generated$1.assertTryStatement = assertTryStatement;
    	generated$1.assertTupleExpression = assertTupleExpression;
    	generated$1.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
    	generated$1.assertTypeAlias = assertTypeAlias;
    	generated$1.assertTypeAnnotation = assertTypeAnnotation;
    	generated$1.assertTypeCastExpression = assertTypeCastExpression;
    	generated$1.assertTypeParameter = assertTypeParameter;
    	generated$1.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
    	generated$1.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
    	generated$1.assertTypeScript = assertTypeScript;
    	generated$1.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
    	generated$1.assertUnaryExpression = assertUnaryExpression;
    	generated$1.assertUnaryLike = assertUnaryLike;
    	generated$1.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
    	generated$1.assertUpdateExpression = assertUpdateExpression;
    	generated$1.assertUserWhitespacable = assertUserWhitespacable;
    	generated$1.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
    	generated$1.assertVariableDeclaration = assertVariableDeclaration;
    	generated$1.assertVariableDeclarator = assertVariableDeclarator;
    	generated$1.assertVariance = assertVariance;
    	generated$1.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
    	generated$1.assertWhile = assertWhile;
    	generated$1.assertWhileStatement = assertWhileStatement;
    	generated$1.assertWithStatement = assertWithStatement;
    	generated$1.assertYieldExpression = assertYieldExpression;
    	var _is = requireIs();
    	var _deprecationWarning = requireDeprecationWarning();
    	function assert(type, node, opts) {
    	  if (!(0, _is.default)(type, node, opts)) {
    	    throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, ` + `but instead got "${node.type}".`);
    	  }
    	}
    	function assertArrayExpression(node, opts) {
    	  assert("ArrayExpression", node, opts);
    	}
    	function assertAssignmentExpression(node, opts) {
    	  assert("AssignmentExpression", node, opts);
    	}
    	function assertBinaryExpression(node, opts) {
    	  assert("BinaryExpression", node, opts);
    	}
    	function assertInterpreterDirective(node, opts) {
    	  assert("InterpreterDirective", node, opts);
    	}
    	function assertDirective(node, opts) {
    	  assert("Directive", node, opts);
    	}
    	function assertDirectiveLiteral(node, opts) {
    	  assert("DirectiveLiteral", node, opts);
    	}
    	function assertBlockStatement(node, opts) {
    	  assert("BlockStatement", node, opts);
    	}
    	function assertBreakStatement(node, opts) {
    	  assert("BreakStatement", node, opts);
    	}
    	function assertCallExpression(node, opts) {
    	  assert("CallExpression", node, opts);
    	}
    	function assertCatchClause(node, opts) {
    	  assert("CatchClause", node, opts);
    	}
    	function assertConditionalExpression(node, opts) {
    	  assert("ConditionalExpression", node, opts);
    	}
    	function assertContinueStatement(node, opts) {
    	  assert("ContinueStatement", node, opts);
    	}
    	function assertDebuggerStatement(node, opts) {
    	  assert("DebuggerStatement", node, opts);
    	}
    	function assertDoWhileStatement(node, opts) {
    	  assert("DoWhileStatement", node, opts);
    	}
    	function assertEmptyStatement(node, opts) {
    	  assert("EmptyStatement", node, opts);
    	}
    	function assertExpressionStatement(node, opts) {
    	  assert("ExpressionStatement", node, opts);
    	}
    	function assertFile(node, opts) {
    	  assert("File", node, opts);
    	}
    	function assertForInStatement(node, opts) {
    	  assert("ForInStatement", node, opts);
    	}
    	function assertForStatement(node, opts) {
    	  assert("ForStatement", node, opts);
    	}
    	function assertFunctionDeclaration(node, opts) {
    	  assert("FunctionDeclaration", node, opts);
    	}
    	function assertFunctionExpression(node, opts) {
    	  assert("FunctionExpression", node, opts);
    	}
    	function assertIdentifier(node, opts) {
    	  assert("Identifier", node, opts);
    	}
    	function assertIfStatement(node, opts) {
    	  assert("IfStatement", node, opts);
    	}
    	function assertLabeledStatement(node, opts) {
    	  assert("LabeledStatement", node, opts);
    	}
    	function assertStringLiteral(node, opts) {
    	  assert("StringLiteral", node, opts);
    	}
    	function assertNumericLiteral(node, opts) {
    	  assert("NumericLiteral", node, opts);
    	}
    	function assertNullLiteral(node, opts) {
    	  assert("NullLiteral", node, opts);
    	}
    	function assertBooleanLiteral(node, opts) {
    	  assert("BooleanLiteral", node, opts);
    	}
    	function assertRegExpLiteral(node, opts) {
    	  assert("RegExpLiteral", node, opts);
    	}
    	function assertLogicalExpression(node, opts) {
    	  assert("LogicalExpression", node, opts);
    	}
    	function assertMemberExpression(node, opts) {
    	  assert("MemberExpression", node, opts);
    	}
    	function assertNewExpression(node, opts) {
    	  assert("NewExpression", node, opts);
    	}
    	function assertProgram(node, opts) {
    	  assert("Program", node, opts);
    	}
    	function assertObjectExpression(node, opts) {
    	  assert("ObjectExpression", node, opts);
    	}
    	function assertObjectMethod(node, opts) {
    	  assert("ObjectMethod", node, opts);
    	}
    	function assertObjectProperty(node, opts) {
    	  assert("ObjectProperty", node, opts);
    	}
    	function assertRestElement(node, opts) {
    	  assert("RestElement", node, opts);
    	}
    	function assertReturnStatement(node, opts) {
    	  assert("ReturnStatement", node, opts);
    	}
    	function assertSequenceExpression(node, opts) {
    	  assert("SequenceExpression", node, opts);
    	}
    	function assertParenthesizedExpression(node, opts) {
    	  assert("ParenthesizedExpression", node, opts);
    	}
    	function assertSwitchCase(node, opts) {
    	  assert("SwitchCase", node, opts);
    	}
    	function assertSwitchStatement(node, opts) {
    	  assert("SwitchStatement", node, opts);
    	}
    	function assertThisExpression(node, opts) {
    	  assert("ThisExpression", node, opts);
    	}
    	function assertThrowStatement(node, opts) {
    	  assert("ThrowStatement", node, opts);
    	}
    	function assertTryStatement(node, opts) {
    	  assert("TryStatement", node, opts);
    	}
    	function assertUnaryExpression(node, opts) {
    	  assert("UnaryExpression", node, opts);
    	}
    	function assertUpdateExpression(node, opts) {
    	  assert("UpdateExpression", node, opts);
    	}
    	function assertVariableDeclaration(node, opts) {
    	  assert("VariableDeclaration", node, opts);
    	}
    	function assertVariableDeclarator(node, opts) {
    	  assert("VariableDeclarator", node, opts);
    	}
    	function assertWhileStatement(node, opts) {
    	  assert("WhileStatement", node, opts);
    	}
    	function assertWithStatement(node, opts) {
    	  assert("WithStatement", node, opts);
    	}
    	function assertAssignmentPattern(node, opts) {
    	  assert("AssignmentPattern", node, opts);
    	}
    	function assertArrayPattern(node, opts) {
    	  assert("ArrayPattern", node, opts);
    	}
    	function assertArrowFunctionExpression(node, opts) {
    	  assert("ArrowFunctionExpression", node, opts);
    	}
    	function assertClassBody(node, opts) {
    	  assert("ClassBody", node, opts);
    	}
    	function assertClassExpression(node, opts) {
    	  assert("ClassExpression", node, opts);
    	}
    	function assertClassDeclaration(node, opts) {
    	  assert("ClassDeclaration", node, opts);
    	}
    	function assertExportAllDeclaration(node, opts) {
    	  assert("ExportAllDeclaration", node, opts);
    	}
    	function assertExportDefaultDeclaration(node, opts) {
    	  assert("ExportDefaultDeclaration", node, opts);
    	}
    	function assertExportNamedDeclaration(node, opts) {
    	  assert("ExportNamedDeclaration", node, opts);
    	}
    	function assertExportSpecifier(node, opts) {
    	  assert("ExportSpecifier", node, opts);
    	}
    	function assertForOfStatement(node, opts) {
    	  assert("ForOfStatement", node, opts);
    	}
    	function assertImportDeclaration(node, opts) {
    	  assert("ImportDeclaration", node, opts);
    	}
    	function assertImportDefaultSpecifier(node, opts) {
    	  assert("ImportDefaultSpecifier", node, opts);
    	}
    	function assertImportNamespaceSpecifier(node, opts) {
    	  assert("ImportNamespaceSpecifier", node, opts);
    	}
    	function assertImportSpecifier(node, opts) {
    	  assert("ImportSpecifier", node, opts);
    	}
    	function assertImportExpression(node, opts) {
    	  assert("ImportExpression", node, opts);
    	}
    	function assertMetaProperty(node, opts) {
    	  assert("MetaProperty", node, opts);
    	}
    	function assertClassMethod(node, opts) {
    	  assert("ClassMethod", node, opts);
    	}
    	function assertObjectPattern(node, opts) {
    	  assert("ObjectPattern", node, opts);
    	}
    	function assertSpreadElement(node, opts) {
    	  assert("SpreadElement", node, opts);
    	}
    	function assertSuper(node, opts) {
    	  assert("Super", node, opts);
    	}
    	function assertTaggedTemplateExpression(node, opts) {
    	  assert("TaggedTemplateExpression", node, opts);
    	}
    	function assertTemplateElement(node, opts) {
    	  assert("TemplateElement", node, opts);
    	}
    	function assertTemplateLiteral(node, opts) {
    	  assert("TemplateLiteral", node, opts);
    	}
    	function assertYieldExpression(node, opts) {
    	  assert("YieldExpression", node, opts);
    	}
    	function assertAwaitExpression(node, opts) {
    	  assert("AwaitExpression", node, opts);
    	}
    	function assertImport(node, opts) {
    	  assert("Import", node, opts);
    	}
    	function assertBigIntLiteral(node, opts) {
    	  assert("BigIntLiteral", node, opts);
    	}
    	function assertExportNamespaceSpecifier(node, opts) {
    	  assert("ExportNamespaceSpecifier", node, opts);
    	}
    	function assertOptionalMemberExpression(node, opts) {
    	  assert("OptionalMemberExpression", node, opts);
    	}
    	function assertOptionalCallExpression(node, opts) {
    	  assert("OptionalCallExpression", node, opts);
    	}
    	function assertClassProperty(node, opts) {
    	  assert("ClassProperty", node, opts);
    	}
    	function assertClassAccessorProperty(node, opts) {
    	  assert("ClassAccessorProperty", node, opts);
    	}
    	function assertClassPrivateProperty(node, opts) {
    	  assert("ClassPrivateProperty", node, opts);
    	}
    	function assertClassPrivateMethod(node, opts) {
    	  assert("ClassPrivateMethod", node, opts);
    	}
    	function assertPrivateName(node, opts) {
    	  assert("PrivateName", node, opts);
    	}
    	function assertStaticBlock(node, opts) {
    	  assert("StaticBlock", node, opts);
    	}
    	function assertAnyTypeAnnotation(node, opts) {
    	  assert("AnyTypeAnnotation", node, opts);
    	}
    	function assertArrayTypeAnnotation(node, opts) {
    	  assert("ArrayTypeAnnotation", node, opts);
    	}
    	function assertBooleanTypeAnnotation(node, opts) {
    	  assert("BooleanTypeAnnotation", node, opts);
    	}
    	function assertBooleanLiteralTypeAnnotation(node, opts) {
    	  assert("BooleanLiteralTypeAnnotation", node, opts);
    	}
    	function assertNullLiteralTypeAnnotation(node, opts) {
    	  assert("NullLiteralTypeAnnotation", node, opts);
    	}
    	function assertClassImplements(node, opts) {
    	  assert("ClassImplements", node, opts);
    	}
    	function assertDeclareClass(node, opts) {
    	  assert("DeclareClass", node, opts);
    	}
    	function assertDeclareFunction(node, opts) {
    	  assert("DeclareFunction", node, opts);
    	}
    	function assertDeclareInterface(node, opts) {
    	  assert("DeclareInterface", node, opts);
    	}
    	function assertDeclareModule(node, opts) {
    	  assert("DeclareModule", node, opts);
    	}
    	function assertDeclareModuleExports(node, opts) {
    	  assert("DeclareModuleExports", node, opts);
    	}
    	function assertDeclareTypeAlias(node, opts) {
    	  assert("DeclareTypeAlias", node, opts);
    	}
    	function assertDeclareOpaqueType(node, opts) {
    	  assert("DeclareOpaqueType", node, opts);
    	}
    	function assertDeclareVariable(node, opts) {
    	  assert("DeclareVariable", node, opts);
    	}
    	function assertDeclareExportDeclaration(node, opts) {
    	  assert("DeclareExportDeclaration", node, opts);
    	}
    	function assertDeclareExportAllDeclaration(node, opts) {
    	  assert("DeclareExportAllDeclaration", node, opts);
    	}
    	function assertDeclaredPredicate(node, opts) {
    	  assert("DeclaredPredicate", node, opts);
    	}
    	function assertExistsTypeAnnotation(node, opts) {
    	  assert("ExistsTypeAnnotation", node, opts);
    	}
    	function assertFunctionTypeAnnotation(node, opts) {
    	  assert("FunctionTypeAnnotation", node, opts);
    	}
    	function assertFunctionTypeParam(node, opts) {
    	  assert("FunctionTypeParam", node, opts);
    	}
    	function assertGenericTypeAnnotation(node, opts) {
    	  assert("GenericTypeAnnotation", node, opts);
    	}
    	function assertInferredPredicate(node, opts) {
    	  assert("InferredPredicate", node, opts);
    	}
    	function assertInterfaceExtends(node, opts) {
    	  assert("InterfaceExtends", node, opts);
    	}
    	function assertInterfaceDeclaration(node, opts) {
    	  assert("InterfaceDeclaration", node, opts);
    	}
    	function assertInterfaceTypeAnnotation(node, opts) {
    	  assert("InterfaceTypeAnnotation", node, opts);
    	}
    	function assertIntersectionTypeAnnotation(node, opts) {
    	  assert("IntersectionTypeAnnotation", node, opts);
    	}
    	function assertMixedTypeAnnotation(node, opts) {
    	  assert("MixedTypeAnnotation", node, opts);
    	}
    	function assertEmptyTypeAnnotation(node, opts) {
    	  assert("EmptyTypeAnnotation", node, opts);
    	}
    	function assertNullableTypeAnnotation(node, opts) {
    	  assert("NullableTypeAnnotation", node, opts);
    	}
    	function assertNumberLiteralTypeAnnotation(node, opts) {
    	  assert("NumberLiteralTypeAnnotation", node, opts);
    	}
    	function assertNumberTypeAnnotation(node, opts) {
    	  assert("NumberTypeAnnotation", node, opts);
    	}
    	function assertObjectTypeAnnotation(node, opts) {
    	  assert("ObjectTypeAnnotation", node, opts);
    	}
    	function assertObjectTypeInternalSlot(node, opts) {
    	  assert("ObjectTypeInternalSlot", node, opts);
    	}
    	function assertObjectTypeCallProperty(node, opts) {
    	  assert("ObjectTypeCallProperty", node, opts);
    	}
    	function assertObjectTypeIndexer(node, opts) {
    	  assert("ObjectTypeIndexer", node, opts);
    	}
    	function assertObjectTypeProperty(node, opts) {
    	  assert("ObjectTypeProperty", node, opts);
    	}
    	function assertObjectTypeSpreadProperty(node, opts) {
    	  assert("ObjectTypeSpreadProperty", node, opts);
    	}
    	function assertOpaqueType(node, opts) {
    	  assert("OpaqueType", node, opts);
    	}
    	function assertQualifiedTypeIdentifier(node, opts) {
    	  assert("QualifiedTypeIdentifier", node, opts);
    	}
    	function assertStringLiteralTypeAnnotation(node, opts) {
    	  assert("StringLiteralTypeAnnotation", node, opts);
    	}
    	function assertStringTypeAnnotation(node, opts) {
    	  assert("StringTypeAnnotation", node, opts);
    	}
    	function assertSymbolTypeAnnotation(node, opts) {
    	  assert("SymbolTypeAnnotation", node, opts);
    	}
    	function assertThisTypeAnnotation(node, opts) {
    	  assert("ThisTypeAnnotation", node, opts);
    	}
    	function assertTupleTypeAnnotation(node, opts) {
    	  assert("TupleTypeAnnotation", node, opts);
    	}
    	function assertTypeofTypeAnnotation(node, opts) {
    	  assert("TypeofTypeAnnotation", node, opts);
    	}
    	function assertTypeAlias(node, opts) {
    	  assert("TypeAlias", node, opts);
    	}
    	function assertTypeAnnotation(node, opts) {
    	  assert("TypeAnnotation", node, opts);
    	}
    	function assertTypeCastExpression(node, opts) {
    	  assert("TypeCastExpression", node, opts);
    	}
    	function assertTypeParameter(node, opts) {
    	  assert("TypeParameter", node, opts);
    	}
    	function assertTypeParameterDeclaration(node, opts) {
    	  assert("TypeParameterDeclaration", node, opts);
    	}
    	function assertTypeParameterInstantiation(node, opts) {
    	  assert("TypeParameterInstantiation", node, opts);
    	}
    	function assertUnionTypeAnnotation(node, opts) {
    	  assert("UnionTypeAnnotation", node, opts);
    	}
    	function assertVariance(node, opts) {
    	  assert("Variance", node, opts);
    	}
    	function assertVoidTypeAnnotation(node, opts) {
    	  assert("VoidTypeAnnotation", node, opts);
    	}
    	function assertEnumDeclaration(node, opts) {
    	  assert("EnumDeclaration", node, opts);
    	}
    	function assertEnumBooleanBody(node, opts) {
    	  assert("EnumBooleanBody", node, opts);
    	}
    	function assertEnumNumberBody(node, opts) {
    	  assert("EnumNumberBody", node, opts);
    	}
    	function assertEnumStringBody(node, opts) {
    	  assert("EnumStringBody", node, opts);
    	}
    	function assertEnumSymbolBody(node, opts) {
    	  assert("EnumSymbolBody", node, opts);
    	}
    	function assertEnumBooleanMember(node, opts) {
    	  assert("EnumBooleanMember", node, opts);
    	}
    	function assertEnumNumberMember(node, opts) {
    	  assert("EnumNumberMember", node, opts);
    	}
    	function assertEnumStringMember(node, opts) {
    	  assert("EnumStringMember", node, opts);
    	}
    	function assertEnumDefaultedMember(node, opts) {
    	  assert("EnumDefaultedMember", node, opts);
    	}
    	function assertIndexedAccessType(node, opts) {
    	  assert("IndexedAccessType", node, opts);
    	}
    	function assertOptionalIndexedAccessType(node, opts) {
    	  assert("OptionalIndexedAccessType", node, opts);
    	}
    	function assertJSXAttribute(node, opts) {
    	  assert("JSXAttribute", node, opts);
    	}
    	function assertJSXClosingElement(node, opts) {
    	  assert("JSXClosingElement", node, opts);
    	}
    	function assertJSXElement(node, opts) {
    	  assert("JSXElement", node, opts);
    	}
    	function assertJSXEmptyExpression(node, opts) {
    	  assert("JSXEmptyExpression", node, opts);
    	}
    	function assertJSXExpressionContainer(node, opts) {
    	  assert("JSXExpressionContainer", node, opts);
    	}
    	function assertJSXSpreadChild(node, opts) {
    	  assert("JSXSpreadChild", node, opts);
    	}
    	function assertJSXIdentifier(node, opts) {
    	  assert("JSXIdentifier", node, opts);
    	}
    	function assertJSXMemberExpression(node, opts) {
    	  assert("JSXMemberExpression", node, opts);
    	}
    	function assertJSXNamespacedName(node, opts) {
    	  assert("JSXNamespacedName", node, opts);
    	}
    	function assertJSXOpeningElement(node, opts) {
    	  assert("JSXOpeningElement", node, opts);
    	}
    	function assertJSXSpreadAttribute(node, opts) {
    	  assert("JSXSpreadAttribute", node, opts);
    	}
    	function assertJSXText(node, opts) {
    	  assert("JSXText", node, opts);
    	}
    	function assertJSXFragment(node, opts) {
    	  assert("JSXFragment", node, opts);
    	}
    	function assertJSXOpeningFragment(node, opts) {
    	  assert("JSXOpeningFragment", node, opts);
    	}
    	function assertJSXClosingFragment(node, opts) {
    	  assert("JSXClosingFragment", node, opts);
    	}
    	function assertNoop(node, opts) {
    	  assert("Noop", node, opts);
    	}
    	function assertPlaceholder(node, opts) {
    	  assert("Placeholder", node, opts);
    	}
    	function assertV8IntrinsicIdentifier(node, opts) {
    	  assert("V8IntrinsicIdentifier", node, opts);
    	}
    	function assertArgumentPlaceholder(node, opts) {
    	  assert("ArgumentPlaceholder", node, opts);
    	}
    	function assertBindExpression(node, opts) {
    	  assert("BindExpression", node, opts);
    	}
    	function assertImportAttribute(node, opts) {
    	  assert("ImportAttribute", node, opts);
    	}
    	function assertDecorator(node, opts) {
    	  assert("Decorator", node, opts);
    	}
    	function assertDoExpression(node, opts) {
    	  assert("DoExpression", node, opts);
    	}
    	function assertExportDefaultSpecifier(node, opts) {
    	  assert("ExportDefaultSpecifier", node, opts);
    	}
    	function assertRecordExpression(node, opts) {
    	  assert("RecordExpression", node, opts);
    	}
    	function assertTupleExpression(node, opts) {
    	  assert("TupleExpression", node, opts);
    	}
    	function assertDecimalLiteral(node, opts) {
    	  assert("DecimalLiteral", node, opts);
    	}
    	function assertModuleExpression(node, opts) {
    	  assert("ModuleExpression", node, opts);
    	}
    	function assertTopicReference(node, opts) {
    	  assert("TopicReference", node, opts);
    	}
    	function assertPipelineTopicExpression(node, opts) {
    	  assert("PipelineTopicExpression", node, opts);
    	}
    	function assertPipelineBareFunction(node, opts) {
    	  assert("PipelineBareFunction", node, opts);
    	}
    	function assertPipelinePrimaryTopicReference(node, opts) {
    	  assert("PipelinePrimaryTopicReference", node, opts);
    	}
    	function assertTSParameterProperty(node, opts) {
    	  assert("TSParameterProperty", node, opts);
    	}
    	function assertTSDeclareFunction(node, opts) {
    	  assert("TSDeclareFunction", node, opts);
    	}
    	function assertTSDeclareMethod(node, opts) {
    	  assert("TSDeclareMethod", node, opts);
    	}
    	function assertTSQualifiedName(node, opts) {
    	  assert("TSQualifiedName", node, opts);
    	}
    	function assertTSCallSignatureDeclaration(node, opts) {
    	  assert("TSCallSignatureDeclaration", node, opts);
    	}
    	function assertTSConstructSignatureDeclaration(node, opts) {
    	  assert("TSConstructSignatureDeclaration", node, opts);
    	}
    	function assertTSPropertySignature(node, opts) {
    	  assert("TSPropertySignature", node, opts);
    	}
    	function assertTSMethodSignature(node, opts) {
    	  assert("TSMethodSignature", node, opts);
    	}
    	function assertTSIndexSignature(node, opts) {
    	  assert("TSIndexSignature", node, opts);
    	}
    	function assertTSAnyKeyword(node, opts) {
    	  assert("TSAnyKeyword", node, opts);
    	}
    	function assertTSBooleanKeyword(node, opts) {
    	  assert("TSBooleanKeyword", node, opts);
    	}
    	function assertTSBigIntKeyword(node, opts) {
    	  assert("TSBigIntKeyword", node, opts);
    	}
    	function assertTSIntrinsicKeyword(node, opts) {
    	  assert("TSIntrinsicKeyword", node, opts);
    	}
    	function assertTSNeverKeyword(node, opts) {
    	  assert("TSNeverKeyword", node, opts);
    	}
    	function assertTSNullKeyword(node, opts) {
    	  assert("TSNullKeyword", node, opts);
    	}
    	function assertTSNumberKeyword(node, opts) {
    	  assert("TSNumberKeyword", node, opts);
    	}
    	function assertTSObjectKeyword(node, opts) {
    	  assert("TSObjectKeyword", node, opts);
    	}
    	function assertTSStringKeyword(node, opts) {
    	  assert("TSStringKeyword", node, opts);
    	}
    	function assertTSSymbolKeyword(node, opts) {
    	  assert("TSSymbolKeyword", node, opts);
    	}
    	function assertTSUndefinedKeyword(node, opts) {
    	  assert("TSUndefinedKeyword", node, opts);
    	}
    	function assertTSUnknownKeyword(node, opts) {
    	  assert("TSUnknownKeyword", node, opts);
    	}
    	function assertTSVoidKeyword(node, opts) {
    	  assert("TSVoidKeyword", node, opts);
    	}
    	function assertTSThisType(node, opts) {
    	  assert("TSThisType", node, opts);
    	}
    	function assertTSFunctionType(node, opts) {
    	  assert("TSFunctionType", node, opts);
    	}
    	function assertTSConstructorType(node, opts) {
    	  assert("TSConstructorType", node, opts);
    	}
    	function assertTSTypeReference(node, opts) {
    	  assert("TSTypeReference", node, opts);
    	}
    	function assertTSTypePredicate(node, opts) {
    	  assert("TSTypePredicate", node, opts);
    	}
    	function assertTSTypeQuery(node, opts) {
    	  assert("TSTypeQuery", node, opts);
    	}
    	function assertTSTypeLiteral(node, opts) {
    	  assert("TSTypeLiteral", node, opts);
    	}
    	function assertTSArrayType(node, opts) {
    	  assert("TSArrayType", node, opts);
    	}
    	function assertTSTupleType(node, opts) {
    	  assert("TSTupleType", node, opts);
    	}
    	function assertTSOptionalType(node, opts) {
    	  assert("TSOptionalType", node, opts);
    	}
    	function assertTSRestType(node, opts) {
    	  assert("TSRestType", node, opts);
    	}
    	function assertTSNamedTupleMember(node, opts) {
    	  assert("TSNamedTupleMember", node, opts);
    	}
    	function assertTSUnionType(node, opts) {
    	  assert("TSUnionType", node, opts);
    	}
    	function assertTSIntersectionType(node, opts) {
    	  assert("TSIntersectionType", node, opts);
    	}
    	function assertTSConditionalType(node, opts) {
    	  assert("TSConditionalType", node, opts);
    	}
    	function assertTSInferType(node, opts) {
    	  assert("TSInferType", node, opts);
    	}
    	function assertTSParenthesizedType(node, opts) {
    	  assert("TSParenthesizedType", node, opts);
    	}
    	function assertTSTypeOperator(node, opts) {
    	  assert("TSTypeOperator", node, opts);
    	}
    	function assertTSIndexedAccessType(node, opts) {
    	  assert("TSIndexedAccessType", node, opts);
    	}
    	function assertTSMappedType(node, opts) {
    	  assert("TSMappedType", node, opts);
    	}
    	function assertTSLiteralType(node, opts) {
    	  assert("TSLiteralType", node, opts);
    	}
    	function assertTSExpressionWithTypeArguments(node, opts) {
    	  assert("TSExpressionWithTypeArguments", node, opts);
    	}
    	function assertTSInterfaceDeclaration(node, opts) {
    	  assert("TSInterfaceDeclaration", node, opts);
    	}
    	function assertTSInterfaceBody(node, opts) {
    	  assert("TSInterfaceBody", node, opts);
    	}
    	function assertTSTypeAliasDeclaration(node, opts) {
    	  assert("TSTypeAliasDeclaration", node, opts);
    	}
    	function assertTSInstantiationExpression(node, opts) {
    	  assert("TSInstantiationExpression", node, opts);
    	}
    	function assertTSAsExpression(node, opts) {
    	  assert("TSAsExpression", node, opts);
    	}
    	function assertTSSatisfiesExpression(node, opts) {
    	  assert("TSSatisfiesExpression", node, opts);
    	}
    	function assertTSTypeAssertion(node, opts) {
    	  assert("TSTypeAssertion", node, opts);
    	}
    	function assertTSEnumDeclaration(node, opts) {
    	  assert("TSEnumDeclaration", node, opts);
    	}
    	function assertTSEnumMember(node, opts) {
    	  assert("TSEnumMember", node, opts);
    	}
    	function assertTSModuleDeclaration(node, opts) {
    	  assert("TSModuleDeclaration", node, opts);
    	}
    	function assertTSModuleBlock(node, opts) {
    	  assert("TSModuleBlock", node, opts);
    	}
    	function assertTSImportType(node, opts) {
    	  assert("TSImportType", node, opts);
    	}
    	function assertTSImportEqualsDeclaration(node, opts) {
    	  assert("TSImportEqualsDeclaration", node, opts);
    	}
    	function assertTSExternalModuleReference(node, opts) {
    	  assert("TSExternalModuleReference", node, opts);
    	}
    	function assertTSNonNullExpression(node, opts) {
    	  assert("TSNonNullExpression", node, opts);
    	}
    	function assertTSExportAssignment(node, opts) {
    	  assert("TSExportAssignment", node, opts);
    	}
    	function assertTSNamespaceExportDeclaration(node, opts) {
    	  assert("TSNamespaceExportDeclaration", node, opts);
    	}
    	function assertTSTypeAnnotation(node, opts) {
    	  assert("TSTypeAnnotation", node, opts);
    	}
    	function assertTSTypeParameterInstantiation(node, opts) {
    	  assert("TSTypeParameterInstantiation", node, opts);
    	}
    	function assertTSTypeParameterDeclaration(node, opts) {
    	  assert("TSTypeParameterDeclaration", node, opts);
    	}
    	function assertTSTypeParameter(node, opts) {
    	  assert("TSTypeParameter", node, opts);
    	}
    	function assertStandardized(node, opts) {
    	  assert("Standardized", node, opts);
    	}
    	function assertExpression(node, opts) {
    	  assert("Expression", node, opts);
    	}
    	function assertBinary(node, opts) {
    	  assert("Binary", node, opts);
    	}
    	function assertScopable(node, opts) {
    	  assert("Scopable", node, opts);
    	}
    	function assertBlockParent(node, opts) {
    	  assert("BlockParent", node, opts);
    	}
    	function assertBlock(node, opts) {
    	  assert("Block", node, opts);
    	}
    	function assertStatement(node, opts) {
    	  assert("Statement", node, opts);
    	}
    	function assertTerminatorless(node, opts) {
    	  assert("Terminatorless", node, opts);
    	}
    	function assertCompletionStatement(node, opts) {
    	  assert("CompletionStatement", node, opts);
    	}
    	function assertConditional(node, opts) {
    	  assert("Conditional", node, opts);
    	}
    	function assertLoop(node, opts) {
    	  assert("Loop", node, opts);
    	}
    	function assertWhile(node, opts) {
    	  assert("While", node, opts);
    	}
    	function assertExpressionWrapper(node, opts) {
    	  assert("ExpressionWrapper", node, opts);
    	}
    	function assertFor(node, opts) {
    	  assert("For", node, opts);
    	}
    	function assertForXStatement(node, opts) {
    	  assert("ForXStatement", node, opts);
    	}
    	function assertFunction(node, opts) {
    	  assert("Function", node, opts);
    	}
    	function assertFunctionParent(node, opts) {
    	  assert("FunctionParent", node, opts);
    	}
    	function assertPureish(node, opts) {
    	  assert("Pureish", node, opts);
    	}
    	function assertDeclaration(node, opts) {
    	  assert("Declaration", node, opts);
    	}
    	function assertPatternLike(node, opts) {
    	  assert("PatternLike", node, opts);
    	}
    	function assertLVal(node, opts) {
    	  assert("LVal", node, opts);
    	}
    	function assertTSEntityName(node, opts) {
    	  assert("TSEntityName", node, opts);
    	}
    	function assertLiteral(node, opts) {
    	  assert("Literal", node, opts);
    	}
    	function assertImmutable(node, opts) {
    	  assert("Immutable", node, opts);
    	}
    	function assertUserWhitespacable(node, opts) {
    	  assert("UserWhitespacable", node, opts);
    	}
    	function assertMethod(node, opts) {
    	  assert("Method", node, opts);
    	}
    	function assertObjectMember(node, opts) {
    	  assert("ObjectMember", node, opts);
    	}
    	function assertProperty(node, opts) {
    	  assert("Property", node, opts);
    	}
    	function assertUnaryLike(node, opts) {
    	  assert("UnaryLike", node, opts);
    	}
    	function assertPattern(node, opts) {
    	  assert("Pattern", node, opts);
    	}
    	function assertClass(node, opts) {
    	  assert("Class", node, opts);
    	}
    	function assertImportOrExportDeclaration(node, opts) {
    	  assert("ImportOrExportDeclaration", node, opts);
    	}
    	function assertExportDeclaration(node, opts) {
    	  assert("ExportDeclaration", node, opts);
    	}
    	function assertModuleSpecifier(node, opts) {
    	  assert("ModuleSpecifier", node, opts);
    	}
    	function assertAccessor(node, opts) {
    	  assert("Accessor", node, opts);
    	}
    	function assertPrivate(node, opts) {
    	  assert("Private", node, opts);
    	}
    	function assertFlow(node, opts) {
    	  assert("Flow", node, opts);
    	}
    	function assertFlowType(node, opts) {
    	  assert("FlowType", node, opts);
    	}
    	function assertFlowBaseAnnotation(node, opts) {
    	  assert("FlowBaseAnnotation", node, opts);
    	}
    	function assertFlowDeclaration(node, opts) {
    	  assert("FlowDeclaration", node, opts);
    	}
    	function assertFlowPredicate(node, opts) {
    	  assert("FlowPredicate", node, opts);
    	}
    	function assertEnumBody(node, opts) {
    	  assert("EnumBody", node, opts);
    	}
    	function assertEnumMember(node, opts) {
    	  assert("EnumMember", node, opts);
    	}
    	function assertJSX(node, opts) {
    	  assert("JSX", node, opts);
    	}
    	function assertMiscellaneous(node, opts) {
    	  assert("Miscellaneous", node, opts);
    	}
    	function assertTypeScript(node, opts) {
    	  assert("TypeScript", node, opts);
    	}
    	function assertTSTypeElement(node, opts) {
    	  assert("TSTypeElement", node, opts);
    	}
    	function assertTSType(node, opts) {
    	  assert("TSType", node, opts);
    	}
    	function assertTSBaseType(node, opts) {
    	  assert("TSBaseType", node, opts);
    	}
    	function assertNumberLiteral(node, opts) {
    	  (0, _deprecationWarning.default)("assertNumberLiteral", "assertNumericLiteral");
    	  assert("NumberLiteral", node, opts);
    	}
    	function assertRegexLiteral(node, opts) {
    	  (0, _deprecationWarning.default)("assertRegexLiteral", "assertRegExpLiteral");
    	  assert("RegexLiteral", node, opts);
    	}
    	function assertRestProperty(node, opts) {
    	  (0, _deprecationWarning.default)("assertRestProperty", "assertRestElement");
    	  assert("RestProperty", node, opts);
    	}
    	function assertSpreadProperty(node, opts) {
    	  (0, _deprecationWarning.default)("assertSpreadProperty", "assertSpreadElement");
    	  assert("SpreadProperty", node, opts);
    	}
    	function assertModuleDeclaration(node, opts) {
    	  (0, _deprecationWarning.default)("assertModuleDeclaration", "assertImportOrExportDeclaration");
    	  assert("ModuleDeclaration", node, opts);
    	}

    	
    	return generated$1;
    }

    var createTypeAnnotationBasedOnTypeof = {};

    var hasRequiredCreateTypeAnnotationBasedOnTypeof;

    function requireCreateTypeAnnotationBasedOnTypeof () {
    	if (hasRequiredCreateTypeAnnotationBasedOnTypeof) return createTypeAnnotationBasedOnTypeof;
    	hasRequiredCreateTypeAnnotationBasedOnTypeof = 1;

    	Object.defineProperty(createTypeAnnotationBasedOnTypeof, "__esModule", {
    	  value: true
    	});
    	createTypeAnnotationBasedOnTypeof.default = void 0;
    	var _index = requireGenerated$2();
    	var _default = createTypeAnnotationBasedOnTypeof$1;
    	createTypeAnnotationBasedOnTypeof.default = _default;
    	function createTypeAnnotationBasedOnTypeof$1(type) {
    	  switch (type) {
    	    case "string":
    	      return (0, _index.stringTypeAnnotation)();
    	    case "number":
    	      return (0, _index.numberTypeAnnotation)();
    	    case "undefined":
    	      return (0, _index.voidTypeAnnotation)();
    	    case "boolean":
    	      return (0, _index.booleanTypeAnnotation)();
    	    case "function":
    	      return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Function"));
    	    case "object":
    	      return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Object"));
    	    case "symbol":
    	      return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Symbol"));
    	    case "bigint":
    	      return (0, _index.anyTypeAnnotation)();
    	  }
    	  throw new Error("Invalid typeof value: " + type);
    	}

    	
    	return createTypeAnnotationBasedOnTypeof;
    }

    var createFlowUnionType = {};

    var removeTypeDuplicates$1 = {};

    var hasRequiredRemoveTypeDuplicates$1;

    function requireRemoveTypeDuplicates$1 () {
    	if (hasRequiredRemoveTypeDuplicates$1) return removeTypeDuplicates$1;
    	hasRequiredRemoveTypeDuplicates$1 = 1;

    	Object.defineProperty(removeTypeDuplicates$1, "__esModule", {
    	  value: true
    	});
    	removeTypeDuplicates$1.default = removeTypeDuplicates;
    	var _index = requireGenerated$3();
    	function getQualifiedName(node) {
    	  return (0, _index.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;
    	}
    	function removeTypeDuplicates(nodesIn) {
    	  const nodes = Array.from(nodesIn);
    	  const generics = new Map();
    	  const bases = new Map();
    	  const typeGroups = new Set();
    	  const types = [];
    	  for (let i = 0; i < nodes.length; i++) {
    	    const node = nodes[i];
    	    if (!node) continue;
    	    if (types.indexOf(node) >= 0) {
    	      continue;
    	    }
    	    if ((0, _index.isAnyTypeAnnotation)(node)) {
    	      return [node];
    	    }
    	    if ((0, _index.isFlowBaseAnnotation)(node)) {
    	      bases.set(node.type, node);
    	      continue;
    	    }
    	    if ((0, _index.isUnionTypeAnnotation)(node)) {
    	      if (!typeGroups.has(node.types)) {
    	        nodes.push(...node.types);
    	        typeGroups.add(node.types);
    	      }
    	      continue;
    	    }
    	    if ((0, _index.isGenericTypeAnnotation)(node)) {
    	      const name = getQualifiedName(node.id);
    	      if (generics.has(name)) {
    	        let existing = generics.get(name);
    	        if (existing.typeParameters) {
    	          if (node.typeParameters) {
    	            existing.typeParameters.params.push(...node.typeParameters.params);
    	            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);
    	          }
    	        } else {
    	          existing = node.typeParameters;
    	        }
    	      } else {
    	        generics.set(name, node);
    	      }
    	      continue;
    	    }
    	    types.push(node);
    	  }
    	  for (const [, baseType] of bases) {
    	    types.push(baseType);
    	  }
    	  for (const [, genericName] of generics) {
    	    types.push(genericName);
    	  }
    	  return types;
    	}

    	
    	return removeTypeDuplicates$1;
    }

    var hasRequiredCreateFlowUnionType;

    function requireCreateFlowUnionType () {
    	if (hasRequiredCreateFlowUnionType) return createFlowUnionType;
    	hasRequiredCreateFlowUnionType = 1;

    	Object.defineProperty(createFlowUnionType, "__esModule", {
    	  value: true
    	});
    	createFlowUnionType.default = createFlowUnionType$1;
    	var _index = requireGenerated$2();
    	var _removeTypeDuplicates = requireRemoveTypeDuplicates$1();
    	function createFlowUnionType$1(types) {
    	  const flattened = (0, _removeTypeDuplicates.default)(types);
    	  if (flattened.length === 1) {
    	    return flattened[0];
    	  } else {
    	    return (0, _index.unionTypeAnnotation)(flattened);
    	  }
    	}

    	
    	return createFlowUnionType;
    }

    var createTSUnionType = {};

    var removeTypeDuplicates = {};

    var hasRequiredRemoveTypeDuplicates;

    function requireRemoveTypeDuplicates () {
    	if (hasRequiredRemoveTypeDuplicates) return removeTypeDuplicates;
    	hasRequiredRemoveTypeDuplicates = 1;

    	Object.defineProperty(removeTypeDuplicates, "__esModule", {
    	  value: true
    	});
    	removeTypeDuplicates.default = removeTypeDuplicates$1;
    	var _index = requireGenerated$3();
    	function getQualifiedName(node) {
    	  return (0, _index.isIdentifier)(node) ? node.name : `${node.right.name}.${getQualifiedName(node.left)}`;
    	}
    	function removeTypeDuplicates$1(nodesIn) {
    	  const nodes = Array.from(nodesIn);
    	  const generics = new Map();
    	  const bases = new Map();
    	  const typeGroups = new Set();
    	  const types = [];
    	  for (let i = 0; i < nodes.length; i++) {
    	    const node = nodes[i];
    	    if (!node) continue;
    	    if (types.indexOf(node) >= 0) {
    	      continue;
    	    }
    	    if ((0, _index.isTSAnyKeyword)(node)) {
    	      return [node];
    	    }
    	    if ((0, _index.isTSBaseType)(node)) {
    	      bases.set(node.type, node);
    	      continue;
    	    }
    	    if ((0, _index.isTSUnionType)(node)) {
    	      if (!typeGroups.has(node.types)) {
    	        nodes.push(...node.types);
    	        typeGroups.add(node.types);
    	      }
    	      continue;
    	    }
    	    if ((0, _index.isTSTypeReference)(node) && node.typeParameters) {
    	      const name = getQualifiedName(node.typeName);
    	      if (generics.has(name)) {
    	        let existing = generics.get(name);
    	        if (existing.typeParameters) {
    	          if (node.typeParameters) {
    	            existing.typeParameters.params.push(...node.typeParameters.params);
    	            existing.typeParameters.params = removeTypeDuplicates$1(existing.typeParameters.params);
    	          }
    	        } else {
    	          existing = node.typeParameters;
    	        }
    	      } else {
    	        generics.set(name, node);
    	      }
    	      continue;
    	    }
    	    types.push(node);
    	  }
    	  for (const [, baseType] of bases) {
    	    types.push(baseType);
    	  }
    	  for (const [, genericName] of generics) {
    	    types.push(genericName);
    	  }
    	  return types;
    	}

    	
    	return removeTypeDuplicates;
    }

    var hasRequiredCreateTSUnionType;

    function requireCreateTSUnionType () {
    	if (hasRequiredCreateTSUnionType) return createTSUnionType;
    	hasRequiredCreateTSUnionType = 1;

    	Object.defineProperty(createTSUnionType, "__esModule", {
    	  value: true
    	});
    	createTSUnionType.default = createTSUnionType$1;
    	var _index = requireGenerated$2();
    	var _removeTypeDuplicates = requireRemoveTypeDuplicates();
    	var _index2 = requireGenerated$3();
    	function createTSUnionType$1(typeAnnotations) {
    	  const types = typeAnnotations.map(type => {
    	    return (0, _index2.isTSTypeAnnotation)(type) ? type.typeAnnotation : type;
    	  });
    	  const flattened = (0, _removeTypeDuplicates.default)(types);
    	  if (flattened.length === 1) {
    	    return flattened[0];
    	  } else {
    	    return (0, _index.tsUnionType)(flattened);
    	  }
    	}

    	
    	return createTSUnionType;
    }

    var uppercase = {};

    var hasRequiredUppercase;

    function requireUppercase () {
    	if (hasRequiredUppercase) return uppercase;
    	hasRequiredUppercase = 1;
    	(function (exports) {

    		Object.defineProperty(exports, "__esModule", {
    		  value: true
    		});
    		Object.defineProperty(exports, "AnyTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.anyTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "ArgumentPlaceholder", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.argumentPlaceholder;
    		  }
    		});
    		Object.defineProperty(exports, "ArrayExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.arrayExpression;
    		  }
    		});
    		Object.defineProperty(exports, "ArrayPattern", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.arrayPattern;
    		  }
    		});
    		Object.defineProperty(exports, "ArrayTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.arrayTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "ArrowFunctionExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.arrowFunctionExpression;
    		  }
    		});
    		Object.defineProperty(exports, "AssignmentExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.assignmentExpression;
    		  }
    		});
    		Object.defineProperty(exports, "AssignmentPattern", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.assignmentPattern;
    		  }
    		});
    		Object.defineProperty(exports, "AwaitExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.awaitExpression;
    		  }
    		});
    		Object.defineProperty(exports, "BigIntLiteral", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.bigIntLiteral;
    		  }
    		});
    		Object.defineProperty(exports, "BinaryExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.binaryExpression;
    		  }
    		});
    		Object.defineProperty(exports, "BindExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.bindExpression;
    		  }
    		});
    		Object.defineProperty(exports, "BlockStatement", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.blockStatement;
    		  }
    		});
    		Object.defineProperty(exports, "BooleanLiteral", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.booleanLiteral;
    		  }
    		});
    		Object.defineProperty(exports, "BooleanLiteralTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.booleanLiteralTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "BooleanTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.booleanTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "BreakStatement", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.breakStatement;
    		  }
    		});
    		Object.defineProperty(exports, "CallExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.callExpression;
    		  }
    		});
    		Object.defineProperty(exports, "CatchClause", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.catchClause;
    		  }
    		});
    		Object.defineProperty(exports, "ClassAccessorProperty", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.classAccessorProperty;
    		  }
    		});
    		Object.defineProperty(exports, "ClassBody", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.classBody;
    		  }
    		});
    		Object.defineProperty(exports, "ClassDeclaration", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.classDeclaration;
    		  }
    		});
    		Object.defineProperty(exports, "ClassExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.classExpression;
    		  }
    		});
    		Object.defineProperty(exports, "ClassImplements", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.classImplements;
    		  }
    		});
    		Object.defineProperty(exports, "ClassMethod", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.classMethod;
    		  }
    		});
    		Object.defineProperty(exports, "ClassPrivateMethod", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.classPrivateMethod;
    		  }
    		});
    		Object.defineProperty(exports, "ClassPrivateProperty", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.classPrivateProperty;
    		  }
    		});
    		Object.defineProperty(exports, "ClassProperty", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.classProperty;
    		  }
    		});
    		Object.defineProperty(exports, "ConditionalExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.conditionalExpression;
    		  }
    		});
    		Object.defineProperty(exports, "ContinueStatement", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.continueStatement;
    		  }
    		});
    		Object.defineProperty(exports, "DebuggerStatement", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.debuggerStatement;
    		  }
    		});
    		Object.defineProperty(exports, "DecimalLiteral", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.decimalLiteral;
    		  }
    		});
    		Object.defineProperty(exports, "DeclareClass", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.declareClass;
    		  }
    		});
    		Object.defineProperty(exports, "DeclareExportAllDeclaration", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.declareExportAllDeclaration;
    		  }
    		});
    		Object.defineProperty(exports, "DeclareExportDeclaration", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.declareExportDeclaration;
    		  }
    		});
    		Object.defineProperty(exports, "DeclareFunction", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.declareFunction;
    		  }
    		});
    		Object.defineProperty(exports, "DeclareInterface", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.declareInterface;
    		  }
    		});
    		Object.defineProperty(exports, "DeclareModule", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.declareModule;
    		  }
    		});
    		Object.defineProperty(exports, "DeclareModuleExports", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.declareModuleExports;
    		  }
    		});
    		Object.defineProperty(exports, "DeclareOpaqueType", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.declareOpaqueType;
    		  }
    		});
    		Object.defineProperty(exports, "DeclareTypeAlias", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.declareTypeAlias;
    		  }
    		});
    		Object.defineProperty(exports, "DeclareVariable", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.declareVariable;
    		  }
    		});
    		Object.defineProperty(exports, "DeclaredPredicate", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.declaredPredicate;
    		  }
    		});
    		Object.defineProperty(exports, "Decorator", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.decorator;
    		  }
    		});
    		Object.defineProperty(exports, "Directive", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.directive;
    		  }
    		});
    		Object.defineProperty(exports, "DirectiveLiteral", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.directiveLiteral;
    		  }
    		});
    		Object.defineProperty(exports, "DoExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.doExpression;
    		  }
    		});
    		Object.defineProperty(exports, "DoWhileStatement", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.doWhileStatement;
    		  }
    		});
    		Object.defineProperty(exports, "EmptyStatement", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.emptyStatement;
    		  }
    		});
    		Object.defineProperty(exports, "EmptyTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.emptyTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "EnumBooleanBody", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.enumBooleanBody;
    		  }
    		});
    		Object.defineProperty(exports, "EnumBooleanMember", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.enumBooleanMember;
    		  }
    		});
    		Object.defineProperty(exports, "EnumDeclaration", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.enumDeclaration;
    		  }
    		});
    		Object.defineProperty(exports, "EnumDefaultedMember", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.enumDefaultedMember;
    		  }
    		});
    		Object.defineProperty(exports, "EnumNumberBody", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.enumNumberBody;
    		  }
    		});
    		Object.defineProperty(exports, "EnumNumberMember", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.enumNumberMember;
    		  }
    		});
    		Object.defineProperty(exports, "EnumStringBody", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.enumStringBody;
    		  }
    		});
    		Object.defineProperty(exports, "EnumStringMember", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.enumStringMember;
    		  }
    		});
    		Object.defineProperty(exports, "EnumSymbolBody", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.enumSymbolBody;
    		  }
    		});
    		Object.defineProperty(exports, "ExistsTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.existsTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "ExportAllDeclaration", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.exportAllDeclaration;
    		  }
    		});
    		Object.defineProperty(exports, "ExportDefaultDeclaration", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.exportDefaultDeclaration;
    		  }
    		});
    		Object.defineProperty(exports, "ExportDefaultSpecifier", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.exportDefaultSpecifier;
    		  }
    		});
    		Object.defineProperty(exports, "ExportNamedDeclaration", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.exportNamedDeclaration;
    		  }
    		});
    		Object.defineProperty(exports, "ExportNamespaceSpecifier", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.exportNamespaceSpecifier;
    		  }
    		});
    		Object.defineProperty(exports, "ExportSpecifier", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.exportSpecifier;
    		  }
    		});
    		Object.defineProperty(exports, "ExpressionStatement", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.expressionStatement;
    		  }
    		});
    		Object.defineProperty(exports, "File", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.file;
    		  }
    		});
    		Object.defineProperty(exports, "ForInStatement", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.forInStatement;
    		  }
    		});
    		Object.defineProperty(exports, "ForOfStatement", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.forOfStatement;
    		  }
    		});
    		Object.defineProperty(exports, "ForStatement", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.forStatement;
    		  }
    		});
    		Object.defineProperty(exports, "FunctionDeclaration", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.functionDeclaration;
    		  }
    		});
    		Object.defineProperty(exports, "FunctionExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.functionExpression;
    		  }
    		});
    		Object.defineProperty(exports, "FunctionTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.functionTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "FunctionTypeParam", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.functionTypeParam;
    		  }
    		});
    		Object.defineProperty(exports, "GenericTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.genericTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "Identifier", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.identifier;
    		  }
    		});
    		Object.defineProperty(exports, "IfStatement", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.ifStatement;
    		  }
    		});
    		Object.defineProperty(exports, "Import", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.import;
    		  }
    		});
    		Object.defineProperty(exports, "ImportAttribute", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.importAttribute;
    		  }
    		});
    		Object.defineProperty(exports, "ImportDeclaration", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.importDeclaration;
    		  }
    		});
    		Object.defineProperty(exports, "ImportDefaultSpecifier", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.importDefaultSpecifier;
    		  }
    		});
    		Object.defineProperty(exports, "ImportExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.importExpression;
    		  }
    		});
    		Object.defineProperty(exports, "ImportNamespaceSpecifier", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.importNamespaceSpecifier;
    		  }
    		});
    		Object.defineProperty(exports, "ImportSpecifier", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.importSpecifier;
    		  }
    		});
    		Object.defineProperty(exports, "IndexedAccessType", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.indexedAccessType;
    		  }
    		});
    		Object.defineProperty(exports, "InferredPredicate", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.inferredPredicate;
    		  }
    		});
    		Object.defineProperty(exports, "InterfaceDeclaration", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.interfaceDeclaration;
    		  }
    		});
    		Object.defineProperty(exports, "InterfaceExtends", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.interfaceExtends;
    		  }
    		});
    		Object.defineProperty(exports, "InterfaceTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.interfaceTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "InterpreterDirective", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.interpreterDirective;
    		  }
    		});
    		Object.defineProperty(exports, "IntersectionTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.intersectionTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "JSXAttribute", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.jsxAttribute;
    		  }
    		});
    		Object.defineProperty(exports, "JSXClosingElement", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.jsxClosingElement;
    		  }
    		});
    		Object.defineProperty(exports, "JSXClosingFragment", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.jsxClosingFragment;
    		  }
    		});
    		Object.defineProperty(exports, "JSXElement", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.jsxElement;
    		  }
    		});
    		Object.defineProperty(exports, "JSXEmptyExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.jsxEmptyExpression;
    		  }
    		});
    		Object.defineProperty(exports, "JSXExpressionContainer", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.jsxExpressionContainer;
    		  }
    		});
    		Object.defineProperty(exports, "JSXFragment", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.jsxFragment;
    		  }
    		});
    		Object.defineProperty(exports, "JSXIdentifier", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.jsxIdentifier;
    		  }
    		});
    		Object.defineProperty(exports, "JSXMemberExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.jsxMemberExpression;
    		  }
    		});
    		Object.defineProperty(exports, "JSXNamespacedName", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.jsxNamespacedName;
    		  }
    		});
    		Object.defineProperty(exports, "JSXOpeningElement", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.jsxOpeningElement;
    		  }
    		});
    		Object.defineProperty(exports, "JSXOpeningFragment", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.jsxOpeningFragment;
    		  }
    		});
    		Object.defineProperty(exports, "JSXSpreadAttribute", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.jsxSpreadAttribute;
    		  }
    		});
    		Object.defineProperty(exports, "JSXSpreadChild", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.jsxSpreadChild;
    		  }
    		});
    		Object.defineProperty(exports, "JSXText", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.jsxText;
    		  }
    		});
    		Object.defineProperty(exports, "LabeledStatement", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.labeledStatement;
    		  }
    		});
    		Object.defineProperty(exports, "LogicalExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.logicalExpression;
    		  }
    		});
    		Object.defineProperty(exports, "MemberExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.memberExpression;
    		  }
    		});
    		Object.defineProperty(exports, "MetaProperty", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.metaProperty;
    		  }
    		});
    		Object.defineProperty(exports, "MixedTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.mixedTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "ModuleExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.moduleExpression;
    		  }
    		});
    		Object.defineProperty(exports, "NewExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.newExpression;
    		  }
    		});
    		Object.defineProperty(exports, "Noop", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.noop;
    		  }
    		});
    		Object.defineProperty(exports, "NullLiteral", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.nullLiteral;
    		  }
    		});
    		Object.defineProperty(exports, "NullLiteralTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.nullLiteralTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "NullableTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.nullableTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "NumberLiteral", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.numberLiteral;
    		  }
    		});
    		Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.numberLiteralTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "NumberTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.numberTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "NumericLiteral", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.numericLiteral;
    		  }
    		});
    		Object.defineProperty(exports, "ObjectExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.objectExpression;
    		  }
    		});
    		Object.defineProperty(exports, "ObjectMethod", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.objectMethod;
    		  }
    		});
    		Object.defineProperty(exports, "ObjectPattern", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.objectPattern;
    		  }
    		});
    		Object.defineProperty(exports, "ObjectProperty", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.objectProperty;
    		  }
    		});
    		Object.defineProperty(exports, "ObjectTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.objectTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "ObjectTypeCallProperty", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.objectTypeCallProperty;
    		  }
    		});
    		Object.defineProperty(exports, "ObjectTypeIndexer", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.objectTypeIndexer;
    		  }
    		});
    		Object.defineProperty(exports, "ObjectTypeInternalSlot", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.objectTypeInternalSlot;
    		  }
    		});
    		Object.defineProperty(exports, "ObjectTypeProperty", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.objectTypeProperty;
    		  }
    		});
    		Object.defineProperty(exports, "ObjectTypeSpreadProperty", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.objectTypeSpreadProperty;
    		  }
    		});
    		Object.defineProperty(exports, "OpaqueType", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.opaqueType;
    		  }
    		});
    		Object.defineProperty(exports, "OptionalCallExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.optionalCallExpression;
    		  }
    		});
    		Object.defineProperty(exports, "OptionalIndexedAccessType", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.optionalIndexedAccessType;
    		  }
    		});
    		Object.defineProperty(exports, "OptionalMemberExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.optionalMemberExpression;
    		  }
    		});
    		Object.defineProperty(exports, "ParenthesizedExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.parenthesizedExpression;
    		  }
    		});
    		Object.defineProperty(exports, "PipelineBareFunction", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.pipelineBareFunction;
    		  }
    		});
    		Object.defineProperty(exports, "PipelinePrimaryTopicReference", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.pipelinePrimaryTopicReference;
    		  }
    		});
    		Object.defineProperty(exports, "PipelineTopicExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.pipelineTopicExpression;
    		  }
    		});
    		Object.defineProperty(exports, "Placeholder", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.placeholder;
    		  }
    		});
    		Object.defineProperty(exports, "PrivateName", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.privateName;
    		  }
    		});
    		Object.defineProperty(exports, "Program", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.program;
    		  }
    		});
    		Object.defineProperty(exports, "QualifiedTypeIdentifier", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.qualifiedTypeIdentifier;
    		  }
    		});
    		Object.defineProperty(exports, "RecordExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.recordExpression;
    		  }
    		});
    		Object.defineProperty(exports, "RegExpLiteral", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.regExpLiteral;
    		  }
    		});
    		Object.defineProperty(exports, "RegexLiteral", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.regexLiteral;
    		  }
    		});
    		Object.defineProperty(exports, "RestElement", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.restElement;
    		  }
    		});
    		Object.defineProperty(exports, "RestProperty", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.restProperty;
    		  }
    		});
    		Object.defineProperty(exports, "ReturnStatement", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.returnStatement;
    		  }
    		});
    		Object.defineProperty(exports, "SequenceExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.sequenceExpression;
    		  }
    		});
    		Object.defineProperty(exports, "SpreadElement", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.spreadElement;
    		  }
    		});
    		Object.defineProperty(exports, "SpreadProperty", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.spreadProperty;
    		  }
    		});
    		Object.defineProperty(exports, "StaticBlock", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.staticBlock;
    		  }
    		});
    		Object.defineProperty(exports, "StringLiteral", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.stringLiteral;
    		  }
    		});
    		Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.stringLiteralTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "StringTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.stringTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "Super", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.super;
    		  }
    		});
    		Object.defineProperty(exports, "SwitchCase", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.switchCase;
    		  }
    		});
    		Object.defineProperty(exports, "SwitchStatement", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.switchStatement;
    		  }
    		});
    		Object.defineProperty(exports, "SymbolTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.symbolTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "TSAnyKeyword", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsAnyKeyword;
    		  }
    		});
    		Object.defineProperty(exports, "TSArrayType", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsArrayType;
    		  }
    		});
    		Object.defineProperty(exports, "TSAsExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsAsExpression;
    		  }
    		});
    		Object.defineProperty(exports, "TSBigIntKeyword", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsBigIntKeyword;
    		  }
    		});
    		Object.defineProperty(exports, "TSBooleanKeyword", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsBooleanKeyword;
    		  }
    		});
    		Object.defineProperty(exports, "TSCallSignatureDeclaration", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsCallSignatureDeclaration;
    		  }
    		});
    		Object.defineProperty(exports, "TSConditionalType", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsConditionalType;
    		  }
    		});
    		Object.defineProperty(exports, "TSConstructSignatureDeclaration", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsConstructSignatureDeclaration;
    		  }
    		});
    		Object.defineProperty(exports, "TSConstructorType", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsConstructorType;
    		  }
    		});
    		Object.defineProperty(exports, "TSDeclareFunction", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsDeclareFunction;
    		  }
    		});
    		Object.defineProperty(exports, "TSDeclareMethod", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsDeclareMethod;
    		  }
    		});
    		Object.defineProperty(exports, "TSEnumDeclaration", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsEnumDeclaration;
    		  }
    		});
    		Object.defineProperty(exports, "TSEnumMember", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsEnumMember;
    		  }
    		});
    		Object.defineProperty(exports, "TSExportAssignment", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsExportAssignment;
    		  }
    		});
    		Object.defineProperty(exports, "TSExpressionWithTypeArguments", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsExpressionWithTypeArguments;
    		  }
    		});
    		Object.defineProperty(exports, "TSExternalModuleReference", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsExternalModuleReference;
    		  }
    		});
    		Object.defineProperty(exports, "TSFunctionType", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsFunctionType;
    		  }
    		});
    		Object.defineProperty(exports, "TSImportEqualsDeclaration", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsImportEqualsDeclaration;
    		  }
    		});
    		Object.defineProperty(exports, "TSImportType", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsImportType;
    		  }
    		});
    		Object.defineProperty(exports, "TSIndexSignature", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsIndexSignature;
    		  }
    		});
    		Object.defineProperty(exports, "TSIndexedAccessType", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsIndexedAccessType;
    		  }
    		});
    		Object.defineProperty(exports, "TSInferType", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsInferType;
    		  }
    		});
    		Object.defineProperty(exports, "TSInstantiationExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsInstantiationExpression;
    		  }
    		});
    		Object.defineProperty(exports, "TSInterfaceBody", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsInterfaceBody;
    		  }
    		});
    		Object.defineProperty(exports, "TSInterfaceDeclaration", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsInterfaceDeclaration;
    		  }
    		});
    		Object.defineProperty(exports, "TSIntersectionType", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsIntersectionType;
    		  }
    		});
    		Object.defineProperty(exports, "TSIntrinsicKeyword", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsIntrinsicKeyword;
    		  }
    		});
    		Object.defineProperty(exports, "TSLiteralType", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsLiteralType;
    		  }
    		});
    		Object.defineProperty(exports, "TSMappedType", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsMappedType;
    		  }
    		});
    		Object.defineProperty(exports, "TSMethodSignature", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsMethodSignature;
    		  }
    		});
    		Object.defineProperty(exports, "TSModuleBlock", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsModuleBlock;
    		  }
    		});
    		Object.defineProperty(exports, "TSModuleDeclaration", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsModuleDeclaration;
    		  }
    		});
    		Object.defineProperty(exports, "TSNamedTupleMember", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsNamedTupleMember;
    		  }
    		});
    		Object.defineProperty(exports, "TSNamespaceExportDeclaration", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsNamespaceExportDeclaration;
    		  }
    		});
    		Object.defineProperty(exports, "TSNeverKeyword", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsNeverKeyword;
    		  }
    		});
    		Object.defineProperty(exports, "TSNonNullExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsNonNullExpression;
    		  }
    		});
    		Object.defineProperty(exports, "TSNullKeyword", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsNullKeyword;
    		  }
    		});
    		Object.defineProperty(exports, "TSNumberKeyword", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsNumberKeyword;
    		  }
    		});
    		Object.defineProperty(exports, "TSObjectKeyword", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsObjectKeyword;
    		  }
    		});
    		Object.defineProperty(exports, "TSOptionalType", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsOptionalType;
    		  }
    		});
    		Object.defineProperty(exports, "TSParameterProperty", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsParameterProperty;
    		  }
    		});
    		Object.defineProperty(exports, "TSParenthesizedType", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsParenthesizedType;
    		  }
    		});
    		Object.defineProperty(exports, "TSPropertySignature", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsPropertySignature;
    		  }
    		});
    		Object.defineProperty(exports, "TSQualifiedName", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsQualifiedName;
    		  }
    		});
    		Object.defineProperty(exports, "TSRestType", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsRestType;
    		  }
    		});
    		Object.defineProperty(exports, "TSSatisfiesExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsSatisfiesExpression;
    		  }
    		});
    		Object.defineProperty(exports, "TSStringKeyword", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsStringKeyword;
    		  }
    		});
    		Object.defineProperty(exports, "TSSymbolKeyword", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsSymbolKeyword;
    		  }
    		});
    		Object.defineProperty(exports, "TSThisType", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsThisType;
    		  }
    		});
    		Object.defineProperty(exports, "TSTupleType", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsTupleType;
    		  }
    		});
    		Object.defineProperty(exports, "TSTypeAliasDeclaration", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsTypeAliasDeclaration;
    		  }
    		});
    		Object.defineProperty(exports, "TSTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "TSTypeAssertion", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsTypeAssertion;
    		  }
    		});
    		Object.defineProperty(exports, "TSTypeLiteral", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsTypeLiteral;
    		  }
    		});
    		Object.defineProperty(exports, "TSTypeOperator", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsTypeOperator;
    		  }
    		});
    		Object.defineProperty(exports, "TSTypeParameter", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsTypeParameter;
    		  }
    		});
    		Object.defineProperty(exports, "TSTypeParameterDeclaration", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsTypeParameterDeclaration;
    		  }
    		});
    		Object.defineProperty(exports, "TSTypeParameterInstantiation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsTypeParameterInstantiation;
    		  }
    		});
    		Object.defineProperty(exports, "TSTypePredicate", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsTypePredicate;
    		  }
    		});
    		Object.defineProperty(exports, "TSTypeQuery", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsTypeQuery;
    		  }
    		});
    		Object.defineProperty(exports, "TSTypeReference", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsTypeReference;
    		  }
    		});
    		Object.defineProperty(exports, "TSUndefinedKeyword", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsUndefinedKeyword;
    		  }
    		});
    		Object.defineProperty(exports, "TSUnionType", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsUnionType;
    		  }
    		});
    		Object.defineProperty(exports, "TSUnknownKeyword", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsUnknownKeyword;
    		  }
    		});
    		Object.defineProperty(exports, "TSVoidKeyword", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tsVoidKeyword;
    		  }
    		});
    		Object.defineProperty(exports, "TaggedTemplateExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.taggedTemplateExpression;
    		  }
    		});
    		Object.defineProperty(exports, "TemplateElement", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.templateElement;
    		  }
    		});
    		Object.defineProperty(exports, "TemplateLiteral", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.templateLiteral;
    		  }
    		});
    		Object.defineProperty(exports, "ThisExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.thisExpression;
    		  }
    		});
    		Object.defineProperty(exports, "ThisTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.thisTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "ThrowStatement", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.throwStatement;
    		  }
    		});
    		Object.defineProperty(exports, "TopicReference", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.topicReference;
    		  }
    		});
    		Object.defineProperty(exports, "TryStatement", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tryStatement;
    		  }
    		});
    		Object.defineProperty(exports, "TupleExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tupleExpression;
    		  }
    		});
    		Object.defineProperty(exports, "TupleTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.tupleTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "TypeAlias", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.typeAlias;
    		  }
    		});
    		Object.defineProperty(exports, "TypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.typeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "TypeCastExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.typeCastExpression;
    		  }
    		});
    		Object.defineProperty(exports, "TypeParameter", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.typeParameter;
    		  }
    		});
    		Object.defineProperty(exports, "TypeParameterDeclaration", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.typeParameterDeclaration;
    		  }
    		});
    		Object.defineProperty(exports, "TypeParameterInstantiation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.typeParameterInstantiation;
    		  }
    		});
    		Object.defineProperty(exports, "TypeofTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.typeofTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "UnaryExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.unaryExpression;
    		  }
    		});
    		Object.defineProperty(exports, "UnionTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.unionTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "UpdateExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.updateExpression;
    		  }
    		});
    		Object.defineProperty(exports, "V8IntrinsicIdentifier", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.v8IntrinsicIdentifier;
    		  }
    		});
    		Object.defineProperty(exports, "VariableDeclaration", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.variableDeclaration;
    		  }
    		});
    		Object.defineProperty(exports, "VariableDeclarator", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.variableDeclarator;
    		  }
    		});
    		Object.defineProperty(exports, "Variance", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.variance;
    		  }
    		});
    		Object.defineProperty(exports, "VoidTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.voidTypeAnnotation;
    		  }
    		});
    		Object.defineProperty(exports, "WhileStatement", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.whileStatement;
    		  }
    		});
    		Object.defineProperty(exports, "WithStatement", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.withStatement;
    		  }
    		});
    		Object.defineProperty(exports, "YieldExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _index.yieldExpression;
    		  }
    		});
    		var _index = requireGenerated$2();

    		
    	} (uppercase));
    	return uppercase;
    }

    var productions = {};

    var hasRequiredProductions;

    function requireProductions () {
    	if (hasRequiredProductions) return productions;
    	hasRequiredProductions = 1;

    	Object.defineProperty(productions, "__esModule", {
    	  value: true
    	});
    	productions.buildUndefinedNode = buildUndefinedNode;
    	var _index = requireGenerated$2();
    	function buildUndefinedNode() {
    	  return (0, _index.unaryExpression)("void", (0, _index.numericLiteral)(0), true);
    	}

    	
    	return productions;
    }

    var cloneNode = {};

    var hasRequiredCloneNode;

    function requireCloneNode () {
    	if (hasRequiredCloneNode) return cloneNode;
    	hasRequiredCloneNode = 1;

    	Object.defineProperty(cloneNode, "__esModule", {
    	  value: true
    	});
    	cloneNode.default = cloneNode$1;
    	var _index = requireDefinitions();
    	var _index2 = requireGenerated$3();
    	const has = Function.call.bind(Object.prototype.hasOwnProperty);
    	function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
    	  if (obj && typeof obj.type === "string") {
    	    return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
    	  }
    	  return obj;
    	}
    	function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
    	  if (Array.isArray(obj)) {
    	    return obj.map(node => cloneIfNode(node, deep, withoutLoc, commentsCache));
    	  }
    	  return cloneIfNode(obj, deep, withoutLoc, commentsCache);
    	}
    	function cloneNode$1(node, deep = true, withoutLoc = false) {
    	  return cloneNodeInternal(node, deep, withoutLoc, new Map());
    	}
    	function cloneNodeInternal(node, deep = true, withoutLoc = false, commentsCache) {
    	  if (!node) return node;
    	  const {
    	    type
    	  } = node;
    	  const newNode = {
    	    type: node.type
    	  };
    	  if ((0, _index2.isIdentifier)(node)) {
    	    newNode.name = node.name;
    	    if (has(node, "optional") && typeof node.optional === "boolean") {
    	      newNode.optional = node.optional;
    	    }
    	    if (has(node, "typeAnnotation")) {
    	      newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;
    	    }
    	  } else if (!has(_index.NODE_FIELDS, type)) {
    	    throw new Error(`Unknown node type: "${type}"`);
    	  } else {
    	    for (const field of Object.keys(_index.NODE_FIELDS[type])) {
    	      if (has(node, field)) {
    	        if (deep) {
    	          newNode[field] = (0, _index2.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], true, withoutLoc, commentsCache);
    	        } else {
    	          newNode[field] = node[field];
    	        }
    	      }
    	    }
    	  }
    	  if (has(node, "loc")) {
    	    if (withoutLoc) {
    	      newNode.loc = null;
    	    } else {
    	      newNode.loc = node.loc;
    	    }
    	  }
    	  if (has(node, "leadingComments")) {
    	    newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);
    	  }
    	  if (has(node, "innerComments")) {
    	    newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);
    	  }
    	  if (has(node, "trailingComments")) {
    	    newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);
    	  }
    	  if (has(node, "extra")) {
    	    newNode.extra = Object.assign({}, node.extra);
    	  }
    	  return newNode;
    	}
    	function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
    	  if (!comments || !deep) {
    	    return comments;
    	  }
    	  return comments.map(comment => {
    	    const cache = commentsCache.get(comment);
    	    if (cache) return cache;
    	    const {
    	      type,
    	      value,
    	      loc
    	    } = comment;
    	    const ret = {
    	      type,
    	      value,
    	      loc
    	    };
    	    if (withoutLoc) {
    	      ret.loc = null;
    	    }
    	    commentsCache.set(comment, ret);
    	    return ret;
    	  });
    	}

    	
    	return cloneNode;
    }

    var clone = {};

    var hasRequiredClone;

    function requireClone () {
    	if (hasRequiredClone) return clone;
    	hasRequiredClone = 1;

    	Object.defineProperty(clone, "__esModule", {
    	  value: true
    	});
    	clone.default = clone$1;
    	var _cloneNode = requireCloneNode();
    	function clone$1(node) {
    	  return (0, _cloneNode.default)(node, false);
    	}

    	
    	return clone;
    }

    var cloneDeep = {};

    var hasRequiredCloneDeep;

    function requireCloneDeep () {
    	if (hasRequiredCloneDeep) return cloneDeep;
    	hasRequiredCloneDeep = 1;

    	Object.defineProperty(cloneDeep, "__esModule", {
    	  value: true
    	});
    	cloneDeep.default = cloneDeep$1;
    	var _cloneNode = requireCloneNode();
    	function cloneDeep$1(node) {
    	  return (0, _cloneNode.default)(node);
    	}

    	
    	return cloneDeep;
    }

    var cloneDeepWithoutLoc = {};

    var hasRequiredCloneDeepWithoutLoc;

    function requireCloneDeepWithoutLoc () {
    	if (hasRequiredCloneDeepWithoutLoc) return cloneDeepWithoutLoc;
    	hasRequiredCloneDeepWithoutLoc = 1;

    	Object.defineProperty(cloneDeepWithoutLoc, "__esModule", {
    	  value: true
    	});
    	cloneDeepWithoutLoc.default = cloneDeepWithoutLoc$1;
    	var _cloneNode = requireCloneNode();
    	function cloneDeepWithoutLoc$1(node) {
    	  return (0, _cloneNode.default)(node, true, true);
    	}

    	
    	return cloneDeepWithoutLoc;
    }

    var cloneWithoutLoc = {};

    var hasRequiredCloneWithoutLoc;

    function requireCloneWithoutLoc () {
    	if (hasRequiredCloneWithoutLoc) return cloneWithoutLoc;
    	hasRequiredCloneWithoutLoc = 1;

    	Object.defineProperty(cloneWithoutLoc, "__esModule", {
    	  value: true
    	});
    	cloneWithoutLoc.default = cloneWithoutLoc$1;
    	var _cloneNode = requireCloneNode();
    	function cloneWithoutLoc$1(node) {
    	  return (0, _cloneNode.default)(node, false, true);
    	}

    	
    	return cloneWithoutLoc;
    }

    var addComment = {};

    var addComments = {};

    var hasRequiredAddComments;

    function requireAddComments () {
    	if (hasRequiredAddComments) return addComments;
    	hasRequiredAddComments = 1;

    	Object.defineProperty(addComments, "__esModule", {
    	  value: true
    	});
    	addComments.default = addComments$1;
    	function addComments$1(node, type, comments) {
    	  if (!comments || !node) return node;
    	  const key = `${type}Comments`;
    	  if (node[key]) {
    	    if (type === "leading") {
    	      node[key] = comments.concat(node[key]);
    	    } else {
    	      node[key].push(...comments);
    	    }
    	  } else {
    	    node[key] = comments;
    	  }
    	  return node;
    	}

    	
    	return addComments;
    }

    var hasRequiredAddComment;

    function requireAddComment () {
    	if (hasRequiredAddComment) return addComment;
    	hasRequiredAddComment = 1;

    	Object.defineProperty(addComment, "__esModule", {
    	  value: true
    	});
    	addComment.default = addComment$1;
    	var _addComments = requireAddComments();
    	function addComment$1(node, type, content, line) {
    	  return (0, _addComments.default)(node, type, [{
    	    type: line ? "CommentLine" : "CommentBlock",
    	    value: content
    	  }]);
    	}

    	
    	return addComment;
    }

    var inheritInnerComments = {};

    var inherit = {};

    var hasRequiredInherit;

    function requireInherit () {
    	if (hasRequiredInherit) return inherit;
    	hasRequiredInherit = 1;

    	Object.defineProperty(inherit, "__esModule", {
    	  value: true
    	});
    	inherit.default = inherit$1;
    	function inherit$1(key, child, parent) {
    	  if (child && parent) {
    	    child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
    	  }
    	}

    	
    	return inherit;
    }

    var hasRequiredInheritInnerComments;

    function requireInheritInnerComments () {
    	if (hasRequiredInheritInnerComments) return inheritInnerComments;
    	hasRequiredInheritInnerComments = 1;

    	Object.defineProperty(inheritInnerComments, "__esModule", {
    	  value: true
    	});
    	inheritInnerComments.default = inheritInnerComments$1;
    	var _inherit = requireInherit();
    	function inheritInnerComments$1(child, parent) {
    	  (0, _inherit.default)("innerComments", child, parent);
    	}

    	
    	return inheritInnerComments;
    }

    var inheritLeadingComments = {};

    var hasRequiredInheritLeadingComments;

    function requireInheritLeadingComments () {
    	if (hasRequiredInheritLeadingComments) return inheritLeadingComments;
    	hasRequiredInheritLeadingComments = 1;

    	Object.defineProperty(inheritLeadingComments, "__esModule", {
    	  value: true
    	});
    	inheritLeadingComments.default = inheritLeadingComments$1;
    	var _inherit = requireInherit();
    	function inheritLeadingComments$1(child, parent) {
    	  (0, _inherit.default)("leadingComments", child, parent);
    	}

    	
    	return inheritLeadingComments;
    }

    var inheritsComments = {};

    var inheritTrailingComments = {};

    var hasRequiredInheritTrailingComments;

    function requireInheritTrailingComments () {
    	if (hasRequiredInheritTrailingComments) return inheritTrailingComments;
    	hasRequiredInheritTrailingComments = 1;

    	Object.defineProperty(inheritTrailingComments, "__esModule", {
    	  value: true
    	});
    	inheritTrailingComments.default = inheritTrailingComments$1;
    	var _inherit = requireInherit();
    	function inheritTrailingComments$1(child, parent) {
    	  (0, _inherit.default)("trailingComments", child, parent);
    	}

    	
    	return inheritTrailingComments;
    }

    var hasRequiredInheritsComments;

    function requireInheritsComments () {
    	if (hasRequiredInheritsComments) return inheritsComments;
    	hasRequiredInheritsComments = 1;

    	Object.defineProperty(inheritsComments, "__esModule", {
    	  value: true
    	});
    	inheritsComments.default = inheritsComments$1;
    	var _inheritTrailingComments = requireInheritTrailingComments();
    	var _inheritLeadingComments = requireInheritLeadingComments();
    	var _inheritInnerComments = requireInheritInnerComments();
    	function inheritsComments$1(child, parent) {
    	  (0, _inheritTrailingComments.default)(child, parent);
    	  (0, _inheritLeadingComments.default)(child, parent);
    	  (0, _inheritInnerComments.default)(child, parent);
    	  return child;
    	}

    	
    	return inheritsComments;
    }

    var removeComments = {};

    var hasRequiredRemoveComments;

    function requireRemoveComments () {
    	if (hasRequiredRemoveComments) return removeComments;
    	hasRequiredRemoveComments = 1;

    	Object.defineProperty(removeComments, "__esModule", {
    	  value: true
    	});
    	removeComments.default = removeComments$1;
    	var _index = requireConstants();
    	function removeComments$1(node) {
    	  _index.COMMENT_KEYS.forEach(key => {
    	    node[key] = null;
    	  });
    	  return node;
    	}

    	
    	return removeComments;
    }

    var generated = {};

    var hasRequiredGenerated;

    function requireGenerated () {
    	if (hasRequiredGenerated) return generated;
    	hasRequiredGenerated = 1;

    	Object.defineProperty(generated, "__esModule", {
    	  value: true
    	});
    	generated.WHILE_TYPES = generated.USERWHITESPACABLE_TYPES = generated.UNARYLIKE_TYPES = generated.TYPESCRIPT_TYPES = generated.TSTYPE_TYPES = generated.TSTYPEELEMENT_TYPES = generated.TSENTITYNAME_TYPES = generated.TSBASETYPE_TYPES = generated.TERMINATORLESS_TYPES = generated.STATEMENT_TYPES = generated.STANDARDIZED_TYPES = generated.SCOPABLE_TYPES = generated.PUREISH_TYPES = generated.PROPERTY_TYPES = generated.PRIVATE_TYPES = generated.PATTERN_TYPES = generated.PATTERNLIKE_TYPES = generated.OBJECTMEMBER_TYPES = generated.MODULESPECIFIER_TYPES = generated.MODULEDECLARATION_TYPES = generated.MISCELLANEOUS_TYPES = generated.METHOD_TYPES = generated.LVAL_TYPES = generated.LOOP_TYPES = generated.LITERAL_TYPES = generated.JSX_TYPES = generated.IMPORTOREXPORTDECLARATION_TYPES = generated.IMMUTABLE_TYPES = generated.FUNCTION_TYPES = generated.FUNCTIONPARENT_TYPES = generated.FOR_TYPES = generated.FORXSTATEMENT_TYPES = generated.FLOW_TYPES = generated.FLOWTYPE_TYPES = generated.FLOWPREDICATE_TYPES = generated.FLOWDECLARATION_TYPES = generated.FLOWBASEANNOTATION_TYPES = generated.EXPRESSION_TYPES = generated.EXPRESSIONWRAPPER_TYPES = generated.EXPORTDECLARATION_TYPES = generated.ENUMMEMBER_TYPES = generated.ENUMBODY_TYPES = generated.DECLARATION_TYPES = generated.CONDITIONAL_TYPES = generated.COMPLETIONSTATEMENT_TYPES = generated.CLASS_TYPES = generated.BLOCK_TYPES = generated.BLOCKPARENT_TYPES = generated.BINARY_TYPES = generated.ACCESSOR_TYPES = void 0;
    	var _index = requireDefinitions();
    	const STANDARDIZED_TYPES = _index.FLIPPED_ALIAS_KEYS["Standardized"];
    	generated.STANDARDIZED_TYPES = STANDARDIZED_TYPES;
    	const EXPRESSION_TYPES = _index.FLIPPED_ALIAS_KEYS["Expression"];
    	generated.EXPRESSION_TYPES = EXPRESSION_TYPES;
    	const BINARY_TYPES = _index.FLIPPED_ALIAS_KEYS["Binary"];
    	generated.BINARY_TYPES = BINARY_TYPES;
    	const SCOPABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Scopable"];
    	generated.SCOPABLE_TYPES = SCOPABLE_TYPES;
    	const BLOCKPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["BlockParent"];
    	generated.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
    	const BLOCK_TYPES = _index.FLIPPED_ALIAS_KEYS["Block"];
    	generated.BLOCK_TYPES = BLOCK_TYPES;
    	const STATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["Statement"];
    	generated.STATEMENT_TYPES = STATEMENT_TYPES;
    	const TERMINATORLESS_TYPES = _index.FLIPPED_ALIAS_KEYS["Terminatorless"];
    	generated.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
    	const COMPLETIONSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["CompletionStatement"];
    	generated.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
    	const CONDITIONAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Conditional"];
    	generated.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
    	const LOOP_TYPES = _index.FLIPPED_ALIAS_KEYS["Loop"];
    	generated.LOOP_TYPES = LOOP_TYPES;
    	const WHILE_TYPES = _index.FLIPPED_ALIAS_KEYS["While"];
    	generated.WHILE_TYPES = WHILE_TYPES;
    	const EXPRESSIONWRAPPER_TYPES = _index.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
    	generated.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
    	const FOR_TYPES = _index.FLIPPED_ALIAS_KEYS["For"];
    	generated.FOR_TYPES = FOR_TYPES;
    	const FORXSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["ForXStatement"];
    	generated.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
    	const FUNCTION_TYPES = _index.FLIPPED_ALIAS_KEYS["Function"];
    	generated.FUNCTION_TYPES = FUNCTION_TYPES;
    	const FUNCTIONPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["FunctionParent"];
    	generated.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
    	const PUREISH_TYPES = _index.FLIPPED_ALIAS_KEYS["Pureish"];
    	generated.PUREISH_TYPES = PUREISH_TYPES;
    	const DECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["Declaration"];
    	generated.DECLARATION_TYPES = DECLARATION_TYPES;
    	const PATTERNLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["PatternLike"];
    	generated.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
    	const LVAL_TYPES = _index.FLIPPED_ALIAS_KEYS["LVal"];
    	generated.LVAL_TYPES = LVAL_TYPES;
    	const TSENTITYNAME_TYPES = _index.FLIPPED_ALIAS_KEYS["TSEntityName"];
    	generated.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
    	const LITERAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Literal"];
    	generated.LITERAL_TYPES = LITERAL_TYPES;
    	const IMMUTABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Immutable"];
    	generated.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
    	const USERWHITESPACABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
    	generated.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
    	const METHOD_TYPES = _index.FLIPPED_ALIAS_KEYS["Method"];
    	generated.METHOD_TYPES = METHOD_TYPES;
    	const OBJECTMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["ObjectMember"];
    	generated.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
    	const PROPERTY_TYPES = _index.FLIPPED_ALIAS_KEYS["Property"];
    	generated.PROPERTY_TYPES = PROPERTY_TYPES;
    	const UNARYLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["UnaryLike"];
    	generated.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
    	const PATTERN_TYPES = _index.FLIPPED_ALIAS_KEYS["Pattern"];
    	generated.PATTERN_TYPES = PATTERN_TYPES;
    	const CLASS_TYPES = _index.FLIPPED_ALIAS_KEYS["Class"];
    	generated.CLASS_TYPES = CLASS_TYPES;
    	const IMPORTOREXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ImportOrExportDeclaration"];
    	generated.IMPORTOREXPORTDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
    	const EXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
    	generated.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
    	const MODULESPECIFIER_TYPES = _index.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
    	generated.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
    	const ACCESSOR_TYPES = _index.FLIPPED_ALIAS_KEYS["Accessor"];
    	generated.ACCESSOR_TYPES = ACCESSOR_TYPES;
    	const PRIVATE_TYPES = _index.FLIPPED_ALIAS_KEYS["Private"];
    	generated.PRIVATE_TYPES = PRIVATE_TYPES;
    	const FLOW_TYPES = _index.FLIPPED_ALIAS_KEYS["Flow"];
    	generated.FLOW_TYPES = FLOW_TYPES;
    	const FLOWTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowType"];
    	generated.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
    	const FLOWBASEANNOTATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
    	generated.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
    	const FLOWDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
    	generated.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
    	const FLOWPREDICATE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowPredicate"];
    	generated.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
    	const ENUMBODY_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumBody"];
    	generated.ENUMBODY_TYPES = ENUMBODY_TYPES;
    	const ENUMMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumMember"];
    	generated.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;
    	const JSX_TYPES = _index.FLIPPED_ALIAS_KEYS["JSX"];
    	generated.JSX_TYPES = JSX_TYPES;
    	const MISCELLANEOUS_TYPES = _index.FLIPPED_ALIAS_KEYS["Miscellaneous"];
    	generated.MISCELLANEOUS_TYPES = MISCELLANEOUS_TYPES;
    	const TYPESCRIPT_TYPES = _index.FLIPPED_ALIAS_KEYS["TypeScript"];
    	generated.TYPESCRIPT_TYPES = TYPESCRIPT_TYPES;
    	const TSTYPEELEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["TSTypeElement"];
    	generated.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
    	const TSTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSType"];
    	generated.TSTYPE_TYPES = TSTYPE_TYPES;
    	const TSBASETYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSBaseType"];
    	generated.TSBASETYPE_TYPES = TSBASETYPE_TYPES;
    	const MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
    	generated.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;

    	
    	return generated;
    }

    var ensureBlock = {};

    var toBlock = {};

    var hasRequiredToBlock;

    function requireToBlock () {
    	if (hasRequiredToBlock) return toBlock;
    	hasRequiredToBlock = 1;

    	Object.defineProperty(toBlock, "__esModule", {
    	  value: true
    	});
    	toBlock.default = toBlock$1;
    	var _index = requireGenerated$3();
    	var _index2 = requireGenerated$2();
    	function toBlock$1(node, parent) {
    	  if ((0, _index.isBlockStatement)(node)) {
    	    return node;
    	  }
    	  let blockNodes = [];
    	  if ((0, _index.isEmptyStatement)(node)) {
    	    blockNodes = [];
    	  } else {
    	    if (!(0, _index.isStatement)(node)) {
    	      if ((0, _index.isFunction)(parent)) {
    	        node = (0, _index2.returnStatement)(node);
    	      } else {
    	        node = (0, _index2.expressionStatement)(node);
    	      }
    	    }
    	    blockNodes = [node];
    	  }
    	  return (0, _index2.blockStatement)(blockNodes);
    	}

    	
    	return toBlock;
    }

    var hasRequiredEnsureBlock;

    function requireEnsureBlock () {
    	if (hasRequiredEnsureBlock) return ensureBlock;
    	hasRequiredEnsureBlock = 1;

    	Object.defineProperty(ensureBlock, "__esModule", {
    	  value: true
    	});
    	ensureBlock.default = ensureBlock$1;
    	var _toBlock = requireToBlock();
    	function ensureBlock$1(node, key = "body") {
    	  const result = (0, _toBlock.default)(node[key], node);
    	  node[key] = result;
    	  return result;
    	}

    	
    	return ensureBlock;
    }

    var toBindingIdentifierName = {};

    var toIdentifier = {};

    var hasRequiredToIdentifier;

    function requireToIdentifier () {
    	if (hasRequiredToIdentifier) return toIdentifier;
    	hasRequiredToIdentifier = 1;

    	Object.defineProperty(toIdentifier, "__esModule", {
    	  value: true
    	});
    	toIdentifier.default = toIdentifier$1;
    	var _isValidIdentifier = requireIsValidIdentifier();
    	var _helperValidatorIdentifier = requireLib$4();
    	function toIdentifier$1(input) {
    	  input = input + "";
    	  let name = "";
    	  for (const c of input) {
    	    name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : "-";
    	  }
    	  name = name.replace(/^[-0-9]+/, "");
    	  name = name.replace(/[-\s]+(.)?/g, function (match, c) {
    	    return c ? c.toUpperCase() : "";
    	  });
    	  if (!(0, _isValidIdentifier.default)(name)) {
    	    name = `_${name}`;
    	  }
    	  return name || "_";
    	}

    	
    	return toIdentifier;
    }

    var hasRequiredToBindingIdentifierName;

    function requireToBindingIdentifierName () {
    	if (hasRequiredToBindingIdentifierName) return toBindingIdentifierName;
    	hasRequiredToBindingIdentifierName = 1;

    	Object.defineProperty(toBindingIdentifierName, "__esModule", {
    	  value: true
    	});
    	toBindingIdentifierName.default = toBindingIdentifierName$1;
    	var _toIdentifier = requireToIdentifier();
    	function toBindingIdentifierName$1(name) {
    	  name = (0, _toIdentifier.default)(name);
    	  if (name === "eval" || name === "arguments") name = "_" + name;
    	  return name;
    	}

    	
    	return toBindingIdentifierName;
    }

    var toComputedKey = {};

    var hasRequiredToComputedKey;

    function requireToComputedKey () {
    	if (hasRequiredToComputedKey) return toComputedKey;
    	hasRequiredToComputedKey = 1;

    	Object.defineProperty(toComputedKey, "__esModule", {
    	  value: true
    	});
    	toComputedKey.default = toComputedKey$1;
    	var _index = requireGenerated$3();
    	var _index2 = requireGenerated$2();
    	function toComputedKey$1(node, key = node.key || node.property) {
    	  if (!node.computed && (0, _index.isIdentifier)(key)) key = (0, _index2.stringLiteral)(key.name);
    	  return key;
    	}

    	
    	return toComputedKey;
    }

    var toExpression = {};

    var hasRequiredToExpression;

    function requireToExpression () {
    	if (hasRequiredToExpression) return toExpression;
    	hasRequiredToExpression = 1;

    	Object.defineProperty(toExpression, "__esModule", {
    	  value: true
    	});
    	toExpression.default = void 0;
    	var _index = requireGenerated$3();
    	var _default = toExpression$1;
    	toExpression.default = _default;
    	function toExpression$1(node) {
    	  if ((0, _index.isExpressionStatement)(node)) {
    	    node = node.expression;
    	  }
    	  if ((0, _index.isExpression)(node)) {
    	    return node;
    	  }
    	  if ((0, _index.isClass)(node)) {
    	    node.type = "ClassExpression";
    	  } else if ((0, _index.isFunction)(node)) {
    	    node.type = "FunctionExpression";
    	  }
    	  if (!(0, _index.isExpression)(node)) {
    	    throw new Error(`cannot turn ${node.type} to an expression`);
    	  }
    	  return node;
    	}

    	
    	return toExpression;
    }

    var toKeyAlias = {};

    var removePropertiesDeep = {};

    var traverseFast = {};

    var hasRequiredTraverseFast;

    function requireTraverseFast () {
    	if (hasRequiredTraverseFast) return traverseFast;
    	hasRequiredTraverseFast = 1;

    	Object.defineProperty(traverseFast, "__esModule", {
    	  value: true
    	});
    	traverseFast.default = traverseFast$1;
    	var _index = requireDefinitions();
    	function traverseFast$1(node, enter, opts) {
    	  if (!node) return;
    	  const keys = _index.VISITOR_KEYS[node.type];
    	  if (!keys) return;
    	  opts = opts || {};
    	  enter(node, opts);
    	  for (const key of keys) {
    	    const subNode = node[key];
    	    if (Array.isArray(subNode)) {
    	      for (const node of subNode) {
    	        traverseFast$1(node, enter, opts);
    	      }
    	    } else {
    	      traverseFast$1(subNode, enter, opts);
    	    }
    	  }
    	}

    	
    	return traverseFast;
    }

    var removeProperties = {};

    var hasRequiredRemoveProperties;

    function requireRemoveProperties () {
    	if (hasRequiredRemoveProperties) return removeProperties;
    	hasRequiredRemoveProperties = 1;

    	Object.defineProperty(removeProperties, "__esModule", {
    	  value: true
    	});
    	removeProperties.default = removeProperties$1;
    	var _index = requireConstants();
    	const CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
    	const CLEAR_KEYS_PLUS_COMMENTS = [..._index.COMMENT_KEYS, "comments", ...CLEAR_KEYS];
    	function removeProperties$1(node, opts = {}) {
    	  const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
    	  for (const key of map) {
    	    if (node[key] != null) node[key] = undefined;
    	  }
    	  for (const key of Object.keys(node)) {
    	    if (key[0] === "_" && node[key] != null) node[key] = undefined;
    	  }
    	  const symbols = Object.getOwnPropertySymbols(node);
    	  for (const sym of symbols) {
    	    node[sym] = null;
    	  }
    	}

    	
    	return removeProperties;
    }

    var hasRequiredRemovePropertiesDeep;

    function requireRemovePropertiesDeep () {
    	if (hasRequiredRemovePropertiesDeep) return removePropertiesDeep;
    	hasRequiredRemovePropertiesDeep = 1;

    	Object.defineProperty(removePropertiesDeep, "__esModule", {
    	  value: true
    	});
    	removePropertiesDeep.default = removePropertiesDeep$1;
    	var _traverseFast = requireTraverseFast();
    	var _removeProperties = requireRemoveProperties();
    	function removePropertiesDeep$1(tree, opts) {
    	  (0, _traverseFast.default)(tree, _removeProperties.default, opts);
    	  return tree;
    	}

    	
    	return removePropertiesDeep;
    }

    var hasRequiredToKeyAlias;

    function requireToKeyAlias () {
    	if (hasRequiredToKeyAlias) return toKeyAlias;
    	hasRequiredToKeyAlias = 1;

    	Object.defineProperty(toKeyAlias, "__esModule", {
    	  value: true
    	});
    	toKeyAlias.default = toKeyAlias$1;
    	var _index = requireGenerated$3();
    	var _cloneNode = requireCloneNode();
    	var _removePropertiesDeep = requireRemovePropertiesDeep();
    	function toKeyAlias$1(node, key = node.key) {
    	  let alias;
    	  if (node.kind === "method") {
    	    return toKeyAlias$1.increment() + "";
    	  } else if ((0, _index.isIdentifier)(key)) {
    	    alias = key.name;
    	  } else if ((0, _index.isStringLiteral)(key)) {
    	    alias = JSON.stringify(key.value);
    	  } else {
    	    alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
    	  }
    	  if (node.computed) {
    	    alias = `[${alias}]`;
    	  }
    	  if (node.static) {
    	    alias = `static:${alias}`;
    	  }
    	  return alias;
    	}
    	toKeyAlias$1.uid = 0;
    	toKeyAlias$1.increment = function () {
    	  if (toKeyAlias$1.uid >= Number.MAX_SAFE_INTEGER) {
    	    return toKeyAlias$1.uid = 0;
    	  } else {
    	    return toKeyAlias$1.uid++;
    	  }
    	};

    	
    	return toKeyAlias;
    }

    var toSequenceExpression = {};

    var gatherSequenceExpressions = {};

    var getBindingIdentifiers = {};

    var hasRequiredGetBindingIdentifiers;

    function requireGetBindingIdentifiers () {
    	if (hasRequiredGetBindingIdentifiers) return getBindingIdentifiers;
    	hasRequiredGetBindingIdentifiers = 1;

    	Object.defineProperty(getBindingIdentifiers, "__esModule", {
    	  value: true
    	});
    	getBindingIdentifiers.default = getBindingIdentifiers$1;
    	var _index = requireGenerated$3();
    	function getBindingIdentifiers$1(node, duplicates, outerOnly) {
    	  const search = [].concat(node);
    	  const ids = Object.create(null);
    	  while (search.length) {
    	    const id = search.shift();
    	    if (!id) continue;
    	    const keys = getBindingIdentifiers$1.keys[id.type];
    	    if ((0, _index.isIdentifier)(id)) {
    	      if (duplicates) {
    	        const _ids = ids[id.name] = ids[id.name] || [];
    	        _ids.push(id);
    	      } else {
    	        ids[id.name] = id;
    	      }
    	      continue;
    	    }
    	    if ((0, _index.isExportDeclaration)(id) && !(0, _index.isExportAllDeclaration)(id)) {
    	      if ((0, _index.isDeclaration)(id.declaration)) {
    	        search.push(id.declaration);
    	      }
    	      continue;
    	    }
    	    if (outerOnly) {
    	      if ((0, _index.isFunctionDeclaration)(id)) {
    	        search.push(id.id);
    	        continue;
    	      }
    	      if ((0, _index.isFunctionExpression)(id)) {
    	        continue;
    	      }
    	    }
    	    if (keys) {
    	      for (let i = 0; i < keys.length; i++) {
    	        const key = keys[i];
    	        const nodes = id[key];
    	        if (nodes) {
    	          Array.isArray(nodes) ? search.push(...nodes) : search.push(nodes);
    	        }
    	      }
    	    }
    	  }
    	  return ids;
    	}
    	getBindingIdentifiers$1.keys = {
    	  DeclareClass: ["id"],
    	  DeclareFunction: ["id"],
    	  DeclareModule: ["id"],
    	  DeclareVariable: ["id"],
    	  DeclareInterface: ["id"],
    	  DeclareTypeAlias: ["id"],
    	  DeclareOpaqueType: ["id"],
    	  InterfaceDeclaration: ["id"],
    	  TypeAlias: ["id"],
    	  OpaqueType: ["id"],
    	  CatchClause: ["param"],
    	  LabeledStatement: ["label"],
    	  UnaryExpression: ["argument"],
    	  AssignmentExpression: ["left"],
    	  ImportSpecifier: ["local"],
    	  ImportNamespaceSpecifier: ["local"],
    	  ImportDefaultSpecifier: ["local"],
    	  ImportDeclaration: ["specifiers"],
    	  ExportSpecifier: ["exported"],
    	  ExportNamespaceSpecifier: ["exported"],
    	  ExportDefaultSpecifier: ["exported"],
    	  FunctionDeclaration: ["id", "params"],
    	  FunctionExpression: ["id", "params"],
    	  ArrowFunctionExpression: ["params"],
    	  ObjectMethod: ["params"],
    	  ClassMethod: ["params"],
    	  ClassPrivateMethod: ["params"],
    	  ForInStatement: ["left"],
    	  ForOfStatement: ["left"],
    	  ClassDeclaration: ["id"],
    	  ClassExpression: ["id"],
    	  RestElement: ["argument"],
    	  UpdateExpression: ["argument"],
    	  ObjectProperty: ["value"],
    	  AssignmentPattern: ["left"],
    	  ArrayPattern: ["elements"],
    	  ObjectPattern: ["properties"],
    	  VariableDeclaration: ["declarations"],
    	  VariableDeclarator: ["id"]
    	};

    	
    	return getBindingIdentifiers;
    }

    var hasRequiredGatherSequenceExpressions;

    function requireGatherSequenceExpressions () {
    	if (hasRequiredGatherSequenceExpressions) return gatherSequenceExpressions;
    	hasRequiredGatherSequenceExpressions = 1;

    	Object.defineProperty(gatherSequenceExpressions, "__esModule", {
    	  value: true
    	});
    	gatherSequenceExpressions.default = gatherSequenceExpressions$1;
    	var _getBindingIdentifiers = requireGetBindingIdentifiers();
    	var _index = requireGenerated$3();
    	var _index2 = requireGenerated$2();
    	var _cloneNode = requireCloneNode();
    	function gatherSequenceExpressions$1(nodes, scope, declars) {
    	  const exprs = [];
    	  let ensureLastUndefined = true;
    	  for (const node of nodes) {
    	    if (!(0, _index.isEmptyStatement)(node)) {
    	      ensureLastUndefined = false;
    	    }
    	    if ((0, _index.isExpression)(node)) {
    	      exprs.push(node);
    	    } else if ((0, _index.isExpressionStatement)(node)) {
    	      exprs.push(node.expression);
    	    } else if ((0, _index.isVariableDeclaration)(node)) {
    	      if (node.kind !== "var") return;
    	      for (const declar of node.declarations) {
    	        const bindings = (0, _getBindingIdentifiers.default)(declar);
    	        for (const key of Object.keys(bindings)) {
    	          declars.push({
    	            kind: node.kind,
    	            id: (0, _cloneNode.default)(bindings[key])
    	          });
    	        }
    	        if (declar.init) {
    	          exprs.push((0, _index2.assignmentExpression)("=", declar.id, declar.init));
    	        }
    	      }
    	      ensureLastUndefined = true;
    	    } else if ((0, _index.isIfStatement)(node)) {
    	      const consequent = node.consequent ? gatherSequenceExpressions$1([node.consequent], scope, declars) : scope.buildUndefinedNode();
    	      const alternate = node.alternate ? gatherSequenceExpressions$1([node.alternate], scope, declars) : scope.buildUndefinedNode();
    	      if (!consequent || !alternate) return;
    	      exprs.push((0, _index2.conditionalExpression)(node.test, consequent, alternate));
    	    } else if ((0, _index.isBlockStatement)(node)) {
    	      const body = gatherSequenceExpressions$1(node.body, scope, declars);
    	      if (!body) return;
    	      exprs.push(body);
    	    } else if ((0, _index.isEmptyStatement)(node)) {
    	      if (nodes.indexOf(node) === 0) {
    	        ensureLastUndefined = true;
    	      }
    	    } else {
    	      return;
    	    }
    	  }
    	  if (ensureLastUndefined) {
    	    exprs.push(scope.buildUndefinedNode());
    	  }
    	  if (exprs.length === 1) {
    	    return exprs[0];
    	  } else {
    	    return (0, _index2.sequenceExpression)(exprs);
    	  }
    	}

    	
    	return gatherSequenceExpressions;
    }

    var hasRequiredToSequenceExpression;

    function requireToSequenceExpression () {
    	if (hasRequiredToSequenceExpression) return toSequenceExpression;
    	hasRequiredToSequenceExpression = 1;

    	Object.defineProperty(toSequenceExpression, "__esModule", {
    	  value: true
    	});
    	toSequenceExpression.default = toSequenceExpression$1;
    	var _gatherSequenceExpressions = requireGatherSequenceExpressions();
    	function toSequenceExpression$1(nodes, scope) {
    	  if (!(nodes != null && nodes.length)) return;
    	  const declars = [];
    	  const result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
    	  if (!result) return;
    	  for (const declar of declars) {
    	    scope.push(declar);
    	  }
    	  return result;
    	}

    	
    	return toSequenceExpression;
    }

    var toStatement = {};

    var hasRequiredToStatement;

    function requireToStatement () {
    	if (hasRequiredToStatement) return toStatement;
    	hasRequiredToStatement = 1;

    	Object.defineProperty(toStatement, "__esModule", {
    	  value: true
    	});
    	toStatement.default = void 0;
    	var _index = requireGenerated$3();
    	var _index2 = requireGenerated$2();
    	var _default = toStatement$1;
    	toStatement.default = _default;
    	function toStatement$1(node, ignore) {
    	  if ((0, _index.isStatement)(node)) {
    	    return node;
    	  }
    	  let mustHaveId = false;
    	  let newType;
    	  if ((0, _index.isClass)(node)) {
    	    mustHaveId = true;
    	    newType = "ClassDeclaration";
    	  } else if ((0, _index.isFunction)(node)) {
    	    mustHaveId = true;
    	    newType = "FunctionDeclaration";
    	  } else if ((0, _index.isAssignmentExpression)(node)) {
    	    return (0, _index2.expressionStatement)(node);
    	  }
    	  if (mustHaveId && !node.id) {
    	    newType = false;
    	  }
    	  if (!newType) {
    	    if (ignore) {
    	      return false;
    	    } else {
    	      throw new Error(`cannot turn ${node.type} to a statement`);
    	    }
    	  }
    	  node.type = newType;
    	  return node;
    	}

    	
    	return toStatement;
    }

    var valueToNode = {};

    var hasRequiredValueToNode;

    function requireValueToNode () {
    	if (hasRequiredValueToNode) return valueToNode;
    	hasRequiredValueToNode = 1;

    	Object.defineProperty(valueToNode, "__esModule", {
    	  value: true
    	});
    	valueToNode.default = void 0;
    	var _isValidIdentifier = requireIsValidIdentifier();
    	var _index = requireGenerated$2();
    	var _default = valueToNode$1;
    	valueToNode.default = _default;
    	const objectToString = Function.call.bind(Object.prototype.toString);
    	function isRegExp(value) {
    	  return objectToString(value) === "[object RegExp]";
    	}
    	function isPlainObject(value) {
    	  if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") {
    	    return false;
    	  }
    	  const proto = Object.getPrototypeOf(value);
    	  return proto === null || Object.getPrototypeOf(proto) === null;
    	}
    	function valueToNode$1(value) {
    	  if (value === undefined) {
    	    return (0, _index.identifier)("undefined");
    	  }
    	  if (value === true || value === false) {
    	    return (0, _index.booleanLiteral)(value);
    	  }
    	  if (value === null) {
    	    return (0, _index.nullLiteral)();
    	  }
    	  if (typeof value === "string") {
    	    return (0, _index.stringLiteral)(value);
    	  }
    	  if (typeof value === "number") {
    	    let result;
    	    if (Number.isFinite(value)) {
    	      result = (0, _index.numericLiteral)(Math.abs(value));
    	    } else {
    	      let numerator;
    	      if (Number.isNaN(value)) {
    	        numerator = (0, _index.numericLiteral)(0);
    	      } else {
    	        numerator = (0, _index.numericLiteral)(1);
    	      }
    	      result = (0, _index.binaryExpression)("/", numerator, (0, _index.numericLiteral)(0));
    	    }
    	    if (value < 0 || Object.is(value, -0)) {
    	      result = (0, _index.unaryExpression)("-", result);
    	    }
    	    return result;
    	  }
    	  if (isRegExp(value)) {
    	    const pattern = value.source;
    	    const flags = value.toString().match(/\/([a-z]+|)$/)[1];
    	    return (0, _index.regExpLiteral)(pattern, flags);
    	  }
    	  if (Array.isArray(value)) {
    	    return (0, _index.arrayExpression)(value.map(valueToNode$1));
    	  }
    	  if (isPlainObject(value)) {
    	    const props = [];
    	    for (const key of Object.keys(value)) {
    	      let nodeKey;
    	      if ((0, _isValidIdentifier.default)(key)) {
    	        nodeKey = (0, _index.identifier)(key);
    	      } else {
    	        nodeKey = (0, _index.stringLiteral)(key);
    	      }
    	      props.push((0, _index.objectProperty)(nodeKey, valueToNode$1(value[key])));
    	    }
    	    return (0, _index.objectExpression)(props);
    	  }
    	  throw new Error("don't know how to turn this value into a node");
    	}

    	
    	return valueToNode;
    }

    var appendToMemberExpression = {};

    var hasRequiredAppendToMemberExpression;

    function requireAppendToMemberExpression () {
    	if (hasRequiredAppendToMemberExpression) return appendToMemberExpression;
    	hasRequiredAppendToMemberExpression = 1;

    	Object.defineProperty(appendToMemberExpression, "__esModule", {
    	  value: true
    	});
    	appendToMemberExpression.default = appendToMemberExpression$1;
    	var _index = requireGenerated$2();
    	function appendToMemberExpression$1(member, append, computed = false) {
    	  member.object = (0, _index.memberExpression)(member.object, member.property, member.computed);
    	  member.property = append;
    	  member.computed = !!computed;
    	  return member;
    	}

    	
    	return appendToMemberExpression;
    }

    var inherits = {};

    var hasRequiredInherits;

    function requireInherits () {
    	if (hasRequiredInherits) return inherits;
    	hasRequiredInherits = 1;

    	Object.defineProperty(inherits, "__esModule", {
    	  value: true
    	});
    	inherits.default = inherits$1;
    	var _index = requireConstants();
    	var _inheritsComments = requireInheritsComments();
    	function inherits$1(child, parent) {
    	  if (!child || !parent) return child;
    	  for (const key of _index.INHERIT_KEYS.optional) {
    	    if (child[key] == null) {
    	      child[key] = parent[key];
    	    }
    	  }
    	  for (const key of Object.keys(parent)) {
    	    if (key[0] === "_" && key !== "__clone") {
    	      child[key] = parent[key];
    	    }
    	  }
    	  for (const key of _index.INHERIT_KEYS.force) {
    	    child[key] = parent[key];
    	  }
    	  (0, _inheritsComments.default)(child, parent);
    	  return child;
    	}

    	
    	return inherits;
    }

    var prependToMemberExpression = {};

    var hasRequiredPrependToMemberExpression;

    function requirePrependToMemberExpression () {
    	if (hasRequiredPrependToMemberExpression) return prependToMemberExpression;
    	hasRequiredPrependToMemberExpression = 1;

    	Object.defineProperty(prependToMemberExpression, "__esModule", {
    	  value: true
    	});
    	prependToMemberExpression.default = prependToMemberExpression$1;
    	var _index = requireGenerated$2();
    	var _index2 = requireLib$2();
    	function prependToMemberExpression$1(member, prepend) {
    	  if ((0, _index2.isSuper)(member.object)) {
    	    throw new Error("Cannot prepend node to super property access (`super.foo`).");
    	  }
    	  member.object = (0, _index.memberExpression)(prepend, member.object);
    	  return member;
    	}

    	
    	return prependToMemberExpression;
    }

    var getOuterBindingIdentifiers = {};

    var hasRequiredGetOuterBindingIdentifiers;

    function requireGetOuterBindingIdentifiers () {
    	if (hasRequiredGetOuterBindingIdentifiers) return getOuterBindingIdentifiers;
    	hasRequiredGetOuterBindingIdentifiers = 1;

    	Object.defineProperty(getOuterBindingIdentifiers, "__esModule", {
    	  value: true
    	});
    	getOuterBindingIdentifiers.default = void 0;
    	var _getBindingIdentifiers = requireGetBindingIdentifiers();
    	var _default = getOuterBindingIdentifiers$1;
    	getOuterBindingIdentifiers.default = _default;
    	function getOuterBindingIdentifiers$1(node, duplicates) {
    	  return (0, _getBindingIdentifiers.default)(node, duplicates, true);
    	}

    	
    	return getOuterBindingIdentifiers;
    }

    var traverse = {};

    var hasRequiredTraverse;

    function requireTraverse () {
    	if (hasRequiredTraverse) return traverse;
    	hasRequiredTraverse = 1;

    	Object.defineProperty(traverse, "__esModule", {
    	  value: true
    	});
    	traverse.default = traverse$1;
    	var _index = requireDefinitions();
    	function traverse$1(node, handlers, state) {
    	  if (typeof handlers === "function") {
    	    handlers = {
    	      enter: handlers
    	    };
    	  }
    	  const {
    	    enter,
    	    exit
    	  } = handlers;
    	  traverseSimpleImpl(node, enter, exit, state, []);
    	}
    	function traverseSimpleImpl(node, enter, exit, state, ancestors) {
    	  const keys = _index.VISITOR_KEYS[node.type];
    	  if (!keys) return;
    	  if (enter) enter(node, ancestors, state);
    	  for (const key of keys) {
    	    const subNode = node[key];
    	    if (Array.isArray(subNode)) {
    	      for (let i = 0; i < subNode.length; i++) {
    	        const child = subNode[i];
    	        if (!child) continue;
    	        ancestors.push({
    	          node,
    	          key,
    	          index: i
    	        });
    	        traverseSimpleImpl(child, enter, exit, state, ancestors);
    	        ancestors.pop();
    	      }
    	    } else if (subNode) {
    	      ancestors.push({
    	        node,
    	        key
    	      });
    	      traverseSimpleImpl(subNode, enter, exit, state, ancestors);
    	      ancestors.pop();
    	    }
    	  }
    	  if (exit) exit(node, ancestors, state);
    	}

    	
    	return traverse;
    }

    var isBinding = {};

    var hasRequiredIsBinding;

    function requireIsBinding () {
    	if (hasRequiredIsBinding) return isBinding;
    	hasRequiredIsBinding = 1;

    	Object.defineProperty(isBinding, "__esModule", {
    	  value: true
    	});
    	isBinding.default = isBinding$1;
    	var _getBindingIdentifiers = requireGetBindingIdentifiers();
    	function isBinding$1(node, parent, grandparent) {
    	  if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
    	    return false;
    	  }
    	  const keys = _getBindingIdentifiers.default.keys[parent.type];
    	  if (keys) {
    	    for (let i = 0; i < keys.length; i++) {
    	      const key = keys[i];
    	      const val = parent[key];
    	      if (Array.isArray(val)) {
    	        if (val.indexOf(node) >= 0) return true;
    	      } else {
    	        if (val === node) return true;
    	      }
    	    }
    	  }
    	  return false;
    	}

    	
    	return isBinding;
    }

    var isBlockScoped = {};

    var isLet = {};

    var hasRequiredIsLet;

    function requireIsLet () {
    	if (hasRequiredIsLet) return isLet;
    	hasRequiredIsLet = 1;

    	Object.defineProperty(isLet, "__esModule", {
    	  value: true
    	});
    	isLet.default = isLet$1;
    	var _index = requireGenerated$3();
    	var _index2 = requireConstants();
    	function isLet$1(node) {
    	  return (0, _index.isVariableDeclaration)(node) && (node.kind !== "var" || node[_index2.BLOCK_SCOPED_SYMBOL]);
    	}

    	
    	return isLet;
    }

    var hasRequiredIsBlockScoped;

    function requireIsBlockScoped () {
    	if (hasRequiredIsBlockScoped) return isBlockScoped;
    	hasRequiredIsBlockScoped = 1;

    	Object.defineProperty(isBlockScoped, "__esModule", {
    	  value: true
    	});
    	isBlockScoped.default = isBlockScoped$1;
    	var _index = requireGenerated$3();
    	var _isLet = requireIsLet();
    	function isBlockScoped$1(node) {
    	  return (0, _index.isFunctionDeclaration)(node) || (0, _index.isClassDeclaration)(node) || (0, _isLet.default)(node);
    	}

    	
    	return isBlockScoped;
    }

    var isImmutable = {};

    var hasRequiredIsImmutable;

    function requireIsImmutable () {
    	if (hasRequiredIsImmutable) return isImmutable;
    	hasRequiredIsImmutable = 1;

    	Object.defineProperty(isImmutable, "__esModule", {
    	  value: true
    	});
    	isImmutable.default = isImmutable$1;
    	var _isType = requireIsType();
    	var _index = requireGenerated$3();
    	function isImmutable$1(node) {
    	  if ((0, _isType.default)(node.type, "Immutable")) return true;
    	  if ((0, _index.isIdentifier)(node)) {
    	    if (node.name === "undefined") {
    	      return true;
    	    } else {
    	      return false;
    	    }
    	  }
    	  return false;
    	}

    	
    	return isImmutable;
    }

    var isNodesEquivalent = {};

    var hasRequiredIsNodesEquivalent;

    function requireIsNodesEquivalent () {
    	if (hasRequiredIsNodesEquivalent) return isNodesEquivalent;
    	hasRequiredIsNodesEquivalent = 1;

    	Object.defineProperty(isNodesEquivalent, "__esModule", {
    	  value: true
    	});
    	isNodesEquivalent.default = isNodesEquivalent$1;
    	var _index = requireDefinitions();
    	function isNodesEquivalent$1(a, b) {
    	  if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
    	    return a === b;
    	  }
    	  if (a.type !== b.type) {
    	    return false;
    	  }
    	  const fields = Object.keys(_index.NODE_FIELDS[a.type] || a.type);
    	  const visitorKeys = _index.VISITOR_KEYS[a.type];
    	  for (const field of fields) {
    	    const val_a = a[field];
    	    const val_b = b[field];
    	    if (typeof val_a !== typeof val_b) {
    	      return false;
    	    }
    	    if (val_a == null && val_b == null) {
    	      continue;
    	    } else if (val_a == null || val_b == null) {
    	      return false;
    	    }
    	    if (Array.isArray(val_a)) {
    	      if (!Array.isArray(val_b)) {
    	        return false;
    	      }
    	      if (val_a.length !== val_b.length) {
    	        return false;
    	      }
    	      for (let i = 0; i < val_a.length; i++) {
    	        if (!isNodesEquivalent$1(val_a[i], val_b[i])) {
    	          return false;
    	        }
    	      }
    	      continue;
    	    }
    	    if (typeof val_a === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
    	      for (const key of Object.keys(val_a)) {
    	        if (val_a[key] !== val_b[key]) {
    	          return false;
    	        }
    	      }
    	      continue;
    	    }
    	    if (!isNodesEquivalent$1(val_a, val_b)) {
    	      return false;
    	    }
    	  }
    	  return true;
    	}

    	
    	return isNodesEquivalent;
    }

    var isReferenced = {};

    var hasRequiredIsReferenced;

    function requireIsReferenced () {
    	if (hasRequiredIsReferenced) return isReferenced;
    	hasRequiredIsReferenced = 1;

    	Object.defineProperty(isReferenced, "__esModule", {
    	  value: true
    	});
    	isReferenced.default = isReferenced$1;
    	function isReferenced$1(node, parent, grandparent) {
    	  switch (parent.type) {
    	    case "MemberExpression":
    	    case "OptionalMemberExpression":
    	      if (parent.property === node) {
    	        return !!parent.computed;
    	      }
    	      return parent.object === node;
    	    case "JSXMemberExpression":
    	      return parent.object === node;
    	    case "VariableDeclarator":
    	      return parent.init === node;
    	    case "ArrowFunctionExpression":
    	      return parent.body === node;
    	    case "PrivateName":
    	      return false;
    	    case "ClassMethod":
    	    case "ClassPrivateMethod":
    	    case "ObjectMethod":
    	      if (parent.key === node) {
    	        return !!parent.computed;
    	      }
    	      return false;
    	    case "ObjectProperty":
    	      if (parent.key === node) {
    	        return !!parent.computed;
    	      }
    	      return !grandparent || grandparent.type !== "ObjectPattern";
    	    case "ClassProperty":
    	    case "ClassAccessorProperty":
    	      if (parent.key === node) {
    	        return !!parent.computed;
    	      }
    	      return true;
    	    case "ClassPrivateProperty":
    	      return parent.key !== node;
    	    case "ClassDeclaration":
    	    case "ClassExpression":
    	      return parent.superClass === node;
    	    case "AssignmentExpression":
    	      return parent.right === node;
    	    case "AssignmentPattern":
    	      return parent.right === node;
    	    case "LabeledStatement":
    	      return false;
    	    case "CatchClause":
    	      return false;
    	    case "RestElement":
    	      return false;
    	    case "BreakStatement":
    	    case "ContinueStatement":
    	      return false;
    	    case "FunctionDeclaration":
    	    case "FunctionExpression":
    	      return false;
    	    case "ExportNamespaceSpecifier":
    	    case "ExportDefaultSpecifier":
    	      return false;
    	    case "ExportSpecifier":
    	      if (grandparent != null && grandparent.source) {
    	        return false;
    	      }
    	      return parent.local === node;
    	    case "ImportDefaultSpecifier":
    	    case "ImportNamespaceSpecifier":
    	    case "ImportSpecifier":
    	      return false;
    	    case "ImportAttribute":
    	      return false;
    	    case "JSXAttribute":
    	      return false;
    	    case "ObjectPattern":
    	    case "ArrayPattern":
    	      return false;
    	    case "MetaProperty":
    	      return false;
    	    case "ObjectTypeProperty":
    	      return parent.key !== node;
    	    case "TSEnumMember":
    	      return parent.id !== node;
    	    case "TSPropertySignature":
    	      if (parent.key === node) {
    	        return !!parent.computed;
    	      }
    	      return true;
    	  }
    	  return true;
    	}

    	
    	return isReferenced;
    }

    var isScope = {};

    var hasRequiredIsScope;

    function requireIsScope () {
    	if (hasRequiredIsScope) return isScope;
    	hasRequiredIsScope = 1;

    	Object.defineProperty(isScope, "__esModule", {
    	  value: true
    	});
    	isScope.default = isScope$1;
    	var _index = requireGenerated$3();
    	function isScope$1(node, parent) {
    	  if ((0, _index.isBlockStatement)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
    	    return false;
    	  }
    	  if ((0, _index.isPattern)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
    	    return true;
    	  }
    	  return (0, _index.isScopable)(node);
    	}

    	
    	return isScope;
    }

    var isSpecifierDefault = {};

    var hasRequiredIsSpecifierDefault;

    function requireIsSpecifierDefault () {
    	if (hasRequiredIsSpecifierDefault) return isSpecifierDefault;
    	hasRequiredIsSpecifierDefault = 1;

    	Object.defineProperty(isSpecifierDefault, "__esModule", {
    	  value: true
    	});
    	isSpecifierDefault.default = isSpecifierDefault$1;
    	var _index = requireGenerated$3();
    	function isSpecifierDefault$1(specifier) {
    	  return (0, _index.isImportDefaultSpecifier)(specifier) || (0, _index.isIdentifier)(specifier.imported || specifier.exported, {
    	    name: "default"
    	  });
    	}

    	
    	return isSpecifierDefault;
    }

    var isValidES3Identifier = {};

    var hasRequiredIsValidES3Identifier;

    function requireIsValidES3Identifier () {
    	if (hasRequiredIsValidES3Identifier) return isValidES3Identifier;
    	hasRequiredIsValidES3Identifier = 1;

    	Object.defineProperty(isValidES3Identifier, "__esModule", {
    	  value: true
    	});
    	isValidES3Identifier.default = isValidES3Identifier$1;
    	var _isValidIdentifier = requireIsValidIdentifier();
    	const RESERVED_WORDS_ES3_ONLY = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
    	function isValidES3Identifier$1(name) {
    	  return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
    	}

    	
    	return isValidES3Identifier;
    }

    var isVar = {};

    var hasRequiredIsVar;

    function requireIsVar () {
    	if (hasRequiredIsVar) return isVar;
    	hasRequiredIsVar = 1;

    	Object.defineProperty(isVar, "__esModule", {
    	  value: true
    	});
    	isVar.default = isVar$1;
    	var _index = requireGenerated$3();
    	var _index2 = requireConstants();
    	function isVar$1(node) {
    	  return (0, _index.isVariableDeclaration)(node, {
    	    kind: "var"
    	  }) && !node[_index2.BLOCK_SCOPED_SYMBOL];
    	}

    	
    	return isVar;
    }

    var hasRequiredLib$2;

    function requireLib$2 () {
    	if (hasRequiredLib$2) return lib$4;
    	hasRequiredLib$2 = 1;
    	(function (exports) {

    		Object.defineProperty(exports, "__esModule", {
    		  value: true
    		});
    		var _exportNames = {
    		  react: true,
    		  assertNode: true,
    		  createTypeAnnotationBasedOnTypeof: true,
    		  createUnionTypeAnnotation: true,
    		  createFlowUnionType: true,
    		  createTSUnionType: true,
    		  cloneNode: true,
    		  clone: true,
    		  cloneDeep: true,
    		  cloneDeepWithoutLoc: true,
    		  cloneWithoutLoc: true,
    		  addComment: true,
    		  addComments: true,
    		  inheritInnerComments: true,
    		  inheritLeadingComments: true,
    		  inheritsComments: true,
    		  inheritTrailingComments: true,
    		  removeComments: true,
    		  ensureBlock: true,
    		  toBindingIdentifierName: true,
    		  toBlock: true,
    		  toComputedKey: true,
    		  toExpression: true,
    		  toIdentifier: true,
    		  toKeyAlias: true,
    		  toSequenceExpression: true,
    		  toStatement: true,
    		  valueToNode: true,
    		  appendToMemberExpression: true,
    		  inherits: true,
    		  prependToMemberExpression: true,
    		  removeProperties: true,
    		  removePropertiesDeep: true,
    		  removeTypeDuplicates: true,
    		  getBindingIdentifiers: true,
    		  getOuterBindingIdentifiers: true,
    		  traverse: true,
    		  traverseFast: true,
    		  shallowEqual: true,
    		  is: true,
    		  isBinding: true,
    		  isBlockScoped: true,
    		  isImmutable: true,
    		  isLet: true,
    		  isNode: true,
    		  isNodesEquivalent: true,
    		  isPlaceholderType: true,
    		  isReferenced: true,
    		  isScope: true,
    		  isSpecifierDefault: true,
    		  isType: true,
    		  isValidES3Identifier: true,
    		  isValidIdentifier: true,
    		  isVar: true,
    		  matchesPattern: true,
    		  validate: true,
    		  buildMatchMemberExpression: true,
    		  __internal__deprecationWarning: true
    		};
    		Object.defineProperty(exports, "__internal__deprecationWarning", {
    		  enumerable: true,
    		  get: function () {
    		    return _deprecationWarning.default;
    		  }
    		});
    		Object.defineProperty(exports, "addComment", {
    		  enumerable: true,
    		  get: function () {
    		    return _addComment.default;
    		  }
    		});
    		Object.defineProperty(exports, "addComments", {
    		  enumerable: true,
    		  get: function () {
    		    return _addComments.default;
    		  }
    		});
    		Object.defineProperty(exports, "appendToMemberExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _appendToMemberExpression.default;
    		  }
    		});
    		Object.defineProperty(exports, "assertNode", {
    		  enumerable: true,
    		  get: function () {
    		    return _assertNode.default;
    		  }
    		});
    		Object.defineProperty(exports, "buildMatchMemberExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _buildMatchMemberExpression.default;
    		  }
    		});
    		Object.defineProperty(exports, "clone", {
    		  enumerable: true,
    		  get: function () {
    		    return _clone.default;
    		  }
    		});
    		Object.defineProperty(exports, "cloneDeep", {
    		  enumerable: true,
    		  get: function () {
    		    return _cloneDeep.default;
    		  }
    		});
    		Object.defineProperty(exports, "cloneDeepWithoutLoc", {
    		  enumerable: true,
    		  get: function () {
    		    return _cloneDeepWithoutLoc.default;
    		  }
    		});
    		Object.defineProperty(exports, "cloneNode", {
    		  enumerable: true,
    		  get: function () {
    		    return _cloneNode.default;
    		  }
    		});
    		Object.defineProperty(exports, "cloneWithoutLoc", {
    		  enumerable: true,
    		  get: function () {
    		    return _cloneWithoutLoc.default;
    		  }
    		});
    		Object.defineProperty(exports, "createFlowUnionType", {
    		  enumerable: true,
    		  get: function () {
    		    return _createFlowUnionType.default;
    		  }
    		});
    		Object.defineProperty(exports, "createTSUnionType", {
    		  enumerable: true,
    		  get: function () {
    		    return _createTSUnionType.default;
    		  }
    		});
    		Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
    		  enumerable: true,
    		  get: function () {
    		    return _createTypeAnnotationBasedOnTypeof.default;
    		  }
    		});
    		Object.defineProperty(exports, "createUnionTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _createFlowUnionType.default;
    		  }
    		});
    		Object.defineProperty(exports, "ensureBlock", {
    		  enumerable: true,
    		  get: function () {
    		    return _ensureBlock.default;
    		  }
    		});
    		Object.defineProperty(exports, "getBindingIdentifiers", {
    		  enumerable: true,
    		  get: function () {
    		    return _getBindingIdentifiers.default;
    		  }
    		});
    		Object.defineProperty(exports, "getOuterBindingIdentifiers", {
    		  enumerable: true,
    		  get: function () {
    		    return _getOuterBindingIdentifiers.default;
    		  }
    		});
    		Object.defineProperty(exports, "inheritInnerComments", {
    		  enumerable: true,
    		  get: function () {
    		    return _inheritInnerComments.default;
    		  }
    		});
    		Object.defineProperty(exports, "inheritLeadingComments", {
    		  enumerable: true,
    		  get: function () {
    		    return _inheritLeadingComments.default;
    		  }
    		});
    		Object.defineProperty(exports, "inheritTrailingComments", {
    		  enumerable: true,
    		  get: function () {
    		    return _inheritTrailingComments.default;
    		  }
    		});
    		Object.defineProperty(exports, "inherits", {
    		  enumerable: true,
    		  get: function () {
    		    return _inherits.default;
    		  }
    		});
    		Object.defineProperty(exports, "inheritsComments", {
    		  enumerable: true,
    		  get: function () {
    		    return _inheritsComments.default;
    		  }
    		});
    		Object.defineProperty(exports, "is", {
    		  enumerable: true,
    		  get: function () {
    		    return _is.default;
    		  }
    		});
    		Object.defineProperty(exports, "isBinding", {
    		  enumerable: true,
    		  get: function () {
    		    return _isBinding.default;
    		  }
    		});
    		Object.defineProperty(exports, "isBlockScoped", {
    		  enumerable: true,
    		  get: function () {
    		    return _isBlockScoped.default;
    		  }
    		});
    		Object.defineProperty(exports, "isImmutable", {
    		  enumerable: true,
    		  get: function () {
    		    return _isImmutable.default;
    		  }
    		});
    		Object.defineProperty(exports, "isLet", {
    		  enumerable: true,
    		  get: function () {
    		    return _isLet.default;
    		  }
    		});
    		Object.defineProperty(exports, "isNode", {
    		  enumerable: true,
    		  get: function () {
    		    return _isNode.default;
    		  }
    		});
    		Object.defineProperty(exports, "isNodesEquivalent", {
    		  enumerable: true,
    		  get: function () {
    		    return _isNodesEquivalent.default;
    		  }
    		});
    		Object.defineProperty(exports, "isPlaceholderType", {
    		  enumerable: true,
    		  get: function () {
    		    return _isPlaceholderType.default;
    		  }
    		});
    		Object.defineProperty(exports, "isReferenced", {
    		  enumerable: true,
    		  get: function () {
    		    return _isReferenced.default;
    		  }
    		});
    		Object.defineProperty(exports, "isScope", {
    		  enumerable: true,
    		  get: function () {
    		    return _isScope.default;
    		  }
    		});
    		Object.defineProperty(exports, "isSpecifierDefault", {
    		  enumerable: true,
    		  get: function () {
    		    return _isSpecifierDefault.default;
    		  }
    		});
    		Object.defineProperty(exports, "isType", {
    		  enumerable: true,
    		  get: function () {
    		    return _isType.default;
    		  }
    		});
    		Object.defineProperty(exports, "isValidES3Identifier", {
    		  enumerable: true,
    		  get: function () {
    		    return _isValidES3Identifier.default;
    		  }
    		});
    		Object.defineProperty(exports, "isValidIdentifier", {
    		  enumerable: true,
    		  get: function () {
    		    return _isValidIdentifier.default;
    		  }
    		});
    		Object.defineProperty(exports, "isVar", {
    		  enumerable: true,
    		  get: function () {
    		    return _isVar.default;
    		  }
    		});
    		Object.defineProperty(exports, "matchesPattern", {
    		  enumerable: true,
    		  get: function () {
    		    return _matchesPattern.default;
    		  }
    		});
    		Object.defineProperty(exports, "prependToMemberExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _prependToMemberExpression.default;
    		  }
    		});
    		exports.react = void 0;
    		Object.defineProperty(exports, "removeComments", {
    		  enumerable: true,
    		  get: function () {
    		    return _removeComments.default;
    		  }
    		});
    		Object.defineProperty(exports, "removeProperties", {
    		  enumerable: true,
    		  get: function () {
    		    return _removeProperties.default;
    		  }
    		});
    		Object.defineProperty(exports, "removePropertiesDeep", {
    		  enumerable: true,
    		  get: function () {
    		    return _removePropertiesDeep.default;
    		  }
    		});
    		Object.defineProperty(exports, "removeTypeDuplicates", {
    		  enumerable: true,
    		  get: function () {
    		    return _removeTypeDuplicates.default;
    		  }
    		});
    		Object.defineProperty(exports, "shallowEqual", {
    		  enumerable: true,
    		  get: function () {
    		    return _shallowEqual.default;
    		  }
    		});
    		Object.defineProperty(exports, "toBindingIdentifierName", {
    		  enumerable: true,
    		  get: function () {
    		    return _toBindingIdentifierName.default;
    		  }
    		});
    		Object.defineProperty(exports, "toBlock", {
    		  enumerable: true,
    		  get: function () {
    		    return _toBlock.default;
    		  }
    		});
    		Object.defineProperty(exports, "toComputedKey", {
    		  enumerable: true,
    		  get: function () {
    		    return _toComputedKey.default;
    		  }
    		});
    		Object.defineProperty(exports, "toExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _toExpression.default;
    		  }
    		});
    		Object.defineProperty(exports, "toIdentifier", {
    		  enumerable: true,
    		  get: function () {
    		    return _toIdentifier.default;
    		  }
    		});
    		Object.defineProperty(exports, "toKeyAlias", {
    		  enumerable: true,
    		  get: function () {
    		    return _toKeyAlias.default;
    		  }
    		});
    		Object.defineProperty(exports, "toSequenceExpression", {
    		  enumerable: true,
    		  get: function () {
    		    return _toSequenceExpression.default;
    		  }
    		});
    		Object.defineProperty(exports, "toStatement", {
    		  enumerable: true,
    		  get: function () {
    		    return _toStatement.default;
    		  }
    		});
    		Object.defineProperty(exports, "traverse", {
    		  enumerable: true,
    		  get: function () {
    		    return _traverse.default;
    		  }
    		});
    		Object.defineProperty(exports, "traverseFast", {
    		  enumerable: true,
    		  get: function () {
    		    return _traverseFast.default;
    		  }
    		});
    		Object.defineProperty(exports, "validate", {
    		  enumerable: true,
    		  get: function () {
    		    return _validate.default;
    		  }
    		});
    		Object.defineProperty(exports, "valueToNode", {
    		  enumerable: true,
    		  get: function () {
    		    return _valueToNode.default;
    		  }
    		});
    		var _isReactComponent = requireIsReactComponent();
    		var _isCompatTag = requireIsCompatTag();
    		var _buildChildren = requireBuildChildren();
    		var _assertNode = requireAssertNode();
    		var _index = requireGenerated$1();
    		Object.keys(_index).forEach(function (key) {
    		  if (key === "default" || key === "__esModule") return;
    		  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    		  if (key in exports && exports[key] === _index[key]) return;
    		  Object.defineProperty(exports, key, {
    		    enumerable: true,
    		    get: function () {
    		      return _index[key];
    		    }
    		  });
    		});
    		var _createTypeAnnotationBasedOnTypeof = requireCreateTypeAnnotationBasedOnTypeof();
    		var _createFlowUnionType = requireCreateFlowUnionType();
    		var _createTSUnionType = requireCreateTSUnionType();
    		var _index2 = requireGenerated$2();
    		Object.keys(_index2).forEach(function (key) {
    		  if (key === "default" || key === "__esModule") return;
    		  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    		  if (key in exports && exports[key] === _index2[key]) return;
    		  Object.defineProperty(exports, key, {
    		    enumerable: true,
    		    get: function () {
    		      return _index2[key];
    		    }
    		  });
    		});
    		var _uppercase = requireUppercase();
    		Object.keys(_uppercase).forEach(function (key) {
    		  if (key === "default" || key === "__esModule") return;
    		  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    		  if (key in exports && exports[key] === _uppercase[key]) return;
    		  Object.defineProperty(exports, key, {
    		    enumerable: true,
    		    get: function () {
    		      return _uppercase[key];
    		    }
    		  });
    		});
    		var _productions = requireProductions();
    		Object.keys(_productions).forEach(function (key) {
    		  if (key === "default" || key === "__esModule") return;
    		  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    		  if (key in exports && exports[key] === _productions[key]) return;
    		  Object.defineProperty(exports, key, {
    		    enumerable: true,
    		    get: function () {
    		      return _productions[key];
    		    }
    		  });
    		});
    		var _cloneNode = requireCloneNode();
    		var _clone = requireClone();
    		var _cloneDeep = requireCloneDeep();
    		var _cloneDeepWithoutLoc = requireCloneDeepWithoutLoc();
    		var _cloneWithoutLoc = requireCloneWithoutLoc();
    		var _addComment = requireAddComment();
    		var _addComments = requireAddComments();
    		var _inheritInnerComments = requireInheritInnerComments();
    		var _inheritLeadingComments = requireInheritLeadingComments();
    		var _inheritsComments = requireInheritsComments();
    		var _inheritTrailingComments = requireInheritTrailingComments();
    		var _removeComments = requireRemoveComments();
    		var _index3 = requireGenerated();
    		Object.keys(_index3).forEach(function (key) {
    		  if (key === "default" || key === "__esModule") return;
    		  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    		  if (key in exports && exports[key] === _index3[key]) return;
    		  Object.defineProperty(exports, key, {
    		    enumerable: true,
    		    get: function () {
    		      return _index3[key];
    		    }
    		  });
    		});
    		var _index4 = requireConstants();
    		Object.keys(_index4).forEach(function (key) {
    		  if (key === "default" || key === "__esModule") return;
    		  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    		  if (key in exports && exports[key] === _index4[key]) return;
    		  Object.defineProperty(exports, key, {
    		    enumerable: true,
    		    get: function () {
    		      return _index4[key];
    		    }
    		  });
    		});
    		var _ensureBlock = requireEnsureBlock();
    		var _toBindingIdentifierName = requireToBindingIdentifierName();
    		var _toBlock = requireToBlock();
    		var _toComputedKey = requireToComputedKey();
    		var _toExpression = requireToExpression();
    		var _toIdentifier = requireToIdentifier();
    		var _toKeyAlias = requireToKeyAlias();
    		var _toSequenceExpression = requireToSequenceExpression();
    		var _toStatement = requireToStatement();
    		var _valueToNode = requireValueToNode();
    		var _index5 = requireDefinitions();
    		Object.keys(_index5).forEach(function (key) {
    		  if (key === "default" || key === "__esModule") return;
    		  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    		  if (key in exports && exports[key] === _index5[key]) return;
    		  Object.defineProperty(exports, key, {
    		    enumerable: true,
    		    get: function () {
    		      return _index5[key];
    		    }
    		  });
    		});
    		var _appendToMemberExpression = requireAppendToMemberExpression();
    		var _inherits = requireInherits();
    		var _prependToMemberExpression = requirePrependToMemberExpression();
    		var _removeProperties = requireRemoveProperties();
    		var _removePropertiesDeep = requireRemovePropertiesDeep();
    		var _removeTypeDuplicates = requireRemoveTypeDuplicates$1();
    		var _getBindingIdentifiers = requireGetBindingIdentifiers();
    		var _getOuterBindingIdentifiers = requireGetOuterBindingIdentifiers();
    		var _traverse = requireTraverse();
    		Object.keys(_traverse).forEach(function (key) {
    		  if (key === "default" || key === "__esModule") return;
    		  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    		  if (key in exports && exports[key] === _traverse[key]) return;
    		  Object.defineProperty(exports, key, {
    		    enumerable: true,
    		    get: function () {
    		      return _traverse[key];
    		    }
    		  });
    		});
    		var _traverseFast = requireTraverseFast();
    		var _shallowEqual = requireShallowEqual();
    		var _is = requireIs();
    		var _isBinding = requireIsBinding();
    		var _isBlockScoped = requireIsBlockScoped();
    		var _isImmutable = requireIsImmutable();
    		var _isLet = requireIsLet();
    		var _isNode = requireIsNode();
    		var _isNodesEquivalent = requireIsNodesEquivalent();
    		var _isPlaceholderType = requireIsPlaceholderType();
    		var _isReferenced = requireIsReferenced();
    		var _isScope = requireIsScope();
    		var _isSpecifierDefault = requireIsSpecifierDefault();
    		var _isType = requireIsType();
    		var _isValidES3Identifier = requireIsValidES3Identifier();
    		var _isValidIdentifier = requireIsValidIdentifier();
    		var _isVar = requireIsVar();
    		var _matchesPattern = requireMatchesPattern();
    		var _validate = requireValidate();
    		var _buildMatchMemberExpression = requireBuildMatchMemberExpression();
    		var _index6 = requireGenerated$3();
    		Object.keys(_index6).forEach(function (key) {
    		  if (key === "default" || key === "__esModule") return;
    		  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    		  if (key in exports && exports[key] === _index6[key]) return;
    		  Object.defineProperty(exports, key, {
    		    enumerable: true,
    		    get: function () {
    		      return _index6[key];
    		    }
    		  });
    		});
    		var _deprecationWarning = requireDeprecationWarning();
    		const react = {
    		  isReactComponent: _isReactComponent.default,
    		  isCompatTag: _isCompatTag.default,
    		  buildChildren: _buildChildren.default
    		};
    		exports.react = react;

    		
    	} (lib$4));
    	return lib$4;
    }

    var libExports$2 = requireLib$2();

    /* This Source Code Form is subject to the terms of the Mozilla Public
     * License, v. 2.0. If a copy of the MPL was not distributed with this
     * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

    function createSimplePath(ancestors) {
      if (ancestors.length === 0) {
        return null;
      }

      // Slice the array because babel-types traverse may continue mutating
      // the ancestors array in later traversal logic.
      return new SimplePath(ancestors.slice());
    }

    /**
     * Mimics @babel/traverse's NodePath API in a simpler fashion that isn't as
     * heavy, but still allows the ease of passing paths around to process nested
     * AST structures.
     */
    class SimplePath {
      _index;
      _ancestors;
      _ancestor;

      _parentPath;

      constructor(ancestors, index = ancestors.length - 1) {
        if (index < 0 || index >= ancestors.length) {
          console.error(ancestors);
          throw new Error("Created invalid path");
        }

        this._ancestors = ancestors;
        this._ancestor = ancestors[index];
        this._index = index;
      }

      get parentPath() {
        let path = this._parentPath;
        if (path === undefined) {
          if (this._index === 0) {
            path = null;
          } else {
            path = new SimplePath(this._ancestors, this._index - 1);
          }
          this._parentPath = path;
        }

        return path;
      }

      get parent() {
        return this._ancestor.node;
      }

      get node() {
        const { node, key, index } = this._ancestor;

        if (typeof index === "number") {
          return node[key][index];
        }

        return node[key];
      }

      get key() {
        return this._ancestor.key;
      }

      get type() {
        return this.node.type;
      }

      get inList() {
        return typeof this._ancestor.index === "number";
      }

      get containerIndex() {
        const { index } = this._ancestor;

        if (typeof index !== "number") {
          throw new Error("Cannot get index of non-array node");
        }

        return index;
      }

      find(predicate) {
        for (let path = this; path; path = path.parentPath) {
          if (predicate(path)) {
            return path;
          }
        }
        return null;
      }

      findParent(predicate) {
        if (!this.parentPath) {
          throw new Error("Cannot use findParent on root path");
        }

        return this.parentPath.find(predicate);
      }
    }

    var lib$1 = {};

    var hasRequiredLib$1;

    function requireLib$1 () {
    	if (hasRequiredLib$1) return lib$1;
    	hasRequiredLib$1 = 1;

    	Object.defineProperty(lib$1, '__esModule', {
    	  value: true
    	});
    	function _objectWithoutPropertiesLoose(source, excluded) {
    	  if (source == null) return {};
    	  var target = {};
    	  var sourceKeys = Object.keys(source);
    	  var key, i;
    	  for (i = 0; i < sourceKeys.length; i++) {
    	    key = sourceKeys[i];
    	    if (excluded.indexOf(key) >= 0) continue;
    	    target[key] = source[key];
    	  }
    	  return target;
    	}
    	class Position {
    	  constructor(line, col, index) {
    	    this.line = void 0;
    	    this.column = void 0;
    	    this.index = void 0;
    	    this.line = line;
    	    this.column = col;
    	    this.index = index;
    	  }
    	}
    	class SourceLocation {
    	  constructor(start, end) {
    	    this.start = void 0;
    	    this.end = void 0;
    	    this.filename = void 0;
    	    this.identifierName = void 0;
    	    this.start = start;
    	    this.end = end;
    	  }
    	}
    	function createPositionWithColumnOffset(position, columnOffset) {
    	  const {
    	    line,
    	    column,
    	    index
    	  } = position;
    	  return new Position(line, column + columnOffset, index + columnOffset);
    	}
    	const code = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
    	var ModuleErrors = {
    	  ImportMetaOutsideModule: {
    	    message: `import.meta may appear only with 'sourceType: "module"'`,
    	    code
    	  },
    	  ImportOutsideModule: {
    	    message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
    	    code
    	  }
    	};
    	const NodeDescriptions = {
    	  ArrayPattern: "array destructuring pattern",
    	  AssignmentExpression: "assignment expression",
    	  AssignmentPattern: "assignment expression",
    	  ArrowFunctionExpression: "arrow function expression",
    	  ConditionalExpression: "conditional expression",
    	  CatchClause: "catch clause",
    	  ForOfStatement: "for-of statement",
    	  ForInStatement: "for-in statement",
    	  ForStatement: "for-loop",
    	  FormalParameters: "function parameter list",
    	  Identifier: "identifier",
    	  ImportSpecifier: "import specifier",
    	  ImportDefaultSpecifier: "import default specifier",
    	  ImportNamespaceSpecifier: "import namespace specifier",
    	  ObjectPattern: "object destructuring pattern",
    	  ParenthesizedExpression: "parenthesized expression",
    	  RestElement: "rest element",
    	  UpdateExpression: {
    	    true: "prefix operation",
    	    false: "postfix operation"
    	  },
    	  VariableDeclarator: "variable declaration",
    	  YieldExpression: "yield expression"
    	};
    	const toNodeDescription = ({
    	  type,
    	  prefix
    	}) => type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[String(prefix)] : NodeDescriptions[type];
    	var StandardErrors = {
    	  AccessorIsGenerator: ({
    	    kind
    	  }) => `A ${kind}ter cannot be a generator.`,
    	  ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    	  AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    	  AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    	  AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    	  AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    	  AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    	  AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    	  AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
    	  BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    	  BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    	  BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    	  ConstructorClassField: "Classes may not have a field named 'constructor'.",
    	  ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    	  ConstructorIsAccessor: "Class constructor may not be an accessor.",
    	  ConstructorIsAsync: "Constructor can't be an async function.",
    	  ConstructorIsGenerator: "Constructor can't be a generator.",
    	  DeclarationMissingInitializer: ({
    	    kind
    	  }) => `Missing initializer in ${kind} declaration.`,
    	  DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
    	  DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
    	  DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
    	  DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    	  DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
    	  DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    	  DecoratorStaticBlock: "Decorators can't be used with a static block.",
    	  DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    	  DeletePrivateField: "Deleting a private field is not allowed.",
    	  DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    	  DuplicateConstructor: "Duplicate constructor in the same class.",
    	  DuplicateDefaultExport: "Only one default export allowed per module.",
    	  DuplicateExport: ({
    	    exportName
    	  }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
    	  DuplicateProto: "Redefinition of __proto__ property.",
    	  DuplicateRegExpFlags: "Duplicate regular expression flag.",
    	  DynamicImportPhaseRequiresImportExpressions: ({
    	    phase
    	  }) => `'import.${phase}(...)' can only be parsed when using the 'createImportExpressions' option.`,
    	  ElementAfterRest: "Rest element must be last element.",
    	  EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    	  ExportBindingIsString: ({
    	    localName,
    	    exportName
    	  }) => `A string literal cannot be used as an exported binding without \`from\`.\n- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
    	  ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    	  ForInOfLoopInitializer: ({
    	    type
    	  }) => `'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
    	  ForInUsing: "For-in loop may not start with 'using' declaration.",
    	  ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    	  ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    	  GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    	  IllegalBreakContinue: ({
    	    type
    	  }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,
    	  IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    	  IllegalReturn: "'return' outside of function.",
    	  ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
    	  ImportBindingIsString: ({
    	    importName
    	  }) => `A string literal cannot be used as an imported binding.\n- Did you mean \`import { "${importName}" as foo }\`?`,
    	  ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
    	  ImportCallArity: ({
    	    maxArgumentCount
    	  }) => `\`import()\` requires exactly ${maxArgumentCount === 1 ? "one argument" : "one or two arguments"}.`,
    	  ImportCallNotNewExpression: "Cannot use new with import(...).",
    	  ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    	  ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    	  ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    	  ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    	  IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    	  InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    	  InvalidCodePoint: "Code point out of bounds.",
    	  InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    	  InvalidDecimal: "Invalid decimal.",
    	  InvalidDigit: ({
    	    radix
    	  }) => `Expected number in radix ${radix}.`,
    	  InvalidEscapeSequence: "Bad character escape sequence.",
    	  InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    	  InvalidEscapedReservedWord: ({
    	    reservedWord
    	  }) => `Escape sequence in keyword ${reservedWord}.`,
    	  InvalidIdentifier: ({
    	    identifierName
    	  }) => `Invalid identifier ${identifierName}.`,
    	  InvalidLhs: ({
    	    ancestor
    	  }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
    	  InvalidLhsBinding: ({
    	    ancestor
    	  }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
    	  InvalidLhsOptionalChaining: ({
    	    ancestor
    	  }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,
    	  InvalidNumber: "Invalid number.",
    	  InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    	  InvalidOrUnexpectedToken: ({
    	    unexpected
    	  }) => `Unexpected character '${unexpected}'.`,
    	  InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    	  InvalidPrivateFieldResolution: ({
    	    identifierName
    	  }) => `Private name #${identifierName} is not defined.`,
    	  InvalidPropertyBindingPattern: "Binding member expression.",
    	  InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    	  InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    	  LabelRedeclaration: ({
    	    labelName
    	  }) => `Label '${labelName}' is already declared.`,
    	  LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    	  LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    	  MalformedRegExpFlags: "Invalid regular expression flag.",
    	  MissingClassName: "A class name is required.",
    	  MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    	  MissingSemicolon: "Missing semicolon.",
    	  MissingPlugin: ({
    	    missingPlugin
    	  }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map(name => JSON.stringify(name)).join(", ")}.`,
    	  MissingOneOfPlugins: ({
    	    missingPlugin
    	  }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map(name => JSON.stringify(name)).join(", ")}.`,
    	  MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    	  MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    	  ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    	  ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    	  ModuleAttributesWithDuplicateKeys: ({
    	    key
    	  }) => `Duplicate key "${key}" is not allowed in module attributes.`,
    	  ModuleExportNameHasLoneSurrogate: ({
    	    surrogateCharCode
    	  }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
    	  ModuleExportUndefined: ({
    	    localName
    	  }) => `Export '${localName}' is not defined.`,
    	  MultipleDefaultsInSwitch: "Multiple default clauses.",
    	  NewlineAfterThrow: "Illegal newline after throw.",
    	  NoCatchOrFinally: "Missing catch or finally clause.",
    	  NumberIdentifier: "Identifier directly after number.",
    	  NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    	  ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    	  OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    	  OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    	  OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    	  ParamDupe: "Argument name clash.",
    	  PatternHasAccessor: "Object pattern can't contain getter or setter.",
    	  PatternHasMethod: "Object pattern can't contain methods.",
    	  PrivateInExpectedIn: ({
    	    identifierName
    	  }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
    	  PrivateNameRedeclaration: ({
    	    identifierName
    	  }) => `Duplicate private name #${identifierName}.`,
    	  RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    	  RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    	  RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    	  RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    	  RestTrailingComma: "Unexpected trailing comma after rest element.",
    	  SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    	  SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
    	  SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    	  StaticPrototype: "Classes may not have static property named prototype.",
    	  SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
    	  SuperPrivateField: "Private fields can't be accessed on super.",
    	  TrailingDecorator: "Decorators must be attached to a class element.",
    	  TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    	  TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    	  TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    	  UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    	  UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    	  UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    	  UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    	  UnexpectedKeyword: ({
    	    keyword
    	  }) => `Unexpected keyword '${keyword}'.`,
    	  UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    	  UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    	  UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    	  UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    	  UnexpectedPrivateField: "Unexpected private name.",
    	  UnexpectedReservedWord: ({
    	    reservedWord
    	  }) => `Unexpected reserved word '${reservedWord}'.`,
    	  UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    	  UnexpectedToken: ({
    	    expected,
    	    unexpected
    	  }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
    	  UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    	  UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    	  UnsupportedBind: "Binding should be performed on object property.",
    	  UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    	  UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    	  UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    	  UnsupportedMetaProperty: ({
    	    target,
    	    onlyValidPropertyName
    	  }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
    	  UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    	  UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    	  UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    	  UnterminatedComment: "Unterminated comment.",
    	  UnterminatedRegExp: "Unterminated regular expression.",
    	  UnterminatedString: "Unterminated string constant.",
    	  UnterminatedTemplate: "Unterminated template.",
    	  UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    	  VarRedeclaration: ({
    	    identifierName
    	  }) => `Identifier '${identifierName}' has already been declared.`,
    	  YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    	  YieldInParameter: "Yield expression is not allowed in formal parameters.",
    	  ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
    	};
    	var StrictModeErrors = {
    	  StrictDelete: "Deleting local variable in strict mode.",
    	  StrictEvalArguments: ({
    	    referenceName
    	  }) => `Assigning to '${referenceName}' in strict mode.`,
    	  StrictEvalArgumentsBinding: ({
    	    bindingName
    	  }) => `Binding '${bindingName}' in strict mode.`,
    	  StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    	  StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    	  StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    	  StrictWith: "'with' in strict mode."
    	};
    	const UnparenthesizedPipeBodyDescriptions = new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
    	var PipelineOperatorErrors = {
    	  PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
    	  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
    	  PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    	  PipeTopicUnconfiguredToken: ({
    	    token
    	  }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
    	  PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    	  PipeUnparenthesizedBody: ({
    	    type
    	  }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
	    type
	  })}; please wrap it in parentheses.`,
    	  PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    	  PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    	  PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    	  PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    	  PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    	  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
    	};
    	const _excluded$1 = ["toMessage"],
    	  _excluded2$1 = ["message"];
    	function defineHidden(obj, key, value) {
    	  Object.defineProperty(obj, key, {
    	    enumerable: false,
    	    configurable: true,
    	    value
    	  });
    	}
    	function toParseErrorConstructor(_ref) {
    	  let {
    	      toMessage
    	    } = _ref,
    	    properties = _objectWithoutPropertiesLoose(_ref, _excluded$1);
    	  return function constructor({
    	    loc,
    	    details
    	  }) {
    	    const error = new SyntaxError();
    	    Object.assign(error, properties, {
    	      loc,
    	      pos: loc.index
    	    });
    	    if ("missingPlugin" in details) {
    	      Object.assign(error, {
    	        missingPlugin: details.missingPlugin
    	      });
    	    }
    	    defineHidden(error, "clone", function clone(overrides = {}) {
    	      var _overrides$loc;
    	      const {
    	        line,
    	        column,
    	        index
    	      } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;
    	      return constructor({
    	        loc: new Position(line, column, index),
    	        details: Object.assign({}, details, overrides.details)
    	      });
    	    });
    	    defineHidden(error, "details", details);
    	    Object.defineProperty(error, "message", {
    	      configurable: true,
    	      get() {
    	        const message = `${toMessage(details)} (${loc.line}:${loc.column})`;
    	        this.message = message;
    	        return message;
    	      },
    	      set(value) {
    	        Object.defineProperty(this, "message", {
    	          value,
    	          writable: true
    	        });
    	      }
    	    });
    	    return error;
    	  };
    	}
    	function ParseErrorEnum(argument, syntaxPlugin) {
    	  if (Array.isArray(argument)) {
    	    return parseErrorTemplates => ParseErrorEnum(parseErrorTemplates, argument[0]);
    	  }
    	  const ParseErrorConstructors = {};
    	  for (const reasonCode of Object.keys(argument)) {
    	    const template = argument[reasonCode];
    	    const _ref2 = typeof template === "string" ? {
    	        message: () => template
    	      } : typeof template === "function" ? {
    	        message: template
    	      } : template,
    	      {
    	        message
    	      } = _ref2,
    	      rest = _objectWithoutPropertiesLoose(_ref2, _excluded2$1);
    	    const toMessage = typeof message === "string" ? () => message : message;
    	    ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
    	      code: "BABEL_PARSER_SYNTAX_ERROR",
    	      reasonCode,
    	      toMessage
    	    }, syntaxPlugin ? {
    	      syntaxPlugin
    	    } : {}, rest));
    	  }
    	  return ParseErrorConstructors;
    	}
    	const Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
    	const {
    	  defineProperty
    	} = Object;
    	const toUnenumerable = (object, key) => defineProperty(object, key, {
    	  enumerable: false,
    	  value: object[key]
    	});
    	function toESTreeLocation(node) {
    	  node.loc.start && toUnenumerable(node.loc.start, "index");
    	  node.loc.end && toUnenumerable(node.loc.end, "index");
    	  return node;
    	}
    	var estree = superClass => class ESTreeParserMixin extends superClass {
    	  parse() {
    	    const file = toESTreeLocation(super.parse());
    	    if (this.options.tokens) {
    	      file.tokens = file.tokens.map(toESTreeLocation);
    	    }
    	    return file;
    	  }
    	  parseRegExpLiteral({
    	    pattern,
    	    flags
    	  }) {
    	    let regex = null;
    	    try {
    	      regex = new RegExp(pattern, flags);
    	    } catch (e) {}
    	    const node = this.estreeParseLiteral(regex);
    	    node.regex = {
    	      pattern,
    	      flags
    	    };
    	    return node;
    	  }
    	  parseBigIntLiteral(value) {
    	    let bigInt;
    	    try {
    	      bigInt = BigInt(value);
    	    } catch (_unused) {
    	      bigInt = null;
    	    }
    	    const node = this.estreeParseLiteral(bigInt);
    	    node.bigint = String(node.value || value);
    	    return node;
    	  }
    	  parseDecimalLiteral(value) {
    	    const decimal = null;
    	    const node = this.estreeParseLiteral(decimal);
    	    node.decimal = String(node.value || value);
    	    return node;
    	  }
    	  estreeParseLiteral(value) {
    	    return this.parseLiteral(value, "Literal");
    	  }
    	  parseStringLiteral(value) {
    	    return this.estreeParseLiteral(value);
    	  }
    	  parseNumericLiteral(value) {
    	    return this.estreeParseLiteral(value);
    	  }
    	  parseNullLiteral() {
    	    return this.estreeParseLiteral(null);
    	  }
    	  parseBooleanLiteral(value) {
    	    return this.estreeParseLiteral(value);
    	  }
    	  directiveToStmt(directive) {
    	    const expression = directive.value;
    	    delete directive.value;
    	    expression.type = "Literal";
    	    expression.raw = expression.extra.raw;
    	    expression.value = expression.extra.expressionValue;
    	    const stmt = directive;
    	    stmt.type = "ExpressionStatement";
    	    stmt.expression = expression;
    	    stmt.directive = expression.extra.rawValue;
    	    delete expression.extra;
    	    return stmt;
    	  }
    	  initFunction(node, isAsync) {
    	    super.initFunction(node, isAsync);
    	    node.expression = false;
    	  }
    	  checkDeclaration(node) {
    	    if (node != null && this.isObjectProperty(node)) {
    	      this.checkDeclaration(node.value);
    	    } else {
    	      super.checkDeclaration(node);
    	    }
    	  }
    	  getObjectOrClassMethodParams(method) {
    	    return method.value.params;
    	  }
    	  isValidDirective(stmt) {
    	    var _stmt$expression$extr;
    	    return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
    	  }
    	  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
    	    super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);
    	    const directiveStatements = node.directives.map(d => this.directiveToStmt(d));
    	    node.body = directiveStatements.concat(node.body);
    	    delete node.directives;
    	  }
    	  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
    	    this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);
    	    if (method.typeParameters) {
    	      method.value.typeParameters = method.typeParameters;
    	      delete method.typeParameters;
    	    }
    	    classBody.body.push(method);
    	  }
    	  parsePrivateName() {
    	    const node = super.parsePrivateName();
    	    {
    	      if (!this.getPluginOption("estree", "classFeatures")) {
    	        return node;
    	      }
    	    }
    	    return this.convertPrivateNameToPrivateIdentifier(node);
    	  }
    	  convertPrivateNameToPrivateIdentifier(node) {
    	    const name = super.getPrivateNameSV(node);
    	    node = node;
    	    delete node.id;
    	    node.name = name;
    	    node.type = "PrivateIdentifier";
    	    return node;
    	  }
    	  isPrivateName(node) {
    	    {
    	      if (!this.getPluginOption("estree", "classFeatures")) {
    	        return super.isPrivateName(node);
    	      }
    	    }
    	    return node.type === "PrivateIdentifier";
    	  }
    	  getPrivateNameSV(node) {
    	    {
    	      if (!this.getPluginOption("estree", "classFeatures")) {
    	        return super.getPrivateNameSV(node);
    	      }
    	    }
    	    return node.name;
    	  }
    	  parseLiteral(value, type) {
    	    const node = super.parseLiteral(value, type);
    	    node.raw = node.extra.raw;
    	    delete node.extra;
    	    return node;
    	  }
    	  parseFunctionBody(node, allowExpression, isMethod = false) {
    	    super.parseFunctionBody(node, allowExpression, isMethod);
    	    node.expression = node.body.type !== "BlockStatement";
    	  }
    	  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
    	    let funcNode = this.startNode();
    	    funcNode.kind = node.kind;
    	    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
    	    funcNode.type = "FunctionExpression";
    	    delete funcNode.kind;
    	    node.value = funcNode;
    	    if (type === "ClassPrivateMethod") {
    	      node.computed = false;
    	    }
    	    return this.finishNode(node, "MethodDefinition");
    	  }
    	  parseClassProperty(...args) {
    	    const propertyNode = super.parseClassProperty(...args);
    	    {
    	      if (!this.getPluginOption("estree", "classFeatures")) {
    	        return propertyNode;
    	      }
    	    }
    	    propertyNode.type = "PropertyDefinition";
    	    return propertyNode;
    	  }
    	  parseClassPrivateProperty(...args) {
    	    const propertyNode = super.parseClassPrivateProperty(...args);
    	    {
    	      if (!this.getPluginOption("estree", "classFeatures")) {
    	        return propertyNode;
    	      }
    	    }
    	    propertyNode.type = "PropertyDefinition";
    	    propertyNode.computed = false;
    	    return propertyNode;
    	  }
    	  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
    	    const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);
    	    if (node) {
    	      node.type = "Property";
    	      if (node.kind === "method") {
    	        node.kind = "init";
    	      }
    	      node.shorthand = false;
    	    }
    	    return node;
    	  }
    	  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
    	    const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
    	    if (node) {
    	      node.kind = "init";
    	      node.type = "Property";
    	    }
    	    return node;
    	  }
    	  isValidLVal(type, isUnparenthesizedInAssign, binding) {
    	    return type === "Property" ? "value" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);
    	  }
    	  isAssignable(node, isBinding) {
    	    if (node != null && this.isObjectProperty(node)) {
    	      return this.isAssignable(node.value, isBinding);
    	    }
    	    return super.isAssignable(node, isBinding);
    	  }
    	  toAssignable(node, isLHS = false) {
    	    if (node != null && this.isObjectProperty(node)) {
    	      const {
    	        key,
    	        value
    	      } = node;
    	      if (this.isPrivateName(key)) {
    	        this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
    	      }
    	      this.toAssignable(value, isLHS);
    	    } else {
    	      super.toAssignable(node, isLHS);
    	    }
    	  }
    	  toAssignableObjectExpressionProp(prop, isLast, isLHS) {
    	    if (prop.kind === "get" || prop.kind === "set") {
    	      this.raise(Errors.PatternHasAccessor, {
    	        at: prop.key
    	      });
    	    } else if (prop.method) {
    	      this.raise(Errors.PatternHasMethod, {
    	        at: prop.key
    	      });
    	    } else {
    	      super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
    	    }
    	  }
    	  finishCallExpression(unfinished, optional) {
    	    const node = super.finishCallExpression(unfinished, optional);
    	    if (node.callee.type === "Import") {
    	      node.type = "ImportExpression";
    	      node.source = node.arguments[0];
    	      if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
    	        var _node$arguments$, _node$arguments$2;
    	        node.options = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;
    	        node.attributes = (_node$arguments$2 = node.arguments[1]) != null ? _node$arguments$2 : null;
    	      }
    	      delete node.arguments;
    	      delete node.callee;
    	    }
    	    return node;
    	  }
    	  toReferencedArguments(node) {
    	    if (node.type === "ImportExpression") {
    	      return;
    	    }
    	    super.toReferencedArguments(node);
    	  }
    	  parseExport(unfinished, decorators) {
    	    const exportStartLoc = this.state.lastTokStartLoc;
    	    const node = super.parseExport(unfinished, decorators);
    	    switch (node.type) {
    	      case "ExportAllDeclaration":
    	        node.exported = null;
    	        break;
    	      case "ExportNamedDeclaration":
    	        if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
    	          node.type = "ExportAllDeclaration";
    	          node.exported = node.specifiers[0].exported;
    	          delete node.specifiers;
    	        }
    	      case "ExportDefaultDeclaration":
    	        {
    	          var _declaration$decorato;
    	          const {
    	            declaration
    	          } = node;
    	          if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {
    	            this.resetStartLocation(node, exportStartLoc);
    	          }
    	        }
    	        break;
    	    }
    	    return node;
    	  }
    	  parseSubscript(base, startLoc, noCalls, state) {
    	    const node = super.parseSubscript(base, startLoc, noCalls, state);
    	    if (state.optionalChainMember) {
    	      if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
    	        node.type = node.type.substring(8);
    	      }
    	      if (state.stop) {
    	        const chain = this.startNodeAtNode(node);
    	        chain.expression = node;
    	        return this.finishNode(chain, "ChainExpression");
    	      }
    	    } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
    	      node.optional = false;
    	    }
    	    return node;
    	  }
    	  isOptionalMemberExpression(node) {
    	    if (node.type === "ChainExpression") {
    	      return node.expression.type === "MemberExpression";
    	    }
    	    return super.isOptionalMemberExpression(node);
    	  }
    	  hasPropertyAsPrivateName(node) {
    	    if (node.type === "ChainExpression") {
    	      node = node.expression;
    	    }
    	    return super.hasPropertyAsPrivateName(node);
    	  }
    	  isObjectProperty(node) {
    	    return node.type === "Property" && node.kind === "init" && !node.method;
    	  }
    	  isObjectMethod(node) {
    	    return node.method || node.kind === "get" || node.kind === "set";
    	  }
    	  finishNodeAt(node, type, endLoc) {
    	    return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
    	  }
    	  resetStartLocation(node, startLoc) {
    	    super.resetStartLocation(node, startLoc);
    	    toESTreeLocation(node);
    	  }
    	  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
    	    super.resetEndLocation(node, endLoc);
    	    toESTreeLocation(node);
    	  }
    	};
    	class TokContext {
    	  constructor(token, preserveSpace) {
    	    this.token = void 0;
    	    this.preserveSpace = void 0;
    	    this.token = token;
    	    this.preserveSpace = !!preserveSpace;
    	  }
    	}
    	const types = {
    	  brace: new TokContext("{"),
    	  j_oTag: new TokContext("<tag"),
    	  j_cTag: new TokContext("</tag"),
    	  j_expr: new TokContext("<tag>...</tag>", true)
    	};
    	{
    	  types.template = new TokContext("`", true);
    	}
    	const beforeExpr = true;
    	const startsExpr = true;
    	const isLoop = true;
    	const isAssign = true;
    	const prefix = true;
    	const postfix = true;
    	class ExportedTokenType {
    	  constructor(label, conf = {}) {
    	    this.label = void 0;
    	    this.keyword = void 0;
    	    this.beforeExpr = void 0;
    	    this.startsExpr = void 0;
    	    this.rightAssociative = void 0;
    	    this.isLoop = void 0;
    	    this.isAssign = void 0;
    	    this.prefix = void 0;
    	    this.postfix = void 0;
    	    this.binop = void 0;
    	    this.label = label;
    	    this.keyword = conf.keyword;
    	    this.beforeExpr = !!conf.beforeExpr;
    	    this.startsExpr = !!conf.startsExpr;
    	    this.rightAssociative = !!conf.rightAssociative;
    	    this.isLoop = !!conf.isLoop;
    	    this.isAssign = !!conf.isAssign;
    	    this.prefix = !!conf.prefix;
    	    this.postfix = !!conf.postfix;
    	    this.binop = conf.binop != null ? conf.binop : null;
    	    {
    	      this.updateContext = null;
    	    }
    	  }
    	}
    	const keywords$1 = new Map();
    	function createKeyword(name, options = {}) {
    	  options.keyword = name;
    	  const token = createToken(name, options);
    	  keywords$1.set(name, token);
    	  return token;
    	}
    	function createBinop(name, binop) {
    	  return createToken(name, {
    	    beforeExpr,
    	    binop
    	  });
    	}
    	let tokenTypeCounter = -1;
    	const tokenTypes = [];
    	const tokenLabels = [];
    	const tokenBinops = [];
    	const tokenBeforeExprs = [];
    	const tokenStartsExprs = [];
    	const tokenPrefixes = [];
    	function createToken(name, options = {}) {
    	  var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
    	  ++tokenTypeCounter;
    	  tokenLabels.push(name);
    	  tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
    	  tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
    	  tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
    	  tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
    	  tokenTypes.push(new ExportedTokenType(name, options));
    	  return tokenTypeCounter;
    	}
    	function createKeywordLike(name, options = {}) {
    	  var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
    	  ++tokenTypeCounter;
    	  keywords$1.set(name, tokenTypeCounter);
    	  tokenLabels.push(name);
    	  tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
    	  tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
    	  tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
    	  tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
    	  tokenTypes.push(new ExportedTokenType("name", options));
    	  return tokenTypeCounter;
    	}
    	const tt = {
    	  bracketL: createToken("[", {
    	    beforeExpr,
    	    startsExpr
    	  }),
    	  bracketHashL: createToken("#[", {
    	    beforeExpr,
    	    startsExpr
    	  }),
    	  bracketBarL: createToken("[|", {
    	    beforeExpr,
    	    startsExpr
    	  }),
    	  bracketR: createToken("]"),
    	  bracketBarR: createToken("|]"),
    	  braceL: createToken("{", {
    	    beforeExpr,
    	    startsExpr
    	  }),
    	  braceBarL: createToken("{|", {
    	    beforeExpr,
    	    startsExpr
    	  }),
    	  braceHashL: createToken("#{", {
    	    beforeExpr,
    	    startsExpr
    	  }),
    	  braceR: createToken("}"),
    	  braceBarR: createToken("|}"),
    	  parenL: createToken("(", {
    	    beforeExpr,
    	    startsExpr
    	  }),
    	  parenR: createToken(")"),
    	  comma: createToken(",", {
    	    beforeExpr
    	  }),
    	  semi: createToken(";", {
    	    beforeExpr
    	  }),
    	  colon: createToken(":", {
    	    beforeExpr
    	  }),
    	  doubleColon: createToken("::", {
    	    beforeExpr
    	  }),
    	  dot: createToken("."),
    	  question: createToken("?", {
    	    beforeExpr
    	  }),
    	  questionDot: createToken("?."),
    	  arrow: createToken("=>", {
    	    beforeExpr
    	  }),
    	  template: createToken("template"),
    	  ellipsis: createToken("...", {
    	    beforeExpr
    	  }),
    	  backQuote: createToken("`", {
    	    startsExpr
    	  }),
    	  dollarBraceL: createToken("${", {
    	    beforeExpr,
    	    startsExpr
    	  }),
    	  templateTail: createToken("...`", {
    	    startsExpr
    	  }),
    	  templateNonTail: createToken("...${", {
    	    beforeExpr,
    	    startsExpr
    	  }),
    	  at: createToken("@"),
    	  hash: createToken("#", {
    	    startsExpr
    	  }),
    	  interpreterDirective: createToken("#!..."),
    	  eq: createToken("=", {
    	    beforeExpr,
    	    isAssign
    	  }),
    	  assign: createToken("_=", {
    	    beforeExpr,
    	    isAssign
    	  }),
    	  slashAssign: createToken("_=", {
    	    beforeExpr,
    	    isAssign
    	  }),
    	  xorAssign: createToken("_=", {
    	    beforeExpr,
    	    isAssign
    	  }),
    	  moduloAssign: createToken("_=", {
    	    beforeExpr,
    	    isAssign
    	  }),
    	  incDec: createToken("++/--", {
    	    prefix,
    	    postfix,
    	    startsExpr
    	  }),
    	  bang: createToken("!", {
    	    beforeExpr,
    	    prefix,
    	    startsExpr
    	  }),
    	  tilde: createToken("~", {
    	    beforeExpr,
    	    prefix,
    	    startsExpr
    	  }),
    	  doubleCaret: createToken("^^", {
    	    startsExpr
    	  }),
    	  doubleAt: createToken("@@", {
    	    startsExpr
    	  }),
    	  pipeline: createBinop("|>", 0),
    	  nullishCoalescing: createBinop("??", 1),
    	  logicalOR: createBinop("||", 1),
    	  logicalAND: createBinop("&&", 2),
    	  bitwiseOR: createBinop("|", 3),
    	  bitwiseXOR: createBinop("^", 4),
    	  bitwiseAND: createBinop("&", 5),
    	  equality: createBinop("==/!=/===/!==", 6),
    	  lt: createBinop("</>/<=/>=", 7),
    	  gt: createBinop("</>/<=/>=", 7),
    	  relational: createBinop("</>/<=/>=", 7),
    	  bitShift: createBinop("<</>>/>>>", 8),
    	  bitShiftL: createBinop("<</>>/>>>", 8),
    	  bitShiftR: createBinop("<</>>/>>>", 8),
    	  plusMin: createToken("+/-", {
    	    beforeExpr,
    	    binop: 9,
    	    prefix,
    	    startsExpr
    	  }),
    	  modulo: createToken("%", {
    	    binop: 10,
    	    startsExpr
    	  }),
    	  star: createToken("*", {
    	    binop: 10
    	  }),
    	  slash: createBinop("/", 10),
    	  exponent: createToken("**", {
    	    beforeExpr,
    	    binop: 11,
    	    rightAssociative: true
    	  }),
    	  _in: createKeyword("in", {
    	    beforeExpr,
    	    binop: 7
    	  }),
    	  _instanceof: createKeyword("instanceof", {
    	    beforeExpr,
    	    binop: 7
    	  }),
    	  _break: createKeyword("break"),
    	  _case: createKeyword("case", {
    	    beforeExpr
    	  }),
    	  _catch: createKeyword("catch"),
    	  _continue: createKeyword("continue"),
    	  _debugger: createKeyword("debugger"),
    	  _default: createKeyword("default", {
    	    beforeExpr
    	  }),
    	  _else: createKeyword("else", {
    	    beforeExpr
    	  }),
    	  _finally: createKeyword("finally"),
    	  _function: createKeyword("function", {
    	    startsExpr
    	  }),
    	  _if: createKeyword("if"),
    	  _return: createKeyword("return", {
    	    beforeExpr
    	  }),
    	  _switch: createKeyword("switch"),
    	  _throw: createKeyword("throw", {
    	    beforeExpr,
    	    prefix,
    	    startsExpr
    	  }),
    	  _try: createKeyword("try"),
    	  _var: createKeyword("var"),
    	  _const: createKeyword("const"),
    	  _with: createKeyword("with"),
    	  _new: createKeyword("new", {
    	    beforeExpr,
    	    startsExpr
    	  }),
    	  _this: createKeyword("this", {
    	    startsExpr
    	  }),
    	  _super: createKeyword("super", {
    	    startsExpr
    	  }),
    	  _class: createKeyword("class", {
    	    startsExpr
    	  }),
    	  _extends: createKeyword("extends", {
    	    beforeExpr
    	  }),
    	  _export: createKeyword("export"),
    	  _import: createKeyword("import", {
    	    startsExpr
    	  }),
    	  _null: createKeyword("null", {
    	    startsExpr
    	  }),
    	  _true: createKeyword("true", {
    	    startsExpr
    	  }),
    	  _false: createKeyword("false", {
    	    startsExpr
    	  }),
    	  _typeof: createKeyword("typeof", {
    	    beforeExpr,
    	    prefix,
    	    startsExpr
    	  }),
    	  _void: createKeyword("void", {
    	    beforeExpr,
    	    prefix,
    	    startsExpr
    	  }),
    	  _delete: createKeyword("delete", {
    	    beforeExpr,
    	    prefix,
    	    startsExpr
    	  }),
    	  _do: createKeyword("do", {
    	    isLoop,
    	    beforeExpr
    	  }),
    	  _for: createKeyword("for", {
    	    isLoop
    	  }),
    	  _while: createKeyword("while", {
    	    isLoop
    	  }),
    	  _as: createKeywordLike("as", {
    	    startsExpr
    	  }),
    	  _assert: createKeywordLike("assert", {
    	    startsExpr
    	  }),
    	  _async: createKeywordLike("async", {
    	    startsExpr
    	  }),
    	  _await: createKeywordLike("await", {
    	    startsExpr
    	  }),
    	  _defer: createKeywordLike("defer", {
    	    startsExpr
    	  }),
    	  _from: createKeywordLike("from", {
    	    startsExpr
    	  }),
    	  _get: createKeywordLike("get", {
    	    startsExpr
    	  }),
    	  _let: createKeywordLike("let", {
    	    startsExpr
    	  }),
    	  _meta: createKeywordLike("meta", {
    	    startsExpr
    	  }),
    	  _of: createKeywordLike("of", {
    	    startsExpr
    	  }),
    	  _sent: createKeywordLike("sent", {
    	    startsExpr
    	  }),
    	  _set: createKeywordLike("set", {
    	    startsExpr
    	  }),
    	  _source: createKeywordLike("source", {
    	    startsExpr
    	  }),
    	  _static: createKeywordLike("static", {
    	    startsExpr
    	  }),
    	  _using: createKeywordLike("using", {
    	    startsExpr
    	  }),
    	  _yield: createKeywordLike("yield", {
    	    startsExpr
    	  }),
    	  _asserts: createKeywordLike("asserts", {
    	    startsExpr
    	  }),
    	  _checks: createKeywordLike("checks", {
    	    startsExpr
    	  }),
    	  _exports: createKeywordLike("exports", {
    	    startsExpr
    	  }),
    	  _global: createKeywordLike("global", {
    	    startsExpr
    	  }),
    	  _implements: createKeywordLike("implements", {
    	    startsExpr
    	  }),
    	  _intrinsic: createKeywordLike("intrinsic", {
    	    startsExpr
    	  }),
    	  _infer: createKeywordLike("infer", {
    	    startsExpr
    	  }),
    	  _is: createKeywordLike("is", {
    	    startsExpr
    	  }),
    	  _mixins: createKeywordLike("mixins", {
    	    startsExpr
    	  }),
    	  _proto: createKeywordLike("proto", {
    	    startsExpr
    	  }),
    	  _require: createKeywordLike("require", {
    	    startsExpr
    	  }),
    	  _satisfies: createKeywordLike("satisfies", {
    	    startsExpr
    	  }),
    	  _keyof: createKeywordLike("keyof", {
    	    startsExpr
    	  }),
    	  _readonly: createKeywordLike("readonly", {
    	    startsExpr
    	  }),
    	  _unique: createKeywordLike("unique", {
    	    startsExpr
    	  }),
    	  _abstract: createKeywordLike("abstract", {
    	    startsExpr
    	  }),
    	  _declare: createKeywordLike("declare", {
    	    startsExpr
    	  }),
    	  _enum: createKeywordLike("enum", {
    	    startsExpr
    	  }),
    	  _module: createKeywordLike("module", {
    	    startsExpr
    	  }),
    	  _namespace: createKeywordLike("namespace", {
    	    startsExpr
    	  }),
    	  _interface: createKeywordLike("interface", {
    	    startsExpr
    	  }),
    	  _type: createKeywordLike("type", {
    	    startsExpr
    	  }),
    	  _opaque: createKeywordLike("opaque", {
    	    startsExpr
    	  }),
    	  name: createToken("name", {
    	    startsExpr
    	  }),
    	  string: createToken("string", {
    	    startsExpr
    	  }),
    	  num: createToken("num", {
    	    startsExpr
    	  }),
    	  bigint: createToken("bigint", {
    	    startsExpr
    	  }),
    	  decimal: createToken("decimal", {
    	    startsExpr
    	  }),
    	  regexp: createToken("regexp", {
    	    startsExpr
    	  }),
    	  privateName: createToken("#name", {
    	    startsExpr
    	  }),
    	  eof: createToken("eof"),
    	  jsxName: createToken("jsxName"),
    	  jsxText: createToken("jsxText", {
    	    beforeExpr: true
    	  }),
    	  jsxTagStart: createToken("jsxTagStart", {
    	    startsExpr: true
    	  }),
    	  jsxTagEnd: createToken("jsxTagEnd"),
    	  placeholder: createToken("%%", {
    	    startsExpr: true
    	  })
    	};
    	function tokenIsIdentifier(token) {
    	  return token >= 93 && token <= 132;
    	}
    	function tokenKeywordOrIdentifierIsKeyword(token) {
    	  return token <= 92;
    	}
    	function tokenIsKeywordOrIdentifier(token) {
    	  return token >= 58 && token <= 132;
    	}
    	function tokenIsLiteralPropertyName(token) {
    	  return token >= 58 && token <= 136;
    	}
    	function tokenComesBeforeExpression(token) {
    	  return tokenBeforeExprs[token];
    	}
    	function tokenCanStartExpression(token) {
    	  return tokenStartsExprs[token];
    	}
    	function tokenIsAssignment(token) {
    	  return token >= 29 && token <= 33;
    	}
    	function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
    	  return token >= 129 && token <= 131;
    	}
    	function tokenIsLoop(token) {
    	  return token >= 90 && token <= 92;
    	}
    	function tokenIsKeyword(token) {
    	  return token >= 58 && token <= 92;
    	}
    	function tokenIsOperator(token) {
    	  return token >= 39 && token <= 59;
    	}
    	function tokenIsPostfix(token) {
    	  return token === 34;
    	}
    	function tokenIsPrefix(token) {
    	  return tokenPrefixes[token];
    	}
    	function tokenIsTSTypeOperator(token) {
    	  return token >= 121 && token <= 123;
    	}
    	function tokenIsTSDeclarationStart(token) {
    	  return token >= 124 && token <= 130;
    	}
    	function tokenLabelName(token) {
    	  return tokenLabels[token];
    	}
    	function tokenOperatorPrecedence(token) {
    	  return tokenBinops[token];
    	}
    	function tokenIsRightAssociative(token) {
    	  return token === 57;
    	}
    	function tokenIsTemplate(token) {
    	  return token >= 24 && token <= 25;
    	}
    	function getExportedToken(token) {
    	  return tokenTypes[token];
    	}
    	{
    	  tokenTypes[8].updateContext = context => {
    	    context.pop();
    	  };
    	  tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = context => {
    	    context.push(types.brace);
    	  };
    	  tokenTypes[22].updateContext = context => {
    	    if (context[context.length - 1] === types.template) {
    	      context.pop();
    	    } else {
    	      context.push(types.template);
    	    }
    	  };
    	  tokenTypes[142].updateContext = context => {
    	    context.push(types.j_expr, types.j_oTag);
    	  };
    	}
    	let nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ca\ua7d0\ua7d1\ua7d3\ua7d5-\ua7d9\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
    	let nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0898-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\u30fb\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f\uff65";
    	const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    	const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    	nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    	const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
    	const astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    	function isInAstralSet(code, set) {
    	  let pos = 0x10000;
    	  for (let i = 0, length = set.length; i < length; i += 2) {
    	    pos += set[i];
    	    if (pos > code) return false;
    	    pos += set[i + 1];
    	    if (pos >= code) return true;
    	  }
    	  return false;
    	}
    	function isIdentifierStart(code) {
    	  if (code < 65) return code === 36;
    	  if (code <= 90) return true;
    	  if (code < 97) return code === 95;
    	  if (code <= 122) return true;
    	  if (code <= 0xffff) {
    	    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
    	  }
    	  return isInAstralSet(code, astralIdentifierStartCodes);
    	}
    	function isIdentifierChar(code) {
    	  if (code < 48) return code === 36;
    	  if (code < 58) return true;
    	  if (code < 65) return false;
    	  if (code <= 90) return true;
    	  if (code < 97) return code === 95;
    	  if (code <= 122) return true;
    	  if (code <= 0xffff) {
    	    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
    	  }
    	  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    	}
    	const reservedWords = {
    	  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    	  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    	  strictBind: ["eval", "arguments"]
    	};
    	const keywords = new Set(reservedWords.keyword);
    	const reservedWordsStrictSet = new Set(reservedWords.strict);
    	const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    	function isReservedWord(word, inModule) {
    	  return inModule && word === "await" || word === "enum";
    	}
    	function isStrictReservedWord(word, inModule) {
    	  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    	}
    	function isStrictBindOnlyReservedWord(word) {
    	  return reservedWordsStrictBindSet.has(word);
    	}
    	function isStrictBindReservedWord(word, inModule) {
    	  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    	}
    	function isKeyword(word) {
    	  return keywords.has(word);
    	}
    	function isIteratorStart(current, next, next2) {
    	  return current === 64 && next === 64 && isIdentifierStart(next2);
    	}
    	const reservedWordLikeSet = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
    	function canBeReservedWord(word) {
    	  return reservedWordLikeSet.has(word);
    	}
    	class Scope {
    	  constructor(flags) {
    	    this.var = new Set();
    	    this.lexical = new Set();
    	    this.functions = new Set();
    	    this.flags = flags;
    	  }
    	}
    	class ScopeHandler {
    	  constructor(parser, inModule) {
    	    this.parser = void 0;
    	    this.scopeStack = [];
    	    this.inModule = void 0;
    	    this.undefinedExports = new Map();
    	    this.parser = parser;
    	    this.inModule = inModule;
    	  }
    	  get inTopLevel() {
    	    return (this.currentScope().flags & 1) > 0;
    	  }
    	  get inFunction() {
    	    return (this.currentVarScopeFlags() & 2) > 0;
    	  }
    	  get allowSuper() {
    	    return (this.currentThisScopeFlags() & 16) > 0;
    	  }
    	  get allowDirectSuper() {
    	    return (this.currentThisScopeFlags() & 32) > 0;
    	  }
    	  get inClass() {
    	    return (this.currentThisScopeFlags() & 64) > 0;
    	  }
    	  get inClassAndNotInNonArrowFunction() {
    	    const flags = this.currentThisScopeFlags();
    	    return (flags & 64) > 0 && (flags & 2) === 0;
    	  }
    	  get inStaticBlock() {
    	    for (let i = this.scopeStack.length - 1;; i--) {
    	      const {
    	        flags
    	      } = this.scopeStack[i];
    	      if (flags & 128) {
    	        return true;
    	      }
    	      if (flags & (387 | 64)) {
    	        return false;
    	      }
    	    }
    	  }
    	  get inNonArrowFunction() {
    	    return (this.currentThisScopeFlags() & 2) > 0;
    	  }
    	  get treatFunctionsAsVar() {
    	    return this.treatFunctionsAsVarInScope(this.currentScope());
    	  }
    	  createScope(flags) {
    	    return new Scope(flags);
    	  }
    	  enter(flags) {
    	    this.scopeStack.push(this.createScope(flags));
    	  }
    	  exit() {
    	    const scope = this.scopeStack.pop();
    	    return scope.flags;
    	  }
    	  treatFunctionsAsVarInScope(scope) {
    	    return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);
    	  }
    	  declareName(name, bindingType, loc) {
    	    let scope = this.currentScope();
    	    if (bindingType & 8 || bindingType & 16) {
    	      this.checkRedeclarationInScope(scope, name, bindingType, loc);
    	      if (bindingType & 16) {
    	        scope.functions.add(name);
    	      } else {
    	        scope.lexical.add(name);
    	      }
    	      if (bindingType & 8) {
    	        this.maybeExportDefined(scope, name);
    	      }
    	    } else if (bindingType & 4) {
    	      for (let i = this.scopeStack.length - 1; i >= 0; --i) {
    	        scope = this.scopeStack[i];
    	        this.checkRedeclarationInScope(scope, name, bindingType, loc);
    	        scope.var.add(name);
    	        this.maybeExportDefined(scope, name);
    	        if (scope.flags & 387) break;
    	      }
    	    }
    	    if (this.parser.inModule && scope.flags & 1) {
    	      this.undefinedExports.delete(name);
    	    }
    	  }
    	  maybeExportDefined(scope, name) {
    	    if (this.parser.inModule && scope.flags & 1) {
    	      this.undefinedExports.delete(name);
    	    }
    	  }
    	  checkRedeclarationInScope(scope, name, bindingType, loc) {
    	    if (this.isRedeclaredInScope(scope, name, bindingType)) {
    	      this.parser.raise(Errors.VarRedeclaration, {
    	        at: loc,
    	        identifierName: name
    	      });
    	    }
    	  }
    	  isRedeclaredInScope(scope, name, bindingType) {
    	    if (!(bindingType & 1)) return false;
    	    if (bindingType & 8) {
    	      return scope.lexical.has(name) || scope.functions.has(name) || scope.var.has(name);
    	    }
    	    if (bindingType & 16) {
    	      return scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope.var.has(name);
    	    }
    	    return scope.lexical.has(name) && !(scope.flags & 8 && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name);
    	  }
    	  checkLocalExport(id) {
    	    const {
    	      name
    	    } = id;
    	    const topLevelScope = this.scopeStack[0];
    	    if (!topLevelScope.lexical.has(name) && !topLevelScope.var.has(name) && !topLevelScope.functions.has(name)) {
    	      this.undefinedExports.set(name, id.loc.start);
    	    }
    	  }
    	  currentScope() {
    	    return this.scopeStack[this.scopeStack.length - 1];
    	  }
    	  currentVarScopeFlags() {
    	    for (let i = this.scopeStack.length - 1;; i--) {
    	      const {
    	        flags
    	      } = this.scopeStack[i];
    	      if (flags & 387) {
    	        return flags;
    	      }
    	    }
    	  }
    	  currentThisScopeFlags() {
    	    for (let i = this.scopeStack.length - 1;; i--) {
    	      const {
    	        flags
    	      } = this.scopeStack[i];
    	      if (flags & (387 | 64) && !(flags & 4)) {
    	        return flags;
    	      }
    	    }
    	  }
    	}
    	class FlowScope extends Scope {
    	  constructor(...args) {
    	    super(...args);
    	    this.declareFunctions = new Set();
    	  }
    	}
    	class FlowScopeHandler extends ScopeHandler {
    	  createScope(flags) {
    	    return new FlowScope(flags);
    	  }
    	  declareName(name, bindingType, loc) {
    	    const scope = this.currentScope();
    	    if (bindingType & 2048) {
    	      this.checkRedeclarationInScope(scope, name, bindingType, loc);
    	      this.maybeExportDefined(scope, name);
    	      scope.declareFunctions.add(name);
    	      return;
    	    }
    	    super.declareName(name, bindingType, loc);
    	  }
    	  isRedeclaredInScope(scope, name, bindingType) {
    	    if (super.isRedeclaredInScope(scope, name, bindingType)) return true;
    	    if (bindingType & 2048) {
    	      return !scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name));
    	    }
    	    return false;
    	  }
    	  checkLocalExport(id) {
    	    if (!this.scopeStack[0].declareFunctions.has(id.name)) {
    	      super.checkLocalExport(id);
    	    }
    	  }
    	}
    	class BaseParser {
    	  constructor() {
    	    this.sawUnambiguousESM = false;
    	    this.ambiguousScriptDifferentAst = false;
    	  }
    	  hasPlugin(pluginConfig) {
    	    if (typeof pluginConfig === "string") {
    	      return this.plugins.has(pluginConfig);
    	    } else {
    	      const [pluginName, pluginOptions] = pluginConfig;
    	      if (!this.hasPlugin(pluginName)) {
    	        return false;
    	      }
    	      const actualOptions = this.plugins.get(pluginName);
    	      for (const key of Object.keys(pluginOptions)) {
    	        if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
    	          return false;
    	        }
    	      }
    	      return true;
    	    }
    	  }
    	  getPluginOption(plugin, name) {
    	    var _this$plugins$get;
    	    return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];
    	  }
    	}
    	function setTrailingComments(node, comments) {
    	  if (node.trailingComments === undefined) {
    	    node.trailingComments = comments;
    	  } else {
    	    node.trailingComments.unshift(...comments);
    	  }
    	}
    	function setLeadingComments(node, comments) {
    	  if (node.leadingComments === undefined) {
    	    node.leadingComments = comments;
    	  } else {
    	    node.leadingComments.unshift(...comments);
    	  }
    	}
    	function setInnerComments(node, comments) {
    	  if (node.innerComments === undefined) {
    	    node.innerComments = comments;
    	  } else {
    	    node.innerComments.unshift(...comments);
    	  }
    	}
    	function adjustInnerComments(node, elements, commentWS) {
    	  let lastElement = null;
    	  let i = elements.length;
    	  while (lastElement === null && i > 0) {
    	    lastElement = elements[--i];
    	  }
    	  if (lastElement === null || lastElement.start > commentWS.start) {
    	    setInnerComments(node, commentWS.comments);
    	  } else {
    	    setTrailingComments(lastElement, commentWS.comments);
    	  }
    	}
    	class CommentsParser extends BaseParser {
    	  addComment(comment) {
    	    if (this.filename) comment.loc.filename = this.filename;
    	    this.state.comments.push(comment);
    	  }
    	  processComment(node) {
    	    const {
    	      commentStack
    	    } = this.state;
    	    const commentStackLength = commentStack.length;
    	    if (commentStackLength === 0) return;
    	    let i = commentStackLength - 1;
    	    const lastCommentWS = commentStack[i];
    	    if (lastCommentWS.start === node.end) {
    	      lastCommentWS.leadingNode = node;
    	      i--;
    	    }
    	    const {
    	      start: nodeStart
    	    } = node;
    	    for (; i >= 0; i--) {
    	      const commentWS = commentStack[i];
    	      const commentEnd = commentWS.end;
    	      if (commentEnd > nodeStart) {
    	        commentWS.containingNode = node;
    	        this.finalizeComment(commentWS);
    	        commentStack.splice(i, 1);
    	      } else {
    	        if (commentEnd === nodeStart) {
    	          commentWS.trailingNode = node;
    	        }
    	        break;
    	      }
    	    }
    	  }
    	  finalizeComment(commentWS) {
    	    const {
    	      comments
    	    } = commentWS;
    	    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
    	      if (commentWS.leadingNode !== null) {
    	        setTrailingComments(commentWS.leadingNode, comments);
    	      }
    	      if (commentWS.trailingNode !== null) {
    	        setLeadingComments(commentWS.trailingNode, comments);
    	      }
    	    } else {
    	      const {
    	        containingNode: node,
    	        start: commentStart
    	      } = commentWS;
    	      if (this.input.charCodeAt(commentStart - 1) === 44) {
    	        switch (node.type) {
    	          case "ObjectExpression":
    	          case "ObjectPattern":
    	          case "RecordExpression":
    	            adjustInnerComments(node, node.properties, commentWS);
    	            break;
    	          case "CallExpression":
    	          case "OptionalCallExpression":
    	            adjustInnerComments(node, node.arguments, commentWS);
    	            break;
    	          case "FunctionDeclaration":
    	          case "FunctionExpression":
    	          case "ArrowFunctionExpression":
    	          case "ObjectMethod":
    	          case "ClassMethod":
    	          case "ClassPrivateMethod":
    	            adjustInnerComments(node, node.params, commentWS);
    	            break;
    	          case "ArrayExpression":
    	          case "ArrayPattern":
    	          case "TupleExpression":
    	            adjustInnerComments(node, node.elements, commentWS);
    	            break;
    	          case "ExportNamedDeclaration":
    	          case "ImportDeclaration":
    	            adjustInnerComments(node, node.specifiers, commentWS);
    	            break;
    	          default:
    	            {
    	              setInnerComments(node, comments);
    	            }
    	        }
    	      } else {
    	        setInnerComments(node, comments);
    	      }
    	    }
    	  }
    	  finalizeRemainingComments() {
    	    const {
    	      commentStack
    	    } = this.state;
    	    for (let i = commentStack.length - 1; i >= 0; i--) {
    	      this.finalizeComment(commentStack[i]);
    	    }
    	    this.state.commentStack = [];
    	  }
    	  resetPreviousNodeTrailingComments(node) {
    	    const {
    	      commentStack
    	    } = this.state;
    	    const {
    	      length
    	    } = commentStack;
    	    if (length === 0) return;
    	    const commentWS = commentStack[length - 1];
    	    if (commentWS.leadingNode === node) {
    	      commentWS.leadingNode = null;
    	    }
    	  }
    	  resetPreviousIdentifierLeadingComments(node) {
    	    const {
    	      commentStack
    	    } = this.state;
    	    const {
    	      length
    	    } = commentStack;
    	    if (length === 0) return;
    	    if (commentStack[length - 1].trailingNode === node) {
    	      commentStack[length - 1].trailingNode = null;
    	    } else if (length >= 2 && commentStack[length - 2].trailingNode === node) {
    	      commentStack[length - 2].trailingNode = null;
    	    }
    	  }
    	  takeSurroundingComments(node, start, end) {
    	    const {
    	      commentStack
    	    } = this.state;
    	    const commentStackLength = commentStack.length;
    	    if (commentStackLength === 0) return;
    	    let i = commentStackLength - 1;
    	    for (; i >= 0; i--) {
    	      const commentWS = commentStack[i];
    	      const commentEnd = commentWS.end;
    	      const commentStart = commentWS.start;
    	      if (commentStart === end) {
    	        commentWS.leadingNode = node;
    	      } else if (commentEnd === start) {
    	        commentWS.trailingNode = node;
    	      } else if (commentEnd < start) {
    	        break;
    	      }
    	    }
    	  }
    	}
    	const lineBreak = /\r\n?|[\n\u2028\u2029]/;
    	const lineBreakG = new RegExp(lineBreak.source, "g");
    	function isNewLine(code) {
    	  switch (code) {
    	    case 10:
    	    case 13:
    	    case 8232:
    	    case 8233:
    	      return true;
    	    default:
    	      return false;
    	  }
    	}
    	const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    	const skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
    	const skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
    	function isWhitespace(code) {
    	  switch (code) {
    	    case 0x0009:
    	    case 0x000b:
    	    case 0x000c:
    	    case 32:
    	    case 160:
    	    case 5760:
    	    case 0x2000:
    	    case 0x2001:
    	    case 0x2002:
    	    case 0x2003:
    	    case 0x2004:
    	    case 0x2005:
    	    case 0x2006:
    	    case 0x2007:
    	    case 0x2008:
    	    case 0x2009:
    	    case 0x200a:
    	    case 0x202f:
    	    case 0x205f:
    	    case 0x3000:
    	    case 0xfeff:
    	      return true;
    	    default:
    	      return false;
    	  }
    	}
    	class State {
    	  constructor() {
    	    this.strict = void 0;
    	    this.curLine = void 0;
    	    this.lineStart = void 0;
    	    this.startLoc = void 0;
    	    this.endLoc = void 0;
    	    this.errors = [];
    	    this.potentialArrowAt = -1;
    	    this.noArrowAt = [];
    	    this.noArrowParamsConversionAt = [];
    	    this.maybeInArrowParameters = false;
    	    this.inType = false;
    	    this.noAnonFunctionType = false;
    	    this.hasFlowComment = false;
    	    this.isAmbientContext = false;
    	    this.inAbstractClass = false;
    	    this.inDisallowConditionalTypesContext = false;
    	    this.topicContext = {
    	      maxNumOfResolvableTopics: 0,
    	      maxTopicIndex: null
    	    };
    	    this.soloAwait = false;
    	    this.inFSharpPipelineDirectBody = false;
    	    this.labels = [];
    	    this.comments = [];
    	    this.commentStack = [];
    	    this.pos = 0;
    	    this.type = 139;
    	    this.value = null;
    	    this.start = 0;
    	    this.end = 0;
    	    this.lastTokEndLoc = null;
    	    this.lastTokStartLoc = null;
    	    this.lastTokStart = 0;
    	    this.context = [types.brace];
    	    this.canStartJSXElement = true;
    	    this.containsEsc = false;
    	    this.firstInvalidTemplateEscapePos = null;
    	    this.strictErrors = new Map();
    	    this.tokensLength = 0;
    	  }
    	  init({
    	    strictMode,
    	    sourceType,
    	    startLine,
    	    startColumn
    	  }) {
    	    this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
    	    this.curLine = startLine;
    	    this.lineStart = -startColumn;
    	    this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);
    	  }
    	  curPosition() {
    	    return new Position(this.curLine, this.pos - this.lineStart, this.pos);
    	  }
    	  clone(skipArrays) {
    	    const state = new State();
    	    const keys = Object.keys(this);
    	    for (let i = 0, length = keys.length; i < length; i++) {
    	      const key = keys[i];
    	      let val = this[key];
    	      if (!skipArrays && Array.isArray(val)) {
    	        val = val.slice();
    	      }
    	      state[key] = val;
    	    }
    	    return state;
    	  }
    	}
    	var _isDigit = function isDigit(code) {
    	  return code >= 48 && code <= 57;
    	};
    	const forbiddenNumericSeparatorSiblings = {
    	  decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    	  hex: new Set([46, 88, 95, 120])
    	};
    	const isAllowedNumericSeparatorSibling = {
    	  bin: ch => ch === 48 || ch === 49,
    	  oct: ch => ch >= 48 && ch <= 55,
    	  dec: ch => ch >= 48 && ch <= 57,
    	  hex: ch => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
    	};
    	function readStringContents(type, input, pos, lineStart, curLine, errors) {
    	  const initialPos = pos;
    	  const initialLineStart = lineStart;
    	  const initialCurLine = curLine;
    	  let out = "";
    	  let firstInvalidLoc = null;
    	  let chunkStart = pos;
    	  const {
    	    length
    	  } = input;
    	  for (;;) {
    	    if (pos >= length) {
    	      errors.unterminated(initialPos, initialLineStart, initialCurLine);
    	      out += input.slice(chunkStart, pos);
    	      break;
    	    }
    	    const ch = input.charCodeAt(pos);
    	    if (isStringEnd(type, ch, input, pos)) {
    	      out += input.slice(chunkStart, pos);
    	      break;
    	    }
    	    if (ch === 92) {
    	      out += input.slice(chunkStart, pos);
    	      const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
    	      if (res.ch === null && !firstInvalidLoc) {
    	        firstInvalidLoc = {
    	          pos,
    	          lineStart,
    	          curLine
    	        };
    	      } else {
    	        out += res.ch;
    	      }
    	      ({
    	        pos,
    	        lineStart,
    	        curLine
    	      } = res);
    	      chunkStart = pos;
    	    } else if (ch === 8232 || ch === 8233) {
    	      ++pos;
    	      ++curLine;
    	      lineStart = pos;
    	    } else if (ch === 10 || ch === 13) {
    	      if (type === "template") {
    	        out += input.slice(chunkStart, pos) + "\n";
    	        ++pos;
    	        if (ch === 13 && input.charCodeAt(pos) === 10) {
    	          ++pos;
    	        }
    	        ++curLine;
    	        chunkStart = lineStart = pos;
    	      } else {
    	        errors.unterminated(initialPos, initialLineStart, initialCurLine);
    	      }
    	    } else {
    	      ++pos;
    	    }
    	  }
    	  return {
    	    pos,
    	    str: out,
    	    firstInvalidLoc,
    	    lineStart,
    	    curLine,
    	    containsInvalid: !!firstInvalidLoc
    	  };
    	}
    	function isStringEnd(type, ch, input, pos) {
    	  if (type === "template") {
    	    return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
    	  }
    	  return ch === (type === "double" ? 34 : 39);
    	}
    	function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
    	  const throwOnInvalid = !inTemplate;
    	  pos++;
    	  const res = ch => ({
    	    pos,
    	    ch,
    	    lineStart,
    	    curLine
    	  });
    	  const ch = input.charCodeAt(pos++);
    	  switch (ch) {
    	    case 110:
    	      return res("\n");
    	    case 114:
    	      return res("\r");
    	    case 120:
    	      {
    	        let code;
    	        ({
    	          code,
    	          pos
    	        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
    	        return res(code === null ? null : String.fromCharCode(code));
    	      }
    	    case 117:
    	      {
    	        let code;
    	        ({
    	          code,
    	          pos
    	        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
    	        return res(code === null ? null : String.fromCodePoint(code));
    	      }
    	    case 116:
    	      return res("\t");
    	    case 98:
    	      return res("\b");
    	    case 118:
    	      return res("\u000b");
    	    case 102:
    	      return res("\f");
    	    case 13:
    	      if (input.charCodeAt(pos) === 10) {
    	        ++pos;
    	      }
    	    case 10:
    	      lineStart = pos;
    	      ++curLine;
    	    case 8232:
    	    case 8233:
    	      return res("");
    	    case 56:
    	    case 57:
    	      if (inTemplate) {
    	        return res(null);
    	      } else {
    	        errors.strictNumericEscape(pos - 1, lineStart, curLine);
    	      }
    	    default:
    	      if (ch >= 48 && ch <= 55) {
    	        const startPos = pos - 1;
    	        const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
    	        let octalStr = match[0];
    	        let octal = parseInt(octalStr, 8);
    	        if (octal > 255) {
    	          octalStr = octalStr.slice(0, -1);
    	          octal = parseInt(octalStr, 8);
    	        }
    	        pos += octalStr.length - 1;
    	        const next = input.charCodeAt(pos);
    	        if (octalStr !== "0" || next === 56 || next === 57) {
    	          if (inTemplate) {
    	            return res(null);
    	          } else {
    	            errors.strictNumericEscape(startPos, lineStart, curLine);
    	          }
    	        }
    	        return res(String.fromCharCode(octal));
    	      }
    	      return res(String.fromCharCode(ch));
    	  }
    	}
    	function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
    	  const initialPos = pos;
    	  let n;
    	  ({
    	    n,
    	    pos
    	  } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
    	  if (n === null) {
    	    if (throwOnInvalid) {
    	      errors.invalidEscapeSequence(initialPos, lineStart, curLine);
    	    } else {
    	      pos = initialPos - 1;
    	    }
    	  }
    	  return {
    	    code: n,
    	    pos
    	  };
    	}
    	function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
    	  const start = pos;
    	  const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
    	  const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
    	  let invalid = false;
    	  let total = 0;
    	  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
    	    const code = input.charCodeAt(pos);
    	    let val;
    	    if (code === 95 && allowNumSeparator !== "bail") {
    	      const prev = input.charCodeAt(pos - 1);
    	      const next = input.charCodeAt(pos + 1);
    	      if (!allowNumSeparator) {
    	        if (bailOnError) return {
    	          n: null,
    	          pos
    	        };
    	        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
    	      } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
    	        if (bailOnError) return {
    	          n: null,
    	          pos
    	        };
    	        errors.unexpectedNumericSeparator(pos, lineStart, curLine);
    	      }
    	      ++pos;
    	      continue;
    	    }
    	    if (code >= 97) {
    	      val = code - 97 + 10;
    	    } else if (code >= 65) {
    	      val = code - 65 + 10;
    	    } else if (_isDigit(code)) {
    	      val = code - 48;
    	    } else {
    	      val = Infinity;
    	    }
    	    if (val >= radix) {
    	      if (val <= 9 && bailOnError) {
    	        return {
    	          n: null,
    	          pos
    	        };
    	      } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
    	        val = 0;
    	      } else if (forceLen) {
    	        val = 0;
    	        invalid = true;
    	      } else {
    	        break;
    	      }
    	    }
    	    ++pos;
    	    total = total * radix + val;
    	  }
    	  if (pos === start || len != null && pos - start !== len || invalid) {
    	    return {
    	      n: null,
    	      pos
    	    };
    	  }
    	  return {
    	    n: total,
    	    pos
    	  };
    	}
    	function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
    	  const ch = input.charCodeAt(pos);
    	  let code;
    	  if (ch === 123) {
    	    ++pos;
    	    ({
    	      code,
    	      pos
    	    } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
    	    ++pos;
    	    if (code !== null && code > 0x10ffff) {
    	      if (throwOnInvalid) {
    	        errors.invalidCodePoint(pos, lineStart, curLine);
    	      } else {
    	        return {
    	          code: null,
    	          pos
    	        };
    	      }
    	    }
    	  } else {
    	    ({
    	      code,
    	      pos
    	    } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
    	  }
    	  return {
    	    code,
    	    pos
    	  };
    	}
    	const _excluded = ["at"],
    	  _excluded2 = ["at"];
    	function buildPosition(pos, lineStart, curLine) {
    	  return new Position(curLine, pos - lineStart, pos);
    	}
    	const VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100, 118]);
    	class Token {
    	  constructor(state) {
    	    this.type = state.type;
    	    this.value = state.value;
    	    this.start = state.start;
    	    this.end = state.end;
    	    this.loc = new SourceLocation(state.startLoc, state.endLoc);
    	  }
    	}
    	class Tokenizer extends CommentsParser {
    	  constructor(options, input) {
    	    super();
    	    this.isLookahead = void 0;
    	    this.tokens = [];
    	    this.errorHandlers_readInt = {
    	      invalidDigit: (pos, lineStart, curLine, radix) => {
    	        if (!this.options.errorRecovery) return false;
    	        this.raise(Errors.InvalidDigit, {
    	          at: buildPosition(pos, lineStart, curLine),
    	          radix
    	        });
    	        return true;
    	      },
    	      numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
    	      unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
    	    };
    	    this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
    	      invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
    	      invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
    	    });
    	    this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
    	      strictNumericEscape: (pos, lineStart, curLine) => {
    	        this.recordStrictModeErrors(Errors.StrictNumericEscape, {
    	          at: buildPosition(pos, lineStart, curLine)
    	        });
    	      },
    	      unterminated: (pos, lineStart, curLine) => {
    	        throw this.raise(Errors.UnterminatedString, {
    	          at: buildPosition(pos - 1, lineStart, curLine)
    	        });
    	      }
    	    });
    	    this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
    	      strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
    	      unterminated: (pos, lineStart, curLine) => {
    	        throw this.raise(Errors.UnterminatedTemplate, {
    	          at: buildPosition(pos, lineStart, curLine)
    	        });
    	      }
    	    });
    	    this.state = new State();
    	    this.state.init(options);
    	    this.input = input;
    	    this.length = input.length;
    	    this.isLookahead = false;
    	  }
    	  pushToken(token) {
    	    this.tokens.length = this.state.tokensLength;
    	    this.tokens.push(token);
    	    ++this.state.tokensLength;
    	  }
    	  next() {
    	    this.checkKeywordEscapes();
    	    if (this.options.tokens) {
    	      this.pushToken(new Token(this.state));
    	    }
    	    this.state.lastTokStart = this.state.start;
    	    this.state.lastTokEndLoc = this.state.endLoc;
    	    this.state.lastTokStartLoc = this.state.startLoc;
    	    this.nextToken();
    	  }
    	  eat(type) {
    	    if (this.match(type)) {
    	      this.next();
    	      return true;
    	    } else {
    	      return false;
    	    }
    	  }
    	  match(type) {
    	    return this.state.type === type;
    	  }
    	  createLookaheadState(state) {
    	    return {
    	      pos: state.pos,
    	      value: null,
    	      type: state.type,
    	      start: state.start,
    	      end: state.end,
    	      context: [this.curContext()],
    	      inType: state.inType,
    	      startLoc: state.startLoc,
    	      lastTokEndLoc: state.lastTokEndLoc,
    	      curLine: state.curLine,
    	      lineStart: state.lineStart,
    	      curPosition: state.curPosition
    	    };
    	  }
    	  lookahead() {
    	    const old = this.state;
    	    this.state = this.createLookaheadState(old);
    	    this.isLookahead = true;
    	    this.nextToken();
    	    this.isLookahead = false;
    	    const curr = this.state;
    	    this.state = old;
    	    return curr;
    	  }
    	  nextTokenStart() {
    	    return this.nextTokenStartSince(this.state.pos);
    	  }
    	  nextTokenStartSince(pos) {
    	    skipWhiteSpace.lastIndex = pos;
    	    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
    	  }
    	  lookaheadCharCode() {
    	    return this.input.charCodeAt(this.nextTokenStart());
    	  }
    	  nextTokenInLineStart() {
    	    return this.nextTokenInLineStartSince(this.state.pos);
    	  }
    	  nextTokenInLineStartSince(pos) {
    	    skipWhiteSpaceInLine.lastIndex = pos;
    	    return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
    	  }
    	  lookaheadInLineCharCode() {
    	    return this.input.charCodeAt(this.nextTokenInLineStart());
    	  }
    	  codePointAtPos(pos) {
    	    let cp = this.input.charCodeAt(pos);
    	    if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {
    	      const trail = this.input.charCodeAt(pos);
    	      if ((trail & 0xfc00) === 0xdc00) {
    	        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);
    	      }
    	    }
    	    return cp;
    	  }
    	  setStrict(strict) {
    	    this.state.strict = strict;
    	    if (strict) {
    	      this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, {
    	        at
    	      }));
    	      this.state.strictErrors.clear();
    	    }
    	  }
    	  curContext() {
    	    return this.state.context[this.state.context.length - 1];
    	  }
    	  nextToken() {
    	    this.skipSpace();
    	    this.state.start = this.state.pos;
    	    if (!this.isLookahead) this.state.startLoc = this.state.curPosition();
    	    if (this.state.pos >= this.length) {
    	      this.finishToken(139);
    	      return;
    	    }
    	    this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    	  }
    	  skipBlockComment(commentEnd) {
    	    let startLoc;
    	    if (!this.isLookahead) startLoc = this.state.curPosition();
    	    const start = this.state.pos;
    	    const end = this.input.indexOf(commentEnd, start + 2);
    	    if (end === -1) {
    	      throw this.raise(Errors.UnterminatedComment, {
    	        at: this.state.curPosition()
    	      });
    	    }
    	    this.state.pos = end + commentEnd.length;
    	    lineBreakG.lastIndex = start + 2;
    	    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
    	      ++this.state.curLine;
    	      this.state.lineStart = lineBreakG.lastIndex;
    	    }
    	    if (this.isLookahead) return;
    	    const comment = {
    	      type: "CommentBlock",
    	      value: this.input.slice(start + 2, end),
    	      start,
    	      end: end + commentEnd.length,
    	      loc: new SourceLocation(startLoc, this.state.curPosition())
    	    };
    	    if (this.options.tokens) this.pushToken(comment);
    	    return comment;
    	  }
    	  skipLineComment(startSkip) {
    	    const start = this.state.pos;
    	    let startLoc;
    	    if (!this.isLookahead) startLoc = this.state.curPosition();
    	    let ch = this.input.charCodeAt(this.state.pos += startSkip);
    	    if (this.state.pos < this.length) {
    	      while (!isNewLine(ch) && ++this.state.pos < this.length) {
    	        ch = this.input.charCodeAt(this.state.pos);
    	      }
    	    }
    	    if (this.isLookahead) return;
    	    const end = this.state.pos;
    	    const value = this.input.slice(start + startSkip, end);
    	    const comment = {
    	      type: "CommentLine",
    	      value,
    	      start,
    	      end,
    	      loc: new SourceLocation(startLoc, this.state.curPosition())
    	    };
    	    if (this.options.tokens) this.pushToken(comment);
    	    return comment;
    	  }
    	  skipSpace() {
    	    const spaceStart = this.state.pos;
    	    const comments = [];
    	    loop: while (this.state.pos < this.length) {
    	      const ch = this.input.charCodeAt(this.state.pos);
    	      switch (ch) {
    	        case 32:
    	        case 160:
    	        case 9:
    	          ++this.state.pos;
    	          break;
    	        case 13:
    	          if (this.input.charCodeAt(this.state.pos + 1) === 10) {
    	            ++this.state.pos;
    	          }
    	        case 10:
    	        case 8232:
    	        case 8233:
    	          ++this.state.pos;
    	          ++this.state.curLine;
    	          this.state.lineStart = this.state.pos;
    	          break;
    	        case 47:
    	          switch (this.input.charCodeAt(this.state.pos + 1)) {
    	            case 42:
    	              {
    	                const comment = this.skipBlockComment("*/");
    	                if (comment !== undefined) {
    	                  this.addComment(comment);
    	                  if (this.options.attachComment) comments.push(comment);
    	                }
    	                break;
    	              }
    	            case 47:
    	              {
    	                const comment = this.skipLineComment(2);
    	                if (comment !== undefined) {
    	                  this.addComment(comment);
    	                  if (this.options.attachComment) comments.push(comment);
    	                }
    	                break;
    	              }
    	            default:
    	              break loop;
    	          }
    	          break;
    	        default:
    	          if (isWhitespace(ch)) {
    	            ++this.state.pos;
    	          } else if (ch === 45 && !this.inModule && this.options.annexB) {
    	            const pos = this.state.pos;
    	            if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
    	              const comment = this.skipLineComment(3);
    	              if (comment !== undefined) {
    	                this.addComment(comment);
    	                if (this.options.attachComment) comments.push(comment);
    	              }
    	            } else {
    	              break loop;
    	            }
    	          } else if (ch === 60 && !this.inModule && this.options.annexB) {
    	            const pos = this.state.pos;
    	            if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
    	              const comment = this.skipLineComment(4);
    	              if (comment !== undefined) {
    	                this.addComment(comment);
    	                if (this.options.attachComment) comments.push(comment);
    	              }
    	            } else {
    	              break loop;
    	            }
    	          } else {
    	            break loop;
    	          }
    	      }
    	    }
    	    if (comments.length > 0) {
    	      const end = this.state.pos;
    	      const commentWhitespace = {
    	        start: spaceStart,
    	        end,
    	        comments,
    	        leadingNode: null,
    	        trailingNode: null,
    	        containingNode: null
    	      };
    	      this.state.commentStack.push(commentWhitespace);
    	    }
    	  }
    	  finishToken(type, val) {
    	    this.state.end = this.state.pos;
    	    this.state.endLoc = this.state.curPosition();
    	    const prevType = this.state.type;
    	    this.state.type = type;
    	    this.state.value = val;
    	    if (!this.isLookahead) {
    	      this.updateContext(prevType);
    	    }
    	  }
    	  replaceToken(type) {
    	    this.state.type = type;
    	    this.updateContext();
    	  }
    	  readToken_numberSign() {
    	    if (this.state.pos === 0 && this.readToken_interpreter()) {
    	      return;
    	    }
    	    const nextPos = this.state.pos + 1;
    	    const next = this.codePointAtPos(nextPos);
    	    if (next >= 48 && next <= 57) {
    	      throw this.raise(Errors.UnexpectedDigitAfterHash, {
    	        at: this.state.curPosition()
    	      });
    	    }
    	    if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
    	      this.expectPlugin("recordAndTuple");
    	      if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
    	        throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, {
    	          at: this.state.curPosition()
    	        });
    	      }
    	      this.state.pos += 2;
    	      if (next === 123) {
    	        this.finishToken(7);
    	      } else {
    	        this.finishToken(1);
    	      }
    	    } else if (isIdentifierStart(next)) {
    	      ++this.state.pos;
    	      this.finishToken(138, this.readWord1(next));
    	    } else if (next === 92) {
    	      ++this.state.pos;
    	      this.finishToken(138, this.readWord1());
    	    } else {
    	      this.finishOp(27, 1);
    	    }
    	  }
    	  readToken_dot() {
    	    const next = this.input.charCodeAt(this.state.pos + 1);
    	    if (next >= 48 && next <= 57) {
    	      this.readNumber(true);
    	      return;
    	    }
    	    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
    	      this.state.pos += 3;
    	      this.finishToken(21);
    	    } else {
    	      ++this.state.pos;
    	      this.finishToken(16);
    	    }
    	  }
    	  readToken_slash() {
    	    const next = this.input.charCodeAt(this.state.pos + 1);
    	    if (next === 61) {
    	      this.finishOp(31, 2);
    	    } else {
    	      this.finishOp(56, 1);
    	    }
    	  }
    	  readToken_interpreter() {
    	    if (this.state.pos !== 0 || this.length < 2) return false;
    	    let ch = this.input.charCodeAt(this.state.pos + 1);
    	    if (ch !== 33) return false;
    	    const start = this.state.pos;
    	    this.state.pos += 1;
    	    while (!isNewLine(ch) && ++this.state.pos < this.length) {
    	      ch = this.input.charCodeAt(this.state.pos);
    	    }
    	    const value = this.input.slice(start + 2, this.state.pos);
    	    this.finishToken(28, value);
    	    return true;
    	  }
    	  readToken_mult_modulo(code) {
    	    let type = code === 42 ? 55 : 54;
    	    let width = 1;
    	    let next = this.input.charCodeAt(this.state.pos + 1);
    	    if (code === 42 && next === 42) {
    	      width++;
    	      next = this.input.charCodeAt(this.state.pos + 2);
    	      type = 57;
    	    }
    	    if (next === 61 && !this.state.inType) {
    	      width++;
    	      type = code === 37 ? 33 : 30;
    	    }
    	    this.finishOp(type, width);
    	  }
    	  readToken_pipe_amp(code) {
    	    const next = this.input.charCodeAt(this.state.pos + 1);
    	    if (next === code) {
    	      if (this.input.charCodeAt(this.state.pos + 2) === 61) {
    	        this.finishOp(30, 3);
    	      } else {
    	        this.finishOp(code === 124 ? 41 : 42, 2);
    	      }
    	      return;
    	    }
    	    if (code === 124) {
    	      if (next === 62) {
    	        this.finishOp(39, 2);
    	        return;
    	      }
    	      if (this.hasPlugin("recordAndTuple") && next === 125) {
    	        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
    	          throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {
    	            at: this.state.curPosition()
    	          });
    	        }
    	        this.state.pos += 2;
    	        this.finishToken(9);
    	        return;
    	      }
    	      if (this.hasPlugin("recordAndTuple") && next === 93) {
    	        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
    	          throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {
    	            at: this.state.curPosition()
    	          });
    	        }
    	        this.state.pos += 2;
    	        this.finishToken(4);
    	        return;
    	      }
    	    }
    	    if (next === 61) {
    	      this.finishOp(30, 2);
    	      return;
    	    }
    	    this.finishOp(code === 124 ? 43 : 45, 1);
    	  }
    	  readToken_caret() {
    	    const next = this.input.charCodeAt(this.state.pos + 1);
    	    if (next === 61 && !this.state.inType) {
    	      this.finishOp(32, 2);
    	    } else if (next === 94 && this.hasPlugin(["pipelineOperator", {
    	      proposal: "hack",
    	      topicToken: "^^"
    	    }])) {
    	      this.finishOp(37, 2);
    	      const lookaheadCh = this.input.codePointAt(this.state.pos);
    	      if (lookaheadCh === 94) {
    	        this.unexpected();
    	      }
    	    } else {
    	      this.finishOp(44, 1);
    	    }
    	  }
    	  readToken_atSign() {
    	    const next = this.input.charCodeAt(this.state.pos + 1);
    	    if (next === 64 && this.hasPlugin(["pipelineOperator", {
    	      proposal: "hack",
    	      topicToken: "@@"
    	    }])) {
    	      this.finishOp(38, 2);
    	    } else {
    	      this.finishOp(26, 1);
    	    }
    	  }
    	  readToken_plus_min(code) {
    	    const next = this.input.charCodeAt(this.state.pos + 1);
    	    if (next === code) {
    	      this.finishOp(34, 2);
    	      return;
    	    }
    	    if (next === 61) {
    	      this.finishOp(30, 2);
    	    } else {
    	      this.finishOp(53, 1);
    	    }
    	  }
    	  readToken_lt() {
    	    const {
    	      pos
    	    } = this.state;
    	    const next = this.input.charCodeAt(pos + 1);
    	    if (next === 60) {
    	      if (this.input.charCodeAt(pos + 2) === 61) {
    	        this.finishOp(30, 3);
    	        return;
    	      }
    	      this.finishOp(51, 2);
    	      return;
    	    }
    	    if (next === 61) {
    	      this.finishOp(49, 2);
    	      return;
    	    }
    	    this.finishOp(47, 1);
    	  }
    	  readToken_gt() {
    	    const {
    	      pos
    	    } = this.state;
    	    const next = this.input.charCodeAt(pos + 1);
    	    if (next === 62) {
    	      const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
    	      if (this.input.charCodeAt(pos + size) === 61) {
    	        this.finishOp(30, size + 1);
    	        return;
    	      }
    	      this.finishOp(52, size);
    	      return;
    	    }
    	    if (next === 61) {
    	      this.finishOp(49, 2);
    	      return;
    	    }
    	    this.finishOp(48, 1);
    	  }
    	  readToken_eq_excl(code) {
    	    const next = this.input.charCodeAt(this.state.pos + 1);
    	    if (next === 61) {
    	      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
    	      return;
    	    }
    	    if (code === 61 && next === 62) {
    	      this.state.pos += 2;
    	      this.finishToken(19);
    	      return;
    	    }
    	    this.finishOp(code === 61 ? 29 : 35, 1);
    	  }
    	  readToken_question() {
    	    const next = this.input.charCodeAt(this.state.pos + 1);
    	    const next2 = this.input.charCodeAt(this.state.pos + 2);
    	    if (next === 63) {
    	      if (next2 === 61) {
    	        this.finishOp(30, 3);
    	      } else {
    	        this.finishOp(40, 2);
    	      }
    	    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
    	      this.state.pos += 2;
    	      this.finishToken(18);
    	    } else {
    	      ++this.state.pos;
    	      this.finishToken(17);
    	    }
    	  }
    	  getTokenFromCode(code) {
    	    switch (code) {
    	      case 46:
    	        this.readToken_dot();
    	        return;
    	      case 40:
    	        ++this.state.pos;
    	        this.finishToken(10);
    	        return;
    	      case 41:
    	        ++this.state.pos;
    	        this.finishToken(11);
    	        return;
    	      case 59:
    	        ++this.state.pos;
    	        this.finishToken(13);
    	        return;
    	      case 44:
    	        ++this.state.pos;
    	        this.finishToken(12);
    	        return;
    	      case 91:
    	        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
    	          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
    	            throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, {
    	              at: this.state.curPosition()
    	            });
    	          }
    	          this.state.pos += 2;
    	          this.finishToken(2);
    	        } else {
    	          ++this.state.pos;
    	          this.finishToken(0);
    	        }
    	        return;
    	      case 93:
    	        ++this.state.pos;
    	        this.finishToken(3);
    	        return;
    	      case 123:
    	        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
    	          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
    	            throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, {
    	              at: this.state.curPosition()
    	            });
    	          }
    	          this.state.pos += 2;
    	          this.finishToken(6);
    	        } else {
    	          ++this.state.pos;
    	          this.finishToken(5);
    	        }
    	        return;
    	      case 125:
    	        ++this.state.pos;
    	        this.finishToken(8);
    	        return;
    	      case 58:
    	        if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
    	          this.finishOp(15, 2);
    	        } else {
    	          ++this.state.pos;
    	          this.finishToken(14);
    	        }
    	        return;
    	      case 63:
    	        this.readToken_question();
    	        return;
    	      case 96:
    	        this.readTemplateToken();
    	        return;
    	      case 48:
    	        {
    	          const next = this.input.charCodeAt(this.state.pos + 1);
    	          if (next === 120 || next === 88) {
    	            this.readRadixNumber(16);
    	            return;
    	          }
    	          if (next === 111 || next === 79) {
    	            this.readRadixNumber(8);
    	            return;
    	          }
    	          if (next === 98 || next === 66) {
    	            this.readRadixNumber(2);
    	            return;
    	          }
    	        }
    	      case 49:
    	      case 50:
    	      case 51:
    	      case 52:
    	      case 53:
    	      case 54:
    	      case 55:
    	      case 56:
    	      case 57:
    	        this.readNumber(false);
    	        return;
    	      case 34:
    	      case 39:
    	        this.readString(code);
    	        return;
    	      case 47:
    	        this.readToken_slash();
    	        return;
    	      case 37:
    	      case 42:
    	        this.readToken_mult_modulo(code);
    	        return;
    	      case 124:
    	      case 38:
    	        this.readToken_pipe_amp(code);
    	        return;
    	      case 94:
    	        this.readToken_caret();
    	        return;
    	      case 43:
    	      case 45:
    	        this.readToken_plus_min(code);
    	        return;
    	      case 60:
    	        this.readToken_lt();
    	        return;
    	      case 62:
    	        this.readToken_gt();
    	        return;
    	      case 61:
    	      case 33:
    	        this.readToken_eq_excl(code);
    	        return;
    	      case 126:
    	        this.finishOp(36, 1);
    	        return;
    	      case 64:
    	        this.readToken_atSign();
    	        return;
    	      case 35:
    	        this.readToken_numberSign();
    	        return;
    	      case 92:
    	        this.readWord();
    	        return;
    	      default:
    	        if (isIdentifierStart(code)) {
    	          this.readWord(code);
    	          return;
    	        }
    	    }
    	    throw this.raise(Errors.InvalidOrUnexpectedToken, {
    	      at: this.state.curPosition(),
    	      unexpected: String.fromCodePoint(code)
    	    });
    	  }
    	  finishOp(type, size) {
    	    const str = this.input.slice(this.state.pos, this.state.pos + size);
    	    this.state.pos += size;
    	    this.finishToken(type, str);
    	  }
    	  readRegexp() {
    	    const startLoc = this.state.startLoc;
    	    const start = this.state.start + 1;
    	    let escaped, inClass;
    	    let {
    	      pos
    	    } = this.state;
    	    for (;; ++pos) {
    	      if (pos >= this.length) {
    	        throw this.raise(Errors.UnterminatedRegExp, {
    	          at: createPositionWithColumnOffset(startLoc, 1)
    	        });
    	      }
    	      const ch = this.input.charCodeAt(pos);
    	      if (isNewLine(ch)) {
    	        throw this.raise(Errors.UnterminatedRegExp, {
    	          at: createPositionWithColumnOffset(startLoc, 1)
    	        });
    	      }
    	      if (escaped) {
    	        escaped = false;
    	      } else {
    	        if (ch === 91) {
    	          inClass = true;
    	        } else if (ch === 93 && inClass) {
    	          inClass = false;
    	        } else if (ch === 47 && !inClass) {
    	          break;
    	        }
    	        escaped = ch === 92;
    	      }
    	    }
    	    const content = this.input.slice(start, pos);
    	    ++pos;
    	    let mods = "";
    	    const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
    	    while (pos < this.length) {
    	      const cp = this.codePointAtPos(pos);
    	      const char = String.fromCharCode(cp);
    	      if (VALID_REGEX_FLAGS.has(cp)) {
    	        if (cp === 118) {
    	          if (mods.includes("u")) {
    	            this.raise(Errors.IncompatibleRegExpUVFlags, {
    	              at: nextPos()
    	            });
    	          }
    	        } else if (cp === 117) {
    	          if (mods.includes("v")) {
    	            this.raise(Errors.IncompatibleRegExpUVFlags, {
    	              at: nextPos()
    	            });
    	          }
    	        }
    	        if (mods.includes(char)) {
    	          this.raise(Errors.DuplicateRegExpFlags, {
    	            at: nextPos()
    	          });
    	        }
    	      } else if (isIdentifierChar(cp) || cp === 92) {
    	        this.raise(Errors.MalformedRegExpFlags, {
    	          at: nextPos()
    	        });
    	      } else {
    	        break;
    	      }
    	      ++pos;
    	      mods += char;
    	    }
    	    this.state.pos = pos;
    	    this.finishToken(137, {
    	      pattern: content,
    	      flags: mods
    	    });
    	  }
    	  readInt(radix, len, forceLen = false, allowNumSeparator = true) {
    	    const {
    	      n,
    	      pos
    	    } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);
    	    this.state.pos = pos;
    	    return n;
    	  }
    	  readRadixNumber(radix) {
    	    const startLoc = this.state.curPosition();
    	    let isBigInt = false;
    	    this.state.pos += 2;
    	    const val = this.readInt(radix);
    	    if (val == null) {
    	      this.raise(Errors.InvalidDigit, {
    	        at: createPositionWithColumnOffset(startLoc, 2),
    	        radix
    	      });
    	    }
    	    const next = this.input.charCodeAt(this.state.pos);
    	    if (next === 110) {
    	      ++this.state.pos;
    	      isBigInt = true;
    	    } else if (next === 109) {
    	      throw this.raise(Errors.InvalidDecimal, {
    	        at: startLoc
    	      });
    	    }
    	    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
    	      throw this.raise(Errors.NumberIdentifier, {
    	        at: this.state.curPosition()
    	      });
    	    }
    	    if (isBigInt) {
    	      const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, "");
    	      this.finishToken(135, str);
    	      return;
    	    }
    	    this.finishToken(134, val);
    	  }
    	  readNumber(startsWithDot) {
    	    const start = this.state.pos;
    	    const startLoc = this.state.curPosition();
    	    let isFloat = false;
    	    let isBigInt = false;
    	    let isDecimal = false;
    	    let hasExponent = false;
    	    let isOctal = false;
    	    if (!startsWithDot && this.readInt(10) === null) {
    	      this.raise(Errors.InvalidNumber, {
    	        at: this.state.curPosition()
    	      });
    	    }
    	    const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
    	    if (hasLeadingZero) {
    	      const integer = this.input.slice(start, this.state.pos);
    	      this.recordStrictModeErrors(Errors.StrictOctalLiteral, {
    	        at: startLoc
    	      });
    	      if (!this.state.strict) {
    	        const underscorePos = integer.indexOf("_");
    	        if (underscorePos > 0) {
    	          this.raise(Errors.ZeroDigitNumericSeparator, {
    	            at: createPositionWithColumnOffset(startLoc, underscorePos)
    	          });
    	        }
    	      }
    	      isOctal = hasLeadingZero && !/[89]/.test(integer);
    	    }
    	    let next = this.input.charCodeAt(this.state.pos);
    	    if (next === 46 && !isOctal) {
    	      ++this.state.pos;
    	      this.readInt(10);
    	      isFloat = true;
    	      next = this.input.charCodeAt(this.state.pos);
    	    }
    	    if ((next === 69 || next === 101) && !isOctal) {
    	      next = this.input.charCodeAt(++this.state.pos);
    	      if (next === 43 || next === 45) {
    	        ++this.state.pos;
    	      }
    	      if (this.readInt(10) === null) {
    	        this.raise(Errors.InvalidOrMissingExponent, {
    	          at: startLoc
    	        });
    	      }
    	      isFloat = true;
    	      hasExponent = true;
    	      next = this.input.charCodeAt(this.state.pos);
    	    }
    	    if (next === 110) {
    	      if (isFloat || hasLeadingZero) {
    	        this.raise(Errors.InvalidBigIntLiteral, {
    	          at: startLoc
    	        });
    	      }
    	      ++this.state.pos;
    	      isBigInt = true;
    	    }
    	    if (next === 109) {
    	      this.expectPlugin("decimal", this.state.curPosition());
    	      if (hasExponent || hasLeadingZero) {
    	        this.raise(Errors.InvalidDecimal, {
    	          at: startLoc
    	        });
    	      }
    	      ++this.state.pos;
    	      isDecimal = true;
    	    }
    	    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
    	      throw this.raise(Errors.NumberIdentifier, {
    	        at: this.state.curPosition()
    	      });
    	    }
    	    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
    	    if (isBigInt) {
    	      this.finishToken(135, str);
    	      return;
    	    }
    	    if (isDecimal) {
    	      this.finishToken(136, str);
    	      return;
    	    }
    	    const val = isOctal ? parseInt(str, 8) : parseFloat(str);
    	    this.finishToken(134, val);
    	  }
    	  readCodePoint(throwOnInvalid) {
    	    const {
    	      code,
    	      pos
    	    } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
    	    this.state.pos = pos;
    	    return code;
    	  }
    	  readString(quote) {
    	    const {
    	      str,
    	      pos,
    	      curLine,
    	      lineStart
    	    } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
    	    this.state.pos = pos + 1;
    	    this.state.lineStart = lineStart;
    	    this.state.curLine = curLine;
    	    this.finishToken(133, str);
    	  }
    	  readTemplateContinuation() {
    	    if (!this.match(8)) {
    	      this.unexpected(null, 8);
    	    }
    	    this.state.pos--;
    	    this.readTemplateToken();
    	  }
    	  readTemplateToken() {
    	    const opening = this.input[this.state.pos];
    	    const {
    	      str,
    	      firstInvalidLoc,
    	      pos,
    	      curLine,
    	      lineStart
    	    } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
    	    this.state.pos = pos + 1;
    	    this.state.lineStart = lineStart;
    	    this.state.curLine = curLine;
    	    if (firstInvalidLoc) {
    	      this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, firstInvalidLoc.pos);
    	    }
    	    if (this.input.codePointAt(pos) === 96) {
    	      this.finishToken(24, firstInvalidLoc ? null : opening + str + "`");
    	    } else {
    	      this.state.pos++;
    	      this.finishToken(25, firstInvalidLoc ? null : opening + str + "${");
    	    }
    	  }
    	  recordStrictModeErrors(toParseError, {
    	    at
    	  }) {
    	    const index = at.index;
    	    if (this.state.strict && !this.state.strictErrors.has(index)) {
    	      this.raise(toParseError, {
    	        at
    	      });
    	    } else {
    	      this.state.strictErrors.set(index, [toParseError, at]);
    	    }
    	  }
    	  readWord1(firstCode) {
    	    this.state.containsEsc = false;
    	    let word = "";
    	    const start = this.state.pos;
    	    let chunkStart = this.state.pos;
    	    if (firstCode !== undefined) {
    	      this.state.pos += firstCode <= 0xffff ? 1 : 2;
    	    }
    	    while (this.state.pos < this.length) {
    	      const ch = this.codePointAtPos(this.state.pos);
    	      if (isIdentifierChar(ch)) {
    	        this.state.pos += ch <= 0xffff ? 1 : 2;
    	      } else if (ch === 92) {
    	        this.state.containsEsc = true;
    	        word += this.input.slice(chunkStart, this.state.pos);
    	        const escStart = this.state.curPosition();
    	        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
    	        if (this.input.charCodeAt(++this.state.pos) !== 117) {
    	          this.raise(Errors.MissingUnicodeEscape, {
    	            at: this.state.curPosition()
    	          });
    	          chunkStart = this.state.pos - 1;
    	          continue;
    	        }
    	        ++this.state.pos;
    	        const esc = this.readCodePoint(true);
    	        if (esc !== null) {
    	          if (!identifierCheck(esc)) {
    	            this.raise(Errors.EscapedCharNotAnIdentifier, {
    	              at: escStart
    	            });
    	          }
    	          word += String.fromCodePoint(esc);
    	        }
    	        chunkStart = this.state.pos;
    	      } else {
    	        break;
    	      }
    	    }
    	    return word + this.input.slice(chunkStart, this.state.pos);
    	  }
    	  readWord(firstCode) {
    	    const word = this.readWord1(firstCode);
    	    const type = keywords$1.get(word);
    	    if (type !== undefined) {
    	      this.finishToken(type, tokenLabelName(type));
    	    } else {
    	      this.finishToken(132, word);
    	    }
    	  }
    	  checkKeywordEscapes() {
    	    const {
    	      type
    	    } = this.state;
    	    if (tokenIsKeyword(type) && this.state.containsEsc) {
    	      this.raise(Errors.InvalidEscapedReservedWord, {
    	        at: this.state.startLoc,
    	        reservedWord: tokenLabelName(type)
    	      });
    	    }
    	  }
    	  raise(toParseError, raiseProperties) {
    	    const {
    	        at
    	      } = raiseProperties,
    	      details = _objectWithoutPropertiesLoose(raiseProperties, _excluded);
    	    const loc = at instanceof Position ? at : at.loc.start;
    	    const error = toParseError({
    	      loc,
    	      details
    	    });
    	    if (!this.options.errorRecovery) throw error;
    	    if (!this.isLookahead) this.state.errors.push(error);
    	    return error;
    	  }
    	  raiseOverwrite(toParseError, raiseProperties) {
    	    const {
    	        at
    	      } = raiseProperties,
    	      details = _objectWithoutPropertiesLoose(raiseProperties, _excluded2);
    	    const loc = at instanceof Position ? at : at.loc.start;
    	    const pos = loc.index;
    	    const errors = this.state.errors;
    	    for (let i = errors.length - 1; i >= 0; i--) {
    	      const error = errors[i];
    	      if (error.loc.index === pos) {
    	        return errors[i] = toParseError({
    	          loc,
    	          details
    	        });
    	      }
    	      if (error.loc.index < pos) break;
    	    }
    	    return this.raise(toParseError, raiseProperties);
    	  }
    	  updateContext(prevType) {}
    	  unexpected(loc, type) {
    	    throw this.raise(Errors.UnexpectedToken, {
    	      expected: type ? tokenLabelName(type) : null,
    	      at: loc != null ? loc : this.state.startLoc
    	    });
    	  }
    	  expectPlugin(pluginName, loc) {
    	    if (this.hasPlugin(pluginName)) {
    	      return true;
    	    }
    	    throw this.raise(Errors.MissingPlugin, {
    	      at: loc != null ? loc : this.state.startLoc,
    	      missingPlugin: [pluginName]
    	    });
    	  }
    	  expectOnePlugin(pluginNames) {
    	    if (!pluginNames.some(name => this.hasPlugin(name))) {
    	      throw this.raise(Errors.MissingOneOfPlugins, {
    	        at: this.state.startLoc,
    	        missingPlugin: pluginNames
    	      });
    	    }
    	  }
    	  errorBuilder(error) {
    	    return (pos, lineStart, curLine) => {
    	      this.raise(error, {
    	        at: buildPosition(pos, lineStart, curLine)
    	      });
    	    };
    	  }
    	}
    	class ClassScope {
    	  constructor() {
    	    this.privateNames = new Set();
    	    this.loneAccessors = new Map();
    	    this.undefinedPrivateNames = new Map();
    	  }
    	}
    	class ClassScopeHandler {
    	  constructor(parser) {
    	    this.parser = void 0;
    	    this.stack = [];
    	    this.undefinedPrivateNames = new Map();
    	    this.parser = parser;
    	  }
    	  current() {
    	    return this.stack[this.stack.length - 1];
    	  }
    	  enter() {
    	    this.stack.push(new ClassScope());
    	  }
    	  exit() {
    	    const oldClassScope = this.stack.pop();
    	    const current = this.current();
    	    for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
    	      if (current) {
    	        if (!current.undefinedPrivateNames.has(name)) {
    	          current.undefinedPrivateNames.set(name, loc);
    	        }
    	      } else {
    	        this.parser.raise(Errors.InvalidPrivateFieldResolution, {
    	          at: loc,
    	          identifierName: name
    	        });
    	      }
    	    }
    	  }
    	  declarePrivateName(name, elementType, loc) {
    	    const {
    	      privateNames,
    	      loneAccessors,
    	      undefinedPrivateNames
    	    } = this.current();
    	    let redefined = privateNames.has(name);
    	    if (elementType & 3) {
    	      const accessor = redefined && loneAccessors.get(name);
    	      if (accessor) {
    	        const oldStatic = accessor & 4;
    	        const newStatic = elementType & 4;
    	        const oldKind = accessor & 3;
    	        const newKind = elementType & 3;
    	        redefined = oldKind === newKind || oldStatic !== newStatic;
    	        if (!redefined) loneAccessors.delete(name);
    	      } else if (!redefined) {
    	        loneAccessors.set(name, elementType);
    	      }
    	    }
    	    if (redefined) {
    	      this.parser.raise(Errors.PrivateNameRedeclaration, {
    	        at: loc,
    	        identifierName: name
    	      });
    	    }
    	    privateNames.add(name);
    	    undefinedPrivateNames.delete(name);
    	  }
    	  usePrivateName(name, loc) {
    	    let classScope;
    	    for (classScope of this.stack) {
    	      if (classScope.privateNames.has(name)) return;
    	    }
    	    if (classScope) {
    	      classScope.undefinedPrivateNames.set(name, loc);
    	    } else {
    	      this.parser.raise(Errors.InvalidPrivateFieldResolution, {
    	        at: loc,
    	        identifierName: name
    	      });
    	    }
    	  }
    	}
    	class ExpressionScope {
    	  constructor(type = 0) {
    	    this.type = type;
    	  }
    	  canBeArrowParameterDeclaration() {
    	    return this.type === 2 || this.type === 1;
    	  }
    	  isCertainlyParameterDeclaration() {
    	    return this.type === 3;
    	  }
    	}
    	class ArrowHeadParsingScope extends ExpressionScope {
    	  constructor(type) {
    	    super(type);
    	    this.declarationErrors = new Map();
    	  }
    	  recordDeclarationError(ParsingErrorClass, {
    	    at
    	  }) {
    	    const index = at.index;
    	    this.declarationErrors.set(index, [ParsingErrorClass, at]);
    	  }
    	  clearDeclarationError(index) {
    	    this.declarationErrors.delete(index);
    	  }
    	  iterateErrors(iterator) {
    	    this.declarationErrors.forEach(iterator);
    	  }
    	}
    	class ExpressionScopeHandler {
    	  constructor(parser) {
    	    this.parser = void 0;
    	    this.stack = [new ExpressionScope()];
    	    this.parser = parser;
    	  }
    	  enter(scope) {
    	    this.stack.push(scope);
    	  }
    	  exit() {
    	    this.stack.pop();
    	  }
    	  recordParameterInitializerError(toParseError, {
    	    at: node
    	  }) {
    	    const origin = {
    	      at: node.loc.start
    	    };
    	    const {
    	      stack
    	    } = this;
    	    let i = stack.length - 1;
    	    let scope = stack[i];
    	    while (!scope.isCertainlyParameterDeclaration()) {
    	      if (scope.canBeArrowParameterDeclaration()) {
    	        scope.recordDeclarationError(toParseError, origin);
    	      } else {
    	        return;
    	      }
    	      scope = stack[--i];
    	    }
    	    this.parser.raise(toParseError, origin);
    	  }
    	  recordArrowParameterBindingError(error, {
    	    at: node
    	  }) {
    	    const {
    	      stack
    	    } = this;
    	    const scope = stack[stack.length - 1];
    	    const origin = {
    	      at: node.loc.start
    	    };
    	    if (scope.isCertainlyParameterDeclaration()) {
    	      this.parser.raise(error, origin);
    	    } else if (scope.canBeArrowParameterDeclaration()) {
    	      scope.recordDeclarationError(error, origin);
    	    } else {
    	      return;
    	    }
    	  }
    	  recordAsyncArrowParametersError({
    	    at
    	  }) {
    	    const {
    	      stack
    	    } = this;
    	    let i = stack.length - 1;
    	    let scope = stack[i];
    	    while (scope.canBeArrowParameterDeclaration()) {
    	      if (scope.type === 2) {
    	        scope.recordDeclarationError(Errors.AwaitBindingIdentifier, {
    	          at
    	        });
    	      }
    	      scope = stack[--i];
    	    }
    	  }
    	  validateAsPattern() {
    	    const {
    	      stack
    	    } = this;
    	    const currentScope = stack[stack.length - 1];
    	    if (!currentScope.canBeArrowParameterDeclaration()) return;
    	    currentScope.iterateErrors(([toParseError, loc]) => {
    	      this.parser.raise(toParseError, {
    	        at: loc
    	      });
    	      let i = stack.length - 2;
    	      let scope = stack[i];
    	      while (scope.canBeArrowParameterDeclaration()) {
    	        scope.clearDeclarationError(loc.index);
    	        scope = stack[--i];
    	      }
    	    });
    	  }
    	}
    	function newParameterDeclarationScope() {
    	  return new ExpressionScope(3);
    	}
    	function newArrowHeadScope() {
    	  return new ArrowHeadParsingScope(1);
    	}
    	function newAsyncArrowScope() {
    	  return new ArrowHeadParsingScope(2);
    	}
    	function newExpressionScope() {
    	  return new ExpressionScope();
    	}
    	const PARAM = 0b0000,
    	  PARAM_YIELD = 0b0001,
    	  PARAM_AWAIT = 0b0010,
    	  PARAM_RETURN = 0b0100,
    	  PARAM_IN = 0b1000;
    	class ProductionParameterHandler {
    	  constructor() {
    	    this.stacks = [];
    	  }
    	  enter(flags) {
    	    this.stacks.push(flags);
    	  }
    	  exit() {
    	    this.stacks.pop();
    	  }
    	  currentFlags() {
    	    return this.stacks[this.stacks.length - 1];
    	  }
    	  get hasAwait() {
    	    return (this.currentFlags() & PARAM_AWAIT) > 0;
    	  }
    	  get hasYield() {
    	    return (this.currentFlags() & PARAM_YIELD) > 0;
    	  }
    	  get hasReturn() {
    	    return (this.currentFlags() & PARAM_RETURN) > 0;
    	  }
    	  get hasIn() {
    	    return (this.currentFlags() & PARAM_IN) > 0;
    	  }
    	}
    	function functionFlags(isAsync, isGenerator) {
    	  return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
    	}
    	class UtilParser extends Tokenizer {
    	  addExtra(node, key, value, enumerable = true) {
    	    if (!node) return;
    	    const extra = node.extra = node.extra || {};
    	    if (enumerable) {
    	      extra[key] = value;
    	    } else {
    	      Object.defineProperty(extra, key, {
    	        enumerable,
    	        value
    	      });
    	    }
    	  }
    	  isContextual(token) {
    	    return this.state.type === token && !this.state.containsEsc;
    	  }
    	  isUnparsedContextual(nameStart, name) {
    	    const nameEnd = nameStart + name.length;
    	    if (this.input.slice(nameStart, nameEnd) === name) {
    	      const nextCh = this.input.charCodeAt(nameEnd);
    	      return !(isIdentifierChar(nextCh) || (nextCh & 0xfc00) === 0xd800);
    	    }
    	    return false;
    	  }
    	  isLookaheadContextual(name) {
    	    const next = this.nextTokenStart();
    	    return this.isUnparsedContextual(next, name);
    	  }
    	  eatContextual(token) {
    	    if (this.isContextual(token)) {
    	      this.next();
    	      return true;
    	    }
    	    return false;
    	  }
    	  expectContextual(token, toParseError) {
    	    if (!this.eatContextual(token)) {
    	      if (toParseError != null) {
    	        throw this.raise(toParseError, {
    	          at: this.state.startLoc
    	        });
    	      }
    	      this.unexpected(null, token);
    	    }
    	  }
    	  canInsertSemicolon() {
    	    return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
    	  }
    	  hasPrecedingLineBreak() {
    	    return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    	  }
    	  hasFollowingLineBreak() {
    	    skipWhiteSpaceToLineBreak.lastIndex = this.state.end;
    	    return skipWhiteSpaceToLineBreak.test(this.input);
    	  }
    	  isLineTerminator() {
    	    return this.eat(13) || this.canInsertSemicolon();
    	  }
    	  semicolon(allowAsi = true) {
    	    if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;
    	    this.raise(Errors.MissingSemicolon, {
    	      at: this.state.lastTokEndLoc
    	    });
    	  }
    	  expect(type, loc) {
    	    this.eat(type) || this.unexpected(loc, type);
    	  }
    	  tryParse(fn, oldState = this.state.clone()) {
    	    const abortSignal = {
    	      node: null
    	    };
    	    try {
    	      const node = fn((node = null) => {
    	        abortSignal.node = node;
    	        throw abortSignal;
    	      });
    	      if (this.state.errors.length > oldState.errors.length) {
    	        const failState = this.state;
    	        this.state = oldState;
    	        this.state.tokensLength = failState.tokensLength;
    	        return {
    	          node,
    	          error: failState.errors[oldState.errors.length],
    	          thrown: false,
    	          aborted: false,
    	          failState
    	        };
    	      }
    	      return {
    	        node,
    	        error: null,
    	        thrown: false,
    	        aborted: false,
    	        failState: null
    	      };
    	    } catch (error) {
    	      const failState = this.state;
    	      this.state = oldState;
    	      if (error instanceof SyntaxError) {
    	        return {
    	          node: null,
    	          error,
    	          thrown: true,
    	          aborted: false,
    	          failState
    	        };
    	      }
    	      if (error === abortSignal) {
    	        return {
    	          node: abortSignal.node,
    	          error: null,
    	          thrown: false,
    	          aborted: true,
    	          failState
    	        };
    	      }
    	      throw error;
    	    }
    	  }
    	  checkExpressionErrors(refExpressionErrors, andThrow) {
    	    if (!refExpressionErrors) return false;
    	    const {
    	      shorthandAssignLoc,
    	      doubleProtoLoc,
    	      privateKeyLoc,
    	      optionalParametersLoc
    	    } = refExpressionErrors;
    	    const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
    	    if (!andThrow) {
    	      return hasErrors;
    	    }
    	    if (shorthandAssignLoc != null) {
    	      this.raise(Errors.InvalidCoverInitializedName, {
    	        at: shorthandAssignLoc
    	      });
    	    }
    	    if (doubleProtoLoc != null) {
    	      this.raise(Errors.DuplicateProto, {
    	        at: doubleProtoLoc
    	      });
    	    }
    	    if (privateKeyLoc != null) {
    	      this.raise(Errors.UnexpectedPrivateField, {
    	        at: privateKeyLoc
    	      });
    	    }
    	    if (optionalParametersLoc != null) {
    	      this.unexpected(optionalParametersLoc);
    	    }
    	  }
    	  isLiteralPropertyName() {
    	    return tokenIsLiteralPropertyName(this.state.type);
    	  }
    	  isPrivateName(node) {
    	    return node.type === "PrivateName";
    	  }
    	  getPrivateNameSV(node) {
    	    return node.id.name;
    	  }
    	  hasPropertyAsPrivateName(node) {
    	    return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
    	  }
    	  isObjectProperty(node) {
    	    return node.type === "ObjectProperty";
    	  }
    	  isObjectMethod(node) {
    	    return node.type === "ObjectMethod";
    	  }
    	  initializeScopes(inModule = this.options.sourceType === "module") {
    	    const oldLabels = this.state.labels;
    	    this.state.labels = [];
    	    const oldExportedIdentifiers = this.exportedIdentifiers;
    	    this.exportedIdentifiers = new Set();
    	    const oldInModule = this.inModule;
    	    this.inModule = inModule;
    	    const oldScope = this.scope;
    	    const ScopeHandler = this.getScopeHandler();
    	    this.scope = new ScopeHandler(this, inModule);
    	    const oldProdParam = this.prodParam;
    	    this.prodParam = new ProductionParameterHandler();
    	    const oldClassScope = this.classScope;
    	    this.classScope = new ClassScopeHandler(this);
    	    const oldExpressionScope = this.expressionScope;
    	    this.expressionScope = new ExpressionScopeHandler(this);
    	    return () => {
    	      this.state.labels = oldLabels;
    	      this.exportedIdentifiers = oldExportedIdentifiers;
    	      this.inModule = oldInModule;
    	      this.scope = oldScope;
    	      this.prodParam = oldProdParam;
    	      this.classScope = oldClassScope;
    	      this.expressionScope = oldExpressionScope;
    	    };
    	  }
    	  enterInitialScopes() {
    	    let paramFlags = PARAM;
    	    if (this.inModule) {
    	      paramFlags |= PARAM_AWAIT;
    	    }
    	    this.scope.enter(1);
    	    this.prodParam.enter(paramFlags);
    	  }
    	  checkDestructuringPrivate(refExpressionErrors) {
    	    const {
    	      privateKeyLoc
    	    } = refExpressionErrors;
    	    if (privateKeyLoc !== null) {
    	      this.expectPlugin("destructuringPrivate", privateKeyLoc);
    	    }
    	  }
    	}
    	class ExpressionErrors {
    	  constructor() {
    	    this.shorthandAssignLoc = null;
    	    this.doubleProtoLoc = null;
    	    this.privateKeyLoc = null;
    	    this.optionalParametersLoc = null;
    	  }
    	}
    	class Node {
    	  constructor(parser, pos, loc) {
    	    this.type = "";
    	    this.start = pos;
    	    this.end = 0;
    	    this.loc = new SourceLocation(loc);
    	    if (parser != null && parser.options.ranges) this.range = [pos, 0];
    	    if (parser != null && parser.filename) this.loc.filename = parser.filename;
    	  }
    	}
    	const NodePrototype = Node.prototype;
    	{
    	  NodePrototype.__clone = function () {
    	    const newNode = new Node(undefined, this.start, this.loc.start);
    	    const keys = Object.keys(this);
    	    for (let i = 0, length = keys.length; i < length; i++) {
    	      const key = keys[i];
    	      if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
    	        newNode[key] = this[key];
    	      }
    	    }
    	    return newNode;
    	  };
    	}
    	function clonePlaceholder(node) {
    	  return cloneIdentifier(node);
    	}
    	function cloneIdentifier(node) {
    	  const {
    	    type,
    	    start,
    	    end,
    	    loc,
    	    range,
    	    extra,
    	    name
    	  } = node;
    	  const cloned = Object.create(NodePrototype);
    	  cloned.type = type;
    	  cloned.start = start;
    	  cloned.end = end;
    	  cloned.loc = loc;
    	  cloned.range = range;
    	  cloned.extra = extra;
    	  cloned.name = name;
    	  if (type === "Placeholder") {
    	    cloned.expectedNode = node.expectedNode;
    	  }
    	  return cloned;
    	}
    	function cloneStringLiteral(node) {
    	  const {
    	    type,
    	    start,
    	    end,
    	    loc,
    	    range,
    	    extra
    	  } = node;
    	  if (type === "Placeholder") {
    	    return clonePlaceholder(node);
    	  }
    	  const cloned = Object.create(NodePrototype);
    	  cloned.type = type;
    	  cloned.start = start;
    	  cloned.end = end;
    	  cloned.loc = loc;
    	  cloned.range = range;
    	  if (node.raw !== undefined) {
    	    cloned.raw = node.raw;
    	  } else {
    	    cloned.extra = extra;
    	  }
    	  cloned.value = node.value;
    	  return cloned;
    	}
    	class NodeUtils extends UtilParser {
    	  startNode() {
    	    return new Node(this, this.state.start, this.state.startLoc);
    	  }
    	  startNodeAt(loc) {
    	    return new Node(this, loc.index, loc);
    	  }
    	  startNodeAtNode(type) {
    	    return this.startNodeAt(type.loc.start);
    	  }
    	  finishNode(node, type) {
    	    return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
    	  }
    	  finishNodeAt(node, type, endLoc) {
    	    node.type = type;
    	    node.end = endLoc.index;
    	    node.loc.end = endLoc;
    	    if (this.options.ranges) node.range[1] = endLoc.index;
    	    if (this.options.attachComment) this.processComment(node);
    	    return node;
    	  }
    	  resetStartLocation(node, startLoc) {
    	    node.start = startLoc.index;
    	    node.loc.start = startLoc;
    	    if (this.options.ranges) node.range[0] = startLoc.index;
    	  }
    	  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
    	    node.end = endLoc.index;
    	    node.loc.end = endLoc;
    	    if (this.options.ranges) node.range[1] = endLoc.index;
    	  }
    	  resetStartLocationFromNode(node, locationNode) {
    	    this.resetStartLocation(node, locationNode.loc.start);
    	  }
    	}
    	const reservedTypes = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
    	const FlowErrors = ParseErrorEnum`flow`({
    	  AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    	  AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
    	  AssignReservedType: ({
    	    reservedType
    	  }) => `Cannot overwrite reserved type ${reservedType}.`,
    	  DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    	  DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    	  DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    	  EnumBooleanMemberNotInitialized: ({
    	    memberName,
    	    enumName
    	  }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
    	  EnumDuplicateMemberName: ({
    	    memberName,
    	    enumName
    	  }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
    	  EnumInconsistentMemberValues: ({
    	    enumName
    	  }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
    	  EnumInvalidExplicitType: ({
    	    invalidEnumType,
    	    enumName
    	  }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
    	  EnumInvalidExplicitTypeUnknownSupplied: ({
    	    enumName
    	  }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
    	  EnumInvalidMemberInitializerPrimaryType: ({
    	    enumName,
    	    memberName,
    	    explicitType
    	  }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
    	  EnumInvalidMemberInitializerSymbolType: ({
    	    enumName,
    	    memberName
    	  }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
    	  EnumInvalidMemberInitializerUnknownType: ({
    	    enumName,
    	    memberName
    	  }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
    	  EnumInvalidMemberName: ({
    	    enumName,
    	    memberName,
    	    suggestion
    	  }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
    	  EnumNumberMemberNotInitialized: ({
    	    enumName,
    	    memberName
    	  }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
    	  EnumStringMemberInconsistentlyInitialized: ({
    	    enumName
    	  }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
    	  GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    	  ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    	  ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
    	  InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    	  InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    	  InexactVariance: "Explicit inexact syntax cannot have variance.",
    	  InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    	  MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    	  NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    	  NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    	  PatternIsOptional: Object.assign({
    	    message: "A binding pattern parameter cannot be optional in an implementation signature."
    	  }, {
    	    reasonCode: "OptionalBindingPattern"
    	  }),
    	  SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    	  SpreadVariance: "Spread properties cannot have variance.",
    	  ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    	  ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    	  ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    	  ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    	  ThisParamNoDefault: "The `this` parameter may not have a default value.",
    	  TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    	  TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    	  UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    	  UnexpectedReservedType: ({
    	    reservedType
    	  }) => `Unexpected reserved type ${reservedType}.`,
    	  UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    	  UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    	  UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    	  UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    	  UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    	  UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
    	  UnsupportedDeclareExportKind: ({
    	    unsupportedExportKind,
    	    suggestion
    	  }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
    	  UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    	  UnterminatedFlowComment: "Unterminated flow-comment."
    	});
    	function isEsModuleType(bodyElement) {
    	  return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
    	}
    	function hasTypeImportKind(node) {
    	  return node.importKind === "type" || node.importKind === "typeof";
    	}
    	const exportSuggestions = {
    	  const: "declare export var",
    	  let: "declare export var",
    	  type: "export type",
    	  interface: "export interface"
    	};
    	function partition(list, test) {
    	  const list1 = [];
    	  const list2 = [];
    	  for (let i = 0; i < list.length; i++) {
    	    (test(list[i], i, list) ? list1 : list2).push(list[i]);
    	  }
    	  return [list1, list2];
    	}
    	const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
    	var flow = superClass => class FlowParserMixin extends superClass {
    	  constructor(...args) {
    	    super(...args);
    	    this.flowPragma = undefined;
    	  }
    	  getScopeHandler() {
    	    return FlowScopeHandler;
    	  }
    	  shouldParseTypes() {
    	    return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    	  }
    	  shouldParseEnums() {
    	    return !!this.getPluginOption("flow", "enums");
    	  }
    	  finishToken(type, val) {
    	    if (type !== 133 && type !== 13 && type !== 28) {
    	      if (this.flowPragma === undefined) {
    	        this.flowPragma = null;
    	      }
    	    }
    	    super.finishToken(type, val);
    	  }
    	  addComment(comment) {
    	    if (this.flowPragma === undefined) {
    	      const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
    	      if (!matches) ;else if (matches[1] === "flow") {
    	        this.flowPragma = "flow";
    	      } else if (matches[1] === "noflow") {
    	        this.flowPragma = "noflow";
    	      } else {
    	        throw new Error("Unexpected flow pragma");
    	      }
    	    }
    	    super.addComment(comment);
    	  }
    	  flowParseTypeInitialiser(tok) {
    	    const oldInType = this.state.inType;
    	    this.state.inType = true;
    	    this.expect(tok || 14);
    	    const type = this.flowParseType();
    	    this.state.inType = oldInType;
    	    return type;
    	  }
    	  flowParsePredicate() {
    	    const node = this.startNode();
    	    const moduloLoc = this.state.startLoc;
    	    this.next();
    	    this.expectContextual(110);
    	    if (this.state.lastTokStart > moduloLoc.index + 1) {
    	      this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {
    	        at: moduloLoc
    	      });
    	    }
    	    if (this.eat(10)) {
    	      node.value = super.parseExpression();
    	      this.expect(11);
    	      return this.finishNode(node, "DeclaredPredicate");
    	    } else {
    	      return this.finishNode(node, "InferredPredicate");
    	    }
    	  }
    	  flowParseTypeAndPredicateInitialiser() {
    	    const oldInType = this.state.inType;
    	    this.state.inType = true;
    	    this.expect(14);
    	    let type = null;
    	    let predicate = null;
    	    if (this.match(54)) {
    	      this.state.inType = oldInType;
    	      predicate = this.flowParsePredicate();
    	    } else {
    	      type = this.flowParseType();
    	      this.state.inType = oldInType;
    	      if (this.match(54)) {
    	        predicate = this.flowParsePredicate();
    	      }
    	    }
    	    return [type, predicate];
    	  }
    	  flowParseDeclareClass(node) {
    	    this.next();
    	    this.flowParseInterfaceish(node, true);
    	    return this.finishNode(node, "DeclareClass");
    	  }
    	  flowParseDeclareFunction(node) {
    	    this.next();
    	    const id = node.id = this.parseIdentifier();
    	    const typeNode = this.startNode();
    	    const typeContainer = this.startNode();
    	    if (this.match(47)) {
    	      typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
    	    } else {
    	      typeNode.typeParameters = null;
    	    }
    	    this.expect(10);
    	    const tmp = this.flowParseFunctionTypeParams();
    	    typeNode.params = tmp.params;
    	    typeNode.rest = tmp.rest;
    	    typeNode.this = tmp._this;
    	    this.expect(11);
    	    [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
    	    typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
    	    id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
    	    this.resetEndLocation(id);
    	    this.semicolon();
    	    this.scope.declareName(node.id.name, 2048, node.id.loc.start);
    	    return this.finishNode(node, "DeclareFunction");
    	  }
    	  flowParseDeclare(node, insideModule) {
    	    if (this.match(80)) {
    	      return this.flowParseDeclareClass(node);
    	    } else if (this.match(68)) {
    	      return this.flowParseDeclareFunction(node);
    	    } else if (this.match(74)) {
    	      return this.flowParseDeclareVariable(node);
    	    } else if (this.eatContextual(127)) {
    	      if (this.match(16)) {
    	        return this.flowParseDeclareModuleExports(node);
    	      } else {
    	        if (insideModule) {
    	          this.raise(FlowErrors.NestedDeclareModule, {
    	            at: this.state.lastTokStartLoc
    	          });
    	        }
    	        return this.flowParseDeclareModule(node);
    	      }
    	    } else if (this.isContextual(130)) {
    	      return this.flowParseDeclareTypeAlias(node);
    	    } else if (this.isContextual(131)) {
    	      return this.flowParseDeclareOpaqueType(node);
    	    } else if (this.isContextual(129)) {
    	      return this.flowParseDeclareInterface(node);
    	    } else if (this.match(82)) {
    	      return this.flowParseDeclareExportDeclaration(node, insideModule);
    	    } else {
    	      this.unexpected();
    	    }
    	  }
    	  flowParseDeclareVariable(node) {
    	    this.next();
    	    node.id = this.flowParseTypeAnnotatableIdentifier(true);
    	    this.scope.declareName(node.id.name, 5, node.id.loc.start);
    	    this.semicolon();
    	    return this.finishNode(node, "DeclareVariable");
    	  }
    	  flowParseDeclareModule(node) {
    	    this.scope.enter(0);
    	    if (this.match(133)) {
    	      node.id = super.parseExprAtom();
    	    } else {
    	      node.id = this.parseIdentifier();
    	    }
    	    const bodyNode = node.body = this.startNode();
    	    const body = bodyNode.body = [];
    	    this.expect(5);
    	    while (!this.match(8)) {
    	      let bodyNode = this.startNode();
    	      if (this.match(83)) {
    	        this.next();
    	        if (!this.isContextual(130) && !this.match(87)) {
    	          this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {
    	            at: this.state.lastTokStartLoc
    	          });
    	        }
    	        super.parseImport(bodyNode);
    	      } else {
    	        this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);
    	        bodyNode = this.flowParseDeclare(bodyNode, true);
    	      }
    	      body.push(bodyNode);
    	    }
    	    this.scope.exit();
    	    this.expect(8);
    	    this.finishNode(bodyNode, "BlockStatement");
    	    let kind = null;
    	    let hasModuleExport = false;
    	    body.forEach(bodyElement => {
    	      if (isEsModuleType(bodyElement)) {
    	        if (kind === "CommonJS") {
    	          this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
    	            at: bodyElement
    	          });
    	        }
    	        kind = "ES";
    	      } else if (bodyElement.type === "DeclareModuleExports") {
    	        if (hasModuleExport) {
    	          this.raise(FlowErrors.DuplicateDeclareModuleExports, {
    	            at: bodyElement
    	          });
    	        }
    	        if (kind === "ES") {
    	          this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
    	            at: bodyElement
    	          });
    	        }
    	        kind = "CommonJS";
    	        hasModuleExport = true;
    	      }
    	    });
    	    node.kind = kind || "CommonJS";
    	    return this.finishNode(node, "DeclareModule");
    	  }
    	  flowParseDeclareExportDeclaration(node, insideModule) {
    	    this.expect(82);
    	    if (this.eat(65)) {
    	      if (this.match(68) || this.match(80)) {
    	        node.declaration = this.flowParseDeclare(this.startNode());
    	      } else {
    	        node.declaration = this.flowParseType();
    	        this.semicolon();
    	      }
    	      node.default = true;
    	      return this.finishNode(node, "DeclareExportDeclaration");
    	    } else {
    	      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {
    	        const label = this.state.value;
    	        throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {
    	          at: this.state.startLoc,
    	          unsupportedExportKind: label,
    	          suggestion: exportSuggestions[label]
    	        });
    	      }
    	      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {
    	        node.declaration = this.flowParseDeclare(this.startNode());
    	        node.default = false;
    	        return this.finishNode(node, "DeclareExportDeclaration");
    	      } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {
    	        node = this.parseExport(node, null);
    	        if (node.type === "ExportNamedDeclaration") {
    	          node.type = "ExportDeclaration";
    	          node.default = false;
    	          delete node.exportKind;
    	        }
    	        node.type = "Declare" + node.type;
    	        return node;
    	      }
    	    }
    	    this.unexpected();
    	  }
    	  flowParseDeclareModuleExports(node) {
    	    this.next();
    	    this.expectContextual(111);
    	    node.typeAnnotation = this.flowParseTypeAnnotation();
    	    this.semicolon();
    	    return this.finishNode(node, "DeclareModuleExports");
    	  }
    	  flowParseDeclareTypeAlias(node) {
    	    this.next();
    	    const finished = this.flowParseTypeAlias(node);
    	    finished.type = "DeclareTypeAlias";
    	    return finished;
    	  }
    	  flowParseDeclareOpaqueType(node) {
    	    this.next();
    	    const finished = this.flowParseOpaqueType(node, true);
    	    finished.type = "DeclareOpaqueType";
    	    return finished;
    	  }
    	  flowParseDeclareInterface(node) {
    	    this.next();
    	    this.flowParseInterfaceish(node, false);
    	    return this.finishNode(node, "DeclareInterface");
    	  }
    	  flowParseInterfaceish(node, isClass) {
    	    node.id = this.flowParseRestrictedIdentifier(!isClass, true);
    	    this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start);
    	    if (this.match(47)) {
    	      node.typeParameters = this.flowParseTypeParameterDeclaration();
    	    } else {
    	      node.typeParameters = null;
    	    }
    	    node.extends = [];
    	    if (this.eat(81)) {
    	      do {
    	        node.extends.push(this.flowParseInterfaceExtends());
    	      } while (!isClass && this.eat(12));
    	    }
    	    if (isClass) {
    	      node.implements = [];
    	      node.mixins = [];
    	      if (this.eatContextual(117)) {
    	        do {
    	          node.mixins.push(this.flowParseInterfaceExtends());
    	        } while (this.eat(12));
    	      }
    	      if (this.eatContextual(113)) {
    	        do {
    	          node.implements.push(this.flowParseInterfaceExtends());
    	        } while (this.eat(12));
    	      }
    	    }
    	    node.body = this.flowParseObjectType({
    	      allowStatic: isClass,
    	      allowExact: false,
    	      allowSpread: false,
    	      allowProto: isClass,
    	      allowInexact: false
    	    });
    	  }
    	  flowParseInterfaceExtends() {
    	    const node = this.startNode();
    	    node.id = this.flowParseQualifiedTypeIdentifier();
    	    if (this.match(47)) {
    	      node.typeParameters = this.flowParseTypeParameterInstantiation();
    	    } else {
    	      node.typeParameters = null;
    	    }
    	    return this.finishNode(node, "InterfaceExtends");
    	  }
    	  flowParseInterface(node) {
    	    this.flowParseInterfaceish(node, false);
    	    return this.finishNode(node, "InterfaceDeclaration");
    	  }
    	  checkNotUnderscore(word) {
    	    if (word === "_") {
    	      this.raise(FlowErrors.UnexpectedReservedUnderscore, {
    	        at: this.state.startLoc
    	      });
    	    }
    	  }
    	  checkReservedType(word, startLoc, declaration) {
    	    if (!reservedTypes.has(word)) return;
    	    this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, {
    	      at: startLoc,
    	      reservedType: word
    	    });
    	  }
    	  flowParseRestrictedIdentifier(liberal, declaration) {
    	    this.checkReservedType(this.state.value, this.state.startLoc, declaration);
    	    return this.parseIdentifier(liberal);
    	  }
    	  flowParseTypeAlias(node) {
    	    node.id = this.flowParseRestrictedIdentifier(false, true);
    	    this.scope.declareName(node.id.name, 8201, node.id.loc.start);
    	    if (this.match(47)) {
    	      node.typeParameters = this.flowParseTypeParameterDeclaration();
    	    } else {
    	      node.typeParameters = null;
    	    }
    	    node.right = this.flowParseTypeInitialiser(29);
    	    this.semicolon();
    	    return this.finishNode(node, "TypeAlias");
    	  }
    	  flowParseOpaqueType(node, declare) {
    	    this.expectContextual(130);
    	    node.id = this.flowParseRestrictedIdentifier(true, true);
    	    this.scope.declareName(node.id.name, 8201, node.id.loc.start);
    	    if (this.match(47)) {
    	      node.typeParameters = this.flowParseTypeParameterDeclaration();
    	    } else {
    	      node.typeParameters = null;
    	    }
    	    node.supertype = null;
    	    if (this.match(14)) {
    	      node.supertype = this.flowParseTypeInitialiser(14);
    	    }
    	    node.impltype = null;
    	    if (!declare) {
    	      node.impltype = this.flowParseTypeInitialiser(29);
    	    }
    	    this.semicolon();
    	    return this.finishNode(node, "OpaqueType");
    	  }
    	  flowParseTypeParameter(requireDefault = false) {
    	    const nodeStartLoc = this.state.startLoc;
    	    const node = this.startNode();
    	    const variance = this.flowParseVariance();
    	    const ident = this.flowParseTypeAnnotatableIdentifier();
    	    node.name = ident.name;
    	    node.variance = variance;
    	    node.bound = ident.typeAnnotation;
    	    if (this.match(29)) {
    	      this.eat(29);
    	      node.default = this.flowParseType();
    	    } else {
    	      if (requireDefault) {
    	        this.raise(FlowErrors.MissingTypeParamDefault, {
    	          at: nodeStartLoc
    	        });
    	      }
    	    }
    	    return this.finishNode(node, "TypeParameter");
    	  }
    	  flowParseTypeParameterDeclaration() {
    	    const oldInType = this.state.inType;
    	    const node = this.startNode();
    	    node.params = [];
    	    this.state.inType = true;
    	    if (this.match(47) || this.match(142)) {
    	      this.next();
    	    } else {
    	      this.unexpected();
    	    }
    	    let defaultRequired = false;
    	    do {
    	      const typeParameter = this.flowParseTypeParameter(defaultRequired);
    	      node.params.push(typeParameter);
    	      if (typeParameter.default) {
    	        defaultRequired = true;
    	      }
    	      if (!this.match(48)) {
    	        this.expect(12);
    	      }
    	    } while (!this.match(48));
    	    this.expect(48);
    	    this.state.inType = oldInType;
    	    return this.finishNode(node, "TypeParameterDeclaration");
    	  }
    	  flowParseTypeParameterInstantiation() {
    	    const node = this.startNode();
    	    const oldInType = this.state.inType;
    	    node.params = [];
    	    this.state.inType = true;
    	    this.expect(47);
    	    const oldNoAnonFunctionType = this.state.noAnonFunctionType;
    	    this.state.noAnonFunctionType = false;
    	    while (!this.match(48)) {
    	      node.params.push(this.flowParseType());
    	      if (!this.match(48)) {
    	        this.expect(12);
    	      }
    	    }
    	    this.state.noAnonFunctionType = oldNoAnonFunctionType;
    	    this.expect(48);
    	    this.state.inType = oldInType;
    	    return this.finishNode(node, "TypeParameterInstantiation");
    	  }
    	  flowParseTypeParameterInstantiationCallOrNew() {
    	    const node = this.startNode();
    	    const oldInType = this.state.inType;
    	    node.params = [];
    	    this.state.inType = true;
    	    this.expect(47);
    	    while (!this.match(48)) {
    	      node.params.push(this.flowParseTypeOrImplicitInstantiation());
    	      if (!this.match(48)) {
    	        this.expect(12);
    	      }
    	    }
    	    this.expect(48);
    	    this.state.inType = oldInType;
    	    return this.finishNode(node, "TypeParameterInstantiation");
    	  }
    	  flowParseInterfaceType() {
    	    const node = this.startNode();
    	    this.expectContextual(129);
    	    node.extends = [];
    	    if (this.eat(81)) {
    	      do {
    	        node.extends.push(this.flowParseInterfaceExtends());
    	      } while (this.eat(12));
    	    }
    	    node.body = this.flowParseObjectType({
    	      allowStatic: false,
    	      allowExact: false,
    	      allowSpread: false,
    	      allowProto: false,
    	      allowInexact: false
    	    });
    	    return this.finishNode(node, "InterfaceTypeAnnotation");
    	  }
    	  flowParseObjectPropertyKey() {
    	    return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(true);
    	  }
    	  flowParseObjectTypeIndexer(node, isStatic, variance) {
    	    node.static = isStatic;
    	    if (this.lookahead().type === 14) {
    	      node.id = this.flowParseObjectPropertyKey();
    	      node.key = this.flowParseTypeInitialiser();
    	    } else {
    	      node.id = null;
    	      node.key = this.flowParseType();
    	    }
    	    this.expect(3);
    	    node.value = this.flowParseTypeInitialiser();
    	    node.variance = variance;
    	    return this.finishNode(node, "ObjectTypeIndexer");
    	  }
    	  flowParseObjectTypeInternalSlot(node, isStatic) {
    	    node.static = isStatic;
    	    node.id = this.flowParseObjectPropertyKey();
    	    this.expect(3);
    	    this.expect(3);
    	    if (this.match(47) || this.match(10)) {
    	      node.method = true;
    	      node.optional = false;
    	      node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
    	    } else {
    	      node.method = false;
    	      if (this.eat(17)) {
    	        node.optional = true;
    	      }
    	      node.value = this.flowParseTypeInitialiser();
    	    }
    	    return this.finishNode(node, "ObjectTypeInternalSlot");
    	  }
    	  flowParseObjectTypeMethodish(node) {
    	    node.params = [];
    	    node.rest = null;
    	    node.typeParameters = null;
    	    node.this = null;
    	    if (this.match(47)) {
    	      node.typeParameters = this.flowParseTypeParameterDeclaration();
    	    }
    	    this.expect(10);
    	    if (this.match(78)) {
    	      node.this = this.flowParseFunctionTypeParam(true);
    	      node.this.name = null;
    	      if (!this.match(11)) {
    	        this.expect(12);
    	      }
    	    }
    	    while (!this.match(11) && !this.match(21)) {
    	      node.params.push(this.flowParseFunctionTypeParam(false));
    	      if (!this.match(11)) {
    	        this.expect(12);
    	      }
    	    }
    	    if (this.eat(21)) {
    	      node.rest = this.flowParseFunctionTypeParam(false);
    	    }
    	    this.expect(11);
    	    node.returnType = this.flowParseTypeInitialiser();
    	    return this.finishNode(node, "FunctionTypeAnnotation");
    	  }
    	  flowParseObjectTypeCallProperty(node, isStatic) {
    	    const valueNode = this.startNode();
    	    node.static = isStatic;
    	    node.value = this.flowParseObjectTypeMethodish(valueNode);
    	    return this.finishNode(node, "ObjectTypeCallProperty");
    	  }
    	  flowParseObjectType({
    	    allowStatic,
    	    allowExact,
    	    allowSpread,
    	    allowProto,
    	    allowInexact
    	  }) {
    	    const oldInType = this.state.inType;
    	    this.state.inType = true;
    	    const nodeStart = this.startNode();
    	    nodeStart.callProperties = [];
    	    nodeStart.properties = [];
    	    nodeStart.indexers = [];
    	    nodeStart.internalSlots = [];
    	    let endDelim;
    	    let exact;
    	    let inexact = false;
    	    if (allowExact && this.match(6)) {
    	      this.expect(6);
    	      endDelim = 9;
    	      exact = true;
    	    } else {
    	      this.expect(5);
    	      endDelim = 8;
    	      exact = false;
    	    }
    	    nodeStart.exact = exact;
    	    while (!this.match(endDelim)) {
    	      let isStatic = false;
    	      let protoStartLoc = null;
    	      let inexactStartLoc = null;
    	      const node = this.startNode();
    	      if (allowProto && this.isContextual(118)) {
    	        const lookahead = this.lookahead();
    	        if (lookahead.type !== 14 && lookahead.type !== 17) {
    	          this.next();
    	          protoStartLoc = this.state.startLoc;
    	          allowStatic = false;
    	        }
    	      }
    	      if (allowStatic && this.isContextual(106)) {
    	        const lookahead = this.lookahead();
    	        if (lookahead.type !== 14 && lookahead.type !== 17) {
    	          this.next();
    	          isStatic = true;
    	        }
    	      }
    	      const variance = this.flowParseVariance();
    	      if (this.eat(0)) {
    	        if (protoStartLoc != null) {
    	          this.unexpected(protoStartLoc);
    	        }
    	        if (this.eat(0)) {
    	          if (variance) {
    	            this.unexpected(variance.loc.start);
    	          }
    	          nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
    	        } else {
    	          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
    	        }
    	      } else if (this.match(10) || this.match(47)) {
    	        if (protoStartLoc != null) {
    	          this.unexpected(protoStartLoc);
    	        }
    	        if (variance) {
    	          this.unexpected(variance.loc.start);
    	        }
    	        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
    	      } else {
    	        let kind = "init";
    	        if (this.isContextual(99) || this.isContextual(104)) {
    	          const lookahead = this.lookahead();
    	          if (tokenIsLiteralPropertyName(lookahead.type)) {
    	            kind = this.state.value;
    	            this.next();
    	          }
    	        }
    	        const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
    	        if (propOrInexact === null) {
    	          inexact = true;
    	          inexactStartLoc = this.state.lastTokStartLoc;
    	        } else {
    	          nodeStart.properties.push(propOrInexact);
    	        }
    	      }
    	      this.flowObjectTypeSemicolon();
    	      if (inexactStartLoc && !this.match(8) && !this.match(9)) {
    	        this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {
    	          at: inexactStartLoc
    	        });
    	      }
    	    }
    	    this.expect(endDelim);
    	    if (allowSpread) {
    	      nodeStart.inexact = inexact;
    	    }
    	    const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
    	    this.state.inType = oldInType;
    	    return out;
    	  }
    	  flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
    	    if (this.eat(21)) {
    	      const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
    	      if (isInexactToken) {
    	        if (!allowSpread) {
    	          this.raise(FlowErrors.InexactInsideNonObject, {
    	            at: this.state.lastTokStartLoc
    	          });
    	        } else if (!allowInexact) {
    	          this.raise(FlowErrors.InexactInsideExact, {
    	            at: this.state.lastTokStartLoc
    	          });
    	        }
    	        if (variance) {
    	          this.raise(FlowErrors.InexactVariance, {
    	            at: variance
    	          });
    	        }
    	        return null;
    	      }
    	      if (!allowSpread) {
    	        this.raise(FlowErrors.UnexpectedSpreadType, {
    	          at: this.state.lastTokStartLoc
    	        });
    	      }
    	      if (protoStartLoc != null) {
    	        this.unexpected(protoStartLoc);
    	      }
    	      if (variance) {
    	        this.raise(FlowErrors.SpreadVariance, {
    	          at: variance
    	        });
    	      }
    	      node.argument = this.flowParseType();
    	      return this.finishNode(node, "ObjectTypeSpreadProperty");
    	    } else {
    	      node.key = this.flowParseObjectPropertyKey();
    	      node.static = isStatic;
    	      node.proto = protoStartLoc != null;
    	      node.kind = kind;
    	      let optional = false;
    	      if (this.match(47) || this.match(10)) {
    	        node.method = true;
    	        if (protoStartLoc != null) {
    	          this.unexpected(protoStartLoc);
    	        }
    	        if (variance) {
    	          this.unexpected(variance.loc.start);
    	        }
    	        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
    	        if (kind === "get" || kind === "set") {
    	          this.flowCheckGetterSetterParams(node);
    	        }
    	        if (!allowSpread && node.key.name === "constructor" && node.value.this) {
    	          this.raise(FlowErrors.ThisParamBannedInConstructor, {
    	            at: node.value.this
    	          });
    	        }
    	      } else {
    	        if (kind !== "init") this.unexpected();
    	        node.method = false;
    	        if (this.eat(17)) {
    	          optional = true;
    	        }
    	        node.value = this.flowParseTypeInitialiser();
    	        node.variance = variance;
    	      }
    	      node.optional = optional;
    	      return this.finishNode(node, "ObjectTypeProperty");
    	    }
    	  }
    	  flowCheckGetterSetterParams(property) {
    	    const paramCount = property.kind === "get" ? 0 : 1;
    	    const length = property.value.params.length + (property.value.rest ? 1 : 0);
    	    if (property.value.this) {
    	      this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, {
    	        at: property.value.this
    	      });
    	    }
    	    if (length !== paramCount) {
    	      this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
    	        at: property
    	      });
    	    }
    	    if (property.kind === "set" && property.value.rest) {
    	      this.raise(Errors.BadSetterRestParameter, {
    	        at: property
    	      });
    	    }
    	  }
    	  flowObjectTypeSemicolon() {
    	    if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
    	      this.unexpected();
    	    }
    	  }
    	  flowParseQualifiedTypeIdentifier(startLoc, id) {
    	    var _startLoc;
    	    (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;
    	    let node = id || this.flowParseRestrictedIdentifier(true);
    	    while (this.eat(16)) {
    	      const node2 = this.startNodeAt(startLoc);
    	      node2.qualification = node;
    	      node2.id = this.flowParseRestrictedIdentifier(true);
    	      node = this.finishNode(node2, "QualifiedTypeIdentifier");
    	    }
    	    return node;
    	  }
    	  flowParseGenericType(startLoc, id) {
    	    const node = this.startNodeAt(startLoc);
    	    node.typeParameters = null;
    	    node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);
    	    if (this.match(47)) {
    	      node.typeParameters = this.flowParseTypeParameterInstantiation();
    	    }
    	    return this.finishNode(node, "GenericTypeAnnotation");
    	  }
    	  flowParseTypeofType() {
    	    const node = this.startNode();
    	    this.expect(87);
    	    node.argument = this.flowParsePrimaryType();
    	    return this.finishNode(node, "TypeofTypeAnnotation");
    	  }
    	  flowParseTupleType() {
    	    const node = this.startNode();
    	    node.types = [];
    	    this.expect(0);
    	    while (this.state.pos < this.length && !this.match(3)) {
    	      node.types.push(this.flowParseType());
    	      if (this.match(3)) break;
    	      this.expect(12);
    	    }
    	    this.expect(3);
    	    return this.finishNode(node, "TupleTypeAnnotation");
    	  }
    	  flowParseFunctionTypeParam(first) {
    	    let name = null;
    	    let optional = false;
    	    let typeAnnotation = null;
    	    const node = this.startNode();
    	    const lh = this.lookahead();
    	    const isThis = this.state.type === 78;
    	    if (lh.type === 14 || lh.type === 17) {
    	      if (isThis && !first) {
    	        this.raise(FlowErrors.ThisParamMustBeFirst, {
    	          at: node
    	        });
    	      }
    	      name = this.parseIdentifier(isThis);
    	      if (this.eat(17)) {
    	        optional = true;
    	        if (isThis) {
    	          this.raise(FlowErrors.ThisParamMayNotBeOptional, {
    	            at: node
    	          });
    	        }
    	      }
    	      typeAnnotation = this.flowParseTypeInitialiser();
    	    } else {
    	      typeAnnotation = this.flowParseType();
    	    }
    	    node.name = name;
    	    node.optional = optional;
    	    node.typeAnnotation = typeAnnotation;
    	    return this.finishNode(node, "FunctionTypeParam");
    	  }
    	  reinterpretTypeAsFunctionTypeParam(type) {
    	    const node = this.startNodeAt(type.loc.start);
    	    node.name = null;
    	    node.optional = false;
    	    node.typeAnnotation = type;
    	    return this.finishNode(node, "FunctionTypeParam");
    	  }
    	  flowParseFunctionTypeParams(params = []) {
    	    let rest = null;
    	    let _this = null;
    	    if (this.match(78)) {
    	      _this = this.flowParseFunctionTypeParam(true);
    	      _this.name = null;
    	      if (!this.match(11)) {
    	        this.expect(12);
    	      }
    	    }
    	    while (!this.match(11) && !this.match(21)) {
    	      params.push(this.flowParseFunctionTypeParam(false));
    	      if (!this.match(11)) {
    	        this.expect(12);
    	      }
    	    }
    	    if (this.eat(21)) {
    	      rest = this.flowParseFunctionTypeParam(false);
    	    }
    	    return {
    	      params,
    	      rest,
    	      _this
    	    };
    	  }
    	  flowIdentToTypeAnnotation(startLoc, node, id) {
    	    switch (id.name) {
    	      case "any":
    	        return this.finishNode(node, "AnyTypeAnnotation");
    	      case "bool":
    	      case "boolean":
    	        return this.finishNode(node, "BooleanTypeAnnotation");
    	      case "mixed":
    	        return this.finishNode(node, "MixedTypeAnnotation");
    	      case "empty":
    	        return this.finishNode(node, "EmptyTypeAnnotation");
    	      case "number":
    	        return this.finishNode(node, "NumberTypeAnnotation");
    	      case "string":
    	        return this.finishNode(node, "StringTypeAnnotation");
    	      case "symbol":
    	        return this.finishNode(node, "SymbolTypeAnnotation");
    	      default:
    	        this.checkNotUnderscore(id.name);
    	        return this.flowParseGenericType(startLoc, id);
    	    }
    	  }
    	  flowParsePrimaryType() {
    	    const startLoc = this.state.startLoc;
    	    const node = this.startNode();
    	    let tmp;
    	    let type;
    	    let isGroupedType = false;
    	    const oldNoAnonFunctionType = this.state.noAnonFunctionType;
    	    switch (this.state.type) {
    	      case 5:
    	        return this.flowParseObjectType({
    	          allowStatic: false,
    	          allowExact: false,
    	          allowSpread: true,
    	          allowProto: false,
    	          allowInexact: true
    	        });
    	      case 6:
    	        return this.flowParseObjectType({
    	          allowStatic: false,
    	          allowExact: true,
    	          allowSpread: true,
    	          allowProto: false,
    	          allowInexact: false
    	        });
    	      case 0:
    	        this.state.noAnonFunctionType = false;
    	        type = this.flowParseTupleType();
    	        this.state.noAnonFunctionType = oldNoAnonFunctionType;
    	        return type;
    	      case 47:
    	        node.typeParameters = this.flowParseTypeParameterDeclaration();
    	        this.expect(10);
    	        tmp = this.flowParseFunctionTypeParams();
    	        node.params = tmp.params;
    	        node.rest = tmp.rest;
    	        node.this = tmp._this;
    	        this.expect(11);
    	        this.expect(19);
    	        node.returnType = this.flowParseType();
    	        return this.finishNode(node, "FunctionTypeAnnotation");
    	      case 10:
    	        this.next();
    	        if (!this.match(11) && !this.match(21)) {
    	          if (tokenIsIdentifier(this.state.type) || this.match(78)) {
    	            const token = this.lookahead().type;
    	            isGroupedType = token !== 17 && token !== 14;
    	          } else {
    	            isGroupedType = true;
    	          }
    	        }
    	        if (isGroupedType) {
    	          this.state.noAnonFunctionType = false;
    	          type = this.flowParseType();
    	          this.state.noAnonFunctionType = oldNoAnonFunctionType;
    	          if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
    	            this.expect(11);
    	            return type;
    	          } else {
    	            this.eat(12);
    	          }
    	        }
    	        if (type) {
    	          tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
    	        } else {
    	          tmp = this.flowParseFunctionTypeParams();
    	        }
    	        node.params = tmp.params;
    	        node.rest = tmp.rest;
    	        node.this = tmp._this;
    	        this.expect(11);
    	        this.expect(19);
    	        node.returnType = this.flowParseType();
    	        node.typeParameters = null;
    	        return this.finishNode(node, "FunctionTypeAnnotation");
    	      case 133:
    	        return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
    	      case 85:
    	      case 86:
    	        node.value = this.match(85);
    	        this.next();
    	        return this.finishNode(node, "BooleanLiteralTypeAnnotation");
    	      case 53:
    	        if (this.state.value === "-") {
    	          this.next();
    	          if (this.match(134)) {
    	            return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
    	          }
    	          if (this.match(135)) {
    	            return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
    	          }
    	          throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {
    	            at: this.state.startLoc
    	          });
    	        }
    	        this.unexpected();
    	        return;
    	      case 134:
    	        return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
    	      case 135:
    	        return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
    	      case 88:
    	        this.next();
    	        return this.finishNode(node, "VoidTypeAnnotation");
    	      case 84:
    	        this.next();
    	        return this.finishNode(node, "NullLiteralTypeAnnotation");
    	      case 78:
    	        this.next();
    	        return this.finishNode(node, "ThisTypeAnnotation");
    	      case 55:
    	        this.next();
    	        return this.finishNode(node, "ExistsTypeAnnotation");
    	      case 87:
    	        return this.flowParseTypeofType();
    	      default:
    	        if (tokenIsKeyword(this.state.type)) {
    	          const label = tokenLabelName(this.state.type);
    	          this.next();
    	          return super.createIdentifier(node, label);
    	        } else if (tokenIsIdentifier(this.state.type)) {
    	          if (this.isContextual(129)) {
    	            return this.flowParseInterfaceType();
    	          }
    	          return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());
    	        }
    	    }
    	    this.unexpected();
    	  }
    	  flowParsePostfixType() {
    	    const startLoc = this.state.startLoc;
    	    let type = this.flowParsePrimaryType();
    	    let seenOptionalIndexedAccess = false;
    	    while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
    	      const node = this.startNodeAt(startLoc);
    	      const optional = this.eat(18);
    	      seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
    	      this.expect(0);
    	      if (!optional && this.match(3)) {
    	        node.elementType = type;
    	        this.next();
    	        type = this.finishNode(node, "ArrayTypeAnnotation");
    	      } else {
    	        node.objectType = type;
    	        node.indexType = this.flowParseType();
    	        this.expect(3);
    	        if (seenOptionalIndexedAccess) {
    	          node.optional = optional;
    	          type = this.finishNode(node, "OptionalIndexedAccessType");
    	        } else {
    	          type = this.finishNode(node, "IndexedAccessType");
    	        }
    	      }
    	    }
    	    return type;
    	  }
    	  flowParsePrefixType() {
    	    const node = this.startNode();
    	    if (this.eat(17)) {
    	      node.typeAnnotation = this.flowParsePrefixType();
    	      return this.finishNode(node, "NullableTypeAnnotation");
    	    } else {
    	      return this.flowParsePostfixType();
    	    }
    	  }
    	  flowParseAnonFunctionWithoutParens() {
    	    const param = this.flowParsePrefixType();
    	    if (!this.state.noAnonFunctionType && this.eat(19)) {
    	      const node = this.startNodeAt(param.loc.start);
    	      node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
    	      node.rest = null;
    	      node.this = null;
    	      node.returnType = this.flowParseType();
    	      node.typeParameters = null;
    	      return this.finishNode(node, "FunctionTypeAnnotation");
    	    }
    	    return param;
    	  }
    	  flowParseIntersectionType() {
    	    const node = this.startNode();
    	    this.eat(45);
    	    const type = this.flowParseAnonFunctionWithoutParens();
    	    node.types = [type];
    	    while (this.eat(45)) {
    	      node.types.push(this.flowParseAnonFunctionWithoutParens());
    	    }
    	    return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
    	  }
    	  flowParseUnionType() {
    	    const node = this.startNode();
    	    this.eat(43);
    	    const type = this.flowParseIntersectionType();
    	    node.types = [type];
    	    while (this.eat(43)) {
    	      node.types.push(this.flowParseIntersectionType());
    	    }
    	    return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
    	  }
    	  flowParseType() {
    	    const oldInType = this.state.inType;
    	    this.state.inType = true;
    	    const type = this.flowParseUnionType();
    	    this.state.inType = oldInType;
    	    return type;
    	  }
    	  flowParseTypeOrImplicitInstantiation() {
    	    if (this.state.type === 132 && this.state.value === "_") {
    	      const startLoc = this.state.startLoc;
    	      const node = this.parseIdentifier();
    	      return this.flowParseGenericType(startLoc, node);
    	    } else {
    	      return this.flowParseType();
    	    }
    	  }
    	  flowParseTypeAnnotation() {
    	    const node = this.startNode();
    	    node.typeAnnotation = this.flowParseTypeInitialiser();
    	    return this.finishNode(node, "TypeAnnotation");
    	  }
    	  flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
    	    const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
    	    if (this.match(14)) {
    	      ident.typeAnnotation = this.flowParseTypeAnnotation();
    	      this.resetEndLocation(ident);
    	    }
    	    return ident;
    	  }
    	  typeCastToParameter(node) {
    	    node.expression.typeAnnotation = node.typeAnnotation;
    	    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
    	    return node.expression;
    	  }
    	  flowParseVariance() {
    	    let variance = null;
    	    if (this.match(53)) {
    	      variance = this.startNode();
    	      if (this.state.value === "+") {
    	        variance.kind = "plus";
    	      } else {
    	        variance.kind = "minus";
    	      }
    	      this.next();
    	      return this.finishNode(variance, "Variance");
    	    }
    	    return variance;
    	  }
    	  parseFunctionBody(node, allowExpressionBody, isMethod = false) {
    	    if (allowExpressionBody) {
    	      this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));
    	      return;
    	    }
    	    super.parseFunctionBody(node, false, isMethod);
    	  }
    	  parseFunctionBodyAndFinish(node, type, isMethod = false) {
    	    if (this.match(14)) {
    	      const typeNode = this.startNode();
    	      [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
    	      node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
    	    }
    	    return super.parseFunctionBodyAndFinish(node, type, isMethod);
    	  }
    	  parseStatementLike(flags) {
    	    if (this.state.strict && this.isContextual(129)) {
    	      const lookahead = this.lookahead();
    	      if (tokenIsKeywordOrIdentifier(lookahead.type)) {
    	        const node = this.startNode();
    	        this.next();
    	        return this.flowParseInterface(node);
    	      }
    	    } else if (this.shouldParseEnums() && this.isContextual(126)) {
    	      const node = this.startNode();
    	      this.next();
    	      return this.flowParseEnumDeclaration(node);
    	    }
    	    const stmt = super.parseStatementLike(flags);
    	    if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {
    	      this.flowPragma = null;
    	    }
    	    return stmt;
    	  }
    	  parseExpressionStatement(node, expr, decorators) {
    	    if (expr.type === "Identifier") {
    	      if (expr.name === "declare") {
    	        if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
    	          return this.flowParseDeclare(node);
    	        }
    	      } else if (tokenIsIdentifier(this.state.type)) {
    	        if (expr.name === "interface") {
    	          return this.flowParseInterface(node);
    	        } else if (expr.name === "type") {
    	          return this.flowParseTypeAlias(node);
    	        } else if (expr.name === "opaque") {
    	          return this.flowParseOpaqueType(node, false);
    	        }
    	      }
    	    }
    	    return super.parseExpressionStatement(node, expr, decorators);
    	  }
    	  shouldParseExportDeclaration() {
    	    const {
    	      type
    	    } = this.state;
    	    if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 126) {
    	      return !this.state.containsEsc;
    	    }
    	    return super.shouldParseExportDeclaration();
    	  }
    	  isExportDefaultSpecifier() {
    	    const {
    	      type
    	    } = this.state;
    	    if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 126) {
    	      return this.state.containsEsc;
    	    }
    	    return super.isExportDefaultSpecifier();
    	  }
    	  parseExportDefaultExpression() {
    	    if (this.shouldParseEnums() && this.isContextual(126)) {
    	      const node = this.startNode();
    	      this.next();
    	      return this.flowParseEnumDeclaration(node);
    	    }
    	    return super.parseExportDefaultExpression();
    	  }
    	  parseConditional(expr, startLoc, refExpressionErrors) {
    	    if (!this.match(17)) return expr;
    	    if (this.state.maybeInArrowParameters) {
    	      const nextCh = this.lookaheadCharCode();
    	      if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
    	        this.setOptionalParametersError(refExpressionErrors);
    	        return expr;
    	      }
    	    }
    	    this.expect(17);
    	    const state = this.state.clone();
    	    const originalNoArrowAt = this.state.noArrowAt;
    	    const node = this.startNodeAt(startLoc);
    	    let {
    	      consequent,
    	      failed
    	    } = this.tryParseConditionalConsequent();
    	    let [valid, invalid] = this.getArrowLikeExpressions(consequent);
    	    if (failed || invalid.length > 0) {
    	      const noArrowAt = [...originalNoArrowAt];
    	      if (invalid.length > 0) {
    	        this.state = state;
    	        this.state.noArrowAt = noArrowAt;
    	        for (let i = 0; i < invalid.length; i++) {
    	          noArrowAt.push(invalid[i].start);
    	        }
    	        ({
    	          consequent,
    	          failed
    	        } = this.tryParseConditionalConsequent());
    	        [valid, invalid] = this.getArrowLikeExpressions(consequent);
    	      }
    	      if (failed && valid.length > 1) {
    	        this.raise(FlowErrors.AmbiguousConditionalArrow, {
    	          at: state.startLoc
    	        });
    	      }
    	      if (failed && valid.length === 1) {
    	        this.state = state;
    	        noArrowAt.push(valid[0].start);
    	        this.state.noArrowAt = noArrowAt;
    	        ({
    	          consequent,
    	          failed
    	        } = this.tryParseConditionalConsequent());
    	      }
    	    }
    	    this.getArrowLikeExpressions(consequent, true);
    	    this.state.noArrowAt = originalNoArrowAt;
    	    this.expect(14);
    	    node.test = expr;
    	    node.consequent = consequent;
    	    node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(undefined, undefined));
    	    return this.finishNode(node, "ConditionalExpression");
    	  }
    	  tryParseConditionalConsequent() {
    	    this.state.noArrowParamsConversionAt.push(this.state.start);
    	    const consequent = this.parseMaybeAssignAllowIn();
    	    const failed = !this.match(14);
    	    this.state.noArrowParamsConversionAt.pop();
    	    return {
    	      consequent,
    	      failed
    	    };
    	  }
    	  getArrowLikeExpressions(node, disallowInvalid) {
    	    const stack = [node];
    	    const arrows = [];
    	    while (stack.length !== 0) {
    	      const node = stack.pop();
    	      if (node.type === "ArrowFunctionExpression") {
    	        if (node.typeParameters || !node.returnType) {
    	          this.finishArrowValidation(node);
    	        } else {
    	          arrows.push(node);
    	        }
    	        stack.push(node.body);
    	      } else if (node.type === "ConditionalExpression") {
    	        stack.push(node.consequent);
    	        stack.push(node.alternate);
    	      }
    	    }
    	    if (disallowInvalid) {
    	      arrows.forEach(node => this.finishArrowValidation(node));
    	      return [arrows, []];
    	    }
    	    return partition(arrows, node => node.params.every(param => this.isAssignable(param, true)));
    	  }
    	  finishArrowValidation(node) {
    	    var _node$extra;
    	    this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
    	    this.scope.enter(2 | 4);
    	    super.checkParams(node, false, true);
    	    this.scope.exit();
    	  }
    	  forwardNoArrowParamsConversionAt(node, parse) {
    	    let result;
    	    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
    	      this.state.noArrowParamsConversionAt.push(this.state.start);
    	      result = parse();
    	      this.state.noArrowParamsConversionAt.pop();
    	    } else {
    	      result = parse();
    	    }
    	    return result;
    	  }
    	  parseParenItem(node, startLoc) {
    	    node = super.parseParenItem(node, startLoc);
    	    if (this.eat(17)) {
    	      node.optional = true;
    	      this.resetEndLocation(node);
    	    }
    	    if (this.match(14)) {
    	      const typeCastNode = this.startNodeAt(startLoc);
    	      typeCastNode.expression = node;
    	      typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
    	      return this.finishNode(typeCastNode, "TypeCastExpression");
    	    }
    	    return node;
    	  }
    	  assertModuleNodeAllowed(node) {
    	    if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
    	      return;
    	    }
    	    super.assertModuleNodeAllowed(node);
    	  }
    	  parseExportDeclaration(node) {
    	    if (this.isContextual(130)) {
    	      node.exportKind = "type";
    	      const declarationNode = this.startNode();
    	      this.next();
    	      if (this.match(5)) {
    	        node.specifiers = this.parseExportSpecifiers(true);
    	        super.parseExportFrom(node);
    	        return null;
    	      } else {
    	        return this.flowParseTypeAlias(declarationNode);
    	      }
    	    } else if (this.isContextual(131)) {
    	      node.exportKind = "type";
    	      const declarationNode = this.startNode();
    	      this.next();
    	      return this.flowParseOpaqueType(declarationNode, false);
    	    } else if (this.isContextual(129)) {
    	      node.exportKind = "type";
    	      const declarationNode = this.startNode();
    	      this.next();
    	      return this.flowParseInterface(declarationNode);
    	    } else if (this.shouldParseEnums() && this.isContextual(126)) {
    	      node.exportKind = "value";
    	      const declarationNode = this.startNode();
    	      this.next();
    	      return this.flowParseEnumDeclaration(declarationNode);
    	    } else {
    	      return super.parseExportDeclaration(node);
    	    }
    	  }
    	  eatExportStar(node) {
    	    if (super.eatExportStar(node)) return true;
    	    if (this.isContextual(130) && this.lookahead().type === 55) {
    	      node.exportKind = "type";
    	      this.next();
    	      this.next();
    	      return true;
    	    }
    	    return false;
    	  }
    	  maybeParseExportNamespaceSpecifier(node) {
    	    const {
    	      startLoc
    	    } = this.state;
    	    const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
    	    if (hasNamespace && node.exportKind === "type") {
    	      this.unexpected(startLoc);
    	    }
    	    return hasNamespace;
    	  }
    	  parseClassId(node, isStatement, optionalId) {
    	    super.parseClassId(node, isStatement, optionalId);
    	    if (this.match(47)) {
    	      node.typeParameters = this.flowParseTypeParameterDeclaration();
    	    }
    	  }
    	  parseClassMember(classBody, member, state) {
    	    const {
    	      startLoc
    	    } = this.state;
    	    if (this.isContextual(125)) {
    	      if (super.parseClassMemberFromModifier(classBody, member)) {
    	        return;
    	      }
    	      member.declare = true;
    	    }
    	    super.parseClassMember(classBody, member, state);
    	    if (member.declare) {
    	      if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
    	        this.raise(FlowErrors.DeclareClassElement, {
    	          at: startLoc
    	        });
    	      } else if (member.value) {
    	        this.raise(FlowErrors.DeclareClassFieldInitializer, {
    	          at: member.value
    	        });
    	      }
    	    }
    	  }
    	  isIterator(word) {
    	    return word === "iterator" || word === "asyncIterator";
    	  }
    	  readIterator() {
    	    const word = super.readWord1();
    	    const fullWord = "@@" + word;
    	    if (!this.isIterator(word) || !this.state.inType) {
    	      this.raise(Errors.InvalidIdentifier, {
    	        at: this.state.curPosition(),
    	        identifierName: fullWord
    	      });
    	    }
    	    this.finishToken(132, fullWord);
    	  }
    	  getTokenFromCode(code) {
    	    const next = this.input.charCodeAt(this.state.pos + 1);
    	    if (code === 123 && next === 124) {
    	      this.finishOp(6, 2);
    	    } else if (this.state.inType && (code === 62 || code === 60)) {
    	      this.finishOp(code === 62 ? 48 : 47, 1);
    	    } else if (this.state.inType && code === 63) {
    	      if (next === 46) {
    	        this.finishOp(18, 2);
    	      } else {
    	        this.finishOp(17, 1);
    	      }
    	    } else if (isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))) {
    	      this.state.pos += 2;
    	      this.readIterator();
    	    } else {
    	      super.getTokenFromCode(code);
    	    }
    	  }
    	  isAssignable(node, isBinding) {
    	    if (node.type === "TypeCastExpression") {
    	      return this.isAssignable(node.expression, isBinding);
    	    } else {
    	      return super.isAssignable(node, isBinding);
    	    }
    	  }
    	  toAssignable(node, isLHS = false) {
    	    if (!isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression") {
    	      node.left = this.typeCastToParameter(node.left);
    	    }
    	    super.toAssignable(node, isLHS);
    	  }
    	  toAssignableList(exprList, trailingCommaLoc, isLHS) {
    	    for (let i = 0; i < exprList.length; i++) {
    	      const expr = exprList[i];
    	      if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
    	        exprList[i] = this.typeCastToParameter(expr);
    	      }
    	    }
    	    super.toAssignableList(exprList, trailingCommaLoc, isLHS);
    	  }
    	  toReferencedList(exprList, isParenthesizedExpr) {
    	    for (let i = 0; i < exprList.length; i++) {
    	      var _expr$extra;
    	      const expr = exprList[i];
    	      if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
    	        this.raise(FlowErrors.TypeCastInPattern, {
    	          at: expr.typeAnnotation
    	        });
    	      }
    	    }
    	    return exprList;
    	  }
    	  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
    	    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
    	    if (canBePattern && !this.state.maybeInArrowParameters) {
    	      this.toReferencedList(node.elements);
    	    }
    	    return node;
    	  }
    	  isValidLVal(type, isParenthesized, binding) {
    	    return type === "TypeCastExpression" || super.isValidLVal(type, isParenthesized, binding);
    	  }
    	  parseClassProperty(node) {
    	    if (this.match(14)) {
    	      node.typeAnnotation = this.flowParseTypeAnnotation();
    	    }
    	    return super.parseClassProperty(node);
    	  }
    	  parseClassPrivateProperty(node) {
    	    if (this.match(14)) {
    	      node.typeAnnotation = this.flowParseTypeAnnotation();
    	    }
    	    return super.parseClassPrivateProperty(node);
    	  }
    	  isClassMethod() {
    	    return this.match(47) || super.isClassMethod();
    	  }
    	  isClassProperty() {
    	    return this.match(14) || super.isClassProperty();
    	  }
    	  isNonstaticConstructor(method) {
    	    return !this.match(14) && super.isNonstaticConstructor(method);
    	  }
    	  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
    	    if (method.variance) {
    	      this.unexpected(method.variance.loc.start);
    	    }
    	    delete method.variance;
    	    if (this.match(47)) {
    	      method.typeParameters = this.flowParseTypeParameterDeclaration();
    	    }
    	    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
    	    if (method.params && isConstructor) {
    	      const params = method.params;
    	      if (params.length > 0 && this.isThisParam(params[0])) {
    	        this.raise(FlowErrors.ThisParamBannedInConstructor, {
    	          at: method
    	        });
    	      }
    	    } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
    	      const params = method.value.params;
    	      if (params.length > 0 && this.isThisParam(params[0])) {
    	        this.raise(FlowErrors.ThisParamBannedInConstructor, {
    	          at: method
    	        });
    	      }
    	    }
    	  }
    	  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
    	    if (method.variance) {
    	      this.unexpected(method.variance.loc.start);
    	    }
    	    delete method.variance;
    	    if (this.match(47)) {
    	      method.typeParameters = this.flowParseTypeParameterDeclaration();
    	    }
    	    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
    	  }
    	  parseClassSuper(node) {
    	    super.parseClassSuper(node);
    	    if (node.superClass && this.match(47)) {
    	      node.superTypeParameters = this.flowParseTypeParameterInstantiation();
    	    }
    	    if (this.isContextual(113)) {
    	      this.next();
    	      const implemented = node.implements = [];
    	      do {
    	        const node = this.startNode();
    	        node.id = this.flowParseRestrictedIdentifier(true);
    	        if (this.match(47)) {
    	          node.typeParameters = this.flowParseTypeParameterInstantiation();
    	        } else {
    	          node.typeParameters = null;
    	        }
    	        implemented.push(this.finishNode(node, "ClassImplements"));
    	      } while (this.eat(12));
    	    }
    	  }
    	  checkGetterSetterParams(method) {
    	    super.checkGetterSetterParams(method);
    	    const params = this.getObjectOrClassMethodParams(method);
    	    if (params.length > 0) {
    	      const param = params[0];
    	      if (this.isThisParam(param) && method.kind === "get") {
    	        this.raise(FlowErrors.GetterMayNotHaveThisParam, {
    	          at: param
    	        });
    	      } else if (this.isThisParam(param)) {
    	        this.raise(FlowErrors.SetterMayNotHaveThisParam, {
    	          at: param
    	        });
    	      }
    	    }
    	  }
    	  parsePropertyNamePrefixOperator(node) {
    	    node.variance = this.flowParseVariance();
    	  }
    	  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
    	    if (prop.variance) {
    	      this.unexpected(prop.variance.loc.start);
    	    }
    	    delete prop.variance;
    	    let typeParameters;
    	    if (this.match(47) && !isAccessor) {
    	      typeParameters = this.flowParseTypeParameterDeclaration();
    	      if (!this.match(10)) this.unexpected();
    	    }
    	    const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
    	    if (typeParameters) {
    	      (result.value || result).typeParameters = typeParameters;
    	    }
    	    return result;
    	  }
    	  parseAssignableListItemTypes(param) {
    	    if (this.eat(17)) {
    	      if (param.type !== "Identifier") {
    	        this.raise(FlowErrors.PatternIsOptional, {
    	          at: param
    	        });
    	      }
    	      if (this.isThisParam(param)) {
    	        this.raise(FlowErrors.ThisParamMayNotBeOptional, {
    	          at: param
    	        });
    	      }
    	      param.optional = true;
    	    }
    	    if (this.match(14)) {
    	      param.typeAnnotation = this.flowParseTypeAnnotation();
    	    } else if (this.isThisParam(param)) {
    	      this.raise(FlowErrors.ThisParamAnnotationRequired, {
    	        at: param
    	      });
    	    }
    	    if (this.match(29) && this.isThisParam(param)) {
    	      this.raise(FlowErrors.ThisParamNoDefault, {
    	        at: param
    	      });
    	    }
    	    this.resetEndLocation(param);
    	    return param;
    	  }
    	  parseMaybeDefault(startLoc, left) {
    	    const node = super.parseMaybeDefault(startLoc, left);
    	    if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
    	      this.raise(FlowErrors.TypeBeforeInitializer, {
    	        at: node.typeAnnotation
    	      });
    	    }
    	    return node;
    	  }
    	  checkImportReflection(node) {
    	    super.checkImportReflection(node);
    	    if (node.module && node.importKind !== "value") {
    	      this.raise(FlowErrors.ImportReflectionHasImportType, {
    	        at: node.specifiers[0].loc.start
    	      });
    	    }
    	  }
    	  parseImportSpecifierLocal(node, specifier, type) {
    	    specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
    	    node.specifiers.push(this.finishImportSpecifier(specifier, type));
    	  }
    	  isPotentialImportPhase(isExport) {
    	    if (super.isPotentialImportPhase(isExport)) return true;
    	    if (this.isContextual(130)) {
    	      if (!isExport) return true;
    	      const ch = this.lookaheadCharCode();
    	      return ch === 123 || ch === 42;
    	    }
    	    return !isExport && this.isContextual(87);
    	  }
    	  applyImportPhase(node, isExport, phase, loc) {
    	    super.applyImportPhase(node, isExport, phase, loc);
    	    if (isExport) {
    	      if (!phase && this.match(65)) {
    	        return;
    	      }
    	      node.exportKind = phase === "type" ? phase : "value";
    	    } else {
    	      if (phase === "type" && this.match(55)) this.unexpected();
    	      node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
    	    }
    	  }
    	  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
    	    const firstIdent = specifier.imported;
    	    let specifierTypeKind = null;
    	    if (firstIdent.type === "Identifier") {
    	      if (firstIdent.name === "type") {
    	        specifierTypeKind = "type";
    	      } else if (firstIdent.name === "typeof") {
    	        specifierTypeKind = "typeof";
    	      }
    	    }
    	    let isBinding = false;
    	    if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
    	      const as_ident = this.parseIdentifier(true);
    	      if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
    	        specifier.imported = as_ident;
    	        specifier.importKind = specifierTypeKind;
    	        specifier.local = cloneIdentifier(as_ident);
    	      } else {
    	        specifier.imported = firstIdent;
    	        specifier.importKind = null;
    	        specifier.local = this.parseIdentifier();
    	      }
    	    } else {
    	      if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
    	        specifier.imported = this.parseIdentifier(true);
    	        specifier.importKind = specifierTypeKind;
    	      } else {
    	        if (importedIsString) {
    	          throw this.raise(Errors.ImportBindingIsString, {
    	            at: specifier,
    	            importName: firstIdent.value
    	          });
    	        }
    	        specifier.imported = firstIdent;
    	        specifier.importKind = null;
    	      }
    	      if (this.eatContextual(93)) {
    	        specifier.local = this.parseIdentifier();
    	      } else {
    	        isBinding = true;
    	        specifier.local = cloneIdentifier(specifier.imported);
    	      }
    	    }
    	    const specifierIsTypeImport = hasTypeImportKind(specifier);
    	    if (isInTypeOnlyImport && specifierIsTypeImport) {
    	      this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {
    	        at: specifier
    	      });
    	    }
    	    if (isInTypeOnlyImport || specifierIsTypeImport) {
    	      this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
    	    }
    	    if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
    	      this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
    	    }
    	    return this.finishImportSpecifier(specifier, "ImportSpecifier");
    	  }
    	  parseBindingAtom() {
    	    switch (this.state.type) {
    	      case 78:
    	        return this.parseIdentifier(true);
    	      default:
    	        return super.parseBindingAtom();
    	    }
    	  }
    	  parseFunctionParams(node, isConstructor) {
    	    const kind = node.kind;
    	    if (kind !== "get" && kind !== "set" && this.match(47)) {
    	      node.typeParameters = this.flowParseTypeParameterDeclaration();
    	    }
    	    super.parseFunctionParams(node, isConstructor);
    	  }
    	  parseVarId(decl, kind) {
    	    super.parseVarId(decl, kind);
    	    if (this.match(14)) {
    	      decl.id.typeAnnotation = this.flowParseTypeAnnotation();
    	      this.resetEndLocation(decl.id);
    	    }
    	  }
    	  parseAsyncArrowFromCallExpression(node, call) {
    	    if (this.match(14)) {
    	      const oldNoAnonFunctionType = this.state.noAnonFunctionType;
    	      this.state.noAnonFunctionType = true;
    	      node.returnType = this.flowParseTypeAnnotation();
    	      this.state.noAnonFunctionType = oldNoAnonFunctionType;
    	    }
    	    return super.parseAsyncArrowFromCallExpression(node, call);
    	  }
    	  shouldParseAsyncArrow() {
    	    return this.match(14) || super.shouldParseAsyncArrow();
    	  }
    	  parseMaybeAssign(refExpressionErrors, afterLeftParse) {
    	    var _jsx;
    	    let state = null;
    	    let jsx;
    	    if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
    	      state = this.state.clone();
    	      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
    	      if (!jsx.error) return jsx.node;
    	      const {
    	        context
    	      } = this.state;
    	      const currentContext = context[context.length - 1];
    	      if (currentContext === types.j_oTag || currentContext === types.j_expr) {
    	        context.pop();
    	      }
    	    }
    	    if ((_jsx = jsx) != null && _jsx.error || this.match(47)) {
    	      var _jsx2, _jsx3;
    	      state = state || this.state.clone();
    	      let typeParameters;
    	      const arrow = this.tryParse(abort => {
    	        var _arrowExpression$extr;
    	        typeParameters = this.flowParseTypeParameterDeclaration();
    	        const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
    	          const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
    	          this.resetStartLocationFromNode(result, typeParameters);
    	          return result;
    	        });
    	        if ((_arrowExpression$extr = arrowExpression.extra) != null && _arrowExpression$extr.parenthesized) abort();
    	        const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);
    	        if (expr.type !== "ArrowFunctionExpression") abort();
    	        expr.typeParameters = typeParameters;
    	        this.resetStartLocationFromNode(expr, typeParameters);
    	        return arrowExpression;
    	      }, state);
    	      let arrowExpression = null;
    	      if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
    	        if (!arrow.error && !arrow.aborted) {
    	          if (arrow.node.async) {
    	            this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
    	              at: typeParameters
    	            });
    	          }
    	          return arrow.node;
    	        }
    	        arrowExpression = arrow.node;
    	      }
    	      if ((_jsx2 = jsx) != null && _jsx2.node) {
    	        this.state = jsx.failState;
    	        return jsx.node;
    	      }
    	      if (arrowExpression) {
    	        this.state = arrow.failState;
    	        return arrowExpression;
    	      }
    	      if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;
    	      if (arrow.thrown) throw arrow.error;
    	      throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {
    	        at: typeParameters
    	      });
    	    }
    	    return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
    	  }
    	  parseArrow(node) {
    	    if (this.match(14)) {
    	      const result = this.tryParse(() => {
    	        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
    	        this.state.noAnonFunctionType = true;
    	        const typeNode = this.startNode();
    	        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
    	        this.state.noAnonFunctionType = oldNoAnonFunctionType;
    	        if (this.canInsertSemicolon()) this.unexpected();
    	        if (!this.match(19)) this.unexpected();
    	        return typeNode;
    	      });
    	      if (result.thrown) return null;
    	      if (result.error) this.state = result.failState;
    	      node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
    	    }
    	    return super.parseArrow(node);
    	  }
    	  shouldParseArrow(params) {
    	    return this.match(14) || super.shouldParseArrow(params);
    	  }
    	  setArrowFunctionParameters(node, params) {
    	    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
    	      node.params = params;
    	    } else {
    	      super.setArrowFunctionParameters(node, params);
    	    }
    	  }
    	  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
    	    if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
    	      return;
    	    }
    	    for (let i = 0; i < node.params.length; i++) {
    	      if (this.isThisParam(node.params[i]) && i > 0) {
    	        this.raise(FlowErrors.ThisParamMustBeFirst, {
    	          at: node.params[i]
    	        });
    	      }
    	    }
    	    super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);
    	  }
    	  parseParenAndDistinguishExpression(canBeArrow) {
    	    return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
    	  }
    	  parseSubscripts(base, startLoc, noCalls) {
    	    if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startLoc.index) !== -1) {
    	      this.next();
    	      const node = this.startNodeAt(startLoc);
    	      node.callee = base;
    	      node.arguments = super.parseCallExpressionArguments(11, false);
    	      base = this.finishNode(node, "CallExpression");
    	    } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
    	      const state = this.state.clone();
    	      const arrow = this.tryParse(abort => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);
    	      if (!arrow.error && !arrow.aborted) return arrow.node;
    	      const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);
    	      if (result.node && !result.error) return result.node;
    	      if (arrow.node) {
    	        this.state = arrow.failState;
    	        return arrow.node;
    	      }
    	      if (result.node) {
    	        this.state = result.failState;
    	        return result.node;
    	      }
    	      throw arrow.error || result.error;
    	    }
    	    return super.parseSubscripts(base, startLoc, noCalls);
    	  }
    	  parseSubscript(base, startLoc, noCalls, subscriptState) {
    	    if (this.match(18) && this.isLookaheadToken_lt()) {
    	      subscriptState.optionalChainMember = true;
    	      if (noCalls) {
    	        subscriptState.stop = true;
    	        return base;
    	      }
    	      this.next();
    	      const node = this.startNodeAt(startLoc);
    	      node.callee = base;
    	      node.typeArguments = this.flowParseTypeParameterInstantiation();
    	      this.expect(10);
    	      node.arguments = this.parseCallExpressionArguments(11, false);
    	      node.optional = true;
    	      return this.finishCallExpression(node, true);
    	    } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {
    	      const node = this.startNodeAt(startLoc);
    	      node.callee = base;
    	      const result = this.tryParse(() => {
    	        node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
    	        this.expect(10);
    	        node.arguments = super.parseCallExpressionArguments(11, false);
    	        if (subscriptState.optionalChainMember) {
    	          node.optional = false;
    	        }
    	        return this.finishCallExpression(node, subscriptState.optionalChainMember);
    	      });
    	      if (result.node) {
    	        if (result.error) this.state = result.failState;
    	        return result.node;
    	      }
    	    }
    	    return super.parseSubscript(base, startLoc, noCalls, subscriptState);
    	  }
    	  parseNewCallee(node) {
    	    super.parseNewCallee(node);
    	    let targs = null;
    	    if (this.shouldParseTypes() && this.match(47)) {
    	      targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
    	    }
    	    node.typeArguments = targs;
    	  }
    	  parseAsyncArrowWithTypeParameters(startLoc) {
    	    const node = this.startNodeAt(startLoc);
    	    this.parseFunctionParams(node, false);
    	    if (!this.parseArrow(node)) return;
    	    return super.parseArrowExpression(node, undefined, true);
    	  }
    	  readToken_mult_modulo(code) {
    	    const next = this.input.charCodeAt(this.state.pos + 1);
    	    if (code === 42 && next === 47 && this.state.hasFlowComment) {
    	      this.state.hasFlowComment = false;
    	      this.state.pos += 2;
    	      this.nextToken();
    	      return;
    	    }
    	    super.readToken_mult_modulo(code);
    	  }
    	  readToken_pipe_amp(code) {
    	    const next = this.input.charCodeAt(this.state.pos + 1);
    	    if (code === 124 && next === 125) {
    	      this.finishOp(9, 2);
    	      return;
    	    }
    	    super.readToken_pipe_amp(code);
    	  }
    	  parseTopLevel(file, program) {
    	    const fileNode = super.parseTopLevel(file, program);
    	    if (this.state.hasFlowComment) {
    	      this.raise(FlowErrors.UnterminatedFlowComment, {
    	        at: this.state.curPosition()
    	      });
    	    }
    	    return fileNode;
    	  }
    	  skipBlockComment() {
    	    if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
    	      if (this.state.hasFlowComment) {
    	        throw this.raise(FlowErrors.NestedFlowComment, {
    	          at: this.state.startLoc
    	        });
    	      }
    	      this.hasFlowCommentCompletion();
    	      const commentSkip = this.skipFlowComment();
    	      if (commentSkip) {
    	        this.state.pos += commentSkip;
    	        this.state.hasFlowComment = true;
    	      }
    	      return;
    	    }
    	    return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    	  }
    	  skipFlowComment() {
    	    const {
    	      pos
    	    } = this.state;
    	    let shiftToFirstNonWhiteSpace = 2;
    	    while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
    	      shiftToFirstNonWhiteSpace++;
    	    }
    	    const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
    	    const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
    	    if (ch2 === 58 && ch3 === 58) {
    	      return shiftToFirstNonWhiteSpace + 2;
    	    }
    	    if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
    	      return shiftToFirstNonWhiteSpace + 12;
    	    }
    	    if (ch2 === 58 && ch3 !== 58) {
    	      return shiftToFirstNonWhiteSpace;
    	    }
    	    return false;
    	  }
    	  hasFlowCommentCompletion() {
    	    const end = this.input.indexOf("*/", this.state.pos);
    	    if (end === -1) {
    	      throw this.raise(Errors.UnterminatedComment, {
    	        at: this.state.curPosition()
    	      });
    	    }
    	  }
    	  flowEnumErrorBooleanMemberNotInitialized(loc, {
    	    enumName,
    	    memberName
    	  }) {
    	    this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {
    	      at: loc,
    	      memberName,
    	      enumName
    	    });
    	  }
    	  flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
    	    return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, Object.assign({
    	      at: loc
    	    }, enumContext));
    	  }
    	  flowEnumErrorNumberMemberNotInitialized(loc, {
    	    enumName,
    	    memberName
    	  }) {
    	    this.raise(FlowErrors.EnumNumberMemberNotInitialized, {
    	      at: loc,
    	      enumName,
    	      memberName
    	    });
    	  }
    	  flowEnumErrorStringMemberInconsistentlyInitialized(node, {
    	    enumName
    	  }) {
    	    this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, {
    	      at: node,
    	      enumName
    	    });
    	  }
    	  flowEnumMemberInit() {
    	    const startLoc = this.state.startLoc;
    	    const endOfInit = () => this.match(12) || this.match(8);
    	    switch (this.state.type) {
    	      case 134:
    	        {
    	          const literal = this.parseNumericLiteral(this.state.value);
    	          if (endOfInit()) {
    	            return {
    	              type: "number",
    	              loc: literal.loc.start,
    	              value: literal
    	            };
    	          }
    	          return {
    	            type: "invalid",
    	            loc: startLoc
    	          };
    	        }
    	      case 133:
    	        {
    	          const literal = this.parseStringLiteral(this.state.value);
    	          if (endOfInit()) {
    	            return {
    	              type: "string",
    	              loc: literal.loc.start,
    	              value: literal
    	            };
    	          }
    	          return {
    	            type: "invalid",
    	            loc: startLoc
    	          };
    	        }
    	      case 85:
    	      case 86:
    	        {
    	          const literal = this.parseBooleanLiteral(this.match(85));
    	          if (endOfInit()) {
    	            return {
    	              type: "boolean",
    	              loc: literal.loc.start,
    	              value: literal
    	            };
    	          }
    	          return {
    	            type: "invalid",
    	            loc: startLoc
    	          };
    	        }
    	      default:
    	        return {
    	          type: "invalid",
    	          loc: startLoc
    	        };
    	    }
    	  }
    	  flowEnumMemberRaw() {
    	    const loc = this.state.startLoc;
    	    const id = this.parseIdentifier(true);
    	    const init = this.eat(29) ? this.flowEnumMemberInit() : {
    	      type: "none",
    	      loc
    	    };
    	    return {
    	      id,
    	      init
    	    };
    	  }
    	  flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
    	    const {
    	      explicitType
    	    } = context;
    	    if (explicitType === null) {
    	      return;
    	    }
    	    if (explicitType !== expectedType) {
    	      this.flowEnumErrorInvalidMemberInitializer(loc, context);
    	    }
    	  }
    	  flowEnumMembers({
    	    enumName,
    	    explicitType
    	  }) {
    	    const seenNames = new Set();
    	    const members = {
    	      booleanMembers: [],
    	      numberMembers: [],
    	      stringMembers: [],
    	      defaultedMembers: []
    	    };
    	    let hasUnknownMembers = false;
    	    while (!this.match(8)) {
    	      if (this.eat(21)) {
    	        hasUnknownMembers = true;
    	        break;
    	      }
    	      const memberNode = this.startNode();
    	      const {
    	        id,
    	        init
    	      } = this.flowEnumMemberRaw();
    	      const memberName = id.name;
    	      if (memberName === "") {
    	        continue;
    	      }
    	      if (/^[a-z]/.test(memberName)) {
    	        this.raise(FlowErrors.EnumInvalidMemberName, {
    	          at: id,
    	          memberName,
    	          suggestion: memberName[0].toUpperCase() + memberName.slice(1),
    	          enumName
    	        });
    	      }
    	      if (seenNames.has(memberName)) {
    	        this.raise(FlowErrors.EnumDuplicateMemberName, {
    	          at: id,
    	          memberName,
    	          enumName
    	        });
    	      }
    	      seenNames.add(memberName);
    	      const context = {
    	        enumName,
    	        explicitType,
    	        memberName
    	      };
    	      memberNode.id = id;
    	      switch (init.type) {
    	        case "boolean":
    	          {
    	            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
    	            memberNode.init = init.value;
    	            members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
    	            break;
    	          }
    	        case "number":
    	          {
    	            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
    	            memberNode.init = init.value;
    	            members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
    	            break;
    	          }
    	        case "string":
    	          {
    	            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
    	            memberNode.init = init.value;
    	            members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
    	            break;
    	          }
    	        case "invalid":
    	          {
    	            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
    	          }
    	        case "none":
    	          {
    	            switch (explicitType) {
    	              case "boolean":
    	                this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
    	                break;
    	              case "number":
    	                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
    	                break;
    	              default:
    	                members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
    	            }
    	          }
    	      }
    	      if (!this.match(8)) {
    	        this.expect(12);
    	      }
    	    }
    	    return {
    	      members,
    	      hasUnknownMembers
    	    };
    	  }
    	  flowEnumStringMembers(initializedMembers, defaultedMembers, {
    	    enumName
    	  }) {
    	    if (initializedMembers.length === 0) {
    	      return defaultedMembers;
    	    } else if (defaultedMembers.length === 0) {
    	      return initializedMembers;
    	    } else if (defaultedMembers.length > initializedMembers.length) {
    	      for (const member of initializedMembers) {
    	        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
    	          enumName
    	        });
    	      }
    	      return defaultedMembers;
    	    } else {
    	      for (const member of defaultedMembers) {
    	        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
    	          enumName
    	        });
    	      }
    	      return initializedMembers;
    	    }
    	  }
    	  flowEnumParseExplicitType({
    	    enumName
    	  }) {
    	    if (!this.eatContextual(102)) return null;
    	    if (!tokenIsIdentifier(this.state.type)) {
    	      throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {
    	        at: this.state.startLoc,
    	        enumName
    	      });
    	    }
    	    const {
    	      value
    	    } = this.state;
    	    this.next();
    	    if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
    	      this.raise(FlowErrors.EnumInvalidExplicitType, {
    	        at: this.state.startLoc,
    	        enumName,
    	        invalidEnumType: value
    	      });
    	    }
    	    return value;
    	  }
    	  flowEnumBody(node, id) {
    	    const enumName = id.name;
    	    const nameLoc = id.loc.start;
    	    const explicitType = this.flowEnumParseExplicitType({
    	      enumName
    	    });
    	    this.expect(5);
    	    const {
    	      members,
    	      hasUnknownMembers
    	    } = this.flowEnumMembers({
    	      enumName,
    	      explicitType
    	    });
    	    node.hasUnknownMembers = hasUnknownMembers;
    	    switch (explicitType) {
    	      case "boolean":
    	        node.explicitType = true;
    	        node.members = members.booleanMembers;
    	        this.expect(8);
    	        return this.finishNode(node, "EnumBooleanBody");
    	      case "number":
    	        node.explicitType = true;
    	        node.members = members.numberMembers;
    	        this.expect(8);
    	        return this.finishNode(node, "EnumNumberBody");
    	      case "string":
    	        node.explicitType = true;
    	        node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
    	          enumName
    	        });
    	        this.expect(8);
    	        return this.finishNode(node, "EnumStringBody");
    	      case "symbol":
    	        node.members = members.defaultedMembers;
    	        this.expect(8);
    	        return this.finishNode(node, "EnumSymbolBody");
    	      default:
    	        {
    	          const empty = () => {
    	            node.members = [];
    	            this.expect(8);
    	            return this.finishNode(node, "EnumStringBody");
    	          };
    	          node.explicitType = false;
    	          const boolsLen = members.booleanMembers.length;
    	          const numsLen = members.numberMembers.length;
    	          const strsLen = members.stringMembers.length;
    	          const defaultedLen = members.defaultedMembers.length;
    	          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
    	            return empty();
    	          } else if (!boolsLen && !numsLen) {
    	            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
    	              enumName
    	            });
    	            this.expect(8);
    	            return this.finishNode(node, "EnumStringBody");
    	          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
    	            for (const member of members.defaultedMembers) {
    	              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
    	                enumName,
    	                memberName: member.id.name
    	              });
    	            }
    	            node.members = members.booleanMembers;
    	            this.expect(8);
    	            return this.finishNode(node, "EnumBooleanBody");
    	          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
    	            for (const member of members.defaultedMembers) {
    	              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
    	                enumName,
    	                memberName: member.id.name
    	              });
    	            }
    	            node.members = members.numberMembers;
    	            this.expect(8);
    	            return this.finishNode(node, "EnumNumberBody");
    	          } else {
    	            this.raise(FlowErrors.EnumInconsistentMemberValues, {
    	              at: nameLoc,
    	              enumName
    	            });
    	            return empty();
    	          }
    	        }
    	    }
    	  }
    	  flowParseEnumDeclaration(node) {
    	    const id = this.parseIdentifier();
    	    node.id = id;
    	    node.body = this.flowEnumBody(this.startNode(), id);
    	    return this.finishNode(node, "EnumDeclaration");
    	  }
    	  isLookaheadToken_lt() {
    	    const next = this.nextTokenStart();
    	    if (this.input.charCodeAt(next) === 60) {
    	      const afterNext = this.input.charCodeAt(next + 1);
    	      return afterNext !== 60 && afterNext !== 61;
    	    }
    	    return false;
    	  }
    	  maybeUnwrapTypeCastExpression(node) {
    	    return node.type === "TypeCastExpression" ? node.expression : node;
    	  }
    	};
    	const entities = {
    	  __proto__: null,
    	  quot: "\u0022",
    	  amp: "&",
    	  apos: "\u0027",
    	  lt: "<",
    	  gt: ">",
    	  nbsp: "\u00A0",
    	  iexcl: "\u00A1",
    	  cent: "\u00A2",
    	  pound: "\u00A3",
    	  curren: "\u00A4",
    	  yen: "\u00A5",
    	  brvbar: "\u00A6",
    	  sect: "\u00A7",
    	  uml: "\u00A8",
    	  copy: "\u00A9",
    	  ordf: "\u00AA",
    	  laquo: "\u00AB",
    	  not: "\u00AC",
    	  shy: "\u00AD",
    	  reg: "\u00AE",
    	  macr: "\u00AF",
    	  deg: "\u00B0",
    	  plusmn: "\u00B1",
    	  sup2: "\u00B2",
    	  sup3: "\u00B3",
    	  acute: "\u00B4",
    	  micro: "\u00B5",
    	  para: "\u00B6",
    	  middot: "\u00B7",
    	  cedil: "\u00B8",
    	  sup1: "\u00B9",
    	  ordm: "\u00BA",
    	  raquo: "\u00BB",
    	  frac14: "\u00BC",
    	  frac12: "\u00BD",
    	  frac34: "\u00BE",
    	  iquest: "\u00BF",
    	  Agrave: "\u00C0",
    	  Aacute: "\u00C1",
    	  Acirc: "\u00C2",
    	  Atilde: "\u00C3",
    	  Auml: "\u00C4",
    	  Aring: "\u00C5",
    	  AElig: "\u00C6",
    	  Ccedil: "\u00C7",
    	  Egrave: "\u00C8",
    	  Eacute: "\u00C9",
    	  Ecirc: "\u00CA",
    	  Euml: "\u00CB",
    	  Igrave: "\u00CC",
    	  Iacute: "\u00CD",
    	  Icirc: "\u00CE",
    	  Iuml: "\u00CF",
    	  ETH: "\u00D0",
    	  Ntilde: "\u00D1",
    	  Ograve: "\u00D2",
    	  Oacute: "\u00D3",
    	  Ocirc: "\u00D4",
    	  Otilde: "\u00D5",
    	  Ouml: "\u00D6",
    	  times: "\u00D7",
    	  Oslash: "\u00D8",
    	  Ugrave: "\u00D9",
    	  Uacute: "\u00DA",
    	  Ucirc: "\u00DB",
    	  Uuml: "\u00DC",
    	  Yacute: "\u00DD",
    	  THORN: "\u00DE",
    	  szlig: "\u00DF",
    	  agrave: "\u00E0",
    	  aacute: "\u00E1",
    	  acirc: "\u00E2",
    	  atilde: "\u00E3",
    	  auml: "\u00E4",
    	  aring: "\u00E5",
    	  aelig: "\u00E6",
    	  ccedil: "\u00E7",
    	  egrave: "\u00E8",
    	  eacute: "\u00E9",
    	  ecirc: "\u00EA",
    	  euml: "\u00EB",
    	  igrave: "\u00EC",
    	  iacute: "\u00ED",
    	  icirc: "\u00EE",
    	  iuml: "\u00EF",
    	  eth: "\u00F0",
    	  ntilde: "\u00F1",
    	  ograve: "\u00F2",
    	  oacute: "\u00F3",
    	  ocirc: "\u00F4",
    	  otilde: "\u00F5",
    	  ouml: "\u00F6",
    	  divide: "\u00F7",
    	  oslash: "\u00F8",
    	  ugrave: "\u00F9",
    	  uacute: "\u00FA",
    	  ucirc: "\u00FB",
    	  uuml: "\u00FC",
    	  yacute: "\u00FD",
    	  thorn: "\u00FE",
    	  yuml: "\u00FF",
    	  OElig: "\u0152",
    	  oelig: "\u0153",
    	  Scaron: "\u0160",
    	  scaron: "\u0161",
    	  Yuml: "\u0178",
    	  fnof: "\u0192",
    	  circ: "\u02C6",
    	  tilde: "\u02DC",
    	  Alpha: "\u0391",
    	  Beta: "\u0392",
    	  Gamma: "\u0393",
    	  Delta: "\u0394",
    	  Epsilon: "\u0395",
    	  Zeta: "\u0396",
    	  Eta: "\u0397",
    	  Theta: "\u0398",
    	  Iota: "\u0399",
    	  Kappa: "\u039A",
    	  Lambda: "\u039B",
    	  Mu: "\u039C",
    	  Nu: "\u039D",
    	  Xi: "\u039E",
    	  Omicron: "\u039F",
    	  Pi: "\u03A0",
    	  Rho: "\u03A1",
    	  Sigma: "\u03A3",
    	  Tau: "\u03A4",
    	  Upsilon: "\u03A5",
    	  Phi: "\u03A6",
    	  Chi: "\u03A7",
    	  Psi: "\u03A8",
    	  Omega: "\u03A9",
    	  alpha: "\u03B1",
    	  beta: "\u03B2",
    	  gamma: "\u03B3",
    	  delta: "\u03B4",
    	  epsilon: "\u03B5",
    	  zeta: "\u03B6",
    	  eta: "\u03B7",
    	  theta: "\u03B8",
    	  iota: "\u03B9",
    	  kappa: "\u03BA",
    	  lambda: "\u03BB",
    	  mu: "\u03BC",
    	  nu: "\u03BD",
    	  xi: "\u03BE",
    	  omicron: "\u03BF",
    	  pi: "\u03C0",
    	  rho: "\u03C1",
    	  sigmaf: "\u03C2",
    	  sigma: "\u03C3",
    	  tau: "\u03C4",
    	  upsilon: "\u03C5",
    	  phi: "\u03C6",
    	  chi: "\u03C7",
    	  psi: "\u03C8",
    	  omega: "\u03C9",
    	  thetasym: "\u03D1",
    	  upsih: "\u03D2",
    	  piv: "\u03D6",
    	  ensp: "\u2002",
    	  emsp: "\u2003",
    	  thinsp: "\u2009",
    	  zwnj: "\u200C",
    	  zwj: "\u200D",
    	  lrm: "\u200E",
    	  rlm: "\u200F",
    	  ndash: "\u2013",
    	  mdash: "\u2014",
    	  lsquo: "\u2018",
    	  rsquo: "\u2019",
    	  sbquo: "\u201A",
    	  ldquo: "\u201C",
    	  rdquo: "\u201D",
    	  bdquo: "\u201E",
    	  dagger: "\u2020",
    	  Dagger: "\u2021",
    	  bull: "\u2022",
    	  hellip: "\u2026",
    	  permil: "\u2030",
    	  prime: "\u2032",
    	  Prime: "\u2033",
    	  lsaquo: "\u2039",
    	  rsaquo: "\u203A",
    	  oline: "\u203E",
    	  frasl: "\u2044",
    	  euro: "\u20AC",
    	  image: "\u2111",
    	  weierp: "\u2118",
    	  real: "\u211C",
    	  trade: "\u2122",
    	  alefsym: "\u2135",
    	  larr: "\u2190",
    	  uarr: "\u2191",
    	  rarr: "\u2192",
    	  darr: "\u2193",
    	  harr: "\u2194",
    	  crarr: "\u21B5",
    	  lArr: "\u21D0",
    	  uArr: "\u21D1",
    	  rArr: "\u21D2",
    	  dArr: "\u21D3",
    	  hArr: "\u21D4",
    	  forall: "\u2200",
    	  part: "\u2202",
    	  exist: "\u2203",
    	  empty: "\u2205",
    	  nabla: "\u2207",
    	  isin: "\u2208",
    	  notin: "\u2209",
    	  ni: "\u220B",
    	  prod: "\u220F",
    	  sum: "\u2211",
    	  minus: "\u2212",
    	  lowast: "\u2217",
    	  radic: "\u221A",
    	  prop: "\u221D",
    	  infin: "\u221E",
    	  ang: "\u2220",
    	  and: "\u2227",
    	  or: "\u2228",
    	  cap: "\u2229",
    	  cup: "\u222A",
    	  int: "\u222B",
    	  there4: "\u2234",
    	  sim: "\u223C",
    	  cong: "\u2245",
    	  asymp: "\u2248",
    	  ne: "\u2260",
    	  equiv: "\u2261",
    	  le: "\u2264",
    	  ge: "\u2265",
    	  sub: "\u2282",
    	  sup: "\u2283",
    	  nsub: "\u2284",
    	  sube: "\u2286",
    	  supe: "\u2287",
    	  oplus: "\u2295",
    	  otimes: "\u2297",
    	  perp: "\u22A5",
    	  sdot: "\u22C5",
    	  lceil: "\u2308",
    	  rceil: "\u2309",
    	  lfloor: "\u230A",
    	  rfloor: "\u230B",
    	  lang: "\u2329",
    	  rang: "\u232A",
    	  loz: "\u25CA",
    	  spades: "\u2660",
    	  clubs: "\u2663",
    	  hearts: "\u2665",
    	  diams: "\u2666"
    	};
    	const JsxErrors = ParseErrorEnum`jsx`({
    	  AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    	  MissingClosingTagElement: ({
    	    openingTagName
    	  }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
    	  MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    	  UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    	  UnexpectedToken: ({
    	    unexpected,
    	    HTMLEntity
    	  }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
    	  UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    	  UnterminatedJsxContent: "Unterminated JSX contents.",
    	  UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
    	});
    	function isFragment(object) {
    	  return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
    	}
    	function getQualifiedJSXName(object) {
    	  if (object.type === "JSXIdentifier") {
    	    return object.name;
    	  }
    	  if (object.type === "JSXNamespacedName") {
    	    return object.namespace.name + ":" + object.name.name;
    	  }
    	  if (object.type === "JSXMemberExpression") {
    	    return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    	  }
    	  throw new Error("Node had unexpected type: " + object.type);
    	}
    	var jsx = superClass => class JSXParserMixin extends superClass {
    	  jsxReadToken() {
    	    let out = "";
    	    let chunkStart = this.state.pos;
    	    for (;;) {
    	      if (this.state.pos >= this.length) {
    	        throw this.raise(JsxErrors.UnterminatedJsxContent, {
    	          at: this.state.startLoc
    	        });
    	      }
    	      const ch = this.input.charCodeAt(this.state.pos);
    	      switch (ch) {
    	        case 60:
    	        case 123:
    	          if (this.state.pos === this.state.start) {
    	            if (ch === 60 && this.state.canStartJSXElement) {
    	              ++this.state.pos;
    	              this.finishToken(142);
    	            } else {
    	              super.getTokenFromCode(ch);
    	            }
    	            return;
    	          }
    	          out += this.input.slice(chunkStart, this.state.pos);
    	          this.finishToken(141, out);
    	          return;
    	        case 38:
    	          out += this.input.slice(chunkStart, this.state.pos);
    	          out += this.jsxReadEntity();
    	          chunkStart = this.state.pos;
    	          break;
    	        case 62:
    	        case 125:
    	        default:
    	          if (isNewLine(ch)) {
    	            out += this.input.slice(chunkStart, this.state.pos);
    	            out += this.jsxReadNewLine(true);
    	            chunkStart = this.state.pos;
    	          } else {
    	            ++this.state.pos;
    	          }
    	      }
    	    }
    	  }
    	  jsxReadNewLine(normalizeCRLF) {
    	    const ch = this.input.charCodeAt(this.state.pos);
    	    let out;
    	    ++this.state.pos;
    	    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
    	      ++this.state.pos;
    	      out = normalizeCRLF ? "\n" : "\r\n";
    	    } else {
    	      out = String.fromCharCode(ch);
    	    }
    	    ++this.state.curLine;
    	    this.state.lineStart = this.state.pos;
    	    return out;
    	  }
    	  jsxReadString(quote) {
    	    let out = "";
    	    let chunkStart = ++this.state.pos;
    	    for (;;) {
    	      if (this.state.pos >= this.length) {
    	        throw this.raise(Errors.UnterminatedString, {
    	          at: this.state.startLoc
    	        });
    	      }
    	      const ch = this.input.charCodeAt(this.state.pos);
    	      if (ch === quote) break;
    	      if (ch === 38) {
    	        out += this.input.slice(chunkStart, this.state.pos);
    	        out += this.jsxReadEntity();
    	        chunkStart = this.state.pos;
    	      } else if (isNewLine(ch)) {
    	        out += this.input.slice(chunkStart, this.state.pos);
    	        out += this.jsxReadNewLine(false);
    	        chunkStart = this.state.pos;
    	      } else {
    	        ++this.state.pos;
    	      }
    	    }
    	    out += this.input.slice(chunkStart, this.state.pos++);
    	    this.finishToken(133, out);
    	  }
    	  jsxReadEntity() {
    	    const startPos = ++this.state.pos;
    	    if (this.codePointAtPos(this.state.pos) === 35) {
    	      ++this.state.pos;
    	      let radix = 10;
    	      if (this.codePointAtPos(this.state.pos) === 120) {
    	        radix = 16;
    	        ++this.state.pos;
    	      }
    	      const codePoint = this.readInt(radix, undefined, false, "bail");
    	      if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
    	        ++this.state.pos;
    	        return String.fromCodePoint(codePoint);
    	      }
    	    } else {
    	      let count = 0;
    	      let semi = false;
    	      while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59)) {
    	        ++this.state.pos;
    	      }
    	      if (semi) {
    	        const desc = this.input.slice(startPos, this.state.pos);
    	        const entity = entities[desc];
    	        ++this.state.pos;
    	        if (entity) {
    	          return entity;
    	        }
    	      }
    	    }
    	    this.state.pos = startPos;
    	    return "&";
    	  }
    	  jsxReadWord() {
    	    let ch;
    	    const start = this.state.pos;
    	    do {
    	      ch = this.input.charCodeAt(++this.state.pos);
    	    } while (isIdentifierChar(ch) || ch === 45);
    	    this.finishToken(140, this.input.slice(start, this.state.pos));
    	  }
    	  jsxParseIdentifier() {
    	    const node = this.startNode();
    	    if (this.match(140)) {
    	      node.name = this.state.value;
    	    } else if (tokenIsKeyword(this.state.type)) {
    	      node.name = tokenLabelName(this.state.type);
    	    } else {
    	      this.unexpected();
    	    }
    	    this.next();
    	    return this.finishNode(node, "JSXIdentifier");
    	  }
    	  jsxParseNamespacedName() {
    	    const startLoc = this.state.startLoc;
    	    const name = this.jsxParseIdentifier();
    	    if (!this.eat(14)) return name;
    	    const node = this.startNodeAt(startLoc);
    	    node.namespace = name;
    	    node.name = this.jsxParseIdentifier();
    	    return this.finishNode(node, "JSXNamespacedName");
    	  }
    	  jsxParseElementName() {
    	    const startLoc = this.state.startLoc;
    	    let node = this.jsxParseNamespacedName();
    	    if (node.type === "JSXNamespacedName") {
    	      return node;
    	    }
    	    while (this.eat(16)) {
    	      const newNode = this.startNodeAt(startLoc);
    	      newNode.object = node;
    	      newNode.property = this.jsxParseIdentifier();
    	      node = this.finishNode(newNode, "JSXMemberExpression");
    	    }
    	    return node;
    	  }
    	  jsxParseAttributeValue() {
    	    let node;
    	    switch (this.state.type) {
    	      case 5:
    	        node = this.startNode();
    	        this.setContext(types.brace);
    	        this.next();
    	        node = this.jsxParseExpressionContainer(node, types.j_oTag);
    	        if (node.expression.type === "JSXEmptyExpression") {
    	          this.raise(JsxErrors.AttributeIsEmpty, {
    	            at: node
    	          });
    	        }
    	        return node;
    	      case 142:
    	      case 133:
    	        return this.parseExprAtom();
    	      default:
    	        throw this.raise(JsxErrors.UnsupportedJsxValue, {
    	          at: this.state.startLoc
    	        });
    	    }
    	  }
    	  jsxParseEmptyExpression() {
    	    const node = this.startNodeAt(this.state.lastTokEndLoc);
    	    return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
    	  }
    	  jsxParseSpreadChild(node) {
    	    this.next();
    	    node.expression = this.parseExpression();
    	    this.setContext(types.j_expr);
    	    this.state.canStartJSXElement = true;
    	    this.expect(8);
    	    return this.finishNode(node, "JSXSpreadChild");
    	  }
    	  jsxParseExpressionContainer(node, previousContext) {
    	    if (this.match(8)) {
    	      node.expression = this.jsxParseEmptyExpression();
    	    } else {
    	      const expression = this.parseExpression();
    	      node.expression = expression;
    	    }
    	    this.setContext(previousContext);
    	    this.state.canStartJSXElement = true;
    	    this.expect(8);
    	    return this.finishNode(node, "JSXExpressionContainer");
    	  }
    	  jsxParseAttribute() {
    	    const node = this.startNode();
    	    if (this.match(5)) {
    	      this.setContext(types.brace);
    	      this.next();
    	      this.expect(21);
    	      node.argument = this.parseMaybeAssignAllowIn();
    	      this.setContext(types.j_oTag);
    	      this.state.canStartJSXElement = true;
    	      this.expect(8);
    	      return this.finishNode(node, "JSXSpreadAttribute");
    	    }
    	    node.name = this.jsxParseNamespacedName();
    	    node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
    	    return this.finishNode(node, "JSXAttribute");
    	  }
    	  jsxParseOpeningElementAt(startLoc) {
    	    const node = this.startNodeAt(startLoc);
    	    if (this.eat(143)) {
    	      return this.finishNode(node, "JSXOpeningFragment");
    	    }
    	    node.name = this.jsxParseElementName();
    	    return this.jsxParseOpeningElementAfterName(node);
    	  }
    	  jsxParseOpeningElementAfterName(node) {
    	    const attributes = [];
    	    while (!this.match(56) && !this.match(143)) {
    	      attributes.push(this.jsxParseAttribute());
    	    }
    	    node.attributes = attributes;
    	    node.selfClosing = this.eat(56);
    	    this.expect(143);
    	    return this.finishNode(node, "JSXOpeningElement");
    	  }
    	  jsxParseClosingElementAt(startLoc) {
    	    const node = this.startNodeAt(startLoc);
    	    if (this.eat(143)) {
    	      return this.finishNode(node, "JSXClosingFragment");
    	    }
    	    node.name = this.jsxParseElementName();
    	    this.expect(143);
    	    return this.finishNode(node, "JSXClosingElement");
    	  }
    	  jsxParseElementAt(startLoc) {
    	    const node = this.startNodeAt(startLoc);
    	    const children = [];
    	    const openingElement = this.jsxParseOpeningElementAt(startLoc);
    	    let closingElement = null;
    	    if (!openingElement.selfClosing) {
    	      contents: for (;;) {
    	        switch (this.state.type) {
    	          case 142:
    	            startLoc = this.state.startLoc;
    	            this.next();
    	            if (this.eat(56)) {
    	              closingElement = this.jsxParseClosingElementAt(startLoc);
    	              break contents;
    	            }
    	            children.push(this.jsxParseElementAt(startLoc));
    	            break;
    	          case 141:
    	            children.push(this.parseExprAtom());
    	            break;
    	          case 5:
    	            {
    	              const node = this.startNode();
    	              this.setContext(types.brace);
    	              this.next();
    	              if (this.match(21)) {
    	                children.push(this.jsxParseSpreadChild(node));
    	              } else {
    	                children.push(this.jsxParseExpressionContainer(node, types.j_expr));
    	              }
    	              break;
    	            }
    	          default:
    	            this.unexpected();
    	        }
    	      }
    	      if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
    	        this.raise(JsxErrors.MissingClosingTagFragment, {
    	          at: closingElement
    	        });
    	      } else if (!isFragment(openingElement) && isFragment(closingElement)) {
    	        this.raise(JsxErrors.MissingClosingTagElement, {
    	          at: closingElement,
    	          openingTagName: getQualifiedJSXName(openingElement.name)
    	        });
    	      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
    	        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
    	          this.raise(JsxErrors.MissingClosingTagElement, {
    	            at: closingElement,
    	            openingTagName: getQualifiedJSXName(openingElement.name)
    	          });
    	        }
    	      }
    	    }
    	    if (isFragment(openingElement)) {
    	      node.openingFragment = openingElement;
    	      node.closingFragment = closingElement;
    	    } else {
    	      node.openingElement = openingElement;
    	      node.closingElement = closingElement;
    	    }
    	    node.children = children;
    	    if (this.match(47)) {
    	      throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {
    	        at: this.state.startLoc
    	      });
    	    }
    	    return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
    	  }
    	  jsxParseElement() {
    	    const startLoc = this.state.startLoc;
    	    this.next();
    	    return this.jsxParseElementAt(startLoc);
    	  }
    	  setContext(newContext) {
    	    const {
    	      context
    	    } = this.state;
    	    context[context.length - 1] = newContext;
    	  }
    	  parseExprAtom(refExpressionErrors) {
    	    if (this.match(141)) {
    	      return this.parseLiteral(this.state.value, "JSXText");
    	    } else if (this.match(142)) {
    	      return this.jsxParseElement();
    	    } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
    	      this.replaceToken(142);
    	      return this.jsxParseElement();
    	    } else {
    	      return super.parseExprAtom(refExpressionErrors);
    	    }
    	  }
    	  skipSpace() {
    	    const curContext = this.curContext();
    	    if (!curContext.preserveSpace) super.skipSpace();
    	  }
    	  getTokenFromCode(code) {
    	    const context = this.curContext();
    	    if (context === types.j_expr) {
    	      this.jsxReadToken();
    	      return;
    	    }
    	    if (context === types.j_oTag || context === types.j_cTag) {
    	      if (isIdentifierStart(code)) {
    	        this.jsxReadWord();
    	        return;
    	      }
    	      if (code === 62) {
    	        ++this.state.pos;
    	        this.finishToken(143);
    	        return;
    	      }
    	      if ((code === 34 || code === 39) && context === types.j_oTag) {
    	        this.jsxReadString(code);
    	        return;
    	      }
    	    }
    	    if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
    	      ++this.state.pos;
    	      this.finishToken(142);
    	      return;
    	    }
    	    super.getTokenFromCode(code);
    	  }
    	  updateContext(prevType) {
    	    const {
    	      context,
    	      type
    	    } = this.state;
    	    if (type === 56 && prevType === 142) {
    	      context.splice(-2, 2, types.j_cTag);
    	      this.state.canStartJSXElement = false;
    	    } else if (type === 142) {
    	      context.push(types.j_oTag);
    	    } else if (type === 143) {
    	      const out = context[context.length - 1];
    	      if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {
    	        context.pop();
    	        this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;
    	      } else {
    	        this.setContext(types.j_expr);
    	        this.state.canStartJSXElement = true;
    	      }
    	    } else {
    	      this.state.canStartJSXElement = tokenComesBeforeExpression(type);
    	    }
    	  }
    	};
    	class TypeScriptScope extends Scope {
    	  constructor(...args) {
    	    super(...args);
    	    this.types = new Set();
    	    this.enums = new Set();
    	    this.constEnums = new Set();
    	    this.classes = new Set();
    	    this.exportOnlyBindings = new Set();
    	  }
    	}
    	class TypeScriptScopeHandler extends ScopeHandler {
    	  constructor(...args) {
    	    super(...args);
    	    this.importsStack = [];
    	  }
    	  createScope(flags) {
    	    this.importsStack.push(new Set());
    	    return new TypeScriptScope(flags);
    	  }
    	  enter(flags) {
    	    if (flags == 256) {
    	      this.importsStack.push(new Set());
    	    }
    	    super.enter(flags);
    	  }
    	  exit() {
    	    const flags = super.exit();
    	    if (flags == 256) {
    	      this.importsStack.pop();
    	    }
    	    return flags;
    	  }
    	  hasImport(name, allowShadow) {
    	    const len = this.importsStack.length;
    	    if (this.importsStack[len - 1].has(name)) {
    	      return true;
    	    }
    	    if (!allowShadow && len > 1) {
    	      for (let i = 0; i < len - 1; i++) {
    	        if (this.importsStack[i].has(name)) return true;
    	      }
    	    }
    	    return false;
    	  }
    	  declareName(name, bindingType, loc) {
    	    if (bindingType & 4096) {
    	      if (this.hasImport(name, true)) {
    	        this.parser.raise(Errors.VarRedeclaration, {
    	          at: loc,
    	          identifierName: name
    	        });
    	      }
    	      this.importsStack[this.importsStack.length - 1].add(name);
    	      return;
    	    }
    	    const scope = this.currentScope();
    	    if (bindingType & 1024) {
    	      this.maybeExportDefined(scope, name);
    	      scope.exportOnlyBindings.add(name);
    	      return;
    	    }
    	    super.declareName(name, bindingType, loc);
    	    if (bindingType & 2) {
    	      if (!(bindingType & 1)) {
    	        this.checkRedeclarationInScope(scope, name, bindingType, loc);
    	        this.maybeExportDefined(scope, name);
    	      }
    	      scope.types.add(name);
    	    }
    	    if (bindingType & 256) scope.enums.add(name);
    	    if (bindingType & 512) {
    	      scope.constEnums.add(name);
    	    }
    	    if (bindingType & 128) scope.classes.add(name);
    	  }
    	  isRedeclaredInScope(scope, name, bindingType) {
    	    if (scope.enums.has(name)) {
    	      if (bindingType & 256) {
    	        const isConst = !!(bindingType & 512);
    	        const wasConst = scope.constEnums.has(name);
    	        return isConst !== wasConst;
    	      }
    	      return true;
    	    }
    	    if (bindingType & 128 && scope.classes.has(name)) {
    	      if (scope.lexical.has(name)) {
    	        return !!(bindingType & 1);
    	      } else {
    	        return false;
    	      }
    	    }
    	    if (bindingType & 2 && scope.types.has(name)) {
    	      return true;
    	    }
    	    return super.isRedeclaredInScope(scope, name, bindingType);
    	  }
    	  checkLocalExport(id) {
    	    const {
    	      name
    	    } = id;
    	    if (this.hasImport(name)) return;
    	    const len = this.scopeStack.length;
    	    for (let i = len - 1; i >= 0; i--) {
    	      const scope = this.scopeStack[i];
    	      if (scope.types.has(name) || scope.exportOnlyBindings.has(name)) return;
    	    }
    	    super.checkLocalExport(id);
    	  }
    	}
    	const getOwn$1 = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];
    	const unwrapParenthesizedExpression = node => {
    	  return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
    	};
    	class LValParser extends NodeUtils {
    	  toAssignable(node, isLHS = false) {
    	    var _node$extra, _node$extra3;
    	    let parenthesized = undefined;
    	    if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
    	      parenthesized = unwrapParenthesizedExpression(node);
    	      if (isLHS) {
    	        if (parenthesized.type === "Identifier") {
    	          this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, {
    	            at: node
    	          });
    	        } else if (parenthesized.type !== "MemberExpression" && !this.isOptionalMemberExpression(parenthesized)) {
    	          this.raise(Errors.InvalidParenthesizedAssignment, {
    	            at: node
    	          });
    	        }
    	      } else {
    	        this.raise(Errors.InvalidParenthesizedAssignment, {
    	          at: node
    	        });
    	      }
    	    }
    	    switch (node.type) {
    	      case "Identifier":
    	      case "ObjectPattern":
    	      case "ArrayPattern":
    	      case "AssignmentPattern":
    	      case "RestElement":
    	        break;
    	      case "ObjectExpression":
    	        node.type = "ObjectPattern";
    	        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
    	          var _node$extra2;
    	          const prop = node.properties[i];
    	          const isLast = i === last;
    	          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
    	          if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
    	            this.raise(Errors.RestTrailingComma, {
    	              at: node.extra.trailingCommaLoc
    	            });
    	          }
    	        }
    	        break;
    	      case "ObjectProperty":
    	        {
    	          const {
    	            key,
    	            value
    	          } = node;
    	          if (this.isPrivateName(key)) {
    	            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
    	          }
    	          this.toAssignable(value, isLHS);
    	          break;
    	        }
    	      case "SpreadElement":
    	        {
    	          throw new Error("Internal @babel/parser error (this is a bug, please report it)." + " SpreadElement should be converted by .toAssignable's caller.");
    	        }
    	      case "ArrayExpression":
    	        node.type = "ArrayPattern";
    	        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
    	        break;
    	      case "AssignmentExpression":
    	        if (node.operator !== "=") {
    	          this.raise(Errors.MissingEqInAssignment, {
    	            at: node.left.loc.end
    	          });
    	        }
    	        node.type = "AssignmentPattern";
    	        delete node.operator;
    	        this.toAssignable(node.left, isLHS);
    	        break;
    	      case "ParenthesizedExpression":
    	        this.toAssignable(parenthesized, isLHS);
    	        break;
    	    }
    	  }
    	  toAssignableObjectExpressionProp(prop, isLast, isLHS) {
    	    if (prop.type === "ObjectMethod") {
    	      this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, {
    	        at: prop.key
    	      });
    	    } else if (prop.type === "SpreadElement") {
    	      prop.type = "RestElement";
    	      const arg = prop.argument;
    	      this.checkToRestConversion(arg, false);
    	      this.toAssignable(arg, isLHS);
    	      if (!isLast) {
    	        this.raise(Errors.RestTrailingComma, {
    	          at: prop
    	        });
    	      }
    	    } else {
    	      this.toAssignable(prop, isLHS);
    	    }
    	  }
    	  toAssignableList(exprList, trailingCommaLoc, isLHS) {
    	    const end = exprList.length - 1;
    	    for (let i = 0; i <= end; i++) {
    	      const elt = exprList[i];
    	      if (!elt) continue;
    	      if (elt.type === "SpreadElement") {
    	        elt.type = "RestElement";
    	        const arg = elt.argument;
    	        this.checkToRestConversion(arg, true);
    	        this.toAssignable(arg, isLHS);
    	      } else {
    	        this.toAssignable(elt, isLHS);
    	      }
    	      if (elt.type === "RestElement") {
    	        if (i < end) {
    	          this.raise(Errors.RestTrailingComma, {
    	            at: elt
    	          });
    	        } else if (trailingCommaLoc) {
    	          this.raise(Errors.RestTrailingComma, {
    	            at: trailingCommaLoc
    	          });
    	        }
    	      }
    	    }
    	  }
    	  isAssignable(node, isBinding) {
    	    switch (node.type) {
    	      case "Identifier":
    	      case "ObjectPattern":
    	      case "ArrayPattern":
    	      case "AssignmentPattern":
    	      case "RestElement":
    	        return true;
    	      case "ObjectExpression":
    	        {
    	          const last = node.properties.length - 1;
    	          return node.properties.every((prop, i) => {
    	            return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
    	          });
    	        }
    	      case "ObjectProperty":
    	        return this.isAssignable(node.value);
    	      case "SpreadElement":
    	        return this.isAssignable(node.argument);
    	      case "ArrayExpression":
    	        return node.elements.every(element => element === null || this.isAssignable(element));
    	      case "AssignmentExpression":
    	        return node.operator === "=";
    	      case "ParenthesizedExpression":
    	        return this.isAssignable(node.expression);
    	      case "MemberExpression":
    	      case "OptionalMemberExpression":
    	        return !isBinding;
    	      default:
    	        return false;
    	    }
    	  }
    	  toReferencedList(exprList, isParenthesizedExpr) {
    	    return exprList;
    	  }
    	  toReferencedListDeep(exprList, isParenthesizedExpr) {
    	    this.toReferencedList(exprList, isParenthesizedExpr);
    	    for (const expr of exprList) {
    	      if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
    	        this.toReferencedListDeep(expr.elements);
    	      }
    	    }
    	  }
    	  parseSpread(refExpressionErrors) {
    	    const node = this.startNode();
    	    this.next();
    	    node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined);
    	    return this.finishNode(node, "SpreadElement");
    	  }
    	  parseRestBinding() {
    	    const node = this.startNode();
    	    this.next();
    	    node.argument = this.parseBindingAtom();
    	    return this.finishNode(node, "RestElement");
    	  }
    	  parseBindingAtom() {
    	    switch (this.state.type) {
    	      case 0:
    	        {
    	          const node = this.startNode();
    	          this.next();
    	          node.elements = this.parseBindingList(3, 93, 1);
    	          return this.finishNode(node, "ArrayPattern");
    	        }
    	      case 5:
    	        return this.parseObjectLike(8, true);
    	    }
    	    return this.parseIdentifier();
    	  }
    	  parseBindingList(close, closeCharCode, flags) {
    	    const allowEmpty = flags & 1;
    	    const elts = [];
    	    let first = true;
    	    while (!this.eat(close)) {
    	      if (first) {
    	        first = false;
    	      } else {
    	        this.expect(12);
    	      }
    	      if (allowEmpty && this.match(12)) {
    	        elts.push(null);
    	      } else if (this.eat(close)) {
    	        break;
    	      } else if (this.match(21)) {
    	        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding(), flags));
    	        if (!this.checkCommaAfterRest(closeCharCode)) {
    	          this.expect(close);
    	          break;
    	        }
    	      } else {
    	        const decorators = [];
    	        if (this.match(26) && this.hasPlugin("decorators")) {
    	          this.raise(Errors.UnsupportedParameterDecorator, {
    	            at: this.state.startLoc
    	          });
    	        }
    	        while (this.match(26)) {
    	          decorators.push(this.parseDecorator());
    	        }
    	        elts.push(this.parseAssignableListItem(flags, decorators));
    	      }
    	    }
    	    return elts;
    	  }
    	  parseBindingRestProperty(prop) {
    	    this.next();
    	    prop.argument = this.parseIdentifier();
    	    this.checkCommaAfterRest(125);
    	    return this.finishNode(prop, "RestElement");
    	  }
    	  parseBindingProperty() {
    	    const prop = this.startNode();
    	    const {
    	      type,
    	      startLoc
    	    } = this.state;
    	    if (type === 21) {
    	      return this.parseBindingRestProperty(prop);
    	    } else if (type === 138) {
    	      this.expectPlugin("destructuringPrivate", startLoc);
    	      this.classScope.usePrivateName(this.state.value, startLoc);
    	      prop.key = this.parsePrivateName();
    	    } else {
    	      this.parsePropertyName(prop);
    	    }
    	    prop.method = false;
    	    return this.parseObjPropValue(prop, startLoc, false, false, true, false);
    	  }
    	  parseAssignableListItem(flags, decorators) {
    	    const left = this.parseMaybeDefault();
    	    this.parseAssignableListItemTypes(left, flags);
    	    const elt = this.parseMaybeDefault(left.loc.start, left);
    	    if (decorators.length) {
    	      left.decorators = decorators;
    	    }
    	    return elt;
    	  }
    	  parseAssignableListItemTypes(param, flags) {
    	    return param;
    	  }
    	  parseMaybeDefault(startLoc, left) {
    	    var _startLoc, _left;
    	    (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;
    	    left = (_left = left) != null ? _left : this.parseBindingAtom();
    	    if (!this.eat(29)) return left;
    	    const node = this.startNodeAt(startLoc);
    	    node.left = left;
    	    node.right = this.parseMaybeAssignAllowIn();
    	    return this.finishNode(node, "AssignmentPattern");
    	  }
    	  isValidLVal(type, isUnparenthesizedInAssign, binding) {
    	    return getOwn$1({
    	      AssignmentPattern: "left",
    	      RestElement: "argument",
    	      ObjectProperty: "value",
    	      ParenthesizedExpression: "expression",
    	      ArrayPattern: "elements",
    	      ObjectPattern: "properties"
    	    }, type);
    	  }
    	  isOptionalMemberExpression(expression) {
    	    return expression.type === "OptionalMemberExpression";
    	  }
    	  checkLVal(expression, {
    	    in: ancestor,
    	    binding = 64,
    	    checkClashes = false,
    	    strictModeChanged = false,
    	    hasParenthesizedAncestor = false
    	  }) {
    	    var _expression$extra;
    	    const type = expression.type;
    	    if (this.isObjectMethod(expression)) return;
    	    const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);
    	    if (isOptionalMemberExpression || type === "MemberExpression") {
    	      if (isOptionalMemberExpression) {
    	        this.expectPlugin("optionalChainingAssign", expression.loc.start);
    	        if (ancestor.type !== "AssignmentExpression") {
    	          this.raise(Errors.InvalidLhsOptionalChaining, {
    	            at: expression,
    	            ancestor
    	          });
    	        }
    	      }
    	      if (binding !== 64) {
    	        this.raise(Errors.InvalidPropertyBindingPattern, {
    	          at: expression
    	        });
    	      }
    	      return;
    	    }
    	    if (type === "Identifier") {
    	      this.checkIdentifier(expression, binding, strictModeChanged);
    	      const {
    	        name
    	      } = expression;
    	      if (checkClashes) {
    	        if (checkClashes.has(name)) {
    	          this.raise(Errors.ParamDupe, {
    	            at: expression
    	          });
    	        } else {
    	          checkClashes.add(name);
    	        }
    	      }
    	      return;
    	    }
    	    const validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
    	    if (validity === true) return;
    	    if (validity === false) {
    	      const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
    	      this.raise(ParseErrorClass, {
    	        at: expression,
    	        ancestor
    	      });
    	      return;
    	    }
    	    const [key, isParenthesizedExpression] = Array.isArray(validity) ? validity : [validity, type === "ParenthesizedExpression"];
    	    const nextAncestor = type === "ArrayPattern" || type === "ObjectPattern" ? {
    	      type
    	    } : ancestor;
    	    for (const child of [].concat(expression[key])) {
    	      if (child) {
    	        this.checkLVal(child, {
    	          in: nextAncestor,
    	          binding,
    	          checkClashes,
    	          strictModeChanged,
    	          hasParenthesizedAncestor: isParenthesizedExpression
    	        });
    	      }
    	    }
    	  }
    	  checkIdentifier(at, bindingType, strictModeChanged = false) {
    	    if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {
    	      if (bindingType === 64) {
    	        this.raise(Errors.StrictEvalArguments, {
    	          at,
    	          referenceName: at.name
    	        });
    	      } else {
    	        this.raise(Errors.StrictEvalArgumentsBinding, {
    	          at,
    	          bindingName: at.name
    	        });
    	      }
    	    }
    	    if (bindingType & 8192 && at.name === "let") {
    	      this.raise(Errors.LetInLexicalBinding, {
    	        at
    	      });
    	    }
    	    if (!(bindingType & 64)) {
    	      this.declareNameFromIdentifier(at, bindingType);
    	    }
    	  }
    	  declareNameFromIdentifier(identifier, binding) {
    	    this.scope.declareName(identifier.name, binding, identifier.loc.start);
    	  }
    	  checkToRestConversion(node, allowPattern) {
    	    switch (node.type) {
    	      case "ParenthesizedExpression":
    	        this.checkToRestConversion(node.expression, allowPattern);
    	        break;
    	      case "Identifier":
    	      case "MemberExpression":
    	        break;
    	      case "ArrayExpression":
    	      case "ObjectExpression":
    	        if (allowPattern) break;
    	      default:
    	        this.raise(Errors.InvalidRestAssignmentPattern, {
    	          at: node
    	        });
    	    }
    	  }
    	  checkCommaAfterRest(close) {
    	    if (!this.match(12)) {
    	      return false;
    	    }
    	    this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, {
    	      at: this.state.startLoc
    	    });
    	    return true;
    	  }
    	}
    	const getOwn = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];
    	function nonNull(x) {
    	  if (x == null) {
    	    throw new Error(`Unexpected ${x} value.`);
    	  }
    	  return x;
    	}
    	function assert(x) {
    	  if (!x) {
    	    throw new Error("Assert fail");
    	  }
    	}
    	const TSErrors = ParseErrorEnum`typescript`({
    	  AbstractMethodHasImplementation: ({
    	    methodName
    	  }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
    	  AbstractPropertyHasInitializer: ({
    	    propertyName
    	  }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
    	  AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    	  AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    	  AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    	  ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    	  ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    	  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
    	  ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    	  DeclareAccessor: ({
    	    kind
    	  }) => `'declare' is not allowed in ${kind}ters.`,
    	  DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    	  DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    	  DuplicateAccessibilityModifier: ({
    	    modifier
    	  }) => `Accessibility modifier already seen.`,
    	  DuplicateModifier: ({
    	    modifier
    	  }) => `Duplicate modifier: '${modifier}'.`,
    	  EmptyHeritageClauseType: ({
    	    token
    	  }) => `'${token}' list cannot be empty.`,
    	  EmptyTypeArguments: "Type argument list cannot be empty.",
    	  EmptyTypeParameters: "Type parameter list cannot be empty.",
    	  ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    	  ImportAliasHasImportType: "An import alias can not use 'import type'.",
    	  ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    	  IncompatibleModifiers: ({
    	    modifiers
    	  }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
    	  IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    	  IndexSignatureHasAccessibility: ({
    	    modifier
    	  }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
    	  IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    	  IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    	  IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    	  InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    	  InvalidModifierOnTypeMember: ({
    	    modifier
    	  }) => `'${modifier}' modifier cannot appear on a type member.`,
    	  InvalidModifierOnTypeParameter: ({
    	    modifier
    	  }) => `'${modifier}' modifier cannot appear on a type parameter.`,
    	  InvalidModifierOnTypeParameterPositions: ({
    	    modifier
    	  }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
    	  InvalidModifiersOrder: ({
    	    orderedModifiers
    	  }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
    	  InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. " + "You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
    	  InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    	  MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    	  NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    	  NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    	  OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    	  OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    	  PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    	  PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    	  PrivateElementHasAccessibility: ({
    	    modifier
    	  }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
    	  ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    	  ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    	  ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    	  SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    	  SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    	  SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    	  SingleTypeParameterWithoutTrailingComma: ({
    	    typeParameterName
    	  }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
    	  StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    	  TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
    	  TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    	  TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    	  TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
    	  TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
    	  UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    	  UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    	  UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    	  UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    	  UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    	  UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    	  UnsupportedSignatureParameterKind: ({
    	    type
    	  }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`
    	});
    	function keywordTypeFromName(value) {
    	  switch (value) {
    	    case "any":
    	      return "TSAnyKeyword";
    	    case "boolean":
    	      return "TSBooleanKeyword";
    	    case "bigint":
    	      return "TSBigIntKeyword";
    	    case "never":
    	      return "TSNeverKeyword";
    	    case "number":
    	      return "TSNumberKeyword";
    	    case "object":
    	      return "TSObjectKeyword";
    	    case "string":
    	      return "TSStringKeyword";
    	    case "symbol":
    	      return "TSSymbolKeyword";
    	    case "undefined":
    	      return "TSUndefinedKeyword";
    	    case "unknown":
    	      return "TSUnknownKeyword";
    	    default:
    	      return undefined;
    	  }
    	}
    	function tsIsAccessModifier(modifier) {
    	  return modifier === "private" || modifier === "public" || modifier === "protected";
    	}
    	function tsIsVarianceAnnotations(modifier) {
    	  return modifier === "in" || modifier === "out";
    	}
    	var typescript = superClass => class TypeScriptParserMixin extends superClass {
    	  constructor(...args) {
    	    super(...args);
    	    this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
    	      allowedModifiers: ["in", "out"],
    	      disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
    	      errorTemplate: TSErrors.InvalidModifierOnTypeParameter
    	    });
    	    this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
    	      allowedModifiers: ["const"],
    	      disallowedModifiers: ["in", "out"],
    	      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
    	    });
    	    this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
    	      allowedModifiers: ["in", "out", "const"],
    	      disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
    	      errorTemplate: TSErrors.InvalidModifierOnTypeParameter
    	    });
    	  }
    	  getScopeHandler() {
    	    return TypeScriptScopeHandler;
    	  }
    	  tsIsIdentifier() {
    	    return tokenIsIdentifier(this.state.type);
    	  }
    	  tsTokenCanFollowModifier() {
    	    return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
    	  }
    	  tsNextTokenCanFollowModifier() {
    	    this.next();
    	    return this.tsTokenCanFollowModifier();
    	  }
    	  tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
    	    if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {
    	      return undefined;
    	    }
    	    const modifier = this.state.value;
    	    if (allowedModifiers.indexOf(modifier) !== -1) {
    	      if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
    	        return undefined;
    	      }
    	      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
    	        return modifier;
    	      }
    	    }
    	    return undefined;
    	  }
    	  tsParseModifiers({
    	    allowedModifiers,
    	    disallowedModifiers,
    	    stopOnStartOfClassStaticBlock,
    	    errorTemplate = TSErrors.InvalidModifierOnTypeMember
    	  }, modified) {
    	    const enforceOrder = (loc, modifier, before, after) => {
    	      if (modifier === before && modified[after]) {
    	        this.raise(TSErrors.InvalidModifiersOrder, {
    	          at: loc,
    	          orderedModifiers: [before, after]
    	        });
    	      }
    	    };
    	    const incompatible = (loc, modifier, mod1, mod2) => {
    	      if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
    	        this.raise(TSErrors.IncompatibleModifiers, {
    	          at: loc,
    	          modifiers: [mod1, mod2]
    	        });
    	      }
    	    };
    	    for (;;) {
    	      const {
    	        startLoc
    	      } = this.state;
    	      const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
    	      if (!modifier) break;
    	      if (tsIsAccessModifier(modifier)) {
    	        if (modified.accessibility) {
    	          this.raise(TSErrors.DuplicateAccessibilityModifier, {
    	            at: startLoc,
    	            modifier
    	          });
    	        } else {
    	          enforceOrder(startLoc, modifier, modifier, "override");
    	          enforceOrder(startLoc, modifier, modifier, "static");
    	          enforceOrder(startLoc, modifier, modifier, "readonly");
    	          modified.accessibility = modifier;
    	        }
    	      } else if (tsIsVarianceAnnotations(modifier)) {
    	        if (modified[modifier]) {
    	          this.raise(TSErrors.DuplicateModifier, {
    	            at: startLoc,
    	            modifier
    	          });
    	        }
    	        modified[modifier] = true;
    	        enforceOrder(startLoc, modifier, "in", "out");
    	      } else {
    	        if (Object.hasOwnProperty.call(modified, modifier)) {
    	          this.raise(TSErrors.DuplicateModifier, {
    	            at: startLoc,
    	            modifier
    	          });
    	        } else {
    	          enforceOrder(startLoc, modifier, "static", "readonly");
    	          enforceOrder(startLoc, modifier, "static", "override");
    	          enforceOrder(startLoc, modifier, "override", "readonly");
    	          enforceOrder(startLoc, modifier, "abstract", "override");
    	          incompatible(startLoc, modifier, "declare", "override");
    	          incompatible(startLoc, modifier, "static", "abstract");
    	        }
    	        modified[modifier] = true;
    	      }
    	      if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
    	        this.raise(errorTemplate, {
    	          at: startLoc,
    	          modifier
    	        });
    	      }
    	    }
    	  }
    	  tsIsListTerminator(kind) {
    	    switch (kind) {
    	      case "EnumMembers":
    	      case "TypeMembers":
    	        return this.match(8);
    	      case "HeritageClauseElement":
    	        return this.match(5);
    	      case "TupleElementTypes":
    	        return this.match(3);
    	      case "TypeParametersOrArguments":
    	        return this.match(48);
    	    }
    	  }
    	  tsParseList(kind, parseElement) {
    	    const result = [];
    	    while (!this.tsIsListTerminator(kind)) {
    	      result.push(parseElement());
    	    }
    	    return result;
    	  }
    	  tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
    	    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
    	  }
    	  tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
    	    const result = [];
    	    let trailingCommaPos = -1;
    	    for (;;) {
    	      if (this.tsIsListTerminator(kind)) {
    	        break;
    	      }
    	      trailingCommaPos = -1;
    	      const element = parseElement();
    	      if (element == null) {
    	        return undefined;
    	      }
    	      result.push(element);
    	      if (this.eat(12)) {
    	        trailingCommaPos = this.state.lastTokStart;
    	        continue;
    	      }
    	      if (this.tsIsListTerminator(kind)) {
    	        break;
    	      }
    	      if (expectSuccess) {
    	        this.expect(12);
    	      }
    	      return undefined;
    	    }
    	    if (refTrailingCommaPos) {
    	      refTrailingCommaPos.value = trailingCommaPos;
    	    }
    	    return result;
    	  }
    	  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
    	    if (!skipFirstToken) {
    	      if (bracket) {
    	        this.expect(0);
    	      } else {
    	        this.expect(47);
    	      }
    	    }
    	    const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
    	    if (bracket) {
    	      this.expect(3);
    	    } else {
    	      this.expect(48);
    	    }
    	    return result;
    	  }
    	  tsParseImportType() {
    	    const node = this.startNode();
    	    this.expect(83);
    	    this.expect(10);
    	    if (!this.match(133)) {
    	      this.raise(TSErrors.UnsupportedImportTypeArgument, {
    	        at: this.state.startLoc
    	      });
    	    }
    	    node.argument = super.parseExprAtom();
    	    this.expect(11);
    	    if (this.eat(16)) {
    	      node.qualifier = this.tsParseEntityName();
    	    }
    	    if (this.match(47)) {
    	      node.typeParameters = this.tsParseTypeArguments();
    	    }
    	    return this.finishNode(node, "TSImportType");
    	  }
    	  tsParseEntityName(allowReservedWords = true) {
    	    let entity = this.parseIdentifier(allowReservedWords);
    	    while (this.eat(16)) {
    	      const node = this.startNodeAtNode(entity);
    	      node.left = entity;
    	      node.right = this.parseIdentifier(allowReservedWords);
    	      entity = this.finishNode(node, "TSQualifiedName");
    	    }
    	    return entity;
    	  }
    	  tsParseTypeReference() {
    	    const node = this.startNode();
    	    node.typeName = this.tsParseEntityName();
    	    if (!this.hasPrecedingLineBreak() && this.match(47)) {
    	      node.typeParameters = this.tsParseTypeArguments();
    	    }
    	    return this.finishNode(node, "TSTypeReference");
    	  }
    	  tsParseThisTypePredicate(lhs) {
    	    this.next();
    	    const node = this.startNodeAtNode(lhs);
    	    node.parameterName = lhs;
    	    node.typeAnnotation = this.tsParseTypeAnnotation(false);
    	    node.asserts = false;
    	    return this.finishNode(node, "TSTypePredicate");
    	  }
    	  tsParseThisTypeNode() {
    	    const node = this.startNode();
    	    this.next();
    	    return this.finishNode(node, "TSThisType");
    	  }
    	  tsParseTypeQuery() {
    	    const node = this.startNode();
    	    this.expect(87);
    	    if (this.match(83)) {
    	      node.exprName = this.tsParseImportType();
    	    } else {
    	      node.exprName = this.tsParseEntityName();
    	    }
    	    if (!this.hasPrecedingLineBreak() && this.match(47)) {
    	      node.typeParameters = this.tsParseTypeArguments();
    	    }
    	    return this.finishNode(node, "TSTypeQuery");
    	  }
    	  tsParseTypeParameter(parseModifiers) {
    	    const node = this.startNode();
    	    parseModifiers(node);
    	    node.name = this.tsParseTypeParameterName();
    	    node.constraint = this.tsEatThenParseType(81);
    	    node.default = this.tsEatThenParseType(29);
    	    return this.finishNode(node, "TSTypeParameter");
    	  }
    	  tsTryParseTypeParameters(parseModifiers) {
    	    if (this.match(47)) {
    	      return this.tsParseTypeParameters(parseModifiers);
    	    }
    	  }
    	  tsParseTypeParameters(parseModifiers) {
    	    const node = this.startNode();
    	    if (this.match(47) || this.match(142)) {
    	      this.next();
    	    } else {
    	      this.unexpected();
    	    }
    	    const refTrailingCommaPos = {
    	      value: -1
    	    };
    	    node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
    	    if (node.params.length === 0) {
    	      this.raise(TSErrors.EmptyTypeParameters, {
    	        at: node
    	      });
    	    }
    	    if (refTrailingCommaPos.value !== -1) {
    	      this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
    	    }
    	    return this.finishNode(node, "TSTypeParameterDeclaration");
    	  }
    	  tsFillSignature(returnToken, signature) {
    	    const returnTokenRequired = returnToken === 19;
    	    const paramsKey = "parameters";
    	    const returnTypeKey = "typeAnnotation";
    	    signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    	    this.expect(10);
    	    signature[paramsKey] = this.tsParseBindingListForSignature();
    	    if (returnTokenRequired) {
    	      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
    	    } else if (this.match(returnToken)) {
    	      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
    	    }
    	  }
    	  tsParseBindingListForSignature() {
    	    const list = super.parseBindingList(11, 41, 2);
    	    for (const pattern of list) {
    	      const {
    	        type
    	      } = pattern;
    	      if (type === "AssignmentPattern" || type === "TSParameterProperty") {
    	        this.raise(TSErrors.UnsupportedSignatureParameterKind, {
    	          at: pattern,
    	          type
    	        });
    	      }
    	    }
    	    return list;
    	  }
    	  tsParseTypeMemberSemicolon() {
    	    if (!this.eat(12) && !this.isLineTerminator()) {
    	      this.expect(13);
    	    }
    	  }
    	  tsParseSignatureMember(kind, node) {
    	    this.tsFillSignature(14, node);
    	    this.tsParseTypeMemberSemicolon();
    	    return this.finishNode(node, kind);
    	  }
    	  tsIsUnambiguouslyIndexSignature() {
    	    this.next();
    	    if (tokenIsIdentifier(this.state.type)) {
    	      this.next();
    	      return this.match(14);
    	    }
    	    return false;
    	  }
    	  tsTryParseIndexSignature(node) {
    	    if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
    	      return;
    	    }
    	    this.expect(0);
    	    const id = this.parseIdentifier();
    	    id.typeAnnotation = this.tsParseTypeAnnotation();
    	    this.resetEndLocation(id);
    	    this.expect(3);
    	    node.parameters = [id];
    	    const type = this.tsTryParseTypeAnnotation();
    	    if (type) node.typeAnnotation = type;
    	    this.tsParseTypeMemberSemicolon();
    	    return this.finishNode(node, "TSIndexSignature");
    	  }
    	  tsParsePropertyOrMethodSignature(node, readonly) {
    	    if (this.eat(17)) node.optional = true;
    	    const nodeAny = node;
    	    if (this.match(10) || this.match(47)) {
    	      if (readonly) {
    	        this.raise(TSErrors.ReadonlyForMethodSignature, {
    	          at: node
    	        });
    	      }
    	      const method = nodeAny;
    	      if (method.kind && this.match(47)) {
    	        this.raise(TSErrors.AccesorCannotHaveTypeParameters, {
    	          at: this.state.curPosition()
    	        });
    	      }
    	      this.tsFillSignature(14, method);
    	      this.tsParseTypeMemberSemicolon();
    	      const paramsKey = "parameters";
    	      const returnTypeKey = "typeAnnotation";
    	      if (method.kind === "get") {
    	        if (method[paramsKey].length > 0) {
    	          this.raise(Errors.BadGetterArity, {
    	            at: this.state.curPosition()
    	          });
    	          if (this.isThisParam(method[paramsKey][0])) {
    	            this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
    	              at: this.state.curPosition()
    	            });
    	          }
    	        }
    	      } else if (method.kind === "set") {
    	        if (method[paramsKey].length !== 1) {
    	          this.raise(Errors.BadSetterArity, {
    	            at: this.state.curPosition()
    	          });
    	        } else {
    	          const firstParameter = method[paramsKey][0];
    	          if (this.isThisParam(firstParameter)) {
    	            this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
    	              at: this.state.curPosition()
    	            });
    	          }
    	          if (firstParameter.type === "Identifier" && firstParameter.optional) {
    	            this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {
    	              at: this.state.curPosition()
    	            });
    	          }
    	          if (firstParameter.type === "RestElement") {
    	            this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {
    	              at: this.state.curPosition()
    	            });
    	          }
    	        }
    	        if (method[returnTypeKey]) {
    	          this.raise(TSErrors.SetAccesorCannotHaveReturnType, {
    	            at: method[returnTypeKey]
    	          });
    	        }
    	      } else {
    	        method.kind = "method";
    	      }
    	      return this.finishNode(method, "TSMethodSignature");
    	    } else {
    	      const property = nodeAny;
    	      if (readonly) property.readonly = true;
    	      const type = this.tsTryParseTypeAnnotation();
    	      if (type) property.typeAnnotation = type;
    	      this.tsParseTypeMemberSemicolon();
    	      return this.finishNode(property, "TSPropertySignature");
    	    }
    	  }
    	  tsParseTypeMember() {
    	    const node = this.startNode();
    	    if (this.match(10) || this.match(47)) {
    	      return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
    	    }
    	    if (this.match(77)) {
    	      const id = this.startNode();
    	      this.next();
    	      if (this.match(10) || this.match(47)) {
    	        return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
    	      } else {
    	        node.key = this.createIdentifier(id, "new");
    	        return this.tsParsePropertyOrMethodSignature(node, false);
    	      }
    	    }
    	    this.tsParseModifiers({
    	      allowedModifiers: ["readonly"],
    	      disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
    	    }, node);
    	    const idx = this.tsTryParseIndexSignature(node);
    	    if (idx) {
    	      return idx;
    	    }
    	    super.parsePropertyName(node);
    	    if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
    	      node.kind = node.key.name;
    	      super.parsePropertyName(node);
    	    }
    	    return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
    	  }
    	  tsParseTypeLiteral() {
    	    const node = this.startNode();
    	    node.members = this.tsParseObjectTypeMembers();
    	    return this.finishNode(node, "TSTypeLiteral");
    	  }
    	  tsParseObjectTypeMembers() {
    	    this.expect(5);
    	    const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
    	    this.expect(8);
    	    return members;
    	  }
    	  tsIsStartOfMappedType() {
    	    this.next();
    	    if (this.eat(53)) {
    	      return this.isContextual(122);
    	    }
    	    if (this.isContextual(122)) {
    	      this.next();
    	    }
    	    if (!this.match(0)) {
    	      return false;
    	    }
    	    this.next();
    	    if (!this.tsIsIdentifier()) {
    	      return false;
    	    }
    	    this.next();
    	    return this.match(58);
    	  }
    	  tsParseMappedTypeParameter() {
    	    const node = this.startNode();
    	    node.name = this.tsParseTypeParameterName();
    	    node.constraint = this.tsExpectThenParseType(58);
    	    return this.finishNode(node, "TSTypeParameter");
    	  }
    	  tsParseMappedType() {
    	    const node = this.startNode();
    	    this.expect(5);
    	    if (this.match(53)) {
    	      node.readonly = this.state.value;
    	      this.next();
    	      this.expectContextual(122);
    	    } else if (this.eatContextual(122)) {
    	      node.readonly = true;
    	    }
    	    this.expect(0);
    	    node.typeParameter = this.tsParseMappedTypeParameter();
    	    node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
    	    this.expect(3);
    	    if (this.match(53)) {
    	      node.optional = this.state.value;
    	      this.next();
    	      this.expect(17);
    	    } else if (this.eat(17)) {
    	      node.optional = true;
    	    }
    	    node.typeAnnotation = this.tsTryParseType();
    	    this.semicolon();
    	    this.expect(8);
    	    return this.finishNode(node, "TSMappedType");
    	  }
    	  tsParseTupleType() {
    	    const node = this.startNode();
    	    node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
    	    let seenOptionalElement = false;
    	    node.elementTypes.forEach(elementNode => {
    	      const {
    	        type
    	      } = elementNode;
    	      if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
    	        this.raise(TSErrors.OptionalTypeBeforeRequired, {
    	          at: elementNode
    	        });
    	      }
    	      seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
    	    });
    	    return this.finishNode(node, "TSTupleType");
    	  }
    	  tsParseTupleElementType() {
    	    const {
    	      startLoc
    	    } = this.state;
    	    const rest = this.eat(21);
    	    let labeled;
    	    let label;
    	    let optional;
    	    let type;
    	    const isWord = tokenIsKeywordOrIdentifier(this.state.type);
    	    const chAfterWord = isWord ? this.lookaheadCharCode() : null;
    	    if (chAfterWord === 58) {
    	      labeled = true;
    	      optional = false;
    	      label = this.parseIdentifier(true);
    	      this.expect(14);
    	      type = this.tsParseType();
    	    } else if (chAfterWord === 63) {
    	      optional = true;
    	      const startLoc = this.state.startLoc;
    	      const wordName = this.state.value;
    	      const typeOrLabel = this.tsParseNonArrayType();
    	      if (this.lookaheadCharCode() === 58) {
    	        labeled = true;
    	        label = this.createIdentifier(this.startNodeAt(startLoc), wordName);
    	        this.expect(17);
    	        this.expect(14);
    	        type = this.tsParseType();
    	      } else {
    	        labeled = false;
    	        type = typeOrLabel;
    	        this.expect(17);
    	      }
    	    } else {
    	      type = this.tsParseType();
    	      optional = this.eat(17);
    	      labeled = this.eat(14);
    	    }
    	    if (labeled) {
    	      let labeledNode;
    	      if (label) {
    	        labeledNode = this.startNodeAtNode(label);
    	        labeledNode.optional = optional;
    	        labeledNode.label = label;
    	        labeledNode.elementType = type;
    	        if (this.eat(17)) {
    	          labeledNode.optional = true;
    	          this.raise(TSErrors.TupleOptionalAfterType, {
    	            at: this.state.lastTokStartLoc
    	          });
    	        }
    	      } else {
    	        labeledNode = this.startNodeAtNode(type);
    	        labeledNode.optional = optional;
    	        this.raise(TSErrors.InvalidTupleMemberLabel, {
    	          at: type
    	        });
    	        labeledNode.label = type;
    	        labeledNode.elementType = this.tsParseType();
    	      }
    	      type = this.finishNode(labeledNode, "TSNamedTupleMember");
    	    } else if (optional) {
    	      const optionalTypeNode = this.startNodeAtNode(type);
    	      optionalTypeNode.typeAnnotation = type;
    	      type = this.finishNode(optionalTypeNode, "TSOptionalType");
    	    }
    	    if (rest) {
    	      const restNode = this.startNodeAt(startLoc);
    	      restNode.typeAnnotation = type;
    	      type = this.finishNode(restNode, "TSRestType");
    	    }
    	    return type;
    	  }
    	  tsParseParenthesizedType() {
    	    const node = this.startNode();
    	    this.expect(10);
    	    node.typeAnnotation = this.tsParseType();
    	    this.expect(11);
    	    return this.finishNode(node, "TSParenthesizedType");
    	  }
    	  tsParseFunctionOrConstructorType(type, abstract) {
    	    const node = this.startNode();
    	    if (type === "TSConstructorType") {
    	      node.abstract = !!abstract;
    	      if (abstract) this.next();
    	      this.next();
    	    }
    	    this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));
    	    return this.finishNode(node, type);
    	  }
    	  tsParseLiteralTypeNode() {
    	    const node = this.startNode();
    	    switch (this.state.type) {
    	      case 134:
    	      case 135:
    	      case 133:
    	      case 85:
    	      case 86:
    	        node.literal = super.parseExprAtom();
    	        break;
    	      default:
    	        this.unexpected();
    	    }
    	    return this.finishNode(node, "TSLiteralType");
    	  }
    	  tsParseTemplateLiteralType() {
    	    const node = this.startNode();
    	    node.literal = super.parseTemplate(false);
    	    return this.finishNode(node, "TSLiteralType");
    	  }
    	  parseTemplateSubstitution() {
    	    if (this.state.inType) return this.tsParseType();
    	    return super.parseTemplateSubstitution();
    	  }
    	  tsParseThisTypeOrThisTypePredicate() {
    	    const thisKeyword = this.tsParseThisTypeNode();
    	    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
    	      return this.tsParseThisTypePredicate(thisKeyword);
    	    } else {
    	      return thisKeyword;
    	    }
    	  }
    	  tsParseNonArrayType() {
    	    switch (this.state.type) {
    	      case 133:
    	      case 134:
    	      case 135:
    	      case 85:
    	      case 86:
    	        return this.tsParseLiteralTypeNode();
    	      case 53:
    	        if (this.state.value === "-") {
    	          const node = this.startNode();
    	          const nextToken = this.lookahead();
    	          if (nextToken.type !== 134 && nextToken.type !== 135) {
    	            this.unexpected();
    	          }
    	          node.literal = this.parseMaybeUnary();
    	          return this.finishNode(node, "TSLiteralType");
    	        }
    	        break;
    	      case 78:
    	        return this.tsParseThisTypeOrThisTypePredicate();
    	      case 87:
    	        return this.tsParseTypeQuery();
    	      case 83:
    	        return this.tsParseImportType();
    	      case 5:
    	        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
    	      case 0:
    	        return this.tsParseTupleType();
    	      case 10:
    	        return this.tsParseParenthesizedType();
    	      case 25:
    	      case 24:
    	        return this.tsParseTemplateLiteralType();
    	      default:
    	        {
    	          const {
    	            type
    	          } = this.state;
    	          if (tokenIsIdentifier(type) || type === 88 || type === 84) {
    	            const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
    	            if (nodeType !== undefined && this.lookaheadCharCode() !== 46) {
    	              const node = this.startNode();
    	              this.next();
    	              return this.finishNode(node, nodeType);
    	            }
    	            return this.tsParseTypeReference();
    	          }
    	        }
    	    }
    	    this.unexpected();
    	  }
    	  tsParseArrayTypeOrHigher() {
    	    let type = this.tsParseNonArrayType();
    	    while (!this.hasPrecedingLineBreak() && this.eat(0)) {
    	      if (this.match(3)) {
    	        const node = this.startNodeAtNode(type);
    	        node.elementType = type;
    	        this.expect(3);
    	        type = this.finishNode(node, "TSArrayType");
    	      } else {
    	        const node = this.startNodeAtNode(type);
    	        node.objectType = type;
    	        node.indexType = this.tsParseType();
    	        this.expect(3);
    	        type = this.finishNode(node, "TSIndexedAccessType");
    	      }
    	    }
    	    return type;
    	  }
    	  tsParseTypeOperator() {
    	    const node = this.startNode();
    	    const operator = this.state.value;
    	    this.next();
    	    node.operator = operator;
    	    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
    	    if (operator === "readonly") {
    	      this.tsCheckTypeAnnotationForReadOnly(node);
    	    }
    	    return this.finishNode(node, "TSTypeOperator");
    	  }
    	  tsCheckTypeAnnotationForReadOnly(node) {
    	    switch (node.typeAnnotation.type) {
    	      case "TSTupleType":
    	      case "TSArrayType":
    	        return;
    	      default:
    	        this.raise(TSErrors.UnexpectedReadonly, {
    	          at: node
    	        });
    	    }
    	  }
    	  tsParseInferType() {
    	    const node = this.startNode();
    	    this.expectContextual(115);
    	    const typeParameter = this.startNode();
    	    typeParameter.name = this.tsParseTypeParameterName();
    	    typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
    	    node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
    	    return this.finishNode(node, "TSInferType");
    	  }
    	  tsParseConstraintForInferType() {
    	    if (this.eat(81)) {
    	      const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
    	      if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
    	        return constraint;
    	      }
    	    }
    	  }
    	  tsParseTypeOperatorOrHigher() {
    	    const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
    	    return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    	  }
    	  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
    	    const node = this.startNode();
    	    const hasLeadingOperator = this.eat(operator);
    	    const types = [];
    	    do {
    	      types.push(parseConstituentType());
    	    } while (this.eat(operator));
    	    if (types.length === 1 && !hasLeadingOperator) {
    	      return types[0];
    	    }
    	    node.types = types;
    	    return this.finishNode(node, kind);
    	  }
    	  tsParseIntersectionTypeOrHigher() {
    	    return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    	  }
    	  tsParseUnionTypeOrHigher() {
    	    return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    	  }
    	  tsIsStartOfFunctionType() {
    	    if (this.match(47)) {
    	      return true;
    	    }
    	    return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    	  }
    	  tsSkipParameterStart() {
    	    if (tokenIsIdentifier(this.state.type) || this.match(78)) {
    	      this.next();
    	      return true;
    	    }
    	    if (this.match(5)) {
    	      const {
    	        errors
    	      } = this.state;
    	      const previousErrorCount = errors.length;
    	      try {
    	        this.parseObjectLike(8, true);
    	        return errors.length === previousErrorCount;
    	      } catch (_unused) {
    	        return false;
    	      }
    	    }
    	    if (this.match(0)) {
    	      this.next();
    	      const {
    	        errors
    	      } = this.state;
    	      const previousErrorCount = errors.length;
    	      try {
    	        super.parseBindingList(3, 93, 1);
    	        return errors.length === previousErrorCount;
    	      } catch (_unused2) {
    	        return false;
    	      }
    	    }
    	    return false;
    	  }
    	  tsIsUnambiguouslyStartOfFunctionType() {
    	    this.next();
    	    if (this.match(11) || this.match(21)) {
    	      return true;
    	    }
    	    if (this.tsSkipParameterStart()) {
    	      if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
    	        return true;
    	      }
    	      if (this.match(11)) {
    	        this.next();
    	        if (this.match(19)) {
    	          return true;
    	        }
    	      }
    	    }
    	    return false;
    	  }
    	  tsParseTypeOrTypePredicateAnnotation(returnToken) {
    	    return this.tsInType(() => {
    	      const t = this.startNode();
    	      this.expect(returnToken);
    	      const node = this.startNode();
    	      const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
    	      if (asserts && this.match(78)) {
    	        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
    	        if (thisTypePredicate.type === "TSThisType") {
    	          node.parameterName = thisTypePredicate;
    	          node.asserts = true;
    	          node.typeAnnotation = null;
    	          thisTypePredicate = this.finishNode(node, "TSTypePredicate");
    	        } else {
    	          this.resetStartLocationFromNode(thisTypePredicate, node);
    	          thisTypePredicate.asserts = true;
    	        }
    	        t.typeAnnotation = thisTypePredicate;
    	        return this.finishNode(t, "TSTypeAnnotation");
    	      }
    	      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
    	      if (!typePredicateVariable) {
    	        if (!asserts) {
    	          return this.tsParseTypeAnnotation(false, t);
    	        }
    	        node.parameterName = this.parseIdentifier();
    	        node.asserts = asserts;
    	        node.typeAnnotation = null;
    	        t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
    	        return this.finishNode(t, "TSTypeAnnotation");
    	      }
    	      const type = this.tsParseTypeAnnotation(false);
    	      node.parameterName = typePredicateVariable;
    	      node.typeAnnotation = type;
    	      node.asserts = asserts;
    	      t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
    	      return this.finishNode(t, "TSTypeAnnotation");
    	    });
    	  }
    	  tsTryParseTypeOrTypePredicateAnnotation() {
    	    if (this.match(14)) {
    	      return this.tsParseTypeOrTypePredicateAnnotation(14);
    	    }
    	  }
    	  tsTryParseTypeAnnotation() {
    	    if (this.match(14)) {
    	      return this.tsParseTypeAnnotation();
    	    }
    	  }
    	  tsTryParseType() {
    	    return this.tsEatThenParseType(14);
    	  }
    	  tsParseTypePredicatePrefix() {
    	    const id = this.parseIdentifier();
    	    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
    	      this.next();
    	      return id;
    	    }
    	  }
    	  tsParseTypePredicateAsserts() {
    	    if (this.state.type !== 109) {
    	      return false;
    	    }
    	    const containsEsc = this.state.containsEsc;
    	    this.next();
    	    if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
    	      return false;
    	    }
    	    if (containsEsc) {
    	      this.raise(Errors.InvalidEscapedReservedWord, {
    	        at: this.state.lastTokStartLoc,
    	        reservedWord: "asserts"
    	      });
    	    }
    	    return true;
    	  }
    	  tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
    	    this.tsInType(() => {
    	      if (eatColon) this.expect(14);
    	      t.typeAnnotation = this.tsParseType();
    	    });
    	    return this.finishNode(t, "TSTypeAnnotation");
    	  }
    	  tsParseType() {
    	    assert(this.state.inType);
    	    const type = this.tsParseNonConditionalType();
    	    if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
    	      return type;
    	    }
    	    const node = this.startNodeAtNode(type);
    	    node.checkType = type;
    	    node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
    	    this.expect(17);
    	    node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
    	    this.expect(14);
    	    node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
    	    return this.finishNode(node, "TSConditionalType");
    	  }
    	  isAbstractConstructorSignature() {
    	    return this.isContextual(124) && this.lookahead().type === 77;
    	  }
    	  tsParseNonConditionalType() {
    	    if (this.tsIsStartOfFunctionType()) {
    	      return this.tsParseFunctionOrConstructorType("TSFunctionType");
    	    }
    	    if (this.match(77)) {
    	      return this.tsParseFunctionOrConstructorType("TSConstructorType");
    	    } else if (this.isAbstractConstructorSignature()) {
    	      return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
    	    }
    	    return this.tsParseUnionTypeOrHigher();
    	  }
    	  tsParseTypeAssertion() {
    	    if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
    	      this.raise(TSErrors.ReservedTypeAssertion, {
    	        at: this.state.startLoc
    	      });
    	    }
    	    const node = this.startNode();
    	    node.typeAnnotation = this.tsInType(() => {
    	      this.next();
    	      return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();
    	    });
    	    this.expect(48);
    	    node.expression = this.parseMaybeUnary();
    	    return this.finishNode(node, "TSTypeAssertion");
    	  }
    	  tsParseHeritageClause(token) {
    	    const originalStartLoc = this.state.startLoc;
    	    const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
    	      const node = this.startNode();
    	      node.expression = this.tsParseEntityName();
    	      if (this.match(47)) {
    	        node.typeParameters = this.tsParseTypeArguments();
    	      }
    	      return this.finishNode(node, "TSExpressionWithTypeArguments");
    	    });
    	    if (!delimitedList.length) {
    	      this.raise(TSErrors.EmptyHeritageClauseType, {
    	        at: originalStartLoc,
    	        token
    	      });
    	    }
    	    return delimitedList;
    	  }
    	  tsParseInterfaceDeclaration(node, properties = {}) {
    	    if (this.hasFollowingLineBreak()) return null;
    	    this.expectContextual(129);
    	    if (properties.declare) node.declare = true;
    	    if (tokenIsIdentifier(this.state.type)) {
    	      node.id = this.parseIdentifier();
    	      this.checkIdentifier(node.id, 130);
    	    } else {
    	      node.id = null;
    	      this.raise(TSErrors.MissingInterfaceName, {
    	        at: this.state.startLoc
    	      });
    	    }
    	    node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
    	    if (this.eat(81)) {
    	      node.extends = this.tsParseHeritageClause("extends");
    	    }
    	    const body = this.startNode();
    	    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
    	    node.body = this.finishNode(body, "TSInterfaceBody");
    	    return this.finishNode(node, "TSInterfaceDeclaration");
    	  }
    	  tsParseTypeAliasDeclaration(node) {
    	    node.id = this.parseIdentifier();
    	    this.checkIdentifier(node.id, 2);
    	    node.typeAnnotation = this.tsInType(() => {
    	      node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);
    	      this.expect(29);
    	      if (this.isContextual(114) && this.lookahead().type !== 16) {
    	        const node = this.startNode();
    	        this.next();
    	        return this.finishNode(node, "TSIntrinsicKeyword");
    	      }
    	      return this.tsParseType();
    	    });
    	    this.semicolon();
    	    return this.finishNode(node, "TSTypeAliasDeclaration");
    	  }
    	  tsInNoContext(cb) {
    	    const oldContext = this.state.context;
    	    this.state.context = [oldContext[0]];
    	    try {
    	      return cb();
    	    } finally {
    	      this.state.context = oldContext;
    	    }
    	  }
    	  tsInType(cb) {
    	    const oldInType = this.state.inType;
    	    this.state.inType = true;
    	    try {
    	      return cb();
    	    } finally {
    	      this.state.inType = oldInType;
    	    }
    	  }
    	  tsInDisallowConditionalTypesContext(cb) {
    	    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
    	    this.state.inDisallowConditionalTypesContext = true;
    	    try {
    	      return cb();
    	    } finally {
    	      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
    	    }
    	  }
    	  tsInAllowConditionalTypesContext(cb) {
    	    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
    	    this.state.inDisallowConditionalTypesContext = false;
    	    try {
    	      return cb();
    	    } finally {
    	      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
    	    }
    	  }
    	  tsEatThenParseType(token) {
    	    if (this.match(token)) {
    	      return this.tsNextThenParseType();
    	    }
    	  }
    	  tsExpectThenParseType(token) {
    	    return this.tsInType(() => {
    	      this.expect(token);
    	      return this.tsParseType();
    	    });
    	  }
    	  tsNextThenParseType() {
    	    return this.tsInType(() => {
    	      this.next();
    	      return this.tsParseType();
    	    });
    	  }
    	  tsParseEnumMember() {
    	    const node = this.startNode();
    	    node.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
    	    if (this.eat(29)) {
    	      node.initializer = super.parseMaybeAssignAllowIn();
    	    }
    	    return this.finishNode(node, "TSEnumMember");
    	  }
    	  tsParseEnumDeclaration(node, properties = {}) {
    	    if (properties.const) node.const = true;
    	    if (properties.declare) node.declare = true;
    	    this.expectContextual(126);
    	    node.id = this.parseIdentifier();
    	    this.checkIdentifier(node.id, node.const ? 8971 : 8459);
    	    this.expect(5);
    	    node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
    	    this.expect(8);
    	    return this.finishNode(node, "TSEnumDeclaration");
    	  }
    	  tsParseModuleBlock() {
    	    const node = this.startNode();
    	    this.scope.enter(0);
    	    this.expect(5);
    	    super.parseBlockOrModuleBlockBody(node.body = [], undefined, true, 8);
    	    this.scope.exit();
    	    return this.finishNode(node, "TSModuleBlock");
    	  }
    	  tsParseModuleOrNamespaceDeclaration(node, nested = false) {
    	    node.id = this.parseIdentifier();
    	    if (!nested) {
    	      this.checkIdentifier(node.id, 1024);
    	    }
    	    if (this.eat(16)) {
    	      const inner = this.startNode();
    	      this.tsParseModuleOrNamespaceDeclaration(inner, true);
    	      node.body = inner;
    	    } else {
    	      this.scope.enter(256);
    	      this.prodParam.enter(PARAM);
    	      node.body = this.tsParseModuleBlock();
    	      this.prodParam.exit();
    	      this.scope.exit();
    	    }
    	    return this.finishNode(node, "TSModuleDeclaration");
    	  }
    	  tsParseAmbientExternalModuleDeclaration(node) {
    	    if (this.isContextual(112)) {
    	      node.global = true;
    	      node.id = this.parseIdentifier();
    	    } else if (this.match(133)) {
    	      node.id = super.parseStringLiteral(this.state.value);
    	    } else {
    	      this.unexpected();
    	    }
    	    if (this.match(5)) {
    	      this.scope.enter(256);
    	      this.prodParam.enter(PARAM);
    	      node.body = this.tsParseModuleBlock();
    	      this.prodParam.exit();
    	      this.scope.exit();
    	    } else {
    	      this.semicolon();
    	    }
    	    return this.finishNode(node, "TSModuleDeclaration");
    	  }
    	  tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {
    	    node.isExport = isExport || false;
    	    node.id = maybeDefaultIdentifier || this.parseIdentifier();
    	    this.checkIdentifier(node.id, 4096);
    	    this.expect(29);
    	    const moduleReference = this.tsParseModuleReference();
    	    if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
    	      this.raise(TSErrors.ImportAliasHasImportType, {
    	        at: moduleReference
    	      });
    	    }
    	    node.moduleReference = moduleReference;
    	    this.semicolon();
    	    return this.finishNode(node, "TSImportEqualsDeclaration");
    	  }
    	  tsIsExternalModuleReference() {
    	    return this.isContextual(119) && this.lookaheadCharCode() === 40;
    	  }
    	  tsParseModuleReference() {
    	    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
    	  }
    	  tsParseExternalModuleReference() {
    	    const node = this.startNode();
    	    this.expectContextual(119);
    	    this.expect(10);
    	    if (!this.match(133)) {
    	      this.unexpected();
    	    }
    	    node.expression = super.parseExprAtom();
    	    this.expect(11);
    	    this.sawUnambiguousESM = true;
    	    return this.finishNode(node, "TSExternalModuleReference");
    	  }
    	  tsLookAhead(f) {
    	    const state = this.state.clone();
    	    const res = f();
    	    this.state = state;
    	    return res;
    	  }
    	  tsTryParseAndCatch(f) {
    	    const result = this.tryParse(abort => f() || abort());
    	    if (result.aborted || !result.node) return;
    	    if (result.error) this.state = result.failState;
    	    return result.node;
    	  }
    	  tsTryParse(f) {
    	    const state = this.state.clone();
    	    const result = f();
    	    if (result !== undefined && result !== false) {
    	      return result;
    	    }
    	    this.state = state;
    	  }
    	  tsTryParseDeclare(nany) {
    	    if (this.isLineTerminator()) {
    	      return;
    	    }
    	    let startType = this.state.type;
    	    let kind;
    	    if (this.isContextual(100)) {
    	      startType = 74;
    	      kind = "let";
    	    }
    	    return this.tsInAmbientContext(() => {
    	      switch (startType) {
    	        case 68:
    	          nany.declare = true;
    	          return super.parseFunctionStatement(nany, false, false);
    	        case 80:
    	          nany.declare = true;
    	          return this.parseClass(nany, true, false);
    	        case 126:
    	          return this.tsParseEnumDeclaration(nany, {
    	            declare: true
    	          });
    	        case 112:
    	          return this.tsParseAmbientExternalModuleDeclaration(nany);
    	        case 75:
    	        case 74:
    	          if (!this.match(75) || !this.isLookaheadContextual("enum")) {
    	            nany.declare = true;
    	            return this.parseVarStatement(nany, kind || this.state.value, true);
    	          }
    	          this.expect(75);
    	          return this.tsParseEnumDeclaration(nany, {
    	            const: true,
    	            declare: true
    	          });
    	        case 129:
    	          {
    	            const result = this.tsParseInterfaceDeclaration(nany, {
    	              declare: true
    	            });
    	            if (result) return result;
    	          }
    	        default:
    	          if (tokenIsIdentifier(startType)) {
    	            return this.tsParseDeclaration(nany, this.state.value, true, null);
    	          }
    	      }
    	    });
    	  }
    	  tsTryParseExportDeclaration() {
    	    return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
    	  }
    	  tsParseExpressionStatement(node, expr, decorators) {
    	    switch (expr.name) {
    	      case "declare":
    	        {
    	          const declaration = this.tsTryParseDeclare(node);
    	          if (declaration) {
    	            declaration.declare = true;
    	          }
    	          return declaration;
    	        }
    	      case "global":
    	        if (this.match(5)) {
    	          this.scope.enter(256);
    	          this.prodParam.enter(PARAM);
    	          const mod = node;
    	          mod.global = true;
    	          mod.id = expr;
    	          mod.body = this.tsParseModuleBlock();
    	          this.scope.exit();
    	          this.prodParam.exit();
    	          return this.finishNode(mod, "TSModuleDeclaration");
    	        }
    	        break;
    	      default:
    	        return this.tsParseDeclaration(node, expr.name, false, decorators);
    	    }
    	  }
    	  tsParseDeclaration(node, value, next, decorators) {
    	    switch (value) {
    	      case "abstract":
    	        if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
    	          return this.tsParseAbstractDeclaration(node, decorators);
    	        }
    	        break;
    	      case "module":
    	        if (this.tsCheckLineTerminator(next)) {
    	          if (this.match(133)) {
    	            return this.tsParseAmbientExternalModuleDeclaration(node);
    	          } else if (tokenIsIdentifier(this.state.type)) {
    	            return this.tsParseModuleOrNamespaceDeclaration(node);
    	          }
    	        }
    	        break;
    	      case "namespace":
    	        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
    	          return this.tsParseModuleOrNamespaceDeclaration(node);
    	        }
    	        break;
    	      case "type":
    	        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
    	          return this.tsParseTypeAliasDeclaration(node);
    	        }
    	        break;
    	    }
    	  }
    	  tsCheckLineTerminator(next) {
    	    if (next) {
    	      if (this.hasFollowingLineBreak()) return false;
    	      this.next();
    	      return true;
    	    }
    	    return !this.isLineTerminator();
    	  }
    	  tsTryParseGenericAsyncArrowFunction(startLoc) {
    	    if (!this.match(47)) return;
    	    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
    	    this.state.maybeInArrowParameters = true;
    	    const res = this.tsTryParseAndCatch(() => {
    	      const node = this.startNodeAt(startLoc);
    	      node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
    	      super.parseFunctionParams(node);
    	      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
    	      this.expect(19);
    	      return node;
    	    });
    	    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
    	    if (!res) return;
    	    return super.parseArrowExpression(res, null, true);
    	  }
    	  tsParseTypeArgumentsInExpression() {
    	    if (this.reScan_lt() !== 47) return;
    	    return this.tsParseTypeArguments();
    	  }
    	  tsParseTypeArguments() {
    	    const node = this.startNode();
    	    node.params = this.tsInType(() => this.tsInNoContext(() => {
    	      this.expect(47);
    	      return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
    	    }));
    	    if (node.params.length === 0) {
    	      this.raise(TSErrors.EmptyTypeArguments, {
    	        at: node
    	      });
    	    } else if (!this.state.inType && this.curContext() === types.brace) {
    	      this.reScan_lt_gt();
    	    }
    	    this.expect(48);
    	    return this.finishNode(node, "TSTypeParameterInstantiation");
    	  }
    	  tsIsDeclarationStart() {
    	    return tokenIsTSDeclarationStart(this.state.type);
    	  }
    	  isExportDefaultSpecifier() {
    	    if (this.tsIsDeclarationStart()) return false;
    	    return super.isExportDefaultSpecifier();
    	  }
    	  parseAssignableListItem(flags, decorators) {
    	    const startLoc = this.state.startLoc;
    	    const modified = {};
    	    this.tsParseModifiers({
    	      allowedModifiers: ["public", "private", "protected", "override", "readonly"]
    	    }, modified);
    	    const accessibility = modified.accessibility;
    	    const override = modified.override;
    	    const readonly = modified.readonly;
    	    if (!(flags & 4) && (accessibility || readonly || override)) {
    	      this.raise(TSErrors.UnexpectedParameterModifier, {
    	        at: startLoc
    	      });
    	    }
    	    const left = this.parseMaybeDefault();
    	    this.parseAssignableListItemTypes(left, flags);
    	    const elt = this.parseMaybeDefault(left.loc.start, left);
    	    if (accessibility || readonly || override) {
    	      const pp = this.startNodeAt(startLoc);
    	      if (decorators.length) {
    	        pp.decorators = decorators;
    	      }
    	      if (accessibility) pp.accessibility = accessibility;
    	      if (readonly) pp.readonly = readonly;
    	      if (override) pp.override = override;
    	      if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
    	        this.raise(TSErrors.UnsupportedParameterPropertyKind, {
    	          at: pp
    	        });
    	      }
    	      pp.parameter = elt;
    	      return this.finishNode(pp, "TSParameterProperty");
    	    }
    	    if (decorators.length) {
    	      left.decorators = decorators;
    	    }
    	    return elt;
    	  }
    	  isSimpleParameter(node) {
    	    return node.type === "TSParameterProperty" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
    	  }
    	  tsDisallowOptionalPattern(node) {
    	    for (const param of node.params) {
    	      if (param.type !== "Identifier" && param.optional && !this.state.isAmbientContext) {
    	        this.raise(TSErrors.PatternIsOptional, {
    	          at: param
    	        });
    	      }
    	    }
    	  }
    	  setArrowFunctionParameters(node, params, trailingCommaLoc) {
    	    super.setArrowFunctionParameters(node, params, trailingCommaLoc);
    	    this.tsDisallowOptionalPattern(node);
    	  }
    	  parseFunctionBodyAndFinish(node, type, isMethod = false) {
    	    if (this.match(14)) {
    	      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
    	    }
    	    const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : undefined;
    	    if (bodilessType && !this.match(5) && this.isLineTerminator()) {
    	      return this.finishNode(node, bodilessType);
    	    }
    	    if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
    	      this.raise(TSErrors.DeclareFunctionHasImplementation, {
    	        at: node
    	      });
    	      if (node.declare) {
    	        return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
    	      }
    	    }
    	    this.tsDisallowOptionalPattern(node);
    	    return super.parseFunctionBodyAndFinish(node, type, isMethod);
    	  }
    	  registerFunctionStatementId(node) {
    	    if (!node.body && node.id) {
    	      this.checkIdentifier(node.id, 1024);
    	    } else {
    	      super.registerFunctionStatementId(node);
    	    }
    	  }
    	  tsCheckForInvalidTypeCasts(items) {
    	    items.forEach(node => {
    	      if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
    	        this.raise(TSErrors.UnexpectedTypeAnnotation, {
    	          at: node.typeAnnotation
    	        });
    	      }
    	    });
    	  }
    	  toReferencedList(exprList, isInParens) {
    	    this.tsCheckForInvalidTypeCasts(exprList);
    	    return exprList;
    	  }
    	  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
    	    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
    	    if (node.type === "ArrayExpression") {
    	      this.tsCheckForInvalidTypeCasts(node.elements);
    	    }
    	    return node;
    	  }
    	  parseSubscript(base, startLoc, noCalls, state) {
    	    if (!this.hasPrecedingLineBreak() && this.match(35)) {
    	      this.state.canStartJSXElement = false;
    	      this.next();
    	      const nonNullExpression = this.startNodeAt(startLoc);
    	      nonNullExpression.expression = base;
    	      return this.finishNode(nonNullExpression, "TSNonNullExpression");
    	    }
    	    let isOptionalCall = false;
    	    if (this.match(18) && this.lookaheadCharCode() === 60) {
    	      if (noCalls) {
    	        state.stop = true;
    	        return base;
    	      }
    	      state.optionalChainMember = isOptionalCall = true;
    	      this.next();
    	    }
    	    if (this.match(47) || this.match(51)) {
    	      let missingParenErrorLoc;
    	      const result = this.tsTryParseAndCatch(() => {
    	        if (!noCalls && this.atPossibleAsyncArrow(base)) {
    	          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
    	          if (asyncArrowFn) {
    	            return asyncArrowFn;
    	          }
    	        }
    	        const typeArguments = this.tsParseTypeArgumentsInExpression();
    	        if (!typeArguments) return;
    	        if (isOptionalCall && !this.match(10)) {
    	          missingParenErrorLoc = this.state.curPosition();
    	          return;
    	        }
    	        if (tokenIsTemplate(this.state.type)) {
    	          const result = super.parseTaggedTemplateExpression(base, startLoc, state);
    	          result.typeParameters = typeArguments;
    	          return result;
    	        }
    	        if (!noCalls && this.eat(10)) {
    	          const node = this.startNodeAt(startLoc);
    	          node.callee = base;
    	          node.arguments = this.parseCallExpressionArguments(11, false);
    	          this.tsCheckForInvalidTypeCasts(node.arguments);
    	          node.typeParameters = typeArguments;
    	          if (state.optionalChainMember) {
    	            node.optional = isOptionalCall;
    	          }
    	          return this.finishCallExpression(node, state.optionalChainMember);
    	        }
    	        const tokenType = this.state.type;
    	        if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {
    	          return;
    	        }
    	        const node = this.startNodeAt(startLoc);
    	        node.expression = base;
    	        node.typeParameters = typeArguments;
    	        return this.finishNode(node, "TSInstantiationExpression");
    	      });
    	      if (missingParenErrorLoc) {
    	        this.unexpected(missingParenErrorLoc, 10);
    	      }
    	      if (result) {
    	        if (result.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {
    	          this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, {
    	            at: this.state.startLoc
    	          });
    	        }
    	        return result;
    	      }
    	    }
    	    return super.parseSubscript(base, startLoc, noCalls, state);
    	  }
    	  parseNewCallee(node) {
    	    var _callee$extra;
    	    super.parseNewCallee(node);
    	    const {
    	      callee
    	    } = node;
    	    if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
    	      node.typeParameters = callee.typeParameters;
    	      node.callee = callee.expression;
    	    }
    	  }
    	  parseExprOp(left, leftStartLoc, minPrec) {
    	    let isSatisfies;
    	    if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {
    	      const node = this.startNodeAt(leftStartLoc);
    	      node.expression = left;
    	      node.typeAnnotation = this.tsInType(() => {
    	        this.next();
    	        if (this.match(75)) {
    	          if (isSatisfies) {
    	            this.raise(Errors.UnexpectedKeyword, {
    	              at: this.state.startLoc,
    	              keyword: "const"
    	            });
    	          }
    	          return this.tsParseTypeReference();
    	        }
    	        return this.tsParseType();
    	      });
    	      this.finishNode(node, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");
    	      this.reScan_lt_gt();
    	      return this.parseExprOp(node, leftStartLoc, minPrec);
    	    }
    	    return super.parseExprOp(left, leftStartLoc, minPrec);
    	  }
    	  checkReservedWord(word, startLoc, checkKeywords, isBinding) {
    	    if (!this.state.isAmbientContext) {
    	      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
    	    }
    	  }
    	  checkImportReflection(node) {
    	    super.checkImportReflection(node);
    	    if (node.module && node.importKind !== "value") {
    	      this.raise(TSErrors.ImportReflectionHasImportType, {
    	        at: node.specifiers[0].loc.start
    	      });
    	    }
    	  }
    	  checkDuplicateExports() {}
    	  isPotentialImportPhase(isExport) {
    	    if (super.isPotentialImportPhase(isExport)) return true;
    	    if (this.isContextual(130)) {
    	      const ch = this.lookaheadCharCode();
    	      return isExport ? ch === 123 || ch === 42 : ch !== 61;
    	    }
    	    return !isExport && this.isContextual(87);
    	  }
    	  applyImportPhase(node, isExport, phase, loc) {
    	    super.applyImportPhase(node, isExport, phase, loc);
    	    if (isExport) {
    	      node.exportKind = phase === "type" ? "type" : "value";
    	    } else {
    	      node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
    	    }
    	  }
    	  parseImport(node) {
    	    if (this.match(133)) {
    	      node.importKind = "value";
    	      return super.parseImport(node);
    	    }
    	    let importNode;
    	    if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
    	      node.importKind = "value";
    	      return this.tsParseImportEqualsDeclaration(node);
    	    } else if (this.isContextual(130)) {
    	      const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
    	      if (this.lookaheadCharCode() === 61) {
    	        return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);
    	      } else {
    	        importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);
    	      }
    	    } else {
    	      importNode = super.parseImport(node);
    	    }
    	    if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
    	      this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {
    	        at: importNode
    	      });
    	    }
    	    return importNode;
    	  }
    	  parseExport(node, decorators) {
    	    if (this.match(83)) {
    	      this.next();
    	      let maybeDefaultIdentifier = null;
    	      if (this.isContextual(130) && this.isPotentialImportPhase(false)) {
    	        maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
    	      } else {
    	        node.importKind = "value";
    	      }
    	      return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, true);
    	    } else if (this.eat(29)) {
    	      const assign = node;
    	      assign.expression = super.parseExpression();
    	      this.semicolon();
    	      this.sawUnambiguousESM = true;
    	      return this.finishNode(assign, "TSExportAssignment");
    	    } else if (this.eatContextual(93)) {
    	      const decl = node;
    	      this.expectContextual(128);
    	      decl.id = this.parseIdentifier();
    	      this.semicolon();
    	      return this.finishNode(decl, "TSNamespaceExportDeclaration");
    	    } else {
    	      return super.parseExport(node, decorators);
    	    }
    	  }
    	  isAbstractClass() {
    	    return this.isContextual(124) && this.lookahead().type === 80;
    	  }
    	  parseExportDefaultExpression() {
    	    if (this.isAbstractClass()) {
    	      const cls = this.startNode();
    	      this.next();
    	      cls.abstract = true;
    	      return this.parseClass(cls, true, true);
    	    }
    	    if (this.match(129)) {
    	      const result = this.tsParseInterfaceDeclaration(this.startNode());
    	      if (result) return result;
    	    }
    	    return super.parseExportDefaultExpression();
    	  }
    	  parseVarStatement(node, kind, allowMissingInitializer = false) {
    	    const {
    	      isAmbientContext
    	    } = this.state;
    	    const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
    	    if (!isAmbientContext) return declaration;
    	    for (const {
    	      id,
    	      init
    	    } of declaration.declarations) {
    	      if (!init) continue;
    	      if (kind !== "const" || !!id.typeAnnotation) {
    	        this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {
    	          at: init
    	        });
    	      } else if (!isValidAmbientConstInitializer(init, this.hasPlugin("estree"))) {
    	        this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {
    	          at: init
    	        });
    	      }
    	    }
    	    return declaration;
    	  }
    	  parseStatementContent(flags, decorators) {
    	    if (this.match(75) && this.isLookaheadContextual("enum")) {
    	      const node = this.startNode();
    	      this.expect(75);
    	      return this.tsParseEnumDeclaration(node, {
    	        const: true
    	      });
    	    }
    	    if (this.isContextual(126)) {
    	      return this.tsParseEnumDeclaration(this.startNode());
    	    }
    	    if (this.isContextual(129)) {
    	      const result = this.tsParseInterfaceDeclaration(this.startNode());
    	      if (result) return result;
    	    }
    	    return super.parseStatementContent(flags, decorators);
    	  }
    	  parseAccessModifier() {
    	    return this.tsParseModifier(["public", "protected", "private"]);
    	  }
    	  tsHasSomeModifiers(member, modifiers) {
    	    return modifiers.some(modifier => {
    	      if (tsIsAccessModifier(modifier)) {
    	        return member.accessibility === modifier;
    	      }
    	      return !!member[modifier];
    	    });
    	  }
    	  tsIsStartOfStaticBlocks() {
    	    return this.isContextual(106) && this.lookaheadCharCode() === 123;
    	  }
    	  parseClassMember(classBody, member, state) {
    	    const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
    	    this.tsParseModifiers({
    	      allowedModifiers: modifiers,
    	      disallowedModifiers: ["in", "out"],
    	      stopOnStartOfClassStaticBlock: true,
    	      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
    	    }, member);
    	    const callParseClassMemberWithIsStatic = () => {
    	      if (this.tsIsStartOfStaticBlocks()) {
    	        this.next();
    	        this.next();
    	        if (this.tsHasSomeModifiers(member, modifiers)) {
    	          this.raise(TSErrors.StaticBlockCannotHaveModifier, {
    	            at: this.state.curPosition()
    	          });
    	        }
    	        super.parseClassStaticBlock(classBody, member);
    	      } else {
    	        this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
    	      }
    	    };
    	    if (member.declare) {
    	      this.tsInAmbientContext(callParseClassMemberWithIsStatic);
    	    } else {
    	      callParseClassMemberWithIsStatic();
    	    }
    	  }
    	  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
    	    const idx = this.tsTryParseIndexSignature(member);
    	    if (idx) {
    	      classBody.body.push(idx);
    	      if (member.abstract) {
    	        this.raise(TSErrors.IndexSignatureHasAbstract, {
    	          at: member
    	        });
    	      }
    	      if (member.accessibility) {
    	        this.raise(TSErrors.IndexSignatureHasAccessibility, {
    	          at: member,
    	          modifier: member.accessibility
    	        });
    	      }
    	      if (member.declare) {
    	        this.raise(TSErrors.IndexSignatureHasDeclare, {
    	          at: member
    	        });
    	      }
    	      if (member.override) {
    	        this.raise(TSErrors.IndexSignatureHasOverride, {
    	          at: member
    	        });
    	      }
    	      return;
    	    }
    	    if (!this.state.inAbstractClass && member.abstract) {
    	      this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {
    	        at: member
    	      });
    	    }
    	    if (member.override) {
    	      if (!state.hadSuperClass) {
    	        this.raise(TSErrors.OverrideNotInSubClass, {
    	          at: member
    	        });
    	      }
    	    }
    	    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
    	  }
    	  parsePostMemberNameModifiers(methodOrProp) {
    	    const optional = this.eat(17);
    	    if (optional) methodOrProp.optional = true;
    	    if (methodOrProp.readonly && this.match(10)) {
    	      this.raise(TSErrors.ClassMethodHasReadonly, {
    	        at: methodOrProp
    	      });
    	    }
    	    if (methodOrProp.declare && this.match(10)) {
    	      this.raise(TSErrors.ClassMethodHasDeclare, {
    	        at: methodOrProp
    	      });
    	    }
    	  }
    	  parseExpressionStatement(node, expr, decorators) {
    	    const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr, decorators) : undefined;
    	    return decl || super.parseExpressionStatement(node, expr, decorators);
    	  }
    	  shouldParseExportDeclaration() {
    	    if (this.tsIsDeclarationStart()) return true;
    	    return super.shouldParseExportDeclaration();
    	  }
    	  parseConditional(expr, startLoc, refExpressionErrors) {
    	    if (!this.state.maybeInArrowParameters || !this.match(17)) {
    	      return super.parseConditional(expr, startLoc, refExpressionErrors);
    	    }
    	    const result = this.tryParse(() => super.parseConditional(expr, startLoc));
    	    if (!result.node) {
    	      if (result.error) {
    	        super.setOptionalParametersError(refExpressionErrors, result.error);
    	      }
    	      return expr;
    	    }
    	    if (result.error) this.state = result.failState;
    	    return result.node;
    	  }
    	  parseParenItem(node, startLoc) {
    	    node = super.parseParenItem(node, startLoc);
    	    if (this.eat(17)) {
    	      node.optional = true;
    	      this.resetEndLocation(node);
    	    }
    	    if (this.match(14)) {
    	      const typeCastNode = this.startNodeAt(startLoc);
    	      typeCastNode.expression = node;
    	      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
    	      return this.finishNode(typeCastNode, "TSTypeCastExpression");
    	    }
    	    return node;
    	  }
    	  parseExportDeclaration(node) {
    	    if (!this.state.isAmbientContext && this.isContextual(125)) {
    	      return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
    	    }
    	    const startLoc = this.state.startLoc;
    	    const isDeclare = this.eatContextual(125);
    	    if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {
    	      throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {
    	        at: this.state.startLoc
    	      });
    	    }
    	    const isIdentifier = tokenIsIdentifier(this.state.type);
    	    const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
    	    if (!declaration) return null;
    	    if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
    	      node.exportKind = "type";
    	    }
    	    if (isDeclare) {
    	      this.resetStartLocation(declaration, startLoc);
    	      declaration.declare = true;
    	    }
    	    return declaration;
    	  }
    	  parseClassId(node, isStatement, optionalId, bindingType) {
    	    if ((!isStatement || optionalId) && this.isContextual(113)) {
    	      return;
    	    }
    	    super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 8331);
    	    const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
    	    if (typeParameters) node.typeParameters = typeParameters;
    	  }
    	  parseClassPropertyAnnotation(node) {
    	    if (!node.optional) {
    	      if (this.eat(35)) {
    	        node.definite = true;
    	      } else if (this.eat(17)) {
    	        node.optional = true;
    	      }
    	    }
    	    const type = this.tsTryParseTypeAnnotation();
    	    if (type) node.typeAnnotation = type;
    	  }
    	  parseClassProperty(node) {
    	    this.parseClassPropertyAnnotation(node);
    	    if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {
    	      this.raise(TSErrors.DeclareClassFieldHasInitializer, {
    	        at: this.state.startLoc
    	      });
    	    }
    	    if (node.abstract && this.match(29)) {
    	      const {
    	        key
    	      } = node;
    	      this.raise(TSErrors.AbstractPropertyHasInitializer, {
    	        at: this.state.startLoc,
    	        propertyName: key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
    	      });
    	    }
    	    return super.parseClassProperty(node);
    	  }
    	  parseClassPrivateProperty(node) {
    	    if (node.abstract) {
    	      this.raise(TSErrors.PrivateElementHasAbstract, {
    	        at: node
    	      });
    	    }
    	    if (node.accessibility) {
    	      this.raise(TSErrors.PrivateElementHasAccessibility, {
    	        at: node,
    	        modifier: node.accessibility
    	      });
    	    }
    	    this.parseClassPropertyAnnotation(node);
    	    return super.parseClassPrivateProperty(node);
    	  }
    	  parseClassAccessorProperty(node) {
    	    this.parseClassPropertyAnnotation(node);
    	    if (node.optional) {
    	      this.raise(TSErrors.AccessorCannotBeOptional, {
    	        at: node
    	      });
    	    }
    	    return super.parseClassAccessorProperty(node);
    	  }
    	  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
    	    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    	    if (typeParameters && isConstructor) {
    	      this.raise(TSErrors.ConstructorHasTypeParameters, {
    	        at: typeParameters
    	      });
    	    }
    	    const {
    	      declare = false,
    	      kind
    	    } = method;
    	    if (declare && (kind === "get" || kind === "set")) {
    	      this.raise(TSErrors.DeclareAccessor, {
    	        at: method,
    	        kind
    	      });
    	    }
    	    if (typeParameters) method.typeParameters = typeParameters;
    	    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
    	  }
    	  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
    	    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    	    if (typeParameters) method.typeParameters = typeParameters;
    	    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
    	  }
    	  declareClassPrivateMethodInScope(node, kind) {
    	    if (node.type === "TSDeclareMethod") return;
    	    if (node.type === "MethodDefinition" && !node.value.body) return;
    	    super.declareClassPrivateMethodInScope(node, kind);
    	  }
    	  parseClassSuper(node) {
    	    super.parseClassSuper(node);
    	    if (node.superClass && (this.match(47) || this.match(51))) {
    	      node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
    	    }
    	    if (this.eatContextual(113)) {
    	      node.implements = this.tsParseHeritageClause("implements");
    	    }
    	  }
    	  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
    	    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    	    if (typeParameters) prop.typeParameters = typeParameters;
    	    return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
    	  }
    	  parseFunctionParams(node, isConstructor) {
    	    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    	    if (typeParameters) node.typeParameters = typeParameters;
    	    super.parseFunctionParams(node, isConstructor);
    	  }
    	  parseVarId(decl, kind) {
    	    super.parseVarId(decl, kind);
    	    if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
    	      decl.definite = true;
    	    }
    	    const type = this.tsTryParseTypeAnnotation();
    	    if (type) {
    	      decl.id.typeAnnotation = type;
    	      this.resetEndLocation(decl.id);
    	    }
    	  }
    	  parseAsyncArrowFromCallExpression(node, call) {
    	    if (this.match(14)) {
    	      node.returnType = this.tsParseTypeAnnotation();
    	    }
    	    return super.parseAsyncArrowFromCallExpression(node, call);
    	  }
    	  parseMaybeAssign(refExpressionErrors, afterLeftParse) {
    	    var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;
    	    let state;
    	    let jsx;
    	    let typeCast;
    	    if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
    	      state = this.state.clone();
    	      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
    	      if (!jsx.error) return jsx.node;
    	      const {
    	        context
    	      } = this.state;
    	      const currentContext = context[context.length - 1];
    	      if (currentContext === types.j_oTag || currentContext === types.j_expr) {
    	        context.pop();
    	      }
    	    }
    	    if (!((_jsx = jsx) != null && _jsx.error) && !this.match(47)) {
    	      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
    	    }
    	    if (!state || state === this.state) state = this.state.clone();
    	    let typeParameters;
    	    const arrow = this.tryParse(abort => {
    	      var _expr$extra, _typeParameters;
    	      typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
    	      const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
    	      if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
    	        abort();
    	      }
    	      if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
    	        this.resetStartLocationFromNode(expr, typeParameters);
    	      }
    	      expr.typeParameters = typeParameters;
    	      return expr;
    	    }, state);
    	    if (!arrow.error && !arrow.aborted) {
    	      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
    	      return arrow.node;
    	    }
    	    if (!jsx) {
    	      assert(!this.hasPlugin("jsx"));
    	      typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
    	      if (!typeCast.error) return typeCast.node;
    	    }
    	    if ((_jsx2 = jsx) != null && _jsx2.node) {
    	      this.state = jsx.failState;
    	      return jsx.node;
    	    }
    	    if (arrow.node) {
    	      this.state = arrow.failState;
    	      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
    	      return arrow.node;
    	    }
    	    if ((_typeCast = typeCast) != null && _typeCast.node) {
    	      this.state = typeCast.failState;
    	      return typeCast.node;
    	    }
    	    throw ((_jsx3 = jsx) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);
    	  }
    	  reportReservedArrowTypeParam(node) {
    	    var _node$extra;
    	    if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
    	      this.raise(TSErrors.ReservedArrowTypeParam, {
    	        at: node
    	      });
    	    }
    	  }
    	  parseMaybeUnary(refExpressionErrors, sawUnary) {
    	    if (!this.hasPlugin("jsx") && this.match(47)) {
    	      return this.tsParseTypeAssertion();
    	    }
    	    return super.parseMaybeUnary(refExpressionErrors, sawUnary);
    	  }
    	  parseArrow(node) {
    	    if (this.match(14)) {
    	      const result = this.tryParse(abort => {
    	        const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
    	        if (this.canInsertSemicolon() || !this.match(19)) abort();
    	        return returnType;
    	      });
    	      if (result.aborted) return;
    	      if (!result.thrown) {
    	        if (result.error) this.state = result.failState;
    	        node.returnType = result.node;
    	      }
    	    }
    	    return super.parseArrow(node);
    	  }
    	  parseAssignableListItemTypes(param, flags) {
    	    if (!(flags & 2)) return param;
    	    if (this.eat(17)) {
    	      param.optional = true;
    	    }
    	    const type = this.tsTryParseTypeAnnotation();
    	    if (type) param.typeAnnotation = type;
    	    this.resetEndLocation(param);
    	    return param;
    	  }
    	  isAssignable(node, isBinding) {
    	    switch (node.type) {
    	      case "TSTypeCastExpression":
    	        return this.isAssignable(node.expression, isBinding);
    	      case "TSParameterProperty":
    	        return true;
    	      default:
    	        return super.isAssignable(node, isBinding);
    	    }
    	  }
    	  toAssignable(node, isLHS = false) {
    	    switch (node.type) {
    	      case "ParenthesizedExpression":
    	        this.toAssignableParenthesizedExpression(node, isLHS);
    	        break;
    	      case "TSAsExpression":
    	      case "TSSatisfiesExpression":
    	      case "TSNonNullExpression":
    	      case "TSTypeAssertion":
    	        if (isLHS) {
    	          this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, {
    	            at: node
    	          });
    	        } else {
    	          this.raise(TSErrors.UnexpectedTypeCastInParameter, {
    	            at: node
    	          });
    	        }
    	        this.toAssignable(node.expression, isLHS);
    	        break;
    	      case "AssignmentExpression":
    	        if (!isLHS && node.left.type === "TSTypeCastExpression") {
    	          node.left = this.typeCastToParameter(node.left);
    	        }
    	      default:
    	        super.toAssignable(node, isLHS);
    	    }
    	  }
    	  toAssignableParenthesizedExpression(node, isLHS) {
    	    switch (node.expression.type) {
    	      case "TSAsExpression":
    	      case "TSSatisfiesExpression":
    	      case "TSNonNullExpression":
    	      case "TSTypeAssertion":
    	      case "ParenthesizedExpression":
    	        this.toAssignable(node.expression, isLHS);
    	        break;
    	      default:
    	        super.toAssignable(node, isLHS);
    	    }
    	  }
    	  checkToRestConversion(node, allowPattern) {
    	    switch (node.type) {
    	      case "TSAsExpression":
    	      case "TSSatisfiesExpression":
    	      case "TSTypeAssertion":
    	      case "TSNonNullExpression":
    	        this.checkToRestConversion(node.expression, false);
    	        break;
    	      default:
    	        super.checkToRestConversion(node, allowPattern);
    	    }
    	  }
    	  isValidLVal(type, isUnparenthesizedInAssign, binding) {
    	    return getOwn({
    	      TSTypeCastExpression: true,
    	      TSParameterProperty: "parameter",
    	      TSNonNullExpression: "expression",
    	      TSAsExpression: (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true],
    	      TSSatisfiesExpression: (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true],
    	      TSTypeAssertion: (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true]
    	    }, type) || super.isValidLVal(type, isUnparenthesizedInAssign, binding);
    	  }
    	  parseBindingAtom() {
    	    if (this.state.type === 78) {
    	      return this.parseIdentifier(true);
    	    }
    	    return super.parseBindingAtom();
    	  }
    	  parseMaybeDecoratorArguments(expr) {
    	    if (this.match(47) || this.match(51)) {
    	      const typeArguments = this.tsParseTypeArgumentsInExpression();
    	      if (this.match(10)) {
    	        const call = super.parseMaybeDecoratorArguments(expr);
    	        call.typeParameters = typeArguments;
    	        return call;
    	      }
    	      this.unexpected(null, 10);
    	    }
    	    return super.parseMaybeDecoratorArguments(expr);
    	  }
    	  checkCommaAfterRest(close) {
    	    if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
    	      this.next();
    	      return false;
    	    }
    	    return super.checkCommaAfterRest(close);
    	  }
    	  isClassMethod() {
    	    return this.match(47) || super.isClassMethod();
    	  }
    	  isClassProperty() {
    	    return this.match(35) || this.match(14) || super.isClassProperty();
    	  }
    	  parseMaybeDefault(startLoc, left) {
    	    const node = super.parseMaybeDefault(startLoc, left);
    	    if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
    	      this.raise(TSErrors.TypeAnnotationAfterAssign, {
    	        at: node.typeAnnotation
    	      });
    	    }
    	    return node;
    	  }
    	  getTokenFromCode(code) {
    	    if (this.state.inType) {
    	      if (code === 62) {
    	        this.finishOp(48, 1);
    	        return;
    	      }
    	      if (code === 60) {
    	        this.finishOp(47, 1);
    	        return;
    	      }
    	    }
    	    super.getTokenFromCode(code);
    	  }
    	  reScan_lt_gt() {
    	    const {
    	      type
    	    } = this.state;
    	    if (type === 47) {
    	      this.state.pos -= 1;
    	      this.readToken_lt();
    	    } else if (type === 48) {
    	      this.state.pos -= 1;
    	      this.readToken_gt();
    	    }
    	  }
    	  reScan_lt() {
    	    const {
    	      type
    	    } = this.state;
    	    if (type === 51) {
    	      this.state.pos -= 2;
    	      this.finishOp(47, 1);
    	      return 47;
    	    }
    	    return type;
    	  }
    	  toAssignableList(exprList, trailingCommaLoc, isLHS) {
    	    for (let i = 0; i < exprList.length; i++) {
    	      const expr = exprList[i];
    	      if ((expr == null ? void 0 : expr.type) === "TSTypeCastExpression") {
    	        exprList[i] = this.typeCastToParameter(expr);
    	      }
    	    }
    	    super.toAssignableList(exprList, trailingCommaLoc, isLHS);
    	  }
    	  typeCastToParameter(node) {
    	    node.expression.typeAnnotation = node.typeAnnotation;
    	    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
    	    return node.expression;
    	  }
    	  shouldParseArrow(params) {
    	    if (this.match(14)) {
    	      return params.every(expr => this.isAssignable(expr, true));
    	    }
    	    return super.shouldParseArrow(params);
    	  }
    	  shouldParseAsyncArrow() {
    	    return this.match(14) || super.shouldParseAsyncArrow();
    	  }
    	  canHaveLeadingDecorator() {
    	    return super.canHaveLeadingDecorator() || this.isAbstractClass();
    	  }
    	  jsxParseOpeningElementAfterName(node) {
    	    if (this.match(47) || this.match(51)) {
    	      const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
    	      if (typeArguments) node.typeParameters = typeArguments;
    	    }
    	    return super.jsxParseOpeningElementAfterName(node);
    	  }
    	  getGetterSetterExpectedParamCount(method) {
    	    const baseCount = super.getGetterSetterExpectedParamCount(method);
    	    const params = this.getObjectOrClassMethodParams(method);
    	    const firstParam = params[0];
    	    const hasContextParam = firstParam && this.isThisParam(firstParam);
    	    return hasContextParam ? baseCount + 1 : baseCount;
    	  }
    	  parseCatchClauseParam() {
    	    const param = super.parseCatchClauseParam();
    	    const type = this.tsTryParseTypeAnnotation();
    	    if (type) {
    	      param.typeAnnotation = type;
    	      this.resetEndLocation(param);
    	    }
    	    return param;
    	  }
    	  tsInAmbientContext(cb) {
    	    const oldIsAmbientContext = this.state.isAmbientContext;
    	    this.state.isAmbientContext = true;
    	    try {
    	      return cb();
    	    } finally {
    	      this.state.isAmbientContext = oldIsAmbientContext;
    	    }
    	  }
    	  parseClass(node, isStatement, optionalId) {
    	    const oldInAbstractClass = this.state.inAbstractClass;
    	    this.state.inAbstractClass = !!node.abstract;
    	    try {
    	      return super.parseClass(node, isStatement, optionalId);
    	    } finally {
    	      this.state.inAbstractClass = oldInAbstractClass;
    	    }
    	  }
    	  tsParseAbstractDeclaration(node, decorators) {
    	    if (this.match(80)) {
    	      node.abstract = true;
    	      return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));
    	    } else if (this.isContextual(129)) {
    	      if (!this.hasFollowingLineBreak()) {
    	        node.abstract = true;
    	        this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {
    	          at: node
    	        });
    	        return this.tsParseInterfaceDeclaration(node);
    	      }
    	    } else {
    	      this.unexpected(null, 80);
    	    }
    	  }
    	  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
    	    const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
    	    if (method.abstract) {
    	      const hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;
    	      if (hasBody) {
    	        const {
    	          key
    	        } = method;
    	        this.raise(TSErrors.AbstractMethodHasImplementation, {
    	          at: method,
    	          methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
    	        });
    	      }
    	    }
    	    return method;
    	  }
    	  tsParseTypeParameterName() {
    	    const typeName = this.parseIdentifier();
    	    return typeName.name;
    	  }
    	  shouldParseAsAmbientContext() {
    	    return !!this.getPluginOption("typescript", "dts");
    	  }
    	  parse() {
    	    if (this.shouldParseAsAmbientContext()) {
    	      this.state.isAmbientContext = true;
    	    }
    	    return super.parse();
    	  }
    	  getExpression() {
    	    if (this.shouldParseAsAmbientContext()) {
    	      this.state.isAmbientContext = true;
    	    }
    	    return super.getExpression();
    	  }
    	  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
    	    if (!isString && isMaybeTypeOnly) {
    	      this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
    	      return this.finishNode(node, "ExportSpecifier");
    	    }
    	    node.exportKind = "value";
    	    return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);
    	  }
    	  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
    	    if (!importedIsString && isMaybeTypeOnly) {
    	      this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
    	      return this.finishNode(specifier, "ImportSpecifier");
    	    }
    	    specifier.importKind = "value";
    	    return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);
    	  }
    	  parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
    	    const leftOfAsKey = isImport ? "imported" : "local";
    	    const rightOfAsKey = isImport ? "local" : "exported";
    	    let leftOfAs = node[leftOfAsKey];
    	    let rightOfAs;
    	    let hasTypeSpecifier = false;
    	    let canParseAsKeyword = true;
    	    const loc = leftOfAs.loc.start;
    	    if (this.isContextual(93)) {
    	      const firstAs = this.parseIdentifier();
    	      if (this.isContextual(93)) {
    	        const secondAs = this.parseIdentifier();
    	        if (tokenIsKeywordOrIdentifier(this.state.type)) {
    	          hasTypeSpecifier = true;
    	          leftOfAs = firstAs;
    	          rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
    	          canParseAsKeyword = false;
    	        } else {
    	          rightOfAs = secondAs;
    	          canParseAsKeyword = false;
    	        }
    	      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
    	        canParseAsKeyword = false;
    	        rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
    	      } else {
    	        hasTypeSpecifier = true;
    	        leftOfAs = firstAs;
    	      }
    	    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
    	      hasTypeSpecifier = true;
    	      if (isImport) {
    	        leftOfAs = this.parseIdentifier(true);
    	        if (!this.isContextual(93)) {
    	          this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
    	        }
    	      } else {
    	        leftOfAs = this.parseModuleExportName();
    	      }
    	    }
    	    if (hasTypeSpecifier && isInTypeOnlyImportExport) {
    	      this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, {
    	        at: loc
    	      });
    	    }
    	    node[leftOfAsKey] = leftOfAs;
    	    node[rightOfAsKey] = rightOfAs;
    	    const kindKey = isImport ? "importKind" : "exportKind";
    	    node[kindKey] = hasTypeSpecifier ? "type" : "value";
    	    if (canParseAsKeyword && this.eatContextual(93)) {
    	      node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
    	    }
    	    if (!node[rightOfAsKey]) {
    	      node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);
    	    }
    	    if (isImport) {
    	      this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
    	    }
    	  }
    	};
    	function isPossiblyLiteralEnum(expression) {
    	  if (expression.type !== "MemberExpression") return false;
    	  const {
    	    computed,
    	    property
    	  } = expression;
    	  if (computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
    	    return false;
    	  }
    	  return isUncomputedMemberExpressionChain(expression.object);
    	}
    	function isValidAmbientConstInitializer(expression, estree) {
    	  var _expression$extra;
    	  const {
    	    type
    	  } = expression;
    	  if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {
    	    return false;
    	  }
    	  if (estree) {
    	    if (type === "Literal") {
    	      const {
    	        value
    	      } = expression;
    	      if (typeof value === "string" || typeof value === "boolean") {
    	        return true;
    	      }
    	    }
    	  } else {
    	    if (type === "StringLiteral" || type === "BooleanLiteral") {
    	      return true;
    	    }
    	  }
    	  if (isNumber(expression, estree) || isNegativeNumber(expression, estree)) {
    	    return true;
    	  }
    	  if (type === "TemplateLiteral" && expression.expressions.length === 0) {
    	    return true;
    	  }
    	  if (isPossiblyLiteralEnum(expression)) {
    	    return true;
    	  }
    	  return false;
    	}
    	function isNumber(expression, estree) {
    	  if (estree) {
    	    return expression.type === "Literal" && (typeof expression.value === "number" || "bigint" in expression);
    	  }
    	  return expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
    	}
    	function isNegativeNumber(expression, estree) {
    	  if (expression.type === "UnaryExpression") {
    	    const {
    	      operator,
    	      argument
    	    } = expression;
    	    if (operator === "-" && isNumber(argument, estree)) {
    	      return true;
    	    }
    	  }
    	  return false;
    	}
    	function isUncomputedMemberExpressionChain(expression) {
    	  if (expression.type === "Identifier") return true;
    	  if (expression.type !== "MemberExpression" || expression.computed) {
    	    return false;
    	  }
    	  return isUncomputedMemberExpressionChain(expression.object);
    	}
    	const PlaceholderErrors = ParseErrorEnum`placeholders`({
    	  ClassNameIsRequired: "A class name is required.",
    	  UnexpectedSpace: "Unexpected space in placeholder."
    	});
    	var placeholders = superClass => class PlaceholdersParserMixin extends superClass {
    	  parsePlaceholder(expectedNode) {
    	    if (this.match(144)) {
    	      const node = this.startNode();
    	      this.next();
    	      this.assertNoSpace();
    	      node.name = super.parseIdentifier(true);
    	      this.assertNoSpace();
    	      this.expect(144);
    	      return this.finishPlaceholder(node, expectedNode);
    	    }
    	  }
    	  finishPlaceholder(node, expectedNode) {
    	    const isFinished = !!(node.expectedNode && node.type === "Placeholder");
    	    node.expectedNode = expectedNode;
    	    return isFinished ? node : this.finishNode(node, "Placeholder");
    	  }
    	  getTokenFromCode(code) {
    	    if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
    	      this.finishOp(144, 2);
    	    } else {
    	      super.getTokenFromCode(code);
    	    }
    	  }
    	  parseExprAtom(refExpressionErrors) {
    	    return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
    	  }
    	  parseIdentifier(liberal) {
    	    return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
    	  }
    	  checkReservedWord(word, startLoc, checkKeywords, isBinding) {
    	    if (word !== undefined) {
    	      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
    	    }
    	  }
    	  parseBindingAtom() {
    	    return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    	  }
    	  isValidLVal(type, isParenthesized, binding) {
    	    return type === "Placeholder" || super.isValidLVal(type, isParenthesized, binding);
    	  }
    	  toAssignable(node, isLHS) {
    	    if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
    	      node.expectedNode = "Pattern";
    	    } else {
    	      super.toAssignable(node, isLHS);
    	    }
    	  }
    	  chStartsBindingIdentifier(ch, pos) {
    	    if (super.chStartsBindingIdentifier(ch, pos)) {
    	      return true;
    	    }
    	    const nextToken = this.lookahead();
    	    if (nextToken.type === 144) {
    	      return true;
    	    }
    	    return false;
    	  }
    	  verifyBreakContinue(node, isBreak) {
    	    if (node.label && node.label.type === "Placeholder") return;
    	    super.verifyBreakContinue(node, isBreak);
    	  }
    	  parseExpressionStatement(node, expr) {
    	    var _expr$extra;
    	    if (expr.type !== "Placeholder" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
    	      return super.parseExpressionStatement(node, expr);
    	    }
    	    if (this.match(14)) {
    	      const stmt = node;
    	      stmt.label = this.finishPlaceholder(expr, "Identifier");
    	      this.next();
    	      stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();
    	      return this.finishNode(stmt, "LabeledStatement");
    	    }
    	    this.semicolon();
    	    node.name = expr.name;
    	    return this.finishPlaceholder(node, "Statement");
    	  }
    	  parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
    	    return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
    	  }
    	  parseFunctionId(requireId) {
    	    return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
    	  }
    	  parseClass(node, isStatement, optionalId) {
    	    const type = isStatement ? "ClassDeclaration" : "ClassExpression";
    	    this.next();
    	    const oldStrict = this.state.strict;
    	    const placeholder = this.parsePlaceholder("Identifier");
    	    if (placeholder) {
    	      if (this.match(81) || this.match(144) || this.match(5)) {
    	        node.id = placeholder;
    	      } else if (optionalId || !isStatement) {
    	        node.id = null;
    	        node.body = this.finishPlaceholder(placeholder, "ClassBody");
    	        return this.finishNode(node, type);
    	      } else {
    	        throw this.raise(PlaceholderErrors.ClassNameIsRequired, {
    	          at: this.state.startLoc
    	        });
    	      }
    	    } else {
    	      this.parseClassId(node, isStatement, optionalId);
    	    }
    	    super.parseClassSuper(node);
    	    node.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node.superClass, oldStrict);
    	    return this.finishNode(node, type);
    	  }
    	  parseExport(node, decorators) {
    	    const placeholder = this.parsePlaceholder("Identifier");
    	    if (!placeholder) return super.parseExport(node, decorators);
    	    if (!this.isContextual(98) && !this.match(12)) {
    	      node.specifiers = [];
    	      node.source = null;
    	      node.declaration = this.finishPlaceholder(placeholder, "Declaration");
    	      return this.finishNode(node, "ExportNamedDeclaration");
    	    }
    	    this.expectPlugin("exportDefaultFrom");
    	    const specifier = this.startNode();
    	    specifier.exported = placeholder;
    	    node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
    	    return super.parseExport(node, decorators);
    	  }
    	  isExportDefaultSpecifier() {
    	    if (this.match(65)) {
    	      const next = this.nextTokenStart();
    	      if (this.isUnparsedContextual(next, "from")) {
    	        if (this.input.startsWith(tokenLabelName(144), this.nextTokenStartSince(next + 4))) {
    	          return true;
    	        }
    	      }
    	    }
    	    return super.isExportDefaultSpecifier();
    	  }
    	  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
    	    var _specifiers;
    	    if ((_specifiers = node.specifiers) != null && _specifiers.length) {
    	      return true;
    	    }
    	    return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
    	  }
    	  checkExport(node) {
    	    const {
    	      specifiers
    	    } = node;
    	    if (specifiers != null && specifiers.length) {
    	      node.specifiers = specifiers.filter(node => node.exported.type === "Placeholder");
    	    }
    	    super.checkExport(node);
    	    node.specifiers = specifiers;
    	  }
    	  parseImport(node) {
    	    const placeholder = this.parsePlaceholder("Identifier");
    	    if (!placeholder) return super.parseImport(node);
    	    node.specifiers = [];
    	    if (!this.isContextual(98) && !this.match(12)) {
    	      node.source = this.finishPlaceholder(placeholder, "StringLiteral");
    	      this.semicolon();
    	      return this.finishNode(node, "ImportDeclaration");
    	    }
    	    const specifier = this.startNodeAtNode(placeholder);
    	    specifier.local = placeholder;
    	    node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
    	    if (this.eat(12)) {
    	      const hasStarImport = this.maybeParseStarImportSpecifier(node);
    	      if (!hasStarImport) this.parseNamedImportSpecifiers(node);
    	    }
    	    this.expectContextual(98);
    	    node.source = this.parseImportSource();
    	    this.semicolon();
    	    return this.finishNode(node, "ImportDeclaration");
    	  }
    	  parseImportSource() {
    	    return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    	  }
    	  assertNoSpace() {
    	    if (this.state.start > this.state.lastTokEndLoc.index) {
    	      this.raise(PlaceholderErrors.UnexpectedSpace, {
    	        at: this.state.lastTokEndLoc
    	      });
    	    }
    	  }
    	};
    	var v8intrinsic = superClass => class V8IntrinsicMixin extends superClass {
    	  parseV8Intrinsic() {
    	    if (this.match(54)) {
    	      const v8IntrinsicStartLoc = this.state.startLoc;
    	      const node = this.startNode();
    	      this.next();
    	      if (tokenIsIdentifier(this.state.type)) {
    	        const name = this.parseIdentifierName();
    	        const identifier = this.createIdentifier(node, name);
    	        identifier.type = "V8IntrinsicIdentifier";
    	        if (this.match(10)) {
    	          return identifier;
    	        }
    	      }
    	      this.unexpected(v8IntrinsicStartLoc);
    	    }
    	  }
    	  parseExprAtom(refExpressionErrors) {
    	    return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
    	  }
    	};
    	function hasPlugin(plugins, expectedConfig) {
    	  const [expectedName, expectedOptions] = typeof expectedConfig === "string" ? [expectedConfig, {}] : expectedConfig;
    	  const expectedKeys = Object.keys(expectedOptions);
    	  const expectedOptionsIsEmpty = expectedKeys.length === 0;
    	  return plugins.some(p => {
    	    if (typeof p === "string") {
    	      return expectedOptionsIsEmpty && p === expectedName;
    	    } else {
    	      const [pluginName, pluginOptions] = p;
    	      if (pluginName !== expectedName) {
    	        return false;
    	      }
    	      for (const key of expectedKeys) {
    	        if (pluginOptions[key] !== expectedOptions[key]) {
    	          return false;
    	        }
    	      }
    	      return true;
    	    }
    	  });
    	}
    	function getPluginOption(plugins, name, option) {
    	  const plugin = plugins.find(plugin => {
    	    if (Array.isArray(plugin)) {
    	      return plugin[0] === name;
    	    } else {
    	      return plugin === name;
    	    }
    	  });
    	  if (plugin && Array.isArray(plugin) && plugin.length > 1) {
    	    return plugin[1][option];
    	  }
    	  return null;
    	}
    	const PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
    	const TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
    	const RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
    	function validatePlugins(plugins) {
    	  if (hasPlugin(plugins, "decorators")) {
    	    if (hasPlugin(plugins, "decorators-legacy")) {
    	      throw new Error("Cannot use the decorators and decorators-legacy plugin together");
    	    }
    	    const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
    	    if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") {
    	      throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
    	    }
    	    const allowCallParenthesized = getPluginOption(plugins, "decorators", "allowCallParenthesized");
    	    if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") {
    	      throw new Error("'allowCallParenthesized' must be a boolean.");
    	    }
    	  }
    	  if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
    	    throw new Error("Cannot combine flow and typescript plugins.");
    	  }
    	  if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
    	    throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    	  }
    	  if (hasPlugin(plugins, "pipelineOperator")) {
    	    const proposal = getPluginOption(plugins, "pipelineOperator", "proposal");
    	    if (!PIPELINE_PROPOSALS.includes(proposal)) {
    	      const proposalList = PIPELINE_PROPOSALS.map(p => `"${p}"`).join(", ");
    	      throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
    	    }
    	    const tupleSyntaxIsHash = hasPlugin(plugins, ["recordAndTuple", {
    	      syntaxType: "hash"
    	    }]);
    	    if (proposal === "hack") {
    	      if (hasPlugin(plugins, "placeholders")) {
    	        throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
    	      }
    	      if (hasPlugin(plugins, "v8intrinsic")) {
    	        throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
    	      }
    	      const topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");
    	      if (!TOPIC_TOKENS.includes(topicToken)) {
    	        const tokenList = TOPIC_TOKENS.map(t => `"${t}"`).join(", ");
    	        throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
    	      }
    	      if (topicToken === "#" && tupleSyntaxIsHash) {
    	        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
    	      }
    	    } else if (proposal === "smart" && tupleSyntaxIsHash) {
    	      throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
    	    }
    	  }
    	  if (hasPlugin(plugins, "moduleAttributes")) {
    	    {
    	      if (hasPlugin(plugins, "importAssertions") || hasPlugin(plugins, "importAttributes")) {
    	        throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
    	      }
    	      const moduleAttributesVersionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");
    	      if (moduleAttributesVersionPluginOption !== "may-2020") {
    	        throw new Error("The 'moduleAttributes' plugin requires a 'version' option," + " representing the last proposal update. Currently, the" + " only supported value is 'may-2020'.");
    	      }
    	    }
    	  }
    	  if (hasPlugin(plugins, "importAssertions") && hasPlugin(plugins, "importAttributes")) {
    	    throw new Error("Cannot combine importAssertions and importAttributes plugins.");
    	  }
    	  if (hasPlugin(plugins, "recordAndTuple") && getPluginOption(plugins, "recordAndTuple", "syntaxType") != null && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
    	    throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(", "));
    	  }
    	  if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
    	    const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
    	    error.missingPlugins = "doExpressions";
    	    throw error;
    	  }
    	  if (hasPlugin(plugins, "optionalChainingAssign") && getPluginOption(plugins, "optionalChainingAssign", "version") !== "2023-07") {
    	    throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option," + " representing the last proposal update. Currently, the" + " only supported value is '2023-07'.");
    	  }
    	}
    	const mixinPlugins = {
    	  estree,
    	  jsx,
    	  flow,
    	  typescript,
    	  v8intrinsic,
    	  placeholders
    	};
    	const mixinPluginNames = Object.keys(mixinPlugins);
    	const defaultOptions = {
    	  sourceType: "script",
    	  sourceFilename: undefined,
    	  startColumn: 0,
    	  startLine: 1,
    	  allowAwaitOutsideFunction: false,
    	  allowReturnOutsideFunction: false,
    	  allowNewTargetOutsideFunction: false,
    	  allowImportExportEverywhere: false,
    	  allowSuperOutsideMethod: false,
    	  allowUndeclaredExports: false,
    	  plugins: [],
    	  strictMode: null,
    	  ranges: false,
    	  tokens: false,
    	  createImportExpressions: false,
    	  createParenthesizedExpressions: false,
    	  errorRecovery: false,
    	  attachComment: true,
    	  annexB: true
    	};
    	function getOptions(opts) {
    	  if (opts == null) {
    	    return Object.assign({}, defaultOptions);
    	  }
    	  if (opts.annexB != null && opts.annexB !== false) {
    	    throw new Error("The `annexB` option can only be set to `false`.");
    	  }
    	  const options = {};
    	  for (const key of Object.keys(defaultOptions)) {
    	    var _opts$key;
    	    options[key] = (_opts$key = opts[key]) != null ? _opts$key : defaultOptions[key];
    	  }
    	  return options;
    	}
    	class ExpressionParser extends LValParser {
    	  checkProto(prop, isRecord, protoRef, refExpressionErrors) {
    	    if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
    	      return;
    	    }
    	    const key = prop.key;
    	    const name = key.type === "Identifier" ? key.name : key.value;
    	    if (name === "__proto__") {
    	      if (isRecord) {
    	        this.raise(Errors.RecordNoProto, {
    	          at: key
    	        });
    	        return;
    	      }
    	      if (protoRef.used) {
    	        if (refExpressionErrors) {
    	          if (refExpressionErrors.doubleProtoLoc === null) {
    	            refExpressionErrors.doubleProtoLoc = key.loc.start;
    	          }
    	        } else {
    	          this.raise(Errors.DuplicateProto, {
    	            at: key
    	          });
    	        }
    	      }
    	      protoRef.used = true;
    	    }
    	  }
    	  shouldExitDescending(expr, potentialArrowAt) {
    	    return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
    	  }
    	  getExpression() {
    	    this.enterInitialScopes();
    	    this.nextToken();
    	    const expr = this.parseExpression();
    	    if (!this.match(139)) {
    	      this.unexpected();
    	    }
    	    this.finalizeRemainingComments();
    	    expr.comments = this.state.comments;
    	    expr.errors = this.state.errors;
    	    if (this.options.tokens) {
    	      expr.tokens = this.tokens;
    	    }
    	    return expr;
    	  }
    	  parseExpression(disallowIn, refExpressionErrors) {
    	    if (disallowIn) {
    	      return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
    	    }
    	    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
    	  }
    	  parseExpressionBase(refExpressionErrors) {
    	    const startLoc = this.state.startLoc;
    	    const expr = this.parseMaybeAssign(refExpressionErrors);
    	    if (this.match(12)) {
    	      const node = this.startNodeAt(startLoc);
    	      node.expressions = [expr];
    	      while (this.eat(12)) {
    	        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
    	      }
    	      this.toReferencedList(node.expressions);
    	      return this.finishNode(node, "SequenceExpression");
    	    }
    	    return expr;
    	  }
    	  parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
    	    return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
    	  }
    	  parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
    	    return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
    	  }
    	  setOptionalParametersError(refExpressionErrors, resultError) {
    	    var _resultError$loc;
    	    refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;
    	  }
    	  parseMaybeAssign(refExpressionErrors, afterLeftParse) {
    	    const startLoc = this.state.startLoc;
    	    if (this.isContextual(108)) {
    	      if (this.prodParam.hasYield) {
    	        let left = this.parseYield();
    	        if (afterLeftParse) {
    	          left = afterLeftParse.call(this, left, startLoc);
    	        }
    	        return left;
    	      }
    	    }
    	    let ownExpressionErrors;
    	    if (refExpressionErrors) {
    	      ownExpressionErrors = false;
    	    } else {
    	      refExpressionErrors = new ExpressionErrors();
    	      ownExpressionErrors = true;
    	    }
    	    const {
    	      type
    	    } = this.state;
    	    if (type === 10 || tokenIsIdentifier(type)) {
    	      this.state.potentialArrowAt = this.state.start;
    	    }
    	    let left = this.parseMaybeConditional(refExpressionErrors);
    	    if (afterLeftParse) {
    	      left = afterLeftParse.call(this, left, startLoc);
    	    }
    	    if (tokenIsAssignment(this.state.type)) {
    	      const node = this.startNodeAt(startLoc);
    	      const operator = this.state.value;
    	      node.operator = operator;
    	      if (this.match(29)) {
    	        this.toAssignable(left, true);
    	        node.left = left;
    	        const startIndex = startLoc.index;
    	        if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {
    	          refExpressionErrors.doubleProtoLoc = null;
    	        }
    	        if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {
    	          refExpressionErrors.shorthandAssignLoc = null;
    	        }
    	        if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
    	          this.checkDestructuringPrivate(refExpressionErrors);
    	          refExpressionErrors.privateKeyLoc = null;
    	        }
    	      } else {
    	        node.left = left;
    	      }
    	      this.next();
    	      node.right = this.parseMaybeAssign();
    	      this.checkLVal(left, {
    	        in: this.finishNode(node, "AssignmentExpression")
    	      });
    	      return node;
    	    } else if (ownExpressionErrors) {
    	      this.checkExpressionErrors(refExpressionErrors, true);
    	    }
    	    return left;
    	  }
    	  parseMaybeConditional(refExpressionErrors) {
    	    const startLoc = this.state.startLoc;
    	    const potentialArrowAt = this.state.potentialArrowAt;
    	    const expr = this.parseExprOps(refExpressionErrors);
    	    if (this.shouldExitDescending(expr, potentialArrowAt)) {
    	      return expr;
    	    }
    	    return this.parseConditional(expr, startLoc, refExpressionErrors);
    	  }
    	  parseConditional(expr, startLoc, refExpressionErrors) {
    	    if (this.eat(17)) {
    	      const node = this.startNodeAt(startLoc);
    	      node.test = expr;
    	      node.consequent = this.parseMaybeAssignAllowIn();
    	      this.expect(14);
    	      node.alternate = this.parseMaybeAssign();
    	      return this.finishNode(node, "ConditionalExpression");
    	    }
    	    return expr;
    	  }
    	  parseMaybeUnaryOrPrivate(refExpressionErrors) {
    	    return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
    	  }
    	  parseExprOps(refExpressionErrors) {
    	    const startLoc = this.state.startLoc;
    	    const potentialArrowAt = this.state.potentialArrowAt;
    	    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
    	    if (this.shouldExitDescending(expr, potentialArrowAt)) {
    	      return expr;
    	    }
    	    return this.parseExprOp(expr, startLoc, -1);
    	  }
    	  parseExprOp(left, leftStartLoc, minPrec) {
    	    if (this.isPrivateName(left)) {
    	      const value = this.getPrivateNameSV(left);
    	      if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
    	        this.raise(Errors.PrivateInExpectedIn, {
    	          at: left,
    	          identifierName: value
    	        });
    	      }
    	      this.classScope.usePrivateName(value, left.loc.start);
    	    }
    	    const op = this.state.type;
    	    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
    	      let prec = tokenOperatorPrecedence(op);
    	      if (prec > minPrec) {
    	        if (op === 39) {
    	          this.expectPlugin("pipelineOperator");
    	          if (this.state.inFSharpPipelineDirectBody) {
    	            return left;
    	          }
    	          this.checkPipelineAtInfixOperator(left, leftStartLoc);
    	        }
    	        const node = this.startNodeAt(leftStartLoc);
    	        node.left = left;
    	        node.operator = this.state.value;
    	        const logical = op === 41 || op === 42;
    	        const coalesce = op === 40;
    	        if (coalesce) {
    	          prec = tokenOperatorPrecedence(42);
    	        }
    	        this.next();
    	        if (op === 39 && this.hasPlugin(["pipelineOperator", {
    	          proposal: "minimal"
    	        }])) {
    	          if (this.state.type === 96 && this.prodParam.hasAwait) {
    	            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {
    	              at: this.state.startLoc
    	            });
    	          }
    	        }
    	        node.right = this.parseExprOpRightExpr(op, prec);
    	        const finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
    	        const nextOp = this.state.type;
    	        if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
    	          throw this.raise(Errors.MixingCoalesceWithLogical, {
    	            at: this.state.startLoc
    	          });
    	        }
    	        return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
    	      }
    	    }
    	    return left;
    	  }
    	  parseExprOpRightExpr(op, prec) {
    	    const startLoc = this.state.startLoc;
    	    switch (op) {
    	      case 39:
    	        switch (this.getPluginOption("pipelineOperator", "proposal")) {
    	          case "hack":
    	            return this.withTopicBindingContext(() => {
    	              return this.parseHackPipeBody();
    	            });
    	          case "smart":
    	            return this.withTopicBindingContext(() => {
    	              if (this.prodParam.hasYield && this.isContextual(108)) {
    	                throw this.raise(Errors.PipeBodyIsTighter, {
    	                  at: this.state.startLoc
    	                });
    	              }
    	              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);
    	            });
    	          case "fsharp":
    	            return this.withSoloAwaitPermittingContext(() => {
    	              return this.parseFSharpPipelineBody(prec);
    	            });
    	        }
    	      default:
    	        return this.parseExprOpBaseRightExpr(op, prec);
    	    }
    	  }
    	  parseExprOpBaseRightExpr(op, prec) {
    	    const startLoc = this.state.startLoc;
    	    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
    	  }
    	  parseHackPipeBody() {
    	    var _body$extra;
    	    const {
    	      startLoc
    	    } = this.state;
    	    const body = this.parseMaybeAssign();
    	    const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
    	    if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
    	      this.raise(Errors.PipeUnparenthesizedBody, {
    	        at: startLoc,
    	        type: body.type
    	      });
    	    }
    	    if (!this.topicReferenceWasUsedInCurrentContext()) {
    	      this.raise(Errors.PipeTopicUnused, {
    	        at: startLoc
    	      });
    	    }
    	    return body;
    	  }
    	  checkExponentialAfterUnary(node) {
    	    if (this.match(57)) {
    	      this.raise(Errors.UnexpectedTokenUnaryExponentiation, {
    	        at: node.argument
    	      });
    	    }
    	  }
    	  parseMaybeUnary(refExpressionErrors, sawUnary) {
    	    const startLoc = this.state.startLoc;
    	    const isAwait = this.isContextual(96);
    	    if (isAwait && this.isAwaitAllowed()) {
    	      this.next();
    	      const expr = this.parseAwait(startLoc);
    	      if (!sawUnary) this.checkExponentialAfterUnary(expr);
    	      return expr;
    	    }
    	    const update = this.match(34);
    	    const node = this.startNode();
    	    if (tokenIsPrefix(this.state.type)) {
    	      node.operator = this.state.value;
    	      node.prefix = true;
    	      if (this.match(72)) {
    	        this.expectPlugin("throwExpressions");
    	      }
    	      const isDelete = this.match(89);
    	      this.next();
    	      node.argument = this.parseMaybeUnary(null, true);
    	      this.checkExpressionErrors(refExpressionErrors, true);
    	      if (this.state.strict && isDelete) {
    	        const arg = node.argument;
    	        if (arg.type === "Identifier") {
    	          this.raise(Errors.StrictDelete, {
    	            at: node
    	          });
    	        } else if (this.hasPropertyAsPrivateName(arg)) {
    	          this.raise(Errors.DeletePrivateField, {
    	            at: node
    	          });
    	        }
    	      }
    	      if (!update) {
    	        if (!sawUnary) {
    	          this.checkExponentialAfterUnary(node);
    	        }
    	        return this.finishNode(node, "UnaryExpression");
    	      }
    	    }
    	    const expr = this.parseUpdate(node, update, refExpressionErrors);
    	    if (isAwait) {
    	      const {
    	        type
    	      } = this.state;
    	      const startsExpr = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
    	      if (startsExpr && !this.isAmbiguousAwait()) {
    	        this.raiseOverwrite(Errors.AwaitNotInAsyncContext, {
    	          at: startLoc
    	        });
    	        return this.parseAwait(startLoc);
    	      }
    	    }
    	    return expr;
    	  }
    	  parseUpdate(node, update, refExpressionErrors) {
    	    if (update) {
    	      const updateExpressionNode = node;
    	      this.checkLVal(updateExpressionNode.argument, {
    	        in: this.finishNode(updateExpressionNode, "UpdateExpression")
    	      });
    	      return node;
    	    }
    	    const startLoc = this.state.startLoc;
    	    let expr = this.parseExprSubscripts(refExpressionErrors);
    	    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;
    	    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
    	      const node = this.startNodeAt(startLoc);
    	      node.operator = this.state.value;
    	      node.prefix = false;
    	      node.argument = expr;
    	      this.next();
    	      this.checkLVal(expr, {
    	        in: expr = this.finishNode(node, "UpdateExpression")
    	      });
    	    }
    	    return expr;
    	  }
    	  parseExprSubscripts(refExpressionErrors) {
    	    const startLoc = this.state.startLoc;
    	    const potentialArrowAt = this.state.potentialArrowAt;
    	    const expr = this.parseExprAtom(refExpressionErrors);
    	    if (this.shouldExitDescending(expr, potentialArrowAt)) {
    	      return expr;
    	    }
    	    return this.parseSubscripts(expr, startLoc);
    	  }
    	  parseSubscripts(base, startLoc, noCalls) {
    	    const state = {
    	      optionalChainMember: false,
    	      maybeAsyncArrow: this.atPossibleAsyncArrow(base),
    	      stop: false
    	    };
    	    do {
    	      base = this.parseSubscript(base, startLoc, noCalls, state);
    	      state.maybeAsyncArrow = false;
    	    } while (!state.stop);
    	    return base;
    	  }
    	  parseSubscript(base, startLoc, noCalls, state) {
    	    const {
    	      type
    	    } = this.state;
    	    if (!noCalls && type === 15) {
    	      return this.parseBind(base, startLoc, noCalls, state);
    	    } else if (tokenIsTemplate(type)) {
    	      return this.parseTaggedTemplateExpression(base, startLoc, state);
    	    }
    	    let optional = false;
    	    if (type === 18) {
    	      if (noCalls) {
    	        this.raise(Errors.OptionalChainingNoNew, {
    	          at: this.state.startLoc
    	        });
    	        if (this.lookaheadCharCode() === 40) {
    	          state.stop = true;
    	          return base;
    	        }
    	      }
    	      state.optionalChainMember = optional = true;
    	      this.next();
    	    }
    	    if (!noCalls && this.match(10)) {
    	      return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
    	    } else {
    	      const computed = this.eat(0);
    	      if (computed || optional || this.eat(16)) {
    	        return this.parseMember(base, startLoc, state, computed, optional);
    	      } else {
    	        state.stop = true;
    	        return base;
    	      }
    	    }
    	  }
    	  parseMember(base, startLoc, state, computed, optional) {
    	    const node = this.startNodeAt(startLoc);
    	    node.object = base;
    	    node.computed = computed;
    	    if (computed) {
    	      node.property = this.parseExpression();
    	      this.expect(3);
    	    } else if (this.match(138)) {
    	      if (base.type === "Super") {
    	        this.raise(Errors.SuperPrivateField, {
    	          at: startLoc
    	        });
    	      }
    	      this.classScope.usePrivateName(this.state.value, this.state.startLoc);
    	      node.property = this.parsePrivateName();
    	    } else {
    	      node.property = this.parseIdentifier(true);
    	    }
    	    if (state.optionalChainMember) {
    	      node.optional = optional;
    	      return this.finishNode(node, "OptionalMemberExpression");
    	    } else {
    	      return this.finishNode(node, "MemberExpression");
    	    }
    	  }
    	  parseBind(base, startLoc, noCalls, state) {
    	    const node = this.startNodeAt(startLoc);
    	    node.object = base;
    	    this.next();
    	    node.callee = this.parseNoCallExpr();
    	    state.stop = true;
    	    return this.parseSubscripts(this.finishNode(node, "BindExpression"), startLoc, noCalls);
    	  }
    	  parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
    	    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
    	    let refExpressionErrors = null;
    	    this.state.maybeInArrowParameters = true;
    	    this.next();
    	    const node = this.startNodeAt(startLoc);
    	    node.callee = base;
    	    const {
    	      maybeAsyncArrow,
    	      optionalChainMember
    	    } = state;
    	    if (maybeAsyncArrow) {
    	      this.expressionScope.enter(newAsyncArrowScope());
    	      refExpressionErrors = new ExpressionErrors();
    	    }
    	    if (optionalChainMember) {
    	      node.optional = optional;
    	    }
    	    if (optional) {
    	      node.arguments = this.parseCallExpressionArguments(11);
    	    } else {
    	      node.arguments = this.parseCallExpressionArguments(11, base.type === "Import", base.type !== "Super", node, refExpressionErrors);
    	    }
    	    let finishedNode = this.finishCallExpression(node, optionalChainMember);
    	    if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
    	      state.stop = true;
    	      this.checkDestructuringPrivate(refExpressionErrors);
    	      this.expressionScope.validateAsPattern();
    	      this.expressionScope.exit();
    	      finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
    	    } else {
    	      if (maybeAsyncArrow) {
    	        this.checkExpressionErrors(refExpressionErrors, true);
    	        this.expressionScope.exit();
    	      }
    	      this.toReferencedArguments(finishedNode);
    	    }
    	    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
    	    return finishedNode;
    	  }
    	  toReferencedArguments(node, isParenthesizedExpr) {
    	    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
    	  }
    	  parseTaggedTemplateExpression(base, startLoc, state) {
    	    const node = this.startNodeAt(startLoc);
    	    node.tag = base;
    	    node.quasi = this.parseTemplate(true);
    	    if (state.optionalChainMember) {
    	      this.raise(Errors.OptionalChainingNoTemplate, {
    	        at: startLoc
    	      });
    	    }
    	    return this.finishNode(node, "TaggedTemplateExpression");
    	  }
    	  atPossibleAsyncArrow(base) {
    	    return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
    	  }
    	  expectImportAttributesPlugin() {
    	    if (!this.hasPlugin("importAssertions")) {
    	      this.expectPlugin("importAttributes");
    	    }
    	  }
    	  finishCallExpression(node, optional) {
    	    if (node.callee.type === "Import") {
    	      if (node.arguments.length === 2) {
    	        {
    	          if (!this.hasPlugin("moduleAttributes")) {
    	            this.expectImportAttributesPlugin();
    	          }
    	        }
    	      }
    	      if (node.arguments.length === 0 || node.arguments.length > 2) {
    	        this.raise(Errors.ImportCallArity, {
    	          at: node,
    	          maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
    	        });
    	      } else {
    	        for (const arg of node.arguments) {
    	          if (arg.type === "SpreadElement") {
    	            this.raise(Errors.ImportCallSpreadArgument, {
    	              at: arg
    	            });
    	          }
    	        }
    	      }
    	    }
    	    return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
    	  }
    	  parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
    	    const elts = [];
    	    let first = true;
    	    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
    	    this.state.inFSharpPipelineDirectBody = false;
    	    while (!this.eat(close)) {
    	      if (first) {
    	        first = false;
    	      } else {
    	        this.expect(12);
    	        if (this.match(close)) {
    	          if (dynamicImport && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
    	            this.raise(Errors.ImportCallArgumentTrailingComma, {
    	              at: this.state.lastTokStartLoc
    	            });
    	          }
    	          if (nodeForExtra) {
    	            this.addTrailingCommaExtraToNode(nodeForExtra);
    	          }
    	          this.next();
    	          break;
    	        }
    	      }
    	      elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
    	    }
    	    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
    	    return elts;
    	  }
    	  shouldParseAsyncArrow() {
    	    return this.match(19) && !this.canInsertSemicolon();
    	  }
    	  parseAsyncArrowFromCallExpression(node, call) {
    	    var _call$extra;
    	    this.resetPreviousNodeTrailingComments(call);
    	    this.expect(19);
    	    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
    	    if (call.innerComments) {
    	      setInnerComments(node, call.innerComments);
    	    }
    	    if (call.callee.trailingComments) {
    	      setInnerComments(node, call.callee.trailingComments);
    	    }
    	    return node;
    	  }
    	  parseNoCallExpr() {
    	    const startLoc = this.state.startLoc;
    	    return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
    	  }
    	  parseExprAtom(refExpressionErrors) {
    	    let node;
    	    let decorators = null;
    	    const {
    	      type
    	    } = this.state;
    	    switch (type) {
    	      case 79:
    	        return this.parseSuper();
    	      case 83:
    	        node = this.startNode();
    	        this.next();
    	        if (this.match(16)) {
    	          return this.parseImportMetaProperty(node);
    	        }
    	        if (this.match(10)) {
    	          if (this.options.createImportExpressions) {
    	            return this.parseImportCall(node);
    	          } else {
    	            return this.finishNode(node, "Import");
    	          }
    	        } else {
    	          this.raise(Errors.UnsupportedImport, {
    	            at: this.state.lastTokStartLoc
    	          });
    	          return this.finishNode(node, "Import");
    	        }
    	      case 78:
    	        node = this.startNode();
    	        this.next();
    	        return this.finishNode(node, "ThisExpression");
    	      case 90:
    	        {
    	          return this.parseDo(this.startNode(), false);
    	        }
    	      case 56:
    	      case 31:
    	        {
    	          this.readRegexp();
    	          return this.parseRegExpLiteral(this.state.value);
    	        }
    	      case 134:
    	        return this.parseNumericLiteral(this.state.value);
    	      case 135:
    	        return this.parseBigIntLiteral(this.state.value);
    	      case 136:
    	        return this.parseDecimalLiteral(this.state.value);
    	      case 133:
    	        return this.parseStringLiteral(this.state.value);
    	      case 84:
    	        return this.parseNullLiteral();
    	      case 85:
    	        return this.parseBooleanLiteral(true);
    	      case 86:
    	        return this.parseBooleanLiteral(false);
    	      case 10:
    	        {
    	          const canBeArrow = this.state.potentialArrowAt === this.state.start;
    	          return this.parseParenAndDistinguishExpression(canBeArrow);
    	        }
    	      case 2:
    	      case 1:
    	        {
    	          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
    	        }
    	      case 0:
    	        {
    	          return this.parseArrayLike(3, true, false, refExpressionErrors);
    	        }
    	      case 6:
    	      case 7:
    	        {
    	          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
    	        }
    	      case 5:
    	        {
    	          return this.parseObjectLike(8, false, false, refExpressionErrors);
    	        }
    	      case 68:
    	        return this.parseFunctionOrFunctionSent();
    	      case 26:
    	        decorators = this.parseDecorators();
    	      case 80:
    	        return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
    	      case 77:
    	        return this.parseNewOrNewTarget();
    	      case 25:
    	      case 24:
    	        return this.parseTemplate(false);
    	      case 15:
    	        {
    	          node = this.startNode();
    	          this.next();
    	          node.object = null;
    	          const callee = node.callee = this.parseNoCallExpr();
    	          if (callee.type === "MemberExpression") {
    	            return this.finishNode(node, "BindExpression");
    	          } else {
    	            throw this.raise(Errors.UnsupportedBind, {
    	              at: callee
    	            });
    	          }
    	        }
    	      case 138:
    	        {
    	          this.raise(Errors.PrivateInExpectedIn, {
    	            at: this.state.startLoc,
    	            identifierName: this.state.value
    	          });
    	          return this.parsePrivateName();
    	        }
    	      case 33:
    	        {
    	          return this.parseTopicReferenceThenEqualsSign(54, "%");
    	        }
    	      case 32:
    	        {
    	          return this.parseTopicReferenceThenEqualsSign(44, "^");
    	        }
    	      case 37:
    	      case 38:
    	        {
    	          return this.parseTopicReference("hack");
    	        }
    	      case 44:
    	      case 54:
    	      case 27:
    	        {
    	          const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
    	          if (pipeProposal) {
    	            return this.parseTopicReference(pipeProposal);
    	          }
    	          this.unexpected();
    	          break;
    	        }
    	      case 47:
    	        {
    	          const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
    	          if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
    	            this.expectOnePlugin(["jsx", "flow", "typescript"]);
    	          } else {
    	            this.unexpected();
    	          }
    	          break;
    	        }
    	      default:
    	        if (tokenIsIdentifier(type)) {
    	          if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {
    	            return this.parseModuleExpression();
    	          }
    	          const canBeArrow = this.state.potentialArrowAt === this.state.start;
    	          const containsEsc = this.state.containsEsc;
    	          const id = this.parseIdentifier();
    	          if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
    	            const {
    	              type
    	            } = this.state;
    	            if (type === 68) {
    	              this.resetPreviousNodeTrailingComments(id);
    	              this.next();
    	              return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
    	            } else if (tokenIsIdentifier(type)) {
    	              if (this.lookaheadCharCode() === 61) {
    	                return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
    	              } else {
    	                return id;
    	              }
    	            } else if (type === 90) {
    	              this.resetPreviousNodeTrailingComments(id);
    	              return this.parseDo(this.startNodeAtNode(id), true);
    	            }
    	          }
    	          if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
    	            this.next();
    	            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
    	          }
    	          return id;
    	        } else {
    	          this.unexpected();
    	        }
    	    }
    	  }
    	  parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
    	    const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
    	    if (pipeProposal) {
    	      this.state.type = topicTokenType;
    	      this.state.value = topicTokenValue;
    	      this.state.pos--;
    	      this.state.end--;
    	      this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
    	      return this.parseTopicReference(pipeProposal);
    	    } else {
    	      this.unexpected();
    	    }
    	  }
    	  parseTopicReference(pipeProposal) {
    	    const node = this.startNode();
    	    const startLoc = this.state.startLoc;
    	    const tokenType = this.state.type;
    	    this.next();
    	    return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
    	  }
    	  finishTopicReference(node, startLoc, pipeProposal, tokenType) {
    	    if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
    	      const nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
    	      if (!this.topicReferenceIsAllowedInCurrentContext()) {
    	        this.raise(pipeProposal === "smart" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, {
    	          at: startLoc
    	        });
    	      }
    	      this.registerTopicReference();
    	      return this.finishNode(node, nodeType);
    	    } else {
    	      throw this.raise(Errors.PipeTopicUnconfiguredToken, {
    	        at: startLoc,
    	        token: tokenLabelName(tokenType)
    	      });
    	    }
    	  }
    	  testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
    	    switch (pipeProposal) {
    	      case "hack":
    	        {
    	          return this.hasPlugin(["pipelineOperator", {
    	            topicToken: tokenLabelName(tokenType)
    	          }]);
    	        }
    	      case "smart":
    	        return tokenType === 27;
    	      default:
    	        throw this.raise(Errors.PipeTopicRequiresHackPipes, {
    	          at: startLoc
    	        });
    	    }
    	  }
    	  parseAsyncArrowUnaryFunction(node) {
    	    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
    	    const params = [this.parseIdentifier()];
    	    this.prodParam.exit();
    	    if (this.hasPrecedingLineBreak()) {
    	      this.raise(Errors.LineTerminatorBeforeArrow, {
    	        at: this.state.curPosition()
    	      });
    	    }
    	    this.expect(19);
    	    return this.parseArrowExpression(node, params, true);
    	  }
    	  parseDo(node, isAsync) {
    	    this.expectPlugin("doExpressions");
    	    if (isAsync) {
    	      this.expectPlugin("asyncDoExpressions");
    	    }
    	    node.async = isAsync;
    	    this.next();
    	    const oldLabels = this.state.labels;
    	    this.state.labels = [];
    	    if (isAsync) {
    	      this.prodParam.enter(PARAM_AWAIT);
    	      node.body = this.parseBlock();
    	      this.prodParam.exit();
    	    } else {
    	      node.body = this.parseBlock();
    	    }
    	    this.state.labels = oldLabels;
    	    return this.finishNode(node, "DoExpression");
    	  }
    	  parseSuper() {
    	    const node = this.startNode();
    	    this.next();
    	    if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
    	      this.raise(Errors.SuperNotAllowed, {
    	        at: node
    	      });
    	    } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
    	      this.raise(Errors.UnexpectedSuper, {
    	        at: node
    	      });
    	    }
    	    if (!this.match(10) && !this.match(0) && !this.match(16)) {
    	      this.raise(Errors.UnsupportedSuper, {
    	        at: node
    	      });
    	    }
    	    return this.finishNode(node, "Super");
    	  }
    	  parsePrivateName() {
    	    const node = this.startNode();
    	    const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
    	    const name = this.state.value;
    	    this.next();
    	    node.id = this.createIdentifier(id, name);
    	    return this.finishNode(node, "PrivateName");
    	  }
    	  parseFunctionOrFunctionSent() {
    	    const node = this.startNode();
    	    this.next();
    	    if (this.prodParam.hasYield && this.match(16)) {
    	      const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
    	      this.next();
    	      if (this.match(103)) {
    	        this.expectPlugin("functionSent");
    	      } else if (!this.hasPlugin("functionSent")) {
    	        this.unexpected();
    	      }
    	      return this.parseMetaProperty(node, meta, "sent");
    	    }
    	    return this.parseFunction(node);
    	  }
    	  parseMetaProperty(node, meta, propertyName) {
    	    node.meta = meta;
    	    const containsEsc = this.state.containsEsc;
    	    node.property = this.parseIdentifier(true);
    	    if (node.property.name !== propertyName || containsEsc) {
    	      this.raise(Errors.UnsupportedMetaProperty, {
    	        at: node.property,
    	        target: meta.name,
    	        onlyValidPropertyName: propertyName
    	      });
    	    }
    	    return this.finishNode(node, "MetaProperty");
    	  }
    	  parseImportMetaProperty(node) {
    	    const id = this.createIdentifier(this.startNodeAtNode(node), "import");
    	    this.next();
    	    if (this.isContextual(101)) {
    	      if (!this.inModule) {
    	        this.raise(Errors.ImportMetaOutsideModule, {
    	          at: id
    	        });
    	      }
    	      this.sawUnambiguousESM = true;
    	    } else if (this.isContextual(105) || this.isContextual(97)) {
    	      const isSource = this.isContextual(105);
    	      if (!isSource) this.unexpected();
    	      this.expectPlugin(isSource ? "sourcePhaseImports" : "deferredImportEvaluation");
    	      if (!this.options.createImportExpressions) {
    	        throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions, {
    	          at: this.state.startLoc,
    	          phase: this.state.value
    	        });
    	      }
    	      this.next();
    	      node.phase = isSource ? "source" : "defer";
    	      return this.parseImportCall(node);
    	    }
    	    return this.parseMetaProperty(node, id, "meta");
    	  }
    	  parseLiteralAtNode(value, type, node) {
    	    this.addExtra(node, "rawValue", value);
    	    this.addExtra(node, "raw", this.input.slice(node.start, this.state.end));
    	    node.value = value;
    	    this.next();
    	    return this.finishNode(node, type);
    	  }
    	  parseLiteral(value, type) {
    	    const node = this.startNode();
    	    return this.parseLiteralAtNode(value, type, node);
    	  }
    	  parseStringLiteral(value) {
    	    return this.parseLiteral(value, "StringLiteral");
    	  }
    	  parseNumericLiteral(value) {
    	    return this.parseLiteral(value, "NumericLiteral");
    	  }
    	  parseBigIntLiteral(value) {
    	    return this.parseLiteral(value, "BigIntLiteral");
    	  }
    	  parseDecimalLiteral(value) {
    	    return this.parseLiteral(value, "DecimalLiteral");
    	  }
    	  parseRegExpLiteral(value) {
    	    const node = this.parseLiteral(value.value, "RegExpLiteral");
    	    node.pattern = value.pattern;
    	    node.flags = value.flags;
    	    return node;
    	  }
    	  parseBooleanLiteral(value) {
    	    const node = this.startNode();
    	    node.value = value;
    	    this.next();
    	    return this.finishNode(node, "BooleanLiteral");
    	  }
    	  parseNullLiteral() {
    	    const node = this.startNode();
    	    this.next();
    	    return this.finishNode(node, "NullLiteral");
    	  }
    	  parseParenAndDistinguishExpression(canBeArrow) {
    	    const startLoc = this.state.startLoc;
    	    let val;
    	    this.next();
    	    this.expressionScope.enter(newArrowHeadScope());
    	    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
    	    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
    	    this.state.maybeInArrowParameters = true;
    	    this.state.inFSharpPipelineDirectBody = false;
    	    const innerStartLoc = this.state.startLoc;
    	    const exprList = [];
    	    const refExpressionErrors = new ExpressionErrors();
    	    let first = true;
    	    let spreadStartLoc;
    	    let optionalCommaStartLoc;
    	    while (!this.match(11)) {
    	      if (first) {
    	        first = false;
    	      } else {
    	        this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
    	        if (this.match(11)) {
    	          optionalCommaStartLoc = this.state.startLoc;
    	          break;
    	        }
    	      }
    	      if (this.match(21)) {
    	        const spreadNodeStartLoc = this.state.startLoc;
    	        spreadStartLoc = this.state.startLoc;
    	        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));
    	        if (!this.checkCommaAfterRest(41)) {
    	          break;
    	        }
    	      } else {
    	        exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
    	      }
    	    }
    	    const innerEndLoc = this.state.lastTokEndLoc;
    	    this.expect(11);
    	    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
    	    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
    	    let arrowNode = this.startNodeAt(startLoc);
    	    if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
    	      this.checkDestructuringPrivate(refExpressionErrors);
    	      this.expressionScope.validateAsPattern();
    	      this.expressionScope.exit();
    	      this.parseArrowExpression(arrowNode, exprList, false);
    	      return arrowNode;
    	    }
    	    this.expressionScope.exit();
    	    if (!exprList.length) {
    	      this.unexpected(this.state.lastTokStartLoc);
    	    }
    	    if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);
    	    if (spreadStartLoc) this.unexpected(spreadStartLoc);
    	    this.checkExpressionErrors(refExpressionErrors, true);
    	    this.toReferencedListDeep(exprList, true);
    	    if (exprList.length > 1) {
    	      val = this.startNodeAt(innerStartLoc);
    	      val.expressions = exprList;
    	      this.finishNode(val, "SequenceExpression");
    	      this.resetEndLocation(val, innerEndLoc);
    	    } else {
    	      val = exprList[0];
    	    }
    	    return this.wrapParenthesis(startLoc, val);
    	  }
    	  wrapParenthesis(startLoc, expression) {
    	    if (!this.options.createParenthesizedExpressions) {
    	      this.addExtra(expression, "parenthesized", true);
    	      this.addExtra(expression, "parenStart", startLoc.index);
    	      this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);
    	      return expression;
    	    }
    	    const parenExpression = this.startNodeAt(startLoc);
    	    parenExpression.expression = expression;
    	    return this.finishNode(parenExpression, "ParenthesizedExpression");
    	  }
    	  shouldParseArrow(params) {
    	    return !this.canInsertSemicolon();
    	  }
    	  parseArrow(node) {
    	    if (this.eat(19)) {
    	      return node;
    	    }
    	  }
    	  parseParenItem(node, startLoc) {
    	    return node;
    	  }
    	  parseNewOrNewTarget() {
    	    const node = this.startNode();
    	    this.next();
    	    if (this.match(16)) {
    	      const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
    	      this.next();
    	      const metaProp = this.parseMetaProperty(node, meta, "target");
    	      if (!this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction) {
    	        this.raise(Errors.UnexpectedNewTarget, {
    	          at: metaProp
    	        });
    	      }
    	      return metaProp;
    	    }
    	    return this.parseNew(node);
    	  }
    	  parseNew(node) {
    	    this.parseNewCallee(node);
    	    if (this.eat(10)) {
    	      const args = this.parseExprList(11);
    	      this.toReferencedList(args);
    	      node.arguments = args;
    	    } else {
    	      node.arguments = [];
    	    }
    	    return this.finishNode(node, "NewExpression");
    	  }
    	  parseNewCallee(node) {
    	    const isImport = this.match(83);
    	    const callee = this.parseNoCallExpr();
    	    node.callee = callee;
    	    if (isImport && (callee.type === "Import" || callee.type === "ImportExpression")) {
    	      this.raise(Errors.ImportCallNotNewExpression, {
    	        at: callee
    	      });
    	    }
    	  }
    	  parseTemplateElement(isTagged) {
    	    const {
    	      start,
    	      startLoc,
    	      end,
    	      value
    	    } = this.state;
    	    const elemStart = start + 1;
    	    const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
    	    if (value === null) {
    	      if (!isTagged) {
    	        this.raise(Errors.InvalidEscapeSequenceTemplate, {
    	          at: createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1)
    	        });
    	      }
    	    }
    	    const isTail = this.match(24);
    	    const endOffset = isTail ? -1 : -2;
    	    const elemEnd = end + endOffset;
    	    elem.value = {
    	      raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
    	      cooked: value === null ? null : value.slice(1, endOffset)
    	    };
    	    elem.tail = isTail;
    	    this.next();
    	    const finishedNode = this.finishNode(elem, "TemplateElement");
    	    this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
    	    return finishedNode;
    	  }
    	  parseTemplate(isTagged) {
    	    const node = this.startNode();
    	    node.expressions = [];
    	    let curElt = this.parseTemplateElement(isTagged);
    	    node.quasis = [curElt];
    	    while (!curElt.tail) {
    	      node.expressions.push(this.parseTemplateSubstitution());
    	      this.readTemplateContinuation();
    	      node.quasis.push(curElt = this.parseTemplateElement(isTagged));
    	    }
    	    return this.finishNode(node, "TemplateLiteral");
    	  }
    	  parseTemplateSubstitution() {
    	    return this.parseExpression();
    	  }
    	  parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
    	    if (isRecord) {
    	      this.expectPlugin("recordAndTuple");
    	    }
    	    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
    	    this.state.inFSharpPipelineDirectBody = false;
    	    const propHash = Object.create(null);
    	    let first = true;
    	    const node = this.startNode();
    	    node.properties = [];
    	    this.next();
    	    while (!this.match(close)) {
    	      if (first) {
    	        first = false;
    	      } else {
    	        this.expect(12);
    	        if (this.match(close)) {
    	          this.addTrailingCommaExtraToNode(node);
    	          break;
    	        }
    	      }
    	      let prop;
    	      if (isPattern) {
    	        prop = this.parseBindingProperty();
    	      } else {
    	        prop = this.parsePropertyDefinition(refExpressionErrors);
    	        this.checkProto(prop, isRecord, propHash, refExpressionErrors);
    	      }
    	      if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
    	        this.raise(Errors.InvalidRecordProperty, {
    	          at: prop
    	        });
    	      }
    	      if (prop.shorthand) {
    	        this.addExtra(prop, "shorthand", true);
    	      }
    	      node.properties.push(prop);
    	    }
    	    this.next();
    	    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
    	    let type = "ObjectExpression";
    	    if (isPattern) {
    	      type = "ObjectPattern";
    	    } else if (isRecord) {
    	      type = "RecordExpression";
    	    }
    	    return this.finishNode(node, type);
    	  }
    	  addTrailingCommaExtraToNode(node) {
    	    this.addExtra(node, "trailingComma", this.state.lastTokStart);
    	    this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
    	  }
    	  maybeAsyncOrAccessorProp(prop) {
    	    return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    	  }
    	  parsePropertyDefinition(refExpressionErrors) {
    	    let decorators = [];
    	    if (this.match(26)) {
    	      if (this.hasPlugin("decorators")) {
    	        this.raise(Errors.UnsupportedPropertyDecorator, {
    	          at: this.state.startLoc
    	        });
    	      }
    	      while (this.match(26)) {
    	        decorators.push(this.parseDecorator());
    	      }
    	    }
    	    const prop = this.startNode();
    	    let isAsync = false;
    	    let isAccessor = false;
    	    let startLoc;
    	    if (this.match(21)) {
    	      if (decorators.length) this.unexpected();
    	      return this.parseSpread();
    	    }
    	    if (decorators.length) {
    	      prop.decorators = decorators;
    	      decorators = [];
    	    }
    	    prop.method = false;
    	    if (refExpressionErrors) {
    	      startLoc = this.state.startLoc;
    	    }
    	    let isGenerator = this.eat(55);
    	    this.parsePropertyNamePrefixOperator(prop);
    	    const containsEsc = this.state.containsEsc;
    	    const key = this.parsePropertyName(prop, refExpressionErrors);
    	    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
    	      const keyName = key.name;
    	      if (keyName === "async" && !this.hasPrecedingLineBreak()) {
    	        isAsync = true;
    	        this.resetPreviousNodeTrailingComments(key);
    	        isGenerator = this.eat(55);
    	        this.parsePropertyName(prop);
    	      }
    	      if (keyName === "get" || keyName === "set") {
    	        isAccessor = true;
    	        this.resetPreviousNodeTrailingComments(key);
    	        prop.kind = keyName;
    	        if (this.match(55)) {
    	          isGenerator = true;
    	          this.raise(Errors.AccessorIsGenerator, {
    	            at: this.state.curPosition(),
    	            kind: keyName
    	          });
    	          this.next();
    	        }
    	        this.parsePropertyName(prop);
    	      }
    	    }
    	    return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
    	  }
    	  getGetterSetterExpectedParamCount(method) {
    	    return method.kind === "get" ? 0 : 1;
    	  }
    	  getObjectOrClassMethodParams(method) {
    	    return method.params;
    	  }
    	  checkGetterSetterParams(method) {
    	    var _params;
    	    const paramCount = this.getGetterSetterExpectedParamCount(method);
    	    const params = this.getObjectOrClassMethodParams(method);
    	    if (params.length !== paramCount) {
    	      this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
    	        at: method
    	      });
    	    }
    	    if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
    	      this.raise(Errors.BadSetterRestParameter, {
    	        at: method
    	      });
    	    }
    	  }
    	  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
    	    if (isAccessor) {
    	      const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
    	      this.checkGetterSetterParams(finishedProp);
    	      return finishedProp;
    	    }
    	    if (isAsync || isGenerator || this.match(10)) {
    	      if (isPattern) this.unexpected();
    	      prop.kind = "method";
    	      prop.method = true;
    	      return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
    	    }
    	  }
    	  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
    	    prop.shorthand = false;
    	    if (this.eat(14)) {
    	      prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
    	      return this.finishNode(prop, "ObjectProperty");
    	    }
    	    if (!prop.computed && prop.key.type === "Identifier") {
    	      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
    	      if (isPattern) {
    	        prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
    	      } else if (this.match(29)) {
    	        const shorthandAssignLoc = this.state.startLoc;
    	        if (refExpressionErrors != null) {
    	          if (refExpressionErrors.shorthandAssignLoc === null) {
    	            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
    	          }
    	        } else {
    	          this.raise(Errors.InvalidCoverInitializedName, {
    	            at: shorthandAssignLoc
    	          });
    	        }
    	        prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
    	      } else {
    	        prop.value = cloneIdentifier(prop.key);
    	      }
    	      prop.shorthand = true;
    	      return this.finishNode(prop, "ObjectProperty");
    	    }
    	  }
    	  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
    	    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
    	    if (!node) this.unexpected();
    	    return node;
    	  }
    	  parsePropertyName(prop, refExpressionErrors) {
    	    if (this.eat(0)) {
    	      prop.computed = true;
    	      prop.key = this.parseMaybeAssignAllowIn();
    	      this.expect(3);
    	    } else {
    	      const {
    	        type,
    	        value
    	      } = this.state;
    	      let key;
    	      if (tokenIsKeywordOrIdentifier(type)) {
    	        key = this.parseIdentifier(true);
    	      } else {
    	        switch (type) {
    	          case 134:
    	            key = this.parseNumericLiteral(value);
    	            break;
    	          case 133:
    	            key = this.parseStringLiteral(value);
    	            break;
    	          case 135:
    	            key = this.parseBigIntLiteral(value);
    	            break;
    	          case 136:
    	            key = this.parseDecimalLiteral(value);
    	            break;
    	          case 138:
    	            {
    	              const privateKeyLoc = this.state.startLoc;
    	              if (refExpressionErrors != null) {
    	                if (refExpressionErrors.privateKeyLoc === null) {
    	                  refExpressionErrors.privateKeyLoc = privateKeyLoc;
    	                }
    	              } else {
    	                this.raise(Errors.UnexpectedPrivateField, {
    	                  at: privateKeyLoc
    	                });
    	              }
    	              key = this.parsePrivateName();
    	              break;
    	            }
    	          default:
    	            this.unexpected();
    	        }
    	      }
    	      prop.key = key;
    	      if (type !== 138) {
    	        prop.computed = false;
    	      }
    	    }
    	    return prop.key;
    	  }
    	  initFunction(node, isAsync) {
    	    node.id = null;
    	    node.generator = false;
    	    node.async = isAsync;
    	  }
    	  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
    	    this.initFunction(node, isAsync);
    	    node.generator = isGenerator;
    	    this.scope.enter(2 | 16 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0));
    	    this.prodParam.enter(functionFlags(isAsync, node.generator));
    	    this.parseFunctionParams(node, isConstructor);
    	    const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
    	    this.prodParam.exit();
    	    this.scope.exit();
    	    return finishedNode;
    	  }
    	  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
    	    if (isTuple) {
    	      this.expectPlugin("recordAndTuple");
    	    }
    	    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
    	    this.state.inFSharpPipelineDirectBody = false;
    	    const node = this.startNode();
    	    this.next();
    	    node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
    	    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
    	    return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
    	  }
    	  parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
    	    this.scope.enter(2 | 4);
    	    let flags = functionFlags(isAsync, false);
    	    if (!this.match(5) && this.prodParam.hasIn) {
    	      flags |= PARAM_IN;
    	    }
    	    this.prodParam.enter(flags);
    	    this.initFunction(node, isAsync);
    	    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
    	    if (params) {
    	      this.state.maybeInArrowParameters = true;
    	      this.setArrowFunctionParameters(node, params, trailingCommaLoc);
    	    }
    	    this.state.maybeInArrowParameters = false;
    	    this.parseFunctionBody(node, true);
    	    this.prodParam.exit();
    	    this.scope.exit();
    	    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
    	    return this.finishNode(node, "ArrowFunctionExpression");
    	  }
    	  setArrowFunctionParameters(node, params, trailingCommaLoc) {
    	    this.toAssignableList(params, trailingCommaLoc, false);
    	    node.params = params;
    	  }
    	  parseFunctionBodyAndFinish(node, type, isMethod = false) {
    	    this.parseFunctionBody(node, false, isMethod);
    	    return this.finishNode(node, type);
    	  }
    	  parseFunctionBody(node, allowExpression, isMethod = false) {
    	    const isExpression = allowExpression && !this.match(5);
    	    this.expressionScope.enter(newExpressionScope());
    	    if (isExpression) {
    	      node.body = this.parseMaybeAssign();
    	      this.checkParams(node, false, allowExpression, false);
    	    } else {
    	      const oldStrict = this.state.strict;
    	      const oldLabels = this.state.labels;
    	      this.state.labels = [];
    	      this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
    	      node.body = this.parseBlock(true, false, hasStrictModeDirective => {
    	        const nonSimple = !this.isSimpleParamList(node.params);
    	        if (hasStrictModeDirective && nonSimple) {
    	          this.raise(Errors.IllegalLanguageModeDirective, {
    	            at: (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.loc.end : node
    	          });
    	        }
    	        const strictModeChanged = !oldStrict && this.state.strict;
    	        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
    	        if (this.state.strict && node.id) {
    	          this.checkIdentifier(node.id, 65, strictModeChanged);
    	        }
    	      });
    	      this.prodParam.exit();
    	      this.state.labels = oldLabels;
    	    }
    	    this.expressionScope.exit();
    	  }
    	  isSimpleParameter(node) {
    	    return node.type === "Identifier";
    	  }
    	  isSimpleParamList(params) {
    	    for (let i = 0, len = params.length; i < len; i++) {
    	      if (!this.isSimpleParameter(params[i])) return false;
    	    }
    	    return true;
    	  }
    	  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
    	    const checkClashes = !allowDuplicates && new Set();
    	    const formalParameters = {
    	      type: "FormalParameters"
    	    };
    	    for (const param of node.params) {
    	      this.checkLVal(param, {
    	        in: formalParameters,
    	        binding: 5,
    	        checkClashes,
    	        strictModeChanged
    	      });
    	    }
    	  }
    	  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
    	    const elts = [];
    	    let first = true;
    	    while (!this.eat(close)) {
    	      if (first) {
    	        first = false;
    	      } else {
    	        this.expect(12);
    	        if (this.match(close)) {
    	          if (nodeForExtra) {
    	            this.addTrailingCommaExtraToNode(nodeForExtra);
    	          }
    	          this.next();
    	          break;
    	        }
    	      }
    	      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
    	    }
    	    return elts;
    	  }
    	  parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
    	    let elt;
    	    if (this.match(12)) {
    	      if (!allowEmpty) {
    	        this.raise(Errors.UnexpectedToken, {
    	          at: this.state.curPosition(),
    	          unexpected: ","
    	        });
    	      }
    	      elt = null;
    	    } else if (this.match(21)) {
    	      const spreadNodeStartLoc = this.state.startLoc;
    	      elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
    	    } else if (this.match(17)) {
    	      this.expectPlugin("partialApplication");
    	      if (!allowPlaceholder) {
    	        this.raise(Errors.UnexpectedArgumentPlaceholder, {
    	          at: this.state.startLoc
    	        });
    	      }
    	      const node = this.startNode();
    	      this.next();
    	      elt = this.finishNode(node, "ArgumentPlaceholder");
    	    } else {
    	      elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
    	    }
    	    return elt;
    	  }
    	  parseIdentifier(liberal) {
    	    const node = this.startNode();
    	    const name = this.parseIdentifierName(liberal);
    	    return this.createIdentifier(node, name);
    	  }
    	  createIdentifier(node, name) {
    	    node.name = name;
    	    node.loc.identifierName = name;
    	    return this.finishNode(node, "Identifier");
    	  }
    	  parseIdentifierName(liberal) {
    	    let name;
    	    const {
    	      startLoc,
    	      type
    	    } = this.state;
    	    if (tokenIsKeywordOrIdentifier(type)) {
    	      name = this.state.value;
    	    } else {
    	      this.unexpected();
    	    }
    	    const tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type);
    	    if (liberal) {
    	      if (tokenIsKeyword) {
    	        this.replaceToken(132);
    	      }
    	    } else {
    	      this.checkReservedWord(name, startLoc, tokenIsKeyword, false);
    	    }
    	    this.next();
    	    return name;
    	  }
    	  checkReservedWord(word, startLoc, checkKeywords, isBinding) {
    	    if (word.length > 10) {
    	      return;
    	    }
    	    if (!canBeReservedWord(word)) {
    	      return;
    	    }
    	    if (checkKeywords && isKeyword(word)) {
    	      this.raise(Errors.UnexpectedKeyword, {
    	        at: startLoc,
    	        keyword: word
    	      });
    	      return;
    	    }
    	    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
    	    if (reservedTest(word, this.inModule)) {
    	      this.raise(Errors.UnexpectedReservedWord, {
    	        at: startLoc,
    	        reservedWord: word
    	      });
    	      return;
    	    } else if (word === "yield") {
    	      if (this.prodParam.hasYield) {
    	        this.raise(Errors.YieldBindingIdentifier, {
    	          at: startLoc
    	        });
    	        return;
    	      }
    	    } else if (word === "await") {
    	      if (this.prodParam.hasAwait) {
    	        this.raise(Errors.AwaitBindingIdentifier, {
    	          at: startLoc
    	        });
    	        return;
    	      }
    	      if (this.scope.inStaticBlock) {
    	        this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {
    	          at: startLoc
    	        });
    	        return;
    	      }
    	      this.expressionScope.recordAsyncArrowParametersError({
    	        at: startLoc
    	      });
    	    } else if (word === "arguments") {
    	      if (this.scope.inClassAndNotInNonArrowFunction) {
    	        this.raise(Errors.ArgumentsInClass, {
    	          at: startLoc
    	        });
    	        return;
    	      }
    	    }
    	  }
    	  isAwaitAllowed() {
    	    if (this.prodParam.hasAwait) return true;
    	    if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
    	      return true;
    	    }
    	    return false;
    	  }
    	  parseAwait(startLoc) {
    	    const node = this.startNodeAt(startLoc);
    	    this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, {
    	      at: node
    	    });
    	    if (this.eat(55)) {
    	      this.raise(Errors.ObsoleteAwaitStar, {
    	        at: node
    	      });
    	    }
    	    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
    	      if (this.isAmbiguousAwait()) {
    	        this.ambiguousScriptDifferentAst = true;
    	      } else {
    	        this.sawUnambiguousESM = true;
    	      }
    	    }
    	    if (!this.state.soloAwait) {
    	      node.argument = this.parseMaybeUnary(null, true);
    	    }
    	    return this.finishNode(node, "AwaitExpression");
    	  }
    	  isAmbiguousAwait() {
    	    if (this.hasPrecedingLineBreak()) return true;
    	    const {
    	      type
    	    } = this.state;
    	    return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 137 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
    	  }
    	  parseYield() {
    	    const node = this.startNode();
    	    this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, {
    	      at: node
    	    });
    	    this.next();
    	    let delegating = false;
    	    let argument = null;
    	    if (!this.hasPrecedingLineBreak()) {
    	      delegating = this.eat(55);
    	      switch (this.state.type) {
    	        case 13:
    	        case 139:
    	        case 8:
    	        case 11:
    	        case 3:
    	        case 9:
    	        case 14:
    	        case 12:
    	          if (!delegating) break;
    	        default:
    	          argument = this.parseMaybeAssign();
    	      }
    	    }
    	    node.delegate = delegating;
    	    node.argument = argument;
    	    return this.finishNode(node, "YieldExpression");
    	  }
    	  parseImportCall(node) {
    	    this.next();
    	    node.source = this.parseMaybeAssignAllowIn();
    	    if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
    	      node.options = null;
    	    }
    	    if (this.eat(12)) {
    	      this.expectImportAttributesPlugin();
    	      if (!this.match(11)) {
    	        node.options = this.parseMaybeAssignAllowIn();
    	        this.eat(12);
    	      }
    	    }
    	    this.expect(11);
    	    return this.finishNode(node, "ImportExpression");
    	  }
    	  checkPipelineAtInfixOperator(left, leftStartLoc) {
    	    if (this.hasPlugin(["pipelineOperator", {
    	      proposal: "smart"
    	    }])) {
    	      if (left.type === "SequenceExpression") {
    	        this.raise(Errors.PipelineHeadSequenceExpression, {
    	          at: leftStartLoc
    	        });
    	      }
    	    }
    	  }
    	  parseSmartPipelineBodyInStyle(childExpr, startLoc) {
    	    if (this.isSimpleReference(childExpr)) {
    	      const bodyNode = this.startNodeAt(startLoc);
    	      bodyNode.callee = childExpr;
    	      return this.finishNode(bodyNode, "PipelineBareFunction");
    	    } else {
    	      const bodyNode = this.startNodeAt(startLoc);
    	      this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
    	      bodyNode.expression = childExpr;
    	      return this.finishNode(bodyNode, "PipelineTopicExpression");
    	    }
    	  }
    	  isSimpleReference(expression) {
    	    switch (expression.type) {
    	      case "MemberExpression":
    	        return !expression.computed && this.isSimpleReference(expression.object);
    	      case "Identifier":
    	        return true;
    	      default:
    	        return false;
    	    }
    	  }
    	  checkSmartPipeTopicBodyEarlyErrors(startLoc) {
    	    if (this.match(19)) {
    	      throw this.raise(Errors.PipelineBodyNoArrow, {
    	        at: this.state.startLoc
    	      });
    	    }
    	    if (!this.topicReferenceWasUsedInCurrentContext()) {
    	      this.raise(Errors.PipelineTopicUnused, {
    	        at: startLoc
    	      });
    	    }
    	  }
    	  withTopicBindingContext(callback) {
    	    const outerContextTopicState = this.state.topicContext;
    	    this.state.topicContext = {
    	      maxNumOfResolvableTopics: 1,
    	      maxTopicIndex: null
    	    };
    	    try {
    	      return callback();
    	    } finally {
    	      this.state.topicContext = outerContextTopicState;
    	    }
    	  }
    	  withSmartMixTopicForbiddingContext(callback) {
    	    if (this.hasPlugin(["pipelineOperator", {
    	      proposal: "smart"
    	    }])) {
    	      const outerContextTopicState = this.state.topicContext;
    	      this.state.topicContext = {
    	        maxNumOfResolvableTopics: 0,
    	        maxTopicIndex: null
    	      };
    	      try {
    	        return callback();
    	      } finally {
    	        this.state.topicContext = outerContextTopicState;
    	      }
    	    } else {
    	      return callback();
    	    }
    	  }
    	  withSoloAwaitPermittingContext(callback) {
    	    const outerContextSoloAwaitState = this.state.soloAwait;
    	    this.state.soloAwait = true;
    	    try {
    	      return callback();
    	    } finally {
    	      this.state.soloAwait = outerContextSoloAwaitState;
    	    }
    	  }
    	  allowInAnd(callback) {
    	    const flags = this.prodParam.currentFlags();
    	    const prodParamToSet = PARAM_IN & ~flags;
    	    if (prodParamToSet) {
    	      this.prodParam.enter(flags | PARAM_IN);
    	      try {
    	        return callback();
    	      } finally {
    	        this.prodParam.exit();
    	      }
    	    }
    	    return callback();
    	  }
    	  disallowInAnd(callback) {
    	    const flags = this.prodParam.currentFlags();
    	    const prodParamToClear = PARAM_IN & flags;
    	    if (prodParamToClear) {
    	      this.prodParam.enter(flags & ~PARAM_IN);
    	      try {
    	        return callback();
    	      } finally {
    	        this.prodParam.exit();
    	      }
    	    }
    	    return callback();
    	  }
    	  registerTopicReference() {
    	    this.state.topicContext.maxTopicIndex = 0;
    	  }
    	  topicReferenceIsAllowedInCurrentContext() {
    	    return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    	  }
    	  topicReferenceWasUsedInCurrentContext() {
    	    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    	  }
    	  parseFSharpPipelineBody(prec) {
    	    const startLoc = this.state.startLoc;
    	    this.state.potentialArrowAt = this.state.start;
    	    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
    	    this.state.inFSharpPipelineDirectBody = true;
    	    const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
    	    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
    	    return ret;
    	  }
    	  parseModuleExpression() {
    	    this.expectPlugin("moduleBlocks");
    	    const node = this.startNode();
    	    this.next();
    	    if (!this.match(5)) {
    	      this.unexpected(null, 5);
    	    }
    	    const program = this.startNodeAt(this.state.endLoc);
    	    this.next();
    	    const revertScopes = this.initializeScopes(true);
    	    this.enterInitialScopes();
    	    try {
    	      node.body = this.parseProgram(program, 8, "module");
    	    } finally {
    	      revertScopes();
    	    }
    	    return this.finishNode(node, "ModuleExpression");
    	  }
    	  parsePropertyNamePrefixOperator(prop) {}
    	}
    	const loopLabel = {
    	    kind: "loop"
    	  },
    	  switchLabel = {
    	    kind: "switch"
    	  };
    	const loneSurrogate = /[\uD800-\uDFFF]/u;
    	const keywordRelationalOperator = /in(?:stanceof)?/y;
    	function babel7CompatTokens(tokens, input) {
    	  for (let i = 0; i < tokens.length; i++) {
    	    const token = tokens[i];
    	    const {
    	      type
    	    } = token;
    	    if (typeof type === "number") {
    	      {
    	        if (type === 138) {
    	          const {
    	            loc,
    	            start,
    	            value,
    	            end
    	          } = token;
    	          const hashEndPos = start + 1;
    	          const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
    	          tokens.splice(i, 1, new Token({
    	            type: getExportedToken(27),
    	            value: "#",
    	            start: start,
    	            end: hashEndPos,
    	            startLoc: loc.start,
    	            endLoc: hashEndLoc
    	          }), new Token({
    	            type: getExportedToken(132),
    	            value: value,
    	            start: hashEndPos,
    	            end: end,
    	            startLoc: hashEndLoc,
    	            endLoc: loc.end
    	          }));
    	          i++;
    	          continue;
    	        }
    	        if (tokenIsTemplate(type)) {
    	          const {
    	            loc,
    	            start,
    	            value,
    	            end
    	          } = token;
    	          const backquoteEnd = start + 1;
    	          const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
    	          let startToken;
    	          if (input.charCodeAt(start) === 96) {
    	            startToken = new Token({
    	              type: getExportedToken(22),
    	              value: "`",
    	              start: start,
    	              end: backquoteEnd,
    	              startLoc: loc.start,
    	              endLoc: backquoteEndLoc
    	            });
    	          } else {
    	            startToken = new Token({
    	              type: getExportedToken(8),
    	              value: "}",
    	              start: start,
    	              end: backquoteEnd,
    	              startLoc: loc.start,
    	              endLoc: backquoteEndLoc
    	            });
    	          }
    	          let templateValue, templateElementEnd, templateElementEndLoc, endToken;
    	          if (type === 24) {
    	            templateElementEnd = end - 1;
    	            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
    	            templateValue = value === null ? null : value.slice(1, -1);
    	            endToken = new Token({
    	              type: getExportedToken(22),
    	              value: "`",
    	              start: templateElementEnd,
    	              end: end,
    	              startLoc: templateElementEndLoc,
    	              endLoc: loc.end
    	            });
    	          } else {
    	            templateElementEnd = end - 2;
    	            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
    	            templateValue = value === null ? null : value.slice(1, -2);
    	            endToken = new Token({
    	              type: getExportedToken(23),
    	              value: "${",
    	              start: templateElementEnd,
    	              end: end,
    	              startLoc: templateElementEndLoc,
    	              endLoc: loc.end
    	            });
    	          }
    	          tokens.splice(i, 1, startToken, new Token({
    	            type: getExportedToken(20),
    	            value: templateValue,
    	            start: backquoteEnd,
    	            end: templateElementEnd,
    	            startLoc: backquoteEndLoc,
    	            endLoc: templateElementEndLoc
    	          }), endToken);
    	          i += 2;
    	          continue;
    	        }
    	      }
    	      token.type = getExportedToken(type);
    	    }
    	  }
    	  return tokens;
    	}
    	class StatementParser extends ExpressionParser {
    	  parseTopLevel(file, program) {
    	    file.program = this.parseProgram(program);
    	    file.comments = this.state.comments;
    	    if (this.options.tokens) {
    	      file.tokens = babel7CompatTokens(this.tokens, this.input);
    	    }
    	    return this.finishNode(file, "File");
    	  }
    	  parseProgram(program, end = 139, sourceType = this.options.sourceType) {
    	    program.sourceType = sourceType;
    	    program.interpreter = this.parseInterpreterDirective();
    	    this.parseBlockBody(program, true, true, end);
    	    if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
    	      for (const [localName, at] of Array.from(this.scope.undefinedExports)) {
    	        this.raise(Errors.ModuleExportUndefined, {
    	          at,
    	          localName
    	        });
    	      }
    	    }
    	    let finishedProgram;
    	    if (end === 139) {
    	      finishedProgram = this.finishNode(program, "Program");
    	    } else {
    	      finishedProgram = this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
    	    }
    	    return finishedProgram;
    	  }
    	  stmtToDirective(stmt) {
    	    const directive = stmt;
    	    directive.type = "Directive";
    	    directive.value = directive.expression;
    	    delete directive.expression;
    	    const directiveLiteral = directive.value;
    	    const expressionValue = directiveLiteral.value;
    	    const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);
    	    const val = directiveLiteral.value = raw.slice(1, -1);
    	    this.addExtra(directiveLiteral, "raw", raw);
    	    this.addExtra(directiveLiteral, "rawValue", val);
    	    this.addExtra(directiveLiteral, "expressionValue", expressionValue);
    	    directiveLiteral.type = "DirectiveLiteral";
    	    return directive;
    	  }
    	  parseInterpreterDirective() {
    	    if (!this.match(28)) {
    	      return null;
    	    }
    	    const node = this.startNode();
    	    node.value = this.state.value;
    	    this.next();
    	    return this.finishNode(node, "InterpreterDirective");
    	  }
    	  isLet() {
    	    if (!this.isContextual(100)) {
    	      return false;
    	    }
    	    return this.hasFollowingBindingAtom();
    	  }
    	  chStartsBindingIdentifier(ch, pos) {
    	    if (isIdentifierStart(ch)) {
    	      keywordRelationalOperator.lastIndex = pos;
    	      if (keywordRelationalOperator.test(this.input)) {
    	        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
    	        if (!isIdentifierChar(endCh) && endCh !== 92) {
    	          return false;
    	        }
    	      }
    	      return true;
    	    } else if (ch === 92) {
    	      return true;
    	    } else {
    	      return false;
    	    }
    	  }
    	  chStartsBindingPattern(ch) {
    	    return ch === 91 || ch === 123;
    	  }
    	  hasFollowingBindingAtom() {
    	    const next = this.nextTokenStart();
    	    const nextCh = this.codePointAtPos(next);
    	    return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
    	  }
    	  hasInLineFollowingBindingIdentifier() {
    	    const next = this.nextTokenInLineStart();
    	    const nextCh = this.codePointAtPos(next);
    	    return this.chStartsBindingIdentifier(nextCh, next);
    	  }
    	  startsUsingForOf() {
    	    const {
    	      type,
    	      containsEsc
    	    } = this.lookahead();
    	    if (type === 102 && !containsEsc) {
    	      return false;
    	    } else if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {
    	      this.expectPlugin("explicitResourceManagement");
    	      return true;
    	    }
    	  }
    	  startsAwaitUsing() {
    	    let next = this.nextTokenInLineStart();
    	    if (this.isUnparsedContextual(next, "using")) {
    	      next = this.nextTokenInLineStartSince(next + 5);
    	      const nextCh = this.codePointAtPos(next);
    	      if (this.chStartsBindingIdentifier(nextCh, next)) {
    	        this.expectPlugin("explicitResourceManagement");
    	        return true;
    	      }
    	    }
    	    return false;
    	  }
    	  parseModuleItem() {
    	    return this.parseStatementLike(1 | 2 | 4 | 8);
    	  }
    	  parseStatementListItem() {
    	    return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));
    	  }
    	  parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {
    	    let flags = 0;
    	    if (this.options.annexB && !this.state.strict) {
    	      flags |= 4;
    	      if (allowLabeledFunction) {
    	        flags |= 8;
    	      }
    	    }
    	    return this.parseStatementLike(flags);
    	  }
    	  parseStatement() {
    	    return this.parseStatementLike(0);
    	  }
    	  parseStatementLike(flags) {
    	    let decorators = null;
    	    if (this.match(26)) {
    	      decorators = this.parseDecorators(true);
    	    }
    	    return this.parseStatementContent(flags, decorators);
    	  }
    	  parseStatementContent(flags, decorators) {
    	    const starttype = this.state.type;
    	    const node = this.startNode();
    	    const allowDeclaration = !!(flags & 2);
    	    const allowFunctionDeclaration = !!(flags & 4);
    	    const topLevel = flags & 1;
    	    switch (starttype) {
    	      case 60:
    	        return this.parseBreakContinueStatement(node, true);
    	      case 63:
    	        return this.parseBreakContinueStatement(node, false);
    	      case 64:
    	        return this.parseDebuggerStatement(node);
    	      case 90:
    	        return this.parseDoWhileStatement(node);
    	      case 91:
    	        return this.parseForStatement(node);
    	      case 68:
    	        if (this.lookaheadCharCode() === 46) break;
    	        if (!allowFunctionDeclaration) {
    	          this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, {
    	            at: this.state.startLoc
    	          });
    	        }
    	        return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);
    	      case 80:
    	        if (!allowDeclaration) this.unexpected();
    	        return this.parseClass(this.maybeTakeDecorators(decorators, node), true);
    	      case 69:
    	        return this.parseIfStatement(node);
    	      case 70:
    	        return this.parseReturnStatement(node);
    	      case 71:
    	        return this.parseSwitchStatement(node);
    	      case 72:
    	        return this.parseThrowStatement(node);
    	      case 73:
    	        return this.parseTryStatement(node);
    	      case 96:
    	        if (!this.state.containsEsc && this.startsAwaitUsing()) {
    	          if (!this.isAwaitAllowed()) {
    	            this.raise(Errors.AwaitUsingNotInAsyncContext, {
    	              at: node
    	            });
    	          } else if (!allowDeclaration) {
    	            this.raise(Errors.UnexpectedLexicalDeclaration, {
    	              at: node
    	            });
    	          }
    	          this.next();
    	          return this.parseVarStatement(node, "await using");
    	        }
    	        break;
    	      case 107:
    	        if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier()) {
    	          break;
    	        }
    	        this.expectPlugin("explicitResourceManagement");
    	        if (!this.scope.inModule && this.scope.inTopLevel) {
    	          this.raise(Errors.UnexpectedUsingDeclaration, {
    	            at: this.state.startLoc
    	          });
    	        } else if (!allowDeclaration) {
    	          this.raise(Errors.UnexpectedLexicalDeclaration, {
    	            at: this.state.startLoc
    	          });
    	        }
    	        return this.parseVarStatement(node, "using");
    	      case 100:
    	        {
    	          if (this.state.containsEsc) {
    	            break;
    	          }
    	          const next = this.nextTokenStart();
    	          const nextCh = this.codePointAtPos(next);
    	          if (nextCh !== 91) {
    	            if (!allowDeclaration && this.hasFollowingLineBreak()) break;
    	            if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {
    	              break;
    	            }
    	          }
    	        }
    	      case 75:
    	        {
    	          if (!allowDeclaration) {
    	            this.raise(Errors.UnexpectedLexicalDeclaration, {
    	              at: this.state.startLoc
    	            });
    	          }
    	        }
    	      case 74:
    	        {
    	          const kind = this.state.value;
    	          return this.parseVarStatement(node, kind);
    	        }
    	      case 92:
    	        return this.parseWhileStatement(node);
    	      case 76:
    	        return this.parseWithStatement(node);
    	      case 5:
    	        return this.parseBlock();
    	      case 13:
    	        return this.parseEmptyStatement(node);
    	      case 83:
    	        {
    	          const nextTokenCharCode = this.lookaheadCharCode();
    	          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
    	            break;
    	          }
    	        }
    	      case 82:
    	        {
    	          if (!this.options.allowImportExportEverywhere && !topLevel) {
    	            this.raise(Errors.UnexpectedImportExport, {
    	              at: this.state.startLoc
    	            });
    	          }
    	          this.next();
    	          let result;
    	          if (starttype === 83) {
    	            result = this.parseImport(node);
    	            if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
    	              this.sawUnambiguousESM = true;
    	            }
    	          } else {
    	            result = this.parseExport(node, decorators);
    	            if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
    	              this.sawUnambiguousESM = true;
    	            }
    	          }
    	          this.assertModuleNodeAllowed(result);
    	          return result;
    	        }
    	      default:
    	        {
    	          if (this.isAsyncFunction()) {
    	            if (!allowDeclaration) {
    	              this.raise(Errors.AsyncFunctionInSingleStatementContext, {
    	                at: this.state.startLoc
    	              });
    	            }
    	            this.next();
    	            return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);
    	          }
    	        }
    	    }
    	    const maybeName = this.state.value;
    	    const expr = this.parseExpression();
    	    if (tokenIsIdentifier(starttype) && expr.type === "Identifier" && this.eat(14)) {
    	      return this.parseLabeledStatement(node, maybeName, expr, flags);
    	    } else {
    	      return this.parseExpressionStatement(node, expr, decorators);
    	    }
    	  }
    	  assertModuleNodeAllowed(node) {
    	    if (!this.options.allowImportExportEverywhere && !this.inModule) {
    	      this.raise(Errors.ImportOutsideModule, {
    	        at: node
    	      });
    	    }
    	  }
    	  decoratorsEnabledBeforeExport() {
    	    if (this.hasPlugin("decorators-legacy")) return true;
    	    return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
    	  }
    	  maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
    	    if (maybeDecorators) {
    	      if (classNode.decorators && classNode.decorators.length > 0) {
    	        if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") {
    	          this.raise(Errors.DecoratorsBeforeAfterExport, {
    	            at: classNode.decorators[0]
    	          });
    	        }
    	        classNode.decorators.unshift(...maybeDecorators);
    	      } else {
    	        classNode.decorators = maybeDecorators;
    	      }
    	      this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
    	      if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);
    	    }
    	    return classNode;
    	  }
    	  canHaveLeadingDecorator() {
    	    return this.match(80);
    	  }
    	  parseDecorators(allowExport) {
    	    const decorators = [];
    	    do {
    	      decorators.push(this.parseDecorator());
    	    } while (this.match(26));
    	    if (this.match(82)) {
    	      if (!allowExport) {
    	        this.unexpected();
    	      }
    	      if (!this.decoratorsEnabledBeforeExport()) {
    	        this.raise(Errors.DecoratorExportClass, {
    	          at: this.state.startLoc
    	        });
    	      }
    	    } else if (!this.canHaveLeadingDecorator()) {
    	      throw this.raise(Errors.UnexpectedLeadingDecorator, {
    	        at: this.state.startLoc
    	      });
    	    }
    	    return decorators;
    	  }
    	  parseDecorator() {
    	    this.expectOnePlugin(["decorators", "decorators-legacy"]);
    	    const node = this.startNode();
    	    this.next();
    	    if (this.hasPlugin("decorators")) {
    	      const startLoc = this.state.startLoc;
    	      let expr;
    	      if (this.match(10)) {
    	        const startLoc = this.state.startLoc;
    	        this.next();
    	        expr = this.parseExpression();
    	        this.expect(11);
    	        expr = this.wrapParenthesis(startLoc, expr);
    	        const paramsStartLoc = this.state.startLoc;
    	        node.expression = this.parseMaybeDecoratorArguments(expr);
    	        if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node.expression !== expr) {
    	          this.raise(Errors.DecoratorArgumentsOutsideParentheses, {
    	            at: paramsStartLoc
    	          });
    	        }
    	      } else {
    	        expr = this.parseIdentifier(false);
    	        while (this.eat(16)) {
    	          const node = this.startNodeAt(startLoc);
    	          node.object = expr;
    	          if (this.match(138)) {
    	            this.classScope.usePrivateName(this.state.value, this.state.startLoc);
    	            node.property = this.parsePrivateName();
    	          } else {
    	            node.property = this.parseIdentifier(true);
    	          }
    	          node.computed = false;
    	          expr = this.finishNode(node, "MemberExpression");
    	        }
    	        node.expression = this.parseMaybeDecoratorArguments(expr);
    	      }
    	    } else {
    	      node.expression = this.parseExprSubscripts();
    	    }
    	    return this.finishNode(node, "Decorator");
    	  }
    	  parseMaybeDecoratorArguments(expr) {
    	    if (this.eat(10)) {
    	      const node = this.startNodeAtNode(expr);
    	      node.callee = expr;
    	      node.arguments = this.parseCallExpressionArguments(11, false);
    	      this.toReferencedList(node.arguments);
    	      return this.finishNode(node, "CallExpression");
    	    }
    	    return expr;
    	  }
    	  parseBreakContinueStatement(node, isBreak) {
    	    this.next();
    	    if (this.isLineTerminator()) {
    	      node.label = null;
    	    } else {
    	      node.label = this.parseIdentifier();
    	      this.semicolon();
    	    }
    	    this.verifyBreakContinue(node, isBreak);
    	    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    	  }
    	  verifyBreakContinue(node, isBreak) {
    	    let i;
    	    for (i = 0; i < this.state.labels.length; ++i) {
    	      const lab = this.state.labels[i];
    	      if (node.label == null || lab.name === node.label.name) {
    	        if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
    	        if (node.label && isBreak) break;
    	      }
    	    }
    	    if (i === this.state.labels.length) {
    	      const type = isBreak ? "BreakStatement" : "ContinueStatement";
    	      this.raise(Errors.IllegalBreakContinue, {
    	        at: node,
    	        type
    	      });
    	    }
    	  }
    	  parseDebuggerStatement(node) {
    	    this.next();
    	    this.semicolon();
    	    return this.finishNode(node, "DebuggerStatement");
    	  }
    	  parseHeaderExpression() {
    	    this.expect(10);
    	    const val = this.parseExpression();
    	    this.expect(11);
    	    return val;
    	  }
    	  parseDoWhileStatement(node) {
    	    this.next();
    	    this.state.labels.push(loopLabel);
    	    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
    	    this.state.labels.pop();
    	    this.expect(92);
    	    node.test = this.parseHeaderExpression();
    	    this.eat(13);
    	    return this.finishNode(node, "DoWhileStatement");
    	  }
    	  parseForStatement(node) {
    	    this.next();
    	    this.state.labels.push(loopLabel);
    	    let awaitAt = null;
    	    if (this.isAwaitAllowed() && this.eatContextual(96)) {
    	      awaitAt = this.state.lastTokStartLoc;
    	    }
    	    this.scope.enter(0);
    	    this.expect(10);
    	    if (this.match(13)) {
    	      if (awaitAt !== null) {
    	        this.unexpected(awaitAt);
    	      }
    	      return this.parseFor(node, null);
    	    }
    	    const startsWithLet = this.isContextual(100);
    	    {
    	      const startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing();
    	      const starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(107) && this.startsUsingForOf();
    	      const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
    	      if (this.match(74) || this.match(75) || isLetOrUsing) {
    	        const initNode = this.startNode();
    	        let kind;
    	        if (startsWithAwaitUsing) {
    	          kind = "await using";
    	          if (!this.isAwaitAllowed()) {
    	            this.raise(Errors.AwaitUsingNotInAsyncContext, {
    	              at: this.state.startLoc
    	            });
    	          }
    	          this.next();
    	        } else {
    	          kind = this.state.value;
    	        }
    	        this.next();
    	        this.parseVar(initNode, true, kind);
    	        const init = this.finishNode(initNode, "VariableDeclaration");
    	        const isForIn = this.match(58);
    	        if (isForIn && starsWithUsingDeclaration) {
    	          this.raise(Errors.ForInUsing, {
    	            at: init
    	          });
    	        }
    	        if ((isForIn || this.isContextual(102)) && init.declarations.length === 1) {
    	          return this.parseForIn(node, init, awaitAt);
    	        }
    	        if (awaitAt !== null) {
    	          this.unexpected(awaitAt);
    	        }
    	        return this.parseFor(node, init);
    	      }
    	    }
    	    const startsWithAsync = this.isContextual(95);
    	    const refExpressionErrors = new ExpressionErrors();
    	    const init = this.parseExpression(true, refExpressionErrors);
    	    const isForOf = this.isContextual(102);
    	    if (isForOf) {
    	      if (startsWithLet) {
    	        this.raise(Errors.ForOfLet, {
    	          at: init
    	        });
    	      }
    	      if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
    	        this.raise(Errors.ForOfAsync, {
    	          at: init
    	        });
    	      }
    	    }
    	    if (isForOf || this.match(58)) {
    	      this.checkDestructuringPrivate(refExpressionErrors);
    	      this.toAssignable(init, true);
    	      const type = isForOf ? "ForOfStatement" : "ForInStatement";
    	      this.checkLVal(init, {
    	        in: {
    	          type
    	        }
    	      });
    	      return this.parseForIn(node, init, awaitAt);
    	    } else {
    	      this.checkExpressionErrors(refExpressionErrors, true);
    	    }
    	    if (awaitAt !== null) {
    	      this.unexpected(awaitAt);
    	    }
    	    return this.parseFor(node, init);
    	  }
    	  parseFunctionStatement(node, isAsync, isHangingDeclaration) {
    	    this.next();
    	    return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
    	  }
    	  parseIfStatement(node) {
    	    this.next();
    	    node.test = this.parseHeaderExpression();
    	    node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
    	    node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
    	    return this.finishNode(node, "IfStatement");
    	  }
    	  parseReturnStatement(node) {
    	    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
    	      this.raise(Errors.IllegalReturn, {
    	        at: this.state.startLoc
    	      });
    	    }
    	    this.next();
    	    if (this.isLineTerminator()) {
    	      node.argument = null;
    	    } else {
    	      node.argument = this.parseExpression();
    	      this.semicolon();
    	    }
    	    return this.finishNode(node, "ReturnStatement");
    	  }
    	  parseSwitchStatement(node) {
    	    this.next();
    	    node.discriminant = this.parseHeaderExpression();
    	    const cases = node.cases = [];
    	    this.expect(5);
    	    this.state.labels.push(switchLabel);
    	    this.scope.enter(0);
    	    let cur;
    	    for (let sawDefault; !this.match(8);) {
    	      if (this.match(61) || this.match(65)) {
    	        const isCase = this.match(61);
    	        if (cur) this.finishNode(cur, "SwitchCase");
    	        cases.push(cur = this.startNode());
    	        cur.consequent = [];
    	        this.next();
    	        if (isCase) {
    	          cur.test = this.parseExpression();
    	        } else {
    	          if (sawDefault) {
    	            this.raise(Errors.MultipleDefaultsInSwitch, {
    	              at: this.state.lastTokStartLoc
    	            });
    	          }
    	          sawDefault = true;
    	          cur.test = null;
    	        }
    	        this.expect(14);
    	      } else {
    	        if (cur) {
    	          cur.consequent.push(this.parseStatementListItem());
    	        } else {
    	          this.unexpected();
    	        }
    	      }
    	    }
    	    this.scope.exit();
    	    if (cur) this.finishNode(cur, "SwitchCase");
    	    this.next();
    	    this.state.labels.pop();
    	    return this.finishNode(node, "SwitchStatement");
    	  }
    	  parseThrowStatement(node) {
    	    this.next();
    	    if (this.hasPrecedingLineBreak()) {
    	      this.raise(Errors.NewlineAfterThrow, {
    	        at: this.state.lastTokEndLoc
    	      });
    	    }
    	    node.argument = this.parseExpression();
    	    this.semicolon();
    	    return this.finishNode(node, "ThrowStatement");
    	  }
    	  parseCatchClauseParam() {
    	    const param = this.parseBindingAtom();
    	    this.scope.enter(this.options.annexB && param.type === "Identifier" ? 8 : 0);
    	    this.checkLVal(param, {
    	      in: {
    	        type: "CatchClause"
    	      },
    	      binding: 9
    	    });
    	    return param;
    	  }
    	  parseTryStatement(node) {
    	    this.next();
    	    node.block = this.parseBlock();
    	    node.handler = null;
    	    if (this.match(62)) {
    	      const clause = this.startNode();
    	      this.next();
    	      if (this.match(10)) {
    	        this.expect(10);
    	        clause.param = this.parseCatchClauseParam();
    	        this.expect(11);
    	      } else {
    	        clause.param = null;
    	        this.scope.enter(0);
    	      }
    	      clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
    	      this.scope.exit();
    	      node.handler = this.finishNode(clause, "CatchClause");
    	    }
    	    node.finalizer = this.eat(67) ? this.parseBlock() : null;
    	    if (!node.handler && !node.finalizer) {
    	      this.raise(Errors.NoCatchOrFinally, {
    	        at: node
    	      });
    	    }
    	    return this.finishNode(node, "TryStatement");
    	  }
    	  parseVarStatement(node, kind, allowMissingInitializer = false) {
    	    this.next();
    	    this.parseVar(node, false, kind, allowMissingInitializer);
    	    this.semicolon();
    	    return this.finishNode(node, "VariableDeclaration");
    	  }
    	  parseWhileStatement(node) {
    	    this.next();
    	    node.test = this.parseHeaderExpression();
    	    this.state.labels.push(loopLabel);
    	    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
    	    this.state.labels.pop();
    	    return this.finishNode(node, "WhileStatement");
    	  }
    	  parseWithStatement(node) {
    	    if (this.state.strict) {
    	      this.raise(Errors.StrictWith, {
    	        at: this.state.startLoc
    	      });
    	    }
    	    this.next();
    	    node.object = this.parseHeaderExpression();
    	    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
    	    return this.finishNode(node, "WithStatement");
    	  }
    	  parseEmptyStatement(node) {
    	    this.next();
    	    return this.finishNode(node, "EmptyStatement");
    	  }
    	  parseLabeledStatement(node, maybeName, expr, flags) {
    	    for (const label of this.state.labels) {
    	      if (label.name === maybeName) {
    	        this.raise(Errors.LabelRedeclaration, {
    	          at: expr,
    	          labelName: maybeName
    	        });
    	      }
    	    }
    	    const kind = tokenIsLoop(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
    	    for (let i = this.state.labels.length - 1; i >= 0; i--) {
    	      const label = this.state.labels[i];
    	      if (label.statementStart === node.start) {
    	        label.statementStart = this.state.start;
    	        label.kind = kind;
    	      } else {
    	        break;
    	      }
    	    }
    	    this.state.labels.push({
    	      name: maybeName,
    	      kind: kind,
    	      statementStart: this.state.start
    	    });
    	    node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
    	    this.state.labels.pop();
    	    node.label = expr;
    	    return this.finishNode(node, "LabeledStatement");
    	  }
    	  parseExpressionStatement(node, expr, decorators) {
    	    node.expression = expr;
    	    this.semicolon();
    	    return this.finishNode(node, "ExpressionStatement");
    	  }
    	  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
    	    const node = this.startNode();
    	    if (allowDirectives) {
    	      this.state.strictErrors.clear();
    	    }
    	    this.expect(5);
    	    if (createNewLexicalScope) {
    	      this.scope.enter(0);
    	    }
    	    this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
    	    if (createNewLexicalScope) {
    	      this.scope.exit();
    	    }
    	    return this.finishNode(node, "BlockStatement");
    	  }
    	  isValidDirective(stmt) {
    	    return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
    	  }
    	  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
    	    const body = node.body = [];
    	    const directives = node.directives = [];
    	    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);
    	  }
    	  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
    	    const oldStrict = this.state.strict;
    	    let hasStrictModeDirective = false;
    	    let parsedNonDirective = false;
    	    while (!this.match(end)) {
    	      const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
    	      if (directives && !parsedNonDirective) {
    	        if (this.isValidDirective(stmt)) {
    	          const directive = this.stmtToDirective(stmt);
    	          directives.push(directive);
    	          if (!hasStrictModeDirective && directive.value.value === "use strict") {
    	            hasStrictModeDirective = true;
    	            this.setStrict(true);
    	          }
    	          continue;
    	        }
    	        parsedNonDirective = true;
    	        this.state.strictErrors.clear();
    	      }
    	      body.push(stmt);
    	    }
    	    afterBlockParse == null ? void 0 : afterBlockParse.call(this, hasStrictModeDirective);
    	    if (!oldStrict) {
    	      this.setStrict(false);
    	    }
    	    this.next();
    	  }
    	  parseFor(node, init) {
    	    node.init = init;
    	    this.semicolon(false);
    	    node.test = this.match(13) ? null : this.parseExpression();
    	    this.semicolon(false);
    	    node.update = this.match(11) ? null : this.parseExpression();
    	    this.expect(11);
    	    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
    	    this.scope.exit();
    	    this.state.labels.pop();
    	    return this.finishNode(node, "ForStatement");
    	  }
    	  parseForIn(node, init, awaitAt) {
    	    const isForIn = this.match(58);
    	    this.next();
    	    if (isForIn) {
    	      if (awaitAt !== null) this.unexpected(awaitAt);
    	    } else {
    	      node.await = awaitAt !== null;
    	    }
    	    if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
    	      this.raise(Errors.ForInOfLoopInitializer, {
    	        at: init,
    	        type: isForIn ? "ForInStatement" : "ForOfStatement"
    	      });
    	    }
    	    if (init.type === "AssignmentPattern") {
    	      this.raise(Errors.InvalidLhs, {
    	        at: init,
    	        ancestor: {
    	          type: "ForStatement"
    	        }
    	      });
    	    }
    	    node.left = init;
    	    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
    	    this.expect(11);
    	    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
    	    this.scope.exit();
    	    this.state.labels.pop();
    	    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
    	  }
    	  parseVar(node, isFor, kind, allowMissingInitializer = false) {
    	    const declarations = node.declarations = [];
    	    node.kind = kind;
    	    for (;;) {
    	      const decl = this.startNode();
    	      this.parseVarId(decl, kind);
    	      decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
    	      if (decl.init === null && !allowMissingInitializer) {
    	        if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(102)))) {
    	          this.raise(Errors.DeclarationMissingInitializer, {
    	            at: this.state.lastTokEndLoc,
    	            kind: "destructuring"
    	          });
    	        } else if (kind === "const" && !(this.match(58) || this.isContextual(102))) {
    	          this.raise(Errors.DeclarationMissingInitializer, {
    	            at: this.state.lastTokEndLoc,
    	            kind: "const"
    	          });
    	        }
    	      }
    	      declarations.push(this.finishNode(decl, "VariableDeclarator"));
    	      if (!this.eat(12)) break;
    	    }
    	    return node;
    	  }
    	  parseVarId(decl, kind) {
    	    const id = this.parseBindingAtom();
    	    this.checkLVal(id, {
    	      in: {
    	        type: "VariableDeclarator"
    	      },
    	      binding: kind === "var" ? 5 : 8201
    	    });
    	    decl.id = id;
    	  }
    	  parseAsyncFunctionExpression(node) {
    	    return this.parseFunction(node, 8);
    	  }
    	  parseFunction(node, flags = 0) {
    	    const hangingDeclaration = flags & 2;
    	    const isDeclaration = !!(flags & 1);
    	    const requireId = isDeclaration && !(flags & 4);
    	    const isAsync = !!(flags & 8);
    	    this.initFunction(node, isAsync);
    	    if (this.match(55)) {
    	      if (hangingDeclaration) {
    	        this.raise(Errors.GeneratorInSingleStatementContext, {
    	          at: this.state.startLoc
    	        });
    	      }
    	      this.next();
    	      node.generator = true;
    	    }
    	    if (isDeclaration) {
    	      node.id = this.parseFunctionId(requireId);
    	    }
    	    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
    	    this.state.maybeInArrowParameters = false;
    	    this.scope.enter(2);
    	    this.prodParam.enter(functionFlags(isAsync, node.generator));
    	    if (!isDeclaration) {
    	      node.id = this.parseFunctionId();
    	    }
    	    this.parseFunctionParams(node, false);
    	    this.withSmartMixTopicForbiddingContext(() => {
    	      this.parseFunctionBodyAndFinish(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
    	    });
    	    this.prodParam.exit();
    	    this.scope.exit();
    	    if (isDeclaration && !hangingDeclaration) {
    	      this.registerFunctionStatementId(node);
    	    }
    	    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
    	    return node;
    	  }
    	  parseFunctionId(requireId) {
    	    return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
    	  }
    	  parseFunctionParams(node, isConstructor) {
    	    this.expect(10);
    	    this.expressionScope.enter(newParameterDeclarationScope());
    	    node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));
    	    this.expressionScope.exit();
    	  }
    	  registerFunctionStatementId(node) {
    	    if (!node.id) return;
    	    this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);
    	  }
    	  parseClass(node, isStatement, optionalId) {
    	    this.next();
    	    const oldStrict = this.state.strict;
    	    this.state.strict = true;
    	    this.parseClassId(node, isStatement, optionalId);
    	    this.parseClassSuper(node);
    	    node.body = this.parseClassBody(!!node.superClass, oldStrict);
    	    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    	  }
    	  isClassProperty() {
    	    return this.match(29) || this.match(13) || this.match(8);
    	  }
    	  isClassMethod() {
    	    return this.match(10);
    	  }
    	  isNonstaticConstructor(method) {
    	    return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
    	  }
    	  parseClassBody(hadSuperClass, oldStrict) {
    	    this.classScope.enter();
    	    const state = {
    	      hadConstructor: false,
    	      hadSuperClass
    	    };
    	    let decorators = [];
    	    const classBody = this.startNode();
    	    classBody.body = [];
    	    this.expect(5);
    	    this.withSmartMixTopicForbiddingContext(() => {
    	      while (!this.match(8)) {
    	        if (this.eat(13)) {
    	          if (decorators.length > 0) {
    	            throw this.raise(Errors.DecoratorSemicolon, {
    	              at: this.state.lastTokEndLoc
    	            });
    	          }
    	          continue;
    	        }
    	        if (this.match(26)) {
    	          decorators.push(this.parseDecorator());
    	          continue;
    	        }
    	        const member = this.startNode();
    	        if (decorators.length) {
    	          member.decorators = decorators;
    	          this.resetStartLocationFromNode(member, decorators[0]);
    	          decorators = [];
    	        }
    	        this.parseClassMember(classBody, member, state);
    	        if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
    	          this.raise(Errors.DecoratorConstructor, {
    	            at: member
    	          });
    	        }
    	      }
    	    });
    	    this.state.strict = oldStrict;
    	    this.next();
    	    if (decorators.length) {
    	      throw this.raise(Errors.TrailingDecorator, {
    	        at: this.state.startLoc
    	      });
    	    }
    	    this.classScope.exit();
    	    return this.finishNode(classBody, "ClassBody");
    	  }
    	  parseClassMemberFromModifier(classBody, member) {
    	    const key = this.parseIdentifier(true);
    	    if (this.isClassMethod()) {
    	      const method = member;
    	      method.kind = "method";
    	      method.computed = false;
    	      method.key = key;
    	      method.static = false;
    	      this.pushClassMethod(classBody, method, false, false, false, false);
    	      return true;
    	    } else if (this.isClassProperty()) {
    	      const prop = member;
    	      prop.computed = false;
    	      prop.key = key;
    	      prop.static = false;
    	      classBody.body.push(this.parseClassProperty(prop));
    	      return true;
    	    }
    	    this.resetPreviousNodeTrailingComments(key);
    	    return false;
    	  }
    	  parseClassMember(classBody, member, state) {
    	    const isStatic = this.isContextual(106);
    	    if (isStatic) {
    	      if (this.parseClassMemberFromModifier(classBody, member)) {
    	        return;
    	      }
    	      if (this.eat(5)) {
    	        this.parseClassStaticBlock(classBody, member);
    	        return;
    	      }
    	    }
    	    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
    	  }
    	  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
    	    const publicMethod = member;
    	    const privateMethod = member;
    	    const publicProp = member;
    	    const privateProp = member;
    	    const accessorProp = member;
    	    const method = publicMethod;
    	    const publicMember = publicMethod;
    	    member.static = isStatic;
    	    this.parsePropertyNamePrefixOperator(member);
    	    if (this.eat(55)) {
    	      method.kind = "method";
    	      const isPrivateName = this.match(138);
    	      this.parseClassElementName(method);
    	      if (isPrivateName) {
    	        this.pushClassPrivateMethod(classBody, privateMethod, true, false);
    	        return;
    	      }
    	      if (this.isNonstaticConstructor(publicMethod)) {
    	        this.raise(Errors.ConstructorIsGenerator, {
    	          at: publicMethod.key
    	        });
    	      }
    	      this.pushClassMethod(classBody, publicMethod, true, false, false, false);
    	      return;
    	    }
    	    const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;
    	    const isPrivate = this.match(138);
    	    const key = this.parseClassElementName(member);
    	    const maybeQuestionTokenStartLoc = this.state.startLoc;
    	    this.parsePostMemberNameModifiers(publicMember);
    	    if (this.isClassMethod()) {
    	      method.kind = "method";
    	      if (isPrivate) {
    	        this.pushClassPrivateMethod(classBody, privateMethod, false, false);
    	        return;
    	      }
    	      const isConstructor = this.isNonstaticConstructor(publicMethod);
    	      let allowsDirectSuper = false;
    	      if (isConstructor) {
    	        publicMethod.kind = "constructor";
    	        if (state.hadConstructor && !this.hasPlugin("typescript")) {
    	          this.raise(Errors.DuplicateConstructor, {
    	            at: key
    	          });
    	        }
    	        if (isConstructor && this.hasPlugin("typescript") && member.override) {
    	          this.raise(Errors.OverrideOnConstructor, {
    	            at: key
    	          });
    	        }
    	        state.hadConstructor = true;
    	        allowsDirectSuper = state.hadSuperClass;
    	      }
    	      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
    	    } else if (this.isClassProperty()) {
    	      if (isPrivate) {
    	        this.pushClassPrivateProperty(classBody, privateProp);
    	      } else {
    	        this.pushClassProperty(classBody, publicProp);
    	      }
    	    } else if (isContextual && key.name === "async" && !this.isLineTerminator()) {
    	      this.resetPreviousNodeTrailingComments(key);
    	      const isGenerator = this.eat(55);
    	      if (publicMember.optional) {
    	        this.unexpected(maybeQuestionTokenStartLoc);
    	      }
    	      method.kind = "method";
    	      const isPrivate = this.match(138);
    	      this.parseClassElementName(method);
    	      this.parsePostMemberNameModifiers(publicMember);
    	      if (isPrivate) {
    	        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
    	      } else {
    	        if (this.isNonstaticConstructor(publicMethod)) {
    	          this.raise(Errors.ConstructorIsAsync, {
    	            at: publicMethod.key
    	          });
    	        }
    	        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
    	      }
    	    } else if (isContextual && (key.name === "get" || key.name === "set") && !(this.match(55) && this.isLineTerminator())) {
    	      this.resetPreviousNodeTrailingComments(key);
    	      method.kind = key.name;
    	      const isPrivate = this.match(138);
    	      this.parseClassElementName(publicMethod);
    	      if (isPrivate) {
    	        this.pushClassPrivateMethod(classBody, privateMethod, false, false);
    	      } else {
    	        if (this.isNonstaticConstructor(publicMethod)) {
    	          this.raise(Errors.ConstructorIsAccessor, {
    	            at: publicMethod.key
    	          });
    	        }
    	        this.pushClassMethod(classBody, publicMethod, false, false, false, false);
    	      }
    	      this.checkGetterSetterParams(publicMethod);
    	    } else if (isContextual && key.name === "accessor" && !this.isLineTerminator()) {
    	      this.expectPlugin("decoratorAutoAccessors");
    	      this.resetPreviousNodeTrailingComments(key);
    	      const isPrivate = this.match(138);
    	      this.parseClassElementName(publicProp);
    	      this.pushClassAccessorProperty(classBody, accessorProp, isPrivate);
    	    } else if (this.isLineTerminator()) {
    	      if (isPrivate) {
    	        this.pushClassPrivateProperty(classBody, privateProp);
    	      } else {
    	        this.pushClassProperty(classBody, publicProp);
    	      }
    	    } else {
    	      this.unexpected();
    	    }
    	  }
    	  parseClassElementName(member) {
    	    const {
    	      type,
    	      value
    	    } = this.state;
    	    if ((type === 132 || type === 133) && member.static && value === "prototype") {
    	      this.raise(Errors.StaticPrototype, {
    	        at: this.state.startLoc
    	      });
    	    }
    	    if (type === 138) {
    	      if (value === "constructor") {
    	        this.raise(Errors.ConstructorClassPrivateField, {
    	          at: this.state.startLoc
    	        });
    	      }
    	      const key = this.parsePrivateName();
    	      member.key = key;
    	      return key;
    	    }
    	    return this.parsePropertyName(member);
    	  }
    	  parseClassStaticBlock(classBody, member) {
    	    var _member$decorators;
    	    this.scope.enter(64 | 128 | 16);
    	    const oldLabels = this.state.labels;
    	    this.state.labels = [];
    	    this.prodParam.enter(PARAM);
    	    const body = member.body = [];
    	    this.parseBlockOrModuleBlockBody(body, undefined, false, 8);
    	    this.prodParam.exit();
    	    this.scope.exit();
    	    this.state.labels = oldLabels;
    	    classBody.body.push(this.finishNode(member, "StaticBlock"));
    	    if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
    	      this.raise(Errors.DecoratorStaticBlock, {
    	        at: member
    	      });
    	    }
    	  }
    	  pushClassProperty(classBody, prop) {
    	    if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
    	      this.raise(Errors.ConstructorClassField, {
    	        at: prop.key
    	      });
    	    }
    	    classBody.body.push(this.parseClassProperty(prop));
    	  }
    	  pushClassPrivateProperty(classBody, prop) {
    	    const node = this.parseClassPrivateProperty(prop);
    	    classBody.body.push(node);
    	    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
    	  }
    	  pushClassAccessorProperty(classBody, prop, isPrivate) {
    	    if (!isPrivate && !prop.computed) {
    	      const key = prop.key;
    	      if (key.name === "constructor" || key.value === "constructor") {
    	        this.raise(Errors.ConstructorClassField, {
    	          at: key
    	        });
    	      }
    	    }
    	    const node = this.parseClassAccessorProperty(prop);
    	    classBody.body.push(node);
    	    if (isPrivate) {
    	      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
    	    }
    	  }
    	  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
    	    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
    	  }
    	  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
    	    const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
    	    classBody.body.push(node);
    	    const kind = node.kind === "get" ? node.static ? 6 : 2 : node.kind === "set" ? node.static ? 5 : 1 : 0;
    	    this.declareClassPrivateMethodInScope(node, kind);
    	  }
    	  declareClassPrivateMethodInScope(node, kind) {
    	    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
    	  }
    	  parsePostMemberNameModifiers(methodOrProp) {}
    	  parseClassPrivateProperty(node) {
    	    this.parseInitializer(node);
    	    this.semicolon();
    	    return this.finishNode(node, "ClassPrivateProperty");
    	  }
    	  parseClassProperty(node) {
    	    this.parseInitializer(node);
    	    this.semicolon();
    	    return this.finishNode(node, "ClassProperty");
    	  }
    	  parseClassAccessorProperty(node) {
    	    this.parseInitializer(node);
    	    this.semicolon();
    	    return this.finishNode(node, "ClassAccessorProperty");
    	  }
    	  parseInitializer(node) {
    	    this.scope.enter(64 | 16);
    	    this.expressionScope.enter(newExpressionScope());
    	    this.prodParam.enter(PARAM);
    	    node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
    	    this.expressionScope.exit();
    	    this.prodParam.exit();
    	    this.scope.exit();
    	  }
    	  parseClassId(node, isStatement, optionalId, bindingType = 8331) {
    	    if (tokenIsIdentifier(this.state.type)) {
    	      node.id = this.parseIdentifier();
    	      if (isStatement) {
    	        this.declareNameFromIdentifier(node.id, bindingType);
    	      }
    	    } else {
    	      if (optionalId || !isStatement) {
    	        node.id = null;
    	      } else {
    	        throw this.raise(Errors.MissingClassName, {
    	          at: this.state.startLoc
    	        });
    	      }
    	    }
    	  }
    	  parseClassSuper(node) {
    	    node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    	  }
    	  parseExport(node, decorators) {
    	    const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);
    	    const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
    	    const parseAfterDefault = !hasDefault || this.eat(12);
    	    const hasStar = parseAfterDefault && this.eatExportStar(node);
    	    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
    	    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
    	    const isFromRequired = hasDefault || hasStar;
    	    if (hasStar && !hasNamespace) {
    	      if (hasDefault) this.unexpected();
    	      if (decorators) {
    	        throw this.raise(Errors.UnsupportedDecoratorExport, {
    	          at: node
    	        });
    	      }
    	      this.parseExportFrom(node, true);
    	      return this.finishNode(node, "ExportAllDeclaration");
    	    }
    	    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
    	    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {
    	      this.unexpected(null, 5);
    	    }
    	    if (hasNamespace && parseAfterNamespace) {
    	      this.unexpected(null, 98);
    	    }
    	    let hasDeclaration;
    	    if (isFromRequired || hasSpecifiers) {
    	      hasDeclaration = false;
    	      if (decorators) {
    	        throw this.raise(Errors.UnsupportedDecoratorExport, {
    	          at: node
    	        });
    	      }
    	      this.parseExportFrom(node, isFromRequired);
    	    } else {
    	      hasDeclaration = this.maybeParseExportDeclaration(node);
    	    }
    	    if (isFromRequired || hasSpecifiers || hasDeclaration) {
    	      var _node2$declaration;
    	      const node2 = node;
    	      this.checkExport(node2, true, false, !!node2.source);
    	      if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === "ClassDeclaration") {
    	        this.maybeTakeDecorators(decorators, node2.declaration, node2);
    	      } else if (decorators) {
    	        throw this.raise(Errors.UnsupportedDecoratorExport, {
    	          at: node
    	        });
    	      }
    	      return this.finishNode(node2, "ExportNamedDeclaration");
    	    }
    	    if (this.eat(65)) {
    	      const node2 = node;
    	      const decl = this.parseExportDefaultExpression();
    	      node2.declaration = decl;
    	      if (decl.type === "ClassDeclaration") {
    	        this.maybeTakeDecorators(decorators, decl, node2);
    	      } else if (decorators) {
    	        throw this.raise(Errors.UnsupportedDecoratorExport, {
    	          at: node
    	        });
    	      }
    	      this.checkExport(node2, true, true);
    	      return this.finishNode(node2, "ExportDefaultDeclaration");
    	    }
    	    this.unexpected(null, 5);
    	  }
    	  eatExportStar(node) {
    	    return this.eat(55);
    	  }
    	  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
    	    if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
    	      this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);
    	      const id = maybeDefaultIdentifier || this.parseIdentifier(true);
    	      const specifier = this.startNodeAtNode(id);
    	      specifier.exported = id;
    	      node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
    	      return true;
    	    }
    	    return false;
    	  }
    	  maybeParseExportNamespaceSpecifier(node) {
    	    if (this.isContextual(93)) {
    	      if (!node.specifiers) node.specifiers = [];
    	      const specifier = this.startNodeAt(this.state.lastTokStartLoc);
    	      this.next();
    	      specifier.exported = this.parseModuleExportName();
    	      node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
    	      return true;
    	    }
    	    return false;
    	  }
    	  maybeParseExportNamedSpecifiers(node) {
    	    if (this.match(5)) {
    	      if (!node.specifiers) node.specifiers = [];
    	      const isTypeExport = node.exportKind === "type";
    	      node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
    	      node.source = null;
    	      node.declaration = null;
    	      if (this.hasPlugin("importAssertions")) {
    	        node.assertions = [];
    	      }
    	      return true;
    	    }
    	    return false;
    	  }
    	  maybeParseExportDeclaration(node) {
    	    if (this.shouldParseExportDeclaration()) {
    	      node.specifiers = [];
    	      node.source = null;
    	      if (this.hasPlugin("importAssertions")) {
    	        node.assertions = [];
    	      }
    	      node.declaration = this.parseExportDeclaration(node);
    	      return true;
    	    }
    	    return false;
    	  }
    	  isAsyncFunction() {
    	    if (!this.isContextual(95)) return false;
    	    const next = this.nextTokenInLineStart();
    	    return this.isUnparsedContextual(next, "function");
    	  }
    	  parseExportDefaultExpression() {
    	    const expr = this.startNode();
    	    if (this.match(68)) {
    	      this.next();
    	      return this.parseFunction(expr, 1 | 4);
    	    } else if (this.isAsyncFunction()) {
    	      this.next();
    	      this.next();
    	      return this.parseFunction(expr, 1 | 4 | 8);
    	    }
    	    if (this.match(80)) {
    	      return this.parseClass(expr, true, true);
    	    }
    	    if (this.match(26)) {
    	      if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
    	        this.raise(Errors.DecoratorBeforeExport, {
    	          at: this.state.startLoc
    	        });
    	      }
    	      return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
    	    }
    	    if (this.match(75) || this.match(74) || this.isLet()) {
    	      throw this.raise(Errors.UnsupportedDefaultExport, {
    	        at: this.state.startLoc
    	      });
    	    }
    	    const res = this.parseMaybeAssignAllowIn();
    	    this.semicolon();
    	    return res;
    	  }
    	  parseExportDeclaration(node) {
    	    if (this.match(80)) {
    	      const node = this.parseClass(this.startNode(), true, false);
    	      return node;
    	    }
    	    return this.parseStatementListItem();
    	  }
    	  isExportDefaultSpecifier() {
    	    const {
    	      type
    	    } = this.state;
    	    if (tokenIsIdentifier(type)) {
    	      if (type === 95 && !this.state.containsEsc || type === 100) {
    	        return false;
    	      }
    	      if ((type === 130 || type === 129) && !this.state.containsEsc) {
    	        const {
    	          type: nextType
    	        } = this.lookahead();
    	        if (tokenIsIdentifier(nextType) && nextType !== 98 || nextType === 5) {
    	          this.expectOnePlugin(["flow", "typescript"]);
    	          return false;
    	        }
    	      }
    	    } else if (!this.match(65)) {
    	      return false;
    	    }
    	    const next = this.nextTokenStart();
    	    const hasFrom = this.isUnparsedContextual(next, "from");
    	    if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
    	      return true;
    	    }
    	    if (this.match(65) && hasFrom) {
    	      const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
    	      return nextAfterFrom === 34 || nextAfterFrom === 39;
    	    }
    	    return false;
    	  }
    	  parseExportFrom(node, expect) {
    	    if (this.eatContextual(98)) {
    	      node.source = this.parseImportSource();
    	      this.checkExport(node);
    	      this.maybeParseImportAttributes(node);
    	      this.checkJSONModuleImport(node);
    	    } else if (expect) {
    	      this.unexpected();
    	    }
    	    this.semicolon();
    	  }
    	  shouldParseExportDeclaration() {
    	    const {
    	      type
    	    } = this.state;
    	    if (type === 26) {
    	      this.expectOnePlugin(["decorators", "decorators-legacy"]);
    	      if (this.hasPlugin("decorators")) {
    	        if (this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
    	          this.raise(Errors.DecoratorBeforeExport, {
    	            at: this.state.startLoc
    	          });
    	        }
    	        return true;
    	      }
    	    }
    	    return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
    	  }
    	  checkExport(node, checkNames, isDefault, isFrom) {
    	    if (checkNames) {
    	      var _node$specifiers;
    	      if (isDefault) {
    	        this.checkDuplicateExports(node, "default");
    	        if (this.hasPlugin("exportDefaultFrom")) {
    	          var _declaration$extra;
    	          const declaration = node.declaration;
    	          if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
    	            this.raise(Errors.ExportDefaultFromAsIdentifier, {
    	              at: declaration
    	            });
    	          }
    	        }
    	      } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length) {
    	        for (const specifier of node.specifiers) {
    	          const {
    	            exported
    	          } = specifier;
    	          const exportName = exported.type === "Identifier" ? exported.name : exported.value;
    	          this.checkDuplicateExports(specifier, exportName);
    	          if (!isFrom && specifier.local) {
    	            const {
    	              local
    	            } = specifier;
    	            if (local.type !== "Identifier") {
    	              this.raise(Errors.ExportBindingIsString, {
    	                at: specifier,
    	                localName: local.value,
    	                exportName
    	              });
    	            } else {
    	              this.checkReservedWord(local.name, local.loc.start, true, false);
    	              this.scope.checkLocalExport(local);
    	            }
    	          }
    	        }
    	      } else if (node.declaration) {
    	        if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
    	          const id = node.declaration.id;
    	          if (!id) throw new Error("Assertion failure");
    	          this.checkDuplicateExports(node, id.name);
    	        } else if (node.declaration.type === "VariableDeclaration") {
    	          for (const declaration of node.declaration.declarations) {
    	            this.checkDeclaration(declaration.id);
    	          }
    	        }
    	      }
    	    }
    	  }
    	  checkDeclaration(node) {
    	    if (node.type === "Identifier") {
    	      this.checkDuplicateExports(node, node.name);
    	    } else if (node.type === "ObjectPattern") {
    	      for (const prop of node.properties) {
    	        this.checkDeclaration(prop);
    	      }
    	    } else if (node.type === "ArrayPattern") {
    	      for (const elem of node.elements) {
    	        if (elem) {
    	          this.checkDeclaration(elem);
    	        }
    	      }
    	    } else if (node.type === "ObjectProperty") {
    	      this.checkDeclaration(node.value);
    	    } else if (node.type === "RestElement") {
    	      this.checkDeclaration(node.argument);
    	    } else if (node.type === "AssignmentPattern") {
    	      this.checkDeclaration(node.left);
    	    }
    	  }
    	  checkDuplicateExports(node, exportName) {
    	    if (this.exportedIdentifiers.has(exportName)) {
    	      if (exportName === "default") {
    	        this.raise(Errors.DuplicateDefaultExport, {
    	          at: node
    	        });
    	      } else {
    	        this.raise(Errors.DuplicateExport, {
    	          at: node,
    	          exportName
    	        });
    	      }
    	    }
    	    this.exportedIdentifiers.add(exportName);
    	  }
    	  parseExportSpecifiers(isInTypeExport) {
    	    const nodes = [];
    	    let first = true;
    	    this.expect(5);
    	    while (!this.eat(8)) {
    	      if (first) {
    	        first = false;
    	      } else {
    	        this.expect(12);
    	        if (this.eat(8)) break;
    	      }
    	      const isMaybeTypeOnly = this.isContextual(130);
    	      const isString = this.match(133);
    	      const node = this.startNode();
    	      node.local = this.parseModuleExportName();
    	      nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
    	    }
    	    return nodes;
    	  }
    	  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
    	    if (this.eatContextual(93)) {
    	      node.exported = this.parseModuleExportName();
    	    } else if (isString) {
    	      node.exported = cloneStringLiteral(node.local);
    	    } else if (!node.exported) {
    	      node.exported = cloneIdentifier(node.local);
    	    }
    	    return this.finishNode(node, "ExportSpecifier");
    	  }
    	  parseModuleExportName() {
    	    if (this.match(133)) {
    	      const result = this.parseStringLiteral(this.state.value);
    	      const surrogate = result.value.match(loneSurrogate);
    	      if (surrogate) {
    	        this.raise(Errors.ModuleExportNameHasLoneSurrogate, {
    	          at: result,
    	          surrogateCharCode: surrogate[0].charCodeAt(0)
    	        });
    	      }
    	      return result;
    	    }
    	    return this.parseIdentifier(true);
    	  }
    	  isJSONModuleImport(node) {
    	    if (node.assertions != null) {
    	      return node.assertions.some(({
    	        key,
    	        value
    	      }) => {
    	        return value.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
    	      });
    	    }
    	    return false;
    	  }
    	  checkImportReflection(node) {
    	    const {
    	      specifiers
    	    } = node;
    	    const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;
    	    if (node.phase === "source") {
    	      if (singleBindingType !== "ImportDefaultSpecifier") {
    	        this.raise(Errors.SourcePhaseImportRequiresDefault, {
    	          at: specifiers[0].loc.start
    	        });
    	      }
    	    } else if (node.phase === "defer") {
    	      if (singleBindingType !== "ImportNamespaceSpecifier") {
    	        this.raise(Errors.DeferImportRequiresNamespace, {
    	          at: specifiers[0].loc.start
    	        });
    	      }
    	    } else if (node.module) {
    	      var _node$assertions;
    	      if (singleBindingType !== "ImportDefaultSpecifier") {
    	        this.raise(Errors.ImportReflectionNotBinding, {
    	          at: specifiers[0].loc.start
    	        });
    	      }
    	      if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {
    	        this.raise(Errors.ImportReflectionHasAssertion, {
    	          at: node.specifiers[0].loc.start
    	        });
    	      }
    	    }
    	  }
    	  checkJSONModuleImport(node) {
    	    if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
    	      const {
    	        specifiers
    	      } = node;
    	      if (specifiers != null) {
    	        const nonDefaultNamedSpecifier = specifiers.find(specifier => {
    	          let imported;
    	          if (specifier.type === "ExportSpecifier") {
    	            imported = specifier.local;
    	          } else if (specifier.type === "ImportSpecifier") {
    	            imported = specifier.imported;
    	          }
    	          if (imported !== undefined) {
    	            return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
    	          }
    	        });
    	        if (nonDefaultNamedSpecifier !== undefined) {
    	          this.raise(Errors.ImportJSONBindingNotDefault, {
    	            at: nonDefaultNamedSpecifier.loc.start
    	          });
    	        }
    	      }
    	    }
    	  }
    	  isPotentialImportPhase(isExport) {
    	    if (isExport) return false;
    	    return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    	  }
    	  applyImportPhase(node, isExport, phase, loc) {
    	    if (isExport) {
    	      return;
    	    }
    	    if (phase === "module") {
    	      this.expectPlugin("importReflection", loc);
    	      node.module = true;
    	    } else if (this.hasPlugin("importReflection")) {
    	      node.module = false;
    	    }
    	    if (phase === "source") {
    	      this.expectPlugin("sourcePhaseImports", loc);
    	      node.phase = "source";
    	    } else if (phase === "defer") {
    	      this.expectPlugin("deferredImportEvaluation", loc);
    	      node.phase = "defer";
    	    } else if (this.hasPlugin("sourcePhaseImports")) {
    	      node.phase = null;
    	    }
    	  }
    	  parseMaybeImportPhase(node, isExport) {
    	    if (!this.isPotentialImportPhase(isExport)) {
    	      this.applyImportPhase(node, isExport, null);
    	      return null;
    	    }
    	    const phaseIdentifier = this.parseIdentifier(true);
    	    const {
    	      type
    	    } = this.state;
    	    const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
    	    if (isImportPhase) {
    	      this.resetPreviousIdentifierLeadingComments(phaseIdentifier);
    	      this.applyImportPhase(node, isExport, phaseIdentifier.name, phaseIdentifier.loc.start);
    	      return null;
    	    } else {
    	      this.applyImportPhase(node, isExport, null);
    	      return phaseIdentifier;
    	    }
    	  }
    	  isPrecedingIdImportPhase(phase) {
    	    const {
    	      type
    	    } = this.state;
    	    return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
    	  }
    	  parseImport(node) {
    	    if (this.match(133)) {
    	      return this.parseImportSourceAndAttributes(node);
    	    }
    	    return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));
    	  }
    	  parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {
    	    node.specifiers = [];
    	    const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);
    	    const parseNext = !hasDefault || this.eat(12);
    	    const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
    	    if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
    	    this.expectContextual(98);
    	    return this.parseImportSourceAndAttributes(node);
    	  }
    	  parseImportSourceAndAttributes(node) {
    	    var _node$specifiers2;
    	    (_node$specifiers2 = node.specifiers) != null ? _node$specifiers2 : node.specifiers = [];
    	    node.source = this.parseImportSource();
    	    this.maybeParseImportAttributes(node);
    	    this.checkImportReflection(node);
    	    this.checkJSONModuleImport(node);
    	    this.semicolon();
    	    return this.finishNode(node, "ImportDeclaration");
    	  }
    	  parseImportSource() {
    	    if (!this.match(133)) this.unexpected();
    	    return this.parseExprAtom();
    	  }
    	  parseImportSpecifierLocal(node, specifier, type) {
    	    specifier.local = this.parseIdentifier();
    	    node.specifiers.push(this.finishImportSpecifier(specifier, type));
    	  }
    	  finishImportSpecifier(specifier, type, bindingType = 8201) {
    	    this.checkLVal(specifier.local, {
    	      in: {
    	        type
    	      },
    	      binding: bindingType
    	    });
    	    return this.finishNode(specifier, type);
    	  }
    	  parseImportAttributes() {
    	    this.expect(5);
    	    const attrs = [];
    	    const attrNames = new Set();
    	    do {
    	      if (this.match(8)) {
    	        break;
    	      }
    	      const node = this.startNode();
    	      const keyName = this.state.value;
    	      if (attrNames.has(keyName)) {
    	        this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
    	          at: this.state.startLoc,
    	          key: keyName
    	        });
    	      }
    	      attrNames.add(keyName);
    	      if (this.match(133)) {
    	        node.key = this.parseStringLiteral(keyName);
    	      } else {
    	        node.key = this.parseIdentifier(true);
    	      }
    	      this.expect(14);
    	      if (!this.match(133)) {
    	        throw this.raise(Errors.ModuleAttributeInvalidValue, {
    	          at: this.state.startLoc
    	        });
    	      }
    	      node.value = this.parseStringLiteral(this.state.value);
    	      attrs.push(this.finishNode(node, "ImportAttribute"));
    	    } while (this.eat(12));
    	    this.expect(8);
    	    return attrs;
    	  }
    	  parseModuleAttributes() {
    	    const attrs = [];
    	    const attributes = new Set();
    	    do {
    	      const node = this.startNode();
    	      node.key = this.parseIdentifier(true);
    	      if (node.key.name !== "type") {
    	        this.raise(Errors.ModuleAttributeDifferentFromType, {
    	          at: node.key
    	        });
    	      }
    	      if (attributes.has(node.key.name)) {
    	        this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
    	          at: node.key,
    	          key: node.key.name
    	        });
    	      }
    	      attributes.add(node.key.name);
    	      this.expect(14);
    	      if (!this.match(133)) {
    	        throw this.raise(Errors.ModuleAttributeInvalidValue, {
    	          at: this.state.startLoc
    	        });
    	      }
    	      node.value = this.parseStringLiteral(this.state.value);
    	      attrs.push(this.finishNode(node, "ImportAttribute"));
    	    } while (this.eat(12));
    	    return attrs;
    	  }
    	  maybeParseImportAttributes(node) {
    	    let attributes;
    	    let useWith = false;
    	    if (this.match(76)) {
    	      if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {
    	        return;
    	      }
    	      this.next();
    	      {
    	        if (this.hasPlugin("moduleAttributes")) {
    	          attributes = this.parseModuleAttributes();
    	        } else {
    	          this.expectImportAttributesPlugin();
    	          attributes = this.parseImportAttributes();
    	        }
    	      }
    	      useWith = true;
    	    } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
    	      if (this.hasPlugin("importAttributes")) {
    	        if (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== true) {
    	          this.raise(Errors.ImportAttributesUseAssert, {
    	            at: this.state.startLoc
    	          });
    	        }
    	        this.addExtra(node, "deprecatedAssertSyntax", true);
    	      } else {
    	        this.expectOnePlugin(["importAttributes", "importAssertions"]);
    	      }
    	      this.next();
    	      attributes = this.parseImportAttributes();
    	    } else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
    	      attributes = [];
    	    } else {
    	      if (this.hasPlugin("moduleAttributes")) {
    	        attributes = [];
    	      } else return;
    	    }
    	    if (!useWith && this.hasPlugin("importAssertions")) {
    	      node.assertions = attributes;
    	    } else {
    	      node.attributes = attributes;
    	    }
    	  }
    	  maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {
    	    if (maybeDefaultIdentifier) {
    	      const specifier = this.startNodeAtNode(maybeDefaultIdentifier);
    	      specifier.local = maybeDefaultIdentifier;
    	      node.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier"));
    	      return true;
    	    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
    	      this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier");
    	      return true;
    	    }
    	    return false;
    	  }
    	  maybeParseStarImportSpecifier(node) {
    	    if (this.match(55)) {
    	      const specifier = this.startNode();
    	      this.next();
    	      this.expectContextual(93);
    	      this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier");
    	      return true;
    	    }
    	    return false;
    	  }
    	  parseNamedImportSpecifiers(node) {
    	    let first = true;
    	    this.expect(5);
    	    while (!this.eat(8)) {
    	      if (first) {
    	        first = false;
    	      } else {
    	        if (this.eat(14)) {
    	          throw this.raise(Errors.DestructureNamedImport, {
    	            at: this.state.startLoc
    	          });
    	        }
    	        this.expect(12);
    	        if (this.eat(8)) break;
    	      }
    	      const specifier = this.startNode();
    	      const importedIsString = this.match(133);
    	      const isMaybeTypeOnly = this.isContextual(130);
    	      specifier.imported = this.parseModuleExportName();
    	      const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly, undefined);
    	      node.specifiers.push(importSpecifier);
    	    }
    	  }
    	  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
    	    if (this.eatContextual(93)) {
    	      specifier.local = this.parseIdentifier();
    	    } else {
    	      const {
    	        imported
    	      } = specifier;
    	      if (importedIsString) {
    	        throw this.raise(Errors.ImportBindingIsString, {
    	          at: specifier,
    	          importName: imported.value
    	        });
    	      }
    	      this.checkReservedWord(imported.name, specifier.loc.start, true, true);
    	      if (!specifier.local) {
    	        specifier.local = cloneIdentifier(imported);
    	      }
    	    }
    	    return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
    	  }
    	  isThisParam(param) {
    	    return param.type === "Identifier" && param.name === "this";
    	  }
    	}
    	class Parser extends StatementParser {
    	  constructor(options, input) {
    	    options = getOptions(options);
    	    super(options, input);
    	    this.options = options;
    	    this.initializeScopes();
    	    this.plugins = pluginsMap(this.options.plugins);
    	    this.filename = options.sourceFilename;
    	  }
    	  getScopeHandler() {
    	    return ScopeHandler;
    	  }
    	  parse() {
    	    this.enterInitialScopes();
    	    const file = this.startNode();
    	    const program = this.startNode();
    	    this.nextToken();
    	    file.errors = null;
    	    this.parseTopLevel(file, program);
    	    file.errors = this.state.errors;
    	    return file;
    	  }
    	}
    	function pluginsMap(plugins) {
    	  const pluginMap = new Map();
    	  for (const plugin of plugins) {
    	    const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];
    	    if (!pluginMap.has(name)) pluginMap.set(name, options || {});
    	  }
    	  return pluginMap;
    	}
    	function parse(input, options) {
    	  var _options;
    	  if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
    	    options = Object.assign({}, options);
    	    try {
    	      options.sourceType = "module";
    	      const parser = getParser(options, input);
    	      const ast = parser.parse();
    	      if (parser.sawUnambiguousESM) {
    	        return ast;
    	      }
    	      if (parser.ambiguousScriptDifferentAst) {
    	        try {
    	          options.sourceType = "script";
    	          return getParser(options, input).parse();
    	        } catch (_unused) {}
    	      } else {
    	        ast.program.sourceType = "script";
    	      }
    	      return ast;
    	    } catch (moduleError) {
    	      try {
    	        options.sourceType = "script";
    	        return getParser(options, input).parse();
    	      } catch (_unused2) {}
    	      throw moduleError;
    	    }
    	  } else {
    	    return getParser(options, input).parse();
    	  }
    	}
    	function parseExpression(input, options) {
    	  const parser = getParser(options, input);
    	  if (parser.options.strictMode) {
    	    parser.state.strict = true;
    	  }
    	  return parser.getExpression();
    	}
    	function generateExportedTokenTypes(internalTokenTypes) {
    	  const tokenTypes = {};
    	  for (const typeName of Object.keys(internalTokenTypes)) {
    	    tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);
    	  }
    	  return tokenTypes;
    	}
    	const tokTypes = generateExportedTokenTypes(tt);
    	function getParser(options, input) {
    	  let cls = Parser;
    	  if (options != null && options.plugins) {
    	    validatePlugins(options.plugins);
    	    cls = getParserClass(options.plugins);
    	  }
    	  return new cls(options, input);
    	}
    	const parserClassCache = {};
    	function getParserClass(pluginsFromOptions) {
    	  const pluginList = mixinPluginNames.filter(name => hasPlugin(pluginsFromOptions, name));
    	  const key = pluginList.join("/");
    	  let cls = parserClassCache[key];
    	  if (!cls) {
    	    cls = Parser;
    	    for (const plugin of pluginList) {
    	      cls = mixinPlugins[plugin](cls);
    	    }
    	    parserClassCache[key] = cls;
    	  }
    	  return cls;
    	}
    	lib$1.parse = parse;
    	lib$1.parseExpression = parseExpression;
    	lib$1.tokTypes = tokTypes;
    	
    	return lib$1;
    }

    var libExports$1 = requireLib$1();

    /**
     *  https://github.com/ryanjduffy/parse-script-tags
     *
     * Copyright (c) by Ryan Duff
     * Licensed under the MIT License.
     */

    const alphanum = /[a-z0-9\-]/i;

    function parseToken(str, start) {
      let i = start;
      while (i < str.length && alphanum.test(str.charAt(i++))) {
        continue;
      }

      if (i !== start) {
        return {
          token: str.substring(start, i - 1),
          index: i,
        };
      }

      return null;
    }

    function parseAttributes(str, start) {
      let i = start;
      const attributes = {};
      let attribute = null;

      while (i < str.length) {
        const c = str.charAt(i);

        if (attribute === null && c == ">") {
          break;
        } else if (attribute === null && alphanum.test(c)) {
          attribute = {
            name: null,
            value: true,
            bool: true,
            terminator: null,
          };

          const attributeNameNode = parseToken(str, i);
          if (attributeNameNode) {
            attribute.name = attributeNameNode.token;
            i = attributeNameNode.index - 2;
          }
        } else if (attribute !== null) {
          if (c === "=") {
            // once we've started an attribute, look for = to indicate
            // it's a non-boolean attribute
            attribute.bool = false;
            if (attribute.value === true) {
              attribute.value = "";
            }
          } else if (
            !attribute.bool &&
            attribute.terminator === null &&
            (c === '"' || c === "'")
          ) {
            // once we've determined it's non-boolean, look for a
            // value terminator (", ')
            attribute.terminator = c;
          } else if (attribute.terminator) {
            if (c === attribute.terminator) {
              // if we had a terminator and found another, we've
              // reach the end of the attribute
              attributes[attribute.name] = attribute.value;
              attribute = null;
            } else {
              // otherwise, append the character to the attribute value
              attribute.value += c;

              // check for an escaped terminator and push it as well
              // to avoid terminating prematurely
              if (c === "\\") {
                const next = str.charAt(i + 1);
                if (next === attribute.terminator) {
                  attribute.value += next;
                  i += 1;
                }
              }
            }
          } else if (!/\s/.test(c)) {
            // if we've hit a non-space character and aren't processing a value,
            // we're starting a new attribute so push the attribute and clear the
            // local variable
            attributes[attribute.name] = attribute.value;
            attribute = null;

            // move the cursor back to re-find the start of the attribute
            i -= 1;
          }
        }

        i++;
      }

      if (i !== start) {
        return {
          attributes,
          index: i,
        };
      }

      return null;
    }

    function parseFragment(str, start = 0) {
      let tag = null;
      let open = false;
      let attributes = {};

      let i = start;
      while (i < str.length) {
        const c = str.charAt(i++);

        if (!open && !tag && c === "<") {
          // Open Start Tag
          open = true;

          const tagNode = parseToken(str, i);
          if (!tagNode) {
            return null;
          }

          i = tagNode.index - 1;
          tag = tagNode.token;
        } else if (open && c === ">") {
          // Close Start Tag
          break;
        } else if (open) {
          // Attributes
          const attributeNode = parseAttributes(str, i - 1);

          if (attributeNode) {
            i = attributeNode.index;
            attributes = attributeNode.attributes || attributes;
          }
        }
      }

      if (tag) {
        return {
          tag,
          attributes,
        };
      }

      return null;
    }

    const startScript = /<script[^>]*>/im;
    const endScript = /<\/script\s*>/im;
    // https://stackoverflow.com/questions/5034781/js-regex-to-split-by-line#comment5633979_5035005
    const newLines = /\r\n|[\n\v\f\r\x85\u2028\u2029]/;

    function getType(tag) {
      const fragment = parseFragment(tag);

      if (fragment) {
        const type = fragment.attributes.type;

        return type ? type.toLowerCase() : null;
      }

      return null;
    }

    function getCandidateScriptLocations(source, index) {
      const i = index || 0;
      const str = source.substring(i);

      const startMatch = startScript.exec(str);
      if (startMatch) {
        const startsAt = startMatch.index + startMatch[0].length;
        const afterStart = str.substring(startsAt);
        const endMatch = endScript.exec(afterStart);
        if (endMatch) {
          const locLength = endMatch.index;
          const locIndex = i + startsAt;
          const endIndex = locIndex + locLength + endMatch[0].length;

          // extract the complete tag (incl start and end tags and content). if the
          // type is invalid (= not JS), skip this tag and continue
          const tag = source.substring(i + startMatch.index, endIndex);
          const type = getType(tag);
          if (
            type &&
            type !== "javascript" &&
            type !== "text/javascript" &&
            type !== "module"
          ) {
            return getCandidateScriptLocations(source, endIndex);
          }

          return [
            adjustForLineAndColumn(source, {
              index: locIndex,
              length: locLength,
              source: source.substring(locIndex, locIndex + locLength),
            }),
            ...getCandidateScriptLocations(source, endIndex),
          ];
        }
      }

      return [];
    }

    function parseScripts(locations, parser) {
      return locations.map(parser);
    }

    function calcLineAndColumn(source, index) {
      const lines = source.substring(0, index).split(newLines);
      const line = lines.length;
      const column = lines.pop().length + 1;

      return {
        column,
        line,
      };
    }

    function adjustForLineAndColumn(fullSource, location) {
      const { column, line } = calcLineAndColumn(fullSource, location.index);
      return Object.assign({}, location, {
        line,
        column,
        // prepend whitespace for scripts that do not start on the first column
        // NOTE: `column` is 1-based
        source: " ".repeat(column - 1) + location.source,
      });
    }

    function parseScriptTags$1(source, parser) {
      const scripts = parseScripts(getCandidateScriptLocations(source), parser)
        .filter(libExports$2.isFile)
        .reduce(
          (main, script) => {
            return {
              statements: main.statements.concat(script.program.body),
              comments: main.comments.concat(script.comments),
              tokens: main.tokens.concat(script.tokens),
            };
          },
          {
            statements: [],
            comments: [],
            tokens: [],
          }
        );

      const program = libExports$2.program(scripts.statements);
      const file = libExports$2.file(program, scripts.comments, scripts.tokens);

      const end = calcLineAndColumn(source, source.length);
      file.start = program.start = 0;
      file.end = program.end = source.length;
      file.loc = program.loc = {
        start: {
          line: 1,
          column: 0,
        },
        end,
      };

      return file;
    }

    function parseScript$1({ source, line }) {
      // remove empty or only whitespace scripts
      if (source.length === 0 || /^\s+$/.test(source)) {
        return null;
      }

      try {
        return libExports$1.parse(source, {
          sourceType: "script",
          startLine: line,
        });
      } catch (e) {
        return null;
      }
    }

    function parseScriptTags(source, parser = parseScript$1) {
      return parseScriptTags$1(source, parser);
    }

    /* This Source Code Form is subject to the terms of the Mozilla Public
     * License, v. 2.0. If a copy of the MPL was not distributed with this
     * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

    const cachedSources = new Map();

    function setSource(source) {
      cachedSources.set(source.id, source);
    }

    function getSource(sourceId) {
      const source = cachedSources.get(sourceId);
      if (!source) {
        throw new Error(`Parser: source ${sourceId} was not provided.`);
      }

      return source;
    }

    function clearSources(sourceIds) {
      for (const sourceId of sourceIds) {
        cachedSources.delete(sourceId);
      }
    }

    const ASTs = new Map();

    function _parse(code, opts) {
      return libExports$1.parse(code, {
        ...opts,
        tokens: true,
      });
    }

    const sourceOptions = {
      generated: {
        sourceType: "unambiguous",
        tokens: true,
        plugins: [
          "classStaticBlock",
          "classPrivateProperties",
          "classPrivateMethods",
          "classProperties",
          "objectRestSpread",
          "optionalChaining",
          "privateIn",
          "nullishCoalescingOperator",
          "regexpUnicodeSets",
        ],
      },
      original: {
        sourceType: "unambiguous",
        tokens: true,
        plugins: [
          "jsx",
          "flow",
          "doExpressions",
          "optionalChaining",
          "nullishCoalescingOperator",
          "decorators-legacy",
          "objectRestSpread",
          "classStaticBlock",
          "classPrivateProperties",
          "classPrivateMethods",
          "classProperties",
          "exportDefaultFrom",
          "exportNamespaceFrom",
          "asyncGenerators",
          "functionBind",
          "functionSent",
          "dynamicImport",
          "react-jsx",
          "regexpUnicodeSets",
        ],
      },
    };

    function parse(text, opts) {
      let ast = {};
      if (!text) {
        return ast;
      }

      try {
        ast = _parse(text, opts);
      } catch (error) {
        console.error(error);
      }

      return ast;
    }

    // Custom parser for parse-script-tags that adapts its input structure to
    // our parser's signature
    function htmlParser({ source, line }) {
      return parse(source, { startLine: line, ...sourceOptions.generated });
    }

    const VUE_COMPONENT_START = /^\s*</;
    function vueParser({ source, line }) {
      return parse(source, {
        startLine: line,
        ...sourceOptions.original,
      });
    }
    function parseVueScript(code) {
      if (typeof code !== "string") {
        return {};
      }

      let ast;

      // .vue files go through several passes, so while there is a
      // single-file-component Vue template, there are also generally .vue files
      // that are still just JS as well.
      if (code.match(VUE_COMPONENT_START)) {
        ast = parseScriptTags(code, vueParser);
        if (libExports$2.isFile(ast)) {
          // parseScriptTags is currently hard-coded to return scripts, but Vue
          // always expects ESM syntax, so we just hard-code it.
          ast.program.sourceType = "module";
        }
      } else {
        ast = parse(code, sourceOptions.original);
      }
      return ast;
    }

    function parseConsoleScript(text, opts) {
      try {
        return _parse(text, {
          plugins: [
            "classStaticBlock",
            "classPrivateProperties",
            "classPrivateMethods",
            "objectRestSpread",
            "dynamicImport",
            "nullishCoalescingOperator",
            "optionalChaining",
            "regexpUnicodeSets",
          ],
          ...opts,
          allowAwaitOutsideFunction: true,
        });
      } catch (e) {
        return null;
      }
    }

    function parseScript(text, opts) {
      return _parse(text, opts);
    }

    function getAst(sourceId) {
      if (ASTs.has(sourceId)) {
        return ASTs.get(sourceId);
      }

      const source = getSource(sourceId);

      if (source.isWasm) {
        return null;
      }

      let ast = {};
      const { contentType } = source;
      if (contentType == "text/html") {
        ast = parseScriptTags(source.text, htmlParser) || {};
      } else if (contentType && contentType === "text/vue") {
        ast = parseVueScript(source.text) || {};
      } else if (
        contentType &&
        contentType.match(/(javascript|jsx)/) &&
        !contentType.match(/typescript-jsx/)
      ) {
        const type = source.id.includes("original") ? "original" : "generated";
        const options = sourceOptions[type];
        ast = parse(source.text, options);
      } else if (contentType && contentType.match(/typescript/)) {
        const options = {
          ...sourceOptions.original,
          plugins: [
            ...sourceOptions.original.plugins.filter(
              p =>
                p !== "flow" &&
                p !== "decorators" &&
                p !== "decorators2" &&
                (p !== "jsx" || contentType.match(/typescript-jsx/))
            ),
            "decorators-legacy",
            "typescript",
          ],
        };
        ast = parse(source.text, options);
      }

      ASTs.set(source.id, ast);
      return ast;
    }

    function clearASTs(sourceIds) {
      for (const sourceId of sourceIds) {
        ASTs.delete(sourceId);
      }
    }

    function traverseAst(sourceId, visitor, state) {
      const ast = getAst(sourceId);
      if (!ast || !Object.keys(ast).length) {
        return null;
      }

      libExports$2.traverse(ast, visitor, state);
      return ast;
    }

    function hasNode(rootNode, predicate) {
      try {
        libExports$2.traverse(rootNode, {
          enter: (node, ancestors) => {
            if (predicate(node, ancestors)) {
              throw new Error("MATCH");
            }
          },
        });
      } catch (e) {
        if (e.message === "MATCH") {
          return true;
        }
      }
      return false;
    }

    function replaceNode$1(ancestors, node) {
      const parent = ancestors[ancestors.length - 1];

      if (typeof parent.index === "number") {
        if (Array.isArray(node)) {
          parent.node[parent.key].splice(parent.index, 1, ...node);
        } else {
          parent.node[parent.key][parent.index] = node;
        }
      } else {
        parent.node[parent.key] = node;
      }
    }

    var lib = {};

    var sourceMap = {};

    var genMapping_umd = {exports: {}};

    var setArray_umd = {exports: {}};

    var hasRequiredSetArray_umd;

    function requireSetArray_umd () {
    	if (hasRequiredSetArray_umd) return setArray_umd.exports;
    	hasRequiredSetArray_umd = 1;
    	(function (module, exports) {
    		(function (global, factory) {
    		    factory(exports) ;
    		})(commonjsGlobal, (function (exports) {
    		    /**
    		     * Gets the index associated with `key` in the backing array, if it is already present.
    		     */
    		    exports.get = void 0;
    		    /**
    		     * Puts `key` into the backing array, if it is not already present. Returns
    		     * the index of the `key` in the backing array.
    		     */
    		    exports.put = void 0;
    		    /**
    		     * Pops the last added item out of the SetArray.
    		     */
    		    exports.pop = void 0;
    		    /**
    		     * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the
    		     * index of the `key` in the backing array.
    		     *
    		     * This is designed to allow synchronizing a second array with the contents of the backing array,
    		     * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,
    		     * and there are never duplicates.
    		     */
    		    class SetArray {
    		        constructor() {
    		            this._indexes = { __proto__: null };
    		            this.array = [];
    		        }
    		    }
    		    (() => {
    		        exports.get = (strarr, key) => strarr._indexes[key];
    		        exports.put = (strarr, key) => {
    		            // The key may or may not be present. If it is present, it's a number.
    		            const index = exports.get(strarr, key);
    		            if (index !== undefined)
    		                return index;
    		            const { array, _indexes: indexes } = strarr;
    		            return (indexes[key] = array.push(key) - 1);
    		        };
    		        exports.pop = (strarr) => {
    		            const { array, _indexes: indexes } = strarr;
    		            if (array.length === 0)
    		                return;
    		            const last = array.pop();
    		            indexes[last] = undefined;
    		        };
    		    })();

    		    exports.SetArray = SetArray;

    		    Object.defineProperty(exports, '__esModule', { value: true });

    		}));
    		
    	} (setArray_umd, setArray_umd.exports));
    	return setArray_umd.exports;
    }

    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
    var inited = false;
    function init () {
      inited = true;
      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }

      revLookup['-'.charCodeAt(0)] = 62;
      revLookup['_'.charCodeAt(0)] = 63;
    }

    function toByteArray (b64) {
      if (!inited) {
        init();
      }
      var i, j, l, tmp, placeHolders, arr;
      var len = b64.length;

      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }

      // the number of equal signs (place holders)
      // if there are two placeholders, than the two characters before it
      // represent one byte
      // if there is only one, then the three characters before it represent 2 bytes
      // this is just a cheap hack to not do indexOf twice
      placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

      // base64 is 4/3 + up to two characters of the original data
      arr = new Arr(len * 3 / 4 - placeHolders);

      // if there are placeholders, only get up to the last complete 4 chars
      l = placeHolders > 0 ? len - 4 : len;

      var L = 0;

      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
        arr[L++] = (tmp >> 16) & 0xFF;
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      if (placeHolders === 2) {
        tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
        arr[L++] = tmp & 0xFF;
      } else if (placeHolders === 1) {
        tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      return arr
    }

    function tripletToBase64 (num) {
      return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
    }

    function encodeChunk (uint8, start, end) {
      var tmp;
      var output = [];
      for (var i = start; i < end; i += 3) {
        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
        output.push(tripletToBase64(tmp));
      }
      return output.join('')
    }

    function fromByteArray (uint8) {
      if (!inited) {
        init();
      }
      var tmp;
      var len = uint8.length;
      var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
      var output = '';
      var parts = [];
      var maxChunkLength = 16383; // must be multiple of 3

      // go through the array every three bytes, we'll deal with trailing stuff later
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
      }

      // pad the end with zeros, but make sure to not forget the extra bytes
      if (extraBytes === 1) {
        tmp = uint8[len - 1];
        output += lookup[tmp >> 2];
        output += lookup[(tmp << 4) & 0x3F];
        output += '==';
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
        output += lookup[tmp >> 10];
        output += lookup[(tmp >> 4) & 0x3F];
        output += lookup[(tmp << 2) & 0x3F];
        output += '=';
      }

      parts.push(output);

      return parts.join('')
    }

    function read (buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? (nBytes - 1) : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];

      i += d;

      e = s & ((1 << (-nBits)) - 1);
      s >>= (-nBits);
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      m = e & ((1 << (-nBits)) - 1);
      e >>= (-nBits);
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }

    function write (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
      var i = isLE ? 0 : (nBytes - 1);
      var d = isLE ? 1 : -1;
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

      value = Math.abs(value);

      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }

        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }

      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

      e = (e << mLen) | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

      buffer[offset + i - d] |= s * 128;
    }

    var toString = {}.toString;

    var isArray = Array.isArray || function (arr) {
      return toString.call(arr) == '[object Array]';
    };

    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
     * @license  MIT
     */

    var INSPECT_MAX_BYTES = 50;

    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Use Object implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * Due to various browser bugs, sometimes the Object implementation will be used even
     * when the browser supports typed arrays.
     *
     * Note:
     *
     *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
     *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
     *
     *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
     *
     *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
     *     incorrect length in some situations.

     * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
     * get the Object implementation, which is slower but behaves correctly.
     */
    Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
      ? global$1.TYPED_ARRAY_SUPPORT
      : true;

    /*
     * Export kMaxLength after typed array support is determined.
     */
    kMaxLength();

    function kMaxLength () {
      return Buffer.TYPED_ARRAY_SUPPORT
        ? 0x7fffffff
        : 0x3fffffff
    }

    function createBuffer (that, length) {
      if (kMaxLength() < length) {
        throw new RangeError('Invalid typed array length')
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = new Uint8Array(length);
        that.__proto__ = Buffer.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        if (that === null) {
          that = new Buffer(length);
        }
        that.length = length;
      }

      return that
    }

    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */

    function Buffer (arg, encodingOrOffset, length) {
      if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
        return new Buffer(arg, encodingOrOffset, length)
      }

      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new Error(
            'If encoding is specified then the first argument must be a string'
          )
        }
        return allocUnsafe(this, arg)
      }
      return from(this, arg, encodingOrOffset, length)
    }

    Buffer.poolSize = 8192; // not used by this implementation

    // TODO: Legacy, not needed anymore. Remove in next major version.
    Buffer._augment = function (arr) {
      arr.__proto__ = Buffer.prototype;
      return arr
    };

    function from (that, value, encodingOrOffset, length) {
      if (typeof value === 'number') {
        throw new TypeError('"value" argument must not be a number')
      }

      if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, encodingOrOffset, length)
      }

      if (typeof value === 'string') {
        return fromString(that, value, encodingOrOffset)
      }

      return fromObject(that, value)
    }

    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/
    Buffer.from = function (value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length)
    };

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      Buffer.prototype.__proto__ = Uint8Array.prototype;
      Buffer.__proto__ = Uint8Array;
    }

    function assertSize (size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be a number')
      } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative')
      }
    }

    function alloc (that, size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(that, size)
      }
      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpretted as a start offset.
        return typeof encoding === 'string'
          ? createBuffer(that, size).fill(fill, encoding)
          : createBuffer(that, size).fill(fill)
      }
      return createBuffer(that, size)
    }

    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/
    Buffer.alloc = function (size, fill, encoding) {
      return alloc(null, size, fill, encoding)
    };

    function allocUnsafe (that, size) {
      assertSize(size);
      that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) {
        for (var i = 0; i < size; ++i) {
          that[i] = 0;
        }
      }
      return that
    }

    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */
    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(null, size)
    };
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */
    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(null, size)
    };

    function fromString (that, string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }

      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding')
      }

      var length = byteLength(string, encoding) | 0;
      that = createBuffer(that, length);

      var actual = that.write(string, encoding);

      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        that = that.slice(0, actual);
      }

      return that
    }

    function fromArrayLike (that, array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      that = createBuffer(that, length);
      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255;
      }
      return that
    }

    function fromArrayBuffer (that, array, byteOffset, length) {
      array.byteLength; // this throws if `array` is not a valid ArrayBuffer

      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('\'offset\' is out of bounds')
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('\'length\' is out of bounds')
      }

      if (byteOffset === undefined && length === undefined) {
        array = new Uint8Array(array);
      } else if (length === undefined) {
        array = new Uint8Array(array, byteOffset);
      } else {
        array = new Uint8Array(array, byteOffset, length);
      }

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = array;
        that.__proto__ = Buffer.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        that = fromArrayLike(that, array);
      }
      return that
    }

    function fromObject (that, obj) {
      if (internalIsBuffer(obj)) {
        var len = checked(obj.length) | 0;
        that = createBuffer(that, len);

        if (that.length === 0) {
          return that
        }

        obj.copy(that, 0, 0, len);
        return that
      }

      if (obj) {
        if ((typeof ArrayBuffer !== 'undefined' &&
            obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
          if (typeof obj.length !== 'number' || isnan(obj.length)) {
            return createBuffer(that, 0)
          }
          return fromArrayLike(that, obj)
        }

        if (obj.type === 'Buffer' && isArray(obj.data)) {
          return fromArrayLike(that, obj.data)
        }
      }

      throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
    }

    function checked (length) {
      // Note: cannot use `length < kMaxLength()` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= kMaxLength()) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                             'size: 0x' + kMaxLength().toString(16) + ' bytes')
      }
      return length | 0
    }
    Buffer.isBuffer = isBuffer;
    function internalIsBuffer (b) {
      return !!(b != null && b._isBuffer)
    }

    Buffer.compare = function compare (a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError('Arguments must be Buffers')
      }

      if (a === b) return 0

      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    Buffer.isEncoding = function isEncoding (encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true
        default:
          return false
      }
    };

    Buffer.concat = function concat (list, length) {
      if (!isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }

      if (list.length === 0) {
        return Buffer.alloc(0)
      }

      var i;
      if (length === undefined) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }

      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer
    };

    function byteLength (string, encoding) {
      if (internalIsBuffer(string)) {
        return string.length
      }
      if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
          (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength
      }
      if (typeof string !== 'string') {
        string = '' + string;
      }

      var len = string.length;
      if (len === 0) return 0

      // Use a for loop to avoid recursion
      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len
          case 'utf8':
          case 'utf-8':
          case undefined:
            return utf8ToBytes(string).length
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2
          case 'hex':
            return len >>> 1
          case 'base64':
            return base64ToBytes(string).length
          default:
            if (loweredCase) return utf8ToBytes(string).length // assume utf8
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.byteLength = byteLength;

    function slowToString (encoding, start, end) {
      var loweredCase = false;

      // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.

      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
      if (start === undefined || start < 0) {
        start = 0;
      }
      // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.
      if (start > this.length) {
        return ''
      }

      if (end === undefined || end > this.length) {
        end = this.length;
      }

      if (end <= 0) {
        return ''
      }

      // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
      end >>>= 0;
      start >>>= 0;

      if (end <= start) {
        return ''
      }

      if (!encoding) encoding = 'utf8';

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end)

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end)

          case 'ascii':
            return asciiSlice(this, start, end)

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end)

          case 'base64':
            return base64Slice(this, start, end)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    }

    // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
    // Buffer instances.
    Buffer.prototype._isBuffer = true;

    function swap (b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }

    Buffer.prototype.swap16 = function swap16 () {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits')
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this
    };

    Buffer.prototype.swap32 = function swap32 () {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits')
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this
    };

    Buffer.prototype.swap64 = function swap64 () {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits')
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this
    };

    Buffer.prototype.toString = function toString () {
      var length = this.length | 0;
      if (length === 0) return ''
      if (arguments.length === 0) return utf8Slice(this, 0, length)
      return slowToString.apply(this, arguments)
    };

    Buffer.prototype.equals = function equals (b) {
      if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
      if (this === b) return true
      return Buffer.compare(this, b) === 0
    };

    Buffer.prototype.inspect = function inspect () {
      var str = '';
      var max = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
        if (this.length > max) str += ' ... ';
      }
      return '<Buffer ' + str + '>'
    };

    Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError('Argument must be a Buffer')
      }

      if (start === undefined) {
        start = 0;
      }
      if (end === undefined) {
        end = target ? target.length : 0;
      }
      if (thisStart === undefined) {
        thisStart = 0;
      }
      if (thisEnd === undefined) {
        thisEnd = this.length;
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index')
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0
      }
      if (thisStart >= thisEnd) {
        return -1
      }
      if (start >= end) {
        return 1
      }

      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;

      if (this === target) return 0

      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);

      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf
    function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1

      // Normalize byteOffset
      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }
      byteOffset = +byteOffset;  // Coerce to Number.
      if (isNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : (buffer.length - 1);
      }

      // Normalize byteOffset: negative offsets start from the end of the buffer
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1
      }

      // Normalize val
      if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
      }

      // Finally, search either indexOf (if dir is true) or lastIndexOf
      if (internalIsBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
      } else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]
        if (Buffer.TYPED_ARRAY_SUPPORT &&
            typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
          }
        }
        return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
      }

      throw new TypeError('val must be string, number or Buffer')
    }

    function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
            encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }

      function read (buf, i) {
        if (indexSize === 1) {
          return buf[i]
        } else {
          return buf.readUInt16BE(i * indexSize)
        }
      }

      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break
            }
          }
          if (found) return i
        }
      }

      return -1
    }

    Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1
    };

    Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    };

    Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    };

    function hexWrite (buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }

      // must be an even number of digits
      var strLen = string.length;
      if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (isNaN(parsed)) return i
        buf[offset + i] = parsed;
      }
      return i
    }

    function utf8Write (buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    }

    function asciiWrite (buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length)
    }

    function latin1Write (buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length)
    }

    function base64Write (buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length)
    }

    function ucs2Write (buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    }

    Buffer.prototype.write = function write (string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
      // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
      // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        }
      // legacy write(string, encoding, offset, length) - remove in v0.13
      } else {
        throw new Error(
          'Buffer.write(string, encoding, offset[, length]) is no longer supported'
        )
      }

      var remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;

      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds')
      }

      if (!encoding) encoding = 'utf8';

      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length)

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length)

          case 'ascii':
            return asciiWrite(this, string, offset, length)

          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length)

          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };

    Buffer.prototype.toJSON = function toJSON () {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    };

    function base64Slice (buf, start, end) {
      if (start === 0 && end === buf.length) {
        return fromByteArray(buf)
      } else {
        return fromByteArray(buf.slice(start, end))
      }
    }

    function utf8Slice (buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];

      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = (firstByte > 0xEF) ? 4
          : (firstByte > 0xDF) ? 3
          : (firstByte > 0xBF) ? 2
          : 1;

        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }
              break
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }

        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        res.push(codePoint);
        i += bytesPerSequence;
      }

      return decodeCodePointsArray(res)
    }

    // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety
    var MAX_ARGUMENTS_LENGTH = 0x1000;

    function decodeCodePointsArray (codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
      }

      // Decode in chunks to avoid "call stack size exceeded".
      var res = '';
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res
    }

    function asciiSlice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }
      return ret
    }

    function latin1Slice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret
    }

    function hexSlice (buf, start, end) {
      var len = buf.length;

      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;

      var out = '';
      for (var i = start; i < end; ++i) {
        out += toHex(buf[i]);
      }
      return out
    }

    function utf16leSlice (buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = '';
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res
    }

    Buffer.prototype.slice = function slice (start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;

      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }

      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }

      if (end < start) end = start;

      var newBuf;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer(sliceLen, undefined);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }

      return newBuf
    };

    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */
    function checkOffset (offset, ext, length) {
      if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    }

    Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      return val
    };

    Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }

      var val = this[offset + --byteLength];
      var mul = 1;
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }

      return val
    };

    Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset]
    };

    Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | (this[offset + 1] << 8)
    };

    Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return (this[offset] << 8) | this[offset + 1]
    };

    Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return ((this[offset]) |
          (this[offset + 1] << 8) |
          (this[offset + 2] << 16)) +
          (this[offset + 3] * 0x1000000)
    };

    Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] * 0x1000000) +
        ((this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        this[offset + 3])
    };

    Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return (this[offset])
      return ((0xff - this[offset] + 1) * -1)
    };

    Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | (this[offset + 1] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | (this[offset] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16) |
        (this[offset + 3] << 24)
    };

    Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] << 24) |
        (this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        (this[offset + 3])
    };

    Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, true, 23, 4)
    };

    Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, false, 23, 4)
    };

    Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, true, 52, 8)
    };

    Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, false, 52, 8)
    };

    function checkInt (buf, value, offset, ext, max, min) {
      if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
    }

    Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      this[offset] = (value & 0xff);
      return offset + 1
    };

    function objectWriteUInt16 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
        buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
          (littleEndian ? i : 1 - i) * 8;
      }
    }

    Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2
    };

    Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2
    };

    function objectWriteUInt32 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffffffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
        buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
      }
    }

    Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = (value >>> 24);
        this[offset + 2] = (value >>> 16);
        this[offset + 1] = (value >>> 8);
        this[offset] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4
    };

    Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4
    };

    Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = (value & 0xff);
      return offset + 1
    };

    Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2
    };

    Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2
    };

    Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
        this[offset + 2] = (value >>> 16);
        this[offset + 3] = (value >>> 24);
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4
    };

    Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4
    };

    function checkIEEE754 (buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
      if (offset < 0) throw new RangeError('Index out of range')
    }

    function writeFloat (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4
    }

    Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert)
    };

    Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert)
    };

    function writeDouble (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8
    }

    Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert)
    };

    Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert)
    };

    // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    Buffer.prototype.copy = function copy (target, targetStart, start, end) {
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;

      // Copy 0 bytes; we're done
      if (end === start) return 0
      if (target.length === 0 || this.length === 0) return 0

      // Fatal error conditions
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds')
      }
      if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
      if (end < 0) throw new RangeError('sourceEnd out of bounds')

      // Are we oob?
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }

      var len = end - start;
      var i;

      if (this === target && start < targetStart && targetStart < end) {
        // descending copy from end
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
        // ascending copy from start
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }

      return len
    };

    // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])
    Buffer.prototype.fill = function fill (val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string')
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding)
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      }

      // Invalid ranges are not set to a default, so can range check early.
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index')
      }

      if (end <= start) {
        return this
      }

      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;

      if (!val) val = 0;

      var i;
      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val)
          ? val
          : utf8ToBytes(new Buffer(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }

      return this
    };

    // HELPER FUNCTIONS
    // ================

    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

    function base64clean (str) {
      // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = stringtrim(str).replace(INVALID_BASE64_RE, '');
      // Node converts strings with length < 2 to ''
      if (str.length < 2) return ''
      // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
      while (str.length % 4 !== 0) {
        str = str + '=';
      }
      return str
    }

    function stringtrim (str) {
      if (str.trim) return str.trim()
      return str.replace(/^\s+|\s+$/g, '')
    }

    function toHex (n) {
      if (n < 16) return '0' + n.toString(16)
      return n.toString(16)
    }

    function utf8ToBytes (string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            }

            // valid lead
            leadSurrogate = codePoint;

            continue
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }

        leadSurrogate = null;

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          bytes.push(
            codePoint >> 0x6 | 0xC0,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          bytes.push(
            codePoint >> 0xC | 0xE0,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          bytes.push(
            codePoint >> 0x12 | 0xF0,
            codePoint >> 0xC & 0x3F | 0x80,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else {
          throw new Error('Invalid code point')
        }
      }

      return bytes
    }

    function asciiToBytes (str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }
      return byteArray
    }

    function utf16leToBytes (str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break

        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }

      return byteArray
    }


    function base64ToBytes (str) {
      return toByteArray(base64clean(str))
    }

    function blitBuffer (src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if ((i + offset >= dst.length) || (i >= src.length)) break
        dst[i + offset] = src[i];
      }
      return i
    }

    function isnan (val) {
      return val !== val // eslint-disable-line no-self-compare
    }


    // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
    // The _isBuffer check is for Safari 5-7 support, because it's missing
    // Object.prototype.constructor. Remove this eventually
    function isBuffer(obj) {
      return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
    }

    function isFastBuffer (obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
    }

    // For Node v0.10 support. Remove this eventually.
    function isSlowBuffer (obj) {
      return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
    }

    var sourcemapCodec_umd = {exports: {}};

    var hasRequiredSourcemapCodec_umd;

    function requireSourcemapCodec_umd () {
    	if (hasRequiredSourcemapCodec_umd) return sourcemapCodec_umd.exports;
    	hasRequiredSourcemapCodec_umd = 1;
    	(function (module, exports) {
    		(function (global, factory) {
    		    factory(exports) ;
    		})(commonjsGlobal, (function (exports) {
    		    const comma = ','.charCodeAt(0);
    		    const semicolon = ';'.charCodeAt(0);
    		    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    		    const intToChar = new Uint8Array(64); // 64 possible chars.
    		    const charToInt = new Uint8Array(128); // z is 122 in ASCII
    		    for (let i = 0; i < chars.length; i++) {
    		        const c = chars.charCodeAt(i);
    		        intToChar[i] = c;
    		        charToInt[c] = i;
    		    }
    		    // Provide a fallback for older environments.
    		    const td = typeof TextDecoder !== 'undefined'
    		        ? /* #__PURE__ */ new TextDecoder()
    		        : typeof Buffer !== 'undefined'
    		            ? {
    		                decode(buf) {
    		                    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
    		                    return out.toString();
    		                },
    		            }
    		            : {
    		                decode(buf) {
    		                    let out = '';
    		                    for (let i = 0; i < buf.length; i++) {
    		                        out += String.fromCharCode(buf[i]);
    		                    }
    		                    return out;
    		                },
    		            };
    		    function decode(mappings) {
    		        const state = new Int32Array(5);
    		        const decoded = [];
    		        let index = 0;
    		        do {
    		            const semi = indexOf(mappings, index);
    		            const line = [];
    		            let sorted = true;
    		            let lastCol = 0;
    		            state[0] = 0;
    		            for (let i = index; i < semi; i++) {
    		                let seg;
    		                i = decodeInteger(mappings, i, state, 0); // genColumn
    		                const col = state[0];
    		                if (col < lastCol)
    		                    sorted = false;
    		                lastCol = col;
    		                if (hasMoreVlq(mappings, i, semi)) {
    		                    i = decodeInteger(mappings, i, state, 1); // sourcesIndex
    		                    i = decodeInteger(mappings, i, state, 2); // sourceLine
    		                    i = decodeInteger(mappings, i, state, 3); // sourceColumn
    		                    if (hasMoreVlq(mappings, i, semi)) {
    		                        i = decodeInteger(mappings, i, state, 4); // namesIndex
    		                        seg = [col, state[1], state[2], state[3], state[4]];
    		                    }
    		                    else {
    		                        seg = [col, state[1], state[2], state[3]];
    		                    }
    		                }
    		                else {
    		                    seg = [col];
    		                }
    		                line.push(seg);
    		            }
    		            if (!sorted)
    		                sort(line);
    		            decoded.push(line);
    		            index = semi + 1;
    		        } while (index <= mappings.length);
    		        return decoded;
    		    }
    		    function indexOf(mappings, index) {
    		        const idx = mappings.indexOf(';', index);
    		        return idx === -1 ? mappings.length : idx;
    		    }
    		    function decodeInteger(mappings, pos, state, j) {
    		        let value = 0;
    		        let shift = 0;
    		        let integer = 0;
    		        do {
    		            const c = mappings.charCodeAt(pos++);
    		            integer = charToInt[c];
    		            value |= (integer & 31) << shift;
    		            shift += 5;
    		        } while (integer & 32);
    		        const shouldNegate = value & 1;
    		        value >>>= 1;
    		        if (shouldNegate) {
    		            value = -0x80000000 | -value;
    		        }
    		        state[j] += value;
    		        return pos;
    		    }
    		    function hasMoreVlq(mappings, i, length) {
    		        if (i >= length)
    		            return false;
    		        return mappings.charCodeAt(i) !== comma;
    		    }
    		    function sort(line) {
    		        line.sort(sortComparator);
    		    }
    		    function sortComparator(a, b) {
    		        return a[0] - b[0];
    		    }
    		    function encode(decoded) {
    		        const state = new Int32Array(5);
    		        const bufLength = 1024 * 16;
    		        const subLength = bufLength - 36;
    		        const buf = new Uint8Array(bufLength);
    		        const sub = buf.subarray(0, subLength);
    		        let pos = 0;
    		        let out = '';
    		        for (let i = 0; i < decoded.length; i++) {
    		            const line = decoded[i];
    		            if (i > 0) {
    		                if (pos === bufLength) {
    		                    out += td.decode(buf);
    		                    pos = 0;
    		                }
    		                buf[pos++] = semicolon;
    		            }
    		            if (line.length === 0)
    		                continue;
    		            state[0] = 0;
    		            for (let j = 0; j < line.length; j++) {
    		                const segment = line[j];
    		                // We can push up to 5 ints, each int can take at most 7 chars, and we
    		                // may push a comma.
    		                if (pos > subLength) {
    		                    out += td.decode(sub);
    		                    buf.copyWithin(0, subLength, pos);
    		                    pos -= subLength;
    		                }
    		                if (j > 0)
    		                    buf[pos++] = comma;
    		                pos = encodeInteger(buf, pos, state, segment, 0); // genColumn
    		                if (segment.length === 1)
    		                    continue;
    		                pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex
    		                pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine
    		                pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn
    		                if (segment.length === 4)
    		                    continue;
    		                pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex
    		            }
    		        }
    		        return out + td.decode(buf.subarray(0, pos));
    		    }
    		    function encodeInteger(buf, pos, state, segment, j) {
    		        const next = segment[j];
    		        let num = next - state[j];
    		        state[j] = next;
    		        num = num < 0 ? (-num << 1) | 1 : num << 1;
    		        do {
    		            let clamped = num & 0b011111;
    		            num >>>= 5;
    		            if (num > 0)
    		                clamped |= 0b100000;
    		            buf[pos++] = intToChar[clamped];
    		        } while (num > 0);
    		        return pos;
    		    }

    		    exports.decode = decode;
    		    exports.encode = encode;

    		    Object.defineProperty(exports, '__esModule', { value: true });

    		}));
    		
    	} (sourcemapCodec_umd, sourcemapCodec_umd.exports));
    	return sourcemapCodec_umd.exports;
    }

    var traceMapping_umd = {exports: {}};

    var resolveUri_umd = {exports: {}};

    var hasRequiredResolveUri_umd;

    function requireResolveUri_umd () {
    	if (hasRequiredResolveUri_umd) return resolveUri_umd.exports;
    	hasRequiredResolveUri_umd = 1;
    	(function (module, exports) {
    		(function (global, factory) {
    		    module.exports = factory() ;
    		})(commonjsGlobal, (function () {
    		    // Matches the scheme of a URL, eg "http://"
    		    const schemeRegex = /^[\w+.-]+:\/\//;
    		    /**
    		     * Matches the parts of a URL:
    		     * 1. Scheme, including ":", guaranteed.
    		     * 2. User/password, including "@", optional.
    		     * 3. Host, guaranteed.
    		     * 4. Port, including ":", optional.
    		     * 5. Path, including "/", optional.
    		     * 6. Query, including "?", optional.
    		     * 7. Hash, including "#", optional.
    		     */
    		    const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
    		    /**
    		     * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start
    		     * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).
    		     *
    		     * 1. Host, optional.
    		     * 2. Path, which may include "/", guaranteed.
    		     * 3. Query, including "?", optional.
    		     * 4. Hash, including "#", optional.
    		     */
    		    const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
    		    var UrlType;
    		    (function (UrlType) {
    		        UrlType[UrlType["Empty"] = 1] = "Empty";
    		        UrlType[UrlType["Hash"] = 2] = "Hash";
    		        UrlType[UrlType["Query"] = 3] = "Query";
    		        UrlType[UrlType["RelativePath"] = 4] = "RelativePath";
    		        UrlType[UrlType["AbsolutePath"] = 5] = "AbsolutePath";
    		        UrlType[UrlType["SchemeRelative"] = 6] = "SchemeRelative";
    		        UrlType[UrlType["Absolute"] = 7] = "Absolute";
    		    })(UrlType || (UrlType = {}));
    		    function isAbsoluteUrl(input) {
    		        return schemeRegex.test(input);
    		    }
    		    function isSchemeRelativeUrl(input) {
    		        return input.startsWith('//');
    		    }
    		    function isAbsolutePath(input) {
    		        return input.startsWith('/');
    		    }
    		    function isFileUrl(input) {
    		        return input.startsWith('file:');
    		    }
    		    function isRelative(input) {
    		        return /^[.?#]/.test(input);
    		    }
    		    function parseAbsoluteUrl(input) {
    		        const match = urlRegex.exec(input);
    		        return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');
    		    }
    		    function parseFileUrl(input) {
    		        const match = fileRegex.exec(input);
    		        const path = match[2];
    		        return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');
    		    }
    		    function makeUrl(scheme, user, host, port, path, query, hash) {
    		        return {
    		            scheme,
    		            user,
    		            host,
    		            port,
    		            path,
    		            query,
    		            hash,
    		            type: UrlType.Absolute,
    		        };
    		    }
    		    function parseUrl(input) {
    		        if (isSchemeRelativeUrl(input)) {
    		            const url = parseAbsoluteUrl('http:' + input);
    		            url.scheme = '';
    		            url.type = UrlType.SchemeRelative;
    		            return url;
    		        }
    		        if (isAbsolutePath(input)) {
    		            const url = parseAbsoluteUrl('http://foo.com' + input);
    		            url.scheme = '';
    		            url.host = '';
    		            url.type = UrlType.AbsolutePath;
    		            return url;
    		        }
    		        if (isFileUrl(input))
    		            return parseFileUrl(input);
    		        if (isAbsoluteUrl(input))
    		            return parseAbsoluteUrl(input);
    		        const url = parseAbsoluteUrl('http://foo.com/' + input);
    		        url.scheme = '';
    		        url.host = '';
    		        url.type = input
    		            ? input.startsWith('?')
    		                ? UrlType.Query
    		                : input.startsWith('#')
    		                    ? UrlType.Hash
    		                    : UrlType.RelativePath
    		            : UrlType.Empty;
    		        return url;
    		    }
    		    function stripPathFilename(path) {
    		        // If a path ends with a parent directory "..", then it's a relative path with excess parent
    		        // paths. It's not a file, so we can't strip it.
    		        if (path.endsWith('/..'))
    		            return path;
    		        const index = path.lastIndexOf('/');
    		        return path.slice(0, index + 1);
    		    }
    		    function mergePaths(url, base) {
    		        normalizePath(base, base.type);
    		        // If the path is just a "/", then it was an empty path to begin with (remember, we're a relative
    		        // path).
    		        if (url.path === '/') {
    		            url.path = base.path;
    		        }
    		        else {
    		            // Resolution happens relative to the base path's directory, not the file.
    		            url.path = stripPathFilename(base.path) + url.path;
    		        }
    		    }
    		    /**
    		     * The path can have empty directories "//", unneeded parents "foo/..", or current directory
    		     * "foo/.". We need to normalize to a standard representation.
    		     */
    		    function normalizePath(url, type) {
    		        const rel = type <= UrlType.RelativePath;
    		        const pieces = url.path.split('/');
    		        // We need to preserve the first piece always, so that we output a leading slash. The item at
    		        // pieces[0] is an empty string.
    		        let pointer = 1;
    		        // Positive is the number of real directories we've output, used for popping a parent directory.
    		        // Eg, "foo/bar/.." will have a positive 2, and we can decrement to be left with just "foo".
    		        let positive = 0;
    		        // We need to keep a trailing slash if we encounter an empty directory (eg, splitting "foo/" will
    		        // generate `["foo", ""]` pieces). And, if we pop a parent directory. But once we encounter a
    		        // real directory, we won't need to append, unless the other conditions happen again.
    		        let addTrailingSlash = false;
    		        for (let i = 1; i < pieces.length; i++) {
    		            const piece = pieces[i];
    		            // An empty directory, could be a trailing slash, or just a double "//" in the path.
    		            if (!piece) {
    		                addTrailingSlash = true;
    		                continue;
    		            }
    		            // If we encounter a real directory, then we don't need to append anymore.
    		            addTrailingSlash = false;
    		            // A current directory, which we can always drop.
    		            if (piece === '.')
    		                continue;
    		            // A parent directory, we need to see if there are any real directories we can pop. Else, we
    		            // have an excess of parents, and we'll need to keep the "..".
    		            if (piece === '..') {
    		                if (positive) {
    		                    addTrailingSlash = true;
    		                    positive--;
    		                    pointer--;
    		                }
    		                else if (rel) {
    		                    // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute
    		                    // URL, protocol relative URL, or an absolute path, we don't need to keep excess.
    		                    pieces[pointer++] = piece;
    		                }
    		                continue;
    		            }
    		            // We've encountered a real directory. Move it to the next insertion pointer, which accounts for
    		            // any popped or dropped directories.
    		            pieces[pointer++] = piece;
    		            positive++;
    		        }
    		        let path = '';
    		        for (let i = 1; i < pointer; i++) {
    		            path += '/' + pieces[i];
    		        }
    		        if (!path || (addTrailingSlash && !path.endsWith('/..'))) {
    		            path += '/';
    		        }
    		        url.path = path;
    		    }
    		    /**
    		     * Attempts to resolve `input` URL/path relative to `base`.
    		     */
    		    function resolve(input, base) {
    		        if (!input && !base)
    		            return '';
    		        const url = parseUrl(input);
    		        let inputType = url.type;
    		        if (base && inputType !== UrlType.Absolute) {
    		            const baseUrl = parseUrl(base);
    		            const baseType = baseUrl.type;
    		            switch (inputType) {
    		                case UrlType.Empty:
    		                    url.hash = baseUrl.hash;
    		                // fall through
    		                case UrlType.Hash:
    		                    url.query = baseUrl.query;
    		                // fall through
    		                case UrlType.Query:
    		                case UrlType.RelativePath:
    		                    mergePaths(url, baseUrl);
    		                // fall through
    		                case UrlType.AbsolutePath:
    		                    // The host, user, and port are joined, you can't copy one without the others.
    		                    url.user = baseUrl.user;
    		                    url.host = baseUrl.host;
    		                    url.port = baseUrl.port;
    		                // fall through
    		                case UrlType.SchemeRelative:
    		                    // The input doesn't have a schema at least, so we need to copy at least that over.
    		                    url.scheme = baseUrl.scheme;
    		            }
    		            if (baseType > inputType)
    		                inputType = baseType;
    		        }
    		        normalizePath(url, inputType);
    		        const queryHash = url.query + url.hash;
    		        switch (inputType) {
    		            // This is impossible, because of the empty checks at the start of the function.
    		            // case UrlType.Empty:
    		            case UrlType.Hash:
    		            case UrlType.Query:
    		                return queryHash;
    		            case UrlType.RelativePath: {
    		                // The first char is always a "/", and we need it to be relative.
    		                const path = url.path.slice(1);
    		                if (!path)
    		                    return queryHash || '.';
    		                if (isRelative(base || input) && !isRelative(path)) {
    		                    // If base started with a leading ".", or there is no base and input started with a ".",
    		                    // then we need to ensure that the relative path starts with a ".". We don't know if
    		                    // relative starts with a "..", though, so check before prepending.
    		                    return './' + path + queryHash;
    		                }
    		                return path + queryHash;
    		            }
    		            case UrlType.AbsolutePath:
    		                return url.path + queryHash;
    		            default:
    		                return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;
    		        }
    		    }

    		    return resolve;

    		}));
    		
    	} (resolveUri_umd));
    	return resolveUri_umd.exports;
    }

    var hasRequiredTraceMapping_umd;

    function requireTraceMapping_umd () {
    	if (hasRequiredTraceMapping_umd) return traceMapping_umd.exports;
    	hasRequiredTraceMapping_umd = 1;
    	(function (module, exports) {
    		(function (global, factory) {
    		    factory(exports, requireSourcemapCodec_umd(), requireResolveUri_umd()) ;
    		})(commonjsGlobal, (function (exports, sourcemapCodec, resolveUri) {
    		    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    		    var resolveUri__default = /*#__PURE__*/_interopDefaultLegacy(resolveUri);

    		    function resolve(input, base) {
    		        // The base is always treated as a directory, if it's not empty.
    		        // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327
    		        // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401
    		        if (base && !base.endsWith('/'))
    		            base += '/';
    		        return resolveUri__default["default"](input, base);
    		    }

    		    /**
    		     * Removes everything after the last "/", but leaves the slash.
    		     */
    		    function stripFilename(path) {
    		        if (!path)
    		            return '';
    		        const index = path.lastIndexOf('/');
    		        return path.slice(0, index + 1);
    		    }

    		    const COLUMN = 0;
    		    const SOURCES_INDEX = 1;
    		    const SOURCE_LINE = 2;
    		    const SOURCE_COLUMN = 3;
    		    const NAMES_INDEX = 4;
    		    const REV_GENERATED_LINE = 1;
    		    const REV_GENERATED_COLUMN = 2;

    		    function maybeSort(mappings, owned) {
    		        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
    		        if (unsortedIndex === mappings.length)
    		            return mappings;
    		        // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If
    		        // not, we do not want to modify the consumer's input array.
    		        if (!owned)
    		            mappings = mappings.slice();
    		        for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
    		            mappings[i] = sortSegments(mappings[i], owned);
    		        }
    		        return mappings;
    		    }
    		    function nextUnsortedSegmentLine(mappings, start) {
    		        for (let i = start; i < mappings.length; i++) {
    		            if (!isSorted(mappings[i]))
    		                return i;
    		        }
    		        return mappings.length;
    		    }
    		    function isSorted(line) {
    		        for (let j = 1; j < line.length; j++) {
    		            if (line[j][COLUMN] < line[j - 1][COLUMN]) {
    		                return false;
    		            }
    		        }
    		        return true;
    		    }
    		    function sortSegments(line, owned) {
    		        if (!owned)
    		            line = line.slice();
    		        return line.sort(sortComparator);
    		    }
    		    function sortComparator(a, b) {
    		        return a[COLUMN] - b[COLUMN];
    		    }

    		    let found = false;
    		    /**
    		     * A binary search implementation that returns the index if a match is found.
    		     * If no match is found, then the left-index (the index associated with the item that comes just
    		     * before the desired index) is returned. To maintain proper sort order, a splice would happen at
    		     * the next index:
    		     *
    		     * ```js
    		     * const array = [1, 3];
    		     * const needle = 2;
    		     * const index = binarySearch(array, needle, (item, needle) => item - needle);
    		     *
    		     * assert.equal(index, 0);
    		     * array.splice(index + 1, 0, needle);
    		     * assert.deepEqual(array, [1, 2, 3]);
    		     * ```
    		     */
    		    function binarySearch(haystack, needle, low, high) {
    		        while (low <= high) {
    		            const mid = low + ((high - low) >> 1);
    		            const cmp = haystack[mid][COLUMN] - needle;
    		            if (cmp === 0) {
    		                found = true;
    		                return mid;
    		            }
    		            if (cmp < 0) {
    		                low = mid + 1;
    		            }
    		            else {
    		                high = mid - 1;
    		            }
    		        }
    		        found = false;
    		        return low - 1;
    		    }
    		    function upperBound(haystack, needle, index) {
    		        for (let i = index + 1; i < haystack.length; index = i++) {
    		            if (haystack[i][COLUMN] !== needle)
    		                break;
    		        }
    		        return index;
    		    }
    		    function lowerBound(haystack, needle, index) {
    		        for (let i = index - 1; i >= 0; index = i--) {
    		            if (haystack[i][COLUMN] !== needle)
    		                break;
    		        }
    		        return index;
    		    }
    		    function memoizedState() {
    		        return {
    		            lastKey: -1,
    		            lastNeedle: -1,
    		            lastIndex: -1,
    		        };
    		    }
    		    /**
    		     * This overly complicated beast is just to record the last tested line/column and the resulting
    		     * index, allowing us to skip a few tests if mappings are monotonically increasing.
    		     */
    		    function memoizedBinarySearch(haystack, needle, state, key) {
    		        const { lastKey, lastNeedle, lastIndex } = state;
    		        let low = 0;
    		        let high = haystack.length - 1;
    		        if (key === lastKey) {
    		            if (needle === lastNeedle) {
    		                found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
    		                return lastIndex;
    		            }
    		            if (needle >= lastNeedle) {
    		                // lastIndex may be -1 if the previous needle was not found.
    		                low = lastIndex === -1 ? 0 : lastIndex;
    		            }
    		            else {
    		                high = lastIndex;
    		            }
    		        }
    		        state.lastKey = key;
    		        state.lastNeedle = needle;
    		        return (state.lastIndex = binarySearch(haystack, needle, low, high));
    		    }

    		    // Rebuilds the original source files, with mappings that are ordered by source line/column instead
    		    // of generated line/column.
    		    function buildBySources(decoded, memos) {
    		        const sources = memos.map(buildNullArray);
    		        for (let i = 0; i < decoded.length; i++) {
    		            const line = decoded[i];
    		            for (let j = 0; j < line.length; j++) {
    		                const seg = line[j];
    		                if (seg.length === 1)
    		                    continue;
    		                const sourceIndex = seg[SOURCES_INDEX];
    		                const sourceLine = seg[SOURCE_LINE];
    		                const sourceColumn = seg[SOURCE_COLUMN];
    		                const originalSource = sources[sourceIndex];
    		                const originalLine = (originalSource[sourceLine] || (originalSource[sourceLine] = []));
    		                const memo = memos[sourceIndex];
    		                // The binary search either found a match, or it found the left-index just before where the
    		                // segment should go. Either way, we want to insert after that. And there may be multiple
    		                // generated segments associated with an original location, so there may need to move several
    		                // indexes before we find where we need to insert.
    		                const index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
    		                insert(originalLine, (memo.lastIndex = index + 1), [sourceColumn, i, seg[COLUMN]]);
    		            }
    		        }
    		        return sources;
    		    }
    		    function insert(array, index, value) {
    		        for (let i = array.length; i > index; i--) {
    		            array[i] = array[i - 1];
    		        }
    		        array[index] = value;
    		    }
    		    // Null arrays allow us to use ordered index keys without actually allocating contiguous memory like
    		    // a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.
    		    // Numeric properties on objects are magically sorted in ascending order by the engine regardless of
    		    // the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending
    		    // order when iterating with for-in.
    		    function buildNullArray() {
    		        return { __proto__: null };
    		    }

    		    const AnyMap = function (map, mapUrl) {
    		        const parsed = typeof map === 'string' ? JSON.parse(map) : map;
    		        if (!('sections' in parsed))
    		            return new TraceMap(parsed, mapUrl);
    		        const mappings = [];
    		        const sources = [];
    		        const sourcesContent = [];
    		        const names = [];
    		        recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);
    		        const joined = {
    		            version: 3,
    		            file: parsed.file,
    		            names,
    		            sources,
    		            sourcesContent,
    		            mappings,
    		        };
    		        return exports.presortedDecodedMap(joined);
    		    };
    		    function recurse(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {
    		        const { sections } = input;
    		        for (let i = 0; i < sections.length; i++) {
    		            const { map, offset } = sections[i];
    		            let sl = stopLine;
    		            let sc = stopColumn;
    		            if (i + 1 < sections.length) {
    		                const nextOffset = sections[i + 1].offset;
    		                sl = Math.min(stopLine, lineOffset + nextOffset.line);
    		                if (sl === stopLine) {
    		                    sc = Math.min(stopColumn, columnOffset + nextOffset.column);
    		                }
    		                else if (sl < stopLine) {
    		                    sc = columnOffset + nextOffset.column;
    		                }
    		            }
    		            addSection(map, mapUrl, mappings, sources, sourcesContent, names, lineOffset + offset.line, columnOffset + offset.column, sl, sc);
    		        }
    		    }
    		    function addSection(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {
    		        if ('sections' in input)
    		            return recurse(...arguments);
    		        const map = new TraceMap(input, mapUrl);
    		        const sourcesOffset = sources.length;
    		        const namesOffset = names.length;
    		        const decoded = exports.decodedMappings(map);
    		        const { resolvedSources, sourcesContent: contents } = map;
    		        append(sources, resolvedSources);
    		        append(names, map.names);
    		        if (contents)
    		            append(sourcesContent, contents);
    		        else
    		            for (let i = 0; i < resolvedSources.length; i++)
    		                sourcesContent.push(null);
    		        for (let i = 0; i < decoded.length; i++) {
    		            const lineI = lineOffset + i;
    		            // We can only add so many lines before we step into the range that the next section's map
    		            // controls. When we get to the last line, then we'll start checking the segments to see if
    		            // they've crossed into the column range. But it may not have any columns that overstep, so we
    		            // still need to check that we don't overstep lines, too.
    		            if (lineI > stopLine)
    		                return;
    		            // The out line may already exist in mappings (if we're continuing the line started by a
    		            // previous section). Or, we may have jumped ahead several lines to start this section.
    		            const out = getLine(mappings, lineI);
    		            // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the
    		            // map can be multiple lines), it doesn't.
    		            const cOffset = i === 0 ? columnOffset : 0;
    		            const line = decoded[i];
    		            for (let j = 0; j < line.length; j++) {
    		                const seg = line[j];
    		                const column = cOffset + seg[COLUMN];
    		                // If this segment steps into the column range that the next section's map controls, we need
    		                // to stop early.
    		                if (lineI === stopLine && column >= stopColumn)
    		                    return;
    		                if (seg.length === 1) {
    		                    out.push([column]);
    		                    continue;
    		                }
    		                const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
    		                const sourceLine = seg[SOURCE_LINE];
    		                const sourceColumn = seg[SOURCE_COLUMN];
    		                out.push(seg.length === 4
    		                    ? [column, sourcesIndex, sourceLine, sourceColumn]
    		                    : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);
    		            }
    		        }
    		    }
    		    function append(arr, other) {
    		        for (let i = 0; i < other.length; i++)
    		            arr.push(other[i]);
    		    }
    		    function getLine(arr, index) {
    		        for (let i = arr.length; i <= index; i++)
    		            arr[i] = [];
    		        return arr[index];
    		    }

    		    const LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';
    		    const COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';
    		    const LEAST_UPPER_BOUND = -1;
    		    const GREATEST_LOWER_BOUND = 1;
    		    /**
    		     * Returns the encoded (VLQ string) form of the SourceMap's mappings field.
    		     */
    		    exports.encodedMappings = void 0;
    		    /**
    		     * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.
    		     */
    		    exports.decodedMappings = void 0;
    		    /**
    		     * A low-level API to find the segment associated with a generated line/column (think, from a
    		     * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.
    		     */
    		    exports.traceSegment = void 0;
    		    /**
    		     * A higher-level API to find the source/line/column associated with a generated line/column
    		     * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in
    		     * `source-map` library.
    		     */
    		    exports.originalPositionFor = void 0;
    		    /**
    		     * Finds the generated line/column position of the provided source/line/column source position.
    		     */
    		    exports.generatedPositionFor = void 0;
    		    /**
    		     * Finds all generated line/column positions of the provided source/line/column source position.
    		     */
    		    exports.allGeneratedPositionsFor = void 0;
    		    /**
    		     * Iterates each mapping in generated position order.
    		     */
    		    exports.eachMapping = void 0;
    		    /**
    		     * Retrieves the source content for a particular source, if its found. Returns null if not.
    		     */
    		    exports.sourceContentFor = void 0;
    		    /**
    		     * A helper that skips sorting of the input map's mappings array, which can be expensive for larger
    		     * maps.
    		     */
    		    exports.presortedDecodedMap = void 0;
    		    /**
    		     * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects
    		     * a sourcemap, or to JSON.stringify.
    		     */
    		    exports.decodedMap = void 0;
    		    /**
    		     * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects
    		     * a sourcemap, or to JSON.stringify.
    		     */
    		    exports.encodedMap = void 0;
    		    class TraceMap {
    		        constructor(map, mapUrl) {
    		            const isString = typeof map === 'string';
    		            if (!isString && map._decodedMemo)
    		                return map;
    		            const parsed = (isString ? JSON.parse(map) : map);
    		            const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
    		            this.version = version;
    		            this.file = file;
    		            this.names = names || [];
    		            this.sourceRoot = sourceRoot;
    		            this.sources = sources;
    		            this.sourcesContent = sourcesContent;
    		            const from = resolve(sourceRoot || '', stripFilename(mapUrl));
    		            this.resolvedSources = sources.map((s) => resolve(s || '', from));
    		            const { mappings } = parsed;
    		            if (typeof mappings === 'string') {
    		                this._encoded = mappings;
    		                this._decoded = undefined;
    		            }
    		            else {
    		                this._encoded = undefined;
    		                this._decoded = maybeSort(mappings, isString);
    		            }
    		            this._decodedMemo = memoizedState();
    		            this._bySources = undefined;
    		            this._bySourceMemos = undefined;
    		        }
    		    }
    		    (() => {
    		        exports.encodedMappings = (map) => {
    		            var _a;
    		            return ((_a = map._encoded) !== null && _a !== void 0 ? _a : (map._encoded = sourcemapCodec.encode(map._decoded)));
    		        };
    		        exports.decodedMappings = (map) => {
    		            return (map._decoded || (map._decoded = sourcemapCodec.decode(map._encoded)));
    		        };
    		        exports.traceSegment = (map, line, column) => {
    		            const decoded = exports.decodedMappings(map);
    		            // It's common for parent source maps to have pointers to lines that have no
    		            // mapping (like a "//# sourceMappingURL=") at the end of the child file.
    		            if (line >= decoded.length)
    		                return null;
    		            const segments = decoded[line];
    		            const index = traceSegmentInternal(segments, map._decodedMemo, line, column, GREATEST_LOWER_BOUND);
    		            return index === -1 ? null : segments[index];
    		        };
    		        exports.originalPositionFor = (map, { line, column, bias }) => {
    		            line--;
    		            if (line < 0)
    		                throw new Error(LINE_GTR_ZERO);
    		            if (column < 0)
    		                throw new Error(COL_GTR_EQ_ZERO);
    		            const decoded = exports.decodedMappings(map);
    		            // It's common for parent source maps to have pointers to lines that have no
    		            // mapping (like a "//# sourceMappingURL=") at the end of the child file.
    		            if (line >= decoded.length)
    		                return OMapping(null, null, null, null);
    		            const segments = decoded[line];
    		            const index = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
    		            if (index === -1)
    		                return OMapping(null, null, null, null);
    		            const segment = segments[index];
    		            if (segment.length === 1)
    		                return OMapping(null, null, null, null);
    		            const { names, resolvedSources } = map;
    		            return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
    		        };
    		        exports.allGeneratedPositionsFor = (map, { source, line, column, bias }) => {
    		            // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.
    		            return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);
    		        };
    		        exports.generatedPositionFor = (map, { source, line, column, bias }) => {
    		            return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);
    		        };
    		        exports.eachMapping = (map, cb) => {
    		            const decoded = exports.decodedMappings(map);
    		            const { names, resolvedSources } = map;
    		            for (let i = 0; i < decoded.length; i++) {
    		                const line = decoded[i];
    		                for (let j = 0; j < line.length; j++) {
    		                    const seg = line[j];
    		                    const generatedLine = i + 1;
    		                    const generatedColumn = seg[0];
    		                    let source = null;
    		                    let originalLine = null;
    		                    let originalColumn = null;
    		                    let name = null;
    		                    if (seg.length !== 1) {
    		                        source = resolvedSources[seg[1]];
    		                        originalLine = seg[2] + 1;
    		                        originalColumn = seg[3];
    		                    }
    		                    if (seg.length === 5)
    		                        name = names[seg[4]];
    		                    cb({
    		                        generatedLine,
    		                        generatedColumn,
    		                        source,
    		                        originalLine,
    		                        originalColumn,
    		                        name,
    		                    });
    		                }
    		            }
    		        };
    		        exports.sourceContentFor = (map, source) => {
    		            const { sources, resolvedSources, sourcesContent } = map;
    		            if (sourcesContent == null)
    		                return null;
    		            let index = sources.indexOf(source);
    		            if (index === -1)
    		                index = resolvedSources.indexOf(source);
    		            return index === -1 ? null : sourcesContent[index];
    		        };
    		        exports.presortedDecodedMap = (map, mapUrl) => {
    		            const tracer = new TraceMap(clone(map, []), mapUrl);
    		            tracer._decoded = map.mappings;
    		            return tracer;
    		        };
    		        exports.decodedMap = (map) => {
    		            return clone(map, exports.decodedMappings(map));
    		        };
    		        exports.encodedMap = (map) => {
    		            return clone(map, exports.encodedMappings(map));
    		        };
    		        function generatedPosition(map, source, line, column, bias, all) {
    		            line--;
    		            if (line < 0)
    		                throw new Error(LINE_GTR_ZERO);
    		            if (column < 0)
    		                throw new Error(COL_GTR_EQ_ZERO);
    		            const { sources, resolvedSources } = map;
    		            let sourceIndex = sources.indexOf(source);
    		            if (sourceIndex === -1)
    		                sourceIndex = resolvedSources.indexOf(source);
    		            if (sourceIndex === -1)
    		                return all ? [] : GMapping(null, null);
    		            const generated = (map._bySources || (map._bySources = buildBySources(exports.decodedMappings(map), (map._bySourceMemos = sources.map(memoizedState)))));
    		            const segments = generated[sourceIndex][line];
    		            if (segments == null)
    		                return all ? [] : GMapping(null, null);
    		            const memo = map._bySourceMemos[sourceIndex];
    		            if (all)
    		                return sliceGeneratedPositions(segments, memo, line, column, bias);
    		            const index = traceSegmentInternal(segments, memo, line, column, bias);
    		            if (index === -1)
    		                return GMapping(null, null);
    		            const segment = segments[index];
    		            return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
    		        }
    		    })();
    		    function clone(map, mappings) {
    		        return {
    		            version: map.version,
    		            file: map.file,
    		            names: map.names,
    		            sourceRoot: map.sourceRoot,
    		            sources: map.sources,
    		            sourcesContent: map.sourcesContent,
    		            mappings,
    		        };
    		    }
    		    function OMapping(source, line, column, name) {
    		        return { source, line, column, name };
    		    }
    		    function GMapping(line, column) {
    		        return { line, column };
    		    }
    		    function traceSegmentInternal(segments, memo, line, column, bias) {
    		        let index = memoizedBinarySearch(segments, column, memo, line);
    		        if (found) {
    		            index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
    		        }
    		        else if (bias === LEAST_UPPER_BOUND)
    		            index++;
    		        if (index === -1 || index === segments.length)
    		            return -1;
    		        return index;
    		    }
    		    function sliceGeneratedPositions(segments, memo, line, column, bias) {
    		        let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);
    		        // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in
    		        // insertion order) segment that matched. Even if we did respect the bias when tracing, we would
    		        // still need to call `lowerBound()` to find the first segment, which is slower than just looking
    		        // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the
    		        // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to
    		        // match LEAST_UPPER_BOUND.
    		        if (!found && bias === LEAST_UPPER_BOUND)
    		            min++;
    		        if (min === -1 || min === segments.length)
    		            return [];
    		        // We may have found the segment that started at an earlier column. If this is the case, then we
    		        // need to slice all generated segments that match _that_ column, because all such segments span
    		        // to our desired column.
    		        const matchedColumn = found ? column : segments[min][COLUMN];
    		        // The binary search is not guaranteed to find the lower bound when a match wasn't found.
    		        if (!found)
    		            min = lowerBound(segments, matchedColumn, min);
    		        const max = upperBound(segments, matchedColumn, min);
    		        const result = [];
    		        for (; min <= max; min++) {
    		            const segment = segments[min];
    		            result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
    		        }
    		        return result;
    		    }

    		    exports.AnyMap = AnyMap;
    		    exports.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;
    		    exports.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;
    		    exports.TraceMap = TraceMap;

    		    Object.defineProperty(exports, '__esModule', { value: true });

    		}));
    		
    	} (traceMapping_umd, traceMapping_umd.exports));
    	return traceMapping_umd.exports;
    }

    var hasRequiredGenMapping_umd;

    function requireGenMapping_umd () {
    	if (hasRequiredGenMapping_umd) return genMapping_umd.exports;
    	hasRequiredGenMapping_umd = 1;
    	(function (module, exports) {
    		(function (global, factory) {
    		    factory(exports, requireSetArray_umd(), requireSourcemapCodec_umd(), requireTraceMapping_umd()) ;
    		})(commonjsGlobal, (function (exports, setArray, sourcemapCodec, traceMapping) {
    		    const COLUMN = 0;
    		    const SOURCES_INDEX = 1;
    		    const SOURCE_LINE = 2;
    		    const SOURCE_COLUMN = 3;
    		    const NAMES_INDEX = 4;

    		    const NO_NAME = -1;
    		    /**
    		     * A low-level API to associate a generated position with an original source position. Line and
    		     * column here are 0-based, unlike `addMapping`.
    		     */
    		    exports.addSegment = void 0;
    		    /**
    		     * A high-level API to associate a generated position with an original source position. Line is
    		     * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.
    		     */
    		    exports.addMapping = void 0;
    		    /**
    		     * Same as `addSegment`, but will only add the segment if it generates useful information in the
    		     * resulting map. This only works correctly if segments are added **in order**, meaning you should
    		     * not add a segment with a lower generated line/column than one that came before.
    		     */
    		    exports.maybeAddSegment = void 0;
    		    /**
    		     * Same as `addMapping`, but will only add the mapping if it generates useful information in the
    		     * resulting map. This only works correctly if mappings are added **in order**, meaning you should
    		     * not add a mapping with a lower generated line/column than one that came before.
    		     */
    		    exports.maybeAddMapping = void 0;
    		    /**
    		     * Adds/removes the content of the source file to the source map.
    		     */
    		    exports.setSourceContent = void 0;
    		    /**
    		     * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects
    		     * a sourcemap, or to JSON.stringify.
    		     */
    		    exports.toDecodedMap = void 0;
    		    /**
    		     * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects
    		     * a sourcemap, or to JSON.stringify.
    		     */
    		    exports.toEncodedMap = void 0;
    		    /**
    		     * Constructs a new GenMapping, using the already present mappings of the input.
    		     */
    		    exports.fromMap = void 0;
    		    /**
    		     * Returns an array of high-level mapping objects for every recorded segment, which could then be
    		     * passed to the `source-map` library.
    		     */
    		    exports.allMappings = void 0;
    		    // This split declaration is only so that terser can elminiate the static initialization block.
    		    let addSegmentInternal;
    		    /**
    		     * Provides the state to generate a sourcemap.
    		     */
    		    class GenMapping {
    		        constructor({ file, sourceRoot } = {}) {
    		            this._names = new setArray.SetArray();
    		            this._sources = new setArray.SetArray();
    		            this._sourcesContent = [];
    		            this._mappings = [];
    		            this.file = file;
    		            this.sourceRoot = sourceRoot;
    		        }
    		    }
    		    (() => {
    		        exports.addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
    		            return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
    		        };
    		        exports.maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
    		            return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
    		        };
    		        exports.addMapping = (map, mapping) => {
    		            return addMappingInternal(false, map, mapping);
    		        };
    		        exports.maybeAddMapping = (map, mapping) => {
    		            return addMappingInternal(true, map, mapping);
    		        };
    		        exports.setSourceContent = (map, source, content) => {
    		            const { _sources: sources, _sourcesContent: sourcesContent } = map;
    		            sourcesContent[setArray.put(sources, source)] = content;
    		        };
    		        exports.toDecodedMap = (map) => {
    		            const { file, sourceRoot, _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, } = map;
    		            removeEmptyFinalLines(mappings);
    		            return {
    		                version: 3,
    		                file: file || undefined,
    		                names: names.array,
    		                sourceRoot: sourceRoot || undefined,
    		                sources: sources.array,
    		                sourcesContent,
    		                mappings,
    		            };
    		        };
    		        exports.toEncodedMap = (map) => {
    		            const decoded = exports.toDecodedMap(map);
    		            return Object.assign(Object.assign({}, decoded), { mappings: sourcemapCodec.encode(decoded.mappings) });
    		        };
    		        exports.allMappings = (map) => {
    		            const out = [];
    		            const { _mappings: mappings, _sources: sources, _names: names } = map;
    		            for (let i = 0; i < mappings.length; i++) {
    		                const line = mappings[i];
    		                for (let j = 0; j < line.length; j++) {
    		                    const seg = line[j];
    		                    const generated = { line: i + 1, column: seg[COLUMN] };
    		                    let source = undefined;
    		                    let original = undefined;
    		                    let name = undefined;
    		                    if (seg.length !== 1) {
    		                        source = sources.array[seg[SOURCES_INDEX]];
    		                        original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };
    		                        if (seg.length === 5)
    		                            name = names.array[seg[NAMES_INDEX]];
    		                    }
    		                    out.push({ generated, source, original, name });
    		                }
    		            }
    		            return out;
    		        };
    		        exports.fromMap = (input) => {
    		            const map = new traceMapping.TraceMap(input);
    		            const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });
    		            putAll(gen._names, map.names);
    		            putAll(gen._sources, map.sources);
    		            gen._sourcesContent = map.sourcesContent || map.sources.map(() => null);
    		            gen._mappings = traceMapping.decodedMappings(map);
    		            return gen;
    		        };
    		        // Internal helpers
    		        addSegmentInternal = (skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
    		            const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, } = map;
    		            const line = getLine(mappings, genLine);
    		            const index = getColumnIndex(line, genColumn);
    		            if (!source) {
    		                if (skipable && skipSourceless(line, index))
    		                    return;
    		                return insert(line, index, [genColumn]);
    		            }
    		            const sourcesIndex = setArray.put(sources, source);
    		            const namesIndex = name ? setArray.put(names, name) : NO_NAME;
    		            if (sourcesIndex === sourcesContent.length)
    		                sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;
    		            if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
    		                return;
    		            }
    		            return insert(line, index, name
    		                ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]
    		                : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
    		        };
    		    })();
    		    function getLine(mappings, index) {
    		        for (let i = mappings.length; i <= index; i++) {
    		            mappings[i] = [];
    		        }
    		        return mappings[index];
    		    }
    		    function getColumnIndex(line, genColumn) {
    		        let index = line.length;
    		        for (let i = index - 1; i >= 0; index = i--) {
    		            const current = line[i];
    		            if (genColumn >= current[COLUMN])
    		                break;
    		        }
    		        return index;
    		    }
    		    function insert(array, index, value) {
    		        for (let i = array.length; i > index; i--) {
    		            array[i] = array[i - 1];
    		        }
    		        array[index] = value;
    		    }
    		    function removeEmptyFinalLines(mappings) {
    		        const { length } = mappings;
    		        let len = length;
    		        for (let i = len - 1; i >= 0; len = i, i--) {
    		            if (mappings[i].length > 0)
    		                break;
    		        }
    		        if (len < length)
    		            mappings.length = len;
    		    }
    		    function putAll(strarr, array) {
    		        for (let i = 0; i < array.length; i++)
    		            setArray.put(strarr, array[i]);
    		    }
    		    function skipSourceless(line, index) {
    		        // The start of a line is already sourceless, so adding a sourceless segment to the beginning
    		        // doesn't generate any useful information.
    		        if (index === 0)
    		            return true;
    		        const prev = line[index - 1];
    		        // If the previous segment is also sourceless, then adding another sourceless segment doesn't
    		        // genrate any new information. Else, this segment will end the source/named segment and point to
    		        // a sourceless position, which is useful.
    		        return prev.length === 1;
    		    }
    		    function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
    		        // A source/named segment at the start of a line gives position at that genColumn
    		        if (index === 0)
    		            return false;
    		        const prev = line[index - 1];
    		        // If the previous segment is sourceless, then we're transitioning to a source.
    		        if (prev.length === 1)
    		            return false;
    		        // If the previous segment maps to the exact same source position, then this segment doesn't
    		        // provide any new position information.
    		        return (sourcesIndex === prev[SOURCES_INDEX] &&
    		            sourceLine === prev[SOURCE_LINE] &&
    		            sourceColumn === prev[SOURCE_COLUMN] &&
    		            namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME));
    		    }
    		    function addMappingInternal(skipable, map, mapping) {
    		        const { generated, source, original, name, content } = mapping;
    		        if (!source) {
    		            return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
    		        }
    		        const s = source;
    		        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, s, original.line - 1, original.column, name, content);
    		    }

    		    exports.GenMapping = GenMapping;

    		    Object.defineProperty(exports, '__esModule', { value: true });

    		}));
    		
    	} (genMapping_umd, genMapping_umd.exports));
    	return genMapping_umd.exports;
    }

    var hasRequiredSourceMap;

    function requireSourceMap () {
    	if (hasRequiredSourceMap) return sourceMap;
    	hasRequiredSourceMap = 1;

    	Object.defineProperty(sourceMap, "__esModule", {
    	  value: true
    	});
    	sourceMap.default = void 0;
    	var _genMapping = requireGenMapping_umd();
    	var _traceMapping = requireTraceMapping_umd();
    	class SourceMap {
    	  constructor(opts, code) {
    	    var _opts$sourceFileName;
    	    this._map = void 0;
    	    this._rawMappings = void 0;
    	    this._sourceFileName = void 0;
    	    this._lastGenLine = 0;
    	    this._lastSourceLine = 0;
    	    this._lastSourceColumn = 0;
    	    this._inputMap = void 0;
    	    const map = this._map = new _genMapping.GenMapping({
    	      sourceRoot: opts.sourceRoot
    	    });
    	    this._sourceFileName = (_opts$sourceFileName = opts.sourceFileName) == null ? void 0 : _opts$sourceFileName.replace(/\\/g, "/");
    	    this._rawMappings = undefined;
    	    if (opts.inputSourceMap) {
    	      this._inputMap = new _traceMapping.TraceMap(opts.inputSourceMap);
    	      const resolvedSources = this._inputMap.resolvedSources;
    	      if (resolvedSources.length) {
    	        for (let i = 0; i < resolvedSources.length; i++) {
    	          var _this$_inputMap$sourc;
    	          (0, _genMapping.setSourceContent)(map, resolvedSources[i], (_this$_inputMap$sourc = this._inputMap.sourcesContent) == null ? void 0 : _this$_inputMap$sourc[i]);
    	        }
    	      }
    	    }
    	    if (typeof code === "string" && !opts.inputSourceMap) {
    	      (0, _genMapping.setSourceContent)(map, this._sourceFileName, code);
    	    } else if (typeof code === "object") {
    	      for (const sourceFileName of Object.keys(code)) {
    	        (0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
    	      }
    	    }
    	  }
    	  get() {
    	    return (0, _genMapping.toEncodedMap)(this._map);
    	  }
    	  getDecoded() {
    	    return (0, _genMapping.toDecodedMap)(this._map);
    	  }
    	  getRawMappings() {
    	    return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));
    	  }
    	  mark(generated, line, column, identifierName, identifierNamePos, filename) {
    	    var _originalMapping;
    	    this._rawMappings = undefined;
    	    let originalMapping;
    	    if (line != null) {
    	      if (this._inputMap) {
    	        originalMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, {
    	          line,
    	          column
    	        });
    	        if (!originalMapping.name && identifierNamePos) {
    	          const originalIdentifierMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, identifierNamePos);
    	          if (originalIdentifierMapping.name) {
    	            identifierName = originalIdentifierMapping.name;
    	          }
    	        }
    	      } else {
    	        originalMapping = {
    	          source: (filename == null ? void 0 : filename.replace(/\\/g, "/")) || this._sourceFileName,
    	          line: line,
    	          column: column
    	        };
    	      }
    	    }
    	    (0, _genMapping.maybeAddMapping)(this._map, {
    	      name: identifierName,
    	      generated,
    	      source: (_originalMapping = originalMapping) == null ? void 0 : _originalMapping.source,
    	      original: originalMapping
    	    });
    	  }
    	}
    	sourceMap.default = SourceMap;

    	
    	return sourceMap;
    }

    var printer = {};

    var buffer = {};

    var hasRequiredBuffer;

    function requireBuffer () {
    	if (hasRequiredBuffer) return buffer;
    	hasRequiredBuffer = 1;

    	Object.defineProperty(buffer, "__esModule", {
    	  value: true
    	});
    	buffer.default = void 0;
    	class Buffer {
    	  constructor(map) {
    	    this._map = null;
    	    this._buf = "";
    	    this._str = "";
    	    this._appendCount = 0;
    	    this._last = 0;
    	    this._queue = [];
    	    this._queueCursor = 0;
    	    this._canMarkIdName = true;
    	    this._position = {
    	      line: 1,
    	      column: 0
    	    };
    	    this._sourcePosition = {
    	      identifierName: undefined,
    	      identifierNamePos: undefined,
    	      line: undefined,
    	      column: undefined,
    	      filename: undefined
    	    };
    	    this._map = map;
    	    this._allocQueue();
    	  }
    	  _allocQueue() {
    	    const queue = this._queue;
    	    for (let i = 0; i < 16; i++) {
    	      queue.push({
    	        char: 0,
    	        repeat: 1,
    	        line: undefined,
    	        column: undefined,
    	        identifierName: undefined,
    	        identifierNamePos: undefined,
    	        filename: ""
    	      });
    	    }
    	  }
    	  _pushQueue(char, repeat, line, column, filename) {
    	    const cursor = this._queueCursor;
    	    if (cursor === this._queue.length) {
    	      this._allocQueue();
    	    }
    	    const item = this._queue[cursor];
    	    item.char = char;
    	    item.repeat = repeat;
    	    item.line = line;
    	    item.column = column;
    	    item.filename = filename;
    	    this._queueCursor++;
    	  }
    	  _popQueue() {
    	    if (this._queueCursor === 0) {
    	      throw new Error("Cannot pop from empty queue");
    	    }
    	    return this._queue[--this._queueCursor];
    	  }
    	  get() {
    	    this._flush();
    	    const map = this._map;
    	    const result = {
    	      code: (this._buf + this._str).trimRight(),
    	      decodedMap: map == null ? void 0 : map.getDecoded(),
    	      get __mergedMap() {
    	        return this.map;
    	      },
    	      get map() {
    	        const resultMap = map ? map.get() : null;
    	        result.map = resultMap;
    	        return resultMap;
    	      },
    	      set map(value) {
    	        Object.defineProperty(result, "map", {
    	          value,
    	          writable: true
    	        });
    	      },
    	      get rawMappings() {
    	        const mappings = map == null ? void 0 : map.getRawMappings();
    	        result.rawMappings = mappings;
    	        return mappings;
    	      },
    	      set rawMappings(value) {
    	        Object.defineProperty(result, "rawMappings", {
    	          value,
    	          writable: true
    	        });
    	      }
    	    };
    	    return result;
    	  }
    	  append(str, maybeNewline) {
    	    this._flush();
    	    this._append(str, this._sourcePosition, maybeNewline);
    	  }
    	  appendChar(char) {
    	    this._flush();
    	    this._appendChar(char, 1, this._sourcePosition);
    	  }
    	  queue(char) {
    	    if (char === 10) {
    	      while (this._queueCursor !== 0) {
    	        const char = this._queue[this._queueCursor - 1].char;
    	        if (char !== 32 && char !== 9) {
    	          break;
    	        }
    	        this._queueCursor--;
    	      }
    	    }
    	    const sourcePosition = this._sourcePosition;
    	    this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);
    	  }
    	  queueIndentation(char, repeat) {
    	    this._pushQueue(char, repeat, undefined, undefined, undefined);
    	  }
    	  _flush() {
    	    const queueCursor = this._queueCursor;
    	    const queue = this._queue;
    	    for (let i = 0; i < queueCursor; i++) {
    	      const item = queue[i];
    	      this._appendChar(item.char, item.repeat, item);
    	    }
    	    this._queueCursor = 0;
    	  }
    	  _appendChar(char, repeat, sourcePos) {
    	    this._last = char;
    	    this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char);
    	    if (char !== 10) {
    	      this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename);
    	      this._position.column += repeat;
    	    } else {
    	      this._position.line++;
    	      this._position.column = 0;
    	    }
    	    if (this._canMarkIdName) {
    	      sourcePos.identifierName = undefined;
    	      sourcePos.identifierNamePos = undefined;
    	    }
    	  }
    	  _append(str, sourcePos, maybeNewline) {
    	    const len = str.length;
    	    const position = this._position;
    	    this._last = str.charCodeAt(len - 1);
    	    if (++this._appendCount > 4096) {
    	      +this._str;
    	      this._buf += this._str;
    	      this._str = str;
    	      this._appendCount = 0;
    	    } else {
    	      this._str += str;
    	    }
    	    if (!maybeNewline && !this._map) {
    	      position.column += len;
    	      return;
    	    }
    	    const {
    	      column,
    	      identifierName,
    	      identifierNamePos,
    	      filename
    	    } = sourcePos;
    	    let line = sourcePos.line;
    	    if ((identifierName != null || identifierNamePos != null) && this._canMarkIdName) {
    	      sourcePos.identifierName = undefined;
    	      sourcePos.identifierNamePos = undefined;
    	    }
    	    let i = str.indexOf("\n");
    	    let last = 0;
    	    if (i !== 0) {
    	      this._mark(line, column, identifierName, identifierNamePos, filename);
    	    }
    	    while (i !== -1) {
    	      position.line++;
    	      position.column = 0;
    	      last = i + 1;
    	      if (last < len && line !== undefined) {
    	        this._mark(++line, 0, null, null, filename);
    	      }
    	      i = str.indexOf("\n", last);
    	    }
    	    position.column += len - last;
    	  }
    	  _mark(line, column, identifierName, identifierNamePos, filename) {
    	    var _this$_map;
    	    (_this$_map = this._map) == null ? void 0 : _this$_map.mark(this._position, line, column, identifierName, identifierNamePos, filename);
    	  }
    	  removeTrailingNewline() {
    	    const queueCursor = this._queueCursor;
    	    if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {
    	      this._queueCursor--;
    	    }
    	  }
    	  removeLastSemicolon() {
    	    const queueCursor = this._queueCursor;
    	    if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {
    	      this._queueCursor--;
    	    }
    	  }
    	  getLastChar() {
    	    const queueCursor = this._queueCursor;
    	    return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;
    	  }
    	  getNewlineCount() {
    	    const queueCursor = this._queueCursor;
    	    let count = 0;
    	    if (queueCursor === 0) return this._last === 10 ? 1 : 0;
    	    for (let i = queueCursor - 1; i >= 0; i--) {
    	      if (this._queue[i].char !== 10) {
    	        break;
    	      }
    	      count++;
    	    }
    	    return count === queueCursor && this._last === 10 ? count + 1 : count;
    	  }
    	  endsWithCharAndNewline() {
    	    const queue = this._queue;
    	    const queueCursor = this._queueCursor;
    	    if (queueCursor !== 0) {
    	      const lastCp = queue[queueCursor - 1].char;
    	      if (lastCp !== 10) return;
    	      if (queueCursor > 1) {
    	        return queue[queueCursor - 2].char;
    	      } else {
    	        return this._last;
    	      }
    	    }
    	  }
    	  hasContent() {
    	    return this._queueCursor !== 0 || !!this._last;
    	  }
    	  exactSource(loc, cb) {
    	    if (!this._map) {
    	      cb();
    	      return;
    	    }
    	    this.source("start", loc);
    	    const identifierName = loc.identifierName;
    	    const sourcePos = this._sourcePosition;
    	    if (identifierName) {
    	      this._canMarkIdName = false;
    	      sourcePos.identifierName = identifierName;
    	    }
    	    cb();
    	    if (identifierName) {
    	      this._canMarkIdName = true;
    	      sourcePos.identifierName = undefined;
    	      sourcePos.identifierNamePos = undefined;
    	    }
    	    this.source("end", loc);
    	  }
    	  source(prop, loc) {
    	    if (!this._map) return;
    	    this._normalizePosition(prop, loc, 0);
    	  }
    	  sourceWithOffset(prop, loc, columnOffset) {
    	    if (!this._map) return;
    	    this._normalizePosition(prop, loc, columnOffset);
    	  }
    	  withSource(prop, loc, cb) {
    	    if (this._map) {
    	      this.source(prop, loc);
    	    }
    	    cb();
    	  }
    	  _normalizePosition(prop, loc, columnOffset) {
    	    const pos = loc[prop];
    	    const target = this._sourcePosition;
    	    if (pos) {
    	      target.line = pos.line;
    	      target.column = Math.max(pos.column + columnOffset, 0);
    	      target.filename = loc.filename;
    	    }
    	  }
    	  getCurrentColumn() {
    	    const queue = this._queue;
    	    const queueCursor = this._queueCursor;
    	    let lastIndex = -1;
    	    let len = 0;
    	    for (let i = 0; i < queueCursor; i++) {
    	      const item = queue[i];
    	      if (item.char === 10) {
    	        lastIndex = len;
    	      }
    	      len += item.repeat;
    	    }
    	    return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;
    	  }
    	  getCurrentLine() {
    	    let count = 0;
    	    const queue = this._queue;
    	    for (let i = 0; i < this._queueCursor; i++) {
    	      if (queue[i].char === 10) {
    	        count++;
    	      }
    	    }
    	    return this._position.line + count;
    	  }
    	}
    	buffer.default = Buffer;

    	
    	return buffer;
    }

    var node = {};

    var whitespace = {};

    var hasRequiredWhitespace;

    function requireWhitespace () {
    	if (hasRequiredWhitespace) return whitespace;
    	hasRequiredWhitespace = 1;

    	Object.defineProperty(whitespace, "__esModule", {
    	  value: true
    	});
    	whitespace.nodes = void 0;
    	var _t = requireLib$2();
    	const {
    	  FLIPPED_ALIAS_KEYS,
    	  isArrayExpression,
    	  isAssignmentExpression,
    	  isBinary,
    	  isBlockStatement,
    	  isCallExpression,
    	  isFunction,
    	  isIdentifier,
    	  isLiteral,
    	  isMemberExpression,
    	  isObjectExpression,
    	  isOptionalCallExpression,
    	  isOptionalMemberExpression,
    	  isStringLiteral
    	} = _t;
    	function crawlInternal(node, state) {
    	  if (!node) return state;
    	  if (isMemberExpression(node) || isOptionalMemberExpression(node)) {
    	    crawlInternal(node.object, state);
    	    if (node.computed) crawlInternal(node.property, state);
    	  } else if (isBinary(node) || isAssignmentExpression(node)) {
    	    crawlInternal(node.left, state);
    	    crawlInternal(node.right, state);
    	  } else if (isCallExpression(node) || isOptionalCallExpression(node)) {
    	    state.hasCall = true;
    	    crawlInternal(node.callee, state);
    	  } else if (isFunction(node)) {
    	    state.hasFunction = true;
    	  } else if (isIdentifier(node)) {
    	    state.hasHelper = state.hasHelper || node.callee && isHelper(node.callee);
    	  }
    	  return state;
    	}
    	function crawl(node) {
    	  return crawlInternal(node, {
    	    hasCall: false,
    	    hasFunction: false,
    	    hasHelper: false
    	  });
    	}
    	function isHelper(node) {
    	  if (!node) return false;
    	  if (isMemberExpression(node)) {
    	    return isHelper(node.object) || isHelper(node.property);
    	  } else if (isIdentifier(node)) {
    	    return node.name === "require" || node.name.charCodeAt(0) === 95;
    	  } else if (isCallExpression(node)) {
    	    return isHelper(node.callee);
    	  } else if (isBinary(node) || isAssignmentExpression(node)) {
    	    return isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);
    	  } else {
    	    return false;
    	  }
    	}
    	function isType(node) {
    	  return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression(node);
    	}
    	const nodes = {
    	  AssignmentExpression(node) {
    	    const state = crawl(node.right);
    	    if (state.hasCall && state.hasHelper || state.hasFunction) {
    	      return state.hasFunction ? 1 | 2 : 2;
    	    }
    	  },
    	  SwitchCase(node, parent) {
    	    return (!!node.consequent.length || parent.cases[0] === node ? 1 : 0) | (!node.consequent.length && parent.cases[parent.cases.length - 1] === node ? 2 : 0);
    	  },
    	  LogicalExpression(node) {
    	    if (isFunction(node.left) || isFunction(node.right)) {
    	      return 2;
    	    }
    	  },
    	  Literal(node) {
    	    if (isStringLiteral(node) && node.value === "use strict") {
    	      return 2;
    	    }
    	  },
    	  CallExpression(node) {
    	    if (isFunction(node.callee) || isHelper(node)) {
    	      return 1 | 2;
    	    }
    	  },
    	  OptionalCallExpression(node) {
    	    if (isFunction(node.callee)) {
    	      return 1 | 2;
    	    }
    	  },
    	  VariableDeclaration(node) {
    	    for (let i = 0; i < node.declarations.length; i++) {
    	      const declar = node.declarations[i];
    	      let enabled = isHelper(declar.id) && !isType(declar.init);
    	      if (!enabled && declar.init) {
    	        const state = crawl(declar.init);
    	        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
    	      }
    	      if (enabled) {
    	        return 1 | 2;
    	      }
    	    }
    	  },
    	  IfStatement(node) {
    	    if (isBlockStatement(node.consequent)) {
    	      return 1 | 2;
    	    }
    	  }
    	};
    	whitespace.nodes = nodes;
    	nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {
    	  if (parent.properties[0] === node) {
    	    return 1;
    	  }
    	};
    	nodes.ObjectTypeCallProperty = function (node, parent) {
    	  var _parent$properties;
    	  if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {
    	    return 1;
    	  }
    	};
    	nodes.ObjectTypeIndexer = function (node, parent) {
    	  var _parent$properties2, _parent$callPropertie;
    	  if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {
    	    return 1;
    	  }
    	};
    	nodes.ObjectTypeInternalSlot = function (node, parent) {
    	  var _parent$properties3, _parent$callPropertie2, _parent$indexers;
    	  if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {
    	    return 1;
    	  }
    	};
    	[["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function ([type, amounts]) {
    	  [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {
    	    const ret = amounts ? 1 | 2 : 0;
    	    nodes[type] = () => ret;
    	  });
    	});

    	
    	return whitespace;
    }

    var parentheses = {};

    var hasRequiredParentheses;

    function requireParentheses () {
    	if (hasRequiredParentheses) return parentheses;
    	hasRequiredParentheses = 1;

    	Object.defineProperty(parentheses, "__esModule", {
    	  value: true
    	});
    	parentheses.ArrowFunctionExpression = ArrowFunctionExpression;
    	parentheses.AssignmentExpression = AssignmentExpression;
    	parentheses.Binary = Binary;
    	parentheses.BinaryExpression = BinaryExpression;
    	parentheses.ClassExpression = ClassExpression;
    	parentheses.ConditionalExpression = ConditionalExpression;
    	parentheses.DoExpression = DoExpression;
    	parentheses.FunctionExpression = FunctionExpression;
    	parentheses.FunctionTypeAnnotation = FunctionTypeAnnotation;
    	parentheses.Identifier = Identifier;
    	parentheses.LogicalExpression = LogicalExpression;
    	parentheses.NullableTypeAnnotation = NullableTypeAnnotation;
    	parentheses.ObjectExpression = ObjectExpression;
    	parentheses.OptionalIndexedAccessType = OptionalIndexedAccessType;
    	parentheses.OptionalCallExpression = parentheses.OptionalMemberExpression = OptionalMemberExpression;
    	parentheses.SequenceExpression = SequenceExpression;
    	parentheses.TSTypeAssertion = parentheses.TSSatisfiesExpression = parentheses.TSAsExpression = TSAsExpression;
    	parentheses.TSInferType = TSInferType;
    	parentheses.TSInstantiationExpression = TSInstantiationExpression;
    	parentheses.TSIntersectionType = parentheses.TSUnionType = TSUnionType;
    	parentheses.UnaryLike = UnaryLike;
    	parentheses.IntersectionTypeAnnotation = parentheses.UnionTypeAnnotation = UnionTypeAnnotation;
    	parentheses.UpdateExpression = UpdateExpression;
    	parentheses.AwaitExpression = parentheses.YieldExpression = YieldExpression;
    	var _t = requireLib$2();
    	const {
    	  isArrayTypeAnnotation,
    	  isArrowFunctionExpression,
    	  isAssignmentExpression,
    	  isAwaitExpression,
    	  isBinary,
    	  isBinaryExpression,
    	  isUpdateExpression,
    	  isCallExpression,
    	  isClass,
    	  isClassExpression,
    	  isConditional,
    	  isConditionalExpression,
    	  isExportDeclaration,
    	  isExportDefaultDeclaration,
    	  isExpressionStatement,
    	  isFor,
    	  isForInStatement,
    	  isForOfStatement,
    	  isForStatement,
    	  isFunctionExpression,
    	  isIfStatement,
    	  isIndexedAccessType,
    	  isIntersectionTypeAnnotation,
    	  isLogicalExpression,
    	  isMemberExpression,
    	  isNewExpression,
    	  isNullableTypeAnnotation,
    	  isObjectPattern,
    	  isOptionalCallExpression,
    	  isOptionalMemberExpression,
    	  isReturnStatement,
    	  isSequenceExpression,
    	  isSwitchStatement,
    	  isTSArrayType,
    	  isTSAsExpression,
    	  isTSInstantiationExpression,
    	  isTSIntersectionType,
    	  isTSNonNullExpression,
    	  isTSOptionalType,
    	  isTSRestType,
    	  isTSTypeAssertion,
    	  isTSUnionType,
    	  isTaggedTemplateExpression,
    	  isThrowStatement,
    	  isTypeAnnotation,
    	  isUnaryLike,
    	  isUnionTypeAnnotation,
    	  isVariableDeclarator,
    	  isWhileStatement,
    	  isYieldExpression,
    	  isTSSatisfiesExpression
    	} = _t;
    	const PRECEDENCE = {
    	  "||": 0,
    	  "??": 0,
    	  "|>": 0,
    	  "&&": 1,
    	  "|": 2,
    	  "^": 3,
    	  "&": 4,
    	  "==": 5,
    	  "===": 5,
    	  "!=": 5,
    	  "!==": 5,
    	  "<": 6,
    	  ">": 6,
    	  "<=": 6,
    	  ">=": 6,
    	  in: 6,
    	  instanceof: 6,
    	  ">>": 7,
    	  "<<": 7,
    	  ">>>": 7,
    	  "+": 8,
    	  "-": 8,
    	  "*": 9,
    	  "/": 9,
    	  "%": 9,
    	  "**": 10
    	};
    	function isTSTypeExpression(node) {
    	  return isTSAsExpression(node) || isTSSatisfiesExpression(node) || isTSTypeAssertion(node);
    	}
    	const isClassExtendsClause = (node, parent) => isClass(parent, {
    	  superClass: node
    	});
    	const hasPostfixPart = (node, parent) => (isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isTaggedTemplateExpression(parent) && parent.tag === node || isTSNonNullExpression(parent);
    	function NullableTypeAnnotation(node, parent) {
    	  return isArrayTypeAnnotation(parent);
    	}
    	function FunctionTypeAnnotation(node, parent, printStack) {
    	  if (printStack.length < 3) return;
    	  return isUnionTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]);
    	}
    	function UpdateExpression(node, parent) {
    	  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
    	}
    	function ObjectExpression(node, parent, printStack) {
    	  return isFirstInContext(printStack, 1 | 2);
    	}
    	function DoExpression(node, parent, printStack) {
    	  return !node.async && isFirstInContext(printStack, 1);
    	}
    	function Binary(node, parent) {
    	  if (node.operator === "**" && isBinaryExpression(parent, {
    	    operator: "**"
    	  })) {
    	    return parent.left === node;
    	  }
    	  if (isClassExtendsClause(node, parent)) {
    	    return true;
    	  }
    	  if (hasPostfixPart(node, parent) || isUnaryLike(parent) || isAwaitExpression(parent)) {
    	    return true;
    	  }
    	  if (isBinary(parent)) {
    	    const parentOp = parent.operator;
    	    const parentPos = PRECEDENCE[parentOp];
    	    const nodeOp = node.operator;
    	    const nodePos = PRECEDENCE[nodeOp];
    	    if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos) {
    	      return true;
    	    }
    	  }
    	}
    	function UnionTypeAnnotation(node, parent) {
    	  return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation(parent);
    	}
    	function OptionalIndexedAccessType(node, parent) {
    	  return isIndexedAccessType(parent, {
    	    objectType: node
    	  });
    	}
    	function TSAsExpression() {
    	  return true;
    	}
    	function TSUnionType(node, parent) {
    	  return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);
    	}
    	function TSInferType(node, parent) {
    	  return isTSArrayType(parent) || isTSOptionalType(parent);
    	}
    	function TSInstantiationExpression(node, parent) {
    	  return (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent) || isTSInstantiationExpression(parent)) && !!parent.typeParameters;
    	}
    	function BinaryExpression(node, parent) {
    	  return node.operator === "in" && (isVariableDeclarator(parent) || isFor(parent));
    	}
    	function SequenceExpression(node, parent) {
    	  if (isForStatement(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement(parent) && parent.expression === node) {
    	    return false;
    	  }
    	  return true;
    	}
    	function YieldExpression(node, parent) {
    	  return isBinary(parent) || isUnaryLike(parent) || hasPostfixPart(node, parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);
    	}
    	function ClassExpression(node, parent, printStack) {
    	  return isFirstInContext(printStack, 1 | 4);
    	}
    	function UnaryLike(node, parent) {
    	  return hasPostfixPart(node, parent) || isBinaryExpression(parent, {
    	    operator: "**",
    	    left: node
    	  }) || isClassExtendsClause(node, parent);
    	}
    	function FunctionExpression(node, parent, printStack) {
    	  return isFirstInContext(printStack, 1 | 4);
    	}
    	function ArrowFunctionExpression(node, parent) {
    	  return isExportDeclaration(parent) || ConditionalExpression(node, parent);
    	}
    	function ConditionalExpression(node, parent) {
    	  if (isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, {
    	    test: node
    	  }) || isAwaitExpression(parent) || isTSTypeExpression(parent)) {
    	    return true;
    	  }
    	  return UnaryLike(node, parent);
    	}
    	function OptionalMemberExpression(node, parent) {
    	  return isCallExpression(parent, {
    	    callee: node
    	  }) || isMemberExpression(parent, {
    	    object: node
    	  });
    	}
    	function AssignmentExpression(node, parent) {
    	  if (isObjectPattern(node.left)) {
    	    return true;
    	  } else {
    	    return ConditionalExpression(node, parent);
    	  }
    	}
    	function LogicalExpression(node, parent) {
    	  if (isTSTypeExpression(parent)) return true;
    	  switch (node.operator) {
    	    case "||":
    	      if (!isLogicalExpression(parent)) return false;
    	      return parent.operator === "??" || parent.operator === "&&";
    	    case "&&":
    	      return isLogicalExpression(parent, {
    	        operator: "??"
    	      });
    	    case "??":
    	      return isLogicalExpression(parent) && parent.operator !== "??";
    	  }
    	}
    	function Identifier(node, parent, printStack) {
    	  var _node$extra;
    	  if ((_node$extra = node.extra) != null && _node$extra.parenthesized && isAssignmentExpression(parent, {
    	    left: node
    	  }) && (isFunctionExpression(parent.right) || isClassExpression(parent.right)) && parent.right.id == null) {
    	    return true;
    	  }
    	  if (node.name === "let") {
    	    const isFollowedByBracket = isMemberExpression(parent, {
    	      object: node,
    	      computed: true
    	    }) || isOptionalMemberExpression(parent, {
    	      object: node,
    	      computed: true,
    	      optional: false
    	    });
    	    return isFirstInContext(printStack, isFollowedByBracket ? 1 | 8 | 16 | 32 : 32);
    	  }
    	  return node.name === "async" && isForOfStatement(parent) && node === parent.left;
    	}
    	function isFirstInContext(printStack, checkParam) {
    	  const expressionStatement = checkParam & 1;
    	  const arrowBody = checkParam & 2;
    	  const exportDefault = checkParam & 4;
    	  const forHead = checkParam & 8;
    	  const forInHead = checkParam & 16;
    	  const forOfHead = checkParam & 32;
    	  let i = printStack.length - 1;
    	  if (i <= 0) return;
    	  let node = printStack[i];
    	  i--;
    	  let parent = printStack[i];
    	  while (i >= 0) {
    	    if (expressionStatement && isExpressionStatement(parent, {
    	      expression: node
    	    }) || exportDefault && isExportDefaultDeclaration(parent, {
    	      declaration: node
    	    }) || arrowBody && isArrowFunctionExpression(parent, {
    	      body: node
    	    }) || forHead && isForStatement(parent, {
    	      init: node
    	    }) || forInHead && isForInStatement(parent, {
    	      left: node
    	    }) || forOfHead && isForOfStatement(parent, {
    	      left: node
    	    })) {
    	      return true;
    	    }
    	    if (i > 0 && (hasPostfixPart(node, parent) && !isNewExpression(parent) || isSequenceExpression(parent) && parent.expressions[0] === node || isUpdateExpression(parent) && !parent.prefix || isConditional(parent, {
    	      test: node
    	    }) || isBinary(parent, {
    	      left: node
    	    }) || isAssignmentExpression(parent, {
    	      left: node
    	    }))) {
    	      node = parent;
    	      i--;
    	      parent = printStack[i];
    	    } else {
    	      return false;
    	    }
    	  }
    	  return false;
    	}

    	
    	return parentheses;
    }

    var hasRequiredNode;

    function requireNode () {
    	if (hasRequiredNode) return node;
    	hasRequiredNode = 1;

    	Object.defineProperty(node, "__esModule", {
    	  value: true
    	});
    	node.needsParens = needsParens;
    	node.needsWhitespace = needsWhitespace;
    	node.needsWhitespaceAfter = needsWhitespaceAfter;
    	node.needsWhitespaceBefore = needsWhitespaceBefore;
    	var whitespace = requireWhitespace();
    	var parens = requireParentheses();
    	var _t = requireLib$2();
    	const {
    	  FLIPPED_ALIAS_KEYS,
    	  isCallExpression,
    	  isExpressionStatement,
    	  isMemberExpression,
    	  isNewExpression
    	} = _t;
    	function expandAliases(obj) {
    	  const newObj = {};
    	  function add(type, func) {
    	    const fn = newObj[type];
    	    newObj[type] = fn ? function (node, parent, stack) {
    	      const result = fn(node, parent, stack);
    	      return result == null ? func(node, parent, stack) : result;
    	    } : func;
    	  }
    	  for (const type of Object.keys(obj)) {
    	    const aliases = FLIPPED_ALIAS_KEYS[type];
    	    if (aliases) {
    	      for (const alias of aliases) {
    	        add(alias, obj[type]);
    	      }
    	    } else {
    	      add(type, obj[type]);
    	    }
    	  }
    	  return newObj;
    	}
    	const expandedParens = expandAliases(parens);
    	const expandedWhitespaceNodes = expandAliases(whitespace.nodes);
    	function find(obj, node, parent, printStack) {
    	  const fn = obj[node.type];
    	  return fn ? fn(node, parent, printStack) : null;
    	}
    	function isOrHasCallExpression(node) {
    	  if (isCallExpression(node)) {
    	    return true;
    	  }
    	  return isMemberExpression(node) && isOrHasCallExpression(node.object);
    	}
    	function needsWhitespace(node, parent, type) {
    	  if (!node) return false;
    	  if (isExpressionStatement(node)) {
    	    node = node.expression;
    	  }
    	  const flag = find(expandedWhitespaceNodes, node, parent);
    	  if (typeof flag === "number") {
    	    return (flag & type) !== 0;
    	  }
    	  return false;
    	}
    	function needsWhitespaceBefore(node, parent) {
    	  return needsWhitespace(node, parent, 1);
    	}
    	function needsWhitespaceAfter(node, parent) {
    	  return needsWhitespace(node, parent, 2);
    	}
    	function needsParens(node, parent, printStack) {
    	  if (!parent) return false;
    	  if (isNewExpression(parent) && parent.callee === node) {
    	    if (isOrHasCallExpression(node)) return true;
    	  }
    	  return find(expandedParens, node, parent, printStack);
    	}

    	
    	return node;
    }

    var generators = {};

    var templateLiterals = {};

    var hasRequiredTemplateLiterals;

    function requireTemplateLiterals () {
    	if (hasRequiredTemplateLiterals) return templateLiterals;
    	hasRequiredTemplateLiterals = 1;

    	Object.defineProperty(templateLiterals, "__esModule", {
    	  value: true
    	});
    	templateLiterals.TaggedTemplateExpression = TaggedTemplateExpression;
    	templateLiterals.TemplateElement = TemplateElement;
    	templateLiterals.TemplateLiteral = TemplateLiteral;
    	function TaggedTemplateExpression(node) {
    	  this.print(node.tag, node);
    	  this.print(node.typeParameters, node);
    	  this.print(node.quasi, node);
    	}
    	function TemplateElement(node, parent) {
    	  const isFirst = parent.quasis[0] === node;
    	  const isLast = parent.quasis[parent.quasis.length - 1] === node;
    	  const value = (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");
    	  this.token(value, true);
    	}
    	function TemplateLiteral(node) {
    	  const quasis = node.quasis;
    	  for (let i = 0; i < quasis.length; i++) {
    	    this.print(quasis[i], node);
    	    if (i + 1 < quasis.length) {
    	      this.print(node.expressions[i], node);
    	    }
    	  }
    	}

    	
    	return templateLiterals;
    }

    var expressions = {};

    var hasRequiredExpressions;

    function requireExpressions () {
    	if (hasRequiredExpressions) return expressions;
    	hasRequiredExpressions = 1;

    	Object.defineProperty(expressions, "__esModule", {
    	  value: true
    	});
    	expressions.LogicalExpression = expressions.BinaryExpression = expressions.AssignmentExpression = AssignmentExpression;
    	expressions.AssignmentPattern = AssignmentPattern;
    	expressions.AwaitExpression = AwaitExpression;
    	expressions.BindExpression = BindExpression;
    	expressions.CallExpression = CallExpression;
    	expressions.ConditionalExpression = ConditionalExpression;
    	expressions.Decorator = Decorator;
    	expressions.DoExpression = DoExpression;
    	expressions.EmptyStatement = EmptyStatement;
    	expressions.ExpressionStatement = ExpressionStatement;
    	expressions.Import = Import;
    	expressions.MemberExpression = MemberExpression;
    	expressions.MetaProperty = MetaProperty;
    	expressions.ModuleExpression = ModuleExpression;
    	expressions.NewExpression = NewExpression;
    	expressions.OptionalCallExpression = OptionalCallExpression;
    	expressions.OptionalMemberExpression = OptionalMemberExpression;
    	expressions.ParenthesizedExpression = ParenthesizedExpression;
    	expressions.PrivateName = PrivateName;
    	expressions.SequenceExpression = SequenceExpression;
    	expressions.Super = Super;
    	expressions.ThisExpression = ThisExpression;
    	expressions.UnaryExpression = UnaryExpression;
    	expressions.UpdateExpression = UpdateExpression;
    	expressions.V8IntrinsicIdentifier = V8IntrinsicIdentifier;
    	expressions.YieldExpression = YieldExpression;
    	expressions._shouldPrintDecoratorsBeforeExport = _shouldPrintDecoratorsBeforeExport;
    	var _t = requireLib$2();
    	var n = requireNode();
    	const {
    	  isCallExpression,
    	  isLiteral,
    	  isMemberExpression,
    	  isNewExpression
    	} = _t;
    	function UnaryExpression(node) {
    	  const {
    	    operator
    	  } = node;
    	  if (operator === "void" || operator === "delete" || operator === "typeof" || operator === "throw") {
    	    this.word(operator);
    	    this.space();
    	  } else {
    	    this.token(operator);
    	  }
    	  this.print(node.argument, node);
    	}
    	function DoExpression(node) {
    	  if (node.async) {
    	    this.word("async", true);
    	    this.space();
    	  }
    	  this.word("do");
    	  this.space();
    	  this.print(node.body, node);
    	}
    	function ParenthesizedExpression(node) {
    	  this.tokenChar(40);
    	  this.print(node.expression, node);
    	  this.rightParens(node);
    	}
    	function UpdateExpression(node) {
    	  if (node.prefix) {
    	    this.token(node.operator);
    	    this.print(node.argument, node);
    	  } else {
    	    this.printTerminatorless(node.argument, node, true);
    	    this.token(node.operator);
    	  }
    	}
    	function ConditionalExpression(node) {
    	  this.print(node.test, node);
    	  this.space();
    	  this.tokenChar(63);
    	  this.space();
    	  this.print(node.consequent, node);
    	  this.space();
    	  this.tokenChar(58);
    	  this.space();
    	  this.print(node.alternate, node);
    	}
    	function NewExpression(node, parent) {
    	  this.word("new");
    	  this.space();
    	  this.print(node.callee, node);
    	  if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression(parent, {
    	    callee: node
    	  }) && !isMemberExpression(parent) && !isNewExpression(parent)) {
    	    return;
    	  }
    	  this.print(node.typeArguments, node);
    	  this.print(node.typeParameters, node);
    	  if (node.optional) {
    	    this.token("?.");
    	  }
    	  this.tokenChar(40);
    	  this.printList(node.arguments, node);
    	  this.rightParens(node);
    	}
    	function SequenceExpression(node) {
    	  this.printList(node.expressions, node);
    	}
    	function ThisExpression() {
    	  this.word("this");
    	}
    	function Super() {
    	  this.word("super");
    	}
    	function isDecoratorMemberExpression(node) {
    	  switch (node.type) {
    	    case "Identifier":
    	      return true;
    	    case "MemberExpression":
    	      return !node.computed && node.property.type === "Identifier" && isDecoratorMemberExpression(node.object);
    	    default:
    	      return false;
    	  }
    	}
    	function shouldParenthesizeDecoratorExpression(node) {
    	  if (node.type === "ParenthesizedExpression") {
    	    return false;
    	  }
    	  return !isDecoratorMemberExpression(node.type === "CallExpression" ? node.callee : node);
    	}
    	function _shouldPrintDecoratorsBeforeExport(node) {
    	  if (typeof this.format.decoratorsBeforeExport === "boolean") {
    	    return this.format.decoratorsBeforeExport;
    	  }
    	  return typeof node.start === "number" && node.start === node.declaration.start;
    	}
    	function Decorator(node) {
    	  this.tokenChar(64);
    	  const {
    	    expression
    	  } = node;
    	  if (shouldParenthesizeDecoratorExpression(expression)) {
    	    this.tokenChar(40);
    	    this.print(expression, node);
    	    this.tokenChar(41);
    	  } else {
    	    this.print(expression, node);
    	  }
    	  this.newline();
    	}
    	function OptionalMemberExpression(node) {
    	  let {
    	    computed
    	  } = node;
    	  const {
    	    optional,
    	    property
    	  } = node;
    	  this.print(node.object, node);
    	  if (!computed && isMemberExpression(property)) {
    	    throw new TypeError("Got a MemberExpression for MemberExpression property");
    	  }
    	  if (isLiteral(property) && typeof property.value === "number") {
    	    computed = true;
    	  }
    	  if (optional) {
    	    this.token("?.");
    	  }
    	  if (computed) {
    	    this.tokenChar(91);
    	    this.print(property, node);
    	    this.tokenChar(93);
    	  } else {
    	    if (!optional) {
    	      this.tokenChar(46);
    	    }
    	    this.print(property, node);
    	  }
    	}
    	function OptionalCallExpression(node) {
    	  this.print(node.callee, node);
    	  this.print(node.typeParameters, node);
    	  if (node.optional) {
    	    this.token("?.");
    	  }
    	  this.print(node.typeArguments, node);
    	  this.tokenChar(40);
    	  this.printList(node.arguments, node);
    	  this.rightParens(node);
    	}
    	function CallExpression(node) {
    	  this.print(node.callee, node);
    	  this.print(node.typeArguments, node);
    	  this.print(node.typeParameters, node);
    	  this.tokenChar(40);
    	  this.printList(node.arguments, node);
    	  this.rightParens(node);
    	}
    	function Import() {
    	  this.word("import");
    	}
    	function AwaitExpression(node) {
    	  this.word("await");
    	  if (node.argument) {
    	    this.space();
    	    this.printTerminatorless(node.argument, node, false);
    	  }
    	}
    	function YieldExpression(node) {
    	  this.word("yield", true);
    	  if (node.delegate) {
    	    this.tokenChar(42);
    	    if (node.argument) {
    	      this.space();
    	      this.print(node.argument, node);
    	    }
    	  } else {
    	    if (node.argument) {
    	      this.space();
    	      this.printTerminatorless(node.argument, node, false);
    	    }
    	  }
    	}
    	function EmptyStatement() {
    	  this.semicolon(true);
    	}
    	function ExpressionStatement(node) {
    	  this.print(node.expression, node);
    	  this.semicolon();
    	}
    	function AssignmentPattern(node) {
    	  this.print(node.left, node);
    	  if (node.left.optional) this.tokenChar(63);
    	  this.print(node.left.typeAnnotation, node);
    	  this.space();
    	  this.tokenChar(61);
    	  this.space();
    	  this.print(node.right, node);
    	}
    	function AssignmentExpression(node, parent) {
    	  const parens = this.inForStatementInitCounter && node.operator === "in" && !n.needsParens(node, parent);
    	  if (parens) {
    	    this.tokenChar(40);
    	  }
    	  this.print(node.left, node);
    	  this.space();
    	  if (node.operator === "in" || node.operator === "instanceof") {
    	    this.word(node.operator);
    	  } else {
    	    this.token(node.operator);
    	  }
    	  this.space();
    	  this.print(node.right, node);
    	  if (parens) {
    	    this.tokenChar(41);
    	  }
    	}
    	function BindExpression(node) {
    	  this.print(node.object, node);
    	  this.token("::");
    	  this.print(node.callee, node);
    	}
    	function MemberExpression(node) {
    	  this.print(node.object, node);
    	  if (!node.computed && isMemberExpression(node.property)) {
    	    throw new TypeError("Got a MemberExpression for MemberExpression property");
    	  }
    	  let computed = node.computed;
    	  if (isLiteral(node.property) && typeof node.property.value === "number") {
    	    computed = true;
    	  }
    	  if (computed) {
    	    this.tokenChar(91);
    	    this.print(node.property, node);
    	    this.tokenChar(93);
    	  } else {
    	    this.tokenChar(46);
    	    this.print(node.property, node);
    	  }
    	}
    	function MetaProperty(node) {
    	  this.print(node.meta, node);
    	  this.tokenChar(46);
    	  this.print(node.property, node);
    	}
    	function PrivateName(node) {
    	  this.tokenChar(35);
    	  this.print(node.id, node);
    	}
    	function V8IntrinsicIdentifier(node) {
    	  this.tokenChar(37);
    	  this.word(node.name);
    	}
    	function ModuleExpression(node) {
    	  this.word("module", true);
    	  this.space();
    	  this.tokenChar(123);
    	  this.indent();
    	  const {
    	    body
    	  } = node;
    	  if (body.body.length || body.directives.length) {
    	    this.newline();
    	  }
    	  this.print(body, node);
    	  this.dedent();
    	  this.rightBrace(node);
    	}

    	
    	return expressions;
    }

    var statements = {};

    var hasRequiredStatements;

    function requireStatements () {
    	if (hasRequiredStatements) return statements;
    	hasRequiredStatements = 1;

    	Object.defineProperty(statements, "__esModule", {
    	  value: true
    	});
    	statements.BreakStatement = BreakStatement;
    	statements.CatchClause = CatchClause;
    	statements.ContinueStatement = ContinueStatement;
    	statements.DebuggerStatement = DebuggerStatement;
    	statements.DoWhileStatement = DoWhileStatement;
    	statements.ForOfStatement = statements.ForInStatement = void 0;
    	statements.ForStatement = ForStatement;
    	statements.IfStatement = IfStatement;
    	statements.LabeledStatement = LabeledStatement;
    	statements.ReturnStatement = ReturnStatement;
    	statements.SwitchCase = SwitchCase;
    	statements.SwitchStatement = SwitchStatement;
    	statements.ThrowStatement = ThrowStatement;
    	statements.TryStatement = TryStatement;
    	statements.VariableDeclaration = VariableDeclaration;
    	statements.VariableDeclarator = VariableDeclarator;
    	statements.WhileStatement = WhileStatement;
    	statements.WithStatement = WithStatement;
    	var _t = requireLib$2();
    	const {
    	  isFor,
    	  isForStatement,
    	  isIfStatement,
    	  isStatement
    	} = _t;
    	function WithStatement(node) {
    	  this.word("with");
    	  this.space();
    	  this.tokenChar(40);
    	  this.print(node.object, node);
    	  this.tokenChar(41);
    	  this.printBlock(node);
    	}
    	function IfStatement(node) {
    	  this.word("if");
    	  this.space();
    	  this.tokenChar(40);
    	  this.print(node.test, node);
    	  this.tokenChar(41);
    	  this.space();
    	  const needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));
    	  if (needsBlock) {
    	    this.tokenChar(123);
    	    this.newline();
    	    this.indent();
    	  }
    	  this.printAndIndentOnComments(node.consequent, node);
    	  if (needsBlock) {
    	    this.dedent();
    	    this.newline();
    	    this.tokenChar(125);
    	  }
    	  if (node.alternate) {
    	    if (this.endsWith(125)) this.space();
    	    this.word("else");
    	    this.space();
    	    this.printAndIndentOnComments(node.alternate, node);
    	  }
    	}
    	function getLastStatement(statement) {
    	  const {
    	    body
    	  } = statement;
    	  if (isStatement(body) === false) {
    	    return statement;
    	  }
    	  return getLastStatement(body);
    	}
    	function ForStatement(node) {
    	  this.word("for");
    	  this.space();
    	  this.tokenChar(40);
    	  this.inForStatementInitCounter++;
    	  this.print(node.init, node);
    	  this.inForStatementInitCounter--;
    	  this.tokenChar(59);
    	  if (node.test) {
    	    this.space();
    	    this.print(node.test, node);
    	  }
    	  this.tokenChar(59);
    	  if (node.update) {
    	    this.space();
    	    this.print(node.update, node);
    	  }
    	  this.tokenChar(41);
    	  this.printBlock(node);
    	}
    	function WhileStatement(node) {
    	  this.word("while");
    	  this.space();
    	  this.tokenChar(40);
    	  this.print(node.test, node);
    	  this.tokenChar(41);
    	  this.printBlock(node);
    	}
    	function ForXStatement(node) {
    	  this.word("for");
    	  this.space();
    	  const isForOf = node.type === "ForOfStatement";
    	  if (isForOf && node.await) {
    	    this.word("await");
    	    this.space();
    	  }
    	  this.noIndentInnerCommentsHere();
    	  this.tokenChar(40);
    	  this.print(node.left, node);
    	  this.space();
    	  this.word(isForOf ? "of" : "in");
    	  this.space();
    	  this.print(node.right, node);
    	  this.tokenChar(41);
    	  this.printBlock(node);
    	}
    	const ForInStatement = ForXStatement;
    	statements.ForInStatement = ForInStatement;
    	const ForOfStatement = ForXStatement;
    	statements.ForOfStatement = ForOfStatement;
    	function DoWhileStatement(node) {
    	  this.word("do");
    	  this.space();
    	  this.print(node.body, node);
    	  this.space();
    	  this.word("while");
    	  this.space();
    	  this.tokenChar(40);
    	  this.print(node.test, node);
    	  this.tokenChar(41);
    	  this.semicolon();
    	}
    	function printStatementAfterKeyword(printer, node, parent, isLabel) {
    	  if (node) {
    	    printer.space();
    	    printer.printTerminatorless(node, parent, isLabel);
    	  }
    	  printer.semicolon();
    	}
    	function BreakStatement(node) {
    	  this.word("break");
    	  printStatementAfterKeyword(this, node.label, node, true);
    	}
    	function ContinueStatement(node) {
    	  this.word("continue");
    	  printStatementAfterKeyword(this, node.label, node, true);
    	}
    	function ReturnStatement(node) {
    	  this.word("return");
    	  printStatementAfterKeyword(this, node.argument, node, false);
    	}
    	function ThrowStatement(node) {
    	  this.word("throw");
    	  printStatementAfterKeyword(this, node.argument, node, false);
    	}
    	function LabeledStatement(node) {
    	  this.print(node.label, node);
    	  this.tokenChar(58);
    	  this.space();
    	  this.print(node.body, node);
    	}
    	function TryStatement(node) {
    	  this.word("try");
    	  this.space();
    	  this.print(node.block, node);
    	  this.space();
    	  if (node.handlers) {
    	    this.print(node.handlers[0], node);
    	  } else {
    	    this.print(node.handler, node);
    	  }
    	  if (node.finalizer) {
    	    this.space();
    	    this.word("finally");
    	    this.space();
    	    this.print(node.finalizer, node);
    	  }
    	}
    	function CatchClause(node) {
    	  this.word("catch");
    	  this.space();
    	  if (node.param) {
    	    this.tokenChar(40);
    	    this.print(node.param, node);
    	    this.print(node.param.typeAnnotation, node);
    	    this.tokenChar(41);
    	    this.space();
    	  }
    	  this.print(node.body, node);
    	}
    	function SwitchStatement(node) {
    	  this.word("switch");
    	  this.space();
    	  this.tokenChar(40);
    	  this.print(node.discriminant, node);
    	  this.tokenChar(41);
    	  this.space();
    	  this.tokenChar(123);
    	  this.printSequence(node.cases, node, {
    	    indent: true,
    	    addNewlines(leading, cas) {
    	      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
    	    }
    	  });
    	  this.rightBrace(node);
    	}
    	function SwitchCase(node) {
    	  if (node.test) {
    	    this.word("case");
    	    this.space();
    	    this.print(node.test, node);
    	    this.tokenChar(58);
    	  } else {
    	    this.word("default");
    	    this.tokenChar(58);
    	  }
    	  if (node.consequent.length) {
    	    this.newline();
    	    this.printSequence(node.consequent, node, {
    	      indent: true
    	    });
    	  }
    	}
    	function DebuggerStatement() {
    	  this.word("debugger");
    	  this.semicolon();
    	}
    	function VariableDeclaration(node, parent) {
    	  if (node.declare) {
    	    this.word("declare");
    	    this.space();
    	  }
    	  const {
    	    kind
    	  } = node;
    	  this.word(kind, kind === "using" || kind === "await using");
    	  this.space();
    	  let hasInits = false;
    	  if (!isFor(parent)) {
    	    for (const declar of node.declarations) {
    	      if (declar.init) {
    	        hasInits = true;
    	      }
    	    }
    	  }
    	  this.printList(node.declarations, node, {
    	    separator: hasInits ? function () {
    	      this.tokenChar(44);
    	      this.newline();
    	    } : undefined,
    	    indent: node.declarations.length > 1 ? true : false
    	  });
    	  if (isFor(parent)) {
    	    if (isForStatement(parent)) {
    	      if (parent.init === node) return;
    	    } else {
    	      if (parent.left === node) return;
    	    }
    	  }
    	  this.semicolon();
    	}
    	function VariableDeclarator(node) {
    	  this.print(node.id, node);
    	  if (node.definite) this.tokenChar(33);
    	  this.print(node.id.typeAnnotation, node);
    	  if (node.init) {
    	    this.space();
    	    this.tokenChar(61);
    	    this.space();
    	    this.print(node.init, node);
    	  }
    	}

    	
    	return statements;
    }

    var classes = {};

    var hasRequiredClasses;

    function requireClasses () {
    	if (hasRequiredClasses) return classes;
    	hasRequiredClasses = 1;

    	Object.defineProperty(classes, "__esModule", {
    	  value: true
    	});
    	classes.ClassAccessorProperty = ClassAccessorProperty;
    	classes.ClassBody = ClassBody;
    	classes.ClassExpression = classes.ClassDeclaration = ClassDeclaration;
    	classes.ClassMethod = ClassMethod;
    	classes.ClassPrivateMethod = ClassPrivateMethod;
    	classes.ClassPrivateProperty = ClassPrivateProperty;
    	classes.ClassProperty = ClassProperty;
    	classes.StaticBlock = StaticBlock;
    	classes._classMethodHead = _classMethodHead;
    	var _t = requireLib$2();
    	const {
    	  isExportDefaultDeclaration,
    	  isExportNamedDeclaration
    	} = _t;
    	function ClassDeclaration(node, parent) {
    	  const inExport = isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent);
    	  if (!inExport || !this._shouldPrintDecoratorsBeforeExport(parent)) {
    	    this.printJoin(node.decorators, node);
    	  }
    	  if (node.declare) {
    	    this.word("declare");
    	    this.space();
    	  }
    	  if (node.abstract) {
    	    this.word("abstract");
    	    this.space();
    	  }
    	  this.word("class");
    	  if (node.id) {
    	    this.space();
    	    this.print(node.id, node);
    	  }
    	  this.print(node.typeParameters, node);
    	  if (node.superClass) {
    	    this.space();
    	    this.word("extends");
    	    this.space();
    	    this.print(node.superClass, node);
    	    this.print(node.superTypeParameters, node);
    	  }
    	  if (node.implements) {
    	    this.space();
    	    this.word("implements");
    	    this.space();
    	    this.printList(node.implements, node);
    	  }
    	  this.space();
    	  this.print(node.body, node);
    	}
    	function ClassBody(node) {
    	  this.tokenChar(123);
    	  if (node.body.length === 0) {
    	    this.tokenChar(125);
    	  } else {
    	    this.newline();
    	    this.printSequence(node.body, node, {
    	      indent: true
    	    });
    	    if (!this.endsWith(10)) this.newline();
    	    this.rightBrace(node);
    	  }
    	}
    	function ClassProperty(node) {
    	  var _node$key$loc;
    	  this.printJoin(node.decorators, node);
    	  const endLine = (_node$key$loc = node.key.loc) == null || (_node$key$loc = _node$key$loc.end) == null ? void 0 : _node$key$loc.line;
    	  if (endLine) this.catchUp(endLine);
    	  this.tsPrintClassMemberModifiers(node);
    	  if (node.computed) {
    	    this.tokenChar(91);
    	    this.print(node.key, node);
    	    this.tokenChar(93);
    	  } else {
    	    this._variance(node);
    	    this.print(node.key, node);
    	  }
    	  if (node.optional) {
    	    this.tokenChar(63);
    	  }
    	  if (node.definite) {
    	    this.tokenChar(33);
    	  }
    	  this.print(node.typeAnnotation, node);
    	  if (node.value) {
    	    this.space();
    	    this.tokenChar(61);
    	    this.space();
    	    this.print(node.value, node);
    	  }
    	  this.semicolon();
    	}
    	function ClassAccessorProperty(node) {
    	  var _node$key$loc2;
    	  this.printJoin(node.decorators, node);
    	  const endLine = (_node$key$loc2 = node.key.loc) == null || (_node$key$loc2 = _node$key$loc2.end) == null ? void 0 : _node$key$loc2.line;
    	  if (endLine) this.catchUp(endLine);
    	  this.tsPrintClassMemberModifiers(node);
    	  this.word("accessor", true);
    	  this.space();
    	  if (node.computed) {
    	    this.tokenChar(91);
    	    this.print(node.key, node);
    	    this.tokenChar(93);
    	  } else {
    	    this._variance(node);
    	    this.print(node.key, node);
    	  }
    	  if (node.optional) {
    	    this.tokenChar(63);
    	  }
    	  if (node.definite) {
    	    this.tokenChar(33);
    	  }
    	  this.print(node.typeAnnotation, node);
    	  if (node.value) {
    	    this.space();
    	    this.tokenChar(61);
    	    this.space();
    	    this.print(node.value, node);
    	  }
    	  this.semicolon();
    	}
    	function ClassPrivateProperty(node) {
    	  this.printJoin(node.decorators, node);
    	  if (node.static) {
    	    this.word("static");
    	    this.space();
    	  }
    	  this.print(node.key, node);
    	  this.print(node.typeAnnotation, node);
    	  if (node.value) {
    	    this.space();
    	    this.tokenChar(61);
    	    this.space();
    	    this.print(node.value, node);
    	  }
    	  this.semicolon();
    	}
    	function ClassMethod(node) {
    	  this._classMethodHead(node);
    	  this.space();
    	  this.print(node.body, node);
    	}
    	function ClassPrivateMethod(node) {
    	  this._classMethodHead(node);
    	  this.space();
    	  this.print(node.body, node);
    	}
    	function _classMethodHead(node) {
    	  var _node$key$loc3;
    	  this.printJoin(node.decorators, node);
    	  const endLine = (_node$key$loc3 = node.key.loc) == null || (_node$key$loc3 = _node$key$loc3.end) == null ? void 0 : _node$key$loc3.line;
    	  if (endLine) this.catchUp(endLine);
    	  this.tsPrintClassMemberModifiers(node);
    	  this._methodHead(node);
    	}
    	function StaticBlock(node) {
    	  this.word("static");
    	  this.space();
    	  this.tokenChar(123);
    	  if (node.body.length === 0) {
    	    this.tokenChar(125);
    	  } else {
    	    this.newline();
    	    this.printSequence(node.body, node, {
    	      indent: true
    	    });
    	    this.rightBrace(node);
    	  }
    	}

    	
    	return classes;
    }

    var methods = {};

    var hasRequiredMethods;

    function requireMethods () {
    	if (hasRequiredMethods) return methods;
    	hasRequiredMethods = 1;

    	Object.defineProperty(methods, "__esModule", {
    	  value: true
    	});
    	methods.ArrowFunctionExpression = ArrowFunctionExpression;
    	methods.FunctionDeclaration = methods.FunctionExpression = FunctionExpression;
    	methods._functionHead = _functionHead;
    	methods._methodHead = _methodHead;
    	methods._param = _param;
    	methods._parameters = _parameters;
    	methods._params = _params;
    	methods._predicate = _predicate;
    	var _t = requireLib$2();
    	const {
    	  isIdentifier
    	} = _t;
    	function _params(node, idNode, parentNode) {
    	  this.print(node.typeParameters, node);
    	  const nameInfo = _getFuncIdName.call(this, idNode, parentNode);
    	  if (nameInfo) {
    	    this.sourceIdentifierName(nameInfo.name, nameInfo.pos);
    	  }
    	  this.tokenChar(40);
    	  this._parameters(node.params, node);
    	  this.tokenChar(41);
    	  const noLineTerminator = node.type === "ArrowFunctionExpression";
    	  this.print(node.returnType, node, noLineTerminator);
    	  this._noLineTerminator = noLineTerminator;
    	}
    	function _parameters(parameters, parent) {
    	  const paramLength = parameters.length;
    	  for (let i = 0; i < paramLength; i++) {
    	    this._param(parameters[i], parent);
    	    if (i < parameters.length - 1) {
    	      this.tokenChar(44);
    	      this.space();
    	    }
    	  }
    	}
    	function _param(parameter, parent) {
    	  this.printJoin(parameter.decorators, parameter);
    	  this.print(parameter, parent);
    	  if (parameter.optional) {
    	    this.tokenChar(63);
    	  }
    	  this.print(parameter.typeAnnotation, parameter);
    	}
    	function _methodHead(node) {
    	  const kind = node.kind;
    	  const key = node.key;
    	  if (kind === "get" || kind === "set") {
    	    this.word(kind);
    	    this.space();
    	  }
    	  if (node.async) {
    	    this.word("async", true);
    	    this.space();
    	  }
    	  if (kind === "method" || kind === "init") {
    	    if (node.generator) {
    	      this.tokenChar(42);
    	    }
    	  }
    	  if (node.computed) {
    	    this.tokenChar(91);
    	    this.print(key, node);
    	    this.tokenChar(93);
    	  } else {
    	    this.print(key, node);
    	  }
    	  if (node.optional) {
    	    this.tokenChar(63);
    	  }
    	  this._params(node, node.computed && node.key.type !== "StringLiteral" ? undefined : node.key, undefined);
    	}
    	function _predicate(node, noLineTerminatorAfter) {
    	  if (node.predicate) {
    	    if (!node.returnType) {
    	      this.tokenChar(58);
    	    }
    	    this.space();
    	    this.print(node.predicate, node, noLineTerminatorAfter);
    	  }
    	}
    	function _functionHead(node, parent) {
    	  if (node.async) {
    	    this.word("async");
    	    this._endsWithInnerRaw = false;
    	    this.space();
    	  }
    	  this.word("function");
    	  if (node.generator) {
    	    this._endsWithInnerRaw = false;
    	    this.tokenChar(42);
    	  }
    	  this.space();
    	  if (node.id) {
    	    this.print(node.id, node);
    	  }
    	  this._params(node, node.id, parent);
    	  if (node.type !== "TSDeclareFunction") {
    	    this._predicate(node);
    	  }
    	}
    	function FunctionExpression(node, parent) {
    	  this._functionHead(node, parent);
    	  this.space();
    	  this.print(node.body, node);
    	}
    	function ArrowFunctionExpression(node, parent) {
    	  if (node.async) {
    	    this.word("async", true);
    	    this.space();
    	  }
    	  let firstParam;
    	  if (!this.format.retainLines && node.params.length === 1 && isIdentifier(firstParam = node.params[0]) && !hasTypesOrComments(node, firstParam)) {
    	    this.print(firstParam, node, true);
    	  } else {
    	    this._params(node, undefined, parent);
    	  }
    	  this._predicate(node, true);
    	  this.space();
    	  this.printInnerComments();
    	  this.token("=>");
    	  this.space();
    	  this.print(node.body, node);
    	}
    	function hasTypesOrComments(node, param) {
    	  var _param$leadingComment, _param$trailingCommen;
    	  return !!(node.typeParameters || node.returnType || node.predicate || param.typeAnnotation || param.optional || (_param$leadingComment = param.leadingComments) != null && _param$leadingComment.length || (_param$trailingCommen = param.trailingComments) != null && _param$trailingCommen.length);
    	}
    	function _getFuncIdName(idNode, parent) {
    	  let id = idNode;
    	  if (!id && parent) {
    	    const parentType = parent.type;
    	    if (parentType === "VariableDeclarator") {
    	      id = parent.id;
    	    } else if (parentType === "AssignmentExpression" || parentType === "AssignmentPattern") {
    	      id = parent.left;
    	    } else if (parentType === "ObjectProperty" || parentType === "ClassProperty") {
    	      if (!parent.computed || parent.key.type === "StringLiteral") {
    	        id = parent.key;
    	      }
    	    } else if (parentType === "ClassPrivateProperty" || parentType === "ClassAccessorProperty") {
    	      id = parent.key;
    	    }
    	  }
    	  if (!id) return;
    	  let nameInfo;
    	  if (id.type === "Identifier") {
    	    var _id$loc, _id$loc2;
    	    nameInfo = {
    	      pos: (_id$loc = id.loc) == null ? void 0 : _id$loc.start,
    	      name: ((_id$loc2 = id.loc) == null ? void 0 : _id$loc2.identifierName) || id.name
    	    };
    	  } else if (id.type === "PrivateName") {
    	    var _id$loc3;
    	    nameInfo = {
    	      pos: (_id$loc3 = id.loc) == null ? void 0 : _id$loc3.start,
    	      name: "#" + id.id.name
    	    };
    	  } else if (id.type === "StringLiteral") {
    	    var _id$loc4;
    	    nameInfo = {
    	      pos: (_id$loc4 = id.loc) == null ? void 0 : _id$loc4.start,
    	      name: id.value
    	    };
    	  }
    	  return nameInfo;
    	}

    	
    	return methods;
    }

    var modules = {};

    var hasRequiredModules;

    function requireModules () {
    	if (hasRequiredModules) return modules;
    	hasRequiredModules = 1;

    	Object.defineProperty(modules, "__esModule", {
    	  value: true
    	});
    	modules.ExportAllDeclaration = ExportAllDeclaration;
    	modules.ExportDefaultDeclaration = ExportDefaultDeclaration;
    	modules.ExportDefaultSpecifier = ExportDefaultSpecifier;
    	modules.ExportNamedDeclaration = ExportNamedDeclaration;
    	modules.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
    	modules.ExportSpecifier = ExportSpecifier;
    	modules.ImportAttribute = ImportAttribute;
    	modules.ImportDeclaration = ImportDeclaration;
    	modules.ImportDefaultSpecifier = ImportDefaultSpecifier;
    	modules.ImportExpression = ImportExpression;
    	modules.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
    	modules.ImportSpecifier = ImportSpecifier;
    	modules._printAttributes = _printAttributes;
    	var _t = requireLib$2();
    	const {
    	  isClassDeclaration,
    	  isExportDefaultSpecifier,
    	  isExportNamespaceSpecifier,
    	  isImportDefaultSpecifier,
    	  isImportNamespaceSpecifier,
    	  isStatement
    	} = _t;
    	function ImportSpecifier(node) {
    	  if (node.importKind === "type" || node.importKind === "typeof") {
    	    this.word(node.importKind);
    	    this.space();
    	  }
    	  this.print(node.imported, node);
    	  if (node.local && node.local.name !== node.imported.name) {
    	    this.space();
    	    this.word("as");
    	    this.space();
    	    this.print(node.local, node);
    	  }
    	}
    	function ImportDefaultSpecifier(node) {
    	  this.print(node.local, node);
    	}
    	function ExportDefaultSpecifier(node) {
    	  this.print(node.exported, node);
    	}
    	function ExportSpecifier(node) {
    	  if (node.exportKind === "type") {
    	    this.word("type");
    	    this.space();
    	  }
    	  this.print(node.local, node);
    	  if (node.exported && node.local.name !== node.exported.name) {
    	    this.space();
    	    this.word("as");
    	    this.space();
    	    this.print(node.exported, node);
    	  }
    	}
    	function ExportNamespaceSpecifier(node) {
    	  this.tokenChar(42);
    	  this.space();
    	  this.word("as");
    	  this.space();
    	  this.print(node.exported, node);
    	}
    	let warningShown = false;
    	function _printAttributes(node) {
    	  const {
    	    importAttributesKeyword
    	  } = this.format;
    	  const {
    	    attributes,
    	    assertions
    	  } = node;
    	  if (attributes && !importAttributesKeyword && !warningShown) {
    	    warningShown = true;
    	    console.warn(`\
You are using import attributes, without specifying the desired output syntax.
Please specify the "importAttributesKeyword" generator option, whose value can be one of:
 - "with"        : \`import { a } from "b" with { type: "json" };\`
 - "assert"      : \`import { a } from "b" assert { type: "json" };\`
 - "with-legacy" : \`import { a } from "b" with type: "json";\`
`);
    	  }
    	  const useAssertKeyword = importAttributesKeyword === "assert" || !importAttributesKeyword && assertions;
    	  this.word(useAssertKeyword ? "assert" : "with");
    	  this.space();
    	  if (!useAssertKeyword && importAttributesKeyword !== "with") {
    	    this.printList(attributes || assertions, node);
    	    return;
    	  }
    	  this.tokenChar(123);
    	  this.space();
    	  this.printList(attributes || assertions, node);
    	  this.space();
    	  this.tokenChar(125);
    	}
    	function ExportAllDeclaration(node) {
    	  var _node$attributes, _node$assertions;
    	  this.word("export");
    	  this.space();
    	  if (node.exportKind === "type") {
    	    this.word("type");
    	    this.space();
    	  }
    	  this.tokenChar(42);
    	  this.space();
    	  this.word("from");
    	  this.space();
    	  if ((_node$attributes = node.attributes) != null && _node$attributes.length || (_node$assertions = node.assertions) != null && _node$assertions.length) {
    	    this.print(node.source, node, true);
    	    this.space();
    	    this._printAttributes(node);
    	  } else {
    	    this.print(node.source, node);
    	  }
    	  this.semicolon();
    	}
    	function maybePrintDecoratorsBeforeExport(printer, node) {
    	  if (isClassDeclaration(node.declaration) && printer._shouldPrintDecoratorsBeforeExport(node)) {
    	    printer.printJoin(node.declaration.decorators, node);
    	  }
    	}
    	function ExportNamedDeclaration(node) {
    	  maybePrintDecoratorsBeforeExport(this, node);
    	  this.word("export");
    	  this.space();
    	  if (node.declaration) {
    	    const declar = node.declaration;
    	    this.print(declar, node);
    	    if (!isStatement(declar)) this.semicolon();
    	  } else {
    	    if (node.exportKind === "type") {
    	      this.word("type");
    	      this.space();
    	    }
    	    const specifiers = node.specifiers.slice(0);
    	    let hasSpecial = false;
    	    for (;;) {
    	      const first = specifiers[0];
    	      if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {
    	        hasSpecial = true;
    	        this.print(specifiers.shift(), node);
    	        if (specifiers.length) {
    	          this.tokenChar(44);
    	          this.space();
    	        }
    	      } else {
    	        break;
    	      }
    	    }
    	    if (specifiers.length || !specifiers.length && !hasSpecial) {
    	      this.tokenChar(123);
    	      if (specifiers.length) {
    	        this.space();
    	        this.printList(specifiers, node);
    	        this.space();
    	      }
    	      this.tokenChar(125);
    	    }
    	    if (node.source) {
    	      var _node$attributes2, _node$assertions2;
    	      this.space();
    	      this.word("from");
    	      this.space();
    	      if ((_node$attributes2 = node.attributes) != null && _node$attributes2.length || (_node$assertions2 = node.assertions) != null && _node$assertions2.length) {
    	        this.print(node.source, node, true);
    	        this.space();
    	        this._printAttributes(node);
    	      } else {
    	        this.print(node.source, node);
    	      }
    	    }
    	    this.semicolon();
    	  }
    	}
    	function ExportDefaultDeclaration(node) {
    	  maybePrintDecoratorsBeforeExport(this, node);
    	  this.word("export");
    	  this.noIndentInnerCommentsHere();
    	  this.space();
    	  this.word("default");
    	  this.space();
    	  const declar = node.declaration;
    	  this.print(declar, node);
    	  if (!isStatement(declar)) this.semicolon();
    	}
    	function ImportDeclaration(node) {
    	  var _node$attributes3, _node$assertions3;
    	  this.word("import");
    	  this.space();
    	  const isTypeKind = node.importKind === "type" || node.importKind === "typeof";
    	  if (isTypeKind) {
    	    this.noIndentInnerCommentsHere();
    	    this.word(node.importKind);
    	    this.space();
    	  } else if (node.module) {
    	    this.noIndentInnerCommentsHere();
    	    this.word("module");
    	    this.space();
    	  } else if (node.phase) {
    	    this.noIndentInnerCommentsHere();
    	    this.word(node.phase);
    	    this.space();
    	  }
    	  const specifiers = node.specifiers.slice(0);
    	  const hasSpecifiers = !!specifiers.length;
    	  while (hasSpecifiers) {
    	    const first = specifiers[0];
    	    if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {
    	      this.print(specifiers.shift(), node);
    	      if (specifiers.length) {
    	        this.tokenChar(44);
    	        this.space();
    	      }
    	    } else {
    	      break;
    	    }
    	  }
    	  if (specifiers.length) {
    	    this.tokenChar(123);
    	    this.space();
    	    this.printList(specifiers, node);
    	    this.space();
    	    this.tokenChar(125);
    	  } else if (isTypeKind && !hasSpecifiers) {
    	    this.tokenChar(123);
    	    this.tokenChar(125);
    	  }
    	  if (hasSpecifiers || isTypeKind) {
    	    this.space();
    	    this.word("from");
    	    this.space();
    	  }
    	  if ((_node$attributes3 = node.attributes) != null && _node$attributes3.length || (_node$assertions3 = node.assertions) != null && _node$assertions3.length) {
    	    this.print(node.source, node, true);
    	    this.space();
    	    this._printAttributes(node);
    	  } else {
    	    this.print(node.source, node);
    	  }
    	  this.semicolon();
    	}
    	function ImportAttribute(node) {
    	  this.print(node.key);
    	  this.tokenChar(58);
    	  this.space();
    	  this.print(node.value);
    	}
    	function ImportNamespaceSpecifier(node) {
    	  this.tokenChar(42);
    	  this.space();
    	  this.word("as");
    	  this.space();
    	  this.print(node.local, node);
    	}
    	function ImportExpression(node) {
    	  this.word("import");
    	  if (node.phase) {
    	    this.tokenChar(46);
    	    this.word(node.phase);
    	  }
    	  this.tokenChar(40);
    	  this.print(node.source, node);
    	  if (node.options != null) {
    	    this.tokenChar(44);
    	    this.space();
    	    this.print(node.options, node);
    	  }
    	  this.tokenChar(41);
    	}

    	
    	return modules;
    }

    var types = {};

    var jsesc_1;
    var hasRequiredJsesc;

    function requireJsesc () {
    	if (hasRequiredJsesc) return jsesc_1;
    	hasRequiredJsesc = 1;

    	const object = {};
    	const hasOwnProperty = object.hasOwnProperty;
    	const forOwn = (object, callback) => {
    		for (const key in object) {
    			if (hasOwnProperty.call(object, key)) {
    				callback(key, object[key]);
    			}
    		}
    	};

    	const extend = (destination, source) => {
    		if (!source) {
    			return destination;
    		}
    		forOwn(source, (key, value) => {
    			destination[key] = value;
    		});
    		return destination;
    	};

    	const forEach = (array, callback) => {
    		const length = array.length;
    		let index = -1;
    		while (++index < length) {
    			callback(array[index]);
    		}
    	};

    	const toString = object.toString;
    	const isArray = Array.isArray;
    	const isBuffer = Buffer.isBuffer;
    	const isObject = (value) => {
    		// This is a very simple check, but its good enough for what we need.
    		return toString.call(value) == '[object Object]';
    	};
    	const isString = (value) => {
    		return typeof value == 'string' ||
    			toString.call(value) == '[object String]';
    	};
    	const isNumber = (value) => {
    		return typeof value == 'number' ||
    			toString.call(value) == '[object Number]';
    	};
    	const isFunction = (value) => {
    		return typeof value == 'function';
    	};
    	const isMap = (value) => {
    		return toString.call(value) == '[object Map]';
    	};
    	const isSet = (value) => {
    		return toString.call(value) == '[object Set]';
    	};

    	/*--------------------------------------------------------------------------*/

    	// https://mathiasbynens.be/notes/javascript-escapes#single
    	const singleEscapes = {
    		'"': '\\"',
    		'\'': '\\\'',
    		'\\': '\\\\',
    		'\b': '\\b',
    		'\f': '\\f',
    		'\n': '\\n',
    		'\r': '\\r',
    		'\t': '\\t'
    		// `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
    		// '\v': '\\x0B'
    	};
    	const regexSingleEscape = /["'\\\b\f\n\r\t]/;

    	const regexDigit = /[0-9]/;
    	const regexWhitelist = /[ !#-&\(-\[\]-_a-~]/;

    	const jsesc = (argument, options) => {
    		const increaseIndentation = () => {
    			oldIndent = indent;
    			++options.indentLevel;
    			indent = options.indent.repeat(options.indentLevel);
    		};
    		// Handle options
    		const defaults = {
    			'escapeEverything': false,
    			'minimal': false,
    			'isScriptContext': false,
    			'quotes': 'single',
    			'wrap': false,
    			'es6': false,
    			'json': false,
    			'compact': true,
    			'lowercaseHex': false,
    			'numbers': 'decimal',
    			'indent': '\t',
    			'indentLevel': 0,
    			'__inline1__': false,
    			'__inline2__': false
    		};
    		const json = options && options.json;
    		if (json) {
    			defaults.quotes = 'double';
    			defaults.wrap = true;
    		}
    		options = extend(defaults, options);
    		if (
    			options.quotes != 'single' &&
    			options.quotes != 'double' &&
    			options.quotes != 'backtick'
    		) {
    			options.quotes = 'single';
    		}
    		const quote = options.quotes == 'double' ?
    			'"' :
    			(options.quotes == 'backtick' ?
    				'`' :
    				'\''
    			);
    		const compact = options.compact;
    		const lowercaseHex = options.lowercaseHex;
    		let indent = options.indent.repeat(options.indentLevel);
    		let oldIndent = '';
    		const inline1 = options.__inline1__;
    		const inline2 = options.__inline2__;
    		const newLine = compact ? '' : '\n';
    		let result;
    		let isEmpty = true;
    		const useBinNumbers = options.numbers == 'binary';
    		const useOctNumbers = options.numbers == 'octal';
    		const useDecNumbers = options.numbers == 'decimal';
    		const useHexNumbers = options.numbers == 'hexadecimal';

    		if (json && argument && isFunction(argument.toJSON)) {
    			argument = argument.toJSON();
    		}

    		if (!isString(argument)) {
    			if (isMap(argument)) {
    				if (argument.size == 0) {
    					return 'new Map()';
    				}
    				if (!compact) {
    					options.__inline1__ = true;
    					options.__inline2__ = false;
    				}
    				return 'new Map(' + jsesc(Array.from(argument), options) + ')';
    			}
    			if (isSet(argument)) {
    				if (argument.size == 0) {
    					return 'new Set()';
    				}
    				return 'new Set(' + jsesc(Array.from(argument), options) + ')';
    			}
    			if (isBuffer(argument)) {
    				if (argument.length == 0) {
    					return 'Buffer.from([])';
    				}
    				return 'Buffer.from(' + jsesc(Array.from(argument), options) + ')';
    			}
    			if (isArray(argument)) {
    				result = [];
    				options.wrap = true;
    				if (inline1) {
    					options.__inline1__ = false;
    					options.__inline2__ = true;
    				}
    				if (!inline2) {
    					increaseIndentation();
    				}
    				forEach(argument, (value) => {
    					isEmpty = false;
    					if (inline2) {
    						options.__inline2__ = false;
    					}
    					result.push(
    						(compact || inline2 ? '' : indent) +
    						jsesc(value, options)
    					);
    				});
    				if (isEmpty) {
    					return '[]';
    				}
    				if (inline2) {
    					return '[' + result.join(', ') + ']';
    				}
    				return '[' + newLine + result.join(',' + newLine) + newLine +
    					(compact ? '' : oldIndent) + ']';
    			} else if (isNumber(argument)) {
    				if (json) {
    					// Some number values (e.g. `Infinity`) cannot be represented in JSON.
    					return JSON.stringify(argument);
    				}
    				if (useDecNumbers) {
    					return String(argument);
    				}
    				if (useHexNumbers) {
    					let hexadecimal = argument.toString(16);
    					if (!lowercaseHex) {
    						hexadecimal = hexadecimal.toUpperCase();
    					}
    					return '0x' + hexadecimal;
    				}
    				if (useBinNumbers) {
    					return '0b' + argument.toString(2);
    				}
    				if (useOctNumbers) {
    					return '0o' + argument.toString(8);
    				}
    			} else if (!isObject(argument)) {
    				if (json) {
    					// For some values (e.g. `undefined`, `function` objects),
    					// `JSON.stringify(value)` returns `undefined` (which isnt valid
    					// JSON) instead of `'null'`.
    					return JSON.stringify(argument) || 'null';
    				}
    				return String(argument);
    			} else { // its an object
    				result = [];
    				options.wrap = true;
    				increaseIndentation();
    				forOwn(argument, (key, value) => {
    					isEmpty = false;
    					result.push(
    						(compact ? '' : indent) +
    						jsesc(key, options) + ':' +
    						(compact ? '' : ' ') +
    						jsesc(value, options)
    					);
    				});
    				if (isEmpty) {
    					return '{}';
    				}
    				return '{' + newLine + result.join(',' + newLine) + newLine +
    					(compact ? '' : oldIndent) + '}';
    			}
    		}

    		const string = argument;
    		// Loop over each code unit in the string and escape it
    		let index = -1;
    		const length = string.length;
    		result = '';
    		while (++index < length) {
    			const character = string.charAt(index);
    			if (options.es6) {
    				const first = string.charCodeAt(index);
    				if ( // check if its the start of a surrogate pair
    					first >= 0xD800 && first <= 0xDBFF && // high surrogate
    					length > index + 1 // there is a next code unit
    				) {
    					const second = string.charCodeAt(index + 1);
    					if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
    						// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    						const codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
    						let hexadecimal = codePoint.toString(16);
    						if (!lowercaseHex) {
    							hexadecimal = hexadecimal.toUpperCase();
    						}
    						result += '\\u{' + hexadecimal + '}';
    						++index;
    						continue;
    					}
    				}
    			}
    			if (!options.escapeEverything) {
    				if (regexWhitelist.test(character)) {
    					// Its a printable ASCII character that is not `"`, `'` or `\`,
    					// so dont escape it.
    					result += character;
    					continue;
    				}
    				if (character == '"') {
    					result += quote == character ? '\\"' : character;
    					continue;
    				}
    				if (character == '`') {
    					result += quote == character ? '\\`' : character;
    					continue;
    				}
    				if (character == '\'') {
    					result += quote == character ? '\\\'' : character;
    					continue;
    				}
    			}
    			if (
    				character == '\0' &&
    				!json &&
    				!regexDigit.test(string.charAt(index + 1))
    			) {
    				result += '\\0';
    				continue;
    			}
    			if (regexSingleEscape.test(character)) {
    				// no need for a `hasOwnProperty` check here
    				result += singleEscapes[character];
    				continue;
    			}
    			const charCode = character.charCodeAt(0);
    			if (options.minimal && charCode != 0x2028 && charCode != 0x2029) {
    				result += character;
    				continue;
    			}
    			let hexadecimal = charCode.toString(16);
    			if (!lowercaseHex) {
    				hexadecimal = hexadecimal.toUpperCase();
    			}
    			const longhand = hexadecimal.length > 2 || json;
    			const escaped = '\\' + (longhand ? 'u' : 'x') +
    				('0000' + hexadecimal).slice(longhand ? -4 : -2);
    			result += escaped;
    			continue;
    		}
    		if (options.wrap) {
    			result = quote + result + quote;
    		}
    		if (quote == '`') {
    			result = result.replace(/\$\{/g, '\\\$\{');
    		}
    		if (options.isScriptContext) {
    			// https://mathiasbynens.be/notes/etago
    			return result
    				.replace(/<\/(script|style)/gi, '<\\/$1')
    				.replace(/<!--/g, json ? '\\u003C!--' : '\\x3C!--');
    		}
    		return result;
    	};

    	jsesc.version = '2.5.2';

    	jsesc_1 = jsesc;
    	return jsesc_1;
    }

    var hasRequiredTypes;

    function requireTypes () {
    	if (hasRequiredTypes) return types;
    	hasRequiredTypes = 1;

    	Object.defineProperty(types, "__esModule", {
    	  value: true
    	});
    	types.ArgumentPlaceholder = ArgumentPlaceholder;
    	types.ArrayPattern = types.ArrayExpression = ArrayExpression;
    	types.BigIntLiteral = BigIntLiteral;
    	types.BooleanLiteral = BooleanLiteral;
    	types.DecimalLiteral = DecimalLiteral;
    	types.Identifier = Identifier;
    	types.NullLiteral = NullLiteral;
    	types.NumericLiteral = NumericLiteral;
    	types.ObjectPattern = types.ObjectExpression = ObjectExpression;
    	types.ObjectMethod = ObjectMethod;
    	types.ObjectProperty = ObjectProperty;
    	types.PipelineBareFunction = PipelineBareFunction;
    	types.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;
    	types.PipelineTopicExpression = PipelineTopicExpression;
    	types.RecordExpression = RecordExpression;
    	types.RegExpLiteral = RegExpLiteral;
    	types.SpreadElement = types.RestElement = RestElement;
    	types.StringLiteral = StringLiteral;
    	types.TopicReference = TopicReference;
    	types.TupleExpression = TupleExpression;
    	var _t = requireLib$2();
    	var _jsesc = requireJsesc();
    	const {
    	  isAssignmentPattern,
    	  isIdentifier
    	} = _t;
    	function Identifier(node) {
    	  var _node$loc;
    	  this.sourceIdentifierName(((_node$loc = node.loc) == null ? void 0 : _node$loc.identifierName) || node.name);
    	  this.word(node.name);
    	}
    	function ArgumentPlaceholder() {
    	  this.tokenChar(63);
    	}
    	function RestElement(node) {
    	  this.token("...");
    	  this.print(node.argument, node);
    	}
    	function ObjectExpression(node) {
    	  const props = node.properties;
    	  this.tokenChar(123);
    	  if (props.length) {
    	    this.space();
    	    this.printList(props, node, {
    	      indent: true,
    	      statement: true
    	    });
    	    this.space();
    	  }
    	  this.sourceWithOffset("end", node.loc, -1);
    	  this.tokenChar(125);
    	}
    	function ObjectMethod(node) {
    	  this.printJoin(node.decorators, node);
    	  this._methodHead(node);
    	  this.space();
    	  this.print(node.body, node);
    	}
    	function ObjectProperty(node) {
    	  this.printJoin(node.decorators, node);
    	  if (node.computed) {
    	    this.tokenChar(91);
    	    this.print(node.key, node);
    	    this.tokenChar(93);
    	  } else {
    	    if (isAssignmentPattern(node.value) && isIdentifier(node.key) && node.key.name === node.value.left.name) {
    	      this.print(node.value, node);
    	      return;
    	    }
    	    this.print(node.key, node);
    	    if (node.shorthand && isIdentifier(node.key) && isIdentifier(node.value) && node.key.name === node.value.name) {
    	      return;
    	    }
    	  }
    	  this.tokenChar(58);
    	  this.space();
    	  this.print(node.value, node);
    	}
    	function ArrayExpression(node) {
    	  const elems = node.elements;
    	  const len = elems.length;
    	  this.tokenChar(91);
    	  for (let i = 0; i < elems.length; i++) {
    	    const elem = elems[i];
    	    if (elem) {
    	      if (i > 0) this.space();
    	      this.print(elem, node);
    	      if (i < len - 1) this.tokenChar(44);
    	    } else {
    	      this.tokenChar(44);
    	    }
    	  }
    	  this.tokenChar(93);
    	}
    	function RecordExpression(node) {
    	  const props = node.properties;
    	  let startToken;
    	  let endToken;
    	  if (this.format.recordAndTupleSyntaxType === "bar") {
    	    startToken = "{|";
    	    endToken = "|}";
    	  } else if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null) {
    	    throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
    	  } else {
    	    startToken = "#{";
    	    endToken = "}";
    	  }
    	  this.token(startToken);
    	  if (props.length) {
    	    this.space();
    	    this.printList(props, node, {
    	      indent: true,
    	      statement: true
    	    });
    	    this.space();
    	  }
    	  this.token(endToken);
    	}
    	function TupleExpression(node) {
    	  const elems = node.elements;
    	  const len = elems.length;
    	  let startToken;
    	  let endToken;
    	  if (this.format.recordAndTupleSyntaxType === "bar") {
    	    startToken = "[|";
    	    endToken = "|]";
    	  } else if (this.format.recordAndTupleSyntaxType === "hash") {
    	    startToken = "#[";
    	    endToken = "]";
    	  } else {
    	    throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
    	  }
    	  this.token(startToken);
    	  for (let i = 0; i < elems.length; i++) {
    	    const elem = elems[i];
    	    if (elem) {
    	      if (i > 0) this.space();
    	      this.print(elem, node);
    	      if (i < len - 1) this.tokenChar(44);
    	    }
    	  }
    	  this.token(endToken);
    	}
    	function RegExpLiteral(node) {
    	  this.word(`/${node.pattern}/${node.flags}`);
    	}
    	function BooleanLiteral(node) {
    	  this.word(node.value ? "true" : "false");
    	}
    	function NullLiteral() {
    	  this.word("null");
    	}
    	function NumericLiteral(node) {
    	  const raw = this.getPossibleRaw(node);
    	  const opts = this.format.jsescOption;
    	  const value = node.value + "";
    	  if (opts.numbers) {
    	    this.number(_jsesc(node.value, opts));
    	  } else if (raw == null) {
    	    this.number(value);
    	  } else if (this.format.minified) {
    	    this.number(raw.length < value.length ? raw : value);
    	  } else {
    	    this.number(raw);
    	  }
    	}
    	function StringLiteral(node) {
    	  const raw = this.getPossibleRaw(node);
    	  if (!this.format.minified && raw !== undefined) {
    	    this.token(raw);
    	    return;
    	  }
    	  const val = _jsesc(node.value, this.format.jsescOption);
    	  this.token(val);
    	}
    	function BigIntLiteral(node) {
    	  const raw = this.getPossibleRaw(node);
    	  if (!this.format.minified && raw !== undefined) {
    	    this.word(raw);
    	    return;
    	  }
    	  this.word(node.value + "n");
    	}
    	function DecimalLiteral(node) {
    	  const raw = this.getPossibleRaw(node);
    	  if (!this.format.minified && raw !== undefined) {
    	    this.word(raw);
    	    return;
    	  }
    	  this.word(node.value + "m");
    	}
    	const validTopicTokenSet = new Set(["^^", "@@", "^", "%", "#"]);
    	function TopicReference() {
    	  const {
    	    topicToken
    	  } = this.format;
    	  if (validTopicTokenSet.has(topicToken)) {
    	    this.token(topicToken);
    	  } else {
    	    const givenTopicTokenJSON = JSON.stringify(topicToken);
    	    const validTopics = Array.from(validTopicTokenSet, v => JSON.stringify(v));
    	    throw new Error(`The "topicToken" generator option must be one of ` + `${validTopics.join(", ")} (${givenTopicTokenJSON} received instead).`);
    	  }
    	}
    	function PipelineTopicExpression(node) {
    	  this.print(node.expression, node);
    	}
    	function PipelineBareFunction(node) {
    	  this.print(node.callee, node);
    	}
    	function PipelinePrimaryTopicReference() {
    	  this.tokenChar(35);
    	}

    	
    	return types;
    }

    var flow = {};

    var hasRequiredFlow;

    function requireFlow () {
    	if (hasRequiredFlow) return flow;
    	hasRequiredFlow = 1;
    	(function (exports) {

    		Object.defineProperty(exports, "__esModule", {
    		  value: true
    		});
    		exports.AnyTypeAnnotation = AnyTypeAnnotation;
    		exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
    		exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
    		exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
    		exports.DeclareClass = DeclareClass;
    		exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
    		exports.DeclareExportDeclaration = DeclareExportDeclaration;
    		exports.DeclareFunction = DeclareFunction;
    		exports.DeclareInterface = DeclareInterface;
    		exports.DeclareModule = DeclareModule;
    		exports.DeclareModuleExports = DeclareModuleExports;
    		exports.DeclareOpaqueType = DeclareOpaqueType;
    		exports.DeclareTypeAlias = DeclareTypeAlias;
    		exports.DeclareVariable = DeclareVariable;
    		exports.DeclaredPredicate = DeclaredPredicate;
    		exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
    		exports.EnumBooleanBody = EnumBooleanBody;
    		exports.EnumBooleanMember = EnumBooleanMember;
    		exports.EnumDeclaration = EnumDeclaration;
    		exports.EnumDefaultedMember = EnumDefaultedMember;
    		exports.EnumNumberBody = EnumNumberBody;
    		exports.EnumNumberMember = EnumNumberMember;
    		exports.EnumStringBody = EnumStringBody;
    		exports.EnumStringMember = EnumStringMember;
    		exports.EnumSymbolBody = EnumSymbolBody;
    		exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
    		exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
    		exports.FunctionTypeParam = FunctionTypeParam;
    		exports.IndexedAccessType = IndexedAccessType;
    		exports.InferredPredicate = InferredPredicate;
    		exports.InterfaceDeclaration = InterfaceDeclaration;
    		exports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;
    		exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
    		exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
    		exports.MixedTypeAnnotation = MixedTypeAnnotation;
    		exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
    		exports.NullableTypeAnnotation = NullableTypeAnnotation;
    		Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _types2.NumericLiteral;
    		  }
    		});
    		exports.NumberTypeAnnotation = NumberTypeAnnotation;
    		exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
    		exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
    		exports.ObjectTypeIndexer = ObjectTypeIndexer;
    		exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
    		exports.ObjectTypeProperty = ObjectTypeProperty;
    		exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
    		exports.OpaqueType = OpaqueType;
    		exports.OptionalIndexedAccessType = OptionalIndexedAccessType;
    		exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
    		Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
    		  enumerable: true,
    		  get: function () {
    		    return _types2.StringLiteral;
    		  }
    		});
    		exports.StringTypeAnnotation = StringTypeAnnotation;
    		exports.SymbolTypeAnnotation = SymbolTypeAnnotation;
    		exports.ThisTypeAnnotation = ThisTypeAnnotation;
    		exports.TupleTypeAnnotation = TupleTypeAnnotation;
    		exports.TypeAlias = TypeAlias;
    		exports.TypeAnnotation = TypeAnnotation;
    		exports.TypeCastExpression = TypeCastExpression;
    		exports.TypeParameter = TypeParameter;
    		exports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;
    		exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
    		exports.UnionTypeAnnotation = UnionTypeAnnotation;
    		exports.Variance = Variance;
    		exports.VoidTypeAnnotation = VoidTypeAnnotation;
    		exports._interfaceish = _interfaceish;
    		exports._variance = _variance;
    		var _t = requireLib$2();
    		var _modules = requireModules();
    		var _types2 = requireTypes();
    		const {
    		  isDeclareExportDeclaration,
    		  isStatement
    		} = _t;
    		function AnyTypeAnnotation() {
    		  this.word("any");
    		}
    		function ArrayTypeAnnotation(node) {
    		  this.print(node.elementType, node, true);
    		  this.tokenChar(91);
    		  this.tokenChar(93);
    		}
    		function BooleanTypeAnnotation() {
    		  this.word("boolean");
    		}
    		function BooleanLiteralTypeAnnotation(node) {
    		  this.word(node.value ? "true" : "false");
    		}
    		function NullLiteralTypeAnnotation() {
    		  this.word("null");
    		}
    		function DeclareClass(node, parent) {
    		  if (!isDeclareExportDeclaration(parent)) {
    		    this.word("declare");
    		    this.space();
    		  }
    		  this.word("class");
    		  this.space();
    		  this._interfaceish(node);
    		}
    		function DeclareFunction(node, parent) {
    		  if (!isDeclareExportDeclaration(parent)) {
    		    this.word("declare");
    		    this.space();
    		  }
    		  this.word("function");
    		  this.space();
    		  this.print(node.id, node);
    		  this.print(node.id.typeAnnotation.typeAnnotation, node);
    		  if (node.predicate) {
    		    this.space();
    		    this.print(node.predicate, node);
    		  }
    		  this.semicolon();
    		}
    		function InferredPredicate() {
    		  this.tokenChar(37);
    		  this.word("checks");
    		}
    		function DeclaredPredicate(node) {
    		  this.tokenChar(37);
    		  this.word("checks");
    		  this.tokenChar(40);
    		  this.print(node.value, node);
    		  this.tokenChar(41);
    		}
    		function DeclareInterface(node) {
    		  this.word("declare");
    		  this.space();
    		  this.InterfaceDeclaration(node);
    		}
    		function DeclareModule(node) {
    		  this.word("declare");
    		  this.space();
    		  this.word("module");
    		  this.space();
    		  this.print(node.id, node);
    		  this.space();
    		  this.print(node.body, node);
    		}
    		function DeclareModuleExports(node) {
    		  this.word("declare");
    		  this.space();
    		  this.word("module");
    		  this.tokenChar(46);
    		  this.word("exports");
    		  this.print(node.typeAnnotation, node);
    		}
    		function DeclareTypeAlias(node) {
    		  this.word("declare");
    		  this.space();
    		  this.TypeAlias(node);
    		}
    		function DeclareOpaqueType(node, parent) {
    		  if (!isDeclareExportDeclaration(parent)) {
    		    this.word("declare");
    		    this.space();
    		  }
    		  this.OpaqueType(node);
    		}
    		function DeclareVariable(node, parent) {
    		  if (!isDeclareExportDeclaration(parent)) {
    		    this.word("declare");
    		    this.space();
    		  }
    		  this.word("var");
    		  this.space();
    		  this.print(node.id, node);
    		  this.print(node.id.typeAnnotation, node);
    		  this.semicolon();
    		}
    		function DeclareExportDeclaration(node) {
    		  this.word("declare");
    		  this.space();
    		  this.word("export");
    		  this.space();
    		  if (node.default) {
    		    this.word("default");
    		    this.space();
    		  }
    		  FlowExportDeclaration.call(this, node);
    		}
    		function DeclareExportAllDeclaration(node) {
    		  this.word("declare");
    		  this.space();
    		  _modules.ExportAllDeclaration.call(this, node);
    		}
    		function EnumDeclaration(node) {
    		  const {
    		    id,
    		    body
    		  } = node;
    		  this.word("enum");
    		  this.space();
    		  this.print(id, node);
    		  this.print(body, node);
    		}
    		function enumExplicitType(context, name, hasExplicitType) {
    		  if (hasExplicitType) {
    		    context.space();
    		    context.word("of");
    		    context.space();
    		    context.word(name);
    		  }
    		  context.space();
    		}
    		function enumBody(context, node) {
    		  const {
    		    members
    		  } = node;
    		  context.token("{");
    		  context.indent();
    		  context.newline();
    		  for (const member of members) {
    		    context.print(member, node);
    		    context.newline();
    		  }
    		  if (node.hasUnknownMembers) {
    		    context.token("...");
    		    context.newline();
    		  }
    		  context.dedent();
    		  context.token("}");
    		}
    		function EnumBooleanBody(node) {
    		  const {
    		    explicitType
    		  } = node;
    		  enumExplicitType(this, "boolean", explicitType);
    		  enumBody(this, node);
    		}
    		function EnumNumberBody(node) {
    		  const {
    		    explicitType
    		  } = node;
    		  enumExplicitType(this, "number", explicitType);
    		  enumBody(this, node);
    		}
    		function EnumStringBody(node) {
    		  const {
    		    explicitType
    		  } = node;
    		  enumExplicitType(this, "string", explicitType);
    		  enumBody(this, node);
    		}
    		function EnumSymbolBody(node) {
    		  enumExplicitType(this, "symbol", true);
    		  enumBody(this, node);
    		}
    		function EnumDefaultedMember(node) {
    		  const {
    		    id
    		  } = node;
    		  this.print(id, node);
    		  this.tokenChar(44);
    		}
    		function enumInitializedMember(context, node) {
    		  const {
    		    id,
    		    init
    		  } = node;
    		  context.print(id, node);
    		  context.space();
    		  context.token("=");
    		  context.space();
    		  context.print(init, node);
    		  context.token(",");
    		}
    		function EnumBooleanMember(node) {
    		  enumInitializedMember(this, node);
    		}
    		function EnumNumberMember(node) {
    		  enumInitializedMember(this, node);
    		}
    		function EnumStringMember(node) {
    		  enumInitializedMember(this, node);
    		}
    		function FlowExportDeclaration(node) {
    		  if (node.declaration) {
    		    const declar = node.declaration;
    		    this.print(declar, node);
    		    if (!isStatement(declar)) this.semicolon();
    		  } else {
    		    this.tokenChar(123);
    		    if (node.specifiers.length) {
    		      this.space();
    		      this.printList(node.specifiers, node);
    		      this.space();
    		    }
    		    this.tokenChar(125);
    		    if (node.source) {
    		      this.space();
    		      this.word("from");
    		      this.space();
    		      this.print(node.source, node);
    		    }
    		    this.semicolon();
    		  }
    		}
    		function ExistsTypeAnnotation() {
    		  this.tokenChar(42);
    		}
    		function FunctionTypeAnnotation(node, parent) {
    		  this.print(node.typeParameters, node);
    		  this.tokenChar(40);
    		  if (node.this) {
    		    this.word("this");
    		    this.tokenChar(58);
    		    this.space();
    		    this.print(node.this.typeAnnotation, node);
    		    if (node.params.length || node.rest) {
    		      this.tokenChar(44);
    		      this.space();
    		    }
    		  }
    		  this.printList(node.params, node);
    		  if (node.rest) {
    		    if (node.params.length) {
    		      this.tokenChar(44);
    		      this.space();
    		    }
    		    this.token("...");
    		    this.print(node.rest, node);
    		  }
    		  this.tokenChar(41);
    		  const type = parent == null ? void 0 : parent.type;
    		  if (type != null && (type === "ObjectTypeCallProperty" || type === "ObjectTypeInternalSlot" || type === "DeclareFunction" || type === "ObjectTypeProperty" && parent.method)) {
    		    this.tokenChar(58);
    		  } else {
    		    this.space();
    		    this.token("=>");
    		  }
    		  this.space();
    		  this.print(node.returnType, node);
    		}
    		function FunctionTypeParam(node) {
    		  this.print(node.name, node);
    		  if (node.optional) this.tokenChar(63);
    		  if (node.name) {
    		    this.tokenChar(58);
    		    this.space();
    		  }
    		  this.print(node.typeAnnotation, node);
    		}
    		function InterfaceExtends(node) {
    		  this.print(node.id, node);
    		  this.print(node.typeParameters, node, true);
    		}
    		function _interfaceish(node) {
    		  var _node$extends;
    		  this.print(node.id, node);
    		  this.print(node.typeParameters, node);
    		  if ((_node$extends = node.extends) != null && _node$extends.length) {
    		    this.space();
    		    this.word("extends");
    		    this.space();
    		    this.printList(node.extends, node);
    		  }
    		  if (node.type === "DeclareClass") {
    		    var _node$mixins, _node$implements;
    		    if ((_node$mixins = node.mixins) != null && _node$mixins.length) {
    		      this.space();
    		      this.word("mixins");
    		      this.space();
    		      this.printList(node.mixins, node);
    		    }
    		    if ((_node$implements = node.implements) != null && _node$implements.length) {
    		      this.space();
    		      this.word("implements");
    		      this.space();
    		      this.printList(node.implements, node);
    		    }
    		  }
    		  this.space();
    		  this.print(node.body, node);
    		}
    		function _variance(node) {
    		  var _node$variance;
    		  const kind = (_node$variance = node.variance) == null ? void 0 : _node$variance.kind;
    		  if (kind != null) {
    		    if (kind === "plus") {
    		      this.tokenChar(43);
    		    } else if (kind === "minus") {
    		      this.tokenChar(45);
    		    }
    		  }
    		}
    		function InterfaceDeclaration(node) {
    		  this.word("interface");
    		  this.space();
    		  this._interfaceish(node);
    		}
    		function andSeparator() {
    		  this.space();
    		  this.tokenChar(38);
    		  this.space();
    		}
    		function InterfaceTypeAnnotation(node) {
    		  var _node$extends2;
    		  this.word("interface");
    		  if ((_node$extends2 = node.extends) != null && _node$extends2.length) {
    		    this.space();
    		    this.word("extends");
    		    this.space();
    		    this.printList(node.extends, node);
    		  }
    		  this.space();
    		  this.print(node.body, node);
    		}
    		function IntersectionTypeAnnotation(node) {
    		  this.printJoin(node.types, node, {
    		    separator: andSeparator
    		  });
    		}
    		function MixedTypeAnnotation() {
    		  this.word("mixed");
    		}
    		function EmptyTypeAnnotation() {
    		  this.word("empty");
    		}
    		function NullableTypeAnnotation(node) {
    		  this.tokenChar(63);
    		  this.print(node.typeAnnotation, node);
    		}
    		function NumberTypeAnnotation() {
    		  this.word("number");
    		}
    		function StringTypeAnnotation() {
    		  this.word("string");
    		}
    		function ThisTypeAnnotation() {
    		  this.word("this");
    		}
    		function TupleTypeAnnotation(node) {
    		  this.tokenChar(91);
    		  this.printList(node.types, node);
    		  this.tokenChar(93);
    		}
    		function TypeofTypeAnnotation(node) {
    		  this.word("typeof");
    		  this.space();
    		  this.print(node.argument, node);
    		}
    		function TypeAlias(node) {
    		  this.word("type");
    		  this.space();
    		  this.print(node.id, node);
    		  this.print(node.typeParameters, node);
    		  this.space();
    		  this.tokenChar(61);
    		  this.space();
    		  this.print(node.right, node);
    		  this.semicolon();
    		}
    		function TypeAnnotation(node) {
    		  this.tokenChar(58);
    		  this.space();
    		  if (node.optional) this.tokenChar(63);
    		  this.print(node.typeAnnotation, node);
    		}
    		function TypeParameterInstantiation(node) {
    		  this.tokenChar(60);
    		  this.printList(node.params, node, {});
    		  this.tokenChar(62);
    		}
    		function TypeParameter(node) {
    		  this._variance(node);
    		  this.word(node.name);
    		  if (node.bound) {
    		    this.print(node.bound, node);
    		  }
    		  if (node.default) {
    		    this.space();
    		    this.tokenChar(61);
    		    this.space();
    		    this.print(node.default, node);
    		  }
    		}
    		function OpaqueType(node) {
    		  this.word("opaque");
    		  this.space();
    		  this.word("type");
    		  this.space();
    		  this.print(node.id, node);
    		  this.print(node.typeParameters, node);
    		  if (node.supertype) {
    		    this.tokenChar(58);
    		    this.space();
    		    this.print(node.supertype, node);
    		  }
    		  if (node.impltype) {
    		    this.space();
    		    this.tokenChar(61);
    		    this.space();
    		    this.print(node.impltype, node);
    		  }
    		  this.semicolon();
    		}
    		function ObjectTypeAnnotation(node) {
    		  if (node.exact) {
    		    this.token("{|");
    		  } else {
    		    this.tokenChar(123);
    		  }
    		  const props = [...node.properties, ...(node.callProperties || []), ...(node.indexers || []), ...(node.internalSlots || [])];
    		  if (props.length) {
    		    this.newline();
    		    this.space();
    		    this.printJoin(props, node, {
    		      addNewlines(leading) {
    		        if (leading && !props[0]) return 1;
    		      },
    		      indent: true,
    		      statement: true,
    		      iterator: () => {
    		        if (props.length !== 1 || node.inexact) {
    		          this.tokenChar(44);
    		          this.space();
    		        }
    		      }
    		    });
    		    this.space();
    		  }
    		  if (node.inexact) {
    		    this.indent();
    		    this.token("...");
    		    if (props.length) {
    		      this.newline();
    		    }
    		    this.dedent();
    		  }
    		  if (node.exact) {
    		    this.token("|}");
    		  } else {
    		    this.tokenChar(125);
    		  }
    		}
    		function ObjectTypeInternalSlot(node) {
    		  if (node.static) {
    		    this.word("static");
    		    this.space();
    		  }
    		  this.tokenChar(91);
    		  this.tokenChar(91);
    		  this.print(node.id, node);
    		  this.tokenChar(93);
    		  this.tokenChar(93);
    		  if (node.optional) this.tokenChar(63);
    		  if (!node.method) {
    		    this.tokenChar(58);
    		    this.space();
    		  }
    		  this.print(node.value, node);
    		}
    		function ObjectTypeCallProperty(node) {
    		  if (node.static) {
    		    this.word("static");
    		    this.space();
    		  }
    		  this.print(node.value, node);
    		}
    		function ObjectTypeIndexer(node) {
    		  if (node.static) {
    		    this.word("static");
    		    this.space();
    		  }
    		  this._variance(node);
    		  this.tokenChar(91);
    		  if (node.id) {
    		    this.print(node.id, node);
    		    this.tokenChar(58);
    		    this.space();
    		  }
    		  this.print(node.key, node);
    		  this.tokenChar(93);
    		  this.tokenChar(58);
    		  this.space();
    		  this.print(node.value, node);
    		}
    		function ObjectTypeProperty(node) {
    		  if (node.proto) {
    		    this.word("proto");
    		    this.space();
    		  }
    		  if (node.static) {
    		    this.word("static");
    		    this.space();
    		  }
    		  if (node.kind === "get" || node.kind === "set") {
    		    this.word(node.kind);
    		    this.space();
    		  }
    		  this._variance(node);
    		  this.print(node.key, node);
    		  if (node.optional) this.tokenChar(63);
    		  if (!node.method) {
    		    this.tokenChar(58);
    		    this.space();
    		  }
    		  this.print(node.value, node);
    		}
    		function ObjectTypeSpreadProperty(node) {
    		  this.token("...");
    		  this.print(node.argument, node);
    		}
    		function QualifiedTypeIdentifier(node) {
    		  this.print(node.qualification, node);
    		  this.tokenChar(46);
    		  this.print(node.id, node);
    		}
    		function SymbolTypeAnnotation() {
    		  this.word("symbol");
    		}
    		function orSeparator() {
    		  this.space();
    		  this.tokenChar(124);
    		  this.space();
    		}
    		function UnionTypeAnnotation(node) {
    		  this.printJoin(node.types, node, {
    		    separator: orSeparator
    		  });
    		}
    		function TypeCastExpression(node) {
    		  this.tokenChar(40);
    		  this.print(node.expression, node);
    		  this.print(node.typeAnnotation, node);
    		  this.tokenChar(41);
    		}
    		function Variance(node) {
    		  if (node.kind === "plus") {
    		    this.tokenChar(43);
    		  } else {
    		    this.tokenChar(45);
    		  }
    		}
    		function VoidTypeAnnotation() {
    		  this.word("void");
    		}
    		function IndexedAccessType(node) {
    		  this.print(node.objectType, node, true);
    		  this.tokenChar(91);
    		  this.print(node.indexType, node);
    		  this.tokenChar(93);
    		}
    		function OptionalIndexedAccessType(node) {
    		  this.print(node.objectType, node);
    		  if (node.optional) {
    		    this.token("?.");
    		  }
    		  this.tokenChar(91);
    		  this.print(node.indexType, node);
    		  this.tokenChar(93);
    		}

    		
    	} (flow));
    	return flow;
    }

    var base = {};

    var hasRequiredBase;

    function requireBase () {
    	if (hasRequiredBase) return base;
    	hasRequiredBase = 1;

    	Object.defineProperty(base, "__esModule", {
    	  value: true
    	});
    	base.BlockStatement = BlockStatement;
    	base.Directive = Directive;
    	base.DirectiveLiteral = DirectiveLiteral;
    	base.File = File;
    	base.InterpreterDirective = InterpreterDirective;
    	base.Placeholder = Placeholder;
    	base.Program = Program;
    	function File(node) {
    	  if (node.program) {
    	    this.print(node.program.interpreter, node);
    	  }
    	  this.print(node.program, node);
    	}
    	function Program(node) {
    	  var _node$directives;
    	  this.noIndentInnerCommentsHere();
    	  this.printInnerComments();
    	  const directivesLen = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;
    	  if (directivesLen) {
    	    var _node$directives$trai;
    	    const newline = node.body.length ? 2 : 1;
    	    this.printSequence(node.directives, node, {
    	      trailingCommentsLineOffset: newline
    	    });
    	    if (!((_node$directives$trai = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai.length)) {
    	      this.newline(newline);
    	    }
    	  }
    	  this.printSequence(node.body, node);
    	}
    	function BlockStatement(node) {
    	  var _node$directives2;
    	  this.tokenChar(123);
    	  const directivesLen = (_node$directives2 = node.directives) == null ? void 0 : _node$directives2.length;
    	  if (directivesLen) {
    	    var _node$directives$trai2;
    	    const newline = node.body.length ? 2 : 1;
    	    this.printSequence(node.directives, node, {
    	      indent: true,
    	      trailingCommentsLineOffset: newline
    	    });
    	    if (!((_node$directives$trai2 = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai2.length)) {
    	      this.newline(newline);
    	    }
    	  }
    	  this.printSequence(node.body, node, {
    	    indent: true
    	  });
    	  this.rightBrace(node);
    	}
    	function Directive(node) {
    	  this.print(node.value, node);
    	  this.semicolon();
    	}
    	const unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
    	const unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
    	function DirectiveLiteral(node) {
    	  const raw = this.getPossibleRaw(node);
    	  if (!this.format.minified && raw !== undefined) {
    	    this.token(raw);
    	    return;
    	  }
    	  const {
    	    value
    	  } = node;
    	  if (!unescapedDoubleQuoteRE.test(value)) {
    	    this.token(`"${value}"`);
    	  } else if (!unescapedSingleQuoteRE.test(value)) {
    	    this.token(`'${value}'`);
    	  } else {
    	    throw new Error("Malformed AST: it is not possible to print a directive containing" + " both unescaped single and double quotes.");
    	  }
    	}
    	function InterpreterDirective(node) {
    	  this.token(`#!${node.value}`);
    	  this.newline(1, true);
    	}
    	function Placeholder(node) {
    	  this.token("%%");
    	  this.print(node.name);
    	  this.token("%%");
    	  if (node.expectedNode === "Statement") {
    	    this.semicolon();
    	  }
    	}

    	
    	return base;
    }

    var jsx = {};

    var hasRequiredJsx;

    function requireJsx () {
    	if (hasRequiredJsx) return jsx;
    	hasRequiredJsx = 1;

    	Object.defineProperty(jsx, "__esModule", {
    	  value: true
    	});
    	jsx.JSXAttribute = JSXAttribute;
    	jsx.JSXClosingElement = JSXClosingElement;
    	jsx.JSXClosingFragment = JSXClosingFragment;
    	jsx.JSXElement = JSXElement;
    	jsx.JSXEmptyExpression = JSXEmptyExpression;
    	jsx.JSXExpressionContainer = JSXExpressionContainer;
    	jsx.JSXFragment = JSXFragment;
    	jsx.JSXIdentifier = JSXIdentifier;
    	jsx.JSXMemberExpression = JSXMemberExpression;
    	jsx.JSXNamespacedName = JSXNamespacedName;
    	jsx.JSXOpeningElement = JSXOpeningElement;
    	jsx.JSXOpeningFragment = JSXOpeningFragment;
    	jsx.JSXSpreadAttribute = JSXSpreadAttribute;
    	jsx.JSXSpreadChild = JSXSpreadChild;
    	jsx.JSXText = JSXText;
    	function JSXAttribute(node) {
    	  this.print(node.name, node);
    	  if (node.value) {
    	    this.tokenChar(61);
    	    this.print(node.value, node);
    	  }
    	}
    	function JSXIdentifier(node) {
    	  this.word(node.name);
    	}
    	function JSXNamespacedName(node) {
    	  this.print(node.namespace, node);
    	  this.tokenChar(58);
    	  this.print(node.name, node);
    	}
    	function JSXMemberExpression(node) {
    	  this.print(node.object, node);
    	  this.tokenChar(46);
    	  this.print(node.property, node);
    	}
    	function JSXSpreadAttribute(node) {
    	  this.tokenChar(123);
    	  this.token("...");
    	  this.print(node.argument, node);
    	  this.tokenChar(125);
    	}
    	function JSXExpressionContainer(node) {
    	  this.tokenChar(123);
    	  this.print(node.expression, node);
    	  this.tokenChar(125);
    	}
    	function JSXSpreadChild(node) {
    	  this.tokenChar(123);
    	  this.token("...");
    	  this.print(node.expression, node);
    	  this.tokenChar(125);
    	}
    	function JSXText(node) {
    	  const raw = this.getPossibleRaw(node);
    	  if (raw !== undefined) {
    	    this.token(raw, true);
    	  } else {
    	    this.token(node.value, true);
    	  }
    	}
    	function JSXElement(node) {
    	  const open = node.openingElement;
    	  this.print(open, node);
    	  if (open.selfClosing) return;
    	  this.indent();
    	  for (const child of node.children) {
    	    this.print(child, node);
    	  }
    	  this.dedent();
    	  this.print(node.closingElement, node);
    	}
    	function spaceSeparator() {
    	  this.space();
    	}
    	function JSXOpeningElement(node) {
    	  this.tokenChar(60);
    	  this.print(node.name, node);
    	  this.print(node.typeParameters, node);
    	  if (node.attributes.length > 0) {
    	    this.space();
    	    this.printJoin(node.attributes, node, {
    	      separator: spaceSeparator
    	    });
    	  }
    	  if (node.selfClosing) {
    	    this.space();
    	    this.token("/>");
    	  } else {
    	    this.tokenChar(62);
    	  }
    	}
    	function JSXClosingElement(node) {
    	  this.token("</");
    	  this.print(node.name, node);
    	  this.tokenChar(62);
    	}
    	function JSXEmptyExpression() {
    	  this.printInnerComments();
    	}
    	function JSXFragment(node) {
    	  this.print(node.openingFragment, node);
    	  this.indent();
    	  for (const child of node.children) {
    	    this.print(child, node);
    	  }
    	  this.dedent();
    	  this.print(node.closingFragment, node);
    	}
    	function JSXOpeningFragment() {
    	  this.tokenChar(60);
    	  this.tokenChar(62);
    	}
    	function JSXClosingFragment() {
    	  this.token("</");
    	  this.tokenChar(62);
    	}

    	
    	return jsx;
    }

    var typescript = {};

    var hasRequiredTypescript;

    function requireTypescript () {
    	if (hasRequiredTypescript) return typescript;
    	hasRequiredTypescript = 1;

    	Object.defineProperty(typescript, "__esModule", {
    	  value: true
    	});
    	typescript.TSAnyKeyword = TSAnyKeyword;
    	typescript.TSArrayType = TSArrayType;
    	typescript.TSSatisfiesExpression = typescript.TSAsExpression = TSTypeExpression;
    	typescript.TSBigIntKeyword = TSBigIntKeyword;
    	typescript.TSBooleanKeyword = TSBooleanKeyword;
    	typescript.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
    	typescript.TSConditionalType = TSConditionalType;
    	typescript.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
    	typescript.TSConstructorType = TSConstructorType;
    	typescript.TSDeclareFunction = TSDeclareFunction;
    	typescript.TSDeclareMethod = TSDeclareMethod;
    	typescript.TSEnumDeclaration = TSEnumDeclaration;
    	typescript.TSEnumMember = TSEnumMember;
    	typescript.TSExportAssignment = TSExportAssignment;
    	typescript.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;
    	typescript.TSExternalModuleReference = TSExternalModuleReference;
    	typescript.TSFunctionType = TSFunctionType;
    	typescript.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
    	typescript.TSImportType = TSImportType;
    	typescript.TSIndexSignature = TSIndexSignature;
    	typescript.TSIndexedAccessType = TSIndexedAccessType;
    	typescript.TSInferType = TSInferType;
    	typescript.TSInstantiationExpression = TSInstantiationExpression;
    	typescript.TSInterfaceBody = TSInterfaceBody;
    	typescript.TSInterfaceDeclaration = TSInterfaceDeclaration;
    	typescript.TSIntersectionType = TSIntersectionType;
    	typescript.TSIntrinsicKeyword = TSIntrinsicKeyword;
    	typescript.TSLiteralType = TSLiteralType;
    	typescript.TSMappedType = TSMappedType;
    	typescript.TSMethodSignature = TSMethodSignature;
    	typescript.TSModuleBlock = TSModuleBlock;
    	typescript.TSModuleDeclaration = TSModuleDeclaration;
    	typescript.TSNamedTupleMember = TSNamedTupleMember;
    	typescript.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
    	typescript.TSNeverKeyword = TSNeverKeyword;
    	typescript.TSNonNullExpression = TSNonNullExpression;
    	typescript.TSNullKeyword = TSNullKeyword;
    	typescript.TSNumberKeyword = TSNumberKeyword;
    	typescript.TSObjectKeyword = TSObjectKeyword;
    	typescript.TSOptionalType = TSOptionalType;
    	typescript.TSParameterProperty = TSParameterProperty;
    	typescript.TSParenthesizedType = TSParenthesizedType;
    	typescript.TSPropertySignature = TSPropertySignature;
    	typescript.TSQualifiedName = TSQualifiedName;
    	typescript.TSRestType = TSRestType;
    	typescript.TSStringKeyword = TSStringKeyword;
    	typescript.TSSymbolKeyword = TSSymbolKeyword;
    	typescript.TSThisType = TSThisType;
    	typescript.TSTupleType = TSTupleType;
    	typescript.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
    	typescript.TSTypeAnnotation = TSTypeAnnotation;
    	typescript.TSTypeAssertion = TSTypeAssertion;
    	typescript.TSTypeLiteral = TSTypeLiteral;
    	typescript.TSTypeOperator = TSTypeOperator;
    	typescript.TSTypeParameter = TSTypeParameter;
    	typescript.TSTypeParameterDeclaration = typescript.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
    	typescript.TSTypePredicate = TSTypePredicate;
    	typescript.TSTypeQuery = TSTypeQuery;
    	typescript.TSTypeReference = TSTypeReference;
    	typescript.TSUndefinedKeyword = TSUndefinedKeyword;
    	typescript.TSUnionType = TSUnionType;
    	typescript.TSUnknownKeyword = TSUnknownKeyword;
    	typescript.TSVoidKeyword = TSVoidKeyword;
    	typescript.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;
    	typescript.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
    	typescript.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
    	typescript.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;
    	typescript.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;
    	function TSTypeAnnotation(node) {
    	  this.tokenChar(58);
    	  this.space();
    	  if (node.optional) this.tokenChar(63);
    	  this.print(node.typeAnnotation, node);
    	}
    	function TSTypeParameterInstantiation(node, parent) {
    	  this.tokenChar(60);
    	  this.printList(node.params, node, {});
    	  if (parent.type === "ArrowFunctionExpression" && node.params.length === 1) {
    	    this.tokenChar(44);
    	  }
    	  this.tokenChar(62);
    	}
    	function TSTypeParameter(node) {
    	  if (node.in) {
    	    this.word("in");
    	    this.space();
    	  }
    	  if (node.out) {
    	    this.word("out");
    	    this.space();
    	  }
    	  this.word(node.name);
    	  if (node.constraint) {
    	    this.space();
    	    this.word("extends");
    	    this.space();
    	    this.print(node.constraint, node);
    	  }
    	  if (node.default) {
    	    this.space();
    	    this.tokenChar(61);
    	    this.space();
    	    this.print(node.default, node);
    	  }
    	}
    	function TSParameterProperty(node) {
    	  if (node.accessibility) {
    	    this.word(node.accessibility);
    	    this.space();
    	  }
    	  if (node.readonly) {
    	    this.word("readonly");
    	    this.space();
    	  }
    	  this._param(node.parameter);
    	}
    	function TSDeclareFunction(node, parent) {
    	  if (node.declare) {
    	    this.word("declare");
    	    this.space();
    	  }
    	  this._functionHead(node, parent);
    	  this.tokenChar(59);
    	}
    	function TSDeclareMethod(node) {
    	  this._classMethodHead(node);
    	  this.tokenChar(59);
    	}
    	function TSQualifiedName(node) {
    	  this.print(node.left, node);
    	  this.tokenChar(46);
    	  this.print(node.right, node);
    	}
    	function TSCallSignatureDeclaration(node) {
    	  this.tsPrintSignatureDeclarationBase(node);
    	  this.tokenChar(59);
    	}
    	function TSConstructSignatureDeclaration(node) {
    	  this.word("new");
    	  this.space();
    	  this.tsPrintSignatureDeclarationBase(node);
    	  this.tokenChar(59);
    	}
    	function TSPropertySignature(node) {
    	  const {
    	    readonly,
    	    initializer
    	  } = node;
    	  if (readonly) {
    	    this.word("readonly");
    	    this.space();
    	  }
    	  this.tsPrintPropertyOrMethodName(node);
    	  this.print(node.typeAnnotation, node);
    	  if (initializer) {
    	    this.space();
    	    this.tokenChar(61);
    	    this.space();
    	    this.print(initializer, node);
    	  }
    	  this.tokenChar(59);
    	}
    	function tsPrintPropertyOrMethodName(node) {
    	  if (node.computed) {
    	    this.tokenChar(91);
    	  }
    	  this.print(node.key, node);
    	  if (node.computed) {
    	    this.tokenChar(93);
    	  }
    	  if (node.optional) {
    	    this.tokenChar(63);
    	  }
    	}
    	function TSMethodSignature(node) {
    	  const {
    	    kind
    	  } = node;
    	  if (kind === "set" || kind === "get") {
    	    this.word(kind);
    	    this.space();
    	  }
    	  this.tsPrintPropertyOrMethodName(node);
    	  this.tsPrintSignatureDeclarationBase(node);
    	  this.tokenChar(59);
    	}
    	function TSIndexSignature(node) {
    	  const {
    	    readonly,
    	    static: isStatic
    	  } = node;
    	  if (isStatic) {
    	    this.word("static");
    	    this.space();
    	  }
    	  if (readonly) {
    	    this.word("readonly");
    	    this.space();
    	  }
    	  this.tokenChar(91);
    	  this._parameters(node.parameters, node);
    	  this.tokenChar(93);
    	  this.print(node.typeAnnotation, node);
    	  this.tokenChar(59);
    	}
    	function TSAnyKeyword() {
    	  this.word("any");
    	}
    	function TSBigIntKeyword() {
    	  this.word("bigint");
    	}
    	function TSUnknownKeyword() {
    	  this.word("unknown");
    	}
    	function TSNumberKeyword() {
    	  this.word("number");
    	}
    	function TSObjectKeyword() {
    	  this.word("object");
    	}
    	function TSBooleanKeyword() {
    	  this.word("boolean");
    	}
    	function TSStringKeyword() {
    	  this.word("string");
    	}
    	function TSSymbolKeyword() {
    	  this.word("symbol");
    	}
    	function TSVoidKeyword() {
    	  this.word("void");
    	}
    	function TSUndefinedKeyword() {
    	  this.word("undefined");
    	}
    	function TSNullKeyword() {
    	  this.word("null");
    	}
    	function TSNeverKeyword() {
    	  this.word("never");
    	}
    	function TSIntrinsicKeyword() {
    	  this.word("intrinsic");
    	}
    	function TSThisType() {
    	  this.word("this");
    	}
    	function TSFunctionType(node) {
    	  this.tsPrintFunctionOrConstructorType(node);
    	}
    	function TSConstructorType(node) {
    	  if (node.abstract) {
    	    this.word("abstract");
    	    this.space();
    	  }
    	  this.word("new");
    	  this.space();
    	  this.tsPrintFunctionOrConstructorType(node);
    	}
    	function tsPrintFunctionOrConstructorType(node) {
    	  const {
    	    typeParameters
    	  } = node;
    	  const parameters = node.parameters;
    	  this.print(typeParameters, node);
    	  this.tokenChar(40);
    	  this._parameters(parameters, node);
    	  this.tokenChar(41);
    	  this.space();
    	  this.token("=>");
    	  this.space();
    	  const returnType = node.typeAnnotation;
    	  this.print(returnType.typeAnnotation, node);
    	}
    	function TSTypeReference(node) {
    	  this.print(node.typeName, node, true);
    	  this.print(node.typeParameters, node, true);
    	}
    	function TSTypePredicate(node) {
    	  if (node.asserts) {
    	    this.word("asserts");
    	    this.space();
    	  }
    	  this.print(node.parameterName);
    	  if (node.typeAnnotation) {
    	    this.space();
    	    this.word("is");
    	    this.space();
    	    this.print(node.typeAnnotation.typeAnnotation);
    	  }
    	}
    	function TSTypeQuery(node) {
    	  this.word("typeof");
    	  this.space();
    	  this.print(node.exprName);
    	  if (node.typeParameters) {
    	    this.print(node.typeParameters, node);
    	  }
    	}
    	function TSTypeLiteral(node) {
    	  this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);
    	}
    	function tsPrintTypeLiteralOrInterfaceBody(members, node) {
    	  tsPrintBraced(this, members, node);
    	}
    	function tsPrintBraced(printer, members, node) {
    	  printer.token("{");
    	  if (members.length) {
    	    printer.indent();
    	    printer.newline();
    	    for (const member of members) {
    	      printer.print(member, node);
    	      printer.newline();
    	    }
    	    printer.dedent();
    	  }
    	  printer.rightBrace(node);
    	}
    	function TSArrayType(node) {
    	  this.print(node.elementType, node, true);
    	  this.token("[]");
    	}
    	function TSTupleType(node) {
    	  this.tokenChar(91);
    	  this.printList(node.elementTypes, node);
    	  this.tokenChar(93);
    	}
    	function TSOptionalType(node) {
    	  this.print(node.typeAnnotation, node);
    	  this.tokenChar(63);
    	}
    	function TSRestType(node) {
    	  this.token("...");
    	  this.print(node.typeAnnotation, node);
    	}
    	function TSNamedTupleMember(node) {
    	  this.print(node.label, node);
    	  if (node.optional) this.tokenChar(63);
    	  this.tokenChar(58);
    	  this.space();
    	  this.print(node.elementType, node);
    	}
    	function TSUnionType(node) {
    	  tsPrintUnionOrIntersectionType(this, node, "|");
    	}
    	function TSIntersectionType(node) {
    	  tsPrintUnionOrIntersectionType(this, node, "&");
    	}
    	function tsPrintUnionOrIntersectionType(printer, node, sep) {
    	  printer.printJoin(node.types, node, {
    	    separator() {
    	      this.space();
    	      this.token(sep);
    	      this.space();
    	    }
    	  });
    	}
    	function TSConditionalType(node) {
    	  this.print(node.checkType);
    	  this.space();
    	  this.word("extends");
    	  this.space();
    	  this.print(node.extendsType);
    	  this.space();
    	  this.tokenChar(63);
    	  this.space();
    	  this.print(node.trueType);
    	  this.space();
    	  this.tokenChar(58);
    	  this.space();
    	  this.print(node.falseType);
    	}
    	function TSInferType(node) {
    	  this.token("infer");
    	  this.space();
    	  this.print(node.typeParameter);
    	}
    	function TSParenthesizedType(node) {
    	  this.tokenChar(40);
    	  this.print(node.typeAnnotation, node);
    	  this.tokenChar(41);
    	}
    	function TSTypeOperator(node) {
    	  this.word(node.operator);
    	  this.space();
    	  this.print(node.typeAnnotation, node);
    	}
    	function TSIndexedAccessType(node) {
    	  this.print(node.objectType, node, true);
    	  this.tokenChar(91);
    	  this.print(node.indexType, node);
    	  this.tokenChar(93);
    	}
    	function TSMappedType(node) {
    	  const {
    	    nameType,
    	    optional,
    	    readonly,
    	    typeParameter
    	  } = node;
    	  this.tokenChar(123);
    	  this.space();
    	  if (readonly) {
    	    tokenIfPlusMinus(this, readonly);
    	    this.word("readonly");
    	    this.space();
    	  }
    	  this.tokenChar(91);
    	  this.word(typeParameter.name);
    	  this.space();
    	  this.word("in");
    	  this.space();
    	  this.print(typeParameter.constraint, typeParameter);
    	  if (nameType) {
    	    this.space();
    	    this.word("as");
    	    this.space();
    	    this.print(nameType, node);
    	  }
    	  this.tokenChar(93);
    	  if (optional) {
    	    tokenIfPlusMinus(this, optional);
    	    this.tokenChar(63);
    	  }
    	  this.tokenChar(58);
    	  this.space();
    	  this.print(node.typeAnnotation, node);
    	  this.space();
    	  this.tokenChar(125);
    	}
    	function tokenIfPlusMinus(self, tok) {
    	  if (tok !== true) {
    	    self.token(tok);
    	  }
    	}
    	function TSLiteralType(node) {
    	  this.print(node.literal, node);
    	}
    	function TSExpressionWithTypeArguments(node) {
    	  this.print(node.expression, node);
    	  this.print(node.typeParameters, node);
    	}
    	function TSInterfaceDeclaration(node) {
    	  const {
    	    declare,
    	    id,
    	    typeParameters,
    	    extends: extendz,
    	    body
    	  } = node;
    	  if (declare) {
    	    this.word("declare");
    	    this.space();
    	  }
    	  this.word("interface");
    	  this.space();
    	  this.print(id, node);
    	  this.print(typeParameters, node);
    	  if (extendz != null && extendz.length) {
    	    this.space();
    	    this.word("extends");
    	    this.space();
    	    this.printList(extendz, node);
    	  }
    	  this.space();
    	  this.print(body, node);
    	}
    	function TSInterfaceBody(node) {
    	  this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);
    	}
    	function TSTypeAliasDeclaration(node) {
    	  const {
    	    declare,
    	    id,
    	    typeParameters,
    	    typeAnnotation
    	  } = node;
    	  if (declare) {
    	    this.word("declare");
    	    this.space();
    	  }
    	  this.word("type");
    	  this.space();
    	  this.print(id, node);
    	  this.print(typeParameters, node);
    	  this.space();
    	  this.tokenChar(61);
    	  this.space();
    	  this.print(typeAnnotation, node);
    	  this.tokenChar(59);
    	}
    	function TSTypeExpression(node) {
    	  var _expression$trailingC;
    	  const {
    	    type,
    	    expression,
    	    typeAnnotation
    	  } = node;
    	  const forceParens = !!((_expression$trailingC = expression.trailingComments) != null && _expression$trailingC.length);
    	  this.print(expression, node, true, undefined, forceParens);
    	  this.space();
    	  this.word(type === "TSAsExpression" ? "as" : "satisfies");
    	  this.space();
    	  this.print(typeAnnotation, node);
    	}
    	function TSTypeAssertion(node) {
    	  const {
    	    typeAnnotation,
    	    expression
    	  } = node;
    	  this.tokenChar(60);
    	  this.print(typeAnnotation, node);
    	  this.tokenChar(62);
    	  this.space();
    	  this.print(expression, node);
    	}
    	function TSInstantiationExpression(node) {
    	  this.print(node.expression, node);
    	  this.print(node.typeParameters, node);
    	}
    	function TSEnumDeclaration(node) {
    	  const {
    	    declare,
    	    const: isConst,
    	    id,
    	    members
    	  } = node;
    	  if (declare) {
    	    this.word("declare");
    	    this.space();
    	  }
    	  if (isConst) {
    	    this.word("const");
    	    this.space();
    	  }
    	  this.word("enum");
    	  this.space();
    	  this.print(id, node);
    	  this.space();
    	  tsPrintBraced(this, members, node);
    	}
    	function TSEnumMember(node) {
    	  const {
    	    id,
    	    initializer
    	  } = node;
    	  this.print(id, node);
    	  if (initializer) {
    	    this.space();
    	    this.tokenChar(61);
    	    this.space();
    	    this.print(initializer, node);
    	  }
    	  this.tokenChar(44);
    	}
    	function TSModuleDeclaration(node) {
    	  const {
    	    declare,
    	    id
    	  } = node;
    	  if (declare) {
    	    this.word("declare");
    	    this.space();
    	  }
    	  if (!node.global) {
    	    this.word(id.type === "Identifier" ? "namespace" : "module");
    	    this.space();
    	  }
    	  this.print(id, node);
    	  if (!node.body) {
    	    this.tokenChar(59);
    	    return;
    	  }
    	  let body = node.body;
    	  while (body.type === "TSModuleDeclaration") {
    	    this.tokenChar(46);
    	    this.print(body.id, body);
    	    body = body.body;
    	  }
    	  this.space();
    	  this.print(body, node);
    	}
    	function TSModuleBlock(node) {
    	  tsPrintBraced(this, node.body, node);
    	}
    	function TSImportType(node) {
    	  const {
    	    argument,
    	    qualifier,
    	    typeParameters
    	  } = node;
    	  this.word("import");
    	  this.tokenChar(40);
    	  this.print(argument, node);
    	  this.tokenChar(41);
    	  if (qualifier) {
    	    this.tokenChar(46);
    	    this.print(qualifier, node);
    	  }
    	  if (typeParameters) {
    	    this.print(typeParameters, node);
    	  }
    	}
    	function TSImportEqualsDeclaration(node) {
    	  const {
    	    isExport,
    	    id,
    	    moduleReference
    	  } = node;
    	  if (isExport) {
    	    this.word("export");
    	    this.space();
    	  }
    	  this.word("import");
    	  this.space();
    	  this.print(id, node);
    	  this.space();
    	  this.tokenChar(61);
    	  this.space();
    	  this.print(moduleReference, node);
    	  this.tokenChar(59);
    	}
    	function TSExternalModuleReference(node) {
    	  this.token("require(");
    	  this.print(node.expression, node);
    	  this.tokenChar(41);
    	}
    	function TSNonNullExpression(node) {
    	  this.print(node.expression, node);
    	  this.tokenChar(33);
    	}
    	function TSExportAssignment(node) {
    	  this.word("export");
    	  this.space();
    	  this.tokenChar(61);
    	  this.space();
    	  this.print(node.expression, node);
    	  this.tokenChar(59);
    	}
    	function TSNamespaceExportDeclaration(node) {
    	  this.word("export");
    	  this.space();
    	  this.word("as");
    	  this.space();
    	  this.word("namespace");
    	  this.space();
    	  this.print(node.id, node);
    	}
    	function tsPrintSignatureDeclarationBase(node) {
    	  const {
    	    typeParameters
    	  } = node;
    	  const parameters = node.parameters;
    	  this.print(typeParameters, node);
    	  this.tokenChar(40);
    	  this._parameters(parameters, node);
    	  this.tokenChar(41);
    	  const returnType = node.typeAnnotation;
    	  this.print(returnType, node);
    	}
    	function tsPrintClassMemberModifiers(node) {
    	  const isField = node.type === "ClassAccessorProperty" || node.type === "ClassProperty";
    	  if (isField && node.declare) {
    	    this.word("declare");
    	    this.space();
    	  }
    	  if (node.accessibility) {
    	    this.word(node.accessibility);
    	    this.space();
    	  }
    	  if (node.static) {
    	    this.word("static");
    	    this.space();
    	  }
    	  if (node.override) {
    	    this.word("override");
    	    this.space();
    	  }
    	  if (node.abstract) {
    	    this.word("abstract");
    	    this.space();
    	  }
    	  if (isField && node.readonly) {
    	    this.word("readonly");
    	    this.space();
    	  }
    	}

    	
    	return typescript;
    }

    var hasRequiredGenerators;

    function requireGenerators () {
    	if (hasRequiredGenerators) return generators;
    	hasRequiredGenerators = 1;
    	(function (exports) {

    		Object.defineProperty(exports, "__esModule", {
    		  value: true
    		});
    		var _templateLiterals = requireTemplateLiterals();
    		Object.keys(_templateLiterals).forEach(function (key) {
    		  if (key === "default" || key === "__esModule") return;
    		  if (key in exports && exports[key] === _templateLiterals[key]) return;
    		  Object.defineProperty(exports, key, {
    		    enumerable: true,
    		    get: function () {
    		      return _templateLiterals[key];
    		    }
    		  });
    		});
    		var _expressions = requireExpressions();
    		Object.keys(_expressions).forEach(function (key) {
    		  if (key === "default" || key === "__esModule") return;
    		  if (key in exports && exports[key] === _expressions[key]) return;
    		  Object.defineProperty(exports, key, {
    		    enumerable: true,
    		    get: function () {
    		      return _expressions[key];
    		    }
    		  });
    		});
    		var _statements = requireStatements();
    		Object.keys(_statements).forEach(function (key) {
    		  if (key === "default" || key === "__esModule") return;
    		  if (key in exports && exports[key] === _statements[key]) return;
    		  Object.defineProperty(exports, key, {
    		    enumerable: true,
    		    get: function () {
    		      return _statements[key];
    		    }
    		  });
    		});
    		var _classes = requireClasses();
    		Object.keys(_classes).forEach(function (key) {
    		  if (key === "default" || key === "__esModule") return;
    		  if (key in exports && exports[key] === _classes[key]) return;
    		  Object.defineProperty(exports, key, {
    		    enumerable: true,
    		    get: function () {
    		      return _classes[key];
    		    }
    		  });
    		});
    		var _methods = requireMethods();
    		Object.keys(_methods).forEach(function (key) {
    		  if (key === "default" || key === "__esModule") return;
    		  if (key in exports && exports[key] === _methods[key]) return;
    		  Object.defineProperty(exports, key, {
    		    enumerable: true,
    		    get: function () {
    		      return _methods[key];
    		    }
    		  });
    		});
    		var _modules = requireModules();
    		Object.keys(_modules).forEach(function (key) {
    		  if (key === "default" || key === "__esModule") return;
    		  if (key in exports && exports[key] === _modules[key]) return;
    		  Object.defineProperty(exports, key, {
    		    enumerable: true,
    		    get: function () {
    		      return _modules[key];
    		    }
    		  });
    		});
    		var _types = requireTypes();
    		Object.keys(_types).forEach(function (key) {
    		  if (key === "default" || key === "__esModule") return;
    		  if (key in exports && exports[key] === _types[key]) return;
    		  Object.defineProperty(exports, key, {
    		    enumerable: true,
    		    get: function () {
    		      return _types[key];
    		    }
    		  });
    		});
    		var _flow = requireFlow();
    		Object.keys(_flow).forEach(function (key) {
    		  if (key === "default" || key === "__esModule") return;
    		  if (key in exports && exports[key] === _flow[key]) return;
    		  Object.defineProperty(exports, key, {
    		    enumerable: true,
    		    get: function () {
    		      return _flow[key];
    		    }
    		  });
    		});
    		var _base = requireBase();
    		Object.keys(_base).forEach(function (key) {
    		  if (key === "default" || key === "__esModule") return;
    		  if (key in exports && exports[key] === _base[key]) return;
    		  Object.defineProperty(exports, key, {
    		    enumerable: true,
    		    get: function () {
    		      return _base[key];
    		    }
    		  });
    		});
    		var _jsx = requireJsx();
    		Object.keys(_jsx).forEach(function (key) {
    		  if (key === "default" || key === "__esModule") return;
    		  if (key in exports && exports[key] === _jsx[key]) return;
    		  Object.defineProperty(exports, key, {
    		    enumerable: true,
    		    get: function () {
    		      return _jsx[key];
    		    }
    		  });
    		});
    		var _typescript = requireTypescript();
    		Object.keys(_typescript).forEach(function (key) {
    		  if (key === "default" || key === "__esModule") return;
    		  if (key in exports && exports[key] === _typescript[key]) return;
    		  Object.defineProperty(exports, key, {
    		    enumerable: true,
    		    get: function () {
    		      return _typescript[key];
    		    }
    		  });
    		});

    		
    	} (generators));
    	return generators;
    }

    var hasRequiredPrinter;

    function requirePrinter () {
    	if (hasRequiredPrinter) return printer;
    	hasRequiredPrinter = 1;

    	Object.defineProperty(printer, "__esModule", {
    	  value: true
    	});
    	printer.default = void 0;
    	var _buffer = requireBuffer();
    	var n = requireNode();
    	var _t = requireLib$2();
    	var generatorFunctions = requireGenerators();
    	const {
    	  isFunction,
    	  isStatement,
    	  isClassBody,
    	  isTSInterfaceBody,
    	  isTSEnumDeclaration
    	} = _t;
    	const SCIENTIFIC_NOTATION = /e/i;
    	const ZERO_DECIMAL_INTEGER = /\.0+$/;
    	const NON_DECIMAL_LITERAL = /^0[box]/;
    	const PURE_ANNOTATION_RE = /^\s*[@#]__PURE__\s*$/;
    	const HAS_NEWLINE = /[\n\r\u2028\u2029]/;
    	const HAS_BlOCK_COMMENT_END = /\*\//;
    	const {
    	  needsParens
    	} = n;
    	class Printer {
    	  constructor(format, map) {
    	    this.inForStatementInitCounter = 0;
    	    this._printStack = [];
    	    this._indent = 0;
    	    this._indentChar = 0;
    	    this._indentRepeat = 0;
    	    this._insideAux = false;
    	    this._parenPushNewlineState = null;
    	    this._noLineTerminator = false;
    	    this._printAuxAfterOnNextUserNode = false;
    	    this._printedComments = new Set();
    	    this._endsWithInteger = false;
    	    this._endsWithWord = false;
    	    this._lastCommentLine = 0;
    	    this._endsWithInnerRaw = false;
    	    this._indentInnerComments = true;
    	    this.format = format;
    	    this._buf = new _buffer.default(map);
    	    this._indentChar = format.indent.style.charCodeAt(0);
    	    this._indentRepeat = format.indent.style.length;
    	    this._inputMap = map == null ? void 0 : map._inputMap;
    	  }
    	  generate(ast) {
    	    this.print(ast);
    	    this._maybeAddAuxComment();
    	    return this._buf.get();
    	  }
    	  indent() {
    	    if (this.format.compact || this.format.concise) return;
    	    this._indent++;
    	  }
    	  dedent() {
    	    if (this.format.compact || this.format.concise) return;
    	    this._indent--;
    	  }
    	  semicolon(force = false) {
    	    this._maybeAddAuxComment();
    	    if (force) {
    	      this._appendChar(59);
    	    } else {
    	      this._queue(59);
    	    }
    	    this._noLineTerminator = false;
    	  }
    	  rightBrace(node) {
    	    if (this.format.minified) {
    	      this._buf.removeLastSemicolon();
    	    }
    	    this.sourceWithOffset("end", node.loc, -1);
    	    this.tokenChar(125);
    	  }
    	  rightParens(node) {
    	    this.sourceWithOffset("end", node.loc, -1);
    	    this.tokenChar(41);
    	  }
    	  space(force = false) {
    	    if (this.format.compact) return;
    	    if (force) {
    	      this._space();
    	    } else if (this._buf.hasContent()) {
    	      const lastCp = this.getLastChar();
    	      if (lastCp !== 32 && lastCp !== 10) {
    	        this._space();
    	      }
    	    }
    	  }
    	  word(str, noLineTerminatorAfter = false) {
    	    this._maybePrintInnerComments();
    	    if (this._endsWithWord || str.charCodeAt(0) === 47 && this.endsWith(47)) {
    	      this._space();
    	    }
    	    this._maybeAddAuxComment();
    	    this._append(str, false);
    	    this._endsWithWord = true;
    	    this._noLineTerminator = noLineTerminatorAfter;
    	  }
    	  number(str) {
    	    this.word(str);
    	    this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;
    	  }
    	  token(str, maybeNewline = false) {
    	    this._maybePrintInnerComments();
    	    const lastChar = this.getLastChar();
    	    const strFirst = str.charCodeAt(0);
    	    if (lastChar === 33 && (str === "--" || strFirst === 61) || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {
    	      this._space();
    	    }
    	    this._maybeAddAuxComment();
    	    this._append(str, maybeNewline);
    	    this._noLineTerminator = false;
    	  }
    	  tokenChar(char) {
    	    this._maybePrintInnerComments();
    	    const lastChar = this.getLastChar();
    	    if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) {
    	      this._space();
    	    }
    	    this._maybeAddAuxComment();
    	    this._appendChar(char);
    	    this._noLineTerminator = false;
    	  }
    	  newline(i = 1, force) {
    	    if (i <= 0) return;
    	    if (!force) {
    	      if (this.format.retainLines || this.format.compact) return;
    	      if (this.format.concise) {
    	        this.space();
    	        return;
    	      }
    	    }
    	    if (i > 2) i = 2;
    	    i -= this._buf.getNewlineCount();
    	    for (let j = 0; j < i; j++) {
    	      this._newline();
    	    }
    	    return;
    	  }
    	  endsWith(char) {
    	    return this.getLastChar() === char;
    	  }
    	  getLastChar() {
    	    return this._buf.getLastChar();
    	  }
    	  endsWithCharAndNewline() {
    	    return this._buf.endsWithCharAndNewline();
    	  }
    	  removeTrailingNewline() {
    	    this._buf.removeTrailingNewline();
    	  }
    	  exactSource(loc, cb) {
    	    if (!loc) {
    	      cb();
    	      return;
    	    }
    	    this._catchUp("start", loc);
    	    this._buf.exactSource(loc, cb);
    	  }
    	  source(prop, loc) {
    	    if (!loc) return;
    	    this._catchUp(prop, loc);
    	    this._buf.source(prop, loc);
    	  }
    	  sourceWithOffset(prop, loc, columnOffset) {
    	    if (!loc) return;
    	    this._catchUp(prop, loc);
    	    this._buf.sourceWithOffset(prop, loc, columnOffset);
    	  }
    	  withSource(prop, loc, cb) {
    	    if (!loc) {
    	      cb();
    	      return;
    	    }
    	    this._catchUp(prop, loc);
    	    this._buf.withSource(prop, loc, cb);
    	  }
    	  sourceIdentifierName(identifierName, pos) {
    	    if (!this._buf._canMarkIdName) return;
    	    const sourcePosition = this._buf._sourcePosition;
    	    sourcePosition.identifierNamePos = pos;
    	    sourcePosition.identifierName = identifierName;
    	  }
    	  _space() {
    	    this._queue(32);
    	  }
    	  _newline() {
    	    this._queue(10);
    	  }
    	  _append(str, maybeNewline) {
    	    this._maybeAddParen(str);
    	    this._maybeIndent(str.charCodeAt(0));
    	    this._buf.append(str, maybeNewline);
    	    this._endsWithWord = false;
    	    this._endsWithInteger = false;
    	  }
    	  _appendChar(char) {
    	    this._maybeAddParenChar(char);
    	    this._maybeIndent(char);
    	    this._buf.appendChar(char);
    	    this._endsWithWord = false;
    	    this._endsWithInteger = false;
    	  }
    	  _queue(char) {
    	    this._maybeAddParenChar(char);
    	    this._maybeIndent(char);
    	    this._buf.queue(char);
    	    this._endsWithWord = false;
    	    this._endsWithInteger = false;
    	  }
    	  _maybeIndent(firstChar) {
    	    if (this._indent && firstChar !== 10 && this.endsWith(10)) {
    	      this._buf.queueIndentation(this._indentChar, this._getIndent());
    	    }
    	  }
    	  _shouldIndent(firstChar) {
    	    if (this._indent && firstChar !== 10 && this.endsWith(10)) {
    	      return true;
    	    }
    	  }
    	  _maybeAddParenChar(char) {
    	    const parenPushNewlineState = this._parenPushNewlineState;
    	    if (!parenPushNewlineState) return;
    	    if (char === 32) {
    	      return;
    	    }
    	    if (char !== 10) {
    	      this._parenPushNewlineState = null;
    	      return;
    	    }
    	    this.tokenChar(40);
    	    this.indent();
    	    parenPushNewlineState.printed = true;
    	  }
    	  _maybeAddParen(str) {
    	    const parenPushNewlineState = this._parenPushNewlineState;
    	    if (!parenPushNewlineState) return;
    	    const len = str.length;
    	    let i;
    	    for (i = 0; i < len && str.charCodeAt(i) === 32; i++) continue;
    	    if (i === len) {
    	      return;
    	    }
    	    const cha = str.charCodeAt(i);
    	    if (cha !== 10) {
    	      if (cha !== 47 || i + 1 === len) {
    	        this._parenPushNewlineState = null;
    	        return;
    	      }
    	      const chaPost = str.charCodeAt(i + 1);
    	      if (chaPost === 42) {
    	        if (PURE_ANNOTATION_RE.test(str.slice(i + 2, len - 2))) {
    	          return;
    	        }
    	      } else if (chaPost !== 47) {
    	        this._parenPushNewlineState = null;
    	        return;
    	      }
    	    }
    	    this.tokenChar(40);
    	    this.indent();
    	    parenPushNewlineState.printed = true;
    	  }
    	  catchUp(line) {
    	    if (!this.format.retainLines) return;
    	    const count = line - this._buf.getCurrentLine();
    	    for (let i = 0; i < count; i++) {
    	      this._newline();
    	    }
    	  }
    	  _catchUp(prop, loc) {
    	    var _loc$prop;
    	    if (!this.format.retainLines) return;
    	    const line = loc == null || (_loc$prop = loc[prop]) == null ? void 0 : _loc$prop.line;
    	    if (line != null) {
    	      const count = line - this._buf.getCurrentLine();
    	      for (let i = 0; i < count; i++) {
    	        this._newline();
    	      }
    	    }
    	  }
    	  _getIndent() {
    	    return this._indentRepeat * this._indent;
    	  }
    	  printTerminatorless(node, parent, isLabel) {
    	    if (isLabel) {
    	      this._noLineTerminator = true;
    	      this.print(node, parent);
    	    } else {
    	      const terminatorState = {
    	        printed: false
    	      };
    	      this._parenPushNewlineState = terminatorState;
    	      this.print(node, parent);
    	      if (terminatorState.printed) {
    	        this.dedent();
    	        this.newline();
    	        this.tokenChar(41);
    	      }
    	    }
    	  }
    	  print(node, parent, noLineTerminatorAfter, trailingCommentsLineOffset, forceParens) {
    	    var _node$extra;
    	    if (!node) return;
    	    this._endsWithInnerRaw = false;
    	    const nodeType = node.type;
    	    const format = this.format;
    	    const oldConcise = format.concise;
    	    if (node._compact) {
    	      format.concise = true;
    	    }
    	    const printMethod = this[nodeType];
    	    if (printMethod === undefined) {
    	      throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node.constructor.name)}`);
    	    }
    	    this._printStack.push(node);
    	    const oldInAux = this._insideAux;
    	    this._insideAux = node.loc == undefined;
    	    this._maybeAddAuxComment(this._insideAux && !oldInAux);
    	    const shouldPrintParens = forceParens || format.retainFunctionParens && nodeType === "FunctionExpression" && ((_node$extra = node.extra) == null ? void 0 : _node$extra.parenthesized) || needsParens(node, parent, this._printStack);
    	    if (shouldPrintParens) {
    	      this.tokenChar(40);
    	      this._endsWithInnerRaw = false;
    	    }
    	    this._lastCommentLine = 0;
    	    this._printLeadingComments(node, parent);
    	    const loc = nodeType === "Program" || nodeType === "File" ? null : node.loc;
    	    this.exactSource(loc, printMethod.bind(this, node, parent));
    	    if (shouldPrintParens) {
    	      this._printTrailingComments(node, parent);
    	      this.tokenChar(41);
    	      this._noLineTerminator = noLineTerminatorAfter;
    	    } else if (noLineTerminatorAfter && !this._noLineTerminator) {
    	      this._noLineTerminator = true;
    	      this._printTrailingComments(node, parent);
    	    } else {
    	      this._printTrailingComments(node, parent, trailingCommentsLineOffset);
    	    }
    	    this._printStack.pop();
    	    format.concise = oldConcise;
    	    this._insideAux = oldInAux;
    	    this._endsWithInnerRaw = false;
    	  }
    	  _maybeAddAuxComment(enteredPositionlessNode) {
    	    if (enteredPositionlessNode) this._printAuxBeforeComment();
    	    if (!this._insideAux) this._printAuxAfterComment();
    	  }
    	  _printAuxBeforeComment() {
    	    if (this._printAuxAfterOnNextUserNode) return;
    	    this._printAuxAfterOnNextUserNode = true;
    	    const comment = this.format.auxiliaryCommentBefore;
    	    if (comment) {
    	      this._printComment({
    	        type: "CommentBlock",
    	        value: comment
    	      }, 0);
    	    }
    	  }
    	  _printAuxAfterComment() {
    	    if (!this._printAuxAfterOnNextUserNode) return;
    	    this._printAuxAfterOnNextUserNode = false;
    	    const comment = this.format.auxiliaryCommentAfter;
    	    if (comment) {
    	      this._printComment({
    	        type: "CommentBlock",
    	        value: comment
    	      }, 0);
    	    }
    	  }
    	  getPossibleRaw(node) {
    	    const extra = node.extra;
    	    if ((extra == null ? void 0 : extra.raw) != null && extra.rawValue != null && node.value === extra.rawValue) {
    	      return extra.raw;
    	    }
    	  }
    	  printJoin(nodes, parent, opts = {}) {
    	    if (!(nodes != null && nodes.length)) return;
    	    let {
    	      indent
    	    } = opts;
    	    if (indent == null && this.format.retainLines) {
    	      var _nodes$0$loc;
    	      const startLine = (_nodes$0$loc = nodes[0].loc) == null ? void 0 : _nodes$0$loc.start.line;
    	      if (startLine != null && startLine !== this._buf.getCurrentLine()) {
    	        indent = true;
    	      }
    	    }
    	    if (indent) this.indent();
    	    const newlineOpts = {
    	      addNewlines: opts.addNewlines,
    	      nextNodeStartLine: 0
    	    };
    	    const separator = opts.separator ? opts.separator.bind(this) : null;
    	    const len = nodes.length;
    	    for (let i = 0; i < len; i++) {
    	      const node = nodes[i];
    	      if (!node) continue;
    	      if (opts.statement) this._printNewline(i === 0, newlineOpts);
    	      this.print(node, parent, undefined, opts.trailingCommentsLineOffset || 0);
    	      opts.iterator == null ? void 0 : opts.iterator(node, i);
    	      if (i < len - 1) separator == null ? void 0 : separator();
    	      if (opts.statement) {
    	        if (i + 1 === len) {
    	          this.newline(1);
    	        } else {
    	          var _nextNode$loc;
    	          const nextNode = nodes[i + 1];
    	          newlineOpts.nextNodeStartLine = ((_nextNode$loc = nextNode.loc) == null ? void 0 : _nextNode$loc.start.line) || 0;
    	          this._printNewline(true, newlineOpts);
    	        }
    	      }
    	    }
    	    if (indent) this.dedent();
    	  }
    	  printAndIndentOnComments(node, parent) {
    	    const indent = node.leadingComments && node.leadingComments.length > 0;
    	    if (indent) this.indent();
    	    this.print(node, parent);
    	    if (indent) this.dedent();
    	  }
    	  printBlock(parent) {
    	    const node = parent.body;
    	    if (node.type !== "EmptyStatement") {
    	      this.space();
    	    }
    	    this.print(node, parent);
    	  }
    	  _printTrailingComments(node, parent, lineOffset) {
    	    const {
    	      innerComments,
    	      trailingComments
    	    } = node;
    	    if (innerComments != null && innerComments.length) {
    	      this._printComments(2, innerComments, node, parent, lineOffset);
    	    }
    	    if (trailingComments != null && trailingComments.length) {
    	      this._printComments(2, trailingComments, node, parent, lineOffset);
    	    }
    	  }
    	  _printLeadingComments(node, parent) {
    	    const comments = node.leadingComments;
    	    if (!(comments != null && comments.length)) return;
    	    this._printComments(0, comments, node, parent);
    	  }
    	  _maybePrintInnerComments() {
    	    if (this._endsWithInnerRaw) this.printInnerComments();
    	    this._endsWithInnerRaw = true;
    	    this._indentInnerComments = true;
    	  }
    	  printInnerComments() {
    	    const node = this._printStack[this._printStack.length - 1];
    	    const comments = node.innerComments;
    	    if (!(comments != null && comments.length)) return;
    	    const hasSpace = this.endsWith(32);
    	    const indent = this._indentInnerComments;
    	    const printedCommentsCount = this._printedComments.size;
    	    if (indent) this.indent();
    	    this._printComments(1, comments, node);
    	    if (hasSpace && printedCommentsCount !== this._printedComments.size) {
    	      this.space();
    	    }
    	    if (indent) this.dedent();
    	  }
    	  noIndentInnerCommentsHere() {
    	    this._indentInnerComments = false;
    	  }
    	  printSequence(nodes, parent, opts = {}) {
    	    var _opts$indent;
    	    opts.statement = true;
    	    (_opts$indent = opts.indent) != null ? _opts$indent : opts.indent = false;
    	    this.printJoin(nodes, parent, opts);
    	  }
    	  printList(items, parent, opts = {}) {
    	    if (opts.separator == null) {
    	      opts.separator = commaSeparator;
    	    }
    	    this.printJoin(items, parent, opts);
    	  }
    	  _printNewline(newLine, opts) {
    	    const format = this.format;
    	    if (format.retainLines || format.compact) return;
    	    if (format.concise) {
    	      this.space();
    	      return;
    	    }
    	    if (!newLine) {
    	      return;
    	    }
    	    const startLine = opts.nextNodeStartLine;
    	    const lastCommentLine = this._lastCommentLine;
    	    if (startLine > 0 && lastCommentLine > 0) {
    	      const offset = startLine - lastCommentLine;
    	      if (offset >= 0) {
    	        this.newline(offset || 1);
    	        return;
    	      }
    	    }
    	    if (this._buf.hasContent()) {
    	      this.newline(1);
    	    }
    	  }
    	  _shouldPrintComment(comment) {
    	    if (comment.ignore) return 0;
    	    if (this._printedComments.has(comment)) return 0;
    	    if (this._noLineTerminator && (HAS_NEWLINE.test(comment.value) || HAS_BlOCK_COMMENT_END.test(comment.value))) {
    	      return 2;
    	    }
    	    this._printedComments.add(comment);
    	    if (!this.format.shouldPrintComment(comment.value)) {
    	      return 0;
    	    }
    	    return 1;
    	  }
    	  _printComment(comment, skipNewLines) {
    	    const noLineTerminator = this._noLineTerminator;
    	    const isBlockComment = comment.type === "CommentBlock";
    	    const printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;
    	    if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) {
    	      this.newline(1);
    	    }
    	    const lastCharCode = this.getLastChar();
    	    if (lastCharCode !== 91 && lastCharCode !== 123) {
    	      this.space();
    	    }
    	    let val;
    	    if (isBlockComment) {
    	      val = `/*${comment.value}*/`;
    	      if (this.format.indent.adjustMultilineComment) {
    	        var _comment$loc;
    	        const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;
    	        if (offset) {
    	          const newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
    	          val = val.replace(newlineRegex, "\n");
    	        }
    	        let indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
    	        if (this._shouldIndent(47) || this.format.retainLines) {
    	          indentSize += this._getIndent();
    	        }
    	        val = val.replace(/\n(?!$)/g, `\n${" ".repeat(indentSize)}`);
    	      }
    	    } else if (!noLineTerminator) {
    	      val = `//${comment.value}`;
    	    } else {
    	      val = `/*${comment.value}*/`;
    	    }
    	    if (this.endsWith(47)) this._space();
    	    this.source("start", comment.loc);
    	    this._append(val, isBlockComment);
    	    if (!isBlockComment && !noLineTerminator) {
    	      this.newline(1, true);
    	    }
    	    if (printNewLines && skipNewLines !== 3) {
    	      this.newline(1);
    	    }
    	  }
    	  _printComments(type, comments, node, parent, lineOffset = 0) {
    	    const nodeLoc = node.loc;
    	    const len = comments.length;
    	    let hasLoc = !!nodeLoc;
    	    const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;
    	    const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;
    	    let lastLine = 0;
    	    let leadingCommentNewline = 0;
    	    const maybeNewline = this._noLineTerminator ? function () {} : this.newline.bind(this);
    	    for (let i = 0; i < len; i++) {
    	      const comment = comments[i];
    	      const shouldPrint = this._shouldPrintComment(comment);
    	      if (shouldPrint === 2) {
    	        hasLoc = false;
    	        break;
    	      }
    	      if (hasLoc && comment.loc && shouldPrint === 1) {
    	        const commentStartLine = comment.loc.start.line;
    	        const commentEndLine = comment.loc.end.line;
    	        if (type === 0) {
    	          let offset = 0;
    	          if (i === 0) {
    	            if (this._buf.hasContent() && (comment.type === "CommentLine" || commentStartLine != commentEndLine)) {
    	              offset = leadingCommentNewline = 1;
    	            }
    	          } else {
    	            offset = commentStartLine - lastLine;
    	          }
    	          lastLine = commentEndLine;
    	          maybeNewline(offset);
    	          this._printComment(comment, 1);
    	          if (i + 1 === len) {
    	            maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline));
    	            lastLine = nodeStartLine;
    	          }
    	        } else if (type === 1) {
    	          const offset = commentStartLine - (i === 0 ? nodeStartLine : lastLine);
    	          lastLine = commentEndLine;
    	          maybeNewline(offset);
    	          this._printComment(comment, 1);
    	          if (i + 1 === len) {
    	            maybeNewline(Math.min(1, nodeEndLine - lastLine));
    	            lastLine = nodeEndLine;
    	          }
    	        } else {
    	          const offset = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);
    	          lastLine = commentEndLine;
    	          maybeNewline(offset);
    	          this._printComment(comment, 1);
    	        }
    	      } else {
    	        hasLoc = false;
    	        if (shouldPrint !== 1) {
    	          continue;
    	        }
    	        if (len === 1) {
    	          const singleLine = comment.loc ? comment.loc.start.line === comment.loc.end.line : !HAS_NEWLINE.test(comment.value);
    	          const shouldSkipNewline = singleLine && !isStatement(node) && !isClassBody(parent) && !isTSInterfaceBody(parent) && !isTSEnumDeclaration(parent);
    	          if (type === 0) {
    	            this._printComment(comment, shouldSkipNewline && node.type !== "ObjectExpression" || singleLine && isFunction(parent, {
    	              body: node
    	            }) ? 1 : 0);
    	          } else if (shouldSkipNewline && type === 2) {
    	            this._printComment(comment, 1);
    	          } else {
    	            this._printComment(comment, 0);
    	          }
    	        } else if (type === 1 && !(node.type === "ObjectExpression" && node.properties.length > 1) && node.type !== "ClassBody" && node.type !== "TSInterfaceBody") {
    	          this._printComment(comment, i === 0 ? 2 : i === len - 1 ? 3 : 0);
    	        } else {
    	          this._printComment(comment, 0);
    	        }
    	      }
    	    }
    	    if (type === 2 && hasLoc && lastLine) {
    	      this._lastCommentLine = lastLine;
    	    }
    	  }
    	}
    	Object.assign(Printer.prototype, generatorFunctions);
    	{
    	  Printer.prototype.Noop = function Noop() {};
    	}
    	var _default = Printer;
    	printer.default = _default;
    	function commaSeparator() {
    	  this.tokenChar(44);
    	  this.space();
    	}

    	
    	return printer;
    }

    var hasRequiredLib;

    function requireLib () {
    	if (hasRequiredLib) return lib;
    	hasRequiredLib = 1;

    	Object.defineProperty(lib, "__esModule", {
    	  value: true
    	});
    	lib.CodeGenerator = void 0;
    	lib.default = generate;
    	var _sourceMap = requireSourceMap();
    	var _printer = requirePrinter();
    	class Generator extends _printer.default {
    	  constructor(ast, opts = {}, code) {
    	    const format = normalizeOptions(code, opts);
    	    const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
    	    super(format, map);
    	    this.ast = void 0;
    	    this.ast = ast;
    	  }
    	  generate() {
    	    return super.generate(this.ast);
    	  }
    	}
    	function normalizeOptions(code, opts) {
    	  var _opts$recordAndTupleS;
    	  const format = {
    	    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
    	    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
    	    shouldPrintComment: opts.shouldPrintComment,
    	    retainLines: opts.retainLines,
    	    retainFunctionParens: opts.retainFunctionParens,
    	    comments: opts.comments == null || opts.comments,
    	    compact: opts.compact,
    	    minified: opts.minified,
    	    concise: opts.concise,
    	    indent: {
    	      adjustMultilineComment: true,
    	      style: "  "
    	    },
    	    jsescOption: Object.assign({
    	      quotes: "double",
    	      wrap: true,
    	      minimal: false
    	    }, opts.jsescOption),
    	    recordAndTupleSyntaxType: (_opts$recordAndTupleS = opts.recordAndTupleSyntaxType) != null ? _opts$recordAndTupleS : "hash",
    	    topicToken: opts.topicToken,
    	    importAttributesKeyword: opts.importAttributesKeyword
    	  };
    	  {
    	    format.decoratorsBeforeExport = opts.decoratorsBeforeExport;
    	    format.jsescOption.json = opts.jsonCompatibleStrings;
    	  }
    	  if (format.minified) {
    	    format.compact = true;
    	    format.shouldPrintComment = format.shouldPrintComment || (() => format.comments);
    	  } else {
    	    format.shouldPrintComment = format.shouldPrintComment || (value => format.comments || value.includes("@license") || value.includes("@preserve"));
    	  }
    	  if (format.compact === "auto") {
    	    format.compact = typeof code === "string" && code.length > 500000;
    	    if (format.compact) {
    	      console.error("[BABEL] Note: The code generator has deoptimised the styling of " + `${opts.filename} as it exceeds the max of ${"500KB"}.`);
    	    }
    	  }
    	  if (format.compact) {
    	    format.indent.adjustMultilineComment = false;
    	  }
    	  const {
    	    auxiliaryCommentBefore,
    	    auxiliaryCommentAfter,
    	    shouldPrintComment
    	  } = format;
    	  if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {
    	    format.auxiliaryCommentBefore = undefined;
    	  }
    	  if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {
    	    format.auxiliaryCommentAfter = undefined;
    	  }
    	  return format;
    	}
    	class CodeGenerator {
    	  constructor(ast, opts, code) {
    	    this._generator = void 0;
    	    this._generator = new Generator(ast, opts, code);
    	  }
    	  generate() {
    	    return this._generator.generate();
    	  }
    	}
    	lib.CodeGenerator = CodeGenerator;
    	function generate(ast, opts, code) {
    	  const gen = new Generator(ast, opts, code);
    	  return gen.generate();
    	}

    	
    	return lib;
    }

    var libExports = requireLib();
    var generate = /*@__PURE__*/getDefaultExportFromCjs(libExports);

    function isFunction(node) {
      return (
        libExports$2.isFunction(node) ||
        libExports$2.isArrowFunctionExpression(node) ||
        libExports$2.isObjectMethod(node) ||
        libExports$2.isClassMethod(node)
      );
    }

    function isObjectShorthand(parent) {
      if (!libExports$2.isObjectProperty(parent)) {
        return false;
      }

      if (parent.value && parent.value.left) {
        return (
          parent.value.type === "AssignmentPattern" &&
          parent.value.left.type === "Identifier"
        );
      }

      return (
        parent.value &&
        parent.key.start == parent.value.start &&
        parent.key.loc.identifierName === parent.value.loc.identifierName
      );
    }

    function getObjectExpressionValue(node) {
      const { value } = node;

      if (libExports$2.isIdentifier(value)) {
        return value.name;
      }

      if (libExports$2.isCallExpression(value) || libExports$2.isFunctionExpression(value)) {
        return "";
      }
      const code = generate(value).code;

      const shouldWrap = libExports$2.isObjectExpression(value);
      return shouldWrap ? `(${code})` : code;
    }

    function getCode(node) {
      return generate(node).code;
    }

    function getComments(ast) {
      if (!ast || !ast.comments) {
        return [];
      }
      return ast.comments.map(comment => ({
        name: comment.location,
        location: comment.loc,
      }));
    }

    function isComputedExpression(expression) {
      return /^\[/m.test(expression);
    }

    /**
     * Add the identifiers for a given object pattern.
     *
     * @param {Array.<Object>} identifiers
     *        the current list of identifiers where to push the new identifiers
     *        related to this path.
     * @param {Set<String>} identifiersKeys
     *        List of currently registered identifier location key.
     * @param {Object} pattern
     */
    function addPatternIdentifiers(identifiers, identifiersKeys, pattern) {
      let items;
      if (libExports$2.isObjectPattern(pattern)) {
        items = pattern.properties.map(({ value }) => value);
      }

      if (libExports$2.isArrayPattern(pattern)) {
        items = pattern.elements;
      }

      if (items) {
        addIdentifiers(identifiers, identifiersKeys, items);
      }
    }

    function addIdentifiers(identifiers, identifiersKeys, items) {
      for (const item of items) {
        if (libExports$2.isObjectPattern(item) || libExports$2.isArrayPattern(item)) {
          addPatternIdentifiers(identifiers, identifiersKeys, item);
        } else if (libExports$2.isIdentifier(item)) {
          if (!identifiersKeys.has(nodeLocationKey(item.loc))) {
            identifiers.push({
              name: item.name,
              expression: item.name,
              location: item.loc,
            });
          }
        }
      }
    }

    // Top Level checks the number of "body" nodes in the ancestor chain
    // if the node is top-level, then it shoul only have one body.
    function isTopLevel(ancestors) {
      return ancestors.filter(ancestor => ancestor.key == "body").length == 1;
    }

    function nodeLocationKey({ start, end }) {
      return `${start.line}:${start.column}:${end.line}:${end.column}`;
    }

    function getFunctionParameterNames(path) {
      if (path.node.params != null) {
        return path.node.params.map(param => {
          if (param.type !== "AssignmentPattern") {
            return param.name;
          }

          // Parameter with default value
          if (
            param.left.type === "Identifier" &&
            param.right.type === "Identifier"
          ) {
            return `${param.left.name} = ${param.right.name}`;
          } else if (
            param.left.type === "Identifier" &&
            param.right.type === "StringLiteral"
          ) {
            return `${param.left.name} = ${param.right.value}`;
          } else if (
            param.left.type === "Identifier" &&
            param.right.type === "ObjectExpression"
          ) {
            return `${param.left.name} = {}`;
          } else if (
            param.left.type === "Identifier" &&
            param.right.type === "ArrayExpression"
          ) {
            return `${param.left.name} = []`;
          } else if (
            param.left.type === "Identifier" &&
            param.right.type === "NullLiteral"
          ) {
            return `${param.left.name} = null`;
          }

          return null;
        });
      }
      return [];
    }

    // the function class is inferred from a call like
    // createClass or extend
    function fromCallExpression(callExpression) {
      const allowlist = ["extend", "createClass"];
      const { callee } = callExpression.node;
      if (!callee) {
        return null;
      }

      const name = libExports$2.isMemberExpression(callee)
        ? callee.property.name
        : callee.name;

      if (!allowlist.includes(name)) {
        return null;
      }

      const variable = callExpression.findParent(p =>
        libExports$2.isVariableDeclarator(p.node)
      );
      if (variable) {
        return variable.node.id.name;
      }

      const assignment = callExpression.findParent(p =>
        libExports$2.isAssignmentExpression(p.node)
      );

      if (!assignment) {
        return null;
      }

      const { left } = assignment.node;

      if (left.name) {
        return name;
      }

      if (libExports$2.isMemberExpression(left)) {
        return left.property.name;
      }

      return null;
    }

    // the function class is inferred from a prototype assignment
    // e.g. TodoClass.prototype.render = function() {}
    function fromPrototype(assignment) {
      const { left } = assignment.node;
      if (!left) {
        return null;
      }

      if (
        libExports$2.isMemberExpression(left) &&
        left.object &&
        libExports$2.isMemberExpression(left.object) &&
        left.object.property.identifier === "prototype"
      ) {
        return left.object.object.name;
      }

      return null;
    }

    // infer class finds an appropriate class for functions
    // that are defined inside of a class like thing.
    // e.g. `class Foo`, `TodoClass.prototype.foo`,
    //      `Todo = createClass({ foo: () => {}})`
    function inferClassName(path) {
      const classDeclaration = path.findParent(p => libExports$2.isClassDeclaration(p.node));
      if (classDeclaration) {
        return classDeclaration.node.id.name;
      }

      const callExpression = path.findParent(p => libExports$2.isCallExpression(p.node));
      if (callExpression) {
        return fromCallExpression(callExpression);
      }

      const assignment = path.findParent(p => libExports$2.isAssignmentExpression(p.node));
      if (assignment) {
        return fromPrototype(assignment);
      }

      return null;
    }

    // Perform ES6's anonymous function name inference for all
    // locations where static analysis is possible.
    // eslint-disable-next-line complexity
    function getFunctionName(node, parent) {
      if (libExports$2.isIdentifier(node.id)) {
        return node.id.name;
      }

      if (
        libExports$2.isObjectMethod(node, { computed: false }) ||
        libExports$2.isClassMethod(node, { computed: false }) ||
        libExports$2.isClassPrivateMethod(node)
      ) {
        const { key } = node;

        if (libExports$2.isIdentifier(key)) {
          return key.name;
        }
        if (libExports$2.isStringLiteral(key)) {
          return key.value;
        }
        if (libExports$2.isNumericLiteral(key)) {
          return `${key.value}`;
        }

        if (libExports$2.isPrivateName(key)) {
          return `#${key.id.name}`;
        }
      }

      if (
        libExports$2.isObjectProperty(parent, { computed: false, value: node }) ||
        // TODO: Babylon 6 doesn't support computed class props. It is included
        // here so that it is most flexible. Once Babylon 7 is used, this
        // can change to use computed: false like ObjectProperty.
        (libExports$2.isClassProperty(parent, { value: node }) && !parent.computed) ||
        (libExports$2.isClassPrivateProperty(parent, { value: node }) && !parent.computed)
      ) {
        const { key } = parent;

        if (libExports$2.isIdentifier(key)) {
          return key.name;
        }
        if (libExports$2.isStringLiteral(key)) {
          return key.value;
        }
        if (libExports$2.isNumericLiteral(key)) {
          return `${key.value}`;
        }

        if (libExports$2.isPrivateName(key)) {
          return `#${key.id.name}`;
        }
      }

      if (libExports$2.isAssignmentExpression(parent, { operator: "=", right: node })) {
        if (libExports$2.isIdentifier(parent.left)) {
          return parent.left.name;
        }

        // This case is not supported in standard ES6 name inference, but it
        // is included here since it is still a helpful case during debugging.
        if (libExports$2.isMemberExpression(parent.left, { computed: false })) {
          return parent.left.property.name;
        }
      }

      if (
        libExports$2.isAssignmentPattern(parent, { right: node }) &&
        libExports$2.isIdentifier(parent.left)
      ) {
        return parent.left.name;
      }

      if (
        libExports$2.isVariableDeclarator(parent, { init: node }) &&
        libExports$2.isIdentifier(parent.id)
      ) {
        return parent.id.name;
      }

      if (
        libExports$2.isExportDefaultDeclaration(parent, { declaration: node }) &&
        libExports$2.isFunctionDeclaration(node)
      ) {
        return "default";
      }

      return "anonymous";
    }

    function getFramework(symbols) {
      if (isReactComponent(symbols)) {
        return "React";
      }
      if (isAngularComponent(symbols)) {
        return "Angular";
      }
      if (isVueComponent(symbols)) {
        return "Vue";
      }

      return null;
    }

    function isReactComponent({ importsReact, classes, identifiers }) {
      return (
        importsReact ||
        extendsReactComponent(classes) ||
        isReact(identifiers) ||
        isRedux(identifiers)
      );
    }

    function extendsReactComponent(classes) {
      return classes.some(
        classObj =>
          libExports$2.isIdentifier(classObj.parent, { name: "Component" }) ||
          libExports$2.isIdentifier(classObj.parent, { name: "PureComponent" }) ||
          (libExports$2.isMemberExpression(classObj.parent, { computed: false }) &&
            libExports$2.isIdentifier(classObj.parent, { name: "Component" }))
      );
    }

    function isAngularComponent({ memberExpressions }) {
      return memberExpressions.some(
        item =>
          item.expression == "angular.controller" ||
          item.expression == "angular.module"
      );
    }

    function isVueComponent({ identifiers }) {
      return identifiers.some(identifier => identifier.name == "Vue");
    }

    /* This identifies the react lib file */
    function isReact(identifiers) {
      return identifiers.some(identifier => identifier.name == "isReactComponent");
    }

    /* This identifies the redux lib file */
    function isRedux(identifiers) {
      return identifiers.some(identifier => identifier.name == "Redux");
    }

    const symbolDeclarations = new Map();

    function extractFunctionSymbol(path, state, symbols) {
      const name = getFunctionName(path.node, path.parent);

      if (!state.fnCounts[name]) {
        state.fnCounts[name] = 0;
      }
      const index = state.fnCounts[name]++;
      symbols.functions.push({
        name,
        klass: inferClassName(path),
        location: path.node.loc,
        parameterNames: getFunctionParameterNames(path),
        identifier: path.node.id,
        // indicates the occurence of the function in a file
        // e.g { name: foo, ... index: 4 } is the 4th foo function
        // in the file
        index,
      });
    }

    function extractSymbol(path, symbols, state) {
      if (isFunction(path)) {
        extractFunctionSymbol(path, state, symbols);
      }

      if (libExports$2.isJSXElement(path)) {
        symbols.hasJsx = true;
      }

      if (libExports$2.isGenericTypeAnnotation(path)) {
        symbols.hasTypes = true;
      }

      if (libExports$2.isClassDeclaration(path)) {
        symbols.classes.push(getClassDeclarationSymbol(path.node));
      }

      if (!symbols.importsReact) {
        if (libExports$2.isImportDeclaration(path)) {
          symbols.importsReact = isReactImport(path.node);
        } else if (libExports$2.isCallExpression(path)) {
          symbols.importsReact = isReactRequire(path.node);
        }
      }

      if (libExports$2.isMemberExpression(path) || libExports$2.isOptionalMemberExpression(path)) {
        symbols.memberExpressions.push(getMemberExpressionSymbol(path));
      }

      if (
        (libExports$2.isStringLiteral(path) || libExports$2.isNumericLiteral(path)) &&
        libExports$2.isMemberExpression(path.parentPath)
      ) {
        // We only need literals that are part of computed memeber expressions
        const { start, end } = path.node.loc;
        symbols.literals.push({
          location: { start, end },
          get expression() {
            delete this.expression;
            this.expression = getSnippet(path.parentPath);
            return this.expression;
          },
        });
      }

      getIdentifierSymbols(symbols.identifiers, symbols.identifiersKeys, path);
    }

    function extractSymbols(sourceId) {
      const symbols = {
        functions: [],
        memberExpressions: [],
        comments: [],
        identifiers: [],
        // This holds a set of unique identifier location key (string)
        // It helps registering only the first identifier when there is duplicated ones for the same location.
        identifiersKeys: new Set(),
        classes: [],
        literals: [],
        hasJsx: false,
        hasTypes: false,
        framework: undefined,
        importsReact: false,
      };

      const state = {
        fnCounts: Object.create(null),
      };

      const ast = traverseAst(sourceId, {
        enter(node, ancestors) {
          try {
            const path = createSimplePath(ancestors);
            if (path) {
              extractSymbol(path, symbols, state);
            }
          } catch (e) {
            console.error(e);
          }
        },
      });

      // comments are extracted separately from the AST
      symbols.comments = getComments(ast);
      symbols.framework = getFramework(symbols);

      return symbols;
    }

    function extendSnippet(name, expression, path, prevPath) {
      const computed = path?.node.computed;
      const optional = path?.node.optional;
      const prevComputed = prevPath?.node.computed;
      const prevArray = libExports$2.isArrayExpression(prevPath);
      const array = libExports$2.isArrayExpression(path);
      const value = path?.node.property?.extra?.raw || "";

      if (expression === "") {
        if (computed) {
          return name === undefined ? `[${value}]` : `[${name}]`;
        }
        return name;
      }

      if (computed || array) {
        if (prevComputed || prevArray) {
          return `[${name}]${expression}`;
        }
        return `[${name === undefined ? value : name}].${expression}`;
      }

      if (prevComputed || prevArray) {
        return `${name}${expression}`;
      }

      if (isComputedExpression(expression) && name !== undefined) {
        return `${name}${expression}`;
      }

      if (optional) {
        return `${name}?.${expression}`;
      }

      return `${name}.${expression}`;
    }

    function getMemberSnippet(node, expression = "", optional = false) {
      if (libExports$2.isMemberExpression(node) || libExports$2.isOptionalMemberExpression(node)) {
        const name = libExports$2.isPrivateName(node.property)
          ? `#${node.property.id.name}`
          : node.property.name;
        const snippet = getMemberSnippet(
          node.object,
          extendSnippet(name, expression, { node }),
          node.optional
        );
        return snippet;
      }

      if (libExports$2.isCallExpression(node)) {
        return "";
      }

      if (libExports$2.isThisExpression(node)) {
        return `this.${expression}`;
      }

      if (libExports$2.isIdentifier(node)) {
        if (isComputedExpression(expression)) {
          return `${node.name}${expression}`;
        }
        if (optional) {
          return `${node.name}?.${expression}`;
        }
        return `${node.name}.${expression}`;
      }

      return expression;
    }

    function getObjectSnippet(path, prevPath, expression = "") {
      if (!path) {
        return expression;
      }

      const { name } = path.node.key;

      const extendedExpression = extendSnippet(name, expression, path, prevPath);

      const nextPrevPath = path;
      const nextPath = path.parentPath && path.parentPath.parentPath;

      return getSnippet(nextPath, nextPrevPath, extendedExpression);
    }

    function getArraySnippet(path, prevPath, expression) {
      if (!prevPath.parentPath) {
        throw new Error("Assertion failure - path should exist");
      }

      const index = `${prevPath.parentPath.containerIndex}`;
      const extendedExpression = extendSnippet(index, expression, path, prevPath);

      const nextPrevPath = path;
      const nextPath = path.parentPath && path.parentPath.parentPath;

      return getSnippet(nextPath, nextPrevPath, extendedExpression);
    }

    function getSnippet(path, prevPath, expression = "") {
      if (!path) {
        return expression;
      }

      if (libExports$2.isVariableDeclaration(path)) {
        const node = path.node.declarations[0];
        const { name } = node.id;
        return extendSnippet(name, expression, path, prevPath);
      }

      if (libExports$2.isVariableDeclarator(path)) {
        const node = path.node.id;
        if (libExports$2.isObjectPattern(node)) {
          return expression;
        }

        const prop = extendSnippet(node.name, expression, path, prevPath);
        return prop;
      }

      if (libExports$2.isAssignmentExpression(path)) {
        const node = path.node.left;
        const name = libExports$2.isMemberExpression(node)
          ? getMemberSnippet(node)
          : node.name;

        const prop = extendSnippet(name, expression, path, prevPath);
        return prop;
      }

      if (isFunction(path)) {
        return expression;
      }

      if (libExports$2.isIdentifier(path)) {
        return `${path.node.name}.${expression}`;
      }

      if (libExports$2.isObjectProperty(path)) {
        return getObjectSnippet(path, prevPath, expression);
      }

      if (libExports$2.isObjectExpression(path)) {
        const parentPath = prevPath?.parentPath;
        return getObjectSnippet(parentPath, prevPath, expression);
      }

      if (libExports$2.isMemberExpression(path) || libExports$2.isOptionalMemberExpression(path)) {
        return getMemberSnippet(path.node, expression);
      }

      if (libExports$2.isArrayExpression(path)) {
        if (!prevPath) {
          throw new Error("Assertion failure - path should exist");
        }

        return getArraySnippet(path, prevPath, expression);
      }

      return "";
    }

    function clearSymbols(sourceIds) {
      for (const sourceId of sourceIds) {
        symbolDeclarations.delete(sourceId);
      }
    }

    function getInternalSymbols(sourceId) {
      if (symbolDeclarations.has(sourceId)) {
        const symbols = symbolDeclarations.get(sourceId);
        if (symbols) {
          return symbols;
        }
      }

      const symbols = extractSymbols(sourceId);

      symbolDeclarations.set(sourceId, symbols);
      return symbols;
    }

    function getFunctionSymbols(sourceId, maxResults) {
      const symbols = getInternalSymbols(sourceId);
      if (!symbols) {
        return [];
      }
      let { functions } = symbols;
      // Avoid transferring more symbols than necessary
      if (maxResults && functions.length > maxResults) {
        functions = functions.slice(0, maxResults);
      }
      // The Outline & the Quick open panels do not need anonymous functions
      return functions.filter(fn => fn.name !== "anonymous");
    }

    function getClassSymbols(sourceId) {
      const symbols = getInternalSymbols(sourceId);
      if (!symbols) {
        return [];
      }

      return symbols.classes;
    }

    function containsPosition$1(a, b) {
      const bColumn = b.column || 0;
      const startsBefore =
        a.start.line < b.line ||
        (a.start.line === b.line && a.start.column <= bColumn);
      const endsAfter =
        a.end.line > b.line || (a.end.line === b.line && a.end.column >= bColumn);

      return startsBefore && endsAfter;
    }

    function getClosestFunctionName(location) {
      const symbols = getInternalSymbols(location.source.id);
      if (!symbols || !symbols.functions) {
        return "";
      }

      const closestFunction = symbols.functions.reduce((found, currNode) => {
        if (
          currNode.name === "anonymous" ||
          !containsPosition$1(currNode.location, {
            line: location.line,
            column: location.column || 0,
          })
        ) {
          return found;
        }

        if (!found) {
          return currNode;
        }

        if (found.location.start.line > currNode.location.start.line) {
          return found;
        }
        if (
          found.location.start.line === currNode.location.start.line &&
          found.location.start.column > currNode.location.start.column
        ) {
          return found;
        }

        return currNode;
      }, null);

      if (!closestFunction) {
        return "";
      }
      return closestFunction.name;
    }

    // This is only called from the main thread and we return a subset of attributes
    function getSymbols(sourceId) {
      const symbols = getInternalSymbols(sourceId);
      return {
        // This is used in the main thread by:
        // * The `getFunctionSymbols` function which is used by the Outline, QuickOpen panels.
        // * The `getClosestFunctionName` function used in the mapping of frame function names.
        // * The `findOutOfScopeLocations` function use to determine in scope lines.
        // functions: symbols.functions,

        // The three following attributes are only used by `findBestMatchExpression` within the worker thread
        // `memberExpressions`, `literals`
        // This one is also used within the worker for framework computation
        // `identifiers`
        //
        // These three memberExpressions, literals and identifiers attributes are arrays containing objects whose attributes are:
        // * name: string
        // * location: object {start: number, end: number}
        // * expression: string
        // * computed: boolean (only for memberExpressions)
        //
        // `findBestMatchExpression` uses `location`, `computed` and `expression` (not name).
        //    `expression` isn't used from the worker thread implementation of `findBestMatchExpression`.
        //    The main thread only uses `expression` and `location`.
        // framework computation uses only:
        // * `name` for identifiers
        // * `expression` for memberExpression

        // This is used within the worker for framework computation,
        // and in the `getClassSymbols` function
        // `classes`

        // The two following are only used by the main thread for computing CodeMirror "mode"
        hasJsx: symbols.hasJsx,
        hasTypes: symbols.hasTypes,

        // This is used in the main thread only to compute the source icon
        framework: symbols.framework,

        // This is only used by `findOutOfScopeLocations`:
        // `comments`
      };
    }

    function getMemberExpressionSymbol(path) {
      const { start, end } = path.node.property.loc;
      return {
        location: { start, end },
        get expression() {
          delete this.expression;
          this.expression = getSnippet(path);
          return this.expression;
        },
        computed: path.node.computed,
      };
    }

    function isReactImport(node) {
      return (
        node.source.value == "react" &&
        node.specifiers?.some(specifier => specifier.local?.name == "React")
      );
    }

    function isReactRequire(node) {
      const { callee } = node;
      const name = libExports$2.isMemberExpression(callee)
        ? callee.property.name
        : callee.loc.identifierName;
      return name == "require" && node.arguments.some(arg => arg.value == "react");
    }

    function getClassParentName(superClass) {
      return libExports$2.isMemberExpression(superClass)
        ? getCode(superClass)
        : superClass.name;
    }

    function getClassParentSymbol(superClass) {
      if (!superClass) {
        return null;
      }
      return {
        name: getClassParentName(superClass),
        location: superClass.loc,
      };
    }

    function getClassDeclarationSymbol(node) {
      const { loc, superClass } = node;
      return {
        name: node.id.name,
        parent: getClassParentSymbol(superClass),
        location: loc,
      };
    }

    /**
     * Get a list of identifiers that are part of the given path.
     *
     * @param {Array.<Object>} identifiers
     *        the current list of identifiers where to push the new identifiers
     *        related to this path.
     * @param {Set<String>} identifiersKeys
     *        List of currently registered identifier location key.
     * @param {Object} path
     */
    function getIdentifierSymbols(identifiers, identifiersKeys, path) {
      if (libExports$2.isStringLiteral(path) && libExports$2.isProperty(path.parentPath)) {
        if (!identifiersKeys.has(nodeLocationKey(path.node.loc))) {
          identifiers.push({
            name: path.node.value,
            get expression() {
              delete this.expression;
              this.expression = getObjectExpressionValue(path.parent);
              return this.expression;
            },
            location: path.node.loc,
          });
        }
        return;
      }

      if (libExports$2.isIdentifier(path) && !libExports$2.isGenericTypeAnnotation(path.parent)) {
        // We want to include function params, but exclude the function name
        if (libExports$2.isClassMethod(path.parent) && !path.inList) {
          return;
        }

        if (libExports$2.isProperty(path.parentPath) && !isObjectShorthand(path.parent)) {
          if (!identifiersKeys.has(nodeLocationKey(path.node.loc))) {
            identifiers.push({
              name: path.node.name,
              get expression() {
                delete this.expression;
                this.expression = getObjectExpressionValue(path.parent);
                return this.expression;
              },
              location: path.node.loc,
            });
          }
          return;
        }

        let { start, end } = path.node.loc;
        if (path.node.typeAnnotation) {
          const { column } = path.node.typeAnnotation.loc.start;
          end = { ...end, column };
        }

        if (!identifiersKeys.has(nodeLocationKey({ start, end }))) {
          identifiers.push({
            name: path.node.name,
            expression: path.node.name,
            location: { start, end },
          });
        }
      }

      if (libExports$2.isThisExpression(path.node)) {
        if (!identifiersKeys.has(nodeLocationKey(path.node.loc))) {
          identifiers.push({
            name: "this",
            location: path.node.loc,
            expression: "this",
          });
        }
      }

      if (libExports$2.isVariableDeclarator(path)) {
        const nodeId = path.node.id;

        addPatternIdentifiers(identifiers, identifiersKeys, nodeId);
      }
    }

    /**
     * "implicit"
     * Variables added automaticly like "this" and "arguments"
     *
     * "var"
     * Variables declared with "var" or non-block function declarations
     *
     * "let"
     * Variables declared with "let".
     *
     * "const"
     * Variables declared with "const", or added as const
     * bindings like inner function expressions and inner class names.
     *
     * "import"
     * Imported binding names exposed from other modules.
     *
     * "global"
     * Variables that reference undeclared global values.
     */

    // Location information about the expression immediartely surrounding a
    // given binding reference.

    function isGeneratedId(id) {
      return !/\/originalSource/.test(id);
    }

    function parseSourceScopes(sourceId) {
      const ast = getAst(sourceId);
      if (!ast || !Object.keys(ast).length) {
        return null;
      }

      return buildScopeList(ast, sourceId);
    }

    function buildScopeList(ast, sourceId) {
      const { global, lexical } = createGlobalScope(ast, sourceId);

      const state = {
        // The id for the source that scope list is generated for
        sourceId,

        // A map of any free variables(variables which are used within the current scope but not
        // declared within the scope). This changes when a new scope is created.
        freeVariables: new Map(),

        // A stack of all the free variables created across all the scopes that have
        // been created.
        freeVariableStack: [],

        inType: null,

        // The current scope, a new scope is potentially created on a visit to each node
        // depending in the criteria. Initially set to the lexical global scope which is the
        // child to the global scope.
        scope: lexical,

        // A stack of all the existing scopes, this is mainly used retrieve the parent scope
        // (which is the last scope push onto the stack) on exiting a visited node.
        scopeStack: [],

        declarationBindingIds: new Set(),
      };
      libExports$2.traverse(ast, scopeCollectionVisitor, state);

      for (const [key, freeVariables] of state.freeVariables) {
        let binding = global.bindings[key];
        if (!binding) {
          binding = {
            type: "global",
            refs: [],
          };
          global.bindings[key] = binding;
        }

        binding.refs = freeVariables.concat(binding.refs);
      }

      // TODO: This should probably check for ".mjs" extension on the
      // original file, and should also be skipped if the the generated
      // code is an ES6 module rather than a script.
      if (
        isGeneratedId(sourceId) ||
        (ast.program.sourceType === "script" && !looksLikeCommonJS(global))
      ) {
        stripModuleScope(global);
      }

      return toParsedScopes([global]) || [];
    }

    function toParsedScopes(children, sourceId) {
      if (!children || children.length === 0) {
        return undefined;
      }
      return children.map(scope => ({
        // Removing unneed information from TempScope such as parent reference.
        // We also need to convert BabelLocation to the Location type.
        start: scope.loc.start,
        end: scope.loc.end,
        type:
          scope.type === "module" || scope.type === "function-body"
            ? "block"
            : scope.type,
        scopeKind: "",
        displayName: scope.displayName,
        bindings: scope.bindings,
        children: toParsedScopes(scope.children),
      }));
    }

    /**
     * Create a new scope object and link the scope to it parent.
     *
     * @param {String} type - scope type
     * @param {String} displayName - The scope display name
     * @param {Object} parent - The parent object scope
     * @param {Object} loc - The start and end postions (line/columns) of the scope
     * @returns {Object} The newly created scope
     */
    function createTempScope(type, displayName, parent, loc) {
      const scope = {
        type,
        displayName,
        parent,

        // A list of all the child scopes
        children: [],
        loc,

        // All the bindings defined in this scope
        // bindings = [binding, ...]
        // binding = { type: "", refs: []}
        bindings: Object.create(null),
      };

      if (parent) {
        parent.children.push(scope);
      }
      return scope;
    }

    // Sets a new current scope and creates a new map to store the free variables
    // that may exist in this scope.
    function pushTempScope(state, type, displayName, loc) {
      const scope = createTempScope(type, displayName, state.scope, loc);

      state.scope = scope;

      state.freeVariableStack.push(state.freeVariables);
      state.freeVariables = new Map();
      return scope;
    }

    function isNode(node, type) {
      return node ? node.type === type : false;
    }

    // Walks up the scope tree to the top most variable scope
    function getVarScope(scope) {
      let s = scope;
      while (s.type !== "function" && s.type !== "module") {
        if (!s.parent) {
          return s;
        }
        s = s.parent;
      }
      return s;
    }

    function fromBabelLocation(location, sourceId) {
      return {
        sourceId,
        line: location.line,
        column: location.column,
      };
    }

    function parseDeclarator(
      declaratorId,
      targetScope,
      type,
      locationType,
      declaration,
      state
    ) {
      if (isNode(declaratorId, "Identifier")) {
        let existing = targetScope.bindings[declaratorId.name];
        if (!existing) {
          existing = {
            type,
            refs: [],
          };
          targetScope.bindings[declaratorId.name] = existing;
        }
        state.declarationBindingIds.add(declaratorId);
        existing.refs.push({
          type: locationType,
          start: fromBabelLocation(declaratorId.loc.start, state.sourceId),
          end: fromBabelLocation(declaratorId.loc.end, state.sourceId),
          declaration: {
            start: fromBabelLocation(declaration.loc.start, state.sourceId),
            end: fromBabelLocation(declaration.loc.end, state.sourceId),
          },
        });
      } else if (isNode(declaratorId, "ObjectPattern")) {
        declaratorId.properties.forEach(prop => {
          parseDeclarator(
            prop.value,
            targetScope,
            type,
            locationType,
            declaration,
            state
          );
        });
      } else if (isNode(declaratorId, "ArrayPattern")) {
        declaratorId.elements.forEach(item => {
          parseDeclarator(
            item,
            targetScope,
            type,
            locationType,
            declaration,
            state
          );
        });
      } else if (isNode(declaratorId, "AssignmentPattern")) {
        parseDeclarator(
          declaratorId.left,
          targetScope,
          type,
          locationType,
          declaration,
          state
        );
      } else if (isNode(declaratorId, "RestElement")) {
        parseDeclarator(
          declaratorId.argument,
          targetScope,
          type,
          locationType,
          declaration,
          state
        );
      } else if (libExports$2.isTSParameterProperty(declaratorId)) {
        parseDeclarator(
          declaratorId.parameter,
          targetScope,
          type,
          locationType,
          declaration,
          state
        );
      }
    }

    function isLetOrConst(node) {
      return node.kind === "let" || node.kind === "const";
    }

    function hasLexicalDeclaration(node, parent) {
      const nodes = [];
      if (libExports$2.isSwitchStatement(node)) {
        for (const caseNode of node.cases) {
          nodes.push(...caseNode.consequent);
        }
      } else {
        nodes.push(...node.body);
      }

      const isFunctionBody = libExports$2.isFunction(parent, { body: node });

      return nodes.some(
        child =>
          isLexicalVariable(child) ||
          libExports$2.isClassDeclaration(child) ||
          (!isFunctionBody && libExports$2.isFunctionDeclaration(child))
      );
    }
    function isLexicalVariable(node) {
      return isNode(node, "VariableDeclaration") && isLetOrConst(node);
    }

    // Creates the global scopes for this source, the overall global scope
    // and a lexical global scope.
    function createGlobalScope(ast, sourceId) {
      const global = createTempScope("object", "Global", null, {
        start: fromBabelLocation(ast.loc.start, sourceId),
        end: fromBabelLocation(ast.loc.end, sourceId),
      });

      const lexical = createTempScope("block", "Lexical Global", global, {
        start: fromBabelLocation(ast.loc.start, sourceId),
        end: fromBabelLocation(ast.loc.end, sourceId),
      });

      return { global, lexical };
    }

    const scopeCollectionVisitor = {
      // eslint-disable-next-line complexity
      enter(node, ancestors, state) {
        state.scopeStack.push(state.scope);

        const parentNode =
          ancestors.length === 0 ? null : ancestors[ancestors.length - 1].node;

        if (state.inType) {
          return;
        }

        if (libExports$2.isProgram(node)) {
          const scope = pushTempScope(state, "module", "Module", {
            start: fromBabelLocation(node.loc.start, state.sourceId),
            end: fromBabelLocation(node.loc.end, state.sourceId),
          });
          scope.bindings.this = {
            type: "implicit",
            refs: [],
          };
        } else if (libExports$2.isFunction(node)) {
          let { scope } = state;

          if (libExports$2.isFunctionExpression(node) && isNode(node.id, "Identifier")) {
            scope = pushTempScope(state, "block", "Function Expression", {
              start: fromBabelLocation(node.loc.start, state.sourceId),
              end: fromBabelLocation(node.loc.end, state.sourceId),
            });
            state.declarationBindingIds.add(node.id);
            scope.bindings[node.id.name] = {
              type: "const",
              refs: [
                {
                  type: "fn-expr",
                  start: fromBabelLocation(node.id.loc.start, state.sourceId),
                  end: fromBabelLocation(node.id.loc.end, state.sourceId),
                  declaration: {
                    start: fromBabelLocation(node.loc.start, state.sourceId),
                    end: fromBabelLocation(node.loc.end, state.sourceId),
                  },
                },
              ],
            };
          }

          if (libExports$2.isFunctionDeclaration(node) && isNode(node.id, "Identifier")) {
            // This ignores Annex B function declaration hoisting, which
            // is probably a fine assumption.
            state.declarationBindingIds.add(node.id);
            const refs = [
              {
                type: "fn-decl",
                start: fromBabelLocation(node.id.loc.start, state.sourceId),
                end: fromBabelLocation(node.id.loc.end, state.sourceId),
                declaration: {
                  start: fromBabelLocation(node.loc.start, state.sourceId),
                  end: fromBabelLocation(node.loc.end, state.sourceId),
                },
              },
            ];

            if (scope.type === "block") {
              scope.bindings[node.id.name] = {
                type: "let",
                refs,
              };
            } else {
              // Add the binding to the ancestor scope
              getVarScope(scope).bindings[node.id.name] = {
                type: "var",
                refs,
              };
            }
          }

          scope = pushTempScope(
            state,
            "function",
            getFunctionName(node, parentNode),
            {
              // Being at the start of a function doesn't count as
              // being inside of it.
              start: fromBabelLocation(
                node.params[0] ? node.params[0].loc.start : node.loc.start,
                state.sourceId
              ),
              end: fromBabelLocation(node.loc.end, state.sourceId),
            }
          );

          node.params.forEach(param =>
            parseDeclarator(param, scope, "var", "fn-param", node, state)
          );

          if (!libExports$2.isArrowFunctionExpression(node)) {
            scope.bindings.this = {
              type: "implicit",
              refs: [],
            };
            scope.bindings.arguments = {
              type: "implicit",
              refs: [],
            };
          }

          if (
            libExports$2.isBlockStatement(node.body) &&
            hasLexicalDeclaration(node.body, node)
          ) {
            scope = pushTempScope(state, "function-body", "Function Body", {
              start: fromBabelLocation(node.body.loc.start, state.sourceId),
              end: fromBabelLocation(node.body.loc.end, state.sourceId),
            });
          }
        } else if (libExports$2.isClass(node)) {
          if (libExports$2.isIdentifier(node.id)) {
            // For decorated classes, the AST considers the first the decorator
            // to be the start of the class. For the purposes of mapping class
            // declarations however, we really want to look for the "class Foo"
            // piece. To achieve that, we estimate the location of the declaration
            // instead.
            let declStart = node.loc.start;
            if (node.decorators && node.decorators.length) {
              // Estimate the location of the "class" keyword since it
              // is unlikely to be a different line than the class name.
              declStart = {
                line: node.id.loc.start.line,
                column: node.id.loc.start.column - "class ".length,
              };
            }

            const declaration = {
              start: fromBabelLocation(declStart, state.sourceId),
              end: fromBabelLocation(node.loc.end, state.sourceId),
            };

            if (libExports$2.isClassDeclaration(node)) {
              state.declarationBindingIds.add(node.id);
              state.scope.bindings[node.id.name] = {
                type: "let",
                refs: [
                  {
                    type: "class-decl",
                    start: fromBabelLocation(node.id.loc.start, state.sourceId),
                    end: fromBabelLocation(node.id.loc.end, state.sourceId),
                    declaration,
                  },
                ],
              };
            }

            const scope = pushTempScope(state, "block", "Class", {
              start: fromBabelLocation(node.loc.start, state.sourceId),
              end: fromBabelLocation(node.loc.end, state.sourceId),
            });

            state.declarationBindingIds.add(node.id);
            scope.bindings[node.id.name] = {
              type: "const",
              refs: [
                {
                  type: "class-inner",
                  start: fromBabelLocation(node.id.loc.start, state.sourceId),
                  end: fromBabelLocation(node.id.loc.end, state.sourceId),
                  declaration,
                },
              ],
            };
          }
        } else if (libExports$2.isForXStatement(node) || libExports$2.isForStatement(node)) {
          const init = node.init || node.left;
          if (isNode(init, "VariableDeclaration") && isLetOrConst(init)) {
            // Debugger will create new lexical environment for the for.
            pushTempScope(state, "block", "For", {
              // Being at the start of a for loop doesn't count as
              // being inside it.
              start: fromBabelLocation(init.loc.start, state.sourceId),
              end: fromBabelLocation(node.loc.end, state.sourceId),
            });
          }
        } else if (libExports$2.isCatchClause(node)) {
          const scope = pushTempScope(state, "block", "Catch", {
            start: fromBabelLocation(node.loc.start, state.sourceId),
            end: fromBabelLocation(node.loc.end, state.sourceId),
          });
          parseDeclarator(node.param, scope, "var", "catch", node, state);
        } else if (
          libExports$2.isBlockStatement(node) &&
          // Function body's are handled in the function logic above.
          !libExports$2.isFunction(parentNode) &&
          hasLexicalDeclaration(node, parentNode)
        ) {
          // Debugger will create new lexical environment for the block.
          pushTempScope(state, "block", "Block", {
            start: fromBabelLocation(node.loc.start, state.sourceId),
            end: fromBabelLocation(node.loc.end, state.sourceId),
          });
        } else if (
          libExports$2.isVariableDeclaration(node) &&
          (node.kind === "var" ||
            // Lexical declarations in for statements are handled above.
            !libExports$2.isForStatement(parentNode, { init: node }) ||
            !libExports$2.isForXStatement(parentNode, { left: node }))
        ) {
          // Finds right lexical environment
          const hoistAt = !isLetOrConst(node)
            ? getVarScope(state.scope)
            : state.scope;
          node.declarations.forEach(declarator => {
            parseDeclarator(
              declarator.id,
              hoistAt,
              node.kind,
              node.kind,
              node,
              state
            );
          });
        } else if (
          libExports$2.isImportDeclaration(node) &&
          (!node.importKind || node.importKind === "value")
        ) {
          node.specifiers.forEach(spec => {
            if (spec.importKind && spec.importKind !== "value") {
              return;
            }

            if (libExports$2.isImportNamespaceSpecifier(spec)) {
              state.declarationBindingIds.add(spec.local);

              state.scope.bindings[spec.local.name] = {
                // Imported namespaces aren't live import bindings, they are
                // just normal const bindings.
                type: "const",
                refs: [
                  {
                    type: "import-ns-decl",
                    start: fromBabelLocation(spec.local.loc.start, state.sourceId),
                    end: fromBabelLocation(spec.local.loc.end, state.sourceId),
                    declaration: {
                      start: fromBabelLocation(node.loc.start, state.sourceId),
                      end: fromBabelLocation(node.loc.end, state.sourceId),
                    },
                  },
                ],
              };
            } else {
              state.declarationBindingIds.add(spec.local);

              state.scope.bindings[spec.local.name] = {
                type: "import",
                refs: [
                  {
                    type: "import-decl",
                    start: fromBabelLocation(spec.local.loc.start, state.sourceId),
                    end: fromBabelLocation(spec.local.loc.end, state.sourceId),
                    importName: libExports$2.isImportDefaultSpecifier(spec)
                      ? "default"
                      : spec.imported.name,
                    declaration: {
                      start: fromBabelLocation(node.loc.start, state.sourceId),
                      end: fromBabelLocation(node.loc.end, state.sourceId),
                    },
                  },
                ],
              };
            }
          });
        } else if (libExports$2.isTSEnumDeclaration(node)) {
          state.declarationBindingIds.add(node.id);
          state.scope.bindings[node.id.name] = {
            type: "const",
            refs: [
              {
                type: "ts-enum-decl",
                start: fromBabelLocation(node.id.loc.start, state.sourceId),
                end: fromBabelLocation(node.id.loc.end, state.sourceId),
                declaration: {
                  start: fromBabelLocation(node.loc.start, state.sourceId),
                  end: fromBabelLocation(node.loc.end, state.sourceId),
                },
              },
            ],
          };
        } else if (libExports$2.isTSModuleDeclaration(node)) {
          state.declarationBindingIds.add(node.id);
          state.scope.bindings[node.id.name] = {
            type: "const",
            refs: [
              {
                type: "ts-namespace-decl",
                start: fromBabelLocation(node.id.loc.start, state.sourceId),
                end: fromBabelLocation(node.id.loc.end, state.sourceId),
                declaration: {
                  start: fromBabelLocation(node.loc.start, state.sourceId),
                  end: fromBabelLocation(node.loc.end, state.sourceId),
                },
              },
            ],
          };
        } else if (libExports$2.isTSModuleBlock(node)) {
          pushTempScope(state, "block", "TypeScript Namespace", {
            start: fromBabelLocation(node.loc.start, state.sourceId),
            end: fromBabelLocation(node.loc.end, state.sourceId),
          });
        } else if (
          libExports$2.isIdentifier(node) &&
          libExports$2.isReferenced(node, parentNode) &&
          // Babel doesn't cover this in 'isReferenced' yet, but it should
          // eventually.
          !libExports$2.isTSEnumMember(parentNode, { id: node }) &&
          !libExports$2.isTSModuleDeclaration(parentNode, { id: node }) &&
          // isReferenced above fails to see `var { foo } = ...` as a non-reference
          // because the direct parent is not enough to know that the pattern is
          // used within a variable declaration.
          !state.declarationBindingIds.has(node)
        ) {
          let freeVariables = state.freeVariables.get(node.name);
          if (!freeVariables) {
            freeVariables = [];
            state.freeVariables.set(node.name, freeVariables);
          }

          freeVariables.push({
            type: "ref",
            start: fromBabelLocation(node.loc.start, state.sourceId),
            end: fromBabelLocation(node.loc.end, state.sourceId),
            meta: buildMetaBindings(state.sourceId, node, ancestors),
          });
        } else if (isOpeningJSXIdentifier(node, ancestors)) {
          let freeVariables = state.freeVariables.get(node.name);
          if (!freeVariables) {
            freeVariables = [];
            state.freeVariables.set(node.name, freeVariables);
          }

          freeVariables.push({
            type: "ref",
            start: fromBabelLocation(node.loc.start, state.sourceId),
            end: fromBabelLocation(node.loc.end, state.sourceId),
            meta: buildMetaBindings(state.sourceId, node, ancestors),
          });
        } else if (libExports$2.isThisExpression(node)) {
          let freeVariables = state.freeVariables.get("this");
          if (!freeVariables) {
            freeVariables = [];
            state.freeVariables.set("this", freeVariables);
          }

          freeVariables.push({
            type: "ref",
            start: fromBabelLocation(node.loc.start, state.sourceId),
            end: fromBabelLocation(node.loc.end, state.sourceId),
            meta: buildMetaBindings(state.sourceId, node, ancestors),
          });
        } else if (libExports$2.isClassProperty(parentNode, { value: node })) {
          const scope = pushTempScope(state, "function", "Class Field", {
            start: fromBabelLocation(node.loc.start, state.sourceId),
            end: fromBabelLocation(node.loc.end, state.sourceId),
          });
          scope.bindings.this = {
            type: "implicit",
            refs: [],
          };
          scope.bindings.arguments = {
            type: "implicit",
            refs: [],
          };
        } else if (
          libExports$2.isSwitchStatement(node) &&
          hasLexicalDeclaration(node, parentNode)
        ) {
          pushTempScope(state, "block", "Switch", {
            start: fromBabelLocation(node.loc.start, state.sourceId),
            end: fromBabelLocation(node.loc.end, state.sourceId),
          });
        }

        if (
          // In general Flow expressions are deleted, so they can't contain
          // runtime bindings, but typecasts are the one exception there.
          (libExports$2.isFlow(node) && !libExports$2.isTypeCastExpression(node)) ||
          // In general TS items are deleted, but TS has a few wrapper node
          // types that can contain general JS expressions.
          (node.type.startsWith("TS") &&
            !libExports$2.isTSTypeAssertion(node) &&
            !libExports$2.isTSAsExpression(node) &&
            !libExports$2.isTSNonNullExpression(node) &&
            !libExports$2.isTSModuleDeclaration(node) &&
            !libExports$2.isTSModuleBlock(node) &&
            !libExports$2.isTSParameterProperty(node) &&
            !libExports$2.isTSExportAssignment(node))
        ) {
          // Flag this node as a root "type" node. All items inside of this
          // will be skipped entirely.
          state.inType = node;
        }
      },
      exit(node, ancestors, state) {
        const currentScope = state.scope;
        const parentScope = state.scopeStack.pop();
        if (!parentScope) {
          throw new Error("Assertion failure - unsynchronized pop");
        }
        state.scope = parentScope;

        // It is possible, as in the case of function expressions, that a single
        // node has added multiple scopes, so we need to traverse upward here
        // rather than jumping stright to 'parentScope'.
        for (
          let scope = currentScope;
          scope && scope !== parentScope;
          scope = scope.parent
        ) {
          const { freeVariables } = state;
          state.freeVariables = state.freeVariableStack.pop();
          const parentFreeVariables = state.freeVariables;

          // Match up any free variables that match this scope's bindings and
          // merge then into the refs.
          for (const key of Object.keys(scope.bindings)) {
            const binding = scope.bindings[key];

            const freeVars = freeVariables.get(key);
            if (freeVars) {
              binding.refs.push(...freeVars);
              freeVariables.delete(key);
            }
          }

          // Move any undeclared references in this scope into the parent for
          // processing in higher scopes.
          for (const [key, value] of freeVariables) {
            let refs = parentFreeVariables.get(key);
            if (!refs) {
              refs = [];
              parentFreeVariables.set(key, refs);
            }

            refs.push(...value);
          }
        }

        if (state.inType === node) {
          state.inType = null;
        }
      },
    };

    function isOpeningJSXIdentifier(node, ancestors) {
      if (!libExports$2.isJSXIdentifier(node)) {
        return false;
      }

      for (let i = ancestors.length - 1; i >= 0; i--) {
        const { node: parent, key } = ancestors[i];

        if (libExports$2.isJSXOpeningElement(parent) && key === "name") {
          return true;
        } else if (!libExports$2.isJSXMemberExpression(parent) || key !== "object") {
          break;
        }
      }

      return false;
    }

    function buildMetaBindings(
      sourceId,
      node,
      ancestors,
      parentIndex = ancestors.length - 1
    ) {
      if (parentIndex <= 1) {
        return null;
      }
      const parent = ancestors[parentIndex].node;
      const grandparent = ancestors[parentIndex - 1].node;

      // Consider "0, foo" to be equivalent to "foo".
      if (
        libExports$2.isSequenceExpression(parent) &&
        parent.expressions.length === 2 &&
        libExports$2.isNumericLiteral(parent.expressions[0]) &&
        parent.expressions[1] === node
      ) {
        let { start, end } = parent.loc;

        if (libExports$2.isCallExpression(grandparent, { callee: parent })) {
          // Attempt to expand the range around parentheses, e.g.
          // (0, foo.bar)()
          start = grandparent.loc.start;
          end = Object.assign({}, end);
          end.column += 1;
        }

        return {
          type: "inherit",
          start: fromBabelLocation(start, sourceId),
          end: fromBabelLocation(end, sourceId),
          parent: buildMetaBindings(sourceId, parent, ancestors, parentIndex - 1),
        };
      }

      // Consider "Object(foo)", and "__webpack_require__.i(foo)" to be
      // equivalent to "foo" since they are essentially identity functions.
      if (
        libExports$2.isCallExpression(parent) &&
        (libExports$2.isIdentifier(parent.callee, { name: "Object" }) ||
          (libExports$2.isMemberExpression(parent.callee, { computed: false }) &&
            libExports$2.isIdentifier(parent.callee.object, { name: "__webpack_require__" }) &&
            libExports$2.isIdentifier(parent.callee.property, { name: "i" }))) &&
        parent.arguments.length === 1 &&
        parent.arguments[0] === node
      ) {
        return {
          type: "inherit",
          start: fromBabelLocation(parent.loc.start, sourceId),
          end: fromBabelLocation(parent.loc.end, sourceId),
          parent: buildMetaBindings(sourceId, parent, ancestors, parentIndex - 1),
        };
      }

      if (libExports$2.isMemberExpression(parent, { object: node })) {
        if (parent.computed) {
          if (libExports$2.isStringLiteral(parent.property)) {
            return {
              type: "member",
              start: fromBabelLocation(parent.loc.start, sourceId),
              end: fromBabelLocation(parent.loc.end, sourceId),
              property: parent.property.value,
              parent: buildMetaBindings(
                sourceId,
                parent,
                ancestors,
                parentIndex - 1
              ),
            };
          }
        } else {
          return {
            type: "member",
            start: fromBabelLocation(parent.loc.start, sourceId),
            end: fromBabelLocation(parent.loc.end, sourceId),
            property: parent.property.name,
            parent: buildMetaBindings(sourceId, parent, ancestors, parentIndex - 1),
          };
        }
      }
      if (
        libExports$2.isCallExpression(parent, { callee: node }) &&
        !parent.arguments.length
      ) {
        return {
          type: "call",
          start: fromBabelLocation(parent.loc.start, sourceId),
          end: fromBabelLocation(parent.loc.end, sourceId),
          parent: buildMetaBindings(sourceId, parent, ancestors, parentIndex - 1),
        };
      }

      return null;
    }

    function looksLikeCommonJS(rootScope) {
      const hasRefs = name =>
        rootScope.bindings[name] && !!rootScope.bindings[name].refs.length;

      return (
        hasRefs("__dirname") ||
        hasRefs("__filename") ||
        hasRefs("require") ||
        hasRefs("exports") ||
        hasRefs("module")
      );
    }

    function stripModuleScope(rootScope) {
      const rootLexicalScope = rootScope.children[0];
      const moduleScope = rootLexicalScope.children[0];
      if (moduleScope.type !== "module") {
        throw new Error("Assertion failure - should be module");
      }

      Object.keys(moduleScope.bindings).forEach(name => {
        const binding = moduleScope.bindings[name];
        if (binding.type === "let" || binding.type === "const") {
          rootLexicalScope.bindings[name] = binding;
        } else {
          rootScope.bindings[name] = binding;
        }
      });
      rootLexicalScope.children = moduleScope.children;
      rootLexicalScope.children.forEach(child => {
        child.parent = rootLexicalScope;
      });
    }

    const parsedScopesCache = new Map();

    function getScopes(location) {
      const sourceId = location.source.id;
      let parsedScopes = parsedScopesCache.get(sourceId);
      if (!parsedScopes) {
        parsedScopes = parseSourceScopes(sourceId);
        parsedScopesCache.set(sourceId, parsedScopes);
      }
      return parsedScopes ? findScopes(parsedScopes, location) : [];
    }

    function clearScopes(sourceIds) {
      for (const sourceId of sourceIds) {
        parsedScopesCache.delete(sourceId);
      }
    }

    /**
     * Searches all scopes and their bindings at the specific location.
     */
    function findScopes(scopes, location) {
      // Find inner most in the tree structure.
      let searchInScopes = scopes;
      const found = [];
      while (searchInScopes) {
        const foundOne = searchInScopes.some(s => {
          if (
            compareLocations(s.start, location) <= 0 &&
            compareLocations(location, s.end) < 0
          ) {
            // Found the next scope, trying to search recusevly in its children.
            found.unshift(s);
            searchInScopes = s.children;
            return true;
          }
          return false;
        });
        if (!foundOne) {
          break;
        }
      }
      return found.map(i => ({
        type: i.type,
        scopeKind: i.scopeKind,
        displayName: i.displayName,
        start: i.start,
        end: i.end,
        bindings: i.bindings,
      }));
    }

    function compareLocations(a, b) {
      // According to type of Location.column can be undefined, if will not be the
      // case here, ignoring flow error.
      return a.line == b.line ? a.column - b.column : a.line - b.line;
    }

    /* This Source Code Form is subject to the terms of the Mozilla Public
     * License, v. 2.0. If a copy of the MPL was not distributed with this
     * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

    function startsBefore(a, b) {
      let before = a.start.line < b.line;
      if (a.start.line === b.line) {
        before =
          a.start.column >= 0 && b.column >= 0 ? a.start.column <= b.column : true;
      }
      return before;
    }

    function endsAfter(a, b) {
      let after = a.end.line > b.line;
      if (a.end.line === b.line) {
        after =
          a.end.column >= 0 && b.column >= 0 ? a.end.column >= b.column : true;
      }
      return after;
    }

    function containsPosition(a, b) {
      return startsBefore(a, b) && endsAfter(a, b);
    }

    function containsLocation(a, b) {
      return containsPosition(a, b.start) && containsPosition(a, b.end);
    }

    function findSymbols(source) {
      const { functions, comments } = getInternalSymbols(source);
      return { functions, comments };
    }

    /**
     * Returns the location for a given function path. If the path represents a
     * function declaration, the location will begin after the function identifier
     * but before the function parameters.
     */

    function getLocation(func) {
      const location = { ...func.location };

      // if the function has an identifier, start the block after it so the
      // identifier is included in the "scope" of its parent
      const identifierEnd = func?.identifier?.loc?.end;
      if (identifierEnd) {
        location.start = identifierEnd;
      }

      return location;
    }

    /**
     * Find the nearest location containing the input position and
     * return inner locations under that nearest location
     *
     * @param {Array<Object>} locations Notice! The locations MUST be sorted by `sortByStart`
     *                  so that we can do linear time complexity operation.
     * @returns {Array<Object>}
     */
    function getInnerLocations(locations, position) {
      // First, let's find the nearest position-enclosing function location,
      // which is to find the last location enclosing the position.
      let parentIndex;
      for (let i = locations.length - 1; i >= 0; i--) {
        const loc = locations[i];
        if (containsPosition(loc, position)) {
          parentIndex = i;
          break;
        }
      }

      if (parentIndex == undefined) {
        return [];
      }
      const parentLoc = locations[parentIndex];

      // Then, from the nearest location, loop locations again and put locations into
      // the innerLocations array until we get to a location not enclosed by the nearest location.
      const innerLocations = [];
      for (let i = parentIndex + 1; i < locations.length; i++) {
        const loc = locations[i];
        if (!containsLocation(parentLoc, loc)) {
          break;
        }

        innerLocations.push(loc);
      }

      return innerLocations;
    }

    /**
     * Return an new locations array which excludes
     * items that are completely enclosed by another location in the input locations
     *
     * @param locations Notice! The locations MUST be sorted by `sortByStart`
     *                  so that we can do linear time complexity operation.
     */
    function removeOverlaps(locations) {
      if (!locations.length) {
        return [];
      }
      const firstParent = locations[0];
      return locations.reduce(deduplicateNode, [firstParent]);
    }

    function deduplicateNode(nodes, location) {
      const parent = nodes[nodes.length - 1];
      if (!containsLocation(parent, location)) {
        nodes.push(location);
      }
      return nodes;
    }

    /**
     * Sorts an array of locations by start position
     */
    function sortByStart(a, b) {
      if (a.start.line < b.start.line) {
        return -1;
      } else if (a.start.line === b.start.line) {
        return a.start.column - b.start.column;
      }

      return 1;
    }

    /**
     * Returns an array of locations that are considered out of scope for the given
     * location.
     */
    function findOutOfScopeLocations(location) {
      const { functions, comments } = findSymbols(location.source.id);
      const commentLocations = comments.map(c => c.location);
      const locations = functions
        .map(getLocation)
        .concat(commentLocations)
        .sort(sortByStart);

      const innerLocations = getInnerLocations(locations, location);
      const outerLocations = locations.filter(loc => {
        if (innerLocations.includes(loc)) {
          return false;
        }

        return !containsPosition(loc, location);
      });
      return removeOverlaps(outerLocations);
    }

    function findBestMatchExpression(sourceId, tokenPos) {
      const symbols = getInternalSymbols(sourceId);
      if (!symbols) {
        return null;
      }

      const { line, column } = tokenPos;
      const { memberExpressions, identifiers, literals } = symbols;

      function matchExpression(expression) {
        const { location } = expression;
        const { start, end } = location;
        return start.line == line && start.column <= column && end.column >= column;
      }
      function matchMemberExpression(expression) {
        // For member expressions we ignore "computed" member expressions `foo[bar]`,
        // to only match the one that looks like: `foo.bar`.
        return !expression.computed && matchExpression(expression);
      }
      // Avoid duplicating these arrays and be careful about performance as they can be large
      //
      // Process member expressions first as they can be including identifiers which
      // are subset of the member expression.
      // Ex: `foo.bar` is a member expression made of `foo` and `bar` identifiers.
      return (
        memberExpressions.find(matchMemberExpression) ||
        literals.find(matchExpression) ||
        identifiers.find(matchExpression)
      );
    }

    function hasSyntaxError(input) {
      try {
        parseScript(input);
        return false;
      } catch (e) {
        return `${e.name} : ${e.message}`;
      }
    }

    // NOTE: this will only work if we are replacing an original identifier
    function replaceNode(ancestors, node) {
      const ancestor = ancestors[ancestors.length - 1];

      if (typeof ancestor.index === "number") {
        ancestor.node[ancestor.key][ancestor.index] = node;
      } else {
        ancestor.node[ancestor.key] = node;
      }
    }

    function getFirstExpression(ast) {
      const statements = ast.program.body;
      if (!statements.length) {
        return null;
      }

      return statements[0].expression;
    }

    function locationKey(start) {
      return `${start.line}:${start.column}`;
    }

    function mapOriginalExpression(expression, ast, mappings) {
      const scopes = buildScopeList(ast, "");
      let shouldUpdate = false;

      const nodes = new Map();
      const replacements = new Map();

      // The ref-only global bindings are the ones that are accessed, but not
      // declared anywhere in the parsed code, meaning they are either global,
      // or declared somewhere in a scope outside the parsed code, so we
      // rewrite all of those specifically to avoid rewritting declarations that
      // shadow outer mappings.
      for (const name of Object.keys(scopes[0].bindings)) {
        const { refs } = scopes[0].bindings[name];
        const mapping = mappings[name];

        if (
          !refs.every(ref => ref.type === "ref") ||
          !mapping ||
          mapping === name
        ) {
          continue;
        }

        let node = nodes.get(name);
        if (!node) {
          node = getFirstExpression(parseScript(mapping));
          nodes.set(name, node);
        }

        for (const ref of refs) {
          let { line, column } = ref.start;

          // This shouldn't happen, just keeping Flow happy.
          if (typeof column !== "number") {
            column = 0;
          }

          replacements.set(locationKey({ line, column }), node);
        }
      }

      if (replacements.size === 0) {
        // Avoid the extra code generation work and also avoid potentially
        // reformatting the user's code unnecessarily.
        return expression;
      }

      libExports$2.traverse(ast, (node, ancestors) => {
        if (!libExports$2.isIdentifier(node) && !libExports$2.isThisExpression(node)) {
          return;
        }

        const ancestor = ancestors[ancestors.length - 1];
        // Shorthand properties can have a key and value with `node.loc.start` value
        // and we only want to replace the value.
        if (libExports$2.isObjectProperty(ancestor.node) && ancestor.key !== "value") {
          return;
        }

        const replacement = replacements.get(locationKey(node.loc.start));
        if (replacement) {
          replaceNode(ancestors, libExports$2.cloneNode(replacement));
          shouldUpdate = true;
        }
      });

      if (shouldUpdate) {
        return generate(ast).code;
      }

      return expression;
    }

    function getAssignmentTarget(node, bindings) {
      if (libExports$2.isObjectPattern(node)) {
        for (const property of node.properties) {
          if (libExports$2.isRestElement(property)) {
            property.argument = getAssignmentTarget(property.argument, bindings);
          } else {
            property.value = getAssignmentTarget(property.value, bindings);
          }
        }

        return node;
      }

      if (libExports$2.isArrayPattern(node)) {
        for (const [i, element] of node.elements.entries()) {
          node.elements[i] = getAssignmentTarget(element, bindings);
        }

        return node;
      }

      if (libExports$2.isAssignmentPattern(node)) {
        node.left = getAssignmentTarget(node.left, bindings);

        return node;
      }

      if (libExports$2.isRestElement(node)) {
        node.argument = getAssignmentTarget(node.argument, bindings);

        return node;
      }

      if (libExports$2.isIdentifier(node)) {
        return bindings.includes(node.name)
          ? node
          : libExports$2.memberExpression(libExports$2.identifier("self"), node);
      }

      return node;
    }

    // translates new bindings `var a = 3` into `self.a = 3`
    // and existing bindings `var a = 3` into `a = 3` for re-assignments
    function globalizeDeclaration(node, bindings) {
      return node.declarations.map(declaration =>
        libExports$2.expressionStatement(
          libExports$2.assignmentExpression(
            "=",
            getAssignmentTarget(declaration.id, bindings),
            declaration.init || libExports$2.unaryExpression("void", libExports$2.numericLiteral(0))
          )
        )
      );
    }

    // translates new bindings `a = 3` into `self.a = 3`
    // and keeps assignments the same for existing bindings.
    function globalizeAssignment(node, bindings) {
      return libExports$2.assignmentExpression(
        node.operator,
        getAssignmentTarget(node.left, bindings),
        node.right
      );
    }

    function mapExpressionBindings(expression, ast, bindings = []) {
      let isMapped = false;
      let shouldUpdate = true;

      libExports$2.traverse(ast, (node, ancestors) => {
        const parent = ancestors[ancestors.length - 1];

        if (libExports$2.isWithStatement(node)) {
          shouldUpdate = false;
          return;
        }

        if (!isTopLevel(ancestors)) {
          return;
        }

        if (libExports$2.isAssignmentExpression(node)) {
          if (libExports$2.isIdentifier(node.left) || libExports$2.isPattern(node.left)) {
            const newNode = globalizeAssignment(node, bindings);
            isMapped = true;
            replaceNode$1(ancestors, newNode);
            return;
          }

          return;
        }

        if (!libExports$2.isVariableDeclaration(node)) {
          return;
        }

        if (!libExports$2.isForStatement(parent.node)) {
          const newNodes = globalizeDeclaration(node, bindings);
          isMapped = true;
          replaceNode$1(ancestors, newNodes);
        }
      });

      if (!shouldUpdate || !isMapped) {
        return expression;
      }

      return generate(ast).code;
    }

    function hasTopLevelAwait(ast) {
      const hasAwait = hasNode(
        ast,
        (node, ancestors, b) => libExports$2.isAwaitExpression(node) && isTopLevel(ancestors)
      );

      return hasAwait;
    }

    // translates new bindings `var a = 3` into `a = 3`.
    function translateDeclarationIntoAssignment(node) {
      return node.declarations.reduce((acc, declaration) => {
        // Don't translate declaration without initial assignment (e.g. `var a;`)
        if (!declaration.init) {
          return acc;
        }
        acc.push(
          libExports$2.expressionStatement(
            libExports$2.assignmentExpression("=", declaration.id, declaration.init)
          )
        );
        return acc;
      }, []);
    }

    /**
     * Given an AST, modify it to return the last evaluated statement's expression value if possible.
     * This is to preserve existing console behavior of displaying the last executed expression value.
     */
    function addReturnNode(ast) {
      const statements = ast.program.body;
      const lastStatement = statements.pop();

      // if the last expression is an awaitExpression, strip the `await` part and directly
      // return the argument to avoid calling the argument's `then` function twice when the
      // mapped expression gets evaluated (See Bug 1771428)
      if (libExports$2.isAwaitExpression(lastStatement.expression)) {
        lastStatement.expression = lastStatement.expression.argument;
      }

      // NOTE: For more complicated cases such as an if/for statement, the last evaluated
      // expression value probably can not be displayed, unless doing hacky workarounds such
      // as returning the `eval` of the final statement (won't always work due to CSP issues?)
      // or SpiderMonkey support (See Bug 1839588) at which point this entire module can be removed.
      statements.push(
        libExports$2.isExpressionStatement(lastStatement)
          ? libExports$2.returnStatement(lastStatement.expression)
          : lastStatement
      );
      return statements;
    }

    function getDeclarations(node) {
      const { kind, declarations } = node;
      const declaratorNodes = declarations.reduce((acc, d) => {
        const declarators = getVariableDeclarators(d.id);
        return acc.concat(declarators);
      }, []);

      // We can't declare const variables outside of the async iife because we
      // wouldn't be able to re-assign them. As a workaround, we transform them
      // to `let` which should be good enough for those case.
      return libExports$2.variableDeclaration(
        kind === "const" ? "let" : kind,
        declaratorNodes
      );
    }

    function getVariableDeclarators(node) {
      if (libExports$2.isIdentifier(node)) {
        return libExports$2.variableDeclarator(libExports$2.identifier(node.name));
      }

      if (libExports$2.isObjectProperty(node)) {
        return getVariableDeclarators(node.value);
      }
      if (libExports$2.isRestElement(node)) {
        return getVariableDeclarators(node.argument);
      }

      if (libExports$2.isAssignmentPattern(node)) {
        return getVariableDeclarators(node.left);
      }

      if (libExports$2.isArrayPattern(node)) {
        return node.elements.reduce(
          (acc, element) => acc.concat(getVariableDeclarators(element)),
          []
        );
      }
      if (libExports$2.isObjectPattern(node)) {
        return node.properties.reduce(
          (acc, property) => acc.concat(getVariableDeclarators(property)),
          []
        );
      }
      return [];
    }

    /**
     * Given an AST and an array of variableDeclaration nodes, return a new AST with
     * all the declarations at the top of the AST.
     */
    function addTopDeclarationNodes(ast, declarationNodes) {
      const statements = [];
      declarationNodes.forEach(declarationNode => {
        statements.push(getDeclarations(declarationNode));
      });
      statements.push(ast);
      return libExports$2.program(statements);
    }

    /**
     * Given an AST, return an object of the following shape:
     *   - newAst: {AST} the AST where variable declarations were transformed into
     *             variable assignments
     *   - declarations: {Array<Node>} An array of all the declaration nodes needed
     *                   outside of the async iife.
     */
    function translateDeclarationsIntoAssignment(ast) {
      const declarations = [];
      libExports$2.traverse(ast, (node, ancestors) => {
        const parent = ancestors[ancestors.length - 1];

        if (
          libExports$2.isWithStatement(node) ||
          !isTopLevel(ancestors) ||
          libExports$2.isAssignmentExpression(node) ||
          !libExports$2.isVariableDeclaration(node) ||
          libExports$2.isForStatement(parent.node) ||
          libExports$2.isForXStatement(parent.node) ||
          !Array.isArray(node.declarations) ||
          node.declarations.length === 0
        ) {
          return;
        }

        const newNodes = translateDeclarationIntoAssignment(node);
        replaceNode$1(ancestors, newNodes);
        declarations.push(node);
      });

      return {
        newAst: ast,
        declarations,
      };
    }

    /**
     * Given an AST, wrap its body in an async iife, transform variable declarations
     * in assignments and move the variable declarations outside of the async iife.
     * Example: With the AST for the following expression: `let a = await 123`, the
     * function will return:
     * let a;
     * (async => {
     *   return a = await 123;
     * })();
     */
    function wrapExpressionFromAst(ast) {
      // Transform let and var declarations into assignments, and get back an array
      // of variable declarations.
      let { newAst, declarations } = translateDeclarationsIntoAssignment(ast);
      const body = addReturnNode(newAst);

      // Create the async iife.
      newAst = libExports$2.expressionStatement(
        libExports$2.callExpression(
          libExports$2.arrowFunctionExpression([], libExports$2.blockStatement(body), true),
          []
        )
      );

      // Now let's put all the variable declarations at the top of the async iife.
      newAst = addTopDeclarationNodes(newAst, declarations);

      return generate(newAst).code;
    }

    function mapTopLevelAwait(expression, ast) {
      if (!ast) {
        // If there's no ast this means the expression is malformed. And if the
        // expression contains the await keyword, we still want to wrap it in an
        // async iife in order to get a meaningful message (without this, the
        // engine will throw an Error stating that await keywords are only valid
        // in async functions and generators).
        if (expression.includes("await ")) {
          return `(async () => { ${expression} })();`;
        }

        return expression;
      }

      if (!hasTopLevelAwait(ast)) {
        return expression;
      }

      return wrapExpressionFromAst(ast);
    }

    function mapExpression(
      expression,
      mappings,
      bindings,
      shouldMapBindings = true,
      shouldMapAwait = true
    ) {
      const mapped = {
        await: false,
        bindings: false,
        originalExpression: false,
      };

      const ast = parseConsoleScript(expression);
      try {
        if (mappings && ast) {
          const beforeOriginalExpression = expression;
          expression = mapOriginalExpression(expression, ast, mappings);
          mapped.originalExpression = beforeOriginalExpression !== expression;
        }

        if (shouldMapBindings && ast) {
          const beforeBindings = expression;
          expression = mapExpressionBindings(expression, ast, bindings);
          mapped.bindings = beforeBindings !== expression;
        }

        if (shouldMapAwait) {
          const beforeAwait = expression;
          expression = mapTopLevelAwait(expression, ast);
          mapped.await = beforeAwait !== expression;
        }
      } catch (e) {
        console.warn(`Error when mapping ${expression} expression:`, e);
      }

      return {
        expression,
        mapped,
      };
    }

    var workerUtils = {exports: {}};

    var hasRequiredWorkerUtils;

    function requireWorkerUtils () {
    	if (hasRequiredWorkerUtils) return workerUtils.exports;
    	hasRequiredWorkerUtils = 1;
    	(function (module) {

    		class WorkerDispatcher {
    		  #msgId = 1;
    		  #worker = null;
    		  // Map of message ids -> promise resolution functions, for dispatching worker responses
    		  #pendingCalls = new Map();
    		  #url = "";

    		  constructor(url) {
    		    this.#url = url;
    		  }

    		  start() {
    		    // When running in debugger jest test, we don't have access to ChromeWorker
    		    if (typeof ChromeWorker == "function") {
    		      this.#worker = new ChromeWorker(this.#url);
    		    } else {
    		      this.#worker = new Worker(this.#url);
    		    }
    		    this.#worker.onerror = err => {
    		      console.error(`Error in worker ${this.#url}`, err.message);
    		    };
    		    this.#worker.addEventListener("message", this.#onMessage);
    		  }

    		  stop() {
    		    if (!this.#worker) {
    		      return;
    		    }

    		    this.#worker.removeEventListener("message", this.#onMessage);
    		    this.#worker.terminate();
    		    this.#worker = null;
    		    this.#pendingCalls.clear();
    		  }

    		  task(method, { queue = false } = {}) {
    		    const calls = [];
    		    const push = args => {
    		      return new Promise((resolve, reject) => {
    		        if (queue && calls.length === 0) {
    		          Promise.resolve().then(flush);
    		        }

    		        calls.push({ args, resolve, reject });

    		        if (!queue) {
    		          flush();
    		        }
    		      });
    		    };

    		    const flush = () => {
    		      const items = calls.slice();
    		      calls.length = 0;

    		      if (!this.#worker) {
    		        this.start();
    		      }

    		      const id = this.#msgId++;
    		      this.#worker.postMessage({
    		        id,
    		        method,
    		        calls: items.map(item => item.args),
    		      });

    		      this.#pendingCalls.set(id, items);
    		    };

    		    return (...args) => push(args);
    		  }

    		  invoke(method, ...args) {
    		    return this.task(method)(...args);
    		  }

    		  #onMessage = ({ data: result }) => {
    		    const items = this.#pendingCalls.get(result.id);
    		    this.#pendingCalls.delete(result.id);
    		    if (!items) {
    		      return;
    		    }

    		    if (!this.#worker) {
    		      return;
    		    }

    		    result.results.forEach((resultData, i) => {
    		      const { resolve, reject } = items[i];

    		      if (resultData.error) {
    		        const err = new Error(resultData.message);
    		        err.metadata = resultData.metadata;
    		        reject(err);
    		      } else {
    		        resolve(resultData.response);
    		      }
    		    });
    		  };
    		}

    		function workerHandler(publicInterface) {
    		  return function (msg) {
    		    const { id, method, calls } = msg.data;

    		    Promise.all(
    		      calls.map(args => {
    		        try {
    		          const response = publicInterface[method].apply(undefined, args);
    		          if (response instanceof Promise) {
    		            return response.then(
    		              val => ({ response: val }),
    		              err => asErrorMessage(err)
    		            );
    		          }
    		          return { response };
    		        } catch (error) {
    		          return asErrorMessage(error);
    		        }
    		      })
    		    ).then(results => {
    		      globalThis.postMessage({ id, results });
    		    });
    		  };
    		}

    		function asErrorMessage(error) {
    		  if (typeof error === "object" && error && "message" in error) {
    		    // Error can't be sent via postMessage, so be sure to convert to
    		    // string.
    		    return {
    		      error: true,
    		      message: error.message,
    		      metadata: error.metadata,
    		    };
    		  }

    		  return {
    		    error: true,
    		    message: error == null ? error : error.toString(),
    		    metadata: undefined,
    		  };
    		}

    		// Might be loaded within a worker thread where `module` isn't available.
    		{
    		  module.exports = {
    		    WorkerDispatcher,
    		    workerHandler,
    		  };
    		} 
    	} (workerUtils));
    	return workerUtils.exports;
    }

    var workerUtilsExports = requireWorkerUtils();

    function clearAllHelpersForSources(sourceIds) {
      clearASTs(sourceIds);
      clearScopes(sourceIds);
      clearSources(sourceIds);
      clearSymbols(sourceIds);
    }

    self.onmessage = workerUtilsExports.workerHandler({
      findOutOfScopeLocations,
      findBestMatchExpression,
      getSymbols,
      getFunctionSymbols,
      getClassSymbols,
      getClosestFunctionName,
      getScopes,
      clearSources: clearAllHelpersForSources,
      hasSyntaxError,
      mapExpression,
      setSource,
    });

}));
