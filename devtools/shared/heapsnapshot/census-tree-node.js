/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
"use strict";

// CensusTreeNode is an intermediate representation of a census report that
// exists between after a report is generated by taking a census and before the
// report is rendered in the DOM. It must be dead simple to render, with no
// further data processing or massaging needed before rendering DOM nodes. Our
// goal is to do the census report to CensusTreeNode transformation in the
// HeapAnalysesWorker, and ensure that the **only** work that the main thread
// has to do is strictly DOM rendering work.

const { Visitor, walk } = require("resource://gre/modules/devtools/shared/heapsnapshot/CensusUtils.js");

/**
 * Return true if the given object is a SavedFrame stack object, false otherwise.
 *
 * @param {any} obj
 * @returns {Boolean}
 */
function isSavedFrame(obj) {
  return Object.prototype.toString.call(obj) === "[object SavedFrame]";
}

/**
 * A FrameCache maps from SavedFrames to CensusTreeNodes. It is used when
 * aggregating multiple SavedFrame allocation stack keys into a tree of many
 * CensusTreeNodes. Each stack may share older frames, and we want to preserve
 * this sharing when converting to CensusTreeNode, so before creating a new
 * CensusTreeNode, we look for an existing one in one of our FrameCaches.
 */
function FrameCache() {}
FrameCache.prototype = null;

/**
 * The value of a single entry stored in a FrameCache. It is a pair of the
 * CensusTreeNode for this frame, and the subsequent FrameCache for this node's
 * children.
 *
 * @param {SavedFrame} frame
 *        The frame being cached.
 */
function FrameCacheValue(frame) {
  // The CensusTreeNode for this frame.
  this.node = new CensusTreeNode(frame);
  // The FrameCache for this frame's children.
  this.children = undefined;
}

FrameCacheValue.prototype = null;

/**
 * Create a unique string for the given SavedFrame (ignoring the frame's parent
 * chain) that can be used as a hash to key this frame within a FrameCache.
 *
 * @param {SavedFrame} frame
 *        The SavedFrame object we would like to lookup in or insert into a
 *        FrameCache.
 *
 * @returns {String}
 *          The unique string that can be used as a key in a FrameCache.
 */
FrameCache.hash = function (frame) {
  return `${frame.functionDisplayName},${frame.source},${frame.line},${frame.column},${frame.asyncCause}`;
};

/**
 * Associate `frame` with `value` in the given `cache`.
 *
 * @param {FrameCache} cache
 * @param {SavedFrame} frame
 * @param {FrameCacheValue} value
 */
FrameCache.insert = function (cache, frame, value) {
  cache[FrameCache.hash(frame)] = value;
};

/**
 * Lookup `frame` in `cache` and return its value if it exists.
 *
 * @param {FrameCache} cache
 * @param {SavedFrame} frame
 *
 * @returns {undefined|FrameCacheValue}
 */
FrameCache.lookup = function (cache, frame) {
  return cache[FrameCache.hash(frame)];
};

/**
 * Add `child` to `parent`'s set of children.
 *
 * @param {CensusTreeNode} parent
 * @param {CensusTreeNode} child
 */
function addChild(parent, child) {
  if (!parent.children) {
    parent.children = [];
  }
  parent.children.push(child);
}

/**
 * Get an array of each frame in the provided stack.
 *
 * @param {SavedFrame} stack
 * @returns {Array<SavedFrame>}
 */
function getArrayOfFrames(stack) {
  const frames = [];
  let frame = stack;
  while (frame) {
    frames.push(frame);
    frame = frame.parent;
  }
  frames.reverse();
  return frames;
}

/**
 * Given an `edge` to a sub-`report` whose structure is described by
 * `breakdown`, create a CensusTreeNode tree.
 *
 * @param {Object} breakdown
 *        The breakdown specifying the structure of the given report.
 *
 * @param {Object} report
 *        The census report.
 *
 * @param {null|String|SavedFrame} edge
 *        The edge leading to this report from the parent report.
 *
 * @param {FrameCache} frameCache
 *        The cache of CensusTreeNodes we have already made for the siblings of
 *        the node being created. The existing nodes are reused when possible.
 *
 * @param {Object} outParams
 *        The return values are attached to this object after this function
 *        returns. Because we create a CensusTreeNode for each frame in a
 *        SavedFrame stack edge, there may multiple nodes per sub-report.
 *
 *          - top: The deepest node in the CensusTreeNode subtree created.
 *
 *          - bottom: The shallowest node in the CensusTreeNode subtree created.
 *                    This is null if the shallowest node in the subtree was
 *                    found in the `frameCache` and reused.
 *
 *        Note that top and bottom are not necessarily different. In the case
 *        where there is a 1:1 correspondence between an edge in the report and
 *        a CensusTreeNode, top and bottom refer to the same node.
 */
function makeCensusTreeNodeSubTree(breakdown, report, edge, frameCache, outParams) {
  if (!isSavedFrame(edge)) {
    const node = new CensusTreeNode(edge);
    outParams.top = outParams.bottom = node;
    return;
  }

  // Loop through each frame in the stack and get or create a CensusTreeNode for
  // the frame.

  const frames = getArrayOfFrames(edge);
  let cache = frameCache;
  let prevNode;
  for (let i = 0, length = frames.length; i < length; i++) {
    const frame = frames[i];

    // Get or create the FrameCacheValue for this frame. If we already have a
    // FrameCacheValue (and hence a CensusTreeNode) for this frame, we don't
    // need to add the node to the previous node's children as we have already
    // done that. If we don't have a FrameCacheValue and CensusTreeNode for
    // this frame, then create one and make sure to hook it up as a child of
    // the previous node.
    let isNewNode = false;
    let val = FrameCache.lookup(cache, frame);
    if (!val) {
      isNewNode = true;
      val = new FrameCacheValue(frame);

      FrameCache.insert(cache, frame, val);
      if (prevNode) {
        addChild(prevNode, val.node);
      }
    }

    if (i === 0) {
      outParams.bottom = isNewNode ? val.node : null;
    }
    if (i === length - 1) {
      outParams.top = val.node;
    }

    prevNode = val.node;

    if (i !== length - 1 && !val.children) {
      // This is not the last frame and therefore this node will have
      // children, which we must cache.
      val.children = new FrameCache();
    }

    cache = val.children;
  }
}

/**
 * A Visitor that walks a census report and creates the corresponding
 * CensusTreeNode tree.
 */
function CensusTreeNodeVisitor() {
  // The root of the resulting CensusTreeNode tree.
  this._root = null;

  // The stack of CensusTreeNodes that we are in the process of building while
  // walking the census report.
  this._nodeStack = [];

  // To avoid unnecessary allocations, we reuse the same out parameter object
  // passed to `makeCensusTreeNodeSubTree` every time we call it.
  this._outParams = {
    top: null,
    bottom: null,
  };

  // The stack of `FrameCache`s that we use to aggregate many SavedFrame stacks
  // into a single CensusTreeNode tree.
  this._frameCacheStack = [new FrameCache()];
}

CensusTreeNodeVisitor.prototype = Object.create(Visitor);

/**
 * Create the CensusTreeNode subtree for this sub-report and link it to the
 * parent CensusTreeNode.
 *
 * @overrides Visitor.prototype.enter
 */
CensusTreeNodeVisitor.prototype.enter = function (breakdown, report, edge) {
  const cache = this._frameCacheStack[this._frameCacheStack.length - 1];
  makeCensusTreeNodeSubTree(breakdown, report, edge, cache, this._outParams);
  const { top, bottom } = this._outParams;

  if (!this._root) {
    this._root = bottom;
  } else {
    if (bottom) {
      addChild(this._nodeStack[this._nodeStack.length - 1], bottom);
    }
  }

  this._frameCacheStack.push(new FrameCache);
  this._nodeStack.push(top);
};

function values(cache) {
  return Object.keys(cache).map(k => cache[k]);
}

/**
 * We have finished adding children to the CensusTreeNode subtree for the
 * current sub-report. Make sure that the children are sorted for every node in
 * the subtree.
 *
 * @overrides Visitor.prototype.exit
 */
CensusTreeNodeVisitor.prototype.exit = function (breakdown, report, edge) {
  const top = this._nodeStack.pop();
  if (top.children) {
    top.children.sort(compareByBytes);
  }

  const cache = this._frameCacheStack.pop();
  const toSort = values(cache);
  while (toSort.length) {
    const { node, children } = toSort.pop();
    if (!node.children) {
      continue;
    }

    if (node !== top) {
      node.children.sort(compareByBytes);
    }

    if (!children) {
      continue;
    }

    const newlyNeedSorting = values(children);
    for (let i = 0, length = newlyNeedSorting.length; i < length; i++) {
      toSort.push(newlyNeedSorting[i]);
    }
  }
};

/**
 * @overrides Visitor.prototype.count
 */
CensusTreeNodeVisitor.prototype.count = function (breakdown, report, edge) {
  const node = this._nodeStack[this._nodeStack.length - 1];

  if (breakdown.count) {
    node.count = report.count;
  }

  if (breakdown.bytes) {
    node.bytes = report.bytes;
  }
};

/**
 * Get the root of the resulting CensusTreeNode tree.
 *
 * @returns {CensusTreeNode}
 */
CensusTreeNodeVisitor.prototype.root = function () {
  if (!this._root) {
    throw new Error("Attempt to get the root before walking the census report!");
  }

  if (this._nodeStack.length) {
    throw new Error("Attempt to get the root while walking the census report!");
  }

  return this._root;
};

/**
 * Create a single, uninitialized CensusTreeNode.
 *
 * @param {null|String|SavedFrame} name
 */
function CensusTreeNode (name) {
  this.name = name;
  this.bytes = undefined;
  this.count = undefined;
  this.children = undefined;
}

CensusTreeNode.prototype = null;

/**
 * Compare the given nodes by their `bytes` properties.
 *
 * @param {CensusTreeNode} node1
 * @param {CensusTreeNode} node2
 *
 * @returns {Number}
 *          A number suitable for using with Array.prototype.sort.
 */
function compareByBytes (node1, node2) {
  return (node2.bytes || 0) - (node1.bytes || 0);
}

/**
 * Takes a report from a census (`dbg.memory.takeCensus()`) and the breakdown
 * used to generate the census and returns a structure used to render
 * a tree to display the data.
 *
 * Returns a recursive "CensusTreeNode" object, looking like:
 *
 * CensusTreeNode = {
 *   // `children` if it exists, is sorted by `bytes`, if they are leaf nodes.
 *   children: ?[<CensusTreeNode...>],
 *   name: <?String>
 *   count: <?Number>
 *   bytes: <?Number>
 * }
 *
 * @param {Object} breakdown
 *        The breakdown used to generate the census report.
 *
 * @param {Object} report
 *        The census report generated with the specified breakdown.
 *
 * @returns {CensusTreeNode}
 */
exports.censusReportToCensusTreeNode = function (breakdown, report) {
  const visitor = new CensusTreeNodeVisitor();
  walk(breakdown, report, visitor);
  return visitor.root();
};
