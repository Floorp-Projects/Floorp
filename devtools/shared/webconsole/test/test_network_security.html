<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf8">
  <title>Test for the network actor (HPKP detection)</title>
  <script type="text/javascript" src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
  <script type="text/javascript" src="common.js"></script>
  <!-- Any copyright is dedicated to the Public Domain.
     - http://creativecommons.org/publicdomain/zero/1.0/ -->
</head>
<body>
<p>Test for the network actor (HPKP detection)</p>

<iframe src="https://example.com/chrome/devtools/shared/webconsole/test/network_requests_iframe.html"></iframe>

<script class="testbody" type="text/javascript">
Cu.import("resource://testing-common/BrowserTestUtils.jsm");
Cu.import("resource://gre/modules/Task.jsm");

SimpleTest.waitForExplicitFinish();

let gCurrentTestCase = -1;
const HPKP_PREF = "security.cert_pinning.process_headers_from_non_builtin_roots";

// Static pins tested by unit/test_security-info-static-hpkp.js.
const TEST_CASES = [
  {
    desc: "no HSTS or HPKP",
    url: "https://example.com",
    usesHSTS: false,
    usesPinning: false,
  },
  {
    desc: "HSTS from this response, no Public Key Pinning",
    url: "https://example.com/" +
         "browser/browser/base/content/test/general/browser_star_hsts.sjs",
    usesHSTS: true,
    usesPinning: false,
  },
  {
    desc: "stored HSTS from previous response, no Public Key Pinning",
    url: "https://example.com/",
    usesHSTS: true,
    usesPinning: false,
  },
  {
    desc: "no Public Key Pinning or HSTS",
    url: "https://include-subdomains.pinning-dynamic.example.com/",
    usesHSTS: false,
    usesPinning: false,
  },
  {
    desc: "dynamic Public Key Pinning with this request, no HSTS",
    url: "https://include-subdomains.pinning-dynamic.example.com/" +
         "browser/browser/base/content/test/general/pinning_headers.sjs",
    usesHSTS: false,
    usesPinning: true,
  },
  {
    desc: "dynamic Public Key Pinning with previous request, no HSTS",
    url: "https://include-subdomains.pinning-dynamic.example.com/",
    usesHSTS: false,
    usesPinning: true,
  }
];

const TEST_MODES = [ "public", "private" ];
let ALL_TESTS = [];

function startTest() {
  // Need to enable this pref or pinning headers are rejected due test
  // certificate.
  Services.prefs.setBoolPref(HPKP_PREF, true);
  SimpleTest.registerCleanupFunction(() => {
    Services.prefs.setBoolPref(HPKP_PREF, false);

    // Reset pinning state.
    let gSSService = Cc["@mozilla.org/ssservice;1"]
                       .getService(Ci.nsISiteSecurityService);

    let gIOService = Cc["@mozilla.org/network/io-service;1"]
                       .getService(Ci.nsIIOService);
    for (let {url} of TEST_CASES) {
      let uri = gIOService.newURI(url);
      gSSService.removeState(Ci.nsISiteSecurityService.HEADER_HSTS, uri, 0);
      gSSService.removeState(Ci.nsISiteSecurityService.HEADER_HSTS, uri,
                             Ci.nsISocketProvider.NO_PERMANENT_STORAGE,
                             { privateBrowsingId: 1 });
      gSSService.removeState(Ci.nsISiteSecurityService.HEADER_HPKP, uri, 0);
      gSSService.removeState(Ci.nsISiteSecurityService.HEADER_HPKP, uri,
                             Ci.nsISocketProvider.NO_PERMANENT_STORAGE,
                             { privateBrowsingId: 1 });
    }
  });

  info("Test detection of HTTP Strict Transport Security" +
       " and Public Key Pinning.");
  for (let mode of TEST_MODES) {
    for (let testCase of TEST_CASES) {
      let test = { mode };
      for (let attr in testCase) {
        test[attr] = testCase[attr];
      }
      ALL_TESTS.push(test);
    }
  }

  removeEventListener("load", startTest);
  attachConsoleToTab(["NetworkActivity"], onAttach);
}

function onAttach(state, response) {
  let callback = onNetworkEventUpdate.bind(null, state);
  state.dbgClient.addListener("networkEventUpdate", callback);

  runNextCase(state);
}

function runNextCase(state) {
  gCurrentTestCase++;
  if (gCurrentTestCase === ALL_TESTS.length) {
    info("Tests ran. Cleaning up.");
    closeDebugger(state, SimpleTest.finish);
    return;
  }

  let { desc, url, mode } = ALL_TESTS[gCurrentTestCase];
  info("Testing site with " + desc);

  if (mode == "private") {
    info("Cleaning up the previous window.");
    closeDebugger(state, runInPrivateWindow);
  } else {
    let iframe = document.querySelector("iframe").contentWindow;
    iframe.wrappedJSObject.makeXhrCallback("GET", url);
  }
}

function onNetworkEventUpdate(state, type, packet) {
  function onSecurityInfo(received) {
    let data = ALL_TESTS[gCurrentTestCase];
    is(received.securityInfo.hsts, data.usesHSTS,
      "Strict Transport Security detected correctly.");
    is(received.securityInfo.hpkp, data.usesPinning,
      "Public Key Pinning detected correctly.");

    runNextCase(state);
  }

  if (packet.updateType === "securityInfo") {
    state.client.getSecurityInfo(packet.from, onSecurityInfo);
  }
}

function whenDelayedStartupFinished(aWindow, aCallback) {
  SpecialPowers.Services.obs.addObserver(function observer(aSubject, aTopic) {
    if (aWindow == aSubject) {
      SpecialPowers.Services.obs.removeObserver(observer, aTopic);
      SimpleTest.executeSoon(aCallback);
    }
  }, "browser-delayed-startup-finished", false);
}

let mainWindow =
  window.QueryInterface(Ci.nsIInterfaceRequestor).
  getInterface(Ci.nsIWebNavigation).QueryInterface(Ci.nsIDocShellTreeItem).
  rootTreeItem.QueryInterface(Ci.nsIInterfaceRequestor).
  getInterface(Ci.nsIDOMWindow);

function runInPrivateWindow() {
  let win = mainWindow.OpenBrowserWindow({private: true});

  Task.spawn(function* () {
    yield new Promise(resolve => whenDelayedStartupFinished(win, resolve));
    let browser = win.gBrowser.selectedBrowser;
    let url = ALL_TESTS[gCurrentTestCase].url;
    win.gBrowser.selectedTab = win.gBrowser.getTabForBrowser(browser);

    yield new Promise(function(resolve) {
      attachConsoleToTab(["NetworkActivity"], function(state) {
        let callback = onNetworkEventUpdate.bind(null, state);
        state.dbgClient.addListener("networkEventUpdate", callback);

        resolve();
      });
    });

    yield BrowserTestUtils.loadURI(browser, url);
  });
}

addEventListener("load", startTest);
</script>
</body>
</html>
