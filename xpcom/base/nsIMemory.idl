/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: NPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Netscape Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/NPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is 
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or 
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the NPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the NPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

/**
 * <font color="#FF0000"><b>    W A R N I N G
 * <p>This API is currently under review in preparation for making it an 
 * officially supported part of the mozilla platform. Please submit comments
 * to porkjockeys@mozilla.org before 6/15/00. Until that time, it is not 
 * advised to base commercial products on this API because it is subject to 
 * change. Use at your own risk!
 * </b></font>
 *
 * @status UNDER_REVIEW
 */

#include "nsISupports.idl"

/**
 * nsIMemory: interface to allocate and deallocate memory. Also provides
 * for notifications in low-memory situations.
 *
 * A client that wishes to be notified of low memory situations (for
 * example, because the client maintains a large memory cache that
 * could be released when memory is tight) may register with the
 * observer service (see nsIObserverService) using the
 * NS_MEMORY_PRESSURE_TOPIC ("memory-pressure") as the topic for
 * observation.
 */
[scriptable, uuid(59e7e77a-38e4-11d4-8cf5-0060b0fc14a3)]
interface nsIMemory : nsISupports
{
    /**
     * Allocates a block of memory of a particular size. If the memory 
     * cannot be allocated (because of an out-of-memory condition), null
     * is returned.
     *
     * @param size - the size of the block to allocate
     * @result the block of memory
     */
    [noscript, notxpcom] voidPtr alloc(in size_t size);

    /**
     * Reallocates a block of memory to a new size.
     *
     * @param ptr - the block of memory to reallocate
     * @param size - the new size
     * @result the reallocated block of memory
     *
     * If ptr is null, this function behaves like malloc.
     * If s is the size of the block to which ptr points, the first
     * min(s, size) bytes of ptr's block are copied to the new block.
     * If the allocation succeeds, ptr is freed and a pointer to the 
     * new block returned.  If the allocation fails, ptr is not freed
     * and null is returned. The returned value may be the same as ptr.
     */
    [noscript, notxpcom] voidPtr realloc(in voidPtr ptr,
                                         in size_t newSize);

    /**
     * Frees a block of memory. Null is a permissible value, in which case
     * nothing happens. 
     *
     * @param ptr - the block of memory to free
     */
    [noscript, notxpcom] void free(in voidPtr ptr);

    /**
     * Attempts to shrink the heap.
     * @param immediate - if true, heap minimization will occur
     *   immediately if the call was made on the main thread. If
     *   false, the flush will be scheduled to happen when the app is
     *   idle.
     * @return NS_ERROR_FAILURE if 'immediate' is set an the call
     *   was not on the application's main thread.
     */
    void heapMinimize(in boolean immediate);

    /**
     * This predicate can be used to determine if we're in a low-memory
     * situation (what constitutes low-memory is platform dependent). This
     * can be used to trigger the memory flushers.
     */
    boolean isLowMemory();
};

%{C++
/**
 * This is the topic that a memory pressure observer
 * should use with the observer service.
 */
#define NS_MEMORY_PRESSURE_TOPIC (NS_LITERAL_STRING("memory-pressure").get())

/**
 * This will be passed as the extra data when the flusher
 * is being asked to flush for low-memory conditions.
 */
#define NS_MEMORY_PRESSURE_LOW_MEMORY (NS_LITERAL_STRING("low-memory").get())

/**
 * This will be passed as the extra data when the flusher
 * is being asked to flush because of a heap minimize call.
 */
#define NS_MEMORY_PRESSURE_HEAP_MINIMIZE (NS_LITERAL_STRING("heap-minimize").get())

/**
 * This will be passed as the extra data when the flusher
 * has been asked to flush because a malloc() or realloc()
 * has failed.
 */
#define NS_MEMORY_PRESSURE_ALLOC_FAILURE (NS_LITERAL_STRING("alloc-failure").get())
%}

%{C++
/**
 * ContractID for the global memory service:
 */
#define NS_MEMORY_CONTRACTID "@mozilla.org/xpcom/memory-service;1"
%}
