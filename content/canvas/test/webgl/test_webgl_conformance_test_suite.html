<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>
Mochitest version of the WebGL Conformance Test Suite
</title>
<script type="application/javascript" src="/MochiKit/packed.js"></script>
<script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
<link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
<script type="text/javascript" src="resources/webgl-test-harness.js"></script>
<script>

/**
 * This is copied from webgl-test-harness.js where it is defined as a private function, not accessible to us (argh!)
 *
 * Loads text from an external file. This function is synchronous.
 * @param {string} url The url of the external file.
 * @return {string} the loaded text if the request is synchronous.
 */
var loadTextFileSynchronous = function(url) {
  var error = 'loadTextFileSynchronous failed to load url "' + url + '"';
  var request;
  if (window.XMLHttpRequest) {
    request = new XMLHttpRequest();
    if (request.overrideMimeType) {
      request.overrideMimeType('text/plain');
    }
  } else {
    throw 'XMLHttpRequest is disabled';
  }
  request.open('GET', url, false);
  request.send(null);
  if (request.readyState != 4) {
    throw error;
  }
  return request.responseText;
};

function start() {

  function prefSvc() {
    var svc = Components.classes["@mozilla.org/preferences-service;1"]
                        .getService(Components.interfaces.nsIPrefService).getBranch("");
    return svc;
  }

  function setEnabledForAllSites(value) {
    netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
    prefSvc().setBoolPref("webgl.enabled_for_all_sites", value);
  }

  function getEnabledForAllSites() {
    netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
    return prefSvc().getBoolPref("webgl.enabled_for_all_sites");
  }

  function setAnglePath(path) {
    netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
    if (path == null) {
      try {
        prefSvc().clearUserPref("gfx.angle.egl.path");
      } catch (e) {
        // ignore
      }
      return;
    }
    try {
      var f = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);
      f.initWithPath(path);
      prefSvc().setComplexValue("gfx.angle.egl.path", Components.interfaces.nsILocalFile, f);
    } catch (e) {
      // ignore -- the path is likely not valid, e.g. trying to use a path of "C:\libs" on non-windows boxes.
    }
  }

  function getAnglePath() {
    netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
    if (prefSvc().getPrefType("gfx.angle.egl.path") == Components.interfaces.nsIPrefBranch.PREF_INVALID)
      return null;
    return prefSvc().getComplexValue("gfx.angle.egl.path", Components.interfaces.nsILocalFile);
  }

  function getPreferEgl() {
    netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
    if (prefSvc().getPrefType("webgl.prefer_egl") == Components.interfaces.nsIPrefBranch.PREF_INVALID)
      return null;
    return prefSvc().getBoolPref("webgl.prefer_egl");
  }

  function setPreferEgl(val) {
    netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
    if (val == null) {
      prefSvc().clearUserPref("webgl.prefer_egl");
      return;
    }
    prefSvc().setBoolPref("webgl.prefer_egl", val);
  }

  function restoreOldPrefs() {
    setEnabledForAllSites(saved_enabled_for_all_sites);
    setAnglePath(saved_angle_path);
    setPreferEgl(saved_prefer_egl);
  }

  function getEnv(env) {
    netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
    var envsvc = Components.classes["@mozilla.org/process/environment;1"].getService(Components.interfaces.nsIEnvironment);
    var val = envsvc.get(env);
    if (val == "")
      return null;
    return val;
  }

  var reportType = WebGLTestHarnessModule.TestHarness.reportType;

  var Page = function(reporter, url) {
    this.reporter = reporter;
    this.url = url;
    this.totalTests = 0;
    this.totalSuccessful = 0;
    this.totalTimeouts = 0;

    var li = reporter.localDoc.createElement('li');
    var div = reporter.localDoc.createElement('div');
    var a = reporter.localDoc.createElement('a');
    a.href = url;
    var node = reporter.localDoc.createTextNode(url);
    a.appendChild(node);
    div.appendChild(a);
    li.setAttribute('class', 'testpage');
    li.appendChild(div);
    var ul = reporter.localDoc.createElement('ul');
    var node = reporter.localDoc.createTextNode('');
    li.appendChild(ul);
    div.appendChild(node);
    this.totalsElem = node;
    this.resultElem = ul;
    this.elem = li;
  };

  Page.prototype.isExpectedToFullyPass = function() {
    return testsExpectedToFail.indexOf(this.url) == -1;
  }

  Page.prototype.errormsg = function(msg) {
    return msg + ' (URL: ' + this.url + ')';
  }

  Page.prototype.addResult = function(msg, success) {
    ++this.totalTests;
    if (success === undefined) {
      ++this.totalTimeouts;
      var result = "timeout";
      var css = "timeout";
      // only few timeouts are actually caught here --- most are caught in finishPage().
      if (this.isExpectedToFullyPass()) {
        ok(false, this.errormsg('Test timed out, "' + msg + '"'));
      }
    } else if (success) {
      ++this.totalSuccessful;
      var result = "success";
      var css = "success";
      // don't report success.
      return;
    } else {
      var result = "failed";
      var css = "fail";
      if (this.isExpectedToFullyPass()) {
        ok(false, this.errormsg('Test failed, "' + msg + '"'));
      }
    }

    var node = this.reporter.localDoc.createTextNode(result + ': ' + msg);
    var li = this.reporter.localDoc.createElement('li');
    li.appendChild(node);
    li.setAttribute('class', css);
    this.resultElem.appendChild(li);
  };

  Page.prototype.startPage = function() {
    this.totalTests = 0;
    this.totalSuccessful = 0;
    this.totalTimeouts = 0;
    // remove previous results.
    while (this.resultElem.hasChildNodes()) {
      this.resultElem.removeChild(this.resultElem.childNodes[0]);
    }
    this.totalsElem.textContent = '';
    return true;
  };

  Page.prototype.finishPage = function(success) {
    var msg = ' (' + this.totalSuccessful + ' of ' +
              this.totalTests + ' passed)';
    if (success === undefined) {
      var css = 'testpagetimeout';
      msg = '(*timeout*)';
      ++this.totalTests;
      ++this.totalTimeouts;
      if (this.isExpectedToFullyPass()) {
        ok(false, this.errormsg('Unexpected timeout in this test page'));
        window.dump('WebGL test error: test page timeout: ' + this.url + '\n');
      }
    } else if (this.totalSuccessful != this.totalTests) {
      var css = 'testpagefail';
      if (this.isExpectedToFullyPass()) {
        window.dump('WebGL test error: test page failure: ' + this.url + '\n');
      }
      // failures have already been reported for the sub-tests
    } else {
      var css = 'testpagesuccess';
      if (this.isExpectedToFullyPass()) {
        ok(true, this.errormsg('Successful test page'));
      }
      window.dump('WebGL test page successful: ' + this.url + '\n');
      testsSuccessful.push(this.url);
    }
    this.elem.setAttribute('class', css);
    this.totalsElem.textContent = msg;
  };

  var Reporter = function() {
    this.localDoc = document;

    this.fullResultsElem = document.getElementById("results-default");

    this.resultElem = document.getElementById("results");
    var node = this.localDoc.createTextNode('');
    this.fullResultsElem.appendChild(node);
    this.fullResultsNode = node;
    this.iframe = document.getElementById("testframe");
    this.currentPageElem = null;
    this.totalPages = 0;
    this.pagesByURL = {};
    this.currentPage = null;
    this.totalTests = 0;
    this.totalSuccessful = 0;
    this.totalTimeouts = 0;
  };

  Reporter.prototype.runTest = function(url) {
    var page = this.pagesByURL[url];
    page.startPage();
    this.currentPage = page;
    this.iframe.src = url;
    return result;
  };

  Reporter.prototype.addPage = function(url) {
    this.currentPage = new Page(this, url, this.resultElem);
    this.resultElem.appendChild(this.currentPage.elem);
    ++this.totalPages;
    this.pagesByURL[url] = this.currentPage;
  };

  Reporter.prototype.startPage = function(url) {
    var page = this.pagesByURL[url];
    this.currentPage = page;
    statusTextNode.textContent = 'Running URL: ' + url;
    expectedtofailTextNode.textContent = testsExpectedToFail.length +
                                         ' test pages are expected to fail out of ' +
                                         this.totalPages;
    return page.startPage();
  };

  Reporter.prototype.totalFailed = function() {
    return this.totalTests - this.totalSuccessful;
  };

  Reporter.prototype.displayStats = function() {
    this.fullResultsNode.textContent =
      this.totalSuccessful + ' passed, ' +
      this.totalFailed() + ' failed, ' +
      this.totalTimeouts + ' timed out';
  };

  Reporter.prototype.addResult = function(msg, success) {
    if (this.currentPage != null) {
      this.currentPage.addResult(msg, success);
    }
  };

  Reporter.prototype.finishPage = function(success) {
    if (this.currentPage != null) {
      this.currentPage.finishPage(success); // must call that first, since this is where totalTimeouts is computed
      this.totalTests += this.currentPage.totalTests;
      this.totalSuccessful += this.currentPage.totalSuccessful;
      this.totalTimeouts += this.currentPage.totalTimeouts;
      this.currentPage = null;
      this.displayStats();
    }
  };

  Reporter.prototype.completedCurrentTestSuiteRun = function() {
        timesTestSuiteAlreadyRun++;
        runTestSuite();
  };

  Reporter.prototype.reportFunc = function(type, msg, success) {
    switch (type) {
      case reportType.ADD_PAGE:
        return this.addPage(msg);
      case reportType.START_PAGE:
        return this.startPage(msg);
      case reportType.TEST_RESULT:
        return this.addResult(msg, success);
      case reportType.FINISH_PAGE:
        return this.finishPage(success);
      case reportType.FINISHED_ALL_TESTS:
        this.completedCurrentTestSuiteRun();
        return true;
      default:
        throw 'unhandled';
        break;
    };
  };

  function doRunTests() {
    var reporter = new Reporter();

    // set WebGL-related preferences needed to run WebGL tests
    setEnabledForAllSites(true);

    // if this wasn't specified, then set it to our expected dir for the build
    // machines
    if (!saved_angle_path) {
      // For windows test runners.  For everyone else, it doesn't matter,
      // we'll use ANGLE if it's installed according to the prefs.
      setAnglePath("C:\\libs");
      setPreferEgl(true);
    }

    // try to create a dummy WebGL context, just to catch context creation failures once here,
    // rather than having them result in 100's of failures (one in each test page)
    var canvas = document.getElementById("webglcheck-default");
    var ctx = null;
    try {
        ctx = canvas.getContext("experimental-webgl");
    } catch(e) {}

    if (ctx) {
        var iframe = document.getElementById("testframe");
        var testHarness = new WebGLTestHarnessModule.TestHarness(
            iframe,
            '00_testFIXME_list.txt',
            function(type, msg, success) {
                return reporter.reportFunc(type, msg, success);
            });
        testHarness.setTimeoutDelay(10000); // and make it much higher when running under valgrind.
        window.webglTestHarness = testHarness;
        testHarness.runTests();
    } else {
        // if the webgl context is null, we agreed that we wouldn't fail the test, we only add a TODO mentioning
        // that the GL setup needs to be fixed in order for these tests to be actually run. The reason why we don't
        // currently want to fail the test is that we want to be able to land this mochitest as soon as possible and
        // just take care of the GL setups on the test machines afterwards.
        var errmsg = "Disabled, because we were unable to create a WebGL context anyhow.";
        reporter.fullResultsNode.textContent = errmsg;
        todo(false, errmsg);
        reporter.completedCurrentTestSuiteRun();
    }
  };

  function runTestSuite() {
    if (timesTestSuiteAlreadyRun == 1) {
      for (var i = 0; i < testsExpectedToFail.length; ++i) {
        if (testsSuccessful.indexOf(testsExpectedToFail[i]) != -1) {
          todo(false, 'Test expected to fail, but passed: ' + testsExpectedToFail[i]);
          dump('Test expected to fail, but passed: ' + testsExpectedToFail[i] + '\n');
        }
      }

      restoreOldPrefs();
      statusTextNode.textContent = 'Finished';
      SimpleTest.finish();
      return;
    }

    doRunTests();
  };

  SimpleTest.waitForExplicitFinish();
  SimpleTest.requestLongerTimeout(2);

  if (getEnv("MOZ_WEBGL_TEST_SUITE") == null) {
    // webgl test suite is disabled unless the env var is set
    todo(false, 'WebGL test suite is disabled!');
    SimpleTest.finish();
    return;
  }

  var timesTestSuiteAlreadyRun = 0;

  var saved_enabled_for_all_sites = getEnabledForAllSites();
  var saved_angle_path = getAnglePath();
  var saved_prefer_egl = getPreferEgl();

  var statusElem = document.getElementById("status");
  var statusTextNode = document.createTextNode('');
  statusElem.appendChild(statusTextNode);

  var expectedtofailElem = document.getElementById("expectedtofail");
  var expectedtofailTextNode = document.createTextNode('');
  expectedtofailElem.appendChild(expectedtofailTextNode);

  var testsExpectedToFail = loadTextFileSynchronous('failing_tests.txt').split('\n');
  var testsSuccessful = [];

  runTestSuite();
}

</script>
</head>
<body onload="start()">
<p id="display"></p>
<div id="content" style="display: none">

</div>
<table border="2">
<tr style="height: 300px;">
<td>
<table>
<tr><td><h4>WebGL Conformance Test Runner</h4>
<tr><td>
  <div style="border: 1px">
    <b>Status:</b> <div><span id="status"></span></div><br />
    <b>Results:</b>
    <div><span id="results-default"></span></div>
    <br />
    <div><span id="expectedtofail"></span></div>
  </div>
</td></tr>
</table>
</td>
<td>
<iframe id="testframe" scrolling="yes" width="100%" height="100%"></iframe>
</td>
</tr>
<tr>
<td colspan="2">
<div style="text-align: left; width: 100%; height: 100%; overflow: auto;">
<div><ul id="results"></ul></div>
</div>
</td>
</tr>
</table>
<canvas id="webglcheck-default" style="display: none;"></canvas>
</body>
</html>
