<!DOCTYPE HTML>
<html>
<!--
https://bugzilla.mozilla.org/show_bug.cgi?id=421640
-->
<head>
  <title>Test for Bug 396392</title>
  <script type="text/javascript" src="/MochiKit/packed.js"></script>
  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
  <script type="text/javascript" src="/tests/SimpleTest/EventUtils.js"></script>
  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
</head>
<body>
<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=396392">Mozilla Bug Range getClientRects and getBoundingClientRect</a>
<div id="content" style="font-face:monospace;font-size:12px;width:100px">
<p>000000<span>0</span></p><div>00000<span>0</span></div><p>0000<span>0000</span>0000</p>
</div>
<pre id="test">
<script class="testbody" type="text/javascript">

function isEmptyRect(rect, name) {
  is(rect.left, 0, name+'empty rect should have left = 0');
  is(rect.right, 0, name+'empty rect should have right = 0');
  is(rect.top, 0, name+'empty rect should have top = 0');
  is(rect.bottom, 0, name+'empty rect should have bottom = 0');
  is(rect.width, 0, name+'empty rect should have width = 0');
  is(rect.height, 0, name+'empty rect should have height = 0');
}

function isEmptyRectList(rectlist, name) {
  is(rectlist.length, 0, name + 'empty rectlist should have zero rects');
}

function _getRect(r) {
  if (r.length) //array
    return "{left:"+r[0]+",right:"+r[1]+",top:"+r[2]+",bottom:"+r[3]
      +",width:"+r[4]+",height:"+r[5]+"}";
  else
    return "{left:"+r.left+",right:"+r.right+",top:"+r.top+",bottom:"
      +r.bottom+",width:"+r.width+",height:"+r.height+"}";
}

function runATest(obj) {
  var range = document.createRange();
  try {
    range.setStart(obj.range[0],obj.range[1]);
    if (obj.range.length>2) {
       range.setEnd(obj.range[2]||obj.range[0], obj.range[3]);
    }
    //test getBoundingClientRect()
    var rect = range.getBoundingClientRect();
    var testname = 'range.getBoundingClientRect for ' + obj.name;
    if (obj.rect) {
      is(_getRect(rect),_getRect(obj.rect), testname);
    } else {
      isEmptyRect(rect,testname+": ");
    }
    //test getClientRects()
    var rectlist = range.getClientRects();
    testname = 'range.getClientRects for '+obj.name;
    if (!obj.rectList) {
      //rectList is not specified, use obj.rect to figure out rectList
      obj.rectList = obj.rect?[obj.rect]:[];
    }
    if (!obj.rectList.length) {
      isEmptyRectList(rectlist, testname+": ");
    } else {
      is(rectlist.length, obj.rectList.length, testname+' should return '+obj.rectList.length+' rects.');
      obj.rectList.forEach(function(rect,i) {
        is(_getRect(rectlist[i]),_getRect(rect),testname+": item at "+i);
      });
    }
  } finally {
    range.detach();
  }
}
/** Test for Bug 396392 **/
function test() {
  var root = document.getElementById('content');
  var firstP = root.firstElementChild, spanInFirstP = firstP.childNodes[1],
    firstDiv = root.childNodes[2], spanInFirstDiv = firstDiv.childNodes[1],
    secondP = root.childNodes[3], spanInSecondP = secondP.childNodes[1];
  var firstPRect = firstP.getBoundingClientRect(),
    spanInFirstPRect = spanInFirstP.getBoundingClientRect(),
    firstDivRect = firstDiv.getBoundingClientRect(),
    spanInFirstDivRect = spanInFirstDiv.getBoundingClientRect(),
    secondPRect = secondP.getBoundingClientRect(),
    spanInSecondPRect = spanInSecondP.getBoundingClientRect();
  var widthPerchar = spanInSecondPRect.width / spanInSecondP.firstChild.length;
  var testcases = [
    {name:'nodesNotInDocument', range:[document.createTextNode('abc'), 1], 
      rect:null},
    {name:'collapsedInBlockNode', range:[firstP, 2], rect:null},
    {name:'collapsedAtBeginningOfTextNode', range:[firstP.firstChild, 0],
      rect:[firstPRect.left, firstPRect.left, spanInFirstPRect.top, 
      spanInFirstPRect.bottom, 0, spanInFirstPRect.height]},
    {name:'collapsedWithinTextNode', range:[firstP.firstChild, 1], 
      rect:[firstPRect.left+widthPerchar, firstPRect.left+widthPerchar,
        spanInFirstPRect.top, spanInFirstPRect.bottom, 0, spanInFirstPRect.height]},
    {name:'collapsedAtEndOfTextNode', range:[firstP.firstChild, 6], 
      rect:[firstPRect.left + 6*widthPerchar, firstPRect.left + 6*widthPerchar,
        spanInFirstPRect.top, spanInFirstPRect.bottom, 0, spanInFirstPRect.height]},
    {name:'singleBlockNode', range:[root, 1, root, 2], rect:firstPRect},
    {name:'twoBlockNodes', range:[root, 1, root, 3],
      rect:[firstPRect.left, firstPRect.right, firstPRect.top,
        firstDivRect.bottom, firstPRect.width,
        firstDivRect.bottom - firstPRect.top],
      rectList:[firstPRect, firstDivRect]},
    {name:'endOfTextNodeToEndOfAnotherTextNodeInAnotherBlock',
      range:[spanInFirstP.firstChild, 1, firstDiv.firstChild, 5],
      rect:[firstDivRect.left, firstDivRect.left + 5*widthPerchar,
        spanInFirstDivRect.top, spanInFirstDivRect.bottom, 5 * widthPerchar, 
        spanInFirstDivRect.height]},
    {name:'startOfTextNodeToStartOfAnotherTextNodeInAnotherBlock', 
      range:[spanInFirstP.firstChild, 0, firstDiv.firstChild, 0],
      rect:[spanInFirstPRect.left, spanInFirstPRect.left + widthPerchar, spanInFirstPRect.top,
        spanInFirstPRect.bottom, widthPerchar, spanInFirstPRect.height]},
    {name:'endPortionOfATextNode', range:[firstP.firstChild, 3, 
        firstP.firstChild, 6],
      rect:[firstPRect.left + 3*widthPerchar, firstPRect.left + 6*widthPerchar,
        spanInFirstPRect.top, spanInFirstPRect.bottom, 3*widthPerchar, spanInFirstPRect.height]},
    {name:'startPortionOfATextNode', range:[firstP.firstChild, 0, 
        firstP.firstChild, 3],
      rect:[firstPRect.left, firstPRect.left + 3*widthPerchar, spanInFirstPRect.top,
        spanInFirstPRect.bottom, 3 * widthPerchar, spanInFirstPRect.height]},
    {name:'spanTextNodes', range:[secondP.firstChild, 1, secondP.lastChild, 1],
      rect:[secondPRect.left + widthPerchar, spanInSecondPRect.right + 
        widthPerchar, spanInSecondPRect.top, spanInSecondPRect.bottom,
        spanInSecondPRect.width + 4*widthPerchar, spanInSecondPRect.height],
      rectList:[[secondPRect.left + widthPerchar, spanInSecondPRect.left,
        spanInSecondPRect.top, spanInSecondPRect.bottom, 3 * widthPerchar,
        spanInSecondPRect.height],
	spanInSecondPRect,
	[spanInSecondPRect.right, spanInSecondPRect.right + widthPerchar,
          spanInSecondPRect.top, spanInSecondPRect.bottom, widthPerchar,
          spanInSecondPRect.height]]}
  ];
  testcases.forEach(function(tc) {
    runATest(tc);
  });
  //alert(_getRect(rect));

  SimpleTest.finish();
}

window.onload = function() {
  SimpleTest.waitForExplicitFinish();
  setTimeout(test, 0);
};

</script>
</pre>
</body>
</html>
