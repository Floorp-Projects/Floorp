/* -*- Mode: IDL; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include "domstubs.idl"
#include "nsIDocShellTreeItem.idl"
#include "nsIRequest.idl"

%{ C++
#include "js/TypeDecls.h"
#include "mozilla/Maybe.h"
#include "mozilla/NotNull.h"
#include "mozilla/UniquePtr.h"
#include "nsCOMPtr.h"
#include "nsIURI.h"
class nsCommandManager;
class nsPresContext;
class nsDocShellLoadState;
namespace mozilla {
class Encoding;
class HTMLEditor;
class PresShell;
namespace dom {
class BrowsingContext;
class ClientSource;
} // namespace dom
}
%}

/**
 * The nsIDocShell interface.
 */

[ptr] native nsPresContext(nsPresContext);
[ptr] native nsCommandManager(nsCommandManager);
[ptr] native PresShell(mozilla::PresShell);
[ref] native MaybeURI(mozilla::Maybe<nsCOMPtr<nsIURI>>);
[ref] native Encoding(const mozilla::Encoding*);
      native UniqueClientSource(mozilla::UniquePtr<mozilla::dom::ClientSource>);

interface nsIURI;
interface nsIChannel;
interface nsIContentViewer;
interface nsIContentSecurityPolicy;
interface nsIDocShellLoadInfo;
interface nsIEditor;
interface nsIEditingSession;
interface nsIInputStream;
interface nsIRequest;
interface nsISHEntry;
interface nsILayoutHistoryState;
interface nsISecureBrowserUI;
interface nsIScriptGlobalObject;
interface nsIStructuredCloneContainer;
interface nsIDOMStorage;
interface nsIPrincipal;
interface nsIWebBrowserPrint;
interface nsIPrivacyTransitionObserver;
interface nsIReflowObserver;
interface nsIScrollObserver;
interface nsIRemoteTab;
interface nsIBrowserChild;
interface nsICommandParams;
interface nsILoadURIDelegate;
native BrowserChildRef(already_AddRefed<nsIBrowserChild>);
native nsDocShellLoadStatePtr(nsDocShellLoadState*);

webidl BrowsingContext;
webidl ContentFrameMessageManager;
webidl EventTarget;
webidl Document;

[scriptable, builtinclass, uuid(049234fe-da10-478b-bc5d-bc6f9a1ba63d)]
interface nsIDocShell : nsIDocShellTreeItem
{
  void setCancelContentJSEpoch(in long aEpoch);

  /**
   * Loads a given URI.  This will give priority to loading the requested URI
   * in the object implementing this interface.  If it can't be loaded here
   * however, the URL dispatcher will go through its normal process of content
   * loading.
   *
   * @param aLoadState This is the extended load info for this load.
   * @param aSetNavigating If we should set isNavigating to true while initiating
   *                       the load.
   */
  [noscript]void loadURI(in nsDocShellLoadStatePtr aLoadState, in boolean aSetNavigating);

  /**
   * Do either a history.pushState() or history.replaceState() operation,
   * depending on the value of aReplace.
   */
  [implicit_jscontext]
  void addState(in jsval aData, in AString aTitle,
                in AString aURL, in boolean aReplace);

  /**
   * Helper for addState and document.open that does just the
   * history-manipulation guts.
   *
   * Arguments the spec defines:
   *
   * @param aDocument the document we're manipulating.  This will get the new URI.
   * @param aNewURI the new URI.
   * @param aData The serialized state data.  May be null.
   * @param aTitle The new title.  May be empty.
   * @param aReplace whether this should replace the exising SHEntry.
   *
   * Arguments we need internally because deriving them from the
   * others is a bit complicated:
   *
   * @param aCurrentURI the current URI we're working with.  Might be null.
   * @param aEqualURIs whether the two URIs involved are equal.
   */
  [nostdcall]
  void updateURLAndHistory(in Document aDocument, in nsIURI aNewURI,
                           in nsIStructuredCloneContainer aData, in AString aTitle,
                           in boolean aReplace, in nsIURI aCurrentURI,
                           in boolean aEqualURIs);

  /**
   * Reset state to a new content model within the current document and the document
   * viewer.  Called by the document before initiating an out of band document.write().
   */
  void prepareForNewContentModel();

  /**
   * For editors and suchlike who wish to change the URI associated with the
   * document. Note if you want to get the current URI, use the read-only
   * property on nsIWebNavigation.
   */
  void setCurrentURI(in nsIURI aURI);

  /**
   * Notify the associated content viewer and all child docshells that they are
   * about to be hidden.  If |isUnload| is true, then the document is being
   * unloaded and all dynamic subframe history entries are removed as well.
   *
   * @param isUnload
   *        True to fire the unload event in addition to the pagehide event,
   *        and remove all dynamic subframe history entries.
   */
  [noscript] void firePageHideNotification(in boolean isUnload);

  /**
   * Presentation context for the currently loaded document.  This may be null.
   */
  [notxpcom,nostdcall] readonly attribute nsPresContext presContext;

  /**
   * Presentation shell for the currently loaded document.  This may be null.
   */
  [notxpcom,nostdcall] readonly attribute PresShell presShell;

  /**
   * Presentation shell for the oldest document, if this docshell is
   * currently transitioning between documents.
   */
  [notxpcom,nostdcall] readonly attribute PresShell eldestPresShell;

  /**
   * Content Viewer that is currently loaded for this DocShell.  This may
   * change as the underlying content changes.
   */
  readonly attribute nsIContentViewer contentViewer;

  /**
   * Get the id of the outer window that is or will be in this docshell.
   */
  [infallible] readonly attribute unsigned long long outerWindowID;

  /**
   * This attribute allows chrome to tie in to handle DOM events that may
   * be of interest to chrome.
   */
  attribute EventTarget chromeEventHandler;

  /**
   * Whether CSS error reporting is enabled.
   */
  attribute boolean cssErrorReportingEnabled;

  /**
   * Whether to allow plugin execution
   */
  attribute boolean allowPlugins;

  /**
   * Whether to allow Javascript execution
   */
  attribute boolean allowJavascript;

  /**
   * Attribute stating if refresh based redirects can be allowed
   */
  attribute boolean allowMetaRedirects;

  /**
   * Attribute stating if it should allow subframes (framesets/iframes) or not
   */
  attribute boolean allowSubframes;

  /**
   * Attribute stating whether or not images should be loaded.
   */
  attribute boolean allowImages;

  /**
   * Attribute stating whether or not media (audio/video) should be loaded.
   */
  [infallible] attribute boolean allowMedia;

  /**
   * Attribute that determines whether DNS prefetch is allowed for this subtree
   * of the docshell tree.  Defaults to true.  Setting this will make it take
   * effect starting with the next document loaded in the docshell.
   */
  attribute boolean allowDNSPrefetch;

  /**
   * Attribute that determines whether window control (move/resize) is allowed.
   */
  attribute boolean allowWindowControl;

  /**
   * True if the docshell allows its content to be handled by a content listener
   * other than the docshell itself, including the external helper app service,
   * and false otherwise.  Defaults to true.
   */
  [infallible] attribute boolean allowContentRetargeting;

  /**
   * True if new child docshells should allow content retargeting.
   * Setting allowContentRetargeting also overwrites this value.
   */
  [infallible] attribute boolean allowContentRetargetingOnChildren;

  /**
   * Get an array of this docShell and its children.
   *
   * @param aItemType  - Only include docShells of this type, or if typeAll,
   *                     include all child shells.
   *                     Uses types from nsIDocShellTreeItem.
   * @param aDirection - Whether to enumerate forwards or backwards.
   */

  cenum DocShellEnumeratorDirection : 8 {
    ENUMERATE_FORWARDS  = 0,
    ENUMERATE_BACKWARDS = 1
  };

  Array<nsIDocShell> getAllDocShellsInSubtree(in long aItemType,
                                              in nsIDocShell_DocShellEnumeratorDirection aDirection);

  /**
   * The type of application that created this window.
   *
   * DO NOT DELETE, see bug 176166. For firefox, this value will always be
   * UNKNOWN. However, it is used heavily in Thunderbird/comm-central and we
   * don't really have a great replacement at the moment, so we'll just leave it
   * here.
   */
  cenum AppType : 8 {
    APP_TYPE_UNKNOWN = 0,
    APP_TYPE_MAIL    = 1,
    APP_TYPE_EDITOR  = 2
  };

  [infallible] attribute nsIDocShell_AppType appType;

  /**
   * certain docshells (like the message pane)
   * should not throw up auth dialogs
   * because it can act as a password trojan
   */
  attribute boolean allowAuth;

  /**
   * Set/Get the document scale factor.  When setting this attribute, a
   * NS_ERROR_NOT_IMPLEMENTED error may be returned by implementations
   * not supporting zoom.  Implementations not supporting zoom should return
   * 1.0 all the time for the Get operation.  1.0 by the way is the default
   * of zoom.  This means 100% of normal scaling or in other words normal size
   * no zoom.
   */
  attribute float zoom;

  /*
   * Tells the docshell to offer focus to its tree owner.
   * This is currently only necessary for embedding chrome.
   * If forDocumentNavigation is true, then document navigation should be
   * performed, where only the root of documents are selected. Otherwise, the
   * next element in the parent should be returned. Returns true if focus was
   * successfully taken by the tree owner.
   */
  bool tabToTreeOwner(in boolean forward, in boolean forDocumentNavigation);

  /**
   * Current busy state for DocShell
   */
  cenum BusyFlags : 8 {
    BUSY_FLAGS_NONE             = 0,
    BUSY_FLAGS_BUSY             = 1,
    BUSY_FLAGS_BEFORE_PAGE_LOAD = 2,
    BUSY_FLAGS_PAGE_LOADING     = 4,
  };

  [infallible] readonly attribute nsIDocShell_BusyFlags busyFlags;

  /**
   * Load commands for the document
   */
  cenum LoadCommand : 8 {
    LOAD_CMD_NORMAL  = 0x1,   // Normal load
    LOAD_CMD_RELOAD  = 0x2,   // Reload
    LOAD_CMD_HISTORY = 0x4,   // Load from history
    LOAD_CMD_PUSHSTATE = 0x8, // History.pushState()
  };

  /*
   * Attribute to access the loadtype for the document. LoadType Enum is
   * defined in nsDocShellLoadTypes.h
   */
  [infallible] attribute unsigned long loadType;

  /*
   * Default load flags (as defined in nsIRequest) that will be set on all
   * requests made by this docShell and propagated to all child docShells and
   * to nsILoadGroup::defaultLoadFlags for the docShell's loadGroup.
   * Default is no flags.  Once set, only future requests initiated by the
   * docShell are affected, so in general, these flags should be set before
   * the docShell loads any content.
   */
  attribute nsLoadFlags defaultLoadFlags;

  /*
   * returns true if the docshell is being destroyed, false otherwise
   */
  boolean isBeingDestroyed();

  /*
   * Returns true if the docshell is currently executing the onLoad Handler
   */
  readonly attribute boolean isExecutingOnLoadHandler;

  attribute nsILayoutHistoryState layoutHistoryState;

  /**
   * The SecureBrowserUI object for this docshell.  This is set by XUL
   * <browser> or nsWebBrowser for their root docshell.
   */
  attribute nsISecureBrowserUI securityUI;

  /**
   * Object used to delegate URI loading to an upper context.
   * Currently only set for GeckoView to allow handling of load requests
   * at the application level.
   */
  readonly attribute nsILoadURIDelegate loadURIDelegate;

  /**
   * Cancel the XPCOM timers for each meta-refresh URI in this docshell,
   * and this docshell's children, recursively. The meta-refresh timers can be
   * restarted using resumeRefreshURIs().  If the timers are already suspended,
   * this has no effect.
   */
  void suspendRefreshURIs();

  /**
   * Restart the XPCOM timers for each meta-refresh URI in this docshell,
   * and this docshell's children, recursively.  If the timers are already
   * running, this has no effect.
   */
  void resumeRefreshURIs();

  /**
   * Begin firing WebProgressListener notifications for restoring a page
   * presentation. |viewer| is the content viewer whose document we are
   * starting to load.  If null, it defaults to the docshell's current content
   * viewer, creating one if necessary.  |top| should be true for the toplevel
   * docshell that is being restored; it will be set to false when this method
   * is called for child docshells.  This method will post an event to
   * complete the simulated load after returning to the event loop.
   */
  void beginRestore(in nsIContentViewer viewer, in boolean top);

  /**
   * Finish firing WebProgressListener notifications and DOM events for
   * restoring a page presentation.  This should only be called via
   * beginRestore().
   */
  void finishRestore();

  void clearCachedUserAgent();

  /* Track whether we're currently restoring a document presentation. */
  readonly attribute boolean restoringDocument;

  /* attribute to access whether error pages are enabled */
  attribute boolean useErrorPages;

  /**
   * Display a load error in a frame while keeping that frame's currentURI
   * pointing correctly to the page where the error ocurred, rather than to
   * the error document page. You must provide either the aURI or aURL parameter.
   *
   * @param  aError         The error code to be displayed
   * @param  aURI           nsIURI of the page where the error happened
   * @param  aURL           wstring of the page where the error happened
   * @param  aFailedChannel The channel related to this error
   *
   * Returns whether or not we displayed an error page (note: will always
   * return false if in-content error pages are disabled!)
   */
  boolean displayLoadError(in nsresult aError,
                           in nsIURI aURI,
                           in wstring aURL,
                           [optional] in nsIChannel aFailedChannel);

  /**
   * The channel that failed to load and resulted in an error page.
   * May be null. Relevant only to error pages.
   */
  readonly attribute nsIChannel failedChannel;

  /**
   * Keeps track of the previous nsISHEntry index and the current
   * nsISHEntry index at the time that the doc shell begins to load.
   * Used for ContentViewer eviction.
   */
  readonly attribute long previousEntryIndex;
  readonly attribute long loadedEntryIndex;

  /**
   * Notification that entries have been removed from the beginning of a
   * nsSHistory which has this as its rootDocShell.
   *
   * @param numEntries - The number of entries removed
   */
  void historyPurged(in long numEntries);

  /**
   * Gets the channel for the currently loaded document, if any.
   * For a new document load, this will be the channel of the previous document
   * until after OnLocationChange fires.
   */
  readonly attribute nsIChannel currentDocumentChannel;

  /**
   * The original offset of this child in its container. This property is -1 for
   * dynamically added docShells.
   */
  [notxpcom,nostdcall] attribute long childOffset;

  /**
   * Find out whether the docshell is currently in the middle of a page
   * transition. This is set just before the pagehide/unload events fire.
   */
  readonly attribute boolean isInUnload;

  /**
   * This attribute determines whether Mixed Active Content is loaded on the
   * document. When it is true, mixed active content was not blocked and has
   * loaded (or is about to load) on the page. When it is false, mixed active content
   * has not loaded on the page, either because there was no mixed active content
   * requests on the page or such requests were blocked by nsMixedContentBlocker.
   * This boolean is set to true in nsMixedContentBlocker if Mixed Active Content
   * is allowed (either explicitly on the page by the user or when the about:config
   * setting security.mixed_content.block_active_content is set to false).
   */
  [infallible] readonly attribute boolean hasMixedActiveContentLoaded;

   /**
   * This attribute determines whether a document has Mixed Active Content
   * that has been blocked from loading. When it is true, there is definitely
   * mixed active content on a page that has been blocked by
   * nsMixedContentBlocker.  When it is false, there may or may not be mixed
   * active content on a page, but if there is, it will load. Note that if the
   * about:config setting security.mixed_content.block_active_content is set
   * false, this boolean will be false, since blocking active content has been
   * disabled.
   */
  [infallible] readonly attribute boolean hasMixedActiveContentBlocked;

  /**
   * This attribute determines whether Mixed Display Content is loaded on the
   * document. When it is true, mixed display content was not blocked and has
   * loaded (or is about to load) on the page. Similar behavior to
   * hasMixedActiveContentLoaded.
   */
  [infallible] readonly attribute boolean hasMixedDisplayContentLoaded;

   /**
   * This attribute determines whether a document has Mixed Display Content
   * that has been blocked from loading. Similar behavior to
   * hasMixedActiveContentBlocked.
   */
  [infallible] readonly attribute boolean hasMixedDisplayContentBlocked;

  /**
   * Disconnects this docshell's editor from its window, and stores the
   * editor data in the open document's session history entry.  This
   * should be called only during page transitions.
   */
  [noscript, notxpcom] void DetachEditorFromWindow();

  /**
   * If true, this browser is not visible in the traditional sense, but
   * is actively being rendered to the screen (ex. painted on a canvas)
   * and should be treated accordingly.
   **/
  attribute boolean isOffScreenBrowser;

  /**
   * Allows nsDocumentViewer to tell the top-level same-type docshell that
   * one of the documents under it is printing.
   */
  [noscript, notxpcom] void setIsPrinting(in boolean aIsPrinting);

  /**
   * This method should only be called on a docShell that has been specifically
   * created to display a print preview document.  If the current document
   * viewer isn't initialized for print preview when this method is called, it
   * is replaced with a new viewer with an about:blank document (with the URL
   * about:printpreview).  The viewer is then returned, ready for the print
   * preview document to be constructed when viewer.printPreview() is called.
   *
   * The same viewer will be returned on subsequent calls since various bits of
   * code assume that, once created, the viewer is never replaced.  Note,
   * however, that the viewer's document will be replaced with a new document
   * each time printPreview() is called on it (which is what we do to take
   * account of print preview settings changes).  Replacing the document
   * viewer's document breaks the normally unchanging 1:1 relationship between
   * a document and its viewer, but that seems to be okay.
   */
  nsIWebBrowserPrint initOrReusePrintPreviewViewer();

  /**
   * Propagated to the print preview document viewer.  Must only be called on
   * a document viewer that has been initialized for print preview.
   */
  void exitPrintPreview();

  /**
   * Whether this docshell can execute scripts based on its hierarchy.
   * The rule of thumb here is that we disable js if this docshell or any
   * of its parents disallow scripting.
   */
  [infallible] readonly attribute boolean canExecuteScripts;

  /**
   * Sets whether a docshell is active. An active docshell is one that is
   * visible, and thus is not a good candidate for certain optimizations
   * like image frame discarding. Docshells are active unless told otherwise.
   */
  [infallible] attribute boolean isActive;

  /**
   * The ID of the docshell in the session history.
   */
  readonly attribute nsIDPtr historyID;

  /**
   * Helper method for accessing this value from C++
   */
  [noscript, notxpcom] nsID HistoryID();

  /**
   * Sets whether a docshell is an app tab. An app tab docshell may behave
   * differently than a non-app tab docshell in some cases, such as when
   * handling link clicks. Docshells are not app tabs unless told otherwise.
   */
  attribute boolean isAppTab;

  /**
   * Create a new about:blank document and content viewer.
   * @param aPrincipal the principal to use for the new document.
   * @param aStoragePrincipal the storage principal to use for the new document.
   * @param aCsp the CSP to use for the new document.
   */
  void createAboutBlankContentViewer(in nsIPrincipal aPrincipal,
                                     in nsIPrincipal aStoragePrincipal,
                                     [optional] in nsIContentSecurityPolicy aCSP);

  /**
   * Upon getting, returns the canonical encoding label of the document
   * currently loaded into this docshell.
   *
   * Upon setting, sets forcedCharset for compatibility with legacy callers.
   */
  attribute ACString charset;

  /**
   * Called when the user chose an encoding override from the character
   * encoding menu. Separate from the setter for the charset property to avoid
   * extensions adding noise to the data.
   */
  void gatherCharsetMenuTelemetry();

  /**
   * The charset forced by the user.
   */
  attribute ACString forcedCharset;

  /**
   * In a child docshell, this is the charset of the parent docshell
   */
  [noscript, notxpcom, nostdcall] void setParentCharset(
    in Encoding parentCharset,
    in int32_t parentCharsetSource,
    in nsIPrincipal parentCharsetPrincipal);
  [noscript, notxpcom, nostdcall] void getParentCharset(
    out Encoding parentCharset,
    out int32_t parentCharsetSource,
    out nsIPrincipal parentCharsetPrincipal);

  /**
   * Whether the docShell records profile timeline markers at the moment
   */
  [infallible] attribute boolean recordProfileTimelineMarkers;

  /**
   * Return a DOMHighResTimeStamp representing the number of
   * milliseconds from an arbitrary point in time.  The reference
   * point is shared by all DocShells and is also used by timestamps
   * on markers.
   */
  DOMHighResTimeStamp now();

  /**
   * Returns and flushes the profile timeline markers gathered by the docShell
   */
  [implicit_jscontext]
  jsval popProfileTimelineMarkers();

  /**
   * Add an observer to the list of parties to be notified when this docshell's
   * private browsing status is changed. |obs| must support weak references.
   */
  void addWeakPrivacyTransitionObserver(in nsIPrivacyTransitionObserver obs);

  /**
   * Add an observer to the list of parties to be notified when reflows are
   * occurring. |obs| must support weak references.
   */
  void addWeakReflowObserver(in nsIReflowObserver obs);

  /**
   * Remove an observer from the list of parties to be notified about reflows.
   */
  void removeWeakReflowObserver(in nsIReflowObserver obs);

  /**
   * Notify all attached observers that a reflow has just occurred.
   *
   * @param interruptible if true, the reflow was interruptible.
   * @param start         timestamp when reflow started, in milliseconds since
   *                      navigationStart (accurate to 1/1000 of a ms)
   * @param end           timestamp when reflow ended, in milliseconds since
   *                      navigationStart (accurate to 1/1000 of a ms)
   */
  [noscript] void notifyReflowObservers(in bool interruptible,
                                        in DOMHighResTimeStamp start,
                                        in DOMHighResTimeStamp end);

  /**
   * Add an observer to the list of parties to be notified when scroll position
   * of some elements is changed.
   */
  [noscript] void addWeakScrollObserver(in nsIScrollObserver obs);

  /**
   * Add an observer to the list of parties to be notified when scroll position
   * of some elements is changed.
   */
  [noscript] void removeWeakScrollObserver(in nsIScrollObserver obs);

  /**
   * Notify all attached observers that the scroll position of some element
   * has changed.
   */
  [noscript] void notifyScrollObservers();

  /**
   * The type of iframe that this docshell lives.
   */
  cenum FrameType : 8 {
    FRAME_TYPE_REGULAR = 0,
    FRAME_TYPE_BROWSER = 1,
  };
  [infallible] attribute nsIDocShell_FrameType frameType;

  /**
   * Returns true if this docshell corresponds to an <iframe mozbrowser>.
   * <xul:browser> returns false here.
   */
  [infallible] readonly attribute boolean isMozBrowser;

  /**
   * Returns true if this docshell corresponds to an <iframe mozbrowser>, or
   * if this docshell is contained in an <iframe mozbrowser>. <xul:browser>
   * returns false here.
   *
   * To compute this value, we walk up the docshell hierarchy.  If we encounter
   * a docshell with isMozBrowser before we hit the end of the hierarchy,
   * we return true.  Otherwise, we return false.
   */
  [infallible] readonly attribute boolean isInMozBrowser;

  /**
   * Returns true if this docshell is the top level content docshell.
   */
  [infallible] readonly attribute boolean isTopLevelContentDocShell;

  /**
   * Like nsIDocShellTreeItem::GetSameTypeParent, except this ignores <iframe
   * mozbrowser> boundaries.
   *
   * @deprecated: Use `BrowsingContext::GetParent()` in the future.
   */
  nsIDocShell getSameTypeParentIgnoreBrowserBoundaries();

  /**
   * Like nsIDocShellTreeItem::GetSameTypeRootTreeItem, except this ignores
   * <iframe mozbrowser> boundaries.
   *
   * @deprecated: Use `BrowsingContext::Top()` in the future.
   */
  nsIDocShell getSameTypeRootTreeItemIgnoreBrowserBoundaries();

  /**
   * True iff asynchronous panning and zooming is enabled for this
   * docshell.
   */
  readonly attribute bool asyncPanZoomEnabled;

  /**
   * Returns true if we are sandboxed from aTargetDocShell.
   * aTargetDocShell - the browsing context we are attempting to navigate.
   */
  [noscript,notxpcom,nostdcall] bool isSandboxedFrom(in BrowsingContext aTargetBC);

  /**
   * This member variable determines whether a document has Mixed Active Content that
   * was initially blocked from loading, but the user has choosen to override the
   * block and allow the content to load. mMixedContentChannel is set to the document's
   * channel when the user allows mixed content. The nsMixedContentBlocker content policy
   * checks if the document's root channel matches the mMixedContentChannel.  If it matches,
   * then Mixed Content is loaded.  If it does match, mixed content is blocked.
   *
   * A match implies that there is definitely mixed active content on a page that was
   * initially blocked by nsMixedContentBlocker and then allowed and loaded by the user.
   * A miss imples that IF there is mixed active content on the page AND it was
   * blocked by nsMixedContentBlocker.cpp, the user has not choosen to override
   * the block. Note that if the about:config setting
   * security.mixed_content.block_active_content is set to false, this boolean
   * will be false, mMixedContentChannel will remain null since blocking active content has
   * been disabled and hence mMixedContentChannel will never be set.
   */
  attribute nsIChannel mixedContentChannel;

  /**
   * Checks whether the channel associated with the root docShell is equal to
   * mMixedContentChannel. If they are the same, allowMixedContent is set to true.
   * Checks if the root document has a secure connection. If it is, sets
   * rootHasSecureConnection to true. If the docShell is the root doc shell,
   * isRootDocShell is set to true.
   */
  void GetAllowMixedContentAndConnectionData(out boolean rootHasSecureConnection, out boolean allowMixedContent, out boolean isRootDocShell);


  /**
   * Are plugins allowed in the current document loaded in this docshell ?
   * (if there is one). This depends on whether plugins are allowed by this
   * docshell itself or if the document is sandboxed and hence plugins should
   * not be allowed.
   */
  [noscript, notxpcom] bool pluginsAllowedInCurrentDoc();


  /**
   * Attribute that determines whether fullscreen is allowed to be entered for
   * this subtree of the docshell tree. This is true when all iframes containing
   * this docshell have their "allowfullscreen" attribute set to "true".
   * fullscreenAllowed is only writable at content boundaries, where it is used
   * to propagate the value of the cross process parent's iframe's
   * "allowfullscreen" attribute to the child process. Setting
   * fullscreenAllowed on docshells which aren't content boundaries throws an
   * exception.
   */
  [infallible] readonly attribute boolean fullscreenAllowed;

  void setFullscreenAllowed(in boolean allowed);

  [notxpcom] uint32_t orientationLock();
  [notxpcom] void setOrientationLock(in uint32_t orientationLock);

  [noscript, infallible] attribute boolean affectPrivateSessionLifetime;

  /**
   * Indicates whether the UI may enable the character encoding menu. The UI
   * must disable the menu when this property is false.
   */
  [infallible] readonly attribute boolean mayEnableCharacterEncodingMenu;

  /**
   * Indicates that the character encoding was autodetected.
   */
  [infallible] readonly attribute boolean charsetAutodetected;

           attribute  nsIEditor editor;
  readonly attribute  boolean   editable;             /* this docShell is editable */
  readonly attribute  boolean   hasEditingSession;    /* this docShell has an editing session */

  /**
   * Make this docShell editable, setting a flag that causes
   * an editor to get created, either immediately, or after
   * a url has been loaded.
   *      @param  inWaitForUriLoad    true to wait for a URI before
   *                                  creating the editor.
   */
  void makeEditable(in boolean inWaitForUriLoad);


  /**
   * Add a Child SHEntry for a frameset page, given the child's loadtype.
   * If aCloneChildren is true, then aCloneReference's children will be
   * cloned onto aHistoryEntry.
   */
  void addChildSHEntry(in nsISHEntry aCloneReference,
                       in nsISHEntry aHistoryEntry,
                       in long aChildOffset,
                       in unsigned long aLoadType,
                       in boolean aCloneChilden);

  /**
   * Whether this docshell should save entries in global history.
   */
  attribute boolean useGlobalHistory;

  /**
   * Removes nsISHEntry objects related to this docshell from session history.
   * Use this only with subdocuments, like iframes.
   */
  void removeFromSessionHistory();

  /**
   * Set when an iframe/frame is added dynamically.
   */
  [infallible] attribute boolean createdDynamically;

  /**
   * Returns false for mLSHE, true for mOSHE
   */
  boolean getCurrentSHEntry(out nsISHEntry aEntry);

  /**
    * Cherry picked parts of nsIController.
    * They are here, because we want to call these functions
    * from JS.
    */
  boolean isCommandEnabled(in string command);
  [can_run_script]
  void doCommand(in string command);
  [can_run_script]
  void doCommandWithParams(in string command, in nsICommandParams aParams);

  /**
   * Invisible DocShell are dummy construct to simulate DOM windows
   * without any actual visual representation. They have to be marked
   * at construction time, to avoid any painting activity.
   */
  [noscript, notxpcom] bool IsInvisible();
  [noscript, notxpcom] void SetInvisible(in bool aIsInvisibleDocshell);

/**
 * Get the script global for the document in this docshell.
*/
  [noscript,notxpcom,nostdcall] nsIScriptGlobalObject GetScriptGlobalObject();

  /**
   * If deviceSizeIsPageSize is set to true, device-width/height media queries
   * will be calculated from the page size, not the device size.
   *
   * Used by the Responsive Design Mode and B2G Simulator.
   *
   * Default is False.
   * Default value can be overriden with
   * docshell.device_size_is_page_size pref.
   */
  [infallible] attribute boolean deviceSizeIsPageSize;

  /**
   * Notify DocShell when the browser is about to start executing JS, and after
   * that execution has stopped.  This only occurs when the Timeline devtool
   * is collecting information.
   */
  [noscript,notxpcom,nostdcall] void notifyJSRunToCompletionStart(in string aReason,
                                                                  in AString functionName,
                                                                  in AString fileName,
                                                                  in unsigned long lineNumber,
                                                                  in jsval asyncStack,
                                                                  in string asyncCause);
  [noscript,notxpcom,nostdcall] void notifyJSRunToCompletionStop();

  [noscript] void GetOSHEId(out uint32_t aSHEntryId);

  /**
   * This attribute determines whether a document which is not about:blank has
   * already be loaded by this docShell.
   */
  [infallible] readonly attribute boolean hasLoadedNonBlankURI;

  /**
   * Allow usage of -moz-window-dragging:drag for content docshells.
   * True for top level chrome docshells. Throws if set to false with
   * top level chrome docshell.
   */
  attribute boolean windowDraggingAllowed;

  /**
   * Sets/gets the current scroll restoration mode.
   * @see https://html.spec.whatwg.org/#dom-history-scroll-restoration
   */
  attribute boolean currentScrollRestorationIsManual;

  /**
   * Setter and getter for the origin attributes living on this docshell.
   */
  [implicit_jscontext]
  jsval getOriginAttributes();

  [implicit_jscontext]
  void setOriginAttributes(in jsval aAttrs);

  /**
   * The editing session for this docshell.
   */
  readonly attribute nsIEditingSession editingSession;

  /**
   * The browser child for this docshell.
   */
  [binaryname(ScriptableBrowserChild)] readonly attribute nsIBrowserChild browserChild;
  [noscript,notxpcom,nostdcall] BrowserChildRef GetBrowserChild();

  [noscript,nostdcall,notxpcom] nsCommandManager GetCommandManager();

  cenum TouchEventsOverride: 8 {
    /**
     * Override platform/pref default behaviour and force-disable touch events.
     */
    TOUCHEVENTS_OVERRIDE_DISABLED = 0,
    /**
     * Override platform/pref default behaviour and force-enable touch events.
     */
    TOUCHEVENTS_OVERRIDE_ENABLED = 1,
    /**
     * Don't override the platform/pref default behaviour for touch events.
     */
    TOUCHEVENTS_OVERRIDE_NONE = 2,
  };

  /**
   * This allows chrome to override the default choice of whether touch events
   * are available on a specific docshell. Possible values are listed below.
   */
  [infallible] attribute nsIDocShell_TouchEventsOverride touchEventsOverride;

  cenum MetaViewportOverride: 8 {
    /**
     * Override platform/pref default behaviour and force-disable support for
     * <meta name="viewport">.
     */
    META_VIEWPORT_OVERRIDE_DISABLED = 0,
    /**
     * Override platform/pref default behaviour and force-enable support for
     * <meta name="viewport">.
     */
    META_VIEWPORT_OVERRIDE_ENABLED = 1,
    /**
     * Don't override the platform/pref default behaviour for support for
     * <meta name="viewport">.
     */
    META_VIEWPORT_OVERRIDE_NONE = 2,
  };

  /**
   * This allows chrome to override the default choice of whether the
   * <meta name="viewport"> tag is respected in a specific docshell.
   * Possible values are listed above.
   */
  [infallible] attribute nsIDocShell_MetaViewportOverride metaViewportOverride;

  /**
   * Returns `true` if this docshell was created due to a Large-Allocation
   * header, and has not seen the initiating load yet.
   */
  [infallible] readonly attribute boolean awaitingLargeAlloc;

  /**
   * Attribute that determines whether tracking protection is enabled.
   */
  attribute boolean useTrackingProtection;

 /**
  * Fire a dummy location change event asynchronously.
  */
  [noscript] void dispatchLocationChangeEvent();


  /**
   * Start delayed autoplay media which are in the current document.
   */
  [noscript] void startDelayedAutoplayMediaComponents();

  /**
   * Take ownership of the ClientSource representing an initial about:blank
   * document that was never needed.  As an optimization we avoid creating
   * this document if no code calls GetDocument(), but we still need a
   * ClientSource object to represent the about:blank window.  This may return
   * nullptr; for example if the docshell has created a real window and document
   * already.
   */
  [noscript, nostdcall, notxpcom]
  UniqueClientSource TakeInitialClientSource();

  void setColorMatrix(in Array<float> aMatrix);

  /**
   * Returns true if the current load is a forced reload,
   * e.g. started by holding shift whilst triggering reload.
   */
  readonly attribute bool isForceReloading;

  Array<float> getColorMatrix();

  /**
   * Initialize session history for this docshell. The docshell must be the root
   * docshell.
   */
  void initSessionHistory();

%{C++
  /**
   * These methods call nsDocShell::GetHTMLEditorInternal() and
   * nsDocShell::SetHTMLEditorInternal() with static_cast.
   */
  mozilla::HTMLEditor* GetHTMLEditor();
  nsresult SetHTMLEditor(mozilla::HTMLEditor* aHTMLEditor);
%}

  /**
   * Allowed CSS display modes. This needs to be kept in
   * sync with similar values in ServoStyleConsts.h
   */
  cenum DisplayMode: 8 {
    DISPLAY_MODE_BROWSER = 0,
    DISPLAY_MODE_MINIMAL_UI = 1,
    DISPLAY_MODE_STANDALONE = 2,
    DISPLAY_MODE_FULLSCREEN = 3,
  };

  /**
   * Display mode for this docshell. Defaults to DISPLAY_MODE_BROWSER.
   * Media queries only look at the value in the top-most docshell.
   */
  [infallible] attribute nsIDocShell_DisplayMode displayMode;

  /**
   * The message manager for this docshell.  This does not throw, but
   * can return null if the docshell has no message manager.
   */
  [infallible] readonly attribute ContentFrameMessageManager messageManager;

   /**
   * This returns a Promise which resolves to a boolean. True when the
   * document has Tracking Content that has been blocked from loading, false
   * otherwise.
   */
  Promise getHasTrackingContentBlocked();

  /**
   * Return whether this docshell is "attempting to navigate" in the
   * sense that's relevant to document.open.
   */
  [notxpcom, nostdcall] readonly attribute boolean isAttemptingToNavigate;

  /**
   * Whether developer tools are watching activity in this docshell.
   */
  [infallible] attribute boolean watchedByDevtools;

  /*
   * Whether or not this docshell is executing a nsIWebNavigation navigation
   * method.
   *
   * This will be true when the following methods are executing:
   *   nsIWebNavigation.binaryLoadURI
   *   nsIWebNavigation.goBack
   *   nsIWebNavigation.goForward
   *   nsIWebNavigation.gotoIndex
   *   nsIWebNavigation.loadURI
   */
  [infallible] readonly attribute boolean isNavigating;

  /**
   * @see nsISHEntry synchronizeLayoutHistoryState().
   */
  void synchronizeLayoutHistoryState();
};
