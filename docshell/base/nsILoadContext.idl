/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: ft=cpp tw=78 sw=2 et ts=2 sts=2 cin
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include "nsISupports.idl"

interface nsIDOMWindow;
interface nsIDOMElement;

%{C++
#ifdef MOZILLA_INTERNAL_API
#include "mozilla/BasePrincipal.h" // for DocShellOriginAttributes
#include "mozilla/dom/ScriptSettings.h" // for AutoJSAPI
#include "xpcpublic.h" // for PrivilegedJunkScope
#include "nsContentUtils.h" // for IsSystemPrincipal
#endif
%}

/**
 * An nsILoadContext represents the context of a load.  This interface
 * can be queried for various information about where the load is
 * happening.
 */
[scriptable, uuid(96014778-d30b-4fee-8902-a3481788907b)]
interface nsILoadContext : nsISupports
{
  /**
   * associatedWindow is the window with which the load is associated, if any.
   * Note that the load may be triggered by a document which is different from
   * the document in associatedWindow, and in fact the source of the load need
   * not be same-origin with the document in associatedWindow.  This attribute
   * may be null if there is no associated window.
   */
  readonly attribute nsIDOMWindow associatedWindow;

  /**
   * topWindow is the top window which is of same type as associatedWindow.
   * This is equivalent to associatedWindow.top, but is provided here as a
   * convenience.  All the same caveats as associatedWindow of apply, of
   * course.  This attribute may be null if there is no associated window.
   */
  readonly attribute nsIDOMWindow topWindow;

  /**
   * topFrameElement is the <iframe>, <frame>, or <browser> element which
   * contains the topWindow with which the load is associated.
   *
   * Note that we may have a topFrameElement even when we don't have an
   * associatedWindow, if the topFrameElement's content lives out of process.
   * topFrameElement is available in single-process and multiprocess contexts.
   * Note that topFrameElement may be in chrome even when the nsILoadContext is
   * associated with content.
   */
  readonly attribute nsIDOMElement topFrameElement;

  /**
   * If this LoadContext corresponds to a nested remote iframe, we don't have
   * access to the topFrameElement.  Instead, we must use this id to send
   * messages. A return value of 0 signifies that this load context is not for
   * a nested frame.
   */
  readonly attribute unsigned long long nestedFrameId;

  /**
   * Check whether the load is happening in a particular type of application.
   *
   * @param an application type.  For now, the constants to be passed here are
   *        the nsIDocShell APP_TYPE_* constants.
   *
   * @return whether there is some ancestor of the associatedWindow that is of
   *         the given app type.
   */
  boolean isAppOfType(in unsigned long appType);

  /**
   * True if the load context is content (as opposed to chrome).  This is
   * determined based on the type of window the load is performed in, NOT based
   * on any URIs that might be around.
   */
  readonly attribute boolean isContent;

  /*
   * Attribute that determines if private browsing should be used.
   */
  attribute boolean usePrivateBrowsing;

  /**
   * Attribute that determines if remote (out-of-process) tabs should be used.
   */
  readonly attribute boolean useRemoteTabs;

%{C++
  /**
   * De-XPCOMed getter to make call-sites cleaner.
   */
  bool UsePrivateBrowsing() {
    bool usingPB;
    GetUsePrivateBrowsing(&usingPB);
    return usingPB;
  }

  bool UseRemoteTabs() {
    bool usingRT;
    GetUseRemoteTabs(&usingRT);
    return usingRT;
  }
%}

  /**
   * Set the private browsing state of the load context, meant to be used internally.
   */
  [noscript] void SetPrivateBrowsing(in boolean aInPrivateBrowsing);

  /**
   * Set the remote tabs state of the load context, meant to be used internally.
   */
  [noscript] void SetRemoteTabs(in boolean aUseRemoteTabs);

  /**
   * Returns true iff the load is occurring inside a browser element.
   */
  readonly attribute boolean isInBrowserElement;

  /**
   * Returns the app id of the app the load is occurring is in. Returns
   * nsIScriptSecurityManager::NO_APP_ID if the load is not part of an app.
   */
  readonly attribute unsigned long appId;

  /**
   * A dictionary of the non-default origin attributes associated with this
   * nsILoadContext.
   */
  readonly attribute jsval originAttributes;

%{C++
#ifdef MOZILLA_INTERNAL_API
  /**
   * The C++ getter for origin attributes.
   */
  bool GetOriginAttributes(mozilla::DocShellOriginAttributes& aAttrs)
  {
    mozilla::dom::AutoJSAPI jsapi;
    bool ok = jsapi.Init(xpc::PrivilegedJunkScope());
    NS_ENSURE_TRUE(ok, false);
    JS::Rooted<JS::Value> v(jsapi.cx());
    nsresult rv = GetOriginAttributes(&v);
    NS_ENSURE_SUCCESS(rv, false);
    NS_ENSURE_TRUE(v.isObject(), false);
    JS::Rooted<JSObject*> obj(jsapi.cx(), &v.toObject());

    // If we're JS-implemented, the object will be left in a different (System-Principaled)
    // scope, so we may need to enter its compartment.
    MOZ_ASSERT(nsContentUtils::IsSystemPrincipal(nsContentUtils::ObjectPrincipal(obj)));
    JSAutoCompartment ac(jsapi.cx(), obj);

    mozilla::DocShellOriginAttributes attrs;
    ok = attrs.Init(jsapi.cx(), v);
    NS_ENSURE_TRUE(ok, false);
    aAttrs = attrs;
    return true;
  }

#endif
%}
};
