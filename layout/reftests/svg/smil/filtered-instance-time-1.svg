<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     class="reftest-wait"
     onload="go()">
  <!-- Instance time filtering involves removing instance times that are no
       longer needed. However, under some arrangements an excessive number of
       instance times may be generated that will never be cleaned up since they
       might potentially still affect the behavior of the timing model.
       
       For example, consider the case where we have a valid cyclic dependency
       (e.g.  a ping-pong effect) between TimeEvents. For example,
       a.begin=b.endEvent and b.begin=a.endEvent. The times generated by this
       arrangement won't be cleared by regular filtering since they're
       technically unpredictable (e.g. seeking the document will cause some
       events to be suppressed) and so we preserve them to provide correct
       backwards seeking support.

       Therefore, after reaching a certain threshold, old instance times are
       simply discarded indiscriminantly to avoid consuming memory in unbounded
       fashion as the animation progresses.

       This test checks this second stage of instance time filtering. -->
  <script>
    function go() {
      var svg = document.documentElement;
      var anim = document.getElementById('anim');

      // To begin with we have an animation from 0s-2s
      svg.pauseAnimations();
      svg.setCurrentTime(1.0); // Seek to mid-interval

      // Generate a lot of instance times beyond the interval end at t=2s
      // The threshold will be something like 100 but just in case it's 200
      // let's make 210 instance times.
      for (var i = 0; i &lt; 210; i++) {
        // The first instance time will be at t=3s and then we'll generate lots
        // of times following on from there
        anim.beginElementAt(2 + i * 0.1);
      }

      // Seek past the interval end -- this will cause the filtering to kick in.
      // The first stage of filtering will only filter instance times before the
      // end of the previous interval (i.e. before t=2s in this case).
      // The second stage of filtering should take care of the rest.
      svg.setCurrentTime(2.5);

      // The second stage of filtering will clear out the oldest times first.
      // However, since first time we generated at t=3s is now used as begin of
      // the yet-to-begin current interval it should not be cleared.
      // So if we force the current interval to be updated by adding another
      // instance time the next interval should still start at t=3s.
      anim.beginElementAt(100);

      // Now when we go to do a snapshot at t=3s, the animation should be in
      // effect.
      svg.setCurrentTime(3.0);
      svg.removeAttribute("class");
    }
  </script>
  <rect id="blueRect" x="100" y="15" width="200" height="200" fill="blue">
    <set id="anim" attributeName="x" to="15" begin="0s" dur="2s"/>
  </rect>
</svg>
