/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set ts=8 sts=2 et sw=2 tw=80: */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

/* C++ types corresponding to Servo and Gecko types used across bindings,
   with some annotations to indicate ownership expectations */

// This file defines a number of C++ types used to represent borrowed,
// strong, and owning references to Servo and Gecko objects that might
// be used across bindings and FFI.
//
// By convention, the types defined here are named "RawServo{Type}" and
// "RawGecko{Type}".  The {Type} should be something close to the real Rust or
// C++ name of the type, but need not be.  The "Raw" is really just used to
// avoid clashing with other names.
//
// For Servo types, each "RawServo{ServoTypeName}" is generated as an opaque,
// declared but not defined struct.
//
// For Gecko types, each "RawGecko{GeckoTypeName}" is a typedef that aliases
// the actual C++ type.
//
// Each of these types can have a number of different typedefs generated for
// them, representing different notions of ownership when passing or receiving
// these values across bindings and FFI:
//
//   Raw{Gecko,Servo}{Type}Borrowed
//   Raw{Gecko,Servo}{Type}BorrowedOrNull
//     immutable, borrowed reference (or null)
//
//   Raw{Gecko,Servo}{Type}BorrowedMut
//   Raw{Gecko,Servo}{Type}BorrowedMutOrNull
//     mutable, borrowed reference (or null)
//
//   RawServo{Type}Strong
//     strong reference to an Arc-managed value
//
//   RawServo{Type}Owned
//   RawServo{Type}OwnedOrNull
//     owned reference to a Box-managed value (or null)
//
// All of these borrowed, strong, and owned types are generated by adding
// entries to one of these files:
//
//   BorrowedTypeList.h
//     generates some or all of the Borrowed types
//
//   ServoArcTypeList.h
//     generates all of the Borrowed types and the Strong type
//
//   ServoBoxedTypeList.h
//     generates all of the Borrowed types and the Owned & OwnedNull types
//
// The borrowed, strong, and owned reference types should be used in FFI
// function signatures where possible, to help indicate the ownership properties
// that both sides of the function call must adhere to.
//
// There are some special cases defined at the bottom of this file that don't
// fit neatly into these three categories.
//
//
// Using these types in C++
// ========================
//
// All of the Borrowed types are C++ typedefs for raw pointers, and can be used
// directly.  Since the types they point to are opaque, there isn't much that
// can be done with these apart from passing them around, holding on to them,
// checking them for equality, etc.  If they are Arc-managed or Box-managed
// Servo types, they can be assigned to a RefPtr<> or UniquePtr<>.
//
// The Strong types are a C++ struct that wraps a raw pointer.  When receiving
// a Strong value from a Servo_* FFI function, you must call Consume() on it
// to convert it into an already_AddRefed<RawServo{Type}>, otherwise it will
// leak.
//
// We don't currently have any cases where we pass a Strong value to Servo; this
// could be done by creating a RawServo{Type}Strong struct value whose mPtr is
// initialized to the result of calling `.forget().take()` on a
// RefPtr<RawServo{Type}>, but it's probably easier just to pass a Borrowed
// value and let the Rust code turn it into an Arc.
//
// The Owned types are C++ typedefs for raw pointers.  When receiving an Owned
// value from a Servo_* FFI function, it should be assigned to a UniquePtr<>,
// otherwise it will leak.
//
// To pass an Owned value to Servo, call `release()` on the UniquePtr<> it's
// living in (to take ownership of it), and pass that pointer in directly.
//
// TODO(heycam): We should perhaps have a similar struct for Owned types with
// a Consume() method to convert them into a UniquePtr.  The struct for Strong
// types at least have MOZ_MUST_USE_TYPE on them.
//
//
// Using these types in Rust
// =========================
//
// The FFI type names are available in Rust in the gecko_bindings::bindings mod,
// which is generated by servo/components/style/build_gecko.rs.
//
// The Borrowed types are defined as Rust reference types.
//
// Borrowed types for Gecko values are references to the bindgened versions of
// the C++ types, so when receiving references over FFI into a Servo_* function,
// they can be used directly, and when returning them back to Gecko, the
// reference can be returned directly.
//
// Borrowed types for Servo values are references to an opaque type, which must
// be converted to or from the appropriate Rust type:
//
//   For an Arc-owned value, a RawServoFooBorrowed received from FFI can be
//   converted into a `&Arc<Foo>` by calling `Foo::as_arc(&raw_servo_foo)`.
//   Returning a RawServoFooBorrowed over FFI back to Gecko can be done by
//   calling `as_borrowed()` on the `Arc<Foo>`.
//
//   For a Box-owned value, a RawServoFooBorrowed received from FFI can be
//   converted into a `&Foo` by calling `Foo::from_ffi(&raw_servo_foo)`.
//   Returning a RawServoFooBorrowed over FFI back to Gecko can be done by
//   calling `as_ffi()` on the `Foo`.
//
// The Strong types are defined as gecko_bindings::sugar::ownership::Strong<T>.
//
// This is an FFI safe type that represents the value with a strong reference
// already added to it.  Dropping a Strong<T> will leak the strong reference.
//
// A RawServoFooStrong received from FFI can be converted into a
// `RawOffsetArc<Foo>` by calling `into_arc()` or `into_arc_opt()` on it.
// To pass a RawServoFooStrong back to Gecko, call `into_strong()` on the
// `Arc<Foo>`.
//
// The Owned types are defined as gecko_bindings::sugar::ownership::Owned<T>
// (or OwnedOrNull<T>).
//
// This is another FFI safe type that represents the owning reference to the
// value.  Dropping an Owned<T> will leak the value.
//
// A RawServoFooOwned received from FFI can be converted into a `Box<Foo>`
// by calling `into_box()` or `into_box_opt()` on it.  To pass a
// RawServoFooOwned back to Gecko, call `HasBoxFFI::into_ffi()` passing in
// the `Box<Foo>` value.
//
//
// Reading through servo/components/style/gecko_bindings/sugar/ownership.rs
// is also instructive in understanding all this.

#ifndef mozilla_ServoBindingTypes_h
#define mozilla_ServoBindingTypes_h

#include "mozilla/RefPtr.h"
#include "mozilla/ServoComputedData.h"
#include "mozilla/ServoTypes.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/gfx/Types.h"
#include "nsCSSPropertyID.h"
#include "nsStyleAutoArray.h"
#include "nsTArray.h"

struct RawServoAuthorStyles;
struct RawServoStyleSet;
struct RawServoSelectorList;
struct RawServoSourceSizeList;
struct RawServoAnimationValueMap;
struct StyleUseCounters;

#define SERVO_ARC_TYPE(name_, type_) struct type_;
#include "mozilla/ServoArcTypeList.h"
#undef SERVO_ARC_TYPE

namespace mozilla {
class ServoElementSnapshot;
class ComputedStyle;
struct StyleAnimation;
struct URLExtraData;
namespace dom {
class Element;
class StyleChildrenIterator;
} // namespace dom
struct AnimationPropertySegment;
struct ComputedTiming;
struct Keyframe;
struct PropertyValuePair;
struct PropertyStyleAnimationValuePair;
using ComputedKeyframeValues = nsTArray<PropertyStyleAnimationValuePair>;
} // namespace mozilla

class nsCSSPropertyIDSet;
class nsCSSValue;
struct nsFontFaceRuleContainer;
class nsIDocument;
class nsINode;
class nsPresContext;
struct nsTimingFunction;
class nsXBLBinding;

using mozilla::dom::StyleChildrenIterator;
using mozilla::ServoElementSnapshot;

typedef void* RawServoAnimationValueTableBorrowed;

typedef nsINode RawGeckoNode;
typedef mozilla::dom::Element RawGeckoElement;
typedef nsIDocument RawGeckoDocument;
typedef nsPresContext RawGeckoPresContext;
typedef nsXBLBinding RawGeckoXBLBinding;
typedef mozilla::URLExtraData RawGeckoURLExtraData;
typedef nsTArray<RefPtr<RawServoAnimationValue>> RawGeckoServoAnimationValueList;
typedef nsTArray<mozilla::Keyframe> RawGeckoKeyframeList;
typedef nsTArray<mozilla::PropertyValuePair> RawGeckoPropertyValuePairList;
typedef nsTArray<mozilla::ComputedKeyframeValues> RawGeckoComputedKeyframeValuesList;
typedef nsStyleAutoArray<mozilla::StyleAnimation> RawGeckoStyleAnimationList;
typedef nsTArray<nsFontFaceRuleContainer> RawGeckoFontFaceRuleList;
typedef mozilla::AnimationPropertySegment RawGeckoAnimationPropertySegment;
typedef mozilla::ComputedTiming RawGeckoComputedTiming;
typedef nsTArray<const RawServoStyleRule*> RawGeckoServoStyleRuleList;
typedef nsTArray<nsCSSPropertyID> RawGeckoCSSPropertyIDList;
typedef mozilla::gfx::Float RawGeckoGfxMatrix4x4[16];
typedef mozilla::dom::StyleChildrenIterator RawGeckoStyleChildrenIterator;

// We have these helper types so that we can directly generate
// things like &T or Borrowed<T> on the Rust side in the function, providing
// additional safety benefits.
//
// FFI has a problem with templated types, so we just use raw pointers here.
//
// The "Borrowed" types generate &T or Borrowed<T> in the nullable case.
//
// The "Owned" types generate Owned<T> or OwnedOrNull<T>. Some of these
// are Servo-managed and can be converted to Box<ServoType> on the
// Servo side.
//
// The "Arc" types are Servo-managed Arc<ServoType>s, which are passed
// over FFI as Strong<T> (which is nullable).
// Note that T != ServoType, rather T is ArcInner<ServoType>
#define DECL_BORROWED_REF_TYPE_FOR(type_) typedef type_ const* type_##Borrowed;
#define DECL_NULLABLE_BORROWED_REF_TYPE_FOR(type_) typedef type_ const* type_##BorrowedOrNull;
#define DECL_BORROWED_MUT_REF_TYPE_FOR(type_) typedef type_* type_##BorrowedMut;
#define DECL_NULLABLE_BORROWED_MUT_REF_TYPE_FOR(type_) typedef type_* type_##BorrowedMutOrNull;

#define SERVO_ARC_TYPE(name_, type_)         \
  DECL_NULLABLE_BORROWED_REF_TYPE_FOR(type_) \
  DECL_BORROWED_REF_TYPE_FOR(type_)          \
  DECL_BORROWED_MUT_REF_TYPE_FOR(type_)      \
  struct MOZ_MUST_USE_TYPE type_##Strong     \
  {                                          \
    type_* mPtr;                             \
    already_AddRefed<type_> Consume();       \
  };
#include "mozilla/ServoArcTypeList.h"
#undef SERVO_ARC_TYPE

typedef mozilla::ComputedStyle const* ComputedStyleBorrowed;
typedef mozilla::ComputedStyle const* ComputedStyleBorrowedOrNull;
typedef ServoComputedData const* ServoComputedDataBorrowed;

struct MOZ_MUST_USE_TYPE ComputedStyleStrong
{
  mozilla::ComputedStyle* mPtr;
  already_AddRefed<mozilla::ComputedStyle> Consume();
};

#define DECL_OWNED_REF_TYPE_FOR(type_)    \
  typedef type_* type_##Owned;            \
  DECL_BORROWED_REF_TYPE_FOR(type_)       \
  DECL_BORROWED_MUT_REF_TYPE_FOR(type_)

#define DECL_NULLABLE_OWNED_REF_TYPE_FOR(type_)    \
  typedef type_* type_##OwnedOrNull;               \
  DECL_NULLABLE_BORROWED_REF_TYPE_FOR(type_)       \
  DECL_NULLABLE_BORROWED_MUT_REF_TYPE_FOR(type_)

// This is a reference to a reference of RawServoDeclarationBlock, which
// corresponds to Option<&Arc<Locked<RawServoDeclarationBlock>>> in Servo side.
DECL_NULLABLE_BORROWED_REF_TYPE_FOR(RawServoDeclarationBlockStrong)
DECL_OWNED_REF_TYPE_FOR(RawServoAuthorStyles)
DECL_NULLABLE_BORROWED_REF_TYPE_FOR(RawServoAuthorStyles)
DECL_OWNED_REF_TYPE_FOR(RawServoStyleSet)
DECL_NULLABLE_BORROWED_REF_TYPE_FOR(RawServoStyleSet)
DECL_NULLABLE_OWNED_REF_TYPE_FOR(StyleChildrenIterator)
DECL_OWNED_REF_TYPE_FOR(StyleChildrenIterator)
DECL_OWNED_REF_TYPE_FOR(ServoElementSnapshot)
DECL_OWNED_REF_TYPE_FOR(RawServoAnimationValueMap)

// We don't use BorrowedMut because the nodes may alias
// Servo itself doesn't directly read or mutate these;
// it only asks Gecko to do so. In case we wish to in
// the future, we should ensure that things being mutated
// are protected from noalias violations by a cell type
DECL_BORROWED_REF_TYPE_FOR(RawGeckoNode)
DECL_NULLABLE_BORROWED_REF_TYPE_FOR(RawGeckoNode)
DECL_BORROWED_REF_TYPE_FOR(RawGeckoElement)
DECL_NULLABLE_BORROWED_REF_TYPE_FOR(RawGeckoElement)
DECL_BORROWED_REF_TYPE_FOR(RawGeckoDocument)
DECL_NULLABLE_BORROWED_REF_TYPE_FOR(RawGeckoDocument)
DECL_BORROWED_REF_TYPE_FOR(RawGeckoXBLBinding)
DECL_NULLABLE_BORROWED_REF_TYPE_FOR(RawGeckoXBLBinding)
DECL_BORROWED_MUT_REF_TYPE_FOR(StyleChildrenIterator)
DECL_BORROWED_MUT_REF_TYPE_FOR(ServoElementSnapshot)
DECL_BORROWED_REF_TYPE_FOR(nsCSSValue)
DECL_BORROWED_MUT_REF_TYPE_FOR(nsCSSValue)
DECL_OWNED_REF_TYPE_FOR(RawGeckoPresContext)
DECL_BORROWED_REF_TYPE_FOR(RawGeckoPresContext)
DECL_BORROWED_MUT_REF_TYPE_FOR(RawGeckoServoAnimationValueList)
DECL_BORROWED_REF_TYPE_FOR(RawGeckoServoAnimationValueList)
DECL_BORROWED_MUT_REF_TYPE_FOR(RawGeckoKeyframeList)
DECL_BORROWED_REF_TYPE_FOR(RawGeckoKeyframeList)
DECL_BORROWED_MUT_REF_TYPE_FOR(RawGeckoPropertyValuePairList)
DECL_BORROWED_REF_TYPE_FOR(RawGeckoPropertyValuePairList)
DECL_BORROWED_MUT_REF_TYPE_FOR(RawGeckoComputedKeyframeValuesList)
DECL_BORROWED_MUT_REF_TYPE_FOR(RawGeckoStyleAnimationList)
DECL_BORROWED_REF_TYPE_FOR(RawGeckoStyleAnimationList)
DECL_BORROWED_MUT_REF_TYPE_FOR(nsTimingFunction)
DECL_BORROWED_REF_TYPE_FOR(nsTimingFunction)
DECL_BORROWED_MUT_REF_TYPE_FOR(RawGeckoFontFaceRuleList)
DECL_BORROWED_REF_TYPE_FOR(RawGeckoAnimationPropertySegment)
DECL_BORROWED_REF_TYPE_FOR(RawGeckoComputedTiming)
DECL_BORROWED_MUT_REF_TYPE_FOR(RawGeckoServoStyleRuleList)
DECL_BORROWED_MUT_REF_TYPE_FOR(nsCSSPropertyIDSet)
DECL_BORROWED_REF_TYPE_FOR(RawGeckoCSSPropertyIDList)
DECL_BORROWED_REF_TYPE_FOR(nsXBLBinding)
DECL_BORROWED_MUT_REF_TYPE_FOR(RawGeckoStyleChildrenIterator)
DECL_OWNED_REF_TYPE_FOR(RawServoSelectorList)
DECL_BORROWED_REF_TYPE_FOR(RawServoSelectorList)
DECL_OWNED_REF_TYPE_FOR(RawServoSourceSizeList)
DECL_BORROWED_REF_TYPE_FOR(RawServoSourceSizeList)
DECL_NULLABLE_BORROWED_REF_TYPE_FOR(RawServoSourceSizeList)
DECL_OWNED_REF_TYPE_FOR(StyleUseCounters)
DECL_NULLABLE_OWNED_REF_TYPE_FOR(StyleUseCounters)
DECL_BORROWED_REF_TYPE_FOR(StyleUseCounters)
DECL_NULLABLE_BORROWED_REF_TYPE_FOR(StyleUseCounters)

#undef DECL_ARC_REF_TYPE_FOR
#undef DECL_OWNED_REF_TYPE_FOR
#undef DECL_NULLABLE_OWNED_REF_TYPE_FOR
#undef DECL_BORROWED_REF_TYPE_FOR
#undef DECL_NULLABLE_BORROWED_REF_TYPE_FOR
#undef DECL_BORROWED_MUT_REF_TYPE_FOR
#undef DECL_NULLABLE_BORROWED_MUT_REF_TYPE_FOR

#define SERVO_ARC_TYPE(name_, type_)                 \
  extern "C" {                                       \
  void Servo_##name_##_AddRef(type_##Borrowed ptr);  \
  void Servo_##name_##_Release(type_##Borrowed ptr); \
  }                                                  \
  namespace mozilla {                                \
  template<> struct RefPtrTraits<type_> {            \
    static void AddRef(type_* aPtr) {                \
      Servo_##name_##_AddRef(aPtr);                  \
    }                                                \
    static void Release(type_* aPtr) {               \
      Servo_##name_##_Release(aPtr);                 \
    }                                                \
  };                                                 \
  }
#include "mozilla/ServoArcTypeList.h"
#undef SERVO_ARC_TYPE

#define DEFINE_BOXED_TYPE(name_, type_)                     \
  extern "C" void Servo_##name_##_Drop(type_##Owned ptr);   \
  namespace mozilla {                                       \
  template<>                                                \
  class DefaultDelete<type_>                                \
  {                                                         \
  public:                                                   \
    void operator()(type_* aPtr) const                      \
    {                                                       \
      Servo_##name_##_Drop(aPtr);                           \
    }                                                       \
  };                                                        \
  }

DEFINE_BOXED_TYPE(StyleSet, RawServoStyleSet);
DEFINE_BOXED_TYPE(AuthorStyles, RawServoAuthorStyles);
DEFINE_BOXED_TYPE(SelectorList, RawServoSelectorList);
DEFINE_BOXED_TYPE(SourceSizeList, RawServoSourceSizeList);
DEFINE_BOXED_TYPE(UseCounters, StyleUseCounters);

#undef DEFINE_BOXED_TYPE

#define DEFINE_ARRAY_TYPE_FOR(type_)                                \
  struct nsTArrayBorrowed_##type_ {                                 \
    nsTArray<type_>* mArray;                                        \
    MOZ_IMPLICIT nsTArrayBorrowed_##type_(nsTArray<type_>* aArray)  \
      : mArray(aArray) {}                                           \
  }
DEFINE_ARRAY_TYPE_FOR(uintptr_t);
#undef DEFINE_ARRAY_TYPE_FOR

#endif // mozilla_ServoBindingTypes_h
