# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this file,
# You can obtain one at http://mozilla.org/MPL/2.0/.

import runpy
import sys
import string
import argparse

class PropertyWrapper(object):
    __slots__ = ["index", "prop", "idlname"]

    def __init__(self, index, prop):
        self.index = index
        self.prop = prop
        if "CSSPropFlags::Internal" in prop.flags:
            self.idlname = None
        else:
            idl_name = prop.method
            if not idl_name.startswith("Moz"):
                idl_name = idl_name[0].lower() + idl_name[1:]
            self.idlname = idl_name

    def __getattr__(self, name):
        return getattr(self.prop, name)


def get_properties(dataFile):
    properties = runpy.run_path(dataFile)["data"]
    return [PropertyWrapper(i, p) for i, p in enumerate(properties)]

def generate_idl_names(properties):
    names = []
    for p in properties:
        if p.type() == "alias":
            continue
        if p.idlname is None:
            names.append("  nullptr,  // %s" % p.name)
        else:
            names.append('  "%s",' % p.idlname)
    return "\n".join(names)

def generate_assertions(properties):
    def enum(p):
        if p.type() == "alias":
            return "eCSSPropertyAlias_%s" % p.alias_id
        else:
            return "eCSSProperty_%s" % p.id
    msg = ('static_assert(%s == %d, "GenerateCSSPropsGenerated.py did not list '
           'properties in nsCSSPropertyID order");')
    return "\n".join(map(lambda p: msg % (enum(p), p.index), properties))

def generate_idl_name_positions(properties):
    # Skip aliases.
    ps = filter(lambda p: p.type() != "alias", properties)

    # Sort alphabetically by IDL name.
    ps = sorted(ps, key=lambda p: p.idlname)

    # Annotate entries with the sorted position.
    ps = [(p, position) for position, p in enumerate(ps)]

    # Sort back to nsCSSPropertyID order.
    ps = sorted(ps, key=lambda (p, position): p.index)

    return ",\n".join(map(lambda (p, position): "  %d" % position, ps))

def generate(output, cppTemplate, dataFile):
    cppFile = open(cppTemplate, "r")
    cppTemplate = cppFile.read()
    cppFile.close()

    properties = get_properties(dataFile)
    substitutions = {
        "idl_names": generate_idl_names(properties),
        "assertions": generate_assertions(properties),
        "idl_name_positions": generate_idl_name_positions(properties),
    }
    output.write("/* THIS IS AN AUTOGENERATED FILE.  DO NOT EDIT */\n\n" +
                 string.Template(cppTemplate).substitute(substitutions) + "\n")

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('cppTemplate', help='CSS property file template')
    parser.add_argument('preprocessorHeader', help='Header file to pass through the preprocessor')
    args = parser.parse_args()
    generate(sys.stdout, args.cppTemplate, args.preprocessorHeader)

if __name__ == '__main__':
    main()
