<?xml version="1.0"?>
<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<bindings id="browserToolbarBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="toolbar">
    <implementation>
      <constructor><![CDATA[
          let scope = {};
          ChromeUtils.import("resource:///modules/CustomizableUI.jsm", scope);
          let CustomizableUI = scope.CustomizableUI;

          // Searching for the toolbox palette in the toolbar binding because
          // toolbars are constructed first.
          let toolbox = this.closest("toolbox");
          if (toolbox && !toolbox.palette) {
            for (let node of toolbox.children) {
              if (node.localName == "toolbarpalette") {
                // Hold on to the palette but remove it from the document.
                toolbox.palette = node;
                toolbox.removeChild(node);
                break;
              }
            }
          }

          // pass the current set of children for comparison with placements:
          let children = Array.from(this.children)
                              .filter(node => node.getAttribute("skipintoolbarset") != "true" && node.id)
                              .map(node => node.id);
          CustomizableUI.registerToolbarNode(this, children);
      ]]></constructor>

      <property name="customizationTarget" readonly="true">
        <getter><![CDATA[
          if (this._customizationTarget)
            return this._customizationTarget;

          let id = this.getAttribute("customizationtarget");
          if (id)
            this._customizationTarget = document.getElementById(id);

          if (!this._customizationTarget)
            this._customizationTarget = this;

          return this._customizationTarget;
        ]]></getter>
      </property>

      <property name="currentSet">
        <getter><![CDATA[
          let currentWidgets = new Set();
          for (let node of this.customizationTarget.children) {
            let realNode = node.localName == "toolbarpaletteitem" ? node.firstElementChild : node;
            if (realNode.getAttribute("skipintoolbarset") != "true") {
              currentWidgets.add(realNode.id);
            }
          }
          if (this.getAttribute("overflowing") == "true") {
            let overflowTarget = this.getAttribute("overflowtarget");
            let overflowList = this.ownerDocument.getElementById(overflowTarget);
            for (let node of overflowList.children) {
              let realNode = node.localName == "toolbarpaletteitem" ? node.firstElementChild : node;
              if (realNode.getAttribute("skipintoolbarset") != "true") {
                currentWidgets.add(realNode.id);
              }
            }
          }
          let orderedPlacements = CustomizableUI.getWidgetIdsInArea(this.id);
          return orderedPlacements.filter(w => currentWidgets.has(w)).join(",");
        ]]></getter>
        <setter><![CDATA[
          // Get list of new and old ids:
          let newVal = (val || "").split(",").filter(x => x);
          let oldIds = CustomizableUI.getWidgetIdsInArea(this.id);

          // Get a list of items only in the new list
          let newIds = newVal.filter(id => !oldIds.includes(id));
          CustomizableUI.beginBatchUpdate();
          try {
            for (let newId of newIds) {
              oldIds = CustomizableUI.getWidgetIdsInArea(this.id);
              let nextId = newId;
              let pos;
              do {
                // Get the next item
                nextId = newVal[newVal.indexOf(nextId) + 1];
                // Figure out where it is in the old list
                pos = oldIds.indexOf(nextId);
                // If it's not in the old list, repeat:
              } while (pos == -1 && nextId);
              if (pos == -1) {
                pos = null; // We didn't find anything, insert at the end
              }
              CustomizableUI.addWidgetToArea(newId, this.id, pos);
            }

            let currentIds = this.currentSet.split(",");
            let removedIds = currentIds.filter(id => !newIds.includes(id) && !newVal.includes(id));
            for (let removedId of removedIds) {
              CustomizableUI.removeWidgetFromArea(removedId);
            }
          } finally {
            CustomizableUI.endBatchUpdate();
          }
        ]]></setter>
      </property>


    </implementation>
  </binding>

  <binding id="toolbar-menubar-stub">
    <implementation>
      <property name="currentSet" readonly="true">
        <getter><![CDATA[
          return this.getAttribute("defaultset");
        ]]></getter>
      </property>
    </implementation>
  </binding>

  <!-- The toolbar-drag binding is almost a verbatim copy of its toolkit counterpart,
       but it inherits from the customizableui's toolbar binding instead of toolkit's.
       This functionality will move into CustomizableUI proper as part of our move
       away from XBL. -->
  <binding id="toolbar-drag"
           extends="chrome://browser/content/customizableui/toolbar.xml#toolbar">
    <implementation>
      <field name="_dragBindingAlive">true</field>
      <constructor><![CDATA[
        if (!this._draggableStarted) {
          this._draggableStarted = true;
          try {
            let tmp = {};
            ChromeUtils.import("resource://gre/modules/WindowDraggingUtils.jsm", tmp);
            let draggableThis = new tmp.WindowDraggingElement(this);
            draggableThis.mouseDownCheck = function(e) {
              return this._dragBindingAlive;
            };
          } catch (e) {}
        }
      ]]></constructor>
    </implementation>
  </binding>

  <binding id="toolbarpaletteitem">
    <content>
      <xul:hbox class="toolbarpaletteitem-box">
        <children/>
      </xul:hbox>
      <xul:label class="toolbarpaletteitem-label" xbl:inherits="xbl:text=title"/>
    </content>
  </binding>
</bindings>
