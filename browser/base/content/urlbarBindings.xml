<?xml version="1.0"?>

# -*- Mode: HTML -*-
# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 1.1/GPL 2.0/LGPL 2.1
#
# The contents of this file are subject to the Mozilla Public License Version
# 1.1 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Original Code is mozilla.org browser.
#
# The Initial Developer of the Original Code is
# Simon Bünzli <zeniko@gmail.com>
# Portions created by the Initial Developer are Copyright (C) 2006
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Dão Gottwald <dao@design-noir.de>
#   Drew Willcoxon <adw@mozilla.com>
#
# Alternatively, the contents of this file may be used under the terms of
# either the GNU General Public License Version 2 or later (the "GPL"), or
# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
# in which case the provisions of the GPL or the LGPL are applicable instead
# of those above. If you wish to allow use of your version of this file only
# under the terms of either the GPL or the LGPL, and not to allow others to
# use your version of this file under the terms of the MPL, indicate your
# decision by deleting the provisions above and replace them with the notice
# and other provisions required by the GPL or the LGPL. If you do not delete
# the provisions above, a recipient may use your version of this file under
# the terms of any one of the MPL, the GPL or the LGPL.
#
# ***** END LICENSE BLOCK *****

<!DOCTYPE bindings [
<!ENTITY % notificationDTD SYSTEM "chrome://global/locale/notification.dtd">
%notificationDTD;
]>

<bindings id="urlbarBindings" xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="urlbar" extends="chrome://global/content/bindings/autocomplete.xml#autocomplete">

    <content sizetopopup="pref">
      <xul:hbox class="urlbar-frontcap-and-textbox" flex="1">
        <xul:hbox class="urlbar-frontcap">
          <children includes="image|deck|stack|box">
            <xul:image class="autocomplete-icon" allowevents="true"/>
          </children>
        </xul:hbox>
        <xul:stack anonid="stack" class="urlbar-stack" flex="1">
          <xul:scrollbox class="urlbar-over-link-layer" flex="1"
                         xbl:inherits="overlinkstate" align="center">
            <xul:label anonid="origin-label" class="urlbar-origin-label" flex="1"
                       crop="end"/>
            <xul:hbox anonid="over-link-box" class="urlbar-over-link-box"
                      xbl:inherits="overlinkstate" align="center">
              <xul:label anonid="over-link-host-label"
                         class="urlbar-over-link-host-label"/>
              <xul:label anonid="over-link-path-label"
                         class="urlbar-over-link-path-label" flex="1"/>
            </xul:hbox>
          </xul:scrollbox>
          <xul:hbox anonid="textbox-container"
                    class="autocomplete-textbox-container urlbar-textbox-container"
                    flex="1" xbl:inherits="focused,overlinkstate">
            <xul:hbox anonid="textbox-input-box"
                      class="textbox-input-box urlbar-input-box"
                      flex="1" xbl:inherits="tooltiptext=inputtooltiptext">
              <xul:hbox class="urlbar-textbox-container-children"
                        xbl:inherits="overlinkstate">
                <children/>
              </xul:hbox>
              <html:input anonid="input"
                          class="autocomplete-textbox urlbar-input textbox-input"
                          flex="1" allowevents="true"
                          xbl:inherits="tooltiptext=inputtooltiptext,onfocus,onblur,value,type,maxlength,disabled,size,readonly,placeholder,tabindex,accesskey"/>
            </xul:hbox>
            <xul:hbox class="urlbar-textbox-container-children"
                      xbl:inherits="overlinkstate">
              <children includes="hbox"/>
            </xul:hbox>
          </xul:hbox>
        </xul:stack>
        <xul:dropmarker anonid="historydropmarker"
                        class="autocomplete-history-dropmarker urlbar-history-dropmarker"
                        allowevents="true"
                        xbl:inherits="open,enablehistory,parentfocused=focused"/>
        <xul:popupset anonid="popupset"
                      class="autocomplete-result-popupset"/>
      </xul:hbox>
      <children includes="toolbarbutton"/>
    </content>

    <implementation implements="nsIObserver, nsIDOMEventListener">
      <constructor><![CDATA[
        this._prefs = Components.classes["@mozilla.org/preferences-service;1"]
                                .getService(Components.interfaces.nsIPrefService)
                                .getBranch("browser.urlbar.")
                                .QueryInterface(Components.interfaces.nsIPrefBranch2);

        this._prefs.addObserver("", this, false);
        this.clickSelectsAll = this._prefs.getBoolPref("clickSelectsAll");
        this.doubleClickSelectsAll = this._prefs.getBoolPref("doubleClickSelectsAll");
        this.completeDefaultIndex = this._prefs.getBoolPref("autoFill");
        this.timeout = this._prefs.getIntPref("delay");

        this._urlTooltip = document.getElementById("urlTooltip");

        this.inputField.controllers.insertControllerAt(0, this._copyCutController);
        this.inputField.addEventListener("mousedown", this, false);
        this.inputField.addEventListener("mousemove", this, false);
        this.inputField.addEventListener("mouseout", this, false);
        this.inputField.addEventListener("overflow", this, false);
        this.inputField.addEventListener("underflow", this, false);
        this._overLinkBox.addEventListener("transitionend", this, false);

        const kXULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
        var textBox = document.getAnonymousElementByAttribute(this,
                                                "anonid", "textbox-input-box");
        var cxmenu = document.getAnonymousElementByAttribute(textBox,
                                            "anonid", "input-box-contextmenu");
        var pasteAndGo;
        cxmenu.addEventListener("popupshowing", function() {
          if (!pasteAndGo)
            return;
          var controller = document.commandDispatcher.getControllerForCommand("cmd_paste");
          var enabled = controller.isCommandEnabled("cmd_paste");
          if (enabled)
            pasteAndGo.removeAttribute("disabled");
          else
            pasteAndGo.setAttribute("disabled", "true");
        }, false);

        var insertLocation = cxmenu.firstChild;
        while (insertLocation.nextSibling &&
               insertLocation.getAttribute("cmd") != "cmd_paste")
          insertLocation = insertLocation.nextSibling;
        if (insertLocation) {
          pasteAndGo = document.createElement("menuitem");
          let label = Services.strings.createBundle("chrome://browser/locale/browser.properties").
                                   GetStringFromName("pasteAndGo.label");
          pasteAndGo.setAttribute("label", label);
          pasteAndGo.setAttribute("anonid", "paste-and-go");
          pasteAndGo.setAttribute("oncommand",
              "gURLBar.select(); goDoCommand('cmd_paste'); gURLBar.handleCommand();");
          cxmenu.insertBefore(pasteAndGo, insertLocation.nextSibling);
        }
      ]]></constructor>

      <destructor><![CDATA[
        this._prefs.removeObserver("", this);
        this._prefs = null;
        this.inputField.controllers.removeController(this._copyCutController);
        this.inputField.removeEventListener("mousedown", this, false);
        this.inputField.removeEventListener("mousemove", this, false);
        this.inputField.removeEventListener("mouseout", this, false);
        this.inputField.removeEventListener("overflow", this, false);
        this.inputField.removeEventListener("underflow", this, false);
        this._overLinkBox.removeEventListener("transitionend", this, false);
      ]]></destructor>

      <field name="_value"></field>

      <!--
        onBeforeValueGet is called by the base-binding's .value getter.
        It can return an object with a "value" property, to override the
        return value of the getter.
      -->
      <method name="onBeforeValueGet">
        <body><![CDATA[
          if (this.hasAttribute("actiontype"))
            return {value: this._value};
          return null;
        ]]></body>
      </method>

      <!--
        onBeforeValueSet is called by the base-binding's .value setter.
        It should return the value that the setter should use.
      -->
      <method name="onBeforeValueSet">
        <parameter name="aValue"/>
        <body><![CDATA[
          this._hideOverLink();
          this._value = aValue;
          var returnValue = aValue;
          var action = this._parseActionUrl(aValue);
          if (action) {
            returnValue = action.param;
            this.setAttribute("actiontype", action.type);
          } else {
            this.removeAttribute("actiontype");
          }
          return returnValue;
        ]]></body>
      </method>

      <method name="handleRevert">
        <body><![CDATA[
          var isScrolling = this.popupOpen;

          gBrowser.userTypedValue = null;

          // don't revert to last valid url unless page is NOT loading
          // and user is NOT key-scrolling through autocomplete list
          if (!XULBrowserWindow.isBusy && !isScrolling) {
            URLBarSetURI();

            // If the value isn't empty and the urlbar has focus, select the value.
            if (this.value && this.hasAttribute("focused"))
              this.select();
          }

          // tell widget to revert to last typed text only if the user
          // was scrolling when they hit escape
          return !isScrolling;
        ]]></body>
      </method>

      <method name="handleCommand">
        <parameter name="aTriggeringEvent"/>
        <body><![CDATA[
          if (aTriggeringEvent instanceof MouseEvent && aTriggeringEvent.button == 2)
            return; // Do nothing for right clicks

          var url = this.value;
          var postData = null;

          var action = this._parseActionUrl(url);
          if (action) {
            url = action.param;
            if (this.hasAttribute("actiontype")) {
              if (action.type == "switchtab") {
                this.handleRevert();
                let prevTab = gBrowser.selectedTab;
                if (switchToTabHavingURI(url) &&
                    isTabEmpty(prevTab))
                  gBrowser.removeTab(prevTab);
              }
              return;
            }
          }
          else {
            [url, postData] = this._canonizeURL(aTriggeringEvent);
            if (!url)
              return;
          }

          this.value = url;
          gBrowser.userTypedValue = url;
          try {
            addToUrlbarHistory(url);
          } catch (ex) {
            // Things may go wrong when adding url to session history,
            // but don't let that interfere with the loading of the url.
            Cu.reportError(ex);
          }

          if (aTriggeringEvent instanceof MouseEvent) {
            // We have a mouse event (from the go button), so use the standard
            // UI link behaviors
            let where = whereToOpenLink(aTriggeringEvent, false, false);
            if (where != "current") {
              this.handleRevert();
              content.focus();
            }
            openUILinkIn(url, where,
                        { allowThirdPartyFixup: true, postData: postData });
            return;
          }

          if (aTriggeringEvent &&
              aTriggeringEvent.altKey &&
              !isTabEmpty(gBrowser.selectedTab)) {
            this.handleRevert();
            content.focus();
            gBrowser.loadOneTab(url, {
                                postData: postData,
                                inBackground: false,
                                allowThirdPartyFixup: true});
            aTriggeringEvent.preventDefault();
            aTriggeringEvent.stopPropagation();
          }
          else
            loadURI(url, null, postData, true /* allow third party fixup */);

          gBrowser.selectedBrowser.focus();
        ]]></body>
      </method>

      <method name="_canonizeURL">
        <parameter name="aTriggeringEvent"/>
        <body><![CDATA[
          var url = this.value;
          if (!url)
            return ["", null];

          // Only add the suffix when the URL bar value isn't already "URL-like",
          // and only if we get a keyboard event, to match user expectations.
          if (!/^\s*(www|https?)\b|\/\s*$/i.test(url) &&
              (aTriggeringEvent instanceof KeyEvent)) {
#ifdef XP_MACOSX
            let accel = aTriggeringEvent.metaKey;
#else
            let accel = aTriggeringEvent.ctrlKey;
#endif
            let shift = aTriggeringEvent.shiftKey;

            let suffix = "";

            switch (true) {
              case (accel && shift):
                suffix = ".org/";
                break;
              case (shift):
                suffix = ".net/";
                break;
              case (accel):
                try {
                  suffix = gPrefService.getCharPref("browser.fixup.alternate.suffix");
                  if (suffix.charAt(suffix.length - 1) != "/")
                    suffix += "/";
                } catch(e) {
                  suffix = ".com/";
                }
                break;
            }

            if (suffix) {
              // trim leading/trailing spaces (bug 233205)
              url = url.trim();

              // Tack www. and suffix on.  If user has appended directories, insert
              // suffix before them (bug 279035).  Be careful not to get two slashes.
              // Also, don't add the suffix if it's in the original url (bug 233853).

              let firstSlash = url.indexOf("/");
              let existingSuffix = url.indexOf(suffix.substring(0, suffix.length - 1));

              // * Logic for slash and existing suffix (example)
              // No slash, no suffix: Add suffix (mozilla)
              // No slash, yes suffix: Add slash (mozilla.com)
              // Yes slash, no suffix: Insert suffix (mozilla/stuff)
              // Yes slash, suffix before slash: Do nothing (mozilla.com/stuff)
              // Yes slash, suffix after slash: Insert suffix (mozilla/?stuff=.com)

              if (firstSlash >= 0) {
                if (existingSuffix == -1 || existingSuffix > firstSlash)
                  url = url.substring(0, firstSlash) + suffix +
                        url.substring(firstSlash + 1);
              } else
                url = url + (existingSuffix == -1 ? suffix : "/");

              url = "http://www." + url;
            }
          }

          var postData = {};
          url = getShortcutOrURI(url, postData);

          return [url, postData.value];
        ]]></body>
      </method>

      <field name="_contentIsCropped">false</field>

      <method name="_initURLTooltip">
        <body><![CDATA[
          if (this.focused || !this._contentIsCropped)
            return;
          if (this._tooltipTimer)
            clearTimeout(this._tooltipTimer);
          this._tooltipTimer = setTimeout(function (self) {
            self._tooltipTimer = 0;
            var label = self._urlTooltip.firstChild;
            label.value = self.value;
            var bO = self.boxObject;
            self._urlTooltip.maxWidth = bO.width;
            self._urlTooltip.showPopup(self, bO.screenX, bO.screenY + bO.height, "tooltip");
          }, 700, this);
        ]]></body>
      </method>

      <method name="_hideURLTooltip">
        <body><![CDATA[
          if (this._tooltipTimer) {
            clearTimeout(this._tooltipTimer);
            this._tooltipTimer = 0;
          }
          this._urlTooltip.hidePopup();
        ]]></body>
      </method>

      <method name="onDragOver">
        <parameter name="aEvent"/>
        <body>
          var types = aEvent.dataTransfer.types;
          if (types.contains("application/x-moz-file") ||
              types.contains("text/x-moz-url") ||
              types.contains("text/uri-list") ||
              types.contains("text/unicode"))
            aEvent.preventDefault();
        </body>
      </method>

      <method name="onDrop">
        <parameter name="aEvent"/>
        <body><![CDATA[
          let url = browserDragAndDrop.drop(aEvent, { })

          // The URL bar automatically handles inputs with newline characters,
          // so we can get away with treating text/x-moz-url flavours as text/plain.
          if (url) {
            aEvent.preventDefault();
            this.value = url;
            SetPageProxyState("invalid");
            try {
              urlSecurityCheck(this.value,
                               gBrowser.contentPrincipal,
                               Ci.nsIScriptSecurityManager.DISALLOW_INHERIT_PRINCIPAL);
            } catch (ex) {
              return;
            }
            this.handleCommand();
          }
        ]]></body>
      </method>

      <method name="_getSelectedValueForClipboard">
        <body><![CDATA[
          // Grab the actual input field's value, not our value, which could include moz-action:
          var inputVal = this.inputField.value;
          var val = inputVal.substring(this.selectionStart, this.selectionEnd);

          // If the entire value is selected and it's a valid non-javascript,
          // non-data URI, encode it.
          if (val == inputVal &&
              this.getAttribute("pageproxystate") == "valid") {
            let uri;
            try {
              uri = makeURI(val);
            } catch (e) {}

            if (uri && !uri.schemeIs("javascript") && !uri.schemeIs("data")) {
              val = uri.spec;

              // Parentheses are known to confuse third-party applications (bug 458565).
              val = val.replace(/[()]/g, function (c) escape(c));
            }
          }

          return val;
        ]]></body>
      </method>

      <field name="_copyCutController"><![CDATA[
        ({
          urlbar: this,
          doCommand: function(aCommand) {
            var urlbar = this.urlbar;
            var val = urlbar._getSelectedValueForClipboard();
            if (!val)
              return;

            if (aCommand == "cmd_cut" && this.isCommandEnabled(aCommand)) {
              let start = urlbar.selectionStart;
              let end = urlbar.selectionEnd;
              // This should reset any "moz-action:" prefix.
              urlbar.value = urlbar.inputField.value.substring(0, start) +
                             urlbar.inputField.value.substring(end);
              urlbar.selectionStart = urlbar.selectionEnd = start;
              SetPageProxyState("invalid");
            }

            Cc["@mozilla.org/widget/clipboardhelper;1"]
              .getService(Ci.nsIClipboardHelper)
              .copyString(val);
          },
          supportsCommand: function(aCommand) {
            switch (aCommand) {
              case "cmd_copy":
              case "cmd_cut":
                return true;
            }
            return false;
          },
          isCommandEnabled: function(aCommand) {
            return this.supportsCommand(aCommand) &&
                   (aCommand != "cmd_cut" || !this.urlbar.readOnly) &&
                   this.urlbar.selectionStart < this.urlbar.selectionEnd;
          },
          onEvent: function(aEventName) {}
        })
      ]]></field>

      <method name="observe">
        <parameter name="aSubject"/>
        <parameter name="aTopic"/>
        <parameter name="aData"/>
        <body><![CDATA[
          if (aTopic == "nsPref:changed") {
            switch (aData) {
              case "clickSelectsAll":
              case "doubleClickSelectsAll":
                this[aData] = this._prefs.getBoolPref(aData);
                break;
              case "autoFill":
                this.completeDefaultIndex = this._prefs.getBoolPref(aData);
                break;
              case "delay":
                this.timeout = this._prefs.getIntPref(aData);
                break;
            }
          }
        ]]></body>
      </method>

      <method name="handleEvent">
        <parameter name="aEvent"/>
        <body><![CDATA[
          switch (aEvent.type) {
            case "mousedown":
              if (this.doubleClickSelectsAll &&
                  aEvent.button == 0 && aEvent.detail == 2) {
                this.editor.selectAll();
                aEvent.preventDefault();
              }
              break;
            case "mousemove":
              this._initURLTooltip();
              break;
            case "mouseout":
              this._hideURLTooltip();
              break;
            case "overflow":
              this._contentIsCropped = true;
              break;
            case "underflow":
              this._contentIsCropped = false;
              this._hideURLTooltip();
              break;
            case "transitionend":
              if (aEvent.target == this._overLinkBox &&
                  aEvent.propertyName == "opacity") {
                this._overLinkTransitioning = false;
              }
              break;
          }
        ]]></body>
      </method>

      <property name="textValue"
                onget="return this.value;">
        <setter>
          <![CDATA[
          try {
            val = losslessDecodeURI(makeURI(val));
          } catch (ex) { }
          this.value = val;

          // Completing a result should simulate the user typing the result, so
          // fire an input event.
          let evt = document.createEvent("UIEvents");
          evt.initUIEvent("input", true, false, window, 0);
          this.mIgnoreInput = true;
          this.dispatchEvent(evt);
          this.mIgnoreInput = false;

          return this.value;
          ]]>
        </setter>
      </property>

      <method name="_parseActionUrl">
        <parameter name="aUrl"/>
        <body><![CDATA[
          if (!/^moz-action:/.test(aUrl))
            return null;

          // url is in the format moz-action:ACTION,PARAM
          let [, action, param] = aUrl.match(/^moz-action:([^,]+),(.*)$/);
          return {type: action, param: param};
        ]]></body>
      </method>

      <field name="_stack" readonly="true"><![CDATA[
        document.getAnonymousElementByAttribute(this, "anonid", "stack");
      ]]></field>

      <field name="_originLabel" readonly="true"><![CDATA[
        document.getAnonymousElementByAttribute(this, "anonid", "origin-label");
      ]]></field>

      <field name="_overLinkBox" readonly="true"><![CDATA[
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "over-link-box");
      ]]></field>

      <field name="_overLinkHostLabel" readonly="true"><![CDATA[
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "over-link-host-label");
      ]]></field>

      <field name="_overLinkPathLabel" readonly="true"><![CDATA[
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "over-link-path-label");
      ]]></field>

      <field name="_textboxContainer" readonly="true"><![CDATA[
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "textbox-container");
      ]]></field>

      <field name="_overLinkIntervalDelay" readonly="true"><![CDATA[
        100
      ]]></field>

      <field name="_overLinkInterval"><![CDATA[
        null
      ]]></field>

      <method name="setOverLink">
        <parameter name="aURL"/>
        <body><![CDATA[
          // NOTE: This method is called many times in a row very quickly when
          // the user mouses over a bookmarks menu, tabs menu, or long list of
          // links in a page, or leaves the cursor over a page with many links
          // while scrolling.  Therefore it's important that it be fast.  Don't
          // regress performance when you modify it!

          // Hide the over-link immediately if necessary.
          if ((!aURL && (XULBrowserWindow.hideOverLinkImmediately ||
                         this._hideOverLinkImmediately)) ||
              this.focused) {
            this._clearOverLinkInterval();
            this._setOverLinkState(null);
            return;
          }

          // Update and show it immediately if it's in transition.
          if (aURL && this._overLinkTransitioning) {
            this._clearOverLinkInterval();
            this._updateOverLink(aURL);
            this._setOverLinkState("showing");
            return;
          }

          this._overLinkURL = aURL;
          this._seenNewOverLink = true;

          // If the user is continually mousing over links, make this method
          // basically a no-op.
          if (this._overLinkInterval)
            return;

          // Otherwise, the user has just moused over or focused a single link.
          // Start the interval and signal that we should potentially show the
          // over-link the first time it fires by unsetting _seenNewOverLink.
          this._seenNewOverLink = false;
          this._overLinkInterval = setInterval(this._overLinkIntervalCallback,
                                               this._overLinkIntervalDelay,
                                               this);
        ]]></body>
      </method>

      <method name="_overLinkIntervalCallback">
        <parameter name="self"/>
        <body><![CDATA[
          // If the user is still mousing over links, bail out early.
          if (self._seenNewOverLink) {
            self._seenNewOverLink = false;
            return;
          }

          // Otherwise, the user has stopped over a link.  Clear the interval
          // and update the over-link.
          self._clearOverLinkInterval();
          if (self._overLinkURL) {
            self._updateOverLink(self._overLinkURL);
            self._setOverLinkState("fade-in");
          }
          else {
            self._setOverLinkState("fade-out");
          }
        ]]></body>
      </method>

      <method name="_hideOverLink">
        <body><![CDATA[
          this._hideOverLinkImmediately = true;
          this.setOverLink("");
          this._hideOverLinkImmediately = false;
        ]]></body>
      </method>

      <method name="_clearOverLinkInterval">
        <body><![CDATA[
          if (this._overLinkInterval) {
            clearInterval(this._overLinkInterval);
            this._overLinkInterval = null;
          }
        ]]></body>
      </method>

      <method name="_setOverLinkState">
        <parameter name="aVal"/>
        <body><![CDATA[
          switch (aVal) {
          case "fade-in":
            var style = window.getComputedStyle(this._overLinkBox);
            this._overLinkTransitioning = style.opacity != 1;
            this.setAttribute("overlinkstate", aVal);
            break;
          case "fade-out":
            style = window.getComputedStyle(this._overLinkBox);
            this._overLinkTransitioning = style.opacity != 0;
            this.setAttribute("overlinkstate", aVal);
            break;
          case "showing":
            this._overLinkTransitioning = false;
            this.setAttribute("overlinkstate", aVal);
            break;
          default:
            this._overLinkTransitioning = false;
            this.removeAttribute("overlinkstate");
            break;
          }
        ]]></body>
      </method>

      <method name="_updateOverLink">
        <parameter name="aURL"/>
        <body><![CDATA[
          // Get the width of the bar before we go modifying it.
          var barWidth = this._stack.boxObject.width;

          // Determine the pre-path and path of the over-link.  Include the
          // path's leading slash in the pre-path so that if the path is
          // truncated its leading slash is visible.
          var re = new RegExp("^([a-z0-9+.-]+://[^/]+/)(.*)$");
          var match = re.exec(aURL);
          var host = match ? match[1] : "";
          var path = match ? match[2] : aURL;

          var overLink = this._overLinkBox;
          var overLinkHost = this._overLinkHostLabel;
          var overLinkPath = this._overLinkPathLabel;

          overLinkHost.value = host;
          overLinkPath.value = path;

          // Remove restrictions on the over-link's width.
          overLinkHost.flex = 0;
          overLinkHost.crop = "none";
          overLinkPath.crop = "none";
          overLink.style.minWidth = "";
          overLink.style.maxWidth = "";

          // Cap the width of the over-link to 2/3 of the location bar's.
          var maxWidth = barWidth * 0.67;
          var overLinkWidth = overLinkHost.boxObject.width +
                              overLinkPath.boxObject.width;
          if (overLinkWidth > maxWidth) {
            // If the host is wider than the cap and therefore the path is not
            // visible at all, crop the host at the end.
            if (overLinkHost.boxObject.width > maxWidth) {
              overLinkHost.flex = 1;
              overLinkHost.crop = "end";
            }
            overLinkPath.crop = host ? "start" : "end";
            overLink.style.minWidth = maxWidth + "px";
            overLink.style.maxWidth = maxWidth + "px";
          }

          var action = this._parseActionUrl(this._value);
          this._originLabel.value = action ? action.param : this._value;
        ]]></body>
      </method>

      <field name="_numNoActionsKeys"><![CDATA[
        0
      ]]></field>

      <method name="_clearNoActions">
        <parameter name="aURL"/>
        <body><![CDATA[
          this._numNoActionsKeys = 0;
          this.popup.removeAttribute("noactions");
          let action = this._parseActionUrl(this._value);
          if (action)
            this.setAttribute("actiontype", action.type);
        ]]></body>
      </method>
    </implementation>

    <handlers>
      <handler event="keydown"><![CDATA[
        if ((event.keyCode === KeyEvent.DOM_VK_ALT ||
             event.keyCode === KeyEvent.DOM_VK_SHIFT) &&
            this.popup.selectedIndex >= 0) {
          this._numNoActionsKeys++;
          this.popup.setAttribute("noactions", "true");
          this.removeAttribute("actiontype");
        }
      ]]></handler>

      <handler event="keyup"><![CDATA[
        if ((event.keyCode === KeyEvent.DOM_VK_ALT ||
             event.keyCode === KeyEvent.DOM_VK_SHIFT) &&
            this._numNoActionsKeys > 0) {
          this._numNoActionsKeys--;
          if (this._numNoActionsKeys == 0)
            this._clearNoActions();
        }
      ]]></handler>

      <handler event="blur"><![CDATA[
        this._clearNoActions();
      ]]></handler>

      <handler event="draggesture" phase="capturing"><![CDATA[
        // TODO: This should use dragstart but editor code is still using
        //       the old drag & drop APIs, so we have to handle draggesture.
        //       This can be changed once editor code is updated to the new API.
        //       See bug 499008 for details.

        // Drag only if the gesture starts from the input field.
        if (event.originalTarget != this.inputField)
          return;

        // Drag only if the entire value is selected and it's a valid URI.
        var isFullSelection = this.selectionStart == 0 &&
                              this.selectionEnd == this.textLength;
        if (!isFullSelection ||
            this.getAttribute("pageproxystate") != "valid")
          return;

        var urlString = content.location.href;
        var title = content.document.title || urlString;
        var htmlString = "<a href=\"" + urlString + "\">" + urlString + "</a>";

        var dt = event.dataTransfer;
        dt.setData("text/x-moz-url", urlString + "\n" + title);
        dt.setData("text/unicode", urlString);
        dt.setData("text/html", htmlString);

        dt.effectAllowed = "copyLink";
        event.stopPropagation();
      ]]></handler>

      <handler event="focus" phase="capturing"><![CDATA[
        this._hideOverLink();
        this._hideURLTooltip();
      ]]></handler>

      <handler event="dragover" phase="capturing" action="this.onDragOver(event, this);"/>
      <handler event="drop" phase="capturing" action="this.onDrop(event, this);"/>
      <handler event="select"><![CDATA[
        if (!Cc["@mozilla.org/widget/clipboard;1"]
               .getService(Ci.nsIClipboard)
               .supportsSelectionClipboard())
          return;

        var val = this._getSelectedValueForClipboard();
        if (!val)
          return;

        Cc["@mozilla.org/widget/clipboardhelper;1"]
          .getService(Ci.nsIClipboardHelper)
          .copyStringToClipboard(val, Ci.nsIClipboard.kSelectionClipboard);
      ]]></handler>
    </handlers>

  </binding>

  <!-- Note: this binding is applied to the autocomplete popup used in the Search bar and in web page content -->
  <binding id="browser-autocomplete-result-popup" extends="chrome://global/content/bindings/autocomplete.xml#autocomplete-result-popup">
    <implementation>
      <method name="openAutocompletePopup">
        <parameter name="aInput"/>
        <parameter name="aElement"/>
        <body>
          <![CDATA[
          // initially the panel is hidden
          // to avoid impacting startup / new window performance
          aInput.popup.hidden = false;

          // this method is defined on the base binding
          this._openAutocompletePopup(aInput, aElement);
        ]]></body>
      </method>

      <method name="onPopupClick">
        <parameter name="aEvent"/>
        <body><![CDATA[
          // Ignore all right-clicks
          if (aEvent.button == 2)
            return;

          var controller = this.view.QueryInterface(Components.interfaces.nsIAutoCompleteController);

          // Check for unmodified left-click, and use default behavior
          if (aEvent.button == 0 && !aEvent.shiftKey && !aEvent.ctrlKey &&
              !aEvent.altKey && !aEvent.metaKey) {
            controller.handleEnter(true);
            return;
          }

          // Check for middle-click or modified clicks on the search bar
          var searchBar = BrowserSearch.searchBar;
          if (searchBar && searchBar.textbox == this.mInput) {
            // Handle search bar popup clicks
            var search = controller.getValueAt(this.selectedIndex);

            // close the autocomplete popup and revert the entered search term
            this.closePopup();
            controller.handleEscape();

            // Fill in the search bar's value
            searchBar.value = search;

            // open the search results according to the clicking subtlety
            var where = whereToOpenLink(aEvent, false, true);
            searchBar.doSearch(search, where);
          }
          ]]></body>
        </method>
      </implementation>
    </binding>

    <binding id="urlbar-rich-result-popup" extends="chrome://global/content/bindings/autocomplete.xml#autocomplete-rich-result-popup">
      <implementation>
      <field name="_maxResults">0</field>

      <field name="_bundle" readonly="true">
        Cc["@mozilla.org/intl/stringbundle;1"].
          getService(Ci.nsIStringBundleService).
          createBundle("chrome://browser/locale/places/places.properties");
      </field>

      <property name="maxResults" readonly="true">
        <getter>
          <![CDATA[
            if (!this._maxResults) {
              var prefService =
                Components.classes["@mozilla.org/preferences-service;1"]
                          .getService(Components.interfaces.nsIPrefBranch);
              this._maxResults = prefService.getIntPref("browser.urlbar.maxRichResults");
            }
            return this._maxResults;
          ]]>
        </getter>
      </property>

      <method name="openAutocompletePopup">
        <parameter name="aInput"/>
        <parameter name="aElement"/>
        <body>
          <![CDATA[
          // initially the panel is hidden
          // to avoid impacting startup / new window performance
          aInput.popup.hidden = false;

          // this method is defined on the base binding
          this._openAutocompletePopup(aInput, aElement);
        ]]></body>
      </method>

      <method name="onPopupClick">
        <parameter name="aEvent"/>
        <body>
          <![CDATA[
          // Ignore right-clicks
          if (aEvent.button == 2)
            return;

          var controller = this.view.QueryInterface(Components.interfaces.nsIAutoCompleteController);

          // Check for unmodified left-click, and use default behavior
          if (aEvent.button == 0 && !aEvent.shiftKey && !aEvent.ctrlKey &&
              !aEvent.altKey && !aEvent.metaKey) {
            controller.handleEnter(true);
            return;
          }

          // Check for middle-click or modified clicks on the URL bar
          if (gURLBar && this.mInput == gURLBar) {
            var url = controller.getValueAt(this.selectedIndex);

            // close the autocomplete popup and revert the entered address
            this.closePopup();
            controller.handleEscape();

            // Check if this is meant to be an action
            let action = this.mInput._parseActionUrl(url);
            if (action) {
              if (action.type == "switchtab")
                url = action.param;
              else
                return;
            }

            // respect the usual clicking subtleties
            openUILink(url, aEvent);
          }
        ]]>
        </body>
      </method>

      <method name="createResultLabel">
        <parameter name="aTitle"/>
        <parameter name="aUrl"/>
        <parameter name="aType"/>
        <body>
          <![CDATA[
            var label = aTitle + " " + aUrl;
            // convert aType (ex: "ac-result-type-<aType>") to text to be spoke aloud
            // by screen readers.  convert "tag" and "bookmark" to the localized versions,
            // but don't do anything for "favicon" (the default)
            if (aType != "favicon") {
              label += " " + this._bundle.GetStringFromName(aType + "ResultLabel");
            }
            return label;
          ]]>
        </body>
      </method>

    </implementation>
  </binding>

  <binding id="geolocation-notification" extends="chrome://global/content/bindings/notification.xml#popup-notification">
    <content align="start">
      <xul:image class="popup-notification-icon"
                 xbl:inherits="popupid"/>
      <xul:vbox flex="1">
        <xul:description class="popup-notification-description"
                         xbl:inherits="xbl:text=label"/>
        <xul:spacer flex="1"/>
        <xul:hbox pack="end">
          <xul:label anonid="learnmore" class="text-link geolocation-text-link"/>
          <xul:spacer flex="1"/>
          <xul:button anonid="button"
                      type="menu-button"
                      class="popup-notification-menubutton"
                      xbl:inherits="oncommand=buttoncommand,label=buttonlabel,accesskey=buttonaccesskey">
            <xul:menupopup anonid="menupopup"
                           xbl:inherits="oncommand=menucommand">
              <children/>
              <xul:menuitem class="menuitem-iconic popup-notification-closeitem"
                            label="&closeNotificationItem.label;"
                            xbl:inherits="oncommand=closeitemcommand"/>
            </xul:menupopup>
          </xul:button>
        </xul:hbox>
      </xul:vbox>
      <xul:vbox pack="start">
        <xul:toolbarbutton anonid="closebutton"
                           class="messageCloseButton popup-notification-closebutton"
                           xbl:inherits="oncommand=closebuttoncommand"
                           tooltiptext="&closeNotification.tooltip;"/>
      </xul:vbox>
    </content>
    <implementation>  
      <constructor><![CDATA[
        let link = document.getAnonymousElementByAttribute(this, "anonid", "learnmore");
        link.value = gNavigatorBundle.getString("geolocation.learnMore");
        
        let formatter = Cc["@mozilla.org/toolkit/URLFormatterService;1"].getService(Ci.nsIURLFormatter);
        link.href = formatter.formatURLPref("browser.geolocation.warning.infoURL");
      ]]></constructor>
    </implementation>
  </binding>

  <binding id="addon-progress-notification" extends="chrome://global/content/bindings/notification.xml#popup-notification">
    <content align="start">
      <xul:image class="popup-notification-icon"
                 xbl:inherits="popupid"/>
      <xul:vbox flex="1">
        <xul:description class="popup-notification-description addon-progress-description"
                         xbl:inherits="xbl:text=label"/>
        <xul:spacer flex="1"/>
        <xul:hbox align="center">
          <xul:progressmeter anonid="progressmeter" flex="1" mode="undetermined" class="popup-progress-meter"/>
          <xul:button anonid="cancel" class="popup-progress-cancel" oncommand="document.getBindingParent(this).cancel()"/>
        </xul:hbox>
        <xul:label anonid="progresstext" class="popup-progress-label"/>
        <xul:hbox pack="end">
          <xul:button anonid="button"
                      class="popup-notification-menubutton"
                      type="menu-button"
                      xbl:inherits="oncommand=buttoncommand,label=buttonlabel,accesskey=buttonaccesskey">
            <xul:menupopup anonid="menupopup"
                           xbl:inherits="oncommand=menucommand">
              <children/>
              <xul:menuitem class="menuitem-iconic popup-notification-closeitem"
                            label="&closeNotificationItem.label;"
                            xbl:inherits="oncommand=closeitemcommand"/>
            </xul:menupopup>
          </xul:button>
        </xul:hbox>
      </xul:vbox>
      <xul:vbox pack="start">
        <xul:toolbarbutton anonid="closebutton"
                           class="messageCloseButton popup-notification-closebutton"
                           xbl:inherits="oncommand=closebuttoncommand"
                           tooltiptext="&closeNotification.tooltip;"/>
      </xul:vbox>
    </content>
    <implementation>
      <constructor><![CDATA[
        this.cancelbtn.setAttribute("tooltiptext", gNavigatorBundle.getString("addonDownloadCancelTooltip"));

        this.notification.options.installs.forEach(function(aInstall) {
          aInstall.addListener(this);
        }, this);

        // Calling updateProgress can sometimes cause this notification to be
        // removed in the middle of refreshing the notification panel which
        // makes the panel get refreshed again. Just initialise to the
        // undetermined state.
        this.setProgress(0, -1);
      ]]></constructor>

      <destructor><![CDATA[
        this.destroy();
      ]]></destructor>

      <field name="progressmeter" readonly="true">
        document.getAnonymousElementByAttribute(this, "anonid", "progressmeter");
      </field>
      <field name="progresstext" readonly="true">
        document.getAnonymousElementByAttribute(this, "anonid", "progresstext");
      </field>
      <field name="cancelbtn" readonly="true">
        document.getAnonymousElementByAttribute(this, "anonid", "cancel");
      </field>
      <field name="DownloadUtils" readonly="true">
        let utils = {};
        Components.utils.import("resource://gre/modules/DownloadUtils.jsm", utils);
        utils.DownloadUtils;
      </field>

      <method name="destroy">
        <body><![CDATA[
          this.notification.options.installs.forEach(function(aInstall) {
            aInstall.removeListener(this);
          }, this);
        ]]></body>
      </method>

      <method name="setProgress">
        <parameter name="aProgress"/>
        <parameter name="aMaxProgress"/>
        <body><![CDATA[
          if (aMaxProgress == -1) {
            this.progressmeter.mode = "undetermined";
          }
          else {
            this.progressmeter.mode = "determined";
            this.progressmeter.value = (aProgress * 100) / aMaxProgress;
          }

          let now = Date.now();

          if (!this.notification.lastUpdate) {
            this.notification.lastUpdate = now;
            this.notification.lastProgress = aProgress;
            return;
          }

          let delta = now - this.notification.lastUpdate;
          if ((delta < 400) && (aProgress < aMaxProgress))
            return;

          delta /= 1000;

          // This code is taken from nsDownloadManager.cpp
          let speed = (aProgress - this.notification.lastProgress) / delta;
          if (this.notification.speed)
            speed = speed * 0.9 + this.notification.speed * 0.1;

          this.notification.lastUpdate = now;
          this.notification.lastProgress = aProgress;
          this.notification.speed = speed;

          let status = null;
          [status, this.notification.last] = this.DownloadUtils.getDownloadStatus(aProgress, aMaxProgress, speed, this.notification.last);
          this.progresstext.value = status;
        ]]></body>
      </method>

      <method name="cancel">
        <body><![CDATA[
          // Cache these as cancelling the installs will remove this
          // notification which will drop these references
          let browser = this.notification.browser;
          let contentWindow = this.notification.options.contentWindow;
          let sourceURI = this.notification.options.sourceURI;

          let installs = this.notification.options.installs;
          installs.forEach(function(aInstall) {
            try {
              aInstall.cancel();
            }
            catch (e) {
              // Cancel will throw if the download has already failed
            }
          }, this);

          let anchorID = "addons-notification-icon";
          let notificationID = "addon-install-cancelled";
          let messageString = gNavigatorBundle.getString("addonDownloadCancelled");
          messageString = PluralForm.get(installs.length, messageString);
          let buttonText = gNavigatorBundle.getString("addonDownloadRestart");
          buttonText = PluralForm.get(installs.length, buttonText);

          let action = {
            label: buttonText,
            accessKey: gNavigatorBundle.getString("addonDownloadRestart.accessKey"),
            callback: function() {
              let weblistener = Cc["@mozilla.org/addons/web-install-listener;1"].
                                getService(Ci.amIWebInstallListener);
              if (weblistener.onWebInstallRequested(contentWindow, sourceURI,
                                                    installs, installs.length)) {
                installs.forEach(function(aInstall) {
                  aInstall.install();
                });
              }
            }
          };

          PopupNotifications.show(browser, notificationID, messageString,
                                  anchorID, action);
        ]]></body>
      </method>

      <method name="updateProgress">
        <body><![CDATA[
          let downloadingCount = 0;
          let progress = 0;
          let maxProgress = 0;

          this.notification.options.installs.forEach(function(aInstall) {
            if (aInstall.maxProgress == -1)
              maxProgress = -1;
            progress += aInstall.progress;
            if (maxProgress >= 0)
              maxProgress += aInstall.maxProgress;
            if (aInstall.state < AddonManager.STATE_DOWNLOADED)
              downloadingCount++;
          });

          if (downloadingCount == 0) {
            this.destroy();
            PopupNotifications.remove(this.notification);
          }
          else {
            this.setProgress(progress, maxProgress);
          }
        ]]></body>
      </method>

      <method name="onDownloadProgress">
        <body><![CDATA[
          this.updateProgress();
        ]]></body>
      </method>

      <method name="onDownloadFailed">
        <body><![CDATA[
          this.updateProgress();
        ]]></body>
      </method>

      <method name="onDownloadCancelled">
        <body><![CDATA[
          this.updateProgress();
        ]]></body>
      </method>

      <method name="onDownloadEnded">
        <body><![CDATA[
          this.updateProgress();
        ]]></body>
      </method>
    </implementation>
  </binding>

  <binding id="splitmenu">
    <content>
      <xul:hbox anonid="menuitem" flex="1"
                class="splitmenu-menuitem"
                xbl:inherits="iconic,label,disabled,onclick=oncommand,_moz-menuactive=active"/>
      <xul:menu anonid="menu" class="splitmenu-menu"
                xbl:inherits="disabled"
                oncommand="event.stopPropagation();">
        <children includes="menupopup"/>
      </xul:menu>
    </content>

    <implementation>
      <field name="menuitem" readonly="true">
        document.getAnonymousElementByAttribute(this, "anonid", "menuitem");
      </field>
      <field name="menu" readonly="true">
        document.getAnonymousElementByAttribute(this, "anonid", "menu");
      </field>

      <field name="_menuDelay">600</field>

      <field name="_parentMenupopup"><![CDATA[
        let node = this.parentNode;
        while (node) {
          if (node.localName == "menupopup")
            break;
          node = node.parentNode;
        }
        node;
      ]]></field>
    </implementation>

    <handlers>
      <handler event="mouseover"><![CDATA[
        if (this.getAttribute("active") != "true" &&
            this.getAttribute("disabled") != "true") {
          this.setAttribute("active", "true");

          let self = this;
          setTimeout(function () {
            if (self.getAttribute("active") == "true")
              self.menu.open = true;
          }, this._menuDelay);
        }
      ]]></handler>

      <handler event="mouseout"><![CDATA[
        if (this.menu.open)
          return;

        let node = event.relatedTarget;
        while (node) {
          if (node == this)
            return;
          node = node.parentNode;
        }
        this.removeAttribute("active");
      ]]></handler>

      <handler event="popuphidden"><![CDATA[
        if (event.target == this.firstChild)
          this.removeAttribute("active");
      ]]></handler>

      <handler event="popupshowing"><![CDATA[
        if (event.target == this.firstChild &&
            this._parentMenupopup._currentPopup)
          this._parentMenupopup._currentPopup.hidePopup();
      ]]></handler>

      <handler event="click" phase="capturing"><![CDATA[
        let node = event.originalTarget;
        while (true) {
          if (node == this.menuitem)
            break;
          if (node == this)
            return;
          node = node.parentNode;
        }

        this._parentMenupopup.hidePopup();
      ]]></handler>
    </handlers>
  </binding>

  <binding id="menuitem-tooltip" extends="chrome://global/content/bindings/menu.xml#menuitem">
    <implementation>
      <constructor><![CDATA[
        this.setAttribute("tooltiptext", this.getAttribute("acceltext"));
        // TODO: Simplify this to this.setAttribute("acceltext", "") once bug
        // 592424 is fixed
        document.getAnonymousElementByAttribute(this, "anonid", "accel").firstChild.setAttribute("value", "");
      ]]></constructor>
    </implementation>
  </binding>

  <binding id="menuitem-iconic-tooltip" extends="chrome://global/content/bindings/menu.xml#menuitem-iconic">
    <implementation>
      <constructor><![CDATA[
        this.setAttribute("tooltiptext", this.getAttribute("acceltext"));
        // TODO: Simplify this to this.setAttribute("acceltext", "") once bug
        // 592424 is fixed
        document.getAnonymousElementByAttribute(this, "anonid", "accel").firstChild.setAttribute("value", "");
      ]]></constructor>
    </implementation>
  </binding>

</bindings>
