/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include "frontend/BCEScriptStencil.h"

#include "frontend/AbstractScopePtr.h"  // AbstractScope
#include "frontend/BytecodeEmitter.h"   // BytecodeEmitter
#include "frontend/BytecodeSection.h"   // BytecodeSection, PerScriptData
#include "vm/SharedStencil.h"

using namespace js;
using namespace js::frontend;

BCEScriptStencil::BCEScriptStencil(BytecodeEmitter& bce,
                                   UniquePtr<ImmutableScriptData> immutableData)
    : ScriptStencil(bce.cx), bce_(bce) {
  init(bce, std::move(immutableData));
}

void BCEScriptStencil::init(BytecodeEmitter& bce,
                            UniquePtr<ImmutableScriptData> immutableData) {
  natoms = bce.perScriptData().atomIndices()->count();

  ngcthings = bce.perScriptData().gcThingList().length();

  immutableFlags = bce.sc->immutableFlags();

  // Update the flags generated by BCE.
  immutableFlags.setFlag(ImmutableFlags::Strict, bce.sc->strict());
  immutableFlags.setFlag(ImmutableFlags::NeedsFunctionEnvironmentObjects,
                         getNeedsFunctionEnvironmentObjects(bce));
  immutableFlags.setFlag(
      ImmutableFlags::HasNonSyntacticScope,
      bce.outermostScope().hasOnChain(ScopeKind::NonSyntactic));

  gcThings = bce.perScriptData().gcThingList().stealGCThings();

  // Hand over the ImmutableScriptData instance generated by BCE.
  immutableScriptData = std::move(immutableData);

  // Update flags specific to functions.
  if (isFunction()) {
    FunctionBox* funbox = bce.sc->asFunctionBox();
    functionIndex.emplace(funbox->index());
    fieldInitializers = funbox->fieldInitializers;

    // Set flags that don't have direct flag representation within the
    // FunctionBox.
    immutableFlags.setFlag(ImmutableFlags::HasMappedArgsObj,
                           funbox->hasMappedArgsObj());
  } /* isFunctionBox */
}

bool BCEScriptStencil::getNeedsFunctionEnvironmentObjects(
    BytecodeEmitter& bce) const {
  // See JSFunction::needsCallObject()
  js::AbstractScopePtr bodyScope = bce.bodyScope();
  if (bodyScope.kind() == js::ScopeKind::Function) {
    if (bodyScope.hasEnvironment()) {
      return true;
    }
  }

  // See JSScript::maybeNamedLambdaScope()
  js::AbstractScopePtr outerScope = bce.outermostScope();
  if (outerScope.kind() == js::ScopeKind::NamedLambda ||
      outerScope.kind() == js::ScopeKind::StrictNamedLambda) {
    MOZ_ASSERT(bce.sc->asFunctionBox()->isNamedLambda());

    if (outerScope.hasEnvironment()) {
      return true;
    }
  }

  return false;
}

bool BCEScriptStencil::finishGCThings(
    JSContext* cx, mozilla::Span<JS::GCCellPtr> output) const {
  return EmitScriptThingsVector(cx, bce_.compilationInfo, gcThings, output);
}

void BCEScriptStencil::initAtomMap(GCPtrAtom* atoms) const {
  const AtomIndexMap& indices = *bce_.perScriptData().atomIndices();

  for (AtomIndexMap::Range r = indices.all(); !r.empty(); r.popFront()) {
    JSAtom* atom = r.front().key();
    uint32_t index = r.front().value();
    MOZ_ASSERT(index < indices.count());
    atoms[index].init(atom);
  }
}

void BCEScriptStencil::finishInnerFunctions() const {
  bce_.perScriptData().gcThingList().finishInnerFunctions();
}
