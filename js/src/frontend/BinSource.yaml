# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

# Rules for generating BinSource-auto.cpp
cpp:
    header: |
        /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
        * vim: set ts=8 sts=4 et sw=4 tw=99:
        * This Source Code Form is subject to the terms of the Mozilla Public
        * License, v. 2.0. If a copy of the MPL was not distributed with this
        * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

        // To generate this file, see the documentation in
        // js/src/frontend/binsource/README.md.

        #include "mozilla/ArrayUtils.h"
        #include "mozilla/Casting.h"
        #include "mozilla/Maybe.h"
        #include "mozilla/Move.h"
        #include "mozilla/PodOperations.h"
        #include "mozilla/Vector.h"

        #include "frontend/BinSource.h"
        #include "frontend/BinTokenReaderTester.h"
        #include "frontend/FullParseHandler.h"
        #include "frontend/Parser.h"
        #include "frontend/SharedContext.h"

        #include "vm/RegExpObject.h"

        #include "frontend/ParseContext-inl.h"
        #include "frontend/ParseNode-inl.h"

        namespace js {
        namespace frontend {

        using AutoList = BinTokenReaderTester::AutoList;
        using AutoTaggedTuple = BinTokenReaderTester::AutoTaggedTuple;
        using AutoTuple = BinTokenReaderTester::AutoTuple;
        using BinFields = BinTokenReaderTester::BinFields;
        using Chars = BinTokenReaderTester::Chars;
        using NameBag = GCHashSet<JSString*>;
        using Names = GCVector<JSString*, 8>;
        using UsedNamePtr = UsedNameTracker::UsedNameMap::Ptr;

        // Evaluate an expression EXPR, checking that the result is not falsy.
        //
        // Throw `cx->alreadyReportedError()` if it returns 0/nullptr.
        #define TRY(EXPR) \
            do { \
                if (!EXPR) \
                    return cx_->alreadyReportedError(); \
            } while(false)


        // Evaluate an expression EXPR, checking that the result is not falsy.
        // In case of success, assign the result to VAR.
        //
        // Throw `cx->alreadyReportedError()` if it returns 0/nullptr.
        #define TRY_VAR(VAR, EXPR) \
            do { \
                VAR = EXPR; \
                if (!VAR) \
                    return cx_->alreadyReportedError(); \
            } while (false)

        // Evaluate an expression EXPR, checking that the result is not falsy.
        // In case of success, assign the result to a new variable VAR.
        //
        // Throw `cx->alreadyReportedError()` if it returns 0/nullptr.
        #define TRY_DECL(VAR, EXPR) \
            auto VAR = EXPR; \
            if (!VAR) \
                return cx_->alreadyReportedError();

        // Evaluate an expression EXPR, checking that the result is a success.
        // In case of success, unwrap and assign the result to a new variable VAR.
        //
        // In case of error, propagate the error.
        #define MOZ_TRY_DECL(VAR, EXPR) \
            auto _##VAR = EXPR; \
            if (_##VAR.isErr()) \
                return ::mozilla::Err(_##VAR.unwrapErr()); \
            auto VAR = _##VAR.unwrap();

        // Ensure that we are visiting the right fields.
        template<size_t N>
        JS::Result<Ok, JS::Error&>
        BinASTParser::checkFields(const BinKind kind, const BinFields& actual, const BinField (&expected)[N])
        {
            if (actual.length() != N)
                return raiseInvalidNumberOfFields(kind, N, actual.length());

            for (size_t i = 0; i < N; ++i) {
                if (actual[i] != expected[i])
                    return raiseInvalidField(describeBinKind(kind), actual[i]);
            }

            return Ok();
        }

        // Special case for N=0, as empty arrays are not permitted in C++
        JS::Result<Ok, JS::Error&>
        BinASTParser::checkFields0(const BinKind kind, const BinFields& actual)
        {
            if (actual.length() != 0)
                return raiseInvalidNumberOfFields(kind, 0, actual.length());

            return Ok();
        }

        // Compare a bunch of `uint8_t` values (as returned by the tokenizer_) with
        // a string literal (and ONLY a string literal).
        template<size_t N>
        bool operator==(const Chars& left, const char (&right)[N]) {
            return BinTokenReaderTester::equals(left, right);
        }

        // Helper class: Restore field `variableDeclarationKind_` upon leaving a scope.
        class MOZ_RAII AutoVariableDeclarationKind {
          public:
            explicit AutoVariableDeclarationKind(BinASTParser* parser
                                                 MOZ_GUARD_OBJECT_NOTIFIER_PARAM) :
              parser_(parser),
              kind(parser->variableDeclarationKind_)
            {
                MOZ_GUARD_OBJECT_NOTIFIER_INIT;
            }
            ~AutoVariableDeclarationKind() {
                parser_->variableDeclarationKind_ = kind;
            }
          private:
            BinASTParser* parser_;
            BinASTParser::VariableDeclarationKind kind;
            MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
        };

    footer: |

        #undef TRY
        #undef TRY_VAR
        #undef TRY_DECL
        #undef MOZ_TRY_DECL
        } // namespace frontend
        } // namespace js

hpp:
    # Rules for generating BinSource-class.h
    class:
        header: |
            /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
            * vim: set ts=8 sts=4 et sw=4 tw=99:
            * This Source Code Form is subject to the terms of the Mozilla Public
            * License, v. 2.0. If a copy of the MPL was not distributed with this
            * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

            // To generate this file, see the documentation in
            // js/src/frontend/binsource/README.md.

            // This file is meant to be included from the declaration
            // of class `BinASTParser`. The include may be public or private.

    # Rules for generating BinToken.h
    tokens:
        kind:
            doc: |
                /**
                 * The different kinds of Binary AST nodes, as per the specifications of
                 * Binary AST.
                 *
                 * These kinds match roughly with the `ParseNodeKind` used internally.
                 *
                 * Usage:
                 *
                 * ```c++
                 * #define WITH_KIND(CPP_NAME, SPEC_NAME) ...
                 * FOR_EACH_BIN_KIND(WITH_KIND)
                 * ```
                 *
                 *
                 * (sorted by alphabetical order)
                 */
        field:
            doc: |
                /**
                 * The different fields of Binary AST nodes, as per the specifications of
                 * Binary AST.
                 *
                 * Usage:
                 *
                 * ```c++
                 * #define WITH_FIELD(CPP_NAME, SPEC_NAME) ...
                 * FOR_EACH_BIN_FIELD(WITH_FIELD)
                 * ```
                 *
                 * (sorted by alphabetical order)
                 */

        header: |
            /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
             * vim: set ts=8 sts=4 et sw=4 tw=99:
             * This Source Code Form is subject to the terms of the Mozilla Public
             * License, v. 2.0. If a copy of the MPL was not distributed with this
             * file, You can obtain one at http://mozilla.org/MPL/2.0/. */


            // To generate this file, see the documentation in
            // js/src/frontend/binsource/README.md.

            #ifndef frontend_BinToken_h
            #define frontend_BinToken_h

            #include <stddef.h>

            /**
             * Definition of Binary AST tokens.
             *
             * In the Binary AST world, an AST is composed of nodes, where a node is
             * defined by:
             * - a Kind (see `BinKind`);
             * - a list of fields, where each field is:
             *    - a Name (see `BinField`);
             *    - a Value, which may be either a node or a primitive value.
             *
             * The mapping between Kind and list of fields is determined entirely by
             * the grammar of Binary AST. The mapping between (Kind, Name) and the
             * structure of Value is also determined entirely by the grammar of
             * Binary AST.
             *
             * As per the specifications of Binary AST, kinds may be added as the
             * language grows, but never removed. The mapping between Kind and list
             * of fields may also change to add new fields or make some fields optional,
             * but may never remove a field. Finally, the mapping between (Kind, Name)
             * and the structure of Value may be modified to add new possible values,
             * but never to remove a value.
             *
             * A Binary AST parser must be able to fail gracefully when confronted with
             * unknown Kinds or Names.
             */

            namespace js {
            namespace frontend {
        footer: |

            /**
             * Return a string describing a `BinKind`.
             */
            const char* describeBinKind(const BinKind& kind);

            /**
             * Return a string describing a `BinField`.
             */
            const char* describeBinField(const BinField& kind);

            } // namespace frontend
            } // namespace js

            #endif // frontend_BinToken_h

Arguments:
    init:
        TRY_DECL(result, factory_.newList(ParseNodeKind::ParamsBody, tokenizer_->pos(start)));
    append:
        factory_.addList(/* list = */ result, /* child = */ item);

ArrayExpression:
    build:
        auto result = elements;

AssertedBlockScope:
    type-ok:
        Ok
    build: |
        if (hasDirectEval && parseContext_->isFunctionBox() && !parseContext_->sc()->strict()) {
            // In non-strict mode code, direct calls to eval can
            // add variables to the call object.
            parseContext_->functionBox()->setHasExtensibleScope();
        }
        auto result = Ok();
    fields:
        capturedNames:
            block:
                replace: |
                    MOZ_TRY(parseAndUpdateCapturedNames());
        hasDirectEval:
            after: |
                if (hasDirectEval) {
                    parseContext_->sc()->setHasDirectEval();
                    parseContext_->sc()->setBindingsAccessedDynamically();
                }
        lexicallyDeclaredNames:
            block:
                replace:
                    MOZ_TRY(parseAndUpdateScopeNames(*parseContext_->innermostScope(), DeclarationKind::Let));

AssertedParameterScope:
    inherits: AssertedBlockScope
    fields:
        parameterNames:
            block:
                replace: |
                    MOZ_TRY(parseAndUpdateScopeNames(parseContext_->functionScope(), DeclarationKind:: PositionalFormalParameter));

AssertedVarScope:
    inherits: AssertedBlockScope
    fields:
        varDeclaredNames:
            block:
                replace:
                    MOZ_TRY(parseAndUpdateScopeNames(parseContext_->varScope(), DeclarationKind::Var));

AssignmentExpression:
    build: |
        TRY_DECL(result, factory_.newAssignment(ParseNodeKind::Assign, binding, expression));

AssignmentTargetIdentifier:
    build: |
        if (!IsIdentifier(name))
            return raiseError("Invalid identifier");
        TRY_DECL(result, factory_.newName(name->asPropertyName(), tokenizer_->pos(start), cx_));

BindingIdentifier:
    build: |
        if (!IsIdentifier(name))
            return raiseError("Invalid identifier");
        TRY_DECL(result, factory_.newName(name->asPropertyName(), tokenizer_->pos(start), cx_));

BinaryExpression:
    build: |
        ParseNodeKind pnk;
        switch (operator_) {
          case BinaryOperator::Comma:
            pnk = ParseNodeKind::Comma;
            break;
          case BinaryOperator::LogicalOr:
            pnk = ParseNodeKind::Or;
            break;
          case BinaryOperator::LogicalAnd:
            pnk = ParseNodeKind::And;
            break;
          case BinaryOperator::BitOr:
            pnk = ParseNodeKind::BitOr;
            break;
          case BinaryOperator::BitXor:
            pnk = ParseNodeKind::BitXor;
            break;
          case BinaryOperator::BitAnd:
            pnk = ParseNodeKind::BitAnd;
            break;
          case BinaryOperator::Eq:
            pnk = ParseNodeKind::Eq;
            break;
          case BinaryOperator::Neq:
            pnk = ParseNodeKind::Ne;
            break;
          case BinaryOperator::StrictEq:
            pnk = ParseNodeKind::StrictEq;
            break;
          case BinaryOperator::StrictNeq:
            pnk = ParseNodeKind::StrictNe;
            break;
          case BinaryOperator::LessThan:
            pnk = ParseNodeKind::Lt;
            break;
          case BinaryOperator::LeqThan:
            pnk = ParseNodeKind::Le;
            break;
          case BinaryOperator::GreaterThan:
            pnk = ParseNodeKind::Gt;
            break;
          case BinaryOperator::GeqThan:
            pnk = ParseNodeKind::Ge;
            break;
          case BinaryOperator::In:
            pnk = ParseNodeKind::In;
            break;
          case BinaryOperator::Instanceof:
            pnk = ParseNodeKind::InstanceOf;
            break;
          case BinaryOperator::Lsh:
            pnk = ParseNodeKind::Lsh;
            break;
          case BinaryOperator::Rsh:
            pnk = ParseNodeKind::Rsh;
            break;
          case BinaryOperator::Ursh:
            pnk = ParseNodeKind::Ursh;
            break;
          case BinaryOperator::Plus:
            pnk = ParseNodeKind::Add;
            break;
          case BinaryOperator::Minus:
            pnk = ParseNodeKind::Sub;
            break;
          case BinaryOperator::Mul:
            pnk = ParseNodeKind::Star;
            break;
          case BinaryOperator::Div:
            pnk = ParseNodeKind::Div;
            break;
          case BinaryOperator::Mod:
            pnk = ParseNodeKind::Mod;
            break;
          case BinaryOperator::Pow:
            pnk = ParseNodeKind::Pow;
            break;
        }

        ParseNode* result;
        if (left->isKind(pnk) &&
            pnk != ParseNodeKind::Pow /* ParseNodeKind::Pow is not left-associative */)
        {
            // Regroup left-associative operations into lists.
            left->appendWithoutOrderAssumption(right);
            result = left;
        } else {
            TRY_DECL(list, factory_.newList(pnk, tokenizer_->pos(start)));

            list->appendWithoutOrderAssumption(left);
            list->appendWithoutOrderAssumption(right);
            result = list;
        }

Block:
    init: |
        ParseContext::Statement stmt(parseContext_, StatementKind::Block);
        ParseContext::Scope currentScope(cx_, parseContext_, usedNames_);
        TRY(currentScope.init(parseContext_));
    build: |
        TRY_DECL(bindings, NewLexicalScopeData(cx_, currentScope, alloc_, parseContext_));
        TRY_DECL(result, factory_.newLexicalScope(*bindings, statements));

BreakStatement:
    fields:
        label:
            block:
                replace: |
                    RootedAtom label(cx_);
                    MOZ_TRY(readMaybeString(&label));

                    if (label && !IsIdentifier(label))
                        return raiseError("Invalid identifier");
    build: |
        if (label) {
            auto validity = parseContext_->checkBreakStatement(label->asPropertyName());

            if (validity.isErr()) {
                switch (validity.unwrapErr()) {
                case ParseContext::BreakStatementError::ToughBreak:
                    return raiseError(kind, "Not in a loop");
                case ParseContext::BreakStatementError::LabelNotFound:
                    return raiseError(kind, "Label not found");
                }
            }
        }
        TRY_DECL(result, factory_.newBreakStatement(label ? label->asPropertyName() : nullptr, tokenizer_->pos(start)));

CallExpression:
    build: |
        auto op = JSOP_CALL;
        // Check for direct calls to `eval`.
        if (factory_.isEvalName(callee, cx_)) {
            if (!parseContext_->varScope().lookupDeclaredNameForAdd(callee->name())
             && !parseContext_->innermostScope()->lookupDeclaredNameForAdd(callee->name())) {
                // This is a direct call to `eval`.
                if (!parseContext_->sc()->hasDirectEval())
                    return raiseMissingDirectEvalInAssertedScope();

                op = parseContext_->sc()->strict() ? JSOP_STRICTEVAL : JSOP_EVAL;
            }
        }
        auto result = arguments;
        result->setKind(ParseNodeKind::Call);
        result->prepend(callee);
        result->setOp(op);


CatchClause:
    init: |
        ParseContext::Statement stmt(parseContext_, StatementKind::Catch);
        ParseContext::Scope currentScope(cx_, parseContext_, usedNames_);
        TRY(currentScope.init(parseContext_));
    build: |
        // Export implicit variables to the scope.
        // FIXME: Handle cases other than Name.
        MOZ_ASSERT(binding->isKind(ParseNodeKind::Name));
        auto ptr = currentScope.lookupDeclaredNameForAdd(binding->name());
        TRY(currentScope.addDeclaredName(parseContext_, ptr, binding->name(), DeclarationKind::Let, start));

        TRY_DECL(bindings, NewLexicalScopeData(cx_, currentScope, alloc_, parseContext_));
        TRY_DECL(result, factory_.newLexicalScope(*bindings, body));
        TRY(factory_.setupCatchScope(result, binding, body));

CompoundAssignmentExpression:
    build: |
        ParseNodeKind pnk;
        switch (operator_){
          case CompoundAssignmentOperator::PlusAssign:
            pnk = ParseNodeKind::AddAssign;
            break;
          case CompoundAssignmentOperator::MinusAssign:
            pnk = ParseNodeKind::SubAssign;
            break;
          case CompoundAssignmentOperator::MulAssign:
            pnk = ParseNodeKind::MulAssign;
            break;
          case CompoundAssignmentOperator::DivAssign:
            pnk = ParseNodeKind::DivAssign;
            break;
          case CompoundAssignmentOperator::ModAssign:
            pnk = ParseNodeKind::ModAssign;
            break;
          case CompoundAssignmentOperator::PowAssign:
            pnk = ParseNodeKind::PowAssign;
            break;
          case CompoundAssignmentOperator::LshAssign:
            pnk = ParseNodeKind::LshAssign;
            break;
          case CompoundAssignmentOperator::RshAssign:
            pnk = ParseNodeKind::RshAssign;
            break;
          case CompoundAssignmentOperator::UrshAssign:
            pnk = ParseNodeKind::UrshAssign;
            break;
          case CompoundAssignmentOperator::BitOrAssign:
            pnk = ParseNodeKind::BitOrAssign;
            break;
          case CompoundAssignmentOperator::BitXorAssign:
            pnk = ParseNodeKind::BitXorAssign;
            break;
          case CompoundAssignmentOperator::BitAndAssign:
            pnk = ParseNodeKind::BitAndAssign;
            break;
        }
        TRY_DECL(result, factory_.newAssignment(pnk, binding, expression));

ComputedMemberAssignmentTarget:
    build: |
        TRY_DECL(result, factory_.newPropertyByValue(object, expression, start));

ComputedMemberExpression:
    build: |
        TRY_DECL(result, factory_.newPropertyByValue(object, expression, start));

ConditionalExpression:
    build: |
        TRY_DECL(result, factory_.newConditional(test, consequent, alternate));

ContinueStatement:
    fields:
        label:
            block:
                replace: |
                    RootedAtom label(cx_);
                    MOZ_TRY(readMaybeString(&label));

                    if (label && !IsIdentifier(label))
                        return raiseError("ContinueStatement - Label MUST be an identifier");
    build: |
        if (label) {
            auto validity = parseContext_->checkContinueStatement(label ? label->asPropertyName() : nullptr);
            if (validity.isErr()) {
                switch (validity.unwrapErr()) {
                  case ParseContext::ContinueStatementError::NotInALoop:
                    return raiseError(kind, "Not in a loop");
                  case ParseContext::ContinueStatementError::LabelNotFound:
                    return raiseError(kind, "Label not found");
                }
            }
        }

        TRY_DECL(result, factory_.newContinueStatement(label ? label->asPropertyName() : nullptr, tokenizer_->pos(start)));

DataProperty:
    build: |
        if (!factory_.isUsableAsObjectPropertyName(name))
            return raiseError("DataProperty key kind");

        TRY_DECL(result, factory_.newObjectMethodOrPropertyDefinition(name, expression, AccessorType::None));

Directive:
    build: |
        TokenPos pos = tokenizer_->pos(start);
        TRY_DECL(result, factory_.newStringLiteral(rawValue, pos));

DoWhileStatement:
    init:
        ParseContext::Statement stmt(parseContext_, StatementKind::DoLoop);
    build:
        TRY_DECL(result, factory_.newDoWhileStatement(body, test, tokenizer_->pos(start)));

EmptyStatement:
    build:
        TRY_DECL(result, factory_.newEmptyStatement(tokenizer_->pos(start)));

ExpressionStatement:
    build:
        TRY_DECL(result, factory_.newExprStatement(expression, tokenizer_->offset()));

ForInOfBinding:
    init:
        AutoVariableDeclarationKind kindGuard(this);
    build: |
        // Restored by `kindGuard`.
        variableDeclarationKind_ = kind_;
        MOZ_TRY(checkBinding(binding->pn_atom->asPropertyName()));
        auto pnk =
            kind_ == VariableDeclarationKind::Let
                ? ParseNodeKind::Let
                : ParseNodeKind::Var;
        TRY_DECL(result, factory_.newDeclarationList(pnk, tokenizer_->pos(start)));
        factory_.addList(result, binding);



ForInStatement:
    init: |
        ParseContext::Statement stmt(parseContext_, StatementKind::ForInLoop);

        // Implicit scope around the `for`, used to store `for (let x in  ...)`
        // or `for (const x in ...)`-style declarations. Detail on the
        // declaration is stored as part of `scope`.
        ParseContext::Scope scope(cx_, parseContext_, usedNames_);
        TRY(scope.init(parseContext_));
    build: |
        TRY_DECL(forHead, factory_.newForInOrOfHead(ParseNodeKind::ForIn, left, right, tokenizer_->pos(start)));
        TRY_DECL(result, factory_.newForStatement(start, forHead, body, /*flags*/ 0));

        if (!scope.isEmpty()) {
            TRY_DECL(bindings, NewLexicalScopeData(cx_, scope, alloc_, parseContext_));
            TRY_VAR(result, factory_.newLexicalScope(*bindings, result));
        }

FormalParameters:
    build: |
        auto result = items;
        if (rest) {
            TRY_DECL(spread, factory_.newSpread(start, rest));
            factory_.addList(result, spread);
        }

ForStatement:
    init: |
        ParseContext::Statement stmt(parseContext_, StatementKind::ForLoop);

        // Implicit scope around the `for`, used to store `for (let x; ...; ...)`
        // or `for (const x; ...; ...)`-style declarations. Detail on the
        // declaration is stored as part of `BINJS_Scope`.
        ParseContext::Scope scope(cx_, parseContext_, usedNames_);
        TRY(scope.init(parseContext_));
    build: |
        TRY_DECL(forHead, factory_.newForHead(init, test, update, tokenizer_->pos(start)));
        TRY_DECL(result, factory_.newForStatement(start, forHead, body, /* iflags = */ 0));

        if (!scope.isEmpty()) {
            TRY_DECL(bindings, NewLexicalScopeData(cx_, scope, alloc_, parseContext_));
            TRY_VAR(result, factory_.newLexicalScope(*bindings, result));
        }

FunctionBody:
    build: |
        MOZ_TRY_DECL(result, appendDirectivesToBody(/* body = */ statements, /* directives = */ directives));

FunctionDeclaration:
    inherits: FunctionExpression

FunctionExpression:
    fields:
        parameterScope:
            before: |
                MOZ_TRY_DECL(funbox, buildFunctionBox(
                    isGenerator ? GeneratorKind::Generator
                                : GeneratorKind::NotGenerator,
                    isAsync ? FunctionAsyncKind::AsyncFunction
                            : FunctionAsyncKind::SyncFunction));

                // Push a new ParseContext. It will be used to parse `scope`, the arguments, the function.
                BinParseContext funpc(cx_, this, funbox, /* newDirectives = */ nullptr);
                TRY(funpc.init());
                parseContext_->functionScope().useAsVarScope(parseContext_);
                MOZ_ASSERT(parseContext_->isFunctionBox());

                ParseContext::Scope lexicalScope(cx_, parseContext_, usedNames_);
                TRY(lexicalScope.init(parseContext_));
    build: |
        TRY_DECL(lexicalScopeData, NewLexicalScopeData(cx_, lexicalScope, alloc_, parseContext_));
        TRY_VAR(body, factory_.newLexicalScope(*lexicalScopeData, body));
        MOZ_TRY_DECL(result, buildFunction(start, kind, name, params, body, funbox));

IdentifierExpression:
    build: |
        if (!IsIdentifier(name))
            return raiseError("Invalid identifier");
        TRY_DECL(result, factory_.newName(name->asPropertyName(), tokenizer_->pos(start), cx_));

IfStatement:
    build: |
        TRY_DECL(result, factory_.newIfStatement(start, test, consequent, alternate));

LabelledStatement:
    fields:
        label:
            after: |
                if (!IsIdentifier(label))
                    return raiseError("Invalid identifier");
                ParseContext::LabelStatement stmt(parseContext_, label);
    build:
        TRY_DECL(result, factory_.newLabeledStatement(label->asPropertyName(), body, start));

ListOfDirective:
    init:
        TRY_DECL(result, factory_.newStatementList(tokenizer_->pos(start)));
    append:
        factory_.addStatementToList(result, item);

ListOfObjectProperty:
    init:
        TRY_DECL(result, factory_.newObjectLiteral(start));

ListOfOptionalSpreadElementOrExpression:
    init:
        TRY_DECL(result, factory_.newArrayLiteral(start));
    append: |
        if (item)
            factory_.addArrayElement(result, item); // Infallible.
        else
            TRY(factory_.addElision(result, tokenizer_->pos(start)));

ListOfParameter:
    init: |
        ParseNode* result = new_<ListNode>(ParseNodeKind::ParamsBody, tokenizer_->pos(start));
    append:
        factory_.addList(/* list = */ result, /* item = */ item);

ListOfStatement:
    init:
        TRY_DECL(result, factory_.newStatementList(tokenizer_->pos(start)));
    append:
        factory_.addStatementToList(result, item);


#ListOfSpreadElementOrExpression:
#    init:
#        ParseNode* result = new_<ListNode>(ParseNodeKind::ParamsBody, tokenizer_->pos());
#    append:
#        result->appendWithoutOrderAssumption(item);

ListOfSwitchCase:
    init:
        TRY_DECL(result, factory_.newStatementList(tokenizer_->pos(start)));
    append:
        factory_.addCaseStatementToList(result, item);

ListOfVariableDeclarator:
    init: |
        TRY_DECL(result, factory_.newDeclarationList(ParseNodeKind::Const /*Placeholder*/,
            tokenizer_->pos(start)));

LiteralBooleanExpression:
    build:
        TRY_DECL(result, factory_.newBooleanLiteral(value, tokenizer_->pos(start)));

LiteralNumericExpression:
    build:
        TRY_DECL(result, factory_.newNumber(value, DecimalPoint::HasDecimal, tokenizer_->pos(start)));

LiteralNullExpression:
    build:
        TRY_DECL(result, factory_.newNullLiteral(tokenizer_->pos(start)));

LiteralPropertyName:
    build: |
        ParseNode* result;
        uint32_t index;
        if (value->isIndex(&index))
            TRY_VAR(result, factory_.newNumber(index, NoDecimal, TokenPos(start, tokenizer_->offset())));
        else
            TRY_VAR(result, factory_.newObjectLiteralPropertyName(value, tokenizer_->pos(start)));

LiteralRegExpExpression:
    fields:
        flags:
            block:
                replace:
                    Chars flags(cx_);
                    MOZ_TRY(readString(flags));
    build: |
        RegExpFlag reflags = NoFlags;
        for (auto c : flags) {
            if (c == 'g' && !(reflags & GlobalFlag))
                reflags = RegExpFlag(reflags | GlobalFlag);
            else if (c == 'i' && !(reflags & IgnoreCaseFlag))
                reflags = RegExpFlag(reflags | IgnoreCaseFlag);
            else if (c == 'm' && !(reflags & MultilineFlag))
                reflags = RegExpFlag(reflags | MultilineFlag);
            else if (c == 'y' && !(reflags & StickyFlag))
                reflags = RegExpFlag(reflags | StickyFlag);
            else if (c == 'u' && !(reflags & UnicodeFlag))
                reflags = RegExpFlag(reflags | UnicodeFlag);
            else
                return raiseInvalidEnum("RegExpLiteral", flags);
        }


        Rooted<RegExpObject*> reobj(cx_);
        TRY_VAR(reobj, RegExpObject::create(cx_,
            pattern,
            reflags,
            alloc_,
            TenuredObject));

        TRY_DECL(result, factory_.newRegExp(reobj, tokenizer_->pos(start), *this));

LiteralStringExpression:
    build:
        TRY_DECL(result, factory_.newStringLiteral(value, tokenizer_->pos(start)));

Method:
    inherits: FunctionExpression
    build: |
        MOZ_TRY_DECL(method, buildFunction(start, kind, name, params, body, funbox));
        TRY_DECL(result, factory_.newObjectMethodOrPropertyDefinition(name, method, AccessorType::None));

NewExpression:
    build: |
        auto result = arguments;
        result->setKind(ParseNodeKind::New);
        result->prepend(callee);

ObjectExpression:
    build:
        auto result = properties;

OptionalAssertedBlockScope:
    type-ok:
        Ok

OptionalAssertedVarScope:
    type-ok:
        Ok

OptionalAssertedParameterScope:
    type-ok:
        Ok

ReturnStatement:
    init: |
        if (!parseContext_->isFunctionBox()) {
            // Return statements are permitted only inside functions.
            return raiseInvalidKind("Toplevel Statement", kind);
        }

        parseContext_->functionBox()->usesReturn = true;
    build:
        TRY_DECL(result, factory_.newReturnStatement(expression, tokenizer_->pos(start)));

Script:
    build:
        MOZ_TRY_DECL(result, appendDirectivesToBody(/* body = */ statements, /* directives = */ directives));

Setter:
    inherits: Method
    init: |
        const auto isAsync = false;
        const auto isGenerator = false;
    build: |
        TRY_DECL(params, factory_.newList(ParseNodeKind::ParamsBody, param));
        MOZ_TRY_DECL(method, buildFunction(start, kind, name, params, body, funbox));
        TRY_DECL(result, factory_.newObjectMethodOrPropertyDefinition(name, method, AccessorType::Setter));

ShorthandProperty:
    build: |
        if (!factory_.isUsableAsObjectPropertyName(name))
            TRY_VAR(name, factory_.newObjectLiteralPropertyName(name->name(), tokenizer_->pos(start)));

        TRY_DECL(result, factory_.newObjectMethodOrPropertyDefinition(name, name, AccessorType::None));

SwitchCase:
    build: |
        TRY_DECL(result, factory_.newCaseOrDefault(start, test, consequent));

SwitchDefault:
    build: |
        TRY_DECL(result, factory_.newCaseOrDefault(start, nullptr, consequent));

SwitchStatement:
    build: |
        TRY_DECL(scope, factory_.newLexicalScope(nullptr, cases));
        TRY_DECL(result, factory_.newSwitchStatement(start, discriminant, scope));

SwitchStatementWithDefault:
    build: |
        // Concatenate `preDefaultCase`, `defaultCase`, `postDefaultCase`
        auto cases = preDefaultCases;
        factory_.addList(cases, defaultCase);
        ParseNode* iter = postDefaultCases->pn_head;
        while (iter) {
            ParseNode* next = iter->pn_next;
            factory_.addList(cases, iter);
            iter = next;
        }
        TRY_DECL(scope, factory_.newLexicalScope(nullptr, cases));
        TRY_DECL(result, factory_.newSwitchStatement(start, discriminant, scope));

StaticMemberAssignmentTarget:
    build: |
        TRY_DECL(result, factory_.newPropertyAccess(object, property->asPropertyName(), start));

StaticMemberExpression:
    build: |
        TRY_DECL(result, factory_.newPropertyAccess(object, property->asPropertyName(), start));

ThisExpression:
    build: |
        if (parseContext_->isFunctionBox())
            parseContext_->functionBox()->usesThis = true;

        TokenPos pos = tokenizer_->pos(start);
        ParseNode* thisName(nullptr);
        if (parseContext_->sc()->thisBinding() == ThisBinding::Function)
            TRY_VAR(thisName, factory_.newName(cx_->names().dotThis, pos, cx_));

        TRY_DECL(result, factory_.newThisLiteral(pos, thisName));

ThrowStatement:
    build:
        TRY_DECL(result, factory_.newThrowStatement(expression, tokenizer_->pos(start)));

TryCatchStatement:
    fields:
        body:
            block:
                declare:
                    ParseNode* body;
                before: |
                    ParseContext::Statement stmt(parseContext_, StatementKind::Try);
                    ParseContext::Scope scope(cx_, parseContext_, usedNames_);
                    TRY(scope.init(parseContext_));
    build:
        TRY_DECL(result, factory_.newTryStatement(start, body, catchClause, /* finally = */ nullptr));

TryFinallyStatement:
    fields:
        body:
            block:
                declare:
                    ParseNode* body;
                before: |
                    ParseContext::Statement stmt(parseContext_, StatementKind::Try);
                    ParseContext::Scope scope(cx_, parseContext_, usedNames_);
                    TRY(scope.init(parseContext_));
        finalizer:
            block:
                declare:
                    ParseNode* finalizer;
                before: |
                    ParseContext::Statement stmt(parseContext_, StatementKind::Finally);
                    ParseContext::Scope scope(cx_, parseContext_, usedNames_);
                    TRY(scope.init(parseContext_));
    build:
        TRY_DECL(result, factory_.newTryStatement(start, body, catchClause, finalizer));

UnaryExpression:
    build: |
        ParseNodeKind pnk;
        switch (operator_) {
          case UnaryOperator::Minus:
            pnk = ParseNodeKind::Neg;
            break;
          case UnaryOperator::Plus:
            pnk = ParseNodeKind::Pos;
            break;
          case UnaryOperator::Not:
            pnk = ParseNodeKind::Not;
            break;
          case UnaryOperator::BitNot:
            pnk = ParseNodeKind::BitNot;
            break;
          case UnaryOperator::Typeof: {
            if (operand->isKind(ParseNodeKind::Name))
                pnk = ParseNodeKind::TypeOfName;
            else
                pnk = ParseNodeKind::TypeOfExpr;
            break;
          }
          case UnaryOperator::Void:
            pnk = ParseNodeKind::Void;
            break;
          case UnaryOperator::Delete: {
            switch (operand->getKind()) {
              case ParseNodeKind::Name:
                operand->setOp(JSOP_DELNAME);
                pnk = ParseNodeKind::DeleteName;
                break;
              case ParseNodeKind::Dot:
                pnk = ParseNodeKind::DeleteProp;
                break;
              case ParseNodeKind::Elem:
                pnk = ParseNodeKind::DeleteElem;
                break;
              default:
                pnk = ParseNodeKind::DeleteExpr;
            }
            break;
          }
        }
        TRY_DECL(result, factory_.newUnary(pnk, start, operand));

UpdateExpression:
    build: |
        ParseNodeKind pnk;
        switch (operator_) {
          case UpdateOperator::Incr:
            pnk = isPrefix ? ParseNodeKind::PreIncrement
                           : ParseNodeKind::PostIncrement;
            break;
          case UpdateOperator::Decr:
            pnk = isPrefix ? ParseNodeKind::PreDecrement
                           : ParseNodeKind::PostDecrement;
            break;
        }
        TRY_DECL(result, factory_.newUnary(pnk, start, operand));

VariableDeclaration:
    init:
        AutoVariableDeclarationKind kindGuard(this);

    fields:
        kind:
            after: |
                // Restored by `kindGuard`.
                variableDeclarationKind_ = kind_;

    build: |
        // By specification, the list may not be empty.
        if (declarators->pn_count == 0)
            return raiseEmpty("VariableDeclaration");

        ParseNodeKind pnk;
        switch (kind_) {
          case VariableDeclarationKind::Var:
            pnk = ParseNodeKind::Var;
            break;
          case VariableDeclarationKind::Let:
            pnk = ParseNodeKind::Let;
            break;
          case VariableDeclarationKind::Const:
            pnk = ParseNodeKind::Const;
            break;
        }
        declarators->setKind(pnk);
        auto result = declarators;

VariableDeclarator:
    build: |
        ParseNode* result;
        if (binding->isKind(ParseNodeKind::Name)) {
            // `var foo [= bar]``
            MOZ_TRY(checkBinding(binding->pn_atom->asPropertyName()));

            TRY_VAR(result, factory_.newName(binding->pn_atom->asPropertyName(), tokenizer_->pos(start), cx_));
            if (init)
                result->pn_expr = init;
        } else {
            // `var pattern = bar`
            if (!init) {
                // Here, `init` is required.
                return raiseMissingField("VariableDeclarator (with non-trivial pattern)", BinField::Init);
            }

            MOZ_CRASH("Unimplemented: AssertedScope check for BindingPattern variable declaration");
            TRY_VAR(result, factory_.newAssignment(ParseNodeKind::Assign, binding, init));
        }

WhileStatement:
    init:
        ParseContext::Statement stmt(parseContext_, StatementKind::WhileLoop);
    build:
        TRY_DECL(result, factory_.newWhileStatement(start, test, body));

WithStatement:
    build:
        TRY_DECL(result, factory_.newWithStatement(start, object, body));
