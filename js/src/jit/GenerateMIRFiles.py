# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

# This script generates jit/MIROpsGenerated.h (list of MIR instructions)
# from MIROps.yaml, as well as MIR op definitions.

import buildconfig
import yaml
import six
from collections import OrderedDict
from mozbuild.preprocessor import Preprocessor

HEADER_TEMPLATE = """\
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#ifndef %(includeguard)s
#define %(includeguard)s

/* This file is generated by jit/GenerateMIRFiles.py. Do not edit! */

%(contents)s

#endif // %(includeguard)s
"""


def generate_header(c_out, includeguard, contents):
    c_out.write(
        HEADER_TEMPLATE
        % {
            "includeguard": includeguard,
            "contents": contents,
        }
    )


def load_yaml(yaml_path):
    # First invoke preprocessor.py so that we can use #ifdef JS_SIMULATOR in
    # the YAML file.
    pp = Preprocessor()
    pp.context.update(buildconfig.defines["ALLDEFINES"])
    pp.out = six.StringIO()
    pp.do_filter("substitution")
    pp.do_include(yaml_path)
    contents = pp.out.getvalue()

    # Load into an OrderedDict to ensure order is preserved. Note: Python 3.7+
    # also preserves ordering for normal dictionaries.
    # Code based on https://stackoverflow.com/a/21912744.
    class OrderedLoader(yaml.Loader):
        pass

    def construct_mapping(loader, node):
        loader.flatten_mapping(node)
        return OrderedDict(loader.construct_pairs(node))

    tag = yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG
    OrderedLoader.add_constructor(tag, construct_mapping)
    return yaml.load(contents, OrderedLoader)


def gen_mir_class(name, result, guard, alias_set, clone):
    """Generates class definition for a single MIR opcode."""

    class_name = "M" + name

    code = "class {} : public MNullaryInstruction {{\\\n".format(class_name)
    code += "  {}() : MNullaryInstruction(classOpcode)".format(class_name)
    code += " {"
    if guard:
        code += "\\\n    setGuard();\\\n  "
    if result:
        code += "\\\n    setResultType(MIRType::{});\\\n  ".format(result)
    code += "}}\\\n public:\\\n  INSTRUCTION_HEADER({})\\\n".format(name)
    code += "  TRIVIAL_NEW_WRAPPERS\\\n"
    if alias_set:
        if alias_set == "custom":
            code += "  AliasSet getAliasSet() const override;\\\n"
        else:
            assert alias_set == "none"
            code += "  AliasSet getAliasSet() const override { return AliasSet::None(); }\\\n"
    if clone:
        code += "  ALLOW_CLONE(" + class_name + ")\\\n"
    code += "};\\\n"
    return code


def generate_mir_header(c_out, yaml_path):
    """Generate MIROpsGenerated.h from MIROps.yaml. The generated file
    has a list of MIR ops and boilerplate for MIR op definitions.
    """

    data = load_yaml(yaml_path)

    # MIR_OPCODE_LIST items. Stores the name of each MIR op.
    ops_items = []

    # Generated MIR op class definitions.
    mir_op_classes = []

    for op in data:
        name = op["name"]

        ops_items.append("_({})".format(name))

        gen_boilerplate = op.get("gen_boilerplate", True)
        assert isinstance(gen_boilerplate, bool)

        if gen_boilerplate:
            result = op.get("result_type", None)
            assert result is None or isinstance(result, str)

            guard = op.get("guard", None)
            assert guard is None or True

            alias_set = op.get("alias_set", None)
            assert alias_set is None or True or isinstance(alias_set, str)

            clone = op.get("clone", None)
            assert clone is None or True

            code = gen_mir_class(name, result, guard, alias_set, clone)
            mir_op_classes.append(code)

    contents = "#define MIR_OPCODE_LIST(_)\\\n"
    contents += "\\\n".join(ops_items)
    contents += "\n\n"

    contents += "#define MIR_OPCODE_CLASS_GENERATED \\\n"
    contents += "\\\n".join(mir_op_classes)
    contents += "\n\n"

    generate_header(c_out, "jit_MIROpsGenerated_h", contents)
