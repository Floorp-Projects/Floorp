# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

# This script generates jit/CacheIROpsGenerated.h from CacheIROps.yaml

import buildconfig
import yaml
import six
from collections import OrderedDict
from mozbuild.preprocessor import Preprocessor

HEADER_TEMPLATE = """\
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#ifndef %(includeguard)s
#define %(includeguard)s

/* This file is generated by jit/GenerateCacheIRFiles.py. Do not edit! */

%(contents)s

#endif // %(includeguard)s
"""


def generate_header(c_out, includeguard, contents):
    c_out.write(HEADER_TEMPLATE % {
        'includeguard': includeguard,
        'contents': contents,
    })


def load_yaml(yaml_path):
    # First invoke preprocessor.py so that we can use #ifdef JS_SIMULATOR in
    # the YAML file.
    pp = Preprocessor()
    pp.context.update(buildconfig.defines['ALLDEFINES'])
    pp.out = six.StringIO()
    pp.do_filter('substitution')
    pp.do_include(yaml_path)
    contents = pp.out.getvalue()

    # Load into an OrderedDict to ensure order is preserved. Note: Python 3.7+
    # also preserves ordering for normal dictionaries.
    # Code based on https://stackoverflow.com/a/21912744.
    class OrderedLoader(yaml.Loader):
        pass

    def construct_mapping(loader, node):
        loader.flatten_mapping(node)
        return OrderedDict(loader.construct_pairs(node))
    tag = yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG
    OrderedLoader.add_constructor(tag, construct_mapping)
    return yaml.load(contents, OrderedLoader)


# Information for generating CacheIRWriter code for a single operand. Tuple
# stores the C++ argument type and the CacheIRWriter method to call.
operand_writer_info = {
    'ValId': ('ValOperandId', 'writeOperandId'),
    'ObjId': ('ObjOperandId', 'writeOperandId'),
    'StrId': ('StringOperandId', 'writeOperandId'),
    'SymId': ('SymbolOperandId', 'writeOperandId'),
    'Int32Id': ('Int32OperandId', 'writeOperandId'),

    'ShapeField': ('Shape*', 'writeShapeField'),
    'GroupField': ('ObjectGroup*', 'writeGroupField'),
    'ObjectField': ('JSObject*', 'writeObjectField'),
    'StringField': ('JSString*', 'writeStringField'),
    'PropertyNameField': ('PropertyName*', 'writeStringField'),
    'SymbolField': ('JS::Symbol*', 'writeSymbolField'),
    'RawWordField': ('uintptr_t', 'writeRawWordField'),
    'RawPointerField': ('const void*', 'writeRawPointerField'),
    'IdField': ('jsid', 'writeIdField'),

    'JSOpImm': ('JSOp', 'writeJSOpImm'),
    'BoolImm': ('bool', 'writeBoolImm'),
    'GuardClassKindImm': ('GuardClassKind', 'writeGuardClassKindImm'),
    'JSWhyMagicImm': ('JSWhyMagic', 'writeJSWhyMagicImm'),
    'CallFlagsImm': ('CallFlags', 'writeCallFlagsImm'),
    'TypedThingLayoutImm': ('TypedThingLayout', 'writeTypedThingLayoutImm'),
    'ReferenceTypeImm': ('ReferenceType', 'writeReferenceTypeImm'),
    'ScalarTypeImm': ('Scalar::Type', 'writeScalarTypeImm'),
    'Int32Imm': ('int32_t', 'writeInt32Imm'),
    'JSNativeImm': ('JSNative', 'writeJSNativeImm'),
}


def gen_writer_method(name, operands):
    """Generates a CacheIRWRiter method for a single opcode."""

    # Generate a single method that writes the opcode and each operand.
    # For example:
    #
    #   void guardShape(ObjOperandId obj, Shape* shape) {
    #     writeOp(CacheOp::GuardShape);
    #     writeOperandId(obj);
    #     writeShapeField(shape);
    #  }

    # Method names start with a lowercase letter.
    method_name = name[0].lower() + name[1:]

    args_sig = []
    operands_code = ''
    if operands:
        for opnd_name, opnd_type in six.iteritems(operands):
            argtype, write_method = operand_writer_info[opnd_type]
            args_sig.append('{} {}'.format(argtype, opnd_name))
            operands_code += '  {}({});\\\n'.format(write_method, opnd_name)

    code = 'void {}({}) {{\\\n'.format(method_name, ', '.join(args_sig))
    code += '  writeOp(CacheOp::{});\\\n'.format(name)
    code += operands_code
    code += '}'
    return code


# Information for generating CacheIRCompiler code for a single operand. Tuple
# stores the C++ type, the suffix used for arguments/variables of this type, and
# the expression to read this type from CacheIRReader.
operand_compiler_info = {
    'ValId': ('ValOperandId', 'Id', 'reader.valOperandId()'),
    'ObjId': ('ObjOperandId', 'Id', 'reader.objOperandId()'),
    'StrId': ('StringOperandId', 'Id', 'reader.stringOperandId()'),
    'SymId': ('SymbolOperandId', 'Id', 'reader.symbolOperandId()'),
    'Int32Id': ('Int32OperandId', 'Id', 'reader.int32OperandId()'),

    'ShapeField': ('uint32_t', 'Offset', 'reader.stubOffset()'),
    'GroupField': ('uint32_t', 'Offset', 'reader.stubOffset()'),
    'ObjectField': ('uint32_t', 'Offset', 'reader.stubOffset()'),
    'StringField': ('uint32_t', 'Offset', 'reader.stubOffset()'),
    'PropertyNameField': ('uint32_t', 'Offset', 'reader.stubOffset()'),
    'SymbolField': ('uint32_t', 'Offset', 'reader.stubOffset()'),
    'RawWordField': ('uint32_t', 'Offset', 'reader.stubOffset()'),
    'RawPointerField': ('uint32_t', 'Offset', 'reader.stubOffset()'),
    'IdField': ('uint32_t', 'Offset', 'reader.stubOffset()'),

    'JSOpImm': ('JSOp', '', 'reader.jsop()'),
    'BoolImm': ('bool', '', 'reader.readBool()'),
    'GuardClassKindImm': ('GuardClassKind', '', 'reader.guardClassKind()'),
    'JSWhyMagicImm': ('JSWhyMagic', '', 'reader.whyMagic()'),
    'CallFlagsImm': ('CallFlags', '', 'reader.callFlags()'),
    'TypedThingLayoutImm': ('TypedThingLayout', '', 'reader.typedThingLayout()'),
    'ReferenceTypeImm': ('ReferenceType', '', 'reader.referenceTypeDescrType()'),
    'ScalarTypeImm': ('Scalar::Type', '', 'reader.scalarType()'),
    'Int32Imm': ('int32_t', '', 'reader.int32Immediate()'),
    'JSNativeImm': ('JSNative', '', 'reinterpret_cast<JSNative>(reader.pointer())'),
}


def gen_compiler_method(name, operands):
    """Generates CacheIRCompiler header code for a single opcode."""

    method_name = 'emit' + name

    # If there are no operands, just generate a `bool emitFoo();` signature.`
    if not operands:
        return 'MOZ_MUST_USE bool {}();\\\n'.format(method_name)

    # If there are operands we generate the signature of the method that needs
    # to be implemented and a separate function forwarding to it. For example:
    #
    #   MOZ_MUST_USE bool emitGuardShape(ObjOperandId objId, uint32_t shapeOffset);
    #   MOZ_MUST_USE bool emitGuardShape() {
    #     ObjOperandId objId = reader.objOperandId();
    #     uint32_t shapeOffset = reader.stubOffset();
    #     return emitGuardShape(objId, shapeOffset);
    #   }
    args_names = []
    args_sig = []
    operands_code = ''
    for opnd_name, opnd_type in six.iteritems(operands):
        vartype, suffix, readexpr = operand_compiler_info[opnd_type]
        varname = opnd_name + suffix
        args_names.append(varname)
        args_sig.append('{} {}'.format(vartype, varname))
        operands_code += '  {} {} = {};\\\n'.format(vartype, varname, readexpr)

    # Generate signature.
    code = 'MOZ_MUST_USE bool {}({});\\\n'.format(method_name, ', '.join(args_sig))

    # Generate the method forwarding to it.
    code += 'MOZ_MUST_USE bool {}() {{\\\n'.format(method_name)
    code += operands_code
    code += '  return {}({});\\\n'.format(method_name, ', '.join(args_names))
    code += '}\\\n'

    return code


def generate_cacheirops_header(c_out, yaml_path):
    """Generate CacheIROpsGenerated.h from CacheIROps.yaml. The generated file
    contains:

    * A list of all CacheIR ops:

        #define CACHE_IR_OPS(_)\
        _(GuardToObject, Id)\
        _(CompareObjectUndefinedNullResult, Id, Byte)\
        ...

    * Lists of shared and unshared ops for the CacheIRCompiler classes. See the
    'shared' attribute in the YAML file.

    * Generated source code for CacheIRWriter and CacheIRCompiler.
    """

    data = load_yaml(yaml_path)

    # Mapping from operand types to the less precise types expected by current
    # C++ code.
    mapping = {
        'ValId': 'Id',
        'ObjId': 'Id',
        'StrId': 'Id',
        'SymId': 'Id',
        'Int32Id': 'Id',
        'NumId': 'Id',
        'BigIntId': 'Id',
        'ValTagId': 'Id',
        'AnyId': 'Id',

        'ShapeField': 'Field',
        'GroupField': 'Field',
        'ObjectField': 'Field',
        'StringField': 'Field',
        'PropertyNameField': 'Field',
        'SymbolField': 'Field',
        'RawWordField': 'Field',
        'RawPointerField': 'Field',
        'DOMExpandoGenerationField': 'Field',
        'IdField': 'Field',
        'ValueField': 'Field',
        'FieldOffset': 'Field',

        'ByteImm': 'Byte',
        'BoolImm': 'Byte',
        'CallFlagsImm': 'Byte',
        'TypedThingLayoutImm': 'Byte',
        'ReferenceTypeImm': 'Byte',
        'ScalarTypeImm': 'Byte',
        'MetaTwoByteKindImm': 'Byte',
        'JSOpImm': 'Byte',
        'ValueTypeImm': 'Byte',
        'GuardClassKindImm': 'Byte',
        'JSWhyMagicImm': 'Byte',

        'Int32Imm': 'Int32',

        'UInt32Imm': 'UInt32',

        'JSNativeImm': 'Word',
        'StaticStringImm': 'Word',
    }

    # CACHE_IR_OPS items.
    ops_items = []

    # CACHE_IR_SHARED_OPS and CACHE_IR_UNSHARED_OPS items. These will go away
    # when all ops have generated boilerplate.
    ops_shared = []
    ops_unshared = []

    # Generated CacheIRWriter methods.
    writer_methods = []

    # Generated CacheIRCompiler methods.
    compiler_shared_methods = []
    compiler_unshared_methods = []

    for op in data:
        name = op['name']

        operands = op['operands']
        assert operands is None or isinstance(operands, OrderedDict)

        shared = op['shared']
        assert isinstance(shared, bool)

        gen_boilerplate = op.get('gen_boilerplate', False)

        if operands:
            operands_str = ', '.join([mapping[v] for v in operands.values()])
        else:
            operands_str = 'None'
        ops_items.append('_({}, {})'.format(name, operands_str))

        if gen_boilerplate:
            writer_methods.append(gen_writer_method(name, operands))
            if shared:
                compiler_shared_methods.append(gen_compiler_method(name, operands))
            else:
                compiler_unshared_methods.append(gen_compiler_method(name, operands))
        else:
            if shared:
                ops_shared.append('_({})'.format(name))
            else:
                ops_unshared.append('_({})'.format(name))

    contents = '#define CACHE_IR_OPS(_)\\\n'
    contents += '\\\n'.join(ops_items)
    contents += '\n\n'

    contents += '#define CACHE_IR_SHARED_OPS(_)\\\n'
    contents += '\\\n'.join(ops_shared)
    contents += '\n\n'

    contents += '#define CACHE_IR_UNSHARED_OPS(_)\\\n'
    contents += '\\\n'.join(ops_unshared)
    contents += '\n\n'

    contents += '#define CACHE_IR_WRITER_GENERATED \\\n'
    contents += '\\\n'.join(writer_methods)
    contents += '\n\n'

    contents += '#define CACHE_IR_COMPILER_SHARED_GENERATED \\\n'
    contents += '\\\n'.join(compiler_shared_methods)
    contents += '\n\n'

    contents += '#define CACHE_IR_COMPILER_UNSHARED_GENERATED \\\n'
    contents += '\\\n'.join(compiler_unshared_methods)
    contents += '\n\n'

    generate_header(c_out, 'jit_CacheIROpsGenerated_h', contents)
