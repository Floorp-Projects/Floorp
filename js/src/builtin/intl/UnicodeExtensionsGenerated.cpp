// Generated by make_intl_data.py. DO NOT EDIT.
// Version: CLDR-35.1
// URL: https://unicode.org/Public/cldr/35.1/core.zip

#include "mozilla/Assertions.h"
#include "mozilla/Range.h"
#include "mozilla/TextUtils.h"

#include <algorithm>
#include <cstdint>
#include <cstring>

#include "builtin/intl/LanguageTag.h"

using namespace js::intl::LanguageTagLimits;

using ConstCharRange = mozilla::Range<const char>;

template <size_t Length>
static inline bool IsUnicodeKey(const ConstCharRange& key,
                                const char (&str)[Length]) {
  static_assert(Length == UnicodeKeyLength + 1,
                "Unicode extension key is two characters long");
  return memcmp(key.begin().get(), str, Length - 1) == 0;
}

template <size_t Length>
static inline bool IsUnicodeType(const ConstCharRange& type,
                                 const char (&str)[Length]) {
  static_assert(Length > UnicodeKeyLength + 1,
                "Unicode extension type contains more than two characters");
  return type.length() == (Length - 1) &&
         memcmp(type.begin().get(), str, Length - 1) == 0;
}

static int32_t CompareUnicodeType(const char* a, const ConstCharRange& b) {
#ifdef DEBUG
  auto isNull = [](char c) {
    return c == '\0';
  };
#endif

  MOZ_ASSERT(std::none_of(b.begin().get(), b.end().get(), isNull),
             "unexpected null-character in string");

  using UnsignedChar = unsigned char;
  for (size_t i = 0; i < b.length(); i++) {
    // |a| is zero-terminated and |b| doesn't contain a null-terminator. So if
    // we've reached the end of |a|, the below if-statement will always be true.
    // That ensures we don't read past the end of |a|.
    if (int32_t r = UnsignedChar(a[i]) - UnsignedChar(b[i])) {
      return r;
    }
  }

  // Return zero if both strings are equal or a negative number if |b| is a
  // prefix of |a|.
  return -int32_t(UnsignedChar(a[b.length()]));
};

template <size_t Length>
static inline const char* SearchReplacement(const char* (&types)[Length],
                                            const char* (&aliases)[Length],
                                            const ConstCharRange& type) {

  auto p = std::lower_bound(std::begin(types), std::end(types), type,
                            [](const auto& a, const auto& b) {
    return CompareUnicodeType(a, b) < 0;
  });
  if (p != std::end(types) && CompareUnicodeType(*p, type) == 0) {
    return aliases[std::distance(std::begin(types), p)];
  }
  return nullptr;
}

/**
 * Mapping from deprecated BCP 47 Unicode extension types to their preferred
 * values.
 *
 * Spec: https://www.unicode.org/reports/tr35/#Unicode_Locale_Extension_Data_Files
 */
const char* js::intl::LanguageTag::replaceUnicodeExtensionType(
    const ConstCharRange& key, const ConstCharRange& type) {
#ifdef DEBUG
  static auto isAsciiLowercaseAlphanumeric = [](char c) {
    return mozilla::IsAsciiLowercaseAlpha(c) || mozilla::IsAsciiDigit(c);
  };

  static auto isAsciiLowercaseAlphanumericOrDash = [](char c) {
    return isAsciiLowercaseAlphanumeric(c) || c == '-';
  };
#endif

  MOZ_ASSERT(key.length() == UnicodeKeyLength);
  MOZ_ASSERT(std::all_of(key.begin().get(), key.end().get(),
                         isAsciiLowercaseAlphanumeric));

  MOZ_ASSERT(type.length() > UnicodeKeyLength);
  MOZ_ASSERT(std::all_of(type.begin().get(), type.end().get(),
                         isAsciiLowercaseAlphanumericOrDash));

  if (IsUnicodeKey(key, "ca")) {
    if (IsUnicodeType(type, "ethiopic-amete-alem")) {
      return "ethioaa";
    }
    if (IsUnicodeType(type, "islamicc")) {
      return "islamic-civil";
    }
  }
  else if (IsUnicodeKey(key, "kb") ||
           IsUnicodeKey(key, "kc") ||
           IsUnicodeKey(key, "kh") ||
           IsUnicodeKey(key, "kk") ||
           IsUnicodeKey(key, "kn")) {
    if (IsUnicodeType(type, "yes")) {
      return "true";
    }
  }
  else if (IsUnicodeKey(key, "ks")) {
    if (IsUnicodeType(type, "primary")) {
      return "level1";
    }
    if (IsUnicodeType(type, "tertiary")) {
      return "level3";
    }
  }
  else if (IsUnicodeKey(key, "ms")) {
    if (IsUnicodeType(type, "imperial")) {
      return "uksystem";
    }
  }
  else if (IsUnicodeKey(key, "rg") ||
           IsUnicodeKey(key, "sd")) {
    static const char* types[116] = {
       "cn11",  "cn12",  "cn13",  "cn14",  "cn15",  "cn21",  "cn22",  "cn23",
       "cn31",  "cn32",  "cn33",  "cn34",  "cn35",  "cn36",  "cn37",  "cn41",
       "cn42",  "cn43",  "cn44",  "cn45",  "cn46",  "cn50",  "cn51",  "cn52",
       "cn53",  "cn54",  "cn61",  "cn62",  "cn63",  "cn64",  "cn65", "cz10a",
      "cz10b", "cz10c", "cz10d", "cz10e", "cz10f", "cz611", "cz612", "cz613",
      "cz614", "cz615", "cz621", "cz622", "cz623", "cz624", "cz626", "cz627",
       "czjc",  "czjm",  "czka",  "czkr",  "czli",  "czmo",  "czol",  "czpa",
       "czpl",  "czpr",  "czst",  "czus",  "czvy",  "czzl",   "fra",   "frb",
        "frc",   "frd",   "fre",   "frf",   "frg",   "frh",   "fri",   "frj",
        "frk",   "frl",   "frm",   "frn",   "fro",   "frp",   "frq",   "frr",
        "frs",   "frt",   "fru",   "frv",  "laxn",   "lud",   "lug",   "lul",
      "mrnkc",   "nzn",   "nzs",  "omba",  "omsh",  "plds",  "plkp",  "pllb",
       "plld",  "pllu",  "plma",  "plmz",  "plop",  "plpd",  "plpk",  "plpm",
       "plsk",  "plsl",  "plwn",  "plwp",  "plzp", "tteto", "ttrcm", "ttwto",
      "twkhq", "twtnq", "twtpq", "twtxq",
    };
    static const char* aliases[116] = {
       "cnbj",  "cntj",  "cnhe",  "cnsx",  "cnmn",  "cnln",  "cnjl",  "cnhl",
       "cnsh",  "cnjs",  "cnzj",  "cnah",  "cnfj",  "cnjx",  "cnsd",  "cnha",
       "cnhb",  "cnhn",  "cngd",  "cngx",  "cnhi",  "cncq",  "cnsc",  "cngz",
       "cnyn",  "cnxz",  "cnsn",  "cngs",  "cnqh",  "cnnx",  "cnxj", "cz110",
      "cz111", "cz112", "cz113", "cz114", "cz115", "cz663", "cz632", "cz633",
      "cz634", "cz635", "cz641", "cz642", "cz643", "cz644", "cz646", "cz647",
       "cz31",  "cz64",  "cz41",  "cz52",  "cz51",  "cz80",  "cz71",  "cz53",
       "cz32",  "cz10",  "cz20",  "cz42",  "cz63",  "cz72", "frges", "frnaq",
      "frara", "frbfc", "frbre", "frcvl", "frges", "frcor", "frbfc", "fridf",
      "frocc", "frnaq", "frges", "frocc", "frhdf", "frnor", "frnor", "frpdl",
      "frhdf", "frnaq", "frpac", "frara",  "laxs",  "lucl",  "luec",  "luca",
       "mr13", "nzauk", "nzcan",  "ombj",  "omsj",  "pl02",  "pl04",  "pl08",
       "pl10",  "pl06",  "pl12",  "pl14",  "pl16",  "pl20",  "pl18",  "pl22",
       "pl26",  "pl24",  "pl28",  "pl30",  "pl32", "tttob", "ttmrc", "tttob",
      "twkhh", "twtnn", "twnwt", "twtxg",
    };
    return SearchReplacement(types, aliases, type);
  }
  else if (IsUnicodeKey(key, "tz")) {
    static const char* types[28] = {
         "aqams",    "cnckg",    "cnhrb",    "cnkhg",     "cuba",    "egypt",
          "eire",      "est",     "gmt0", "hongkong",      "hst",  "iceland",
          "iran",   "israel",  "jamaica",    "japan",    "libya",      "mst",
        "navajo",   "poland", "portugal",      "prc",      "roc",      "rok",
        "turkey",      "uct", "usnavajo",     "zulu",
    };
    static const char* aliases[28] = {
         "nzakl",    "cnsha",    "cnsha",    "cnurc",    "cuhav",    "egcai",
         "iedub",   "utcw05",      "gmt",    "hkhkg",   "utcw10",    "isrey",
         "irthr",  "jeruslm",    "jmkin",    "jptyo",    "lytip",   "utcw07",
         "usden",    "plwaw",    "ptlis",    "cnsha",    "twtpe",    "krsel",
         "trist",      "utc",    "usden",      "utc",
    };
    return SearchReplacement(types, aliases, type);
  }
  return nullptr;
}
