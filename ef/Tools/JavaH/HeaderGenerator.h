/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 *
 * The contents of this file are subject to the Netscape Public License
 * Version 1.0 (the "NPL"); you may not use this file except in
 * compliance with the NPL.  You may obtain a copy of the NPL at
 * http://www.mozilla.org/NPL/
 *
 * Software distributed under the NPL is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the NPL
 * for the specific language governing rights and limitations under the
 * NPL.
 *
 * The Initial Developer of this code under the NPL is Netscape
 * Communications Corporation.  Portions created by Netscape are
 * Copyright (C) 1998 Netscape Communications Corporation.  All Rights
 * Reserved.
 */
#ifndef _HEADER_GENERATOR_H_
#define _HEADER_GENERATOR_H_

#include "ClassCentral.h"
#include "prio.h"

/* A HeaderGenerator class generates C/C++ style headers from a 
 * java class file. It will generate stubs for native methods 
 * in the class, and depending on the kind of mechanism used,
 * might also generate C structures to access the fields of the class.
 * HeaderGenerator is an abstract class; headers for specific native-method 
 * dispatch mechanisms are generated by sub-classes of this class.
 */
class HeaderGenerator {
public:
  /* Initialize a header generator. classPath, if non-zero, is a path to 
   * search for classes. If classPath is zero, the environment variable
   * CLASSPATH is used to determine the class path.
   */
  HeaderGenerator(ClassCentral &central);

  virtual ~HeaderGenerator();

  /* Set the class path to the given string classPath. classPath is a 
   * colon-separated list of canonical (Unix-like) pathnames which are 
   * searched for classes. The new path will completely replace the 
   * existing path.
   */
  void setClassPath(const char *classPath);

  /* Set the directory where the header files are to be written. dir is a 
   * canonical pathname representing the directory.
   */
  void setOutputDir(const char *dir);

  /* Set the temporary directory to store temporary information. */
  void setTempDir(const char *dir);

  /* Set the name of the output header file. */
  void setOutputFile(const char *fileName);

  /* Generate the header for the given fully-qualified className. Returns 
   * true on success, false on failure.
   */
  bool writeFile(const char *className);
  
protected:
  /* Returns true if the header-generation process requires a traversal of
   * the parent classes of the class, false otherwise.
   */
  virtual bool needParents() { return false; }
  
  /* This routine will examine the class for fields and/or
   * native methods and generate the C/C++ header. This routine can assume
   * that it does not have to generate the headers and footers of the header
   * file..it will be done by the caller. This routine should also not close
   * the file -- that will also be done by the caller.
   */
#ifndef USE_PR_IO
  virtual bool genHeaderFile(ClassFileSummary &summ, PRFileDesc *fp) = 0;
#else
  virtual bool genHeaderFile(ClassFileSummary &summ, FILE *fp) = 0;
#endif

  /* Write the header and footer information for amn already open
   * header file whose mangled class name is given by mangledClassName.
   */
#ifndef USE_PR_IO
  virtual void writeHeader(const char *mangledClassName, PRFileDesc *fp);
  virtual void writeFooter(const char *mangledClassName, PRFileDesc *fp);
#else
  virtual void writeHeader(const char *mangledClassName, FILE *fp);
  virtual void writeFooter(const char *mangledClassName, FILE *fp);
#endif

  /* Mangles the given fullyQualifiedClassName and returns the
   * mangled name. Modifies fullyQualifiedClassName; also 
   * assumed that it holds enough memory for the mangling.
   */
  virtual char *mangleClassName(char *fullyQualifiedClassName, 
				char separator) {
    for (char *s = fullyQualifiedClassName; *s; s++)
      if (*s == separator) *s = '_';

    return fullyQualifiedClassName;
  }

  /* Return a string that is the C++ representation of the given type, as
   * used as arguments to C++ functions and return types.
   * Sub-classes might want to re-define this if they want to return
   * different representations. This routine allocates memory (using malloc) 
   * for the string that it generates; it is the responsibility of the 
   * caller to free this memory (using free()).
   */
  virtual char *getArgString(const Type &type);

  /* Given a Java entity whose type is Type, generate a mangled class name.
   * This routine allocates memory using malloc():it is the responsibility
   * of the caller to free this memory (using free()).
   * If asArray is true, returns a string that is equivalent to the
   * exact representation of the type. If asArray is false, this method
   * might return a string that corresponds to this type's layout in 
   * memory (for example, char's and short's are 4-byte aligned in objects
   * but are packed in arrays).
   */
  virtual char *getMangledName(const Type &type, bool asArray = false);

  /* return the name of the parent of the class whose information 
   * is contained in reader.
   */
  const char *getParentName(const ClassFileReader &reader) {
    ConstantClass *parentClass = reader.getSuperClass();
    
    if (!parentClass)
      return 0;
    
    return parentClass->getUtf()->getUtfString();
  }
  
  /* This routine generates forward declarations for all objects
   * referenced in the fields and methods of the class whose representation
   * in memory is summ. The mangled names of all the objects that forward
   * declarations should be generated for are stored in the StringPool.
   * This routine does not generate the forward declarations themselves -
   * that is done as appropriate by a sub-class of HeaderGenerator.
   */
  virtual void genForwards(ClassFileSummary &summ, StringPool &sp);

  /* Add the mangled name corresponding to type, whose typeKind should
   * be tkArray or tkObject, to the stringpool sp. summ contains information
   * about the current class (the class for which forward declarations are
   * being generated.
   *
   */
  void addMangledName(ClassFileSummary &summ,
		      const Type &type, StringPool &sp);

  /* Absolute or relative canonical pathname of the directory where the 
   * headers are written.
   */
   char *headerDir;

   /* Absolute or relative canonical pathname of the temporary directory */
   char *tempDir;

private:
   /* A repository to hold all our classes */
   ClassCentral &central;
   
};

   
#endif /* _HEADER_GENERATOR_H_ */





