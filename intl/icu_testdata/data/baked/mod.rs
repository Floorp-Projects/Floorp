// @generated
mod segmenter ; use :: icu_provider :: prelude :: * ; # [doc = r" Implement [`DataProvider<M>`] on the given struct using the data"] # [doc = r" hardcoded in this module. This allows the struct to be used with"] # [doc = r" `icu`'s `_unstable` constructors."] # [doc = r""] # [doc = r" This macro can only be called from its definition-site, i.e. right"] # [doc = r" after `include!`-ing the generated module."] # [doc = r""] # [doc = r" ```compile_fail"] # [doc = r" struct MyDataProvider;"] # [doc = r#" include!("/path/to/generated/mod.rs");"#] # [doc = r" impl_data_provider(MyDataProvider);"] # [doc = r" ```"] # [allow (unused_macros)] macro_rules ! impl_data_provider { ($ provider : path) => { impl DataProvider < :: icu_segmenter :: provider :: DictionaryForWordOnlyAutoV1Marker > for $ provider { fn load (& self , req : DataRequest ,) -> Result < DataResponse < :: icu_segmenter :: provider :: DictionaryForWordOnlyAutoV1Marker > , DataError > { segmenter :: dictionary :: w_auto_v1 :: lookup (& req . locale) . map (zerofrom :: ZeroFrom :: zero_from) . map (DataPayload :: from_owned) . map (| payload | { DataResponse { metadata : Default :: default () , payload : Some (payload) , } }) . ok_or_else (|| DataErrorKind :: MissingLocale . with_req (:: icu_segmenter :: provider :: DictionaryForWordOnlyAutoV1Marker :: KEY , req)) } } impl DataProvider < :: icu_segmenter :: provider :: GraphemeClusterBreakDataV1Marker > for $ provider { fn load (& self , req : DataRequest ,) -> Result < DataResponse < :: icu_segmenter :: provider :: GraphemeClusterBreakDataV1Marker > , DataError > { segmenter :: grapheme_v1 :: lookup (& req . locale) . map (zerofrom :: ZeroFrom :: zero_from) . map (DataPayload :: from_owned) . map (| payload | { DataResponse { metadata : Default :: default () , payload : Some (payload) , } }) . ok_or_else (|| DataErrorKind :: MissingLocale . with_req (:: icu_segmenter :: provider :: GraphemeClusterBreakDataV1Marker :: KEY , req)) } } impl DataProvider < :: icu_segmenter :: provider :: LineBreakDataV1Marker > for $ provider { fn load (& self , req : DataRequest ,) -> Result < DataResponse < :: icu_segmenter :: provider :: LineBreakDataV1Marker > , DataError > { segmenter :: line_v1 :: lookup (& req . locale) . map (zerofrom :: ZeroFrom :: zero_from) . map (DataPayload :: from_owned) . map (| payload | { DataResponse { metadata : Default :: default () , payload : Some (payload) , } }) . ok_or_else (|| DataErrorKind :: MissingLocale . with_req (:: icu_segmenter :: provider :: LineBreakDataV1Marker :: KEY , req)) } } impl DataProvider < :: icu_segmenter :: provider :: LstmForWordLineAutoV1Marker > for $ provider { fn load (& self , req : DataRequest ,) -> Result < DataResponse < :: icu_segmenter :: provider :: LstmForWordLineAutoV1Marker > , DataError > { segmenter :: lstm :: wl_auto_v1 :: lookup (& req . locale) . map (zerofrom :: ZeroFrom :: zero_from) . map (DataPayload :: from_owned) . map (| payload | { DataResponse { metadata : Default :: default () , payload : Some (payload) , } }) . ok_or_else (|| DataErrorKind :: MissingLocale . with_req (:: icu_segmenter :: provider :: LstmForWordLineAutoV1Marker :: KEY , req)) } } impl DataProvider < :: icu_segmenter :: provider :: SentenceBreakDataV1Marker > for $ provider { fn load (& self , req : DataRequest ,) -> Result < DataResponse < :: icu_segmenter :: provider :: SentenceBreakDataV1Marker > , DataError > { segmenter :: sentence_v1 :: lookup (& req . locale) . map (zerofrom :: ZeroFrom :: zero_from) . map (DataPayload :: from_owned) . map (| payload | { DataResponse { metadata : Default :: default () , payload : Some (payload) , } }) . ok_or_else (|| DataErrorKind :: MissingLocale . with_req (:: icu_segmenter :: provider :: SentenceBreakDataV1Marker :: KEY , req)) } } impl DataProvider < :: icu_segmenter :: provider :: WordBreakDataV1Marker > for $ provider { fn load (& self , req : DataRequest ,) -> Result < DataResponse < :: icu_segmenter :: provider :: WordBreakDataV1Marker > , DataError > { segmenter :: word_v1 :: lookup (& req . locale) . map (zerofrom :: ZeroFrom :: zero_from) . map (DataPayload :: from_owned) . map (| payload | { DataResponse { metadata : Default :: default () , payload : Some (payload) , } }) . ok_or_else (|| DataErrorKind :: MissingLocale . with_req (:: icu_segmenter :: provider :: WordBreakDataV1Marker :: KEY , req)) } } } } # [doc = r" Implement [`AnyProvider`] on the given struct using the data"] # [doc = r" hardcoded in this module. This allows the struct to be used with"] # [doc = r" `icu`'s `_any` constructors."] # [doc = r""] # [doc = r" This macro can only be called from its definition-site, i.e. right"] # [doc = r" after `include!`-ing the generated module."] # [doc = r" "] # [doc = r" ```compile_fail"] # [doc = r" struct MyAnyProvider;"] # [doc = r#" include!("/path/to/generated/mod.rs");"#] # [doc = r" impl_any_provider(MyAnyProvider);"] # [doc = r" ```"] # [allow (unused_macros)] macro_rules ! impl_any_provider { ($ provider : path) => { impl AnyProvider for $ provider { fn load_any (& self , key : DataKey , req : DataRequest) -> Result < AnyResponse , DataError > { const DICTIONARYFORWORDONLYAUTOV1MARKER : :: icu_provider :: DataKeyHash = :: icu_segmenter :: provider :: DictionaryForWordOnlyAutoV1Marker :: KEY . hashed () ; const GRAPHEMECLUSTERBREAKDATAV1MARKER : :: icu_provider :: DataKeyHash = :: icu_segmenter :: provider :: GraphemeClusterBreakDataV1Marker :: KEY . hashed () ; const LINEBREAKDATAV1MARKER : :: icu_provider :: DataKeyHash = :: icu_segmenter :: provider :: LineBreakDataV1Marker :: KEY . hashed () ; const LSTMFORWORDLINEAUTOV1MARKER : :: icu_provider :: DataKeyHash = :: icu_segmenter :: provider :: LstmForWordLineAutoV1Marker :: KEY . hashed () ; const SENTENCEBREAKDATAV1MARKER : :: icu_provider :: DataKeyHash = :: icu_segmenter :: provider :: SentenceBreakDataV1Marker :: KEY . hashed () ; const WORDBREAKDATAV1MARKER : :: icu_provider :: DataKeyHash = :: icu_segmenter :: provider :: WordBreakDataV1Marker :: KEY . hashed () ; match key . hashed () { DICTIONARYFORWORDONLYAUTOV1MARKER => segmenter :: dictionary :: w_auto_v1 :: lookup (& req . locale) . map (AnyPayload :: from_static_ref) , GRAPHEMECLUSTERBREAKDATAV1MARKER => segmenter :: grapheme_v1 :: lookup (& req . locale) . map (AnyPayload :: from_static_ref) , LINEBREAKDATAV1MARKER => segmenter :: line_v1 :: lookup (& req . locale) . map (AnyPayload :: from_static_ref) , LSTMFORWORDLINEAUTOV1MARKER => segmenter :: lstm :: wl_auto_v1 :: lookup (& req . locale) . map (AnyPayload :: from_static_ref) , SENTENCEBREAKDATAV1MARKER => segmenter :: sentence_v1 :: lookup (& req . locale) . map (AnyPayload :: from_static_ref) , WORDBREAKDATAV1MARKER => segmenter :: word_v1 :: lookup (& req . locale) . map (AnyPayload :: from_static_ref) , _ => return Err (DataErrorKind :: MissingDataKey . with_req (key , req)) , } . map (| payload | AnyResponse { payload : Some (payload) , metadata : Default :: default () , }) . ok_or_else (|| DataErrorKind :: MissingLocale . with_req (key , req)) } } } } pub struct BakedDataProvider ; impl_data_provider ! (BakedDataProvider) ;