<!DOCTYPE html>
<meta charset="utf-8" />

<title>Canvas2D test: CaptureStream() with throttled rAF</title>

<script src="/tests/SimpleTest/SimpleTest.js"></script>
<script src="captureStream_common.js"></script>
<link rel="stylesheet" href="/tests/SimpleTest/test.css" />
<script>
SimpleTest.waitForExplicitFinish();
SimpleTest.requestFlakyTimeout(
  "Ensuring nothing happens until timing out with good margin"
);

// CaptureStreamTestHelper holding utility test functions.
const h = new CaptureStreamTestHelper2D();

async function measureRequestAnimationFrameRate() {
  const start = await new Promise(r => requestAnimationFrame(r));
  for (let count = 1; ; count++) {
    const time = await new Promise(r => requestAnimationFrame(r));
    if (time - start > 1000) {
      // One second has passed, break.
      return count / ((time - start) / 1000);
    }
  }
}

async function measureSetTimeoutRate() {
  // The average isn't accurate at low counts.
  const COUNT = 25;
  const start = performance.now();
  for (let i = 0; i < COUNT; ++i) {
    await new Promise(resolve => setTimeout(resolve, 0));
  }
  return COUNT / ((performance.now() - start) / 1000);
}

async function measureCanvasCaptureFrameRate(captureRate) {
  // Canvas element captured by streams.
  const c = h.createAndAppendElement("canvas", "c");

  // Since we are in a background tab, the video element won't get composited,
  // so we cannot look for a frame count there. Instead we use RTCPeerConnection
  // and RTCOutboundRtpStreamStats.framesEncoded.
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();

  // Add the canvas.captureStream track.
  const ctx = c.getContext("2d");
  const [track] = c.captureStream(captureRate).getTracks();
  const sender = pc1.addTrack(track);

  // Ice candidates signaling
  pc1.onicecandidate = e => pc2.addIceCandidate(e.candidate);
  pc2.onicecandidate = e => pc1.addIceCandidate(e.candidate);

  // Offer/Answer exchange
  await pc1.setLocalDescription();
  await pc2.setRemoteDescription(pc1.localDescription);
  await pc2.setLocalDescription();
  await pc1.setRemoteDescription(pc2.localDescription);

  // Wait for RTP packets to arrive.
  const event = await new Promise(r => pc2.ontrack = r);
  await new Promise(r => event.track.onunmute = r);

  // Draw to the canvas
  const intervalMillis = 1000 / 60;
  const getFrameCount = async () => {
    const stats = await sender.getStats();
    const outbound = [...stats.values()].find(
      ({ type }) => type == "outbound-rtp"
    );
    return outbound?.framesEncoded ?? 0; // See bug 1789768.
  };
  is(await getFrameCount(), 0, "frame count starts at 0");
  const start = performance.now();
  let end;
  do {
    h.drawColor(c, h.green);
    await new Promise(resolve => setTimeout(resolve, intervalMillis));
    end = performance.now();
  } while (end - start <= 1000);
  const framerate = (await getFrameCount()) / ((end - start) / 1000);
  pc1.close();
  pc2.close();
  return framerate;
}

(async () => {
  // Disable background timer throttling so we can use setTimeout to draw to the
  // canvas while the refresh driver is throttled.
  await SpecialPowers.pushPrefEnv({
    set: [
      ["dom.timeout.enable_budget_timer_throttling", false],
      ["dom.min_background_timeout_value", 0],
      ["dom.min_background_timeout_value_without_budget_throttling", 0],
      ["browser.link.open_newwindow", 3], // window.open in new tab
    ],
  });
  // Throttle the canvas' refresh driver by opening a new foreground tab
  const foregroundTab = window.open("about:blank");

  // Let the throttling take effect
  await new Promise(r => setTimeout(r, 500));

  const rAFRate = await measureRequestAnimationFrameRate();
  ok(rAFRate < 5, `rAF framerate is at ${rAFRate} fps`);

  const setTimeoutRate = await measureSetTimeoutRate();
  ok(setTimeoutRate > 30, `setTimeout rate is at ${setTimeoutRate} tps`);

  const autoRate = await measureCanvasCaptureFrameRate();
  ok(autoRate > 5, `captureStream() framerate is at ${autoRate} fps`);

  const cappedRate = await measureCanvasCaptureFrameRate(10);
  ok(cappedRate > 5, `captureStream(10) framerate is at ${cappedRate} fps`);

  foregroundTab.close();
  SimpleTest.finish();
})();
</script>
