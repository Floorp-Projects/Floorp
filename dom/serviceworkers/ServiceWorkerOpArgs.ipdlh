/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

include ChannelInfo;
include ClientIPCTypes;
include DOMTypes;
include FetchTypes;

include "mozilla/dom/ServiceWorkerIPCUtils.h";

using ServiceWorkerState from "mozilla/dom/ServiceWorkerBinding.h";
using mozilla::TimeStamp from "mozilla/TimeStamp.h";

namespace mozilla {
namespace dom {

/**
 * ServiceWorkerOpArgs
 */
struct ServiceWorkerCheckScriptEvaluationOpArgs {};

struct ServiceWorkerUpdateStateOpArgs {
  ServiceWorkerState state;
};

struct ServiceWorkerTerminateWorkerOpArgs {
  uint32_t shutdownStateId;
};

struct ServiceWorkerLifeCycleEventOpArgs {
  nsString eventName;
};

// Possibly need to differentiate an empty array from the absence of an array.
union OptionalPushData {
  void_t;
  uint8_t[];
};

struct ServiceWorkerPushEventOpArgs {
  nsString messageId;
  OptionalPushData data;
};

struct ServiceWorkerPushSubscriptionChangeEventOpArgs {};

struct ServiceWorkerNotificationEventOpArgs {
  nsString eventName;
  nsString id;
  nsString title;
  nsString dir;
  nsString lang;
  nsString body;
  nsString tag;
  nsString icon;
  nsString data;
  nsString behavior;
  nsString scope;
  uint32_t disableOpenClickDelay;
};

struct ServiceWorkerExtensionAPIEventOpArgs {
  // WebExtensions API namespace and event names, for a list of the API namespaces
  // and related API event names refer to the API JSONSchema files in-tree:
  //
  // https://searchfox.org/mozilla-central/search?q=&path=extensions%2Fschemas%2F*.json
  nsString apiNamespace;
  nsString apiEventName;
};

struct ServiceWorkerMessageEventOpArgs {
  ClientInfoAndState clientInfoAndState;
  ClonedOrErrorMessageData clonedData;
};

struct ServiceWorkerFetchEventOpArgsCommon {
  nsCString workerScriptSpec;
  IPCInternalRequest internalRequest;
  nsString clientId;
  nsString resultingClientId;
  bool isNonSubresourceRequest;
  // Is navigation preload enabled for this fetch? If true, if some
  // preloadResponse was not already provided in this structure, then it's
  // expected that a PreloadResponse message will eventually be sent.
  bool preloadNavigation;
  // Failure injection helper; non-NS_OK values indicate that the event, instead
  // of dispatching should instead return a `CancelInterceptionArgs` response
  // with this nsresult.  This value originates from
  // `nsIServiceWorkerInfo::testingInjectCancellation`.
  nsresult testingInjectCancellation;
};

struct ParentToParentServiceWorkerFetchEventOpArgs {
  ServiceWorkerFetchEventOpArgsCommon common;
  ParentToParentResponseWithTiming? preloadResponse;
};

struct ParentToChildServiceWorkerFetchEventOpArgs {
  ServiceWorkerFetchEventOpArgsCommon common;
  ParentToChildResponseWithTiming? preloadResponse;
};

union ServiceWorkerOpArgs {
  ServiceWorkerCheckScriptEvaluationOpArgs;
  ServiceWorkerUpdateStateOpArgs;
  ServiceWorkerTerminateWorkerOpArgs;
  ServiceWorkerLifeCycleEventOpArgs;
  ServiceWorkerPushEventOpArgs;
  ServiceWorkerPushSubscriptionChangeEventOpArgs;
  ServiceWorkerNotificationEventOpArgs;
  ServiceWorkerMessageEventOpArgs;
  ServiceWorkerExtensionAPIEventOpArgs;
  ParentToChildServiceWorkerFetchEventOpArgs;
};

/**
 * IPCFetchEventRespondWithResult
 */
struct FetchEventRespondWithClosure {
  nsCString respondWithScriptSpec;
  uint32_t respondWithLineNumber;
  uint32_t respondWithColumnNumber;
};

struct FetchEventTimeStamps {
  TimeStamp fetchHandlerStart;
  TimeStamp fetchHandlerFinish;
};

struct ChildToParentSynthesizeResponseArgs {
  ChildToParentInternalResponse internalResponse;
  FetchEventRespondWithClosure closure;
  FetchEventTimeStamps timeStamps;
};

struct ParentToParentSynthesizeResponseArgs {
  ParentToParentInternalResponse internalResponse;
  FetchEventRespondWithClosure closure;
  FetchEventTimeStamps timeStamps;
};

struct ResetInterceptionArgs {
  FetchEventTimeStamps timeStamps;
};

struct CancelInterceptionArgs {
  nsresult status;
  FetchEventTimeStamps timeStamps;
};

union ChildToParentFetchEventRespondWithResult {
  ChildToParentSynthesizeResponseArgs;
  ResetInterceptionArgs;
  CancelInterceptionArgs;
};

union ParentToParentFetchEventRespondWithResult {
  ParentToParentSynthesizeResponseArgs;
  ResetInterceptionArgs;
  CancelInterceptionArgs;
};

/**
 * ServiceWorkerOpResult
 */
struct ServiceWorkerCheckScriptEvaluationOpResult {
  bool workerScriptExecutedSuccessfully;
  bool fetchHandlerWasAdded;
};

struct ServiceWorkerFetchEventOpResult {
  nsresult rv;
};

struct ServiceWorkerExtensionAPIEventOpResult {
  bool extensionAPIEventListenerWasAdded;
};

union ServiceWorkerOpResult {
  nsresult;
  ServiceWorkerCheckScriptEvaluationOpResult;
  ServiceWorkerFetchEventOpResult;
  ServiceWorkerExtensionAPIEventOpResult;
};

}  // namespace dom
}  // namespace mozilla
