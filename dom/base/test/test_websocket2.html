<!DOCTYPE HTML>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"></meta>
  <title>WebSocket test</title>
  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
  <script type="text/javascript" src="websocket_helpers.js"></script>
  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
</head>
<body onload="testWebSocket()">
<script class="testbody" type="text/javascript">

function test11() {
  return new Promise(function(resolve, reject) {
    var ws = CreateTestWS("ws://mochi.test:8888/tests/dom/base/test/file_websocket", "test-11");
    is(ws.readyState, 0, "create bad readyState in test-11!");

    ws.onopen = function() {
      is(ws.readyState, 1, "open bad readyState in test-11!");
      ws.send("client data");
    }

    ws.onmessage = function(e) {
      is(e.data, "server data", "bad received message in test-11!");
      ws.close(1000, "Have a nice day");

     // this ok() is disabled due to a race condition - it state may have
     // advanced through 2 (closing) and into 3 (closed) before it is evald
     // ok(ws.readyState == 2, "onmessage bad readyState in test-11!");
    }

    ws.onclose = function(e) {
      is(ws.readyState, 3, "onclose bad readyState in test-11!");
      shouldCloseCleanly(e);
      is(e.code, 1000, "test 11 got wrong close code: " + e.code);
      is(e.reason, "Have a nice day", "test 11 got wrong close reason: " + e.reason);
      resolve();
    }
  });
}

function test12() {
  return new Promise(function(resolve, reject) {
    var ws = CreateTestWS("ws://mochi.test:8888/tests/dom/base/test/file_websocket", "test-12");

    ws.onopen = function() {
      try {
        // send an unpaired surrogate
        ws._gotMessage = false;
        ws.send("a\ud800b");
        ok(true, "ok to send an unpaired surrogate");
      } catch (e) {
        ok(false, "shouldn't fail any more when sending an unpaired surrogate!");
      }
    }

    ws.onmessage = function(msg) {
      is(msg.data, "SUCCESS", "Unpaired surrogate in UTF-16 not converted in test-12");
      ws._gotMessage = true;
      // Must support unpaired surrogates in close reason, too
      ws.close(1000, "a\ud800b");
    }

    ws.onclose = function(e) {
      is(ws.readyState, 3, "onclose bad readyState in test-12!");
      ok(ws._gotMessage, "didn't receive message!");
      shouldCloseCleanly(e);
      is(e.code, 1000, "test 12 got wrong close code: " + e.code);
      is(e.reason, "a\ufffdb", "test 11 didn't get replacement char in close reason: " + e.reason);
      resolve();
    }
  });
}

function test13() {
  return new Promise(function(resolve, reject) {
    // previous versions of this test counted the number of protocol errors
    // returned, but the protocol stack typically closes down after reporting a
    // protocol level error - trying to resync is too dangerous

    var ws = CreateTestWS("ws://mochi.test:8888/tests/dom/base/test/file_websocket", "test-13");
    ws._timesCalledOnError = 0;

    ws.onerror = function() {
      ws._timesCalledOnError++;
    }

    ws.onclose = function(e) {
      ok(ws._timesCalledOnError > 0, "no error events");
      resolve();
    }
  });
}

function test14() {
  return new Promise(function(resolve, reject) {
    var ws = CreateTestWS("ws://mochi.test:8888/tests/dom/base/test/file_websocket", "test-14");

    ws.onmessage = function() {
      ok(false, "shouldn't received message after the server sent the close frame");
    }

    ws.onclose = function(e) {
      shouldCloseCleanly(e);
      resolve();
    };
  });
}

function test15() {
  return new Promise(function(resolve, reject) {
    /*
     * DISABLED: see comments for test-15 case in file_websocket_wsh.py
     */
   resolve();

    var ws = CreateTestWS("ws://mochi.test:8888/tests/dom/base/test/file_websocket", "test-15");
    ws.onclose = function(e) {
      shouldCloseNotCleanly(e);
      resolve();
    }

    // termination of the connection might cause an error event if it happens in OPEN
    ws.onerror = function() {
    }
  });
}

function test16() {
  return new Promise(function(resolve, reject) {
    var ws = CreateTestWS("ws://mochi.test:8888/tests/dom/base/test/file_websocket", "test-16");

    ws.onopen = function() {
      ws.close();
      ok(!ws.send("client data"), "shouldn't send message after calling close()");
    }

    ws.onmessage = function() {
      ok(false, "shouldn't send message after calling close()");
    }

    ws.onerror = function() {
    }

    ws.onclose = function() {
      resolve();
    }
  });
}

function test17() {
  return new Promise(function(resolve, reject) {
    var status_test17 = "not started";

    var test17func = function() {
      var local_ws = new WebSocket("ws://sub1.test2.example.org/tests/dom/base/test/file_websocket", "test-17");
      status_test17 = "started";

      local_ws.onopen = function(e) {
        status_test17 = "opened";
        e.target.send("client data");
        forcegc();
      };

      local_ws.onerror = function() {
        ok(false, "onerror called on test " + current_test + "!");
      };

      local_ws.onmessage = function(e) {
        ok(e.data == "server data", "Bad message in test-17");
        status_test17 = "got message";
        forcegc();
      };

      local_ws.onclose = function(e) {
        ok(status_test17 == "got message", "Didn't got message in test-17!");
        shouldCloseCleanly(e);
        status_test17 = "closed";
        forcegc();
        resolve();
      };

      window._test17 = null;
      forcegc();
    }

    window._test17 = test17func;
    window._test17();
  });
}

// The tests that expects that their websockets neither open nor close MUST
// be in the end of the tests, i.e. HERE, in order to prevent blocking the other
// tests.

function test18() {
  return new Promise(function(resolve, reject) {
    var ws = CreateTestWS("ws://mochi.test:8888/tests/dom/base/test/file_websocket_http_resource.txt");
    ws.onopen = shouldNotOpen;
    ws.onerror = ignoreError;
    ws.onclose = function(e)
    {
      shouldCloseNotCleanly(e);
      resolve();
    }
  });
}

function test19() {
  return new Promise(function(resolve, reject) {
    var ws = CreateTestWS("ws://mochi.test:8888/tests/dom/base/test/file_websocket", "test-19");
    ws.onopen = shouldNotOpen;
    ws.onerror = ignoreError;
    ws.onclose = function(e)
    {
      shouldCloseNotCleanly(e);
      resolve();
    }
  });
}

function test20() {
  return new Promise(function(resolve, reject) {
    var test20func = function() {
      var local_ws = new WebSocket("ws://sub1.test1.example.org/tests/dom/base/test/file_websocket", "test-20");

      local_ws.onerror = function() {
        ok(false, "onerror called on test " + current_test + "!");
      }

      local_ws.onclose = function(e) {
        ok(true, "test 20 closed despite gc");
        resolve();
      }

      local_ws = null;
      window._test20 = null;
      forcegc();
    }

    window._test20 = test20func;
    window._test20();
  });
}

var tests = [
  test11, // a simple hello echo;
  test12, // client sends a message containing unpaired surrogates
  test13, //server sends an invalid message;
  test14, // server sends the close frame, it doesn't close the tcp connection
          // and it keeps sending normal ws messages;
  test15, // server closes the tcp connection, but it doesn't send the close
          // frame;
  test16, // client calls close() and tries to send a message;
  test17, // see bug 572975 - all event listeners set
  test18, // client tries to connect to an http resource;
  test19, // server closes the tcp connection before establishing the ws
          // connection;
  test20, // see bug 572975 - only on error and onclose event listeners set
];

function testWebSocket() {
  doTest();
}

</script>

<div id="feedback">
</div>

</body>
</html>
