<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Test for DOMWindowUtils</title>
  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
</head>
<body>
<div id="content" style="display: none"></div>
<pre id="test">
<script type="application/javascript">
SimpleTest.waitForExplicitFinish();

var utils = SpecialPowers.getDOMWindowUtils(window);
function test_sendMouseEventDefaults() {
  var x = 1, y = 2, button = 1, clickCount = 2,
      modifiers = SpecialPowers.Ci.nsIDOMNSEvent.SHIFT_MASK;

  window.addEventListener("mousedown", function(evt) {
    // Mandatory args
    // coordinates may change slightly due to rounding
    ok((evt.clientX <= x+2) && (evt.clientX >= x-2), "check x");
    ok((evt.clientY <= y+2) && (evt.clientY >= y-2), "check y");
    is(evt.button, button, "check button");
    is(evt.detail, clickCount, "check click count");
    is(evt.getModifierState("Shift"), true, "check modifiers");

    // Default value for optionals
    is(evt.mozPressure, 0, "check pressure");
    is(evt.mozInputSource, SpecialPowers.Ci.nsIDOMMouseEvent.MOZ_SOURCE_MOUSE, "check input source");
    is(evt.isSynthesized, undefined, "check isSynthesized is undefined in content");
    is(SpecialPowers.wrap(evt).isSynthesized, true, "check isSynthesized is true from chrome");
    SimpleTest.executeSoon(next);
  }, {once: true});

  // Only pass mandatory arguments and check default values
  utils.sendMouseEvent("mousedown", x, y, button, clickCount, modifiers);
}

function test_sendMouseEventOptionals() {
  var x = 1, y = 2, button = 1, clickCount = 3,
      modifiers = SpecialPowers.Ci.nsIDOMNSEvent.SHIFT_MASK,
      pressure = 0.5,
      source = SpecialPowers.Ci.nsIDOMMouseEvent.MOZ_SOURCE_KEYBOARD;

  window.addEventListener("mouseup", function(evt) {
    is(evt.mozInputSource, source, "explicit input source is valid");
    is(SpecialPowers.wrap(evt).isSynthesized, false, "we can dispatch event that don't look synthesized");
    SimpleTest.executeSoon(next);
  }, {once: true});

  // Check explicit value for optional args
  utils.sendMouseEvent("mouseup", x, y, button, clickCount, modifiers,
                       false, pressure, source, false);
}

function test_getAnimationType() {
  [
    {
      propertyName: "align-content",
      expectedType: "discrete"
    },
    {
      propertyName: "animation-delay",
      expectedType: "none"
    },
    {
      propertyName: "background-color",
      expectedType: "color"
    },
    {
      propertyName: "background-size",
      expectedType: "custom"
    },
    {
      propertyName: "border-bottom-left-radius",
      expectedType: "coord"
    },
    {
      propertyName: "border-bottom-right-radius",
      expectedType: "coord"
    },
    {
      propertyName: "border-top-left-radius",
      expectedType: "coord"
    },
    {
      propertyName: "border-top-right-radius",
      expectedType: "coord"
    },
    {
      propertyName: "font-size",
      expectedType: "length"
    },
    {
      propertyName: "margin-top",
      expectedType: "coord"
    },
    {
      propertyName: "margin-right",
      expectedType: "coord"
    },
    {
      propertyName: "margin-bottom",
      expectedType: "coord"
    },
    {
      propertyName: "margin-left",
      expectedType: "coord"
    },
    {
      propertyName: "opacity",
      expectedType: "float"
    },
    {
      propertyName: "stroke",
      expectedType: "paintServer"
    },
    {
      propertyName: "text-shadow",
      expectedType: "shadow"
    },
    {
      propertyName: "transform",
      expectedType: "custom"
    },
    {
      propertyName: "visibility",
      expectedType: "discrete"
    },
    {
      propertyName: "width",
      expectedType: "coord"
    }
  ].forEach(({ propertyName, expectedType }) => {
    is(utils.getAnimationTypeForLonghand(propertyName), expectedType,
       `Animation type should be ${ expectedType }`);
  });

  SimpleTest.doesThrow(
    () => utils.getAnimationTypeForLonghand("background"),
    "NS_ERROR_ILLEGAL_VALUE",
    "background property should throw");

  SimpleTest.doesThrow(
    () => utils.getAnimationTypeForLonghand("invalid"),
    "NS_ERROR_ILLEGAL_VALUE",
    "Invalid property should throw");

  next();
}

function test_getUnanimatedComputedStyle() {
  [
    {
      property: "opacity",
      keyframes: [1, 0],
      expectedInitialStyle: "1",
      expectedDuringTransitionStyle: "0",
      isDiscrete: false,
    },
    {
      property: "clear",
      keyframes: ["left", "inline-end"],
      expectedInitialStyle: "none",
      expectedDuringTransitionStyle: "inline-end",
      isDiscrete: true,
    },
  ].forEach(testcase => {
    const { property, keyframes, expectedInitialStyle,
            expectedDuringTransitionStyle, isDiscrete } = testcase;

    [null, "unset", "initial", "inherit"].forEach(initialStyle => {
      const scriptAnimation = target => {
        return target.animate({ [property]: keyframes }, 1000);
      }
      checkUnanimatedComputedStyle(property, initialStyle, null,
                                   expectedInitialStyle, expectedInitialStyle,
                                   scriptAnimation, "script animation");

      const cssAnimationStyle = `@keyframes cssanimation {`
                                + ` from { ${property}: ${ keyframes[0] }; }`
                                + ` to { ${property}: ${ keyframes[1] }; } }`;
      document.styleSheets[0].insertRule(cssAnimationStyle, 0);
      const cssAnimation = target => {
        target.style.animation = "cssanimation 1s";
        return target.getAnimations()[0];
      }
      checkUnanimatedComputedStyle(property, initialStyle, null,
                                   expectedInitialStyle, expectedInitialStyle,
                                   cssAnimation, "CSS Animations");
      document.styleSheets[0].deleteRule(0);

      // We don't support discrete animations for CSS Transitions yet.
      // (bug 1320854)
      if (!isDiscrete) {
        const cssTransition = target => {
          target.style[property] = keyframes[0];
          target.style.transition =
            `${ property } 1s`;
          window.getComputedStyle(target)[property];
          target.style[property] = keyframes[1];
          return target.getAnimations()[0];
        }
        checkUnanimatedComputedStyle(property, initialStyle, null,
                                     expectedInitialStyle,
                                     expectedDuringTransitionStyle,
                                     cssTransition, "CSS Transitions");
      }

      document.styleSheets[0].insertRule(cssAnimationStyle, 0);
      document.styleSheets[0].insertRule(
        ".pseudo::before { animation: cssanimation 1s; }", 0);
      const pseudoAnimation = target => {
        target.classList.add("pseudo");
        return target.getAnimations({ subtree: true })[0];
      }
      checkUnanimatedComputedStyle(property, initialStyle, "::before",
                                   expectedInitialStyle, expectedInitialStyle,
                                   pseudoAnimation, "Animation at pseudo");
      document.styleSheets[0].deleteRule(0);
      document.styleSheets[0].deleteRule(0);
    });
  });

  SimpleTest.doesThrow(
    () => utils.getUnanimatedComputedStyle(div, null, "background"),
    "NS_ERROR_INVALID_ARG",
    "Shorthand property should throw");

  SimpleTest.doesThrow(
    () => utils.getUnanimatedComputedStyle(div, null, "invalid"),
    "NS_ERROR_INVALID_ARG",
    "Invalid property should throw");

  SimpleTest.doesThrow(
    () => utils.getUnanimatedComputedStyle(null, null, "opacity"),
    "NS_ERROR_INVALID_ARG",
    "Null element should throw");

  next();
}

function checkUnanimatedComputedStyle(property, initialStyle, pseudoType,
                                      expectedBeforeAnimation,
                                      expectedDuringAnimation,
                                      animate, animationType) {
  const div = document.createElement("div");
  document.body.appendChild(div);

  if (initialStyle) {
    div.style[property] = initialStyle;
  }

  is(utils.getUnanimatedComputedStyle(div, pseudoType, property),
     expectedBeforeAnimation,
     `'${ property }' property with '${ initialStyle }' style `
     + `should be '${ expectedBeforeAnimation }' `
     + `before animating by ${ animationType }`);

  const animation = animate(div);
  animation.currentTime = 500;
  is(utils.getUnanimatedComputedStyle(div, pseudoType, property),
     expectedDuringAnimation,
     `'${ property }' property with '${ initialStyle }' style `
     + `should be '${ expectedDuringAnimation }' `
     + `even while animating by ${ animationType }`);

  div.remove();
}

var tests = [
  test_sendMouseEventDefaults,
  test_sendMouseEventOptionals,
  test_getAnimationType,
  test_getUnanimatedComputedStyle
];

function next() {
  if (!tests.length) {
    SimpleTest.finish();
    return;
  }

  var test = tests.shift();
  test();
}

function start() {
  SimpleTest.waitForExplicitFinish();
  SimpleTest.executeSoon(next);
}

window.addEventListener("load", start);

</script>
</pre>
</body>
</html>
