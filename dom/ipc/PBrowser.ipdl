/* -*- Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 8 -*- */
/* vim: set sw=4 ts=8 et tw=80 ft=cpp : */

/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Content App.
 *
 * The Initial Developer of the Original Code is
 *   The Mozilla Foundation.
 * Portions created by the Initial Developer are Copyright (C) 2009
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

include protocol PContent;
include protocol PContentDialog;
include protocol PDocumentRenderer;
include protocol PDocumentRendererShmem;
include protocol PDocumentRendererNativeID;
include protocol PContentPermissionRequest;
include protocol PRenderFrame;

include "TabMessageUtils.h";
include "gfxMatrix.h";
include "mozilla/net/NeckoMessageUtils.h";
include "IPC/nsGUIEventIPC.h";

using gfxMatrix;
using IPC::URI;
using nsIntSize;
using nsCompositionEvent;
using nsTextEvent;
using nsQueryContentEvent;
using nsSelectionEvent;
using RemoteDOMEvent;
using nsIMEUpdatePreference;

namespace mozilla {
namespace dom {

rpc protocol PBrowser
{
    manager PContent;

    manages PContentDialog;
    manages PDocumentRenderer;
    manages PDocumentRendererShmem;
    manages PDocumentRendererNativeID;
    manages PContentPermissionRequest;
    manages PRenderFrame;

both:
    AsyncMessage(nsString aMessage, nsString aJSON);

parent:
    /**
     * When child sends this message, parent should move focus to
     * the next or previous focusable element.
     */
    MoveFocus(bool forward);

    Event(RemoteDOMEvent aEvent);

    rpc CreateWindow() returns (PBrowser window);

    sync SyncMessage(nsString aMessage, nsString aJSON)
      returns (nsString[] retval);

    /**
     * Notifies chrome that there is a focus change involving an editable
     * object (input, textarea, document, contentEditable. etc.)
     *
     *  focus        PR_TRUE if editable object is receiving focus
     *               PR_FALSE if losing focus
     *  preference   Native widget preference for IME updates
     */
    sync NotifyIMEFocus(PRBool focus)
      returns (nsIMEUpdatePreference preference);

    /**
     * Notifies chrome that there has been a change in text content
     * One call can encompass both a delete and an insert operation
     * Only called when NotifyIMEFocus returns PR_TRUE for mWantUpdates
     *
     *  offset       Starting offset of the change
     *  end          Ending offset of the range deleted
     *  newEnd       New ending offset after insertion
     *
     *  for insertion, offset == end
     *  for deletion, offset == newEnd
     */
    NotifyIMETextChange(PRUint32 offset, PRUint32 end, PRUint32 newEnd);

    /**
     * Notifies chrome that there has been a change in selection
     * Only called when NotifyIMEFocus returns PR_TRUE for mWantUpdates
     *
     *  anchor       Offset where the selection started
     *  focus        Offset where the caret is
     */
    NotifyIMESelection(PRUint32 anchor, PRUint32 focus);

    /**
     * Notifies chrome to refresh its text cache 
     * Only called when NotifyIMEFocus returns PR_TRUE for mWantHints
     *
     *  text         The entire content of the text field
     */
    NotifyIMETextHint(nsString text);

    /**
     * Instructs chrome to end any pending composition
     *
     *  cancel       PR_TRUE if composition should be cancelled
     *  composition  Text to commit before ending the composition
     *
     *  if cancel is PR_TRUE,
     *    widget should return empty string for composition
     *  if cancel is PR_FALSE,
     *    widget should return the current composition text
     */
    sync EndIMEComposition(PRBool cancel) returns (nsString composition);

    sync GetIMEEnabled() returns (PRUint32 value);

    SetIMEEnabled(PRUint32 value);

    sync GetIMEOpenState() returns (PRBool value);

    SetIMEOpenState(PRBool value);

    PContentPermissionRequest(nsCString aType, URI uri);

    PContentDialog(PRUint32 aType, nsCString aName, nsCString aFeatures,
                   PRInt32[] aIntParams, nsString[] aStringParams);

    /**
     * Create a layout frame (encapsulating a remote layer tree) for
     * the page that is currently loaded in the <browser>.
     */
    async PRenderFrame();

    __delete__();

child:
    /**
     * Notify the remote browser that it has been Show()n on this
     * side, with the given |visibleRect|.  This message is expected
     * to trigger creation of the remote browser's "widget".
     *
     * |Show()| and |Move()| take IntSizes rather than Rects because
     * content processes always render to a virtual <0, 0> top-left
     * point.
     */
    Show(nsIntSize size);

    LoadURL(nsCString uri);

    Move(nsIntSize size);

    /**
     * Sending an activate message moves focus to the child.
     */
    Activate();

    /**
     * @see nsIDOMWindowUtils sendMouseEvent.
     */
    MouseEvent(nsString aType,
               float aX,
               float aY,
               PRInt32 aButton,
               PRInt32 aClickCount,
               PRInt32 aModifiers,
               bool aIgnoreRootScrollFrame);

    /**
     * @see nsIDOMWindowUtils sendKeyEvent.
     */
    KeyEvent(nsString aType,
             PRInt32 aKeyCode,
             PRInt32 aCharCode,
             PRInt32 aModifiers,
             bool aPreventDefault);

    CompositionEvent(nsCompositionEvent event);

    TextEvent(nsTextEvent event);

    SelectionEvent(nsSelectionEvent event);

    /**
     * Activate event forwarding from client to parent.
     */
    ActivateFrameEvent(nsString aType, bool capture);

    LoadRemoteScript(nsString aURL);

    PDocumentRenderer(PRInt32 x, PRInt32 y, PRInt32 w, PRInt32 h, nsString bgcolor, PRUint32 flags, bool flush);

    // @param matrix the transformation matrix the context we're going to draw into should have.
    PDocumentRendererShmem(PRInt32 x, PRInt32 y, PRInt32 w, PRInt32 h, nsString bgcolor, PRUint32 flags, bool flush,
                           gfxMatrix matrix, Shmem buf);

    // @param matrix the transformation matrix the context we're going to draw into should have.
    PDocumentRendererNativeID(PRInt32 x, PRInt32 y, PRInt32 w, PRInt32 h, nsString bgcolor, PRUint32 flags, bool flush,
                              gfxMatrix matrix, PRUint32 nativeID);

    /**
     * Sent by the chrome process when it no longer wants this remote
     * <browser>.  The child side cleans up in response, then
     * finalizing its death by sending back __delete__() to the
     * parent.
     */
    Destroy();

/*
 * FIXME: write protocol!

state LIVE:
    send LoadURL goto LIVE;
//etc.
    send Destroy goto DYING;

state DYING:
    discard send blah;
// etc.
    recv __delete__;
 */
};

}
}
