//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef mozilla_plugins_NPPProtocolChild_h
#define mozilla_plugins_NPPProtocolChild_h

#include "mozilla/plugins/NPPProtocol.h"
#include "mozilla/ipc/RPCChannel.h"

namespace mozilla {
namespace plugins {


class /*NS_ABSTRACT_CLASS*/ NPPProtocolChild :
    public mozilla::ipc::RPCChannel::Listener
{
    friend class NPAPIProtocolChild;

protected:
    typedef mozilla::ipc::String String;
    typedef mozilla::ipc::StringArray StringArray;

    virtual nsresult AnswerNPP_SetWindow(
                const NPWindow& window,
                NPError* rv) = 0;
    virtual nsresult AnswerNPP_GetValue(
                const String& key,
                String* value) = 0;

private:
    typedef IPC::Message Message;
    typedef mozilla::ipc::RPCChannel Channel;

public:
    NPPProtocolChild()
    {
    }

    virtual ~NPPProtocolChild()
    {
    }

    nsresult CallNPN_GetValue(
                const String& key,
                String* value)
    {
        Message __reply;
        Message* __msg;
        __msg = new NPPProtocol::Msg_NPN_GetValue(key);
        __msg->set_routing_id(mPeerId);
        if (!(mChannel->Call(__msg, &(__reply)))) {
            return NS_ERROR_FAILURE;
        }
        if (!(NPPProtocol::Reply_NPN_GetValue::Read(&(__reply), value))) {
            return NS_ERROR_ILLEGAL_VALUE;
        }
        return NS_OK;
    }

    virtual Result OnMessageReceived(const Message& msg)
    {
        switch (msg.type()) {
        default:
            {
                return MsgNotKnown;
            }
        }
    }

    virtual Result OnMessageReceived(
                const Message& msg,
                Message*& reply)
    {
        switch (msg.type()) {
        default:
            {
                return MsgNotKnown;
            }
        }
    }

    virtual Result OnCallReceived(
                const Message& msg,
                Message*& reply)
    {
        switch (msg.type()) {
        case NPPProtocol::Msg_NPP_SetWindow__ID:
            {
                NPWindow window;
                NPError rv;

                if (!(NPPProtocol::Msg_NPP_SetWindow::Read(&(msg), &(window)))) {
                    return MsgPayloadError;
                }
                if (NS_FAILED(AnswerNPP_SetWindow(window, &(rv)))) {
                    return MsgValueError;
                }

                reply = new NPPProtocol::Reply_NPP_SetWindow(rv);
                reply->set_reply();
                return MsgProcessed;
            }
        case NPPProtocol::Msg_NPP_GetValue__ID:
            {
                String key;
                String value;

                if (!(NPPProtocol::Msg_NPP_GetValue::Read(&(msg), &(key)))) {
                    return MsgPayloadError;
                }
                if (NS_FAILED(AnswerNPP_GetValue(key, &(value)))) {
                    return MsgValueError;
                }

                reply = new NPPProtocol::Reply_NPP_GetValue(value);
                reply->set_reply();
                return MsgProcessed;
            }
        default:
            {
                return MsgNotKnown;
            }
        }
    }

private:
    Channel* mChannel;
    int mId;
    int mPeerId;
    mozilla::ipc::IProtocolManager* mManager;
};


} // namespace plugins
} // namespace mozilla

#endif // ifndef mozilla_plugins_NPPProtocolChild_h
