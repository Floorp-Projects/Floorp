/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include "nsISupports.idl"

/**
 * nsIDOMWindowUtils is intended for infrequently-used methods related
 * to the current nsIDOMWindow.  Some of the methods may require
 * elevated privileges; the method implementations should contain the
 * necessary security checks.  Access this interface by calling
 * getInterface on a DOMWindow.
 */

%{C++
#include "nsColor.h"
#include "nsRect.h"
#include "gfxContext.h"
%}

[ref] native nsConstRect(const nsRect);
native nscolor(nscolor);
[ptr] native gfxContext(gfxContext);
typedef unsigned long long nsViewID;

interface nsICycleCollectorListener;
interface nsIDOMNode;
interface nsIDOMNodeList;
interface nsIDOMElement;
interface nsIDOMHTMLCanvasElement;
interface nsIDOMEvent;
interface nsITransferable;
interface nsIQueryContentEventResult;
interface nsIDOMWindow;
interface nsIDOMBlob;
interface nsIDOMFile;
interface nsIFile;
interface nsIDOMTouch;
interface nsIDOMClientRect;
interface nsIURI;

[scriptable, uuid(C98B7275-93C4-4EAD-B7CF-573D872C1071)]
interface nsIDOMWindowUtils : nsISupports {

  /**
   * Image animation mode of the window. When this attribute's value
   * is changed, the implementation should set all images in the window
   * to the given value. That is, when set to kDontAnimMode, all images
   * will stop animating. The attribute's value must be one of the
   * animationMode values from imgIContainer.
   * @note Images may individually override the window's setting after
   *       the window's mode is set. Therefore images given different modes
   *       since the last setting of the window's mode may behave
   *       out of line with the window's overall mode.
   * @note The attribute's value is the window's overall mode. It may
   *       for example continue to report kDontAnimMode after all images
   *       have subsequently been individually animated.
   * @note Only images immediately in this window are affected;
   *       this is not recursive to subwindows.
   * @see imgIContainer
   */
  attribute unsigned short imageAnimationMode;

  /**
   * Whether the charset of the window's current document has been forced by
   * the user.
   * Cannot be accessed from unprivileged context (not content-accessible)
   */
  readonly attribute boolean docCharsetIsForced;

  /**
   * Get current cursor type from this window
   * @return the current value of nsCursor
   */
  short getCursorType();

  /**
   * Function to get metadata associated with the window's current document
   * @param aName the name of the metadata.  This should be all lowercase.
   * @return the value of the metadata, or the empty string if it's not set
   *
   * Will throw a DOM security error if called without chrome privileges.
   */
  AString getDocumentMetadata(in AString aName);

  /**
   * Force an immediate redraw of this window.  The parameter specifies
   * the number of times to redraw, and the return value is the length,
   * in milliseconds, that the redraws took.  If aCount is not specified
   * or is 0, it is taken to be 1.
   */
  unsigned long redraw([optional] in unsigned long aCount);

  /**
   * Set the CSS viewport to be |widthPx| x |heightPx| in units of CSS
   * pixels, regardless of the size of the enclosing widget/view.
   * This will trigger reflow.
   *
   * The caller of this method must have chrome privileges.
   */
  void setCSSViewport(in float aWidthPx, in float aHeightPx);

  /**
   * Information retrieved from the <meta name="viewport"> tag.
   * See nsContentUtils::GetViewportInfo for more information.
   */
  void getViewportInfo(in uint32_t aDisplayWidth, in uint32_t aDisplayHeight,
                       out double aDefaultZoom, out boolean aAllowZoom,
                       out double aMinZoom, out double aMaxZoom,
                       out uint32_t aWidth, out uint32_t aHeight,
                       out boolean aAutoSize);

  /**
   * For any scrollable element, this allows you to override the
   * visible region and draw more than what is visible, which is
   * useful for asynchronous drawing. The "displayport" will be
   * <xPx, yPx, widthPx, heightPx> in units of CSS pixels,
   * regardless of the size of the enclosing container.  This
   * will *not* trigger reflow.
   *
   * For the root scroll area, pass in the root document element.
   * For scrollable elements, pass in the container element (for
   * instance, the element with overflow: scroll).
   *
   * <x, y> is relative to the top-left of what would normally be
   * the visible area of the element. This means that the pixels
   * rendered to the displayport take scrolling into account,
   * for example.
   *
   * It's legal to set a displayport that extends beyond the overflow
   * area in any direction (left/right/top/bottom).
   *
   * It's also legal to set a displayport that extends beyond the
   * area's bounds.  No pixels are rendered outside the area bounds.
   *
   * The caller of this method must have chrome privileges.
   *
   * Calling this will always force a recomposite, so it should be
   * avoided if at all possible. Client code should do checks before
   * calling this so that duplicate sets are not made with the same
   * displayport.
   */
  void setDisplayPortForElement(in float aXPx, in float aYPx,
                                in float aWidthPx, in float aHeightPx,
                                in nsIDOMElement aElement);

  /**
   * When a display port is set, this allows a sub-section of that
   * display port to be marked as 'critical'. In this scenario, the
   * area outside of this rectangle may be rendered at a lower
   * detail (for example, by reducing its resolution), or not rendered
   * at all under some circumstances.
   * This call will have no effect if a display port has not been set.
   */
  void setCriticalDisplayPortForElement(in float aXPx, in float aYPx,
                                        in float aWidthPx, in float aHeightPx,
                                        in nsIDOMElement aElement);

  /**
   * Get/set the resolution at which rescalable web content is drawn.
   * Currently this is only (some) thebes content.
   *
   * Setting a new resolution does *not* trigger reflow.  This API is
   * entirely separate from textZoom and fullZoom; a resolution scale
   * can be applied together with both textZoom and fullZoom.
   *
   * The effect of is API for gfx code to allocate more or fewer
   * pixels for rescalable content by a factor of |resolution| in
   * either or both dimensions.  setResolution() together with
   * setDisplayport() can be used to implement a non-reflowing
   * scale-zoom in concert with another entity that can draw with a
   * scale.  For example, to scale a content |window| inside a
   * <browser> by a factor of 2.0
   *
   *   window.setDisplayport(x, y, oldW / 2.0, oldH / 2.0);
   *   window.setResolution(2.0, 2.0);
   *   // elsewhere
   *   browser.setViewportScale(2.0, 2.0);
   *
   * The caller of this method must have chrome privileges.
   */
  void setResolution(in float aXResolution, in float aYResolution);

  void getResolution(out float aXResolution, out float aYResolution);

  /**
   * Whether the next paint should be flagged as the first paint for a document.
   * This gives a way to track the next paint that occurs after the flag is
   * set. The flag gets cleared after the next paint.
   *
   * Can only be accessed with chrome privileges.
   */
  attribute boolean isFirstPaint;

  /**
   * Following modifiers are for sent*Event() except sendNative*Event().
   * NOTE: MODIFIER_ALT, MODIFIER_CONTROL, MODIFIER_SHIFT and MODIFIER_META
   *       are must be same values as nsIDOMNSEvent::*_MASK for backward
   *       compatibility.
   */
  const long MODIFIER_ALT        = 0x0001;
  const long MODIFIER_CONTROL    = 0x0002;
  const long MODIFIER_SHIFT      = 0x0004;
  const long MODIFIER_META       = 0x0008;
  const long MODIFIER_ALTGRAPH   = 0x0010;
  const long MODIFIER_CAPSLOCK   = 0x0020;
  const long MODIFIER_FN         = 0x0040;
  const long MODIFIER_NUMLOCK    = 0x0080;
  const long MODIFIER_SCROLLLOCK = 0x0100;
  const long MODIFIER_SYMBOLLOCK = 0x0200;
  const long MODIFIER_OS         = 0x0400;

  /** Synthesize a mouse event. The event types supported are:
   *    mousedown, mouseup, mousemove, mouseover, mouseout, contextmenu
   *
   * Events are sent in coordinates offset by aX and aY from the window.
   *
   * Note that additional events may be fired as a result of this call. For
   * instance, typically a click event will be fired as a result of a
   * mousedown and mouseup in sequence.
   *
   * Normally at this level of events, the mouseover and mouseout events are
   * only fired when the window is entered or exited. For inter-element
   * mouseover and mouseout events, a movemove event fired on the new element
   * should be sufficient to generate the correct over and out events as well.
   *
   * Cannot be accessed from unprivileged context (not content-accessible)
   * Will throw a DOM security error if called without chrome privileges.
   *
   * The event is dispatched via the toplevel window, so it could go to any
   * window under the toplevel window, in some cases it could never reach this
   * window at all.
   *
   * @param aType event type
   * @param aX x offset in CSS pixels
   * @param aY y offset in CSS pixels
   * @param aButton button to synthesize
   * @param aClickCount number of clicks that have been performed
   * @param aModifiers modifiers pressed, using constants defined as MODIFIER_*
   * @param aIgnoreRootScrollFrame whether the event should ignore viewport bounds
   *                           during dispatch
   * @param aPressure touch input pressure: 0.0 -> 1.0
   * @param aInputSourceArg input source, see nsIDOMMouseEvent for values,
   *        defaults to mouse input.
   */
  void sendMouseEvent(in AString aType,
                      in float aX,
                      in float aY,
                      in long aButton,
                      in long aClickCount,
                      in long aModifiers,
                      [optional] in boolean aIgnoreRootScrollFrame,
                      [optional] in float aPressure,
                      [optional] in unsigned short aInputSourceArg);

  /** Synthesize a touch event. The event types supported are:
   *    touchstart, touchend, touchmove, and touchcancel
   *
   * Events are sent in coordinates offset by aX and aY from the window.
   *
   * Cannot be accessed from unprivileged context (not content-accessible)
   * Will throw a DOM security error if called without chrome privileges.
   *
   * The event is dispatched via the toplevel window, so it could go to any
   * window under the toplevel window, in some cases it could never reach this
   * window at all.
   *
   * @param aType event type
   * @param xs array of offsets in CSS pixels for each touch to be sent
   * @param ys array of offsets in CSS pixels for each touch to be sent
   * @param rxs array of radii in CSS pixels for each touch to be sent
   * @param rys array of radii in CSS pixels for each touch to be sent
   * @param rotationAngles array of angles in degrees for each touch to be sent
   * @param forces array of forces (floats from 0 to 1) for each touch to be sent
   * @param count number of touches in this set
   * @param aModifiers modifiers pressed, using constants defined as MODIFIER_*
   * @param aIgnoreRootScrollFrame whether the event should ignore viewport bounds
   *                           during dispatch
   *
   * returns true if the page called prevent default on this touch event
   */
  boolean sendTouchEvent(in AString aType,
                         [array, size_is(count)] in uint32_t aIdentifiers,
                         [array, size_is(count)] in int32_t aXs,
                         [array, size_is(count)] in int32_t aYs,
                         [array, size_is(count)] in uint32_t aRxs,
                         [array, size_is(count)] in uint32_t aRys,
                         [array, size_is(count)] in float aRotationAngles,
                         [array, size_is(count)] in float aForces,
                         in uint32_t count,
                         in long aModifiers,
                         [optional] in boolean aIgnoreRootScrollFrame);

  /** The same as sendMouseEvent but ensures that the event is dispatched to
   *  this DOM window or one of its children.
   */
  void sendMouseEventToWindow(in AString aType,
                              in float aX,
                              in float aY,
                              in long aButton,
                              in long aClickCount,
                              in long aModifiers,
                              [optional] in boolean aIgnoreRootScrollFrame,
                              [optional] in float aPressure,
                              [optional] in unsigned short aInputSourceArg);

  /** Synthesize a wheel event for a window. The event types supported is only
   *  wheel.
   *
   * Events are sent in coordinates offset by aX and aY from the window.
   *
   * Cannot be accessed from unprivileged context (not content-accessible)
   * Will throw a DOM security error if called without chrome privileges.
   *
   * @param aX                 x offset in CSS pixels
   * @param aY                 y offset in CSS pixels
   * @param aDeltaX            deltaX value.
   * @param aDeltaY            deltaY value.
   * @param aDeltaZ            deltaZ value.
   * @param aDeltaMode         deltaMode value which must be one of
   *                           nsIDOMWheelEvent::DOM_DELTA_*.
   * @param aModifiers         modifiers pressed, using constants defined as
   *                           MODIFIER_*
   * @param aLineOrPageDeltaX  If you set this value non-zero for
   *                           DOM_DELTA_PIXEL event, nsEventStateManager will
   *                           dispatch NS_MOUSE_SCROLL event for horizontal
   *                           scroll.
   * @param aLineOrPageDeltaY  If you set this value non-zero for
   *                           DOM_DELTA_PIXEL event, nsEventStateManager will
   *                           dispatch NS_MOUSE_SCROLL event for vertical
   *                           scroll.
   * @param aOptions           Set following flags.
   */
   const unsigned long WHEEL_EVENT_CAUSED_BY_PIXEL_ONLY_DEVICE = 0x0001;
   const unsigned long WHEEL_EVENT_CAUSED_BY_MOMENTUM          = 0x0002;
   const unsigned long WHEEL_EVENT_CUSTOMIZED_BY_USER_PREFS    = 0x0004;
   // If any of the following flags is specified this method will throw an
   // exception in case the relevant overflowDelta has an unexpected value.
   const unsigned long WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_ZERO      = 0x0010;
   const unsigned long WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_POSITIVE  = 0x0020;
   const unsigned long WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_NEGATIVE  = 0x0040;
   const unsigned long WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_ZERO      = 0x0100;
   const unsigned long WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_POSITIVE  = 0x0200;
   const unsigned long WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_NEGATIVE  = 0x0400;
   void sendWheelEvent(in float aX,
                       in float aY,
                       in double aDeltaX,
                       in double aDeltaY,
                       in double aDeltaZ,
                       in unsigned long aDeltaMode,
                       in long aModifiers,
                       in long aLineOrPageDeltaX,
                       in long aLineOrPageDeltaY,
                       in unsigned long aOptions);

  /**
   * Synthesize a key event to the window. The event types supported are:
   *   keydown, keyup, keypress
   *
   * Key events generally end up being sent to the focused node.
   *
   * Cannot be accessed from unprivileged context (not content-accessible)
   * Will throw a DOM security error if called without chrome privileges.
   *
   * @param aType event type
   * @param aKeyCode key code
   * @param aCharCode character code
   * @param aModifiers modifiers pressed, using constants defined as MODIFIER_*
   * @param aAdditionalFlags special flags for the key event, see KEY_FLAG_*.
   *
   * @return false if the event had preventDefault() called on it,
   *               true otherwise.  In other words, true if and only if the
   *               default action was taken.
   */

  // If this is set, preventDefault() the event before dispatch.
  const unsigned long KEY_FLAG_PREVENT_DEFAULT   = 0x0001;

  // if one of these flags is set, the KeyboardEvent.location will be the value.
  // Otherwise, it will be computed from aKeyCode.
  const unsigned long KEY_FLAG_LOCATION_STANDARD = 0x0010;
  const unsigned long KEY_FLAG_LOCATION_LEFT     = 0x0020;
  const unsigned long KEY_FLAG_LOCATION_RIGHT    = 0x0040;
  const unsigned long KEY_FLAG_LOCATION_NUMPAD   = 0x0080;
  const unsigned long KEY_FLAG_LOCATION_MOBILE   = 0x0100;
  const unsigned long KEY_FLAG_LOCATION_JOYSTICK = 0x0200;

  boolean sendKeyEvent(in AString aType,
                       in long aKeyCode,
                       in long aCharCode,
                       in long aModifiers,
                       [optional] in unsigned long aAdditionalFlags);

  /**
   * See nsIWidget::SynthesizeNativeKeyEvent
   *
   * Cannot be accessed from unprivileged context (not content-accessible)
   * Will throw a DOM security error if called without chrome privileges.
   *
   * When you use this for tests, use the constants defined in NativeKeyCodes.js
   */
  void sendNativeKeyEvent(in long aNativeKeyboardLayout,
                          in long aNativeKeyCode,
                          in long aModifierFlags,
                          in AString aCharacters,
                          in AString aUnmodifiedCharacters);

  /**
   * See nsIWidget::SynthesizeNativeMouseEvent
   *
   * Will be called on the widget that contains aElement.
   * Cannot be accessed from unprivileged context (not content-accessible)
   * Will throw a DOM security error if called without chrome privileges.
   */
  void sendNativeMouseEvent(in long aScreenX,
                            in long aScreenY,
                            in long aNativeMessage,
                            in long aModifierFlags,
                            in nsIDOMElement aElement);

  /**
   * See nsIWidget::SynthesizeNativeMouseScrollEvent
   *
   * Will be called on the widget that contains aElement.
   * Cannot be accessed from unprivileged context (not content-accessible)
   * Will throw a DOM security error if called without chrome privileges.
   *
   * NOTE: The synthesized native event may be fired asynchronously.
   *
   * @param aNativeMessage
   *   On Windows:  WM_MOUSEWHEEL (0x020A), WM_MOUSEHWHEEL(0x020E),
   *                WM_VSCROLL (0x0115) or WM_HSCROLL (0x114).
   */
  void sendNativeMouseScrollEvent(in long aScreenX,
                                  in long aScreenY,
                                  in unsigned long aNativeMessage,
                                  in double aDeltaX,
                                  in double aDeltaY,
                                  in double aDeltaZ,
                                  in unsigned long aModifierFlags,
                                  in unsigned long aAdditionalFlags,
                                  in nsIDOMElement aElement);

  /**
   * The values of aAdditionalFlags.
   */

  /**
   * If MOUSESCROLL_PREFER_WIDGET_AT_POINT is set, widget will dispatch
   * the event to a widget which is under the cursor.  Otherwise, dispatch to
   * a default target on the platform.  E.g., on Windows, it's focused window.
   */
  const unsigned long MOUSESCROLL_PREFER_WIDGET_AT_POINT = 0x00000001;

  /**
   * The platform specific values of aAdditionalFlags.  Must be over 0x00010000.
   */

  /**
   * If MOUSESCROLL_WIN_SCROLL_LPARAM_NOT_NULL is set and aNativeMessage is
   * WM_VSCROLL or WM_HSCROLL, widget will set the window handle to the lParam
   * instead of NULL.
   */
  const unsigned long MOUSESCROLL_WIN_SCROLL_LPARAM_NOT_NULL = 0x00010000;

  /**
   * See nsIWidget::ActivateNativeMenuItemAt
   *
   * Cannot be accessed from unprivileged context (not content-accessible)
   * Will throw a DOM security error if called without chrome privileges.
   */
  void activateNativeMenuItemAt(in AString indexString);

  /**
   * See nsIWidget::ForceUpdateNativeMenuAt
   *
   * Cannot be accessed from unprivileged context (not content-accessible)
   * Will throw a DOM security error if called without chrome privileges.
   */
  void forceUpdateNativeMenuAt(in AString indexString);

  /**
   * Focus the element aElement. The element should be in the same document
   * that the window is displaying. Pass null to blur the element, if any,
   * that currently has focus, and focus the document.
   *
   * Cannot be accessed from unprivileged context (not content-accessible)
   * Will throw a DOM security error if called without chrome privileges.
   *
   * @param aElement the element to focus
   *
   * Do not use this method. Just use element.focus if available or
   * nsIFocusManager::SetFocus instead.
   *
   */
  void focus(in nsIDOMElement aElement);

  /**
   * Force a garbage collection followed by a cycle collection.
   *
   * Will throw a DOM security error if called without chrome privileges in
   * non-debug builds. Available to all callers in debug builds.
   *
   * @param aListener listener that receives information about the CC graph
   *                  (see @mozilla.org/cycle-collector-logger;1 for a logger
   *                   component)
   * @param aExtraForgetSkippableCalls indicates how many times
   *                                   nsCycleCollector_forgetSkippable will
   *                                   be called before running cycle collection.
   *                                   -1 prevents the default
   *                                   nsCycleCollector_forgetSkippable call
   *                                   which happens after garbage collection.
   */
  void garbageCollect([optional] in nsICycleCollectorListener aListener,
                      [optional] in long aExtraForgetSkippableCalls);

  /**
   * Force a cycle collection without garbage collection.
   *
   * Will throw a DOM security error if called without chrome privileges in
   * non-debug builds. Available to all callers in debug builds.
   *
   * @param aListener listener that receives information about the CC graph
   *                  (see @mozilla.org/cycle-collector-logger;1 for a logger
   *                   component)
   * @param aExtraForgetSkippableCalls indicates how many times
   *                                   nsCycleCollector_forgetSkippable will
   *                                   be called before running cycle collection.
   *                                   -1 prevents the default
   *                                   nsCycleCollector_forgetSkippable call
   *                                   which happens after garbage collection.
   */
  void cycleCollect([optional] in nsICycleCollectorListener aListener,
                    [optional] in long aExtraForgetSkippableCalls);

  /** Synthesize a simple gesture event for a window. The event types
   *  supported are: MozSwipeGesture, MozMagnifyGestureStart,
   *  MozMagnifyGestureUpdate, MozMagnifyGesture, MozRotateGestureStart,
   *  MozRotateGestureUpdate, MozRotateGesture, MozPressTapGesture,
   *  MozTapGesture, and MozEdgeUIGesture.
   *
   * Cannot be accessed from unprivileged context (not
   * content-accessible) Will throw a DOM security error if called
   * without chrome privileges.
   *
   * @param aType event type
   * @param aX x offset in CSS pixels
   * @param aY y offset in CSS pixels
   * @param aDirection direction, using constants defined in nsIDOMSimpleGestureEvent
   * @param aDelta  amount of magnification or rotation for magnify and rotation events
   * @param aModifiers modifiers pressed, using constants defined in nsIDOMNSEvent
   * @param aClickCount For tap gestures, the number of taps.
   */
  void sendSimpleGestureEvent(in AString aType,
                              in float aX,
                              in float aY,
                              in unsigned long aDirection,
                              in double aDelta,
                              in long aModifiers,
                              [optional] in unsigned long aClickCount);

  /**
   * Retrieve the element at point aX, aY in the window's document.
   *
   * @param aIgnoreRootScrollFrame whether or not to ignore the root scroll
   *        frame when retrieving the element. If false, this method returns
   *        null for coordinates outside of the viewport.
   * @param aFlushLayout flushes layout if true. Otherwise, no flush occurs.
   */
  nsIDOMElement elementFromPoint(in float aX,
                                 in float aY,
                                 in boolean aIgnoreRootScrollFrame,
                                 in boolean aFlushLayout);

  /**
   * Retrieve all nodes that intersect a rect in the window's document.
   *
   * @param aX x reference for the rectangle in CSS pixels
   * @param aY y reference for the rectangle in CSS pixels
   * @param aTopSize How much to expand up the rectangle
   * @param aRightSize How much to expand right the rectangle
   * @param aBottomSize How much to expand down the rectangle
   * @param aLeftSize How much to expand left the rectangle
   * @param aIgnoreRootScrollFrame whether or not to ignore the root scroll
   *        frame when retrieving the element. If false, this method returns
   *        null for coordinates outside of the viewport.
   * @param aFlushLayout flushes layout if true. Otherwise, no flush occurs.
   */
  nsIDOMNodeList nodesFromRect(in float aX,
                               in float aY,
                               in float aTopSize, 
                               in float aRightSize,
                               in float aBottomSize,
                               in float aLeftSize,
                               in boolean aIgnoreRootScrollFrame,
                               in boolean aFlushLayout);

  /**
   * Compare the two canvases, returning the number of differing pixels and
   * the maximum difference in a channel.  This will throw an error if
   * the dimensions of the two canvases are different.
   *
   * This method requires chrome privileges.
   */
  uint32_t compareCanvases(in nsIDOMHTMLCanvasElement aCanvas1,
                           in nsIDOMHTMLCanvasElement aCanvas2,
                           out unsigned long aMaxDifference);

  /**
   * Returns true if a MozAfterPaint event has been queued but not yet
   * fired.
   */
  readonly attribute boolean isMozAfterPaintPending;

  /**
   * Suppresses/unsuppresses user initiated event handling in window's document
   * and subdocuments.
   *
   * @throw NS_ERROR_DOM_SECURITY_ERR if called without chrome privileges and
   *        NS_ERROR_FAILURE if window doesn't have a document.
   */
  void suppressEventHandling(in boolean aSuppress);

  void clearMozAfterPaintEvents();

  /**
   * Disable or enable non synthetic test mouse events on *all* windows.
   *
   * Cannot be accessed from unprivileged context (not content-accessible).
   * Will throw a DOM security error if called without chrome privileges.
   *
   * @param aDisable  If true, disable all non synthetic test mouse events
   *               on all windows.  Otherwise, enable them.
   */
  void disableNonTestMouseEvents(in boolean aDisable);

  /**
   * Returns the scroll position of the window's currently loaded document.
   *
   * @param aFlushLayout flushes layout if true. Otherwise, no flush occurs.
   * @see nsIDOMWindow::scrollX/Y
   */
  void getScrollXY(in boolean aFlushLayout, out long aScrollX, out long aScrollY);

  /**
   * Returns the bounds of the window's currently loaded document. This will
   * generally be (0, 0, pageWidth, pageHeight) but in some cases (e.g. RTL
   * documents) may have a negative left value.
   */
  nsIDOMClientRect getRootBounds();

  /**
   * Get IME open state. TRUE means 'Open', otherwise, 'Close'.
   * This property works only when IMEEnabled is IME_STATUS_ENABLED.
   */
  readonly attribute boolean IMEIsOpen;

  /**
   * WARNING: These values must be same as nsIWidget's values.
   */

  /**
   * DISABLED means users cannot use IME completely.
   * Note that this state is *not* same as |ime-mode: disabled;|.
   */
  const unsigned long IME_STATUS_DISABLED = 0;

  /**
   * ENABLED means users can use all functions of IME. This state is same as
   * |ime-mode: normal;|.
   */
  const unsigned long IME_STATUS_ENABLED  = 1;

  /**
   * PASSWORD means users cannot use most functions of IME. But on GTK2,
   * users can use "Simple IM" which only supports dead key inputting.
   * The behavior is same as the behavior of the native password field.
   * This state is same as |ime-mode: disabled;|.
   */
  const unsigned long IME_STATUS_PASSWORD = 2;

  /**
   * PLUGIN means a plug-in has focus. At this time we should not touch to
   * controlling the IME state.
   */
  const unsigned long IME_STATUS_PLUGIN   = 3;

  /**
   * Get IME status, see above IME_STATUS_* definitions.
   */
  readonly attribute unsigned long IMEStatus;

  /**
   * Get the number of screen pixels per CSS pixel.
   */
  readonly attribute float screenPixelsPerCSSPixel;

  /**
   * Get the current zoom factor.
   * This is _approximately_ the same as nsIMarkupDocumentViewer.fullZoom,
   * but takes into account Gecko's quantization of the zoom factor, which is
   * implemented by adjusting the (integer) number of appUnits per devPixel.
   */
  readonly attribute float fullZoom;

  /**
   * Dispatches aEvent via the nsIPresShell object of the window's document.
   * The event is dispatched to aTarget, which should be an object
   * which implements nsIContent interface (#element, #text, etc).
   *
   * Cannot be accessed from unprivileged context (not
   * content-accessible) Will throw a DOM security error if called
   * without chrome privileges.
   *
   * @note Event handlers won't get aEvent as parameter, but a similar event.
   *       Also, aEvent should not be reused.
   */
  boolean dispatchDOMEventViaPresShell(in nsIDOMNode aTarget,
                                       in nsIDOMEvent aEvent,
                                       in boolean aTrusted);

  /**
   * Returns the real classname (possibly of the mostly-transparent security
   * wrapper) of aObj.
   */
  [implicit_jscontext] string getClassName(in jsval aObject);

  /**
   * Generate a content command event.
   *
   * Cannot be accessed from unprivileged context (not content-accessible)
   * Will throw a DOM security error if called without chrome privileges.
   *
   * @param aType Type of command content event to send.  Can be one of "cut",
   *        "copy", "paste", "delete", "undo", "redo", or "pasteTransferable".
   * @param aTransferable an instance of nsITransferable when aType is
   *        "pasteTransferable"
   */
  void sendContentCommandEvent(in AString aType,
                               [optional] in nsITransferable aTransferable);

  /**
   * Synthesize a composition event to the window.
   *
   * Cannot be accessed from unprivileged context (not content-accessible)
   * Will throw a DOM security error if called without chrome privileges.
   *
   * @param aType     The event type: "compositionstart", "compositionend" or
   *                  "compositionupdate".
   * @param aData     The data property value.  Note that this isn't applied
   *                  for compositionstart event because its value is the
   *                  selected text which is automatically computed.
   * @param aLocale   The locale property value.
   */
  void sendCompositionEvent(in AString aType,
                            in AString aData,
                            in AString aLocale);

  /**
   * Synthesize a text event to the window.
   *
   * Cannot be accessed from unprivileged context (not content-accessible)
   * Will throw a DOM security error if called without chrome privileges.
   *
   * Currently, this method doesn't support 4 or more clauses composition
   * string.
   *
   * @param aCompositionString  composition string
   * @param a*ClauseLengh       the length of nth clause, set 0 when you
   *                            don't need second or third clause.
   * @param a*ClauseAttr        the attribute of nth clause, uese following
   *                            const values.
   * @param aCaretStart         the caret position in the composition string,
   *                            if you set negative value, this method don't
   *                            set the caret position to the event.
   * @param aCaretLength        the caret length, if this is one or more,
   *                            the caret will be wide caret, otherwise,
   *                            it's collapsed.
   *                            XXX nsEditor doesn't support wide caret yet.
   */

  // NOTE: These values must be same to NS_TEXTRANGE_* in nsGUIEvent.h

  const unsigned long COMPOSITION_ATTR_RAWINPUT              = 0x02;
  const unsigned long COMPOSITION_ATTR_SELECTEDRAWTEXT       = 0x03;
  const unsigned long COMPOSITION_ATTR_CONVERTEDTEXT         = 0x04;
  const unsigned long COMPOSITION_ATTR_SELECTEDCONVERTEDTEXT = 0x05;

  void sendTextEvent(in AString aCompositionString,
                     in long aFirstClauseLength,
                     in unsigned long aFirstClauseAttr,
                     in long aSecondClauseLength,
                     in unsigned long aSecondClauseAttr,
                     in long aThirdClauseLength,
                     in unsigned long aThirdClauseAttr,
                     in long aCaretStart,
                     in long aCaretLength);

  /**
   * Synthesize a query content event.
   *
   * @param aType  One of the following const values.  And see also each comment
   *               for the other parameters and the result.
   */
  nsIQueryContentEventResult sendQueryContentEvent(in unsigned long aType,
                                                   in unsigned long aOffset,
                                                   in unsigned long aLength,
                                                   in long aX,
                                                   in long aY);

  // NOTE: following values are same as NS_QUERY_* in nsGUIEvent.h

  /**
   * QUERY_SELECTED_TEXT queries the first selection range's information.
   *
   * @param aOffset   Not used.
   * @param aLength   Not used.
   * @param aX        Not used.
   * @param aY        Not used.
   *
   * @return offset, reversed and text properties of the result are available.
   */
  const unsigned long QUERY_SELECTED_TEXT                       = 3200;

  /**
   * QUERY_TEXT_CONTENT queries the text at the specified range.
   *
   * @param aOffset   The first character's offset.  0 is the first character.
   * @param aLength   The length of getting text.  If the aLength is too long,
   *                  the result text is shorter than this value.
   * @param aX        Not used.
   * @param aY        Not used.
   *
   * @return text property of the result is available.
   */
  const unsigned long QUERY_TEXT_CONTENT                        = 3201;

  /**
   * QUERY_CARET_RECT queries the (collapsed) caret rect of the offset.
   * If the actual caret is there at the specified offset, this returns the
   * actual caret rect.  Otherwise, this guesses the caret rect from the
   * metrics of the text.
   *
   * @param aOffset   The caret offset.  0 is the left side of the first
   *                  caracter in LTR text.
   * @param aLength   Not used.
   * @param aX        Not used.
   * @param aY        Not used.
   *
   * @return left, top, width and height properties of the result are available.
   *         The left and the top properties are offset in the client area of
   *         the DOM window.
   */
  const unsigned long QUERY_CARET_RECT                          = 3203;

  /**
   * QUERY_TEXT_RECT queries the specified text's rect.
   *
   * @param aOffset   The first character's offset.  0 is the first character.
   * @param aLength   The length of getting text.  If the aLength is too long,
   *                  the extra length is ignored.
   * @param aX        Not used.
   * @param aY        Not used.
   *
   * @return left, top, width and height properties of the result are available.
   *         The left and the top properties are offset in the client area of
   *         the DOM window.
   */
  const unsigned long QUERY_TEXT_RECT                           = 3204;

  /**
   * QUERY_TEXT_RECT queries the focused editor's rect.
   *
   * @param aOffset   Not used.
   * @param aLength   Not used.
   * @param aX        Not used.
   * @param aY        Not used.
   *
   * @return left, top, width and height properties of the result are available.
   */
  const unsigned long QUERY_EDITOR_RECT                         = 3205;

  /**
   * QUERY_CHARACTER_AT_POINT queries the character information at the
   * specified point.  The point is offset in the window.
   * NOTE: If there are some panels at the point, this method send the query
   * event to the panel's widget automatically.
   *
   * @param aOffset   Not used.
   * @param aLength   Not used.
   * @param aX        X offset in the widget.
   * @param aY        Y offset in the widget.
   *
   * @return offset, notFound, left, top, width and height properties of the
   *         result are available.
   */
  const unsigned long QUERY_CHARACTER_AT_POINT                  = 3208;

  /**
   * Called when the remote child frame has changed its fullscreen state,
   * when entering fullscreen, and when the origin which is fullscreen changes.
   * aFrameElement is the iframe element which contains the child-process
   * fullscreen document, and aNewOrigin is the origin of the new fullscreen
   * document.
   */
  void remoteFrameFullscreenChanged(in nsIDOMElement aFrameElement,
                                    in AString aNewOrigin);

  /**
   * Called when the remote frame has popped all fullscreen elements off its
   * stack, so that the operation can complete on the parent side.
   */
  void remoteFrameFullscreenReverted();

  /**
   * Called when the child frame has fully exit fullscreen, so that the parent
   * process can also fully exit.
   */
  void exitFullscreen();

  /**
   * Synthesize a selection set event to the window.
   *
   * This sets the selection as the specified information.
   *
   * @param aOffset  The caret offset of the selection start.
   * @param aLength  The length of the selection.  If this is too long, the
   *                 extra length is ignored.
   * @param aReverse If true, the selection set from |aOffset + aLength| to
   *                 |aOffset|.  Otherwise, set from |aOffset| to
   *                 |aOffset + aLength|.
   * @return True, if succeeded.  Otherwise, false.
   */
  boolean sendSelectionSetEvent(in unsigned long aOffset,
                                in unsigned long aLength,
                                in boolean aReverse);

  /* Selection behaviors - mirror nsIFrame's nsSelectionAmount constants */
  const unsigned long SELECT_CHARACTER   = 0;
  const unsigned long SELECT_CLUSTER     = 1;
  const unsigned long SELECT_WORD        = 2;
  const unsigned long SELECT_LINE        = 3;
  const unsigned long SELECT_BEGINLINE   = 4;
  const unsigned long SELECT_ENDLINE     = 5;
  const unsigned long SELECT_PARAGRAPH   = 6;
  const unsigned long SELECT_WORDNOSPACE = 7;

  /**
   * Select content at a client point based on a selection behavior if the
   * underlying content is selectable. Selection will accumulate with any
   * existing selection, callers should clear selection prior if needed.
   * May fire selection changed events. Calls nsFrame's SelectByTypeAtPoint.
   *
   * @param aX, aY The selection point in client coordinates.
   * @param aSelectType The selection behavior requested.
   * @return True if a selection occured, false otherwise.
   * @throw NS_ERROR_DOM_SECURITY_ERR, NS_ERROR_UNEXPECTED for utils
   * issues, and NS_ERROR_INVALID_ARG for coordinates that are outside
   * this window.
   */
  boolean selectAtPoint(in float aX,
                        in float aY,
                        in unsigned long aSelectBehavior);

  /**
   * Perform the equivalent of:
   *   window.getComputedStyle(aElement, aPseudoElement).
   *     getPropertyValue(aPropertyName)
   * except that, when the link whose presence in history is allowed to
   * influence aElement's style is visited, get the value the property
   * would have if allowed all properties to change as a result of
   * :visited selectors (except for cases where getComputedStyle uses
   * data from the frame).
   *
   * This is easier to implement than adding our property restrictions
   * to this API, and is sufficient for the present testing
   * requirements (which are essentially testing 'color').
   */
  AString getVisitedDependentComputedStyle(in nsIDOMElement aElement,
                                           in AString aPseudoElement,
                                           in AString aPropertyName);

  /**
   * Returns the parent of obj.
   *
   * @param obj The JavaScript object whose parent is to be gotten.
   * @return the parent.
   */
  [implicit_jscontext] jsval getParent(in jsval obj);

  /**
   * Get the id of the outer window of this window.  This will never throw.
   */
  readonly attribute unsigned long long outerWindowID;

  /**
   * Get the id of the current inner window of this window.  If there
   * is no current inner window, throws NS_ERROR_NOT_AVAILABLE.
   */
  readonly attribute unsigned long long currentInnerWindowID;

  /**
   * Put the window into a state where scripts are frozen and events
   * suppressed, for use when the window has launched a modal prompt.
   */
  [noscript] void enterModalState();

  /**
   * Resume normal window state, where scripts can run and events are
   * delivered.
   */
  [noscript] void leaveModalState();

  /**
   * Same as enterModalState, but returns the window associated with the
   * current JS context.
   */
  nsIDOMWindow enterModalStateWithWindow();

  /**
   * Same as leaveModalState, but takes a window associated with the active
   * context when enterModalStateWithWindow was called. The currently context
   * might be different at the moment (see bug 621764).
   */
  void leaveModalStateWithWindow(in nsIDOMWindow aWindow);

  /**
   * Is the window is in a modal state? [See enterModalState()]
   */
  [noscript] boolean isInModalState();

  /**
   * Suspend/resume timeouts on this window and its descendant windows.
   */
  void suspendTimeouts();
  void resumeTimeouts();

  /**
   * What type of layer manager the widget associated with this window is
   * using. "Basic" is unaccelerated; other types are accelerated. Throws an
   * error if there is no widget associated with this window.
   */
  readonly attribute AString layerManagerType;

  void startFrameTimeRecording();
  void stopFrameTimeRecording([optional] out unsigned long frameCount,
                              [retval, array, size_is(frameCount)] out float frameTime);
  /**
   * Signals that we're begining to tab switch. This is used by painting code to
   * determine total tab switch time.
   */
  void beginTabSwitch();

  /**
   * The DPI of the display
   */
  readonly attribute float displayDPI;

  /**
   * Return the outer window with the given ID, if any.  Can return null.
   */
  nsIDOMWindow getOuterWindowWithId(in unsigned long long aOuterWindowID);

  [noscript] void RenderDocument(in nsConstRect aRect,
                                 in uint32_t aFlags,
                                 in nscolor aBackgroundColor,
                                 in gfxContext aThebesContext);

  /**
   * advanceTimeAndRefresh allows the caller to take over the refresh
   * driver timing for a window.  A call to advanceTimeAndRefresh does
   * three things:
   *  (1) It marks the refresh driver for this presentation so that it
   *      no longer refreshes on its own, but is instead driven entirely
   *      by the caller (except for the refresh that happens when a
   *      document comes out of the bfcache).
   *  (2) It advances the refresh driver's current refresh time by the
   *      argument given.  Negative advances are permitted.
   *  (3) It does a refresh (i.e., notifies refresh observers) at that
   *      new time.
   *
   * Note that this affects other connected docshells of the same type
   * in the same docshell tree, such as parent frames.
   *
   * When callers have completed their use of advanceTimeAndRefresh,
   * they must call restoreNormalRefresh.
   */
  void advanceTimeAndRefresh(in long long aMilliseconds);

  /**
   * Undoes the effects of advanceTimeAndRefresh.
   */
  void restoreNormalRefresh();

  /**
   * Method for testing nsStyleAnimation::ComputeDistance.
   *
   * Returns the distance between the two values as reported by
   * nsStyleAnimation::ComputeDistance for the given element and
   * property.
   */
  double computeAnimationDistance(in nsIDOMElement element,
                                  in AString property,
                                  in AString value1,
                                  in AString value2);

  /**
   * Wrap an nsIFile in an nsIDOMFile
   */
  nsIDOMFile wrapDOMFile(in nsIFile aFile);

  /**
   * Get the type of the currently focused html input, if any.
   */
  readonly attribute string focusedInputType;

  /**
   * Given a view ID from the compositor process, retrieve the element
   * associated with a view. For scrollpanes for documents, the root
   * element of the document is returned.
   */
  nsIDOMElement findElementWithViewId(in nsViewID aId);

  /**
   * Checks the layer tree for this window and returns true
   * if all layers have transforms that are translations by integers,
   * no leaf layers overlap, and the union of the leaf layers is exactly
   * the bounds of the window. Always returns true in non-DEBUG builds.
   */
  boolean leafLayersPartitionWindow();

  /**
   * true if the (current inner) window may have event listeners for touch events.
   */
  readonly attribute boolean mayHaveTouchEventListeners;
 
  /**
   * Check if any ThebesLayer painting has been done for this element,
   * clears the painted flags if they have.
   */
  boolean checkAndClearPaintedState(in nsIDOMElement aElement);

  /**
   * Internal file constructor intended for testing of File objects.
   * Example of constructor usage:
   *   getFile("myfile.txt", [b1, "foo"], { type: "text/plain" })
   */
  [optional_argc, implicit_jscontext]
  nsIDOMFile getFile(in DOMString aName, [optional] in jsval aBlobParts,
                     [optional] in jsval aParameters);

  /**
   * Internal blob constructor intended for testing of Blob objects.
   * Example of constructor usage:
   *   getBlob([b1, "foo"], { type: "text/plain" })
   */
  [optional_argc, implicit_jscontext]
  nsIDOMBlob getBlob([optional] in jsval aBlobParts,
                     [optional] in jsval aParameters);

  /**
   * Get internal id of the stored blob, file or file handle.
   */
  [implicit_jscontext] long long getFileId(in jsval aFile);

  /**
   * Get file ref count info for given database and file id.
   *
   */
  boolean getFileReferences(in AString aDatabaseName, in long long aId,
                            [optional] out long aRefCnt,
                            [optional] out long aDBRefCnt,
                            [optional] out long aSliceRefCnt);

  /**
   * Return whether incremental GC has been disabled due to a binary add-on.
   */
  [implicit_jscontext]
  boolean isIncrementalGCEnabled();

  /**
   * Begin opcode-level profiling of all JavaScript execution in the window's
   * runtime.
   */
  [implicit_jscontext]
  void startPCCountProfiling();

  /**
   * Stop opcode-level profiling of JavaScript execution in the runtime, and
   * collect all counts for use by getPCCount methods.
   */
  [implicit_jscontext]
  void stopPCCountProfiling();

  /**
   * Purge collected PC counters.
   */
  [implicit_jscontext]
  void purgePCCounts();

  /**
   * Get the number of scripts with opcode-level profiling information.
   */
  [implicit_jscontext]
  long getPCCountScriptCount();

  /**
   * Get a JSON string for a short summary of a script and the PC counts
   * accumulated for it.
   */
  [implicit_jscontext]
  AString getPCCountScriptSummary(in long script);

  /**
   * Get a JSON string with full information about a profiled script,
   * including the decompilation of the script and placement of decompiled
   * operations within it, and PC counts for each operation.
   */
  [implicit_jscontext]
  AString getPCCountScriptContents(in long script);

  /**
   * Returns true if painting is suppressed for this window and false
   * otherwise.
   */
  readonly attribute boolean paintingSuppressed;

  /**
   * Returns an array of plugins on the page for opt-in activation.
   *
   * Cannot be accessed from unprivileged context (not content-accessible).
   * Will throw a DOM security error if called without chrome privileges.
   *
   */
  [implicit_jscontext]
  readonly attribute jsval plugins;

  /**
   * Set the scrollport size for the purposes of clamping scroll positions for
   * the root scroll frame of this document to be (aWidth,aHeight) in CSS pixels.
   *
   * The caller of this method must have chrome privileges.
   */
  void setScrollPositionClampingScrollPortSize(in float aWidth, in float aHeight);

  /**
   * Prevent this window (and any child windows) from displaying any further
   * dialogs (e.g. window.alert()).
   */
  void preventFurtherDialogs();

  const unsigned long AGENT_SHEET = 0;
  const unsigned long USER_SHEET = 1;
  const unsigned long AUTHOR_SHEET = 2;
  /**
   * Synchronously loads a style sheet from |sheetURI| and adds it to the list
   * of additional style sheets of the document.
   *
   * These additional style sheets are very much like user/agent sheets loaded 
   * with loadAndRegisterSheet. The only difference is that they are applied only
   * on the document owned by this window.
   *
   * Sheets added via this API take effect immediately on the document.
   */
  void loadSheet(in nsIURI sheetURI,
                           in unsigned long type);

  /**
   * Remove the document style sheet at |sheetURI| from the list of additional 
   * style sheets of the document.  The removal takes effect immediately.
   */
  void removeSheet(in nsIURI sheetURI,
                                in unsigned long type);

  /**
   * Returns true if a user input is being handled.
   *
   * This calls nsEventStateManager::IsHandlingUserInput().
   */
  readonly attribute boolean isHandlingUserInput;

  /**
   * After calling the method, the window for which this DOMWindowUtils
   * was created can be closed using scripts.
   */
   void allowScriptsToClose();
};
