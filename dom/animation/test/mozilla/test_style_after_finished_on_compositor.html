<!doctype html>
<head>
<meta charset=utf-8>
<title>Test for styles after an animation has finished on the compositor</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../testcommon.js"></script>
<style>
.compositor {
  /* Element needs geometry to be eligible for layerization */
  width: 100px;
  height: 100px;
  background-color: green;
}
</style>
</head>
<body>
<div id="log"></div>
<script>
"use strict";

promise_test(async t => {
  const div = addDiv(t, { 'class': 'compositor' });
  const anim = div.animate([ { offset: 0, opacity: 1 },
                             { offset: 1, opacity: 0 } ],
                           { delay: 10,
                             duration: 100 });

  await anim.finished;

  await waitForNextFrame();

  const opacity = SpecialPowers.DOMWindowUtils.getOMTAStyle(div, 'opacity');

  assert_equals(opacity, '', 'No opacity animation runs on the compositor');
}, 'Opacity animation with positive delay is removed from compositor when ' +
   'finished');

promise_test(async t => {
  const div = addDiv(t, { 'class': 'compositor' });
  const anim = div.animate([ { offset: 0,   opacity: 1 },
                             { offset: 0.9, opacity: 1 },
                             { offset: 1,   opacity: 0 } ],
                           { duration: 100 });

  await anim.finished;

  await waitForNextFrame();

  const opacity = SpecialPowers.DOMWindowUtils.getOMTAStyle(div, 'opacity');

  assert_equals(opacity, '', 'No opacity animation runs on the compositor');
}, 'Opacity animation initially opacity: 1 is removed from compositor when ' +
   'finished');

promise_test(async t => {
  const div = addDiv(t, { 'class': 'compositor' });
  const anim = div.animate([ { offset: 0,    opacity: 0 },
                             { offset: 0.5,  opacity: 1 },
                             { offset: 0.51, opacity: 1 },
                             { offset: 1,    opacity: 0 } ],
                           { delay: 10, duration: 100 });

  await waitForAnimationFrames(2);

  // Setting the current time at the offset generating opacity: 1.
  anim.currentTime = 60;

  await anim.finished;

  await waitForNextFrame();

  const opacity = SpecialPowers.DOMWindowUtils.getOMTAStyle(div, 'opacity');

  assert_equals(opacity, '', 'No opacity animation runs on the compositor');
}, 'Opacity animation is removed from compositor even when it only visits ' +
   'exactly the point where the opacity: 1 value was set');

promise_test(async t => {
  const div = addDiv(t, { 'class': 'compositor' });
  const anim = div.animate([ { offset: 0, transform: 'none' },
                             { offset: 1, transform: 'translateX(100px)' } ],
                           { delay: 10,
                             duration: 100 });

  await anim.finished;

  await waitForNextFrame();

  const transform = SpecialPowers.DOMWindowUtils.getOMTAStyle(div, 'transform');

  assert_equals(transform, '', 'No transform animation runs on the compositor');
}, 'Transform animation with positive delay is removed from compositor when ' +
   'finished');

promise_test(async t => {
  const div = addDiv(t, { 'class': 'compositor' });
  const anim = div.animate([ { offset: 0,   transform: 'none' },
                             { offset: 0.9, transform: 'none' },
                             { offset: 1,   transform: 'translateX(100px)' } ],
                           { duration: 100 });

  await anim.finished;

  await waitForNextFrame();

  const transform = SpecialPowers.DOMWindowUtils.getOMTAStyle(div, 'transform');

  assert_equals(transform, '', 'No transform animation runs on the compositor');
}, 'Transform animation initially transform: none is removed from compositor ' +
   'when finished');

promise_test(async t => {
  const div = addDiv(t, { 'class': 'compositor' });
  const anim = div.animate([ { offset: 0,   transform: 'translateX(100px)' },
                             { offset: 0.5, transform: 'none' },
                             { offset: 0.9, transform: 'none' },
                             { offset: 1,   transform: 'translateX(100px)' } ],
                           { delay: 10, duration: 100 });

  await waitForAnimationFrames(2);

  // Setting the current time at the offset generating transform: none.
  anim.currentTime = 60;

  await anim.finished;

  await waitForNextFrame();

  const transform = SpecialPowers.DOMWindowUtils.getOMTAStyle(div, 'transform');

  assert_equals(transform, '', 'No transform animation runs on the compositor');
}, 'Transform animation is removed from compositor even when it only visits ' +
   'exactly the point where the transform: none value was set');

/*
 *
 * Tests for synthesized fill modes used when an animation on the compositor
 * has finished and is waiting to be removed by the main thread.
 *
 */

promise_test(async t => {
  // Below if painting takes too long we'll skip the test so in order to give
  // the test a better chance of running, wait until the system settles down.
  await waitForIdle();

  const div = addDiv(t, { class: 'compositor' });
  const anim = div.animate({ opacity: [1, 0] }, 100);

  const timeBeforeStart = window.performance.now();
  await waitForPaints();

  // If it took over 50ms to paint the first frame of the animation, we can't
  // reliably test it. This situation can happen if, for example, GC runs while
  // waiting for the paint.
  if (window.performance.now() - timeBeforeStart >= 50) {
    console.log('Skipping test because it took too long to paint the ' +
                'first frame');
    return;
  }

  let opacity = SpecialPowers.DOMWindowUtils.getOMTAStyle(div, 'opacity');
  assert_not_equals(
    opacity,
    '',
    'The animation style is applied on the compositor'
  );

  // Generate artificial busyness on the main thread for 200ms.
  const waitStart = window.performance.now();
  while (window.performance.now() - waitStart < 200) {}

  // By now the animation on the compositor should have finished but should
  // stay at the end of the animation because the main thread hasn't had
  // a chance to remove the animation from the compositor yet.
  opacity = SpecialPowers.DOMWindowUtils.getOMTAStyle(div, 'opacity');
  assert_equals(
    opacity,
    '0',
    'The opacity style from the end of the animation is still applied on ' +
    'the compositor'
  );
}, 'Opacity animation when playing forwards uses fill: forwards while ' +
   'waiting for the main thread to catch up');

promise_test(async t => {
  await waitForIdle();

  const div = addDiv(t, { class: 'compositor' });
  const anim = div.animate({ opacity: [0, 1] }, 100);
  anim.playbackRate = -1;
  anim.play();

  const timeBeforeStart = window.performance.now();
  await waitForPaints();

  // If it took over 50ms to paint the first frame of the animation, we can't
  // reliably test it. This situation can happen if, for example, GC runs while
  // waiting for the paint.
  if (window.performance.now() - timeBeforeStart >= 50) {
    console.log('Skipping test because it took too long to paint the ' +
                'first frame');
    return;
  }

  // Bug 1496313: For animations playing backwards, in some cases the animation
  // will not have arrived at the compositor by the time we go to check it.
  // For now we just skip that if it happens since it only happens occasionally.
  if (SpecialPowers.DOMWindowUtils.getOMTAStyle(div, 'opacity') === '') {
    console.log('Skipping test because the  took too long to paint the ' +
                'first frame');
    return;
  }

  // Generate artificial busyness on the main thread for 200ms.
  const waitStart = window.performance.now();
  while (window.performance.now() - waitStart < 200) {}

  // By now the animation on the compositor should have finished but should
  // stay at the start of the animation because the main thread hasn't had
  // a chance to remove the animation from the compositor yet.
  const opacity = SpecialPowers.DOMWindowUtils.getOMTAStyle(div, 'opacity');
  assert_equals(
    opacity,
    '0',
    'The opacity style from the start of the animation is still ' +
    'applied on the compositor'
  );
}, 'Opacity animation when playing backwards uses fill: backwards while ' +
   'waiting for the main thread to catch up');

/*
 * The following tests are as above but for a different initial fill mode
 * hence comments have been removed.
 */

promise_test(async t => {
  await waitForIdle();

  const div = addDiv(t, { class: 'compositor' });
  const anim = div.animate(
    { opacity: [1, 0] },
    { duration: 100, fill: 'backwards' }
  );

  const timeBeforeStart = window.performance.now();
  await waitForPaints();

  if (window.performance.now() - timeBeforeStart >= 50) {
    console.log('Skipping test because it took too long to paint the ' +
                'first frame');
    return;
  }

  let opacity = SpecialPowers.DOMWindowUtils.getOMTAStyle(div, 'opacity');
  assert_not_equals(
    opacity,
    '',
    'The animation style is applied on the compositor'
  );

  const waitStart = window.performance.now();
  while (window.performance.now() - waitStart < 200) {}

  opacity = SpecialPowers.DOMWindowUtils.getOMTAStyle(div, 'opacity');
  assert_equals(
    opacity,
    '0',
    'The opacity style from the end of the animation is still ' +
      'applied on the compositor'
  );
}, 'Opacity animation playing forwards with fill: backwards, ' +
   'uses fill: both while waiting for the main thread to catch up');

promise_test(async t => {
  await waitForIdle();

  const div = addDiv(t, { class: 'compositor' });
  const anim = div.animate(
    { opacity: [0, 1] },
    { duration: 100, fill: 'forwards' }
  );
  anim.playbackRate = -1;
  anim.play();

  const timeBeforeStart = window.performance.now();
  await waitForPaints();

  if (window.performance.now() - timeBeforeStart >= 50) {
    console.log('Skipping test because it took too long to paint the ' +
                'first frame');
    return;
  }

  // Bug 1496313: For animations playing backwards, in some cases the animation
  // will not have arrived at the compositor by the time we go to check it.
  // For now we just skip that if it happens since it only happens occasionally.
  if (SpecialPowers.DOMWindowUtils.getOMTAStyle(div, 'opacity') === '') {
    console.log('Skipping test because the  took too long to paint the ' +
                'first frame');
    return;
  }

  const waitStart = window.performance.now();
  while (window.performance.now() - waitStart < 200) {}

  const opacity = SpecialPowers.DOMWindowUtils.getOMTAStyle(div, 'opacity');
  assert_equals(
    opacity,
    '0',
    'The opacity style from the start of the animation is still ' +
    'applied on the compositor'
  );
}, 'Opacity animation playing backwards with fill: forwards, ' +
   'uses fill: both while waiting for the main thread to catch up');

</script>
</body>
