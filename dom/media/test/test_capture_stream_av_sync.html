<!DOCTYPE HTML>
<html>
<head>
<title>A/V sync test for stream capturing</title>
<script src="/tests/SimpleTest/SimpleTest.js"></script>
<link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
<p>Following canvas will capture and show the video frame when the video becomes audible</p><br>
<canvas id="canvas" width="640" height="480"></canvas>
<script type="application/javascript">

/**
 * This test will capture stream before the video starts playing, and check if
 * A/V sync will keep sync during playing.
 */
add_task(async function testAVSyncForStreamCapturing() {
  createVideo();
  await captureStreamFromVideo({ callback : playMedia });
  destroyVideo();
});

/**
 * This test will check if A/V is still on sync after we switch the media sink
 * from playback-based sink to mediatrack-based sink.
 */
add_task(async function testAVSyncWhenSwitchingMediaSink() {
  createVideo();
  await playMedia({resolveAfterReceivingTimeupdate : 5});
  // Because the audio isn't cut cleanly at every second, it would last a little
  // bit audible until it fully becomes silence (from 0.02s to 0.08s). When we
  // switch the sink, we might start detecting the audible frame at those "tail"
  // part which isn't the thing we want. Therefore, skip the first audible
  // frame and wait until next audible sound comes up that will be a real start
  // for audible sound.
  await captureStreamFromVideo({ skipFirstFrame : true });
  destroyVideo();
});

/**
 * Following are helper functions
 */
const DEBUG = false;
function info_debug(msg) {
  if (DEBUG) {
    info(msg);
  }
}

function createVideo() {
  const video = document.createElement("video");
  // This video is special for testing A/V sync, it only produce audible sound
  // once per second, and when the sound comes out, you can check the position
  // of the square to know if the A/V keeps sync.
  video.src = "sync.webm";
  video.loop = true;
  video.controls = true;
  video.width = 640;
  video.height = 480;
  video.id = "video";
  document.body.appendChild(video);
}

function destroyVideo() {
  const video = document.getElementById("video");
  video.src = null;
  video.remove();
}

async function playMedia({ resolveAfterReceivingTimeupdate } = {}) {
  const video = document.getElementById("video");
  ok(await video.play().then(_=>true,_=>false), "video started playing");
  if (resolveAfterReceivingTimeupdate > 0) {
    // Play it for a while to ensure the clock growing on the normal audio sink.
    for (let idx = 0; idx < resolveAfterReceivingTimeupdate; idx++) {
      await new Promise(r => video.ontimeupdate = r);
    }
  }
}

// This method will capture the stream from the video element, and check if A/V
// keeps sync during capturing. `callback` parameter will be executed after
// finishing capturing.
async function captureStreamFromVideo({callback, skipFirstFrame} = {}) {
  return new Promise(r => {
    const video = document.getElementById("video");
    let ac = new AudioContext();
    let analyser = ac.createAnalyser();
    analyser.frequencyBuf = new Float32Array(analyser.frequencyBinCount);
    analyser.smoothingTimeConstant = 0;
    analyser.fftSize = 2048; // 1024 bins
    let sourceNode = ac.createMediaElementSource(video);
    sourceNode.connect(analyser);
    analyser.connect(ac.destination);

    if (callback instanceof Function) {
      callback();
    }

    // The amount of time that we check the audible frames to see if the A/V
    // is still in sync.
    analyser._testTotalFramesAmount = 5;
    analyser._testIdx = 0;
    analyser._hasDetectedAudibleFrame = false;
    analyser.notifyAnalysis = () => {
      let {frequencyBuf} = analyser;
      analyser.getFloatFrequencyData(frequencyBuf);
      if (checkIfBufferIsSilent(frequencyBuf)) {
        info_debug("no need to paint the silent frame");
        analyser._hasDetectedAudibleFrame = false;
        requestAnimationFrame(analyser.notifyAnalysis);
        return;
      }
      if (analyser._hasDetectedAudibleFrame) {
        info_debug("detected audible frame already");
        requestAnimationFrame(analyser.notifyAnalysis);
        return;
      }
      analyser._hasDetectedAudibleFrame = true;
      if (skipFirstFrame) {
        info("skip the first audible frame");
        skipFirstFrame = false;
        requestAnimationFrame(analyser.notifyAnalysis);
        return;
      }
      info("paint audible frame");
      const cvs = document.getElementById("canvas");
      let context = cvs.getContext('2d');
      context.drawImage(video, 0, 0, 640, 480);
      if (checkIfAVIsOnSyncFuzzy(context)) {
        ok(true, `test ${analyser._testIdx++} times, a/v is in sync!`);
      } else {
        ok(false, `test ${analyser._testIdx++} times, a/v is out of sync!`);
      }
      if (analyser._testIdx == analyser._testTotalFramesAmount) {
        r();
        return;
      }
      requestAnimationFrame(analyser.notifyAnalysis);
    }
    analyser.notifyAnalysis();
  });
}

function checkIfBufferIsSilent(buffer) {
  for (let data of buffer) {
    // when sound is audible, its values are around -200 and the silence values
    // are around -800.
    if (data > -250) {
      return false;
    }
  }
  return true;
}

// This function will check the pixel data from the `context` to see if the
// square appears in the right place. As we can't control the exact timing
// of rendering video frames in the compositor, so the result would be fuzzy.
function checkIfAVIsOnSyncFuzzy(context) {
  // This will fuzz the result from +0 (perfect sync) to -X to +X frames.
  const FUZZY_FRAMES = 5;
  const squareLength = 48;
  // Canvas is 640*480, so perfect sync is the left-top corner when the square
  // shows up in the middle.
  const perfectSync =
      { x: 320 - squareLength/2.0 ,
        y: 240 - squareLength/2.0 };
  let isAVSyncFuzzy = false;
  // Get the whole partial section of image and detect where the square is.
  let imageData = context.getImageData(0, perfectSync.y, 640, squareLength);
  for (let i = 0; i < imageData.data.length; i += 4) {
    // If the pixel's color is red, then this position will be the left-top
    // corner of the square.
    if (isPixelColorRed(imageData.data[i], imageData.data[i+1],
                        imageData.data[i+2])) {
      const pos = ImageIdxToRelativeCoordinate(imageData, i);
      const diff = calculateFrameDiffenceInXAxis(pos.x, perfectSync.x);
      info(`find the square in [${pos.x}, ${pos.y + perfectSync.y}], diff=${diff}`);
      if (diff <= FUZZY_FRAMES) {
        isAVSyncFuzzy = true;
      }
      context.putImageData(imageData, 0, 0);
      break;
    }
  }
  if (!isAVSyncFuzzy) {
    const ctx = document.getElementById('canvas');
    info(ctx.toDataURL());
  }
  return isAVSyncFuzzy;
}

// Input an imageData and its idx, then return a relative coordinate on the
// range of given imageData.
function ImageIdxToRelativeCoordinate(imageData, idx) {
  const offset = idx / 4; // RGBA
  return { x: offset % imageData.width, y: offset / imageData.width };
}

function calculateFrameDiffenceInXAxis(squareX, targetX) {
  const offsetX = Math.abs(targetX - squareX);
  const xSpeedPerFrame = 640 / 60; // video is 60fps
  return offsetX / xSpeedPerFrame;
}

function isPixelColorRed(r, g, b) {
  // As the rendering color would vary in the screen on different platforms, so
  // we won't strict the R should be 255, just check if it's larger than a
  // certain threshold.
  return r > 200 && g < 10 && b < 10;
}

</script>
</head>
<body>
</body>
</html>
