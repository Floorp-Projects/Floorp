<!DOCTYPE HTML>
<html>
<head>
  <title>consistent growing clock time after switching to new audio sink</title>
  <script src="/tests/SimpleTest/SimpleTest.js"></script>
  <script src="manifest.js"></script>
  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
</head>
<body>
<script class="testbody" type="text/javascript">
/**
 * This test is used to ensure that when recreating another audio sink, the old
 * sink should inherit the clock time from the previous sink in order to make
 * the clock time consistently growing.
 */
add_task(async function setTestPref() {
  await SpecialPowers.pushPrefEnv({
    set: [["media.testing-only-events", true]]});
});

add_task(async function testConsistentGrowingClockTimeBetweenSinks() {
  const kExpectedLoopingTimes = 3;
  const audio = await createPlayingAndAudibleLoopingAudio();
  await waitAtLeastFinishLoopingOnce(audio, { times : kExpectedLoopingTimes });

  info(`suspend then resume the media element, which would result in creating a new audio sink`);
  let waitingSinkPromise = Promise.all([
    once(audio, "mozsuspendedmediasink"),
    once(audio, "mozresumedmediasink"),
  ]);
  let gapCounter = 0;
  audio.addEventListener("mozaudiosinkaudiogapdetected", _ => {
    // When we switch to the new sink, it's possible to have one small gap
    // because the previous clock time would not always match the first sample.
    // But we shouldn't have other gaps if we keep playing in the same sink.
    if (++gapCounter > 1) {
      ok(false, `gap ${gapCounter} : too many gaps in this audio!`);
    }
  });
  SpecialPowers.wrap(audio).setSuspend(true);
  SpecialPowers.wrap(audio).setSuspend(false);
  await waitingSinkPromise;
  // Wait a while to see if we receive any gap events.
  await expectToReceiveEvent(audio, "timeupdate", { times : 5});
});

/**
 * Follwing are helper functions.
 */
async function createPlayingAndAudibleLoopingAudio() {
  const audio = document.createElement('audio');
  audio.src = "small-shot.ogg";
  audio.loop = true;
  document.body.appendChild(audio);

  info(`wait for audio starting playing and becoming audible.`);
  await Promise.all([
    expectToReceiveEvent(audio, "mozaudiblestatechanged", { times : 1 }),
    audio.play()]);
  return audio;
}

function waitAtLeastFinishLoopingOnce(element, { times }) {
  info(`wait until audio finishes looping at least once`);
  return expectToReceiveEvent(element, "seeked", { times });
}

function expectToReceiveEvent(element, event, { times }) {
  return new Promise(r => {
    let receivedTimes = 0;
    element.addEventListener(event, _ => {
      if (++receivedTimes == times) {
        ok(true, `received ${event} ${times} times.`);
        r();
      }
    });
  });
}

</script>
</body>
</html>
