<!DOCTYPE HTML>
<html>
<head>
  <title>Test PannerNode produces output even when the even when the distance is from the listener is zero</title>
  <script src="/tests/SimpleTest/SimpleTest.js"></script>
  <script type="text/javascript" src="webaudio.js"></script>
  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
</head>
<body>
<pre id="test">
<script class="testbody" type="text/javascript">

var BUF_SIZE = 128;

var types = [
  "equalpower",
  "HRTF"
]

async function testMono(type) {
  var ac = new OfflineAudioContext(1, BUF_SIZE, 44100);

  // A sine to be used to fill the buffers
  function sine(t) {
    return Math.sin(440 * 2 * Math.PI * t / ac.sampleRate);
  }

  var monoBuffer = ac.createBuffer(1, BUF_SIZE, ac.sampleRate);
  for (var i = 0; i < BUF_SIZE; ++i) {
    monoBuffer.getChannelData(0)[i] = sine(i);
  }

  var monoSource = ac.createBufferSource();
  monoSource.buffer = monoBuffer;
  monoSource.start(0);

  var panner = ac.createPanner();
  panner.distanceModel = "linear";
  monoSource.connect(panner);

  var panner2 = ac.createPanner();
  panner2.distanceModel = "inverse";
  panner.connect(panner2);

  var panner3 = ac.createPanner();
  panner3.distanceModel = "exponential";
  panner2.connect(panner3);

  panner3.connect(ac.destination);

  // Use the input buffer to compare the output. According to the spec,
  // mono input at zero distance will apply gain = cos(0.5 * Math.PI / 2)
  // https://webaudio.github.io/web-audio-api/#Spatialzation-equal-power-panning
  const gain = Math.cos(0.5 * Math.PI / 2);
  for (var i = 0; i < BUF_SIZE; ++i) {
    monoBuffer.getChannelData(0)[i] = gain * monoBuffer.getChannelData(0)[i];
  }

  const buffer = await ac.startRendering();
  compareBuffers(buffer, monoBuffer);
}

async function testStereo(type) {
  var ac = new OfflineAudioContext(2, BUF_SIZE, 44100);

  // A sine to be used to fill the buffers
  function sine(t) {
    return Math.sin(440 * 2 * Math.PI * t / ac.sampleRate);
  }

  var stereoBuffer = ac.createBuffer(2, BUF_SIZE, ac.sampleRate);
  for (var i = 0; i < BUF_SIZE; ++i) {
    stereoBuffer.getChannelData(0)[i] = sine(i);
    stereoBuffer.getChannelData(1)[i] = sine(i);
  }

  var stereoSource = ac.createBufferSource();
  stereoSource.buffer = stereoBuffer;
  stereoSource.start(0);

  var panner = ac.createPanner();
  panner.distanceModel = "linear";
  stereoSource.connect(panner);

  var panner2 = ac.createPanner();
  panner2.distanceModel = "inverse";
  panner.connect(panner2);

  var panner3 = ac.createPanner();
  panner3.distanceModel = "exponential";
  panner2.connect(panner3);

  panner3.connect(ac.destination);

  const buffer = await ac.startRendering();
  compareBuffers(buffer, stereoBuffer);
}

async function test(type) {
  await testMono(type)
  await testStereo(type);
}

add_task(async function() {
  for (const panningModel of types) {
    await test(panningModel);
  }
});

</script>
</pre>
</body>
</html>
