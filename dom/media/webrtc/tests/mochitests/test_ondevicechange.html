<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <script type="application/javascript" src="mediaStreamPlayback.js"></script>
</head>
<body>
<script type="application/javascript">
"use strict";

createHTML({
  title: "ondevicechange tests",
  bug: "1152383"
});

async function resolveOnEvent(target, name) {
  return new Promise(r => target.addEventListener(name, r, {once: true}));
}
let eventCount = 0;
async function triggerVideoDevicechange() {
  ++eventCount;
  return pushPrefs(["media.getusermedia.fake-camera-name",
                    `devicechange ${eventCount}`])
}
// Trigger and await two devicechanges on mediaDevices to wait long enough to
// provide that a devicechange on another MediaDevices would be received.
async function doVideoDevicechanges(mediaDevices) {
  for (let i = 0; i < 2; ++i) {
    await Promise.all([
      resolveOnEvent(mediaDevices, "devicechange"),
      triggerVideoDevicechange(),
    ]);
  }
}

runTest(async () => {
  // A toplevel Window and an iframe Window are compared for devicechange
  // events.
  const iframe = document.createElement("iframe");
  // Workaround for bug 1743933
  const promiseIframeLoad = resolveOnEvent(iframe, "load");
  document.documentElement.appendChild(iframe);
  await Promise.all([
    promiseIframeLoad,
    pushPrefs(
      // Use the fake video backend to trigger devicechange events.
      ["media.navigator.streams.fake", true],
      // Loopback would override fake.
      ["media.video_loopback_dev", ""],
      // Make fake devices count as real, permission-wise, or devicechange
      // events won't be exposed
      ["media.navigator.permission.fake", true],
      // For gUM.
      ["media.navigator.permission.disabled", true]
    ),
  ]);
  const topDevices = navigator.mediaDevices;
  const frameDevices = iframe.contentWindow.navigator.mediaDevices;
  // Initialization of MediaDevices::mLastPhysicalDevices is triggered when
  // ondevicechange is set but tests "media.getusermedia.fake-camera-name"
  // asynchronously.  Wait for getUserMedia() completion to ensure that the
  // pref has been read before doDevicechanges() changes it.
  frameDevices.ondevicechange = () => {};
  const topEventPromise = resolveOnEvent(topDevices, "devicechange");
  const frameStream = await frameDevices.getUserMedia({video: true});
  frameStream.getVideoTracks()[0].stop();

  await doVideoDevicechanges(frameDevices);
  ok(true,
     "devicechange event is fired when gUM has been in use");
  // Race a settled Promise to check that the event has not been received in
  // the toplevel Window.
  const racer = {};
  is(await Promise.race([topEventPromise, racer]), racer,
     "devicechange event is NOT fired when gUM has NOT been in use");

  const frameEventPromise1 = resolveOnEvent(frameDevices, "devicechange");
  while (true) {
    const racePromise = Promise.race([
      frameEventPromise1,
      // 100ms is half the coalescing time in MediaManager::DeviceListChanged().
      wait(100, {type: "wait done"}),
    ]);
    await triggerVideoDevicechange();
    if ((await racePromise).type == "devicechange") {
      ok(true,
         "devicechange event is fired even when hardware changes continue");
      break;
    }
  }

  if (navigator.userAgent.includes("Android")) {
    todo(false, "test assumes Firefox-for-Desktop specific API and behavior");
    return;
  }
  // Open a new tab, which is expected to receive focus and hide the first tab.
  const tab = window.open();
  SimpleTest.registerCleanupFunction(() => tab.close());
  await Promise.all([
    resolveOnEvent(document, 'visibilitychange'),
    resolveOnEvent(tab, 'focus'),
  ]);
  ok(tab.document.hasFocus(), "tab.document.hasFocus()");
  await Promise.all([
    resolveOnEvent(tab, 'blur'),
    SpecialPowers.spawnChrome([], function focusUrlBar() {
      this.browsingContext.topChromeWindow.gURLBar.focus();
    }),
  ]);
  ok(!tab.document.hasFocus(), "!tab.document.hasFocus()");
  is(document.visibilityState, 'hidden', 'visibilityState')
  const frameEventPromise2 = resolveOnEvent(frameDevices, "devicechange");
  const tabDevices = tab.navigator.mediaDevices;
  tabDevices.ondevicechange = () => {};
  const tabStream = await tabDevices.getUserMedia({video: true});
  await doVideoDevicechanges(tabDevices);
  is(await Promise.race([frameEventPromise2, racer]), racer,
     "devicechange event is NOT fired while tab is in background");
  tab.close();
  await resolveOnEvent(document, 'visibilitychange');
  is(document.visibilityState, 'visible', 'visibilityState')
  await frameEventPromise2;
  ok(true, "devicechange event IS fired when tab returns to foreground");

  const audioLoopbackDev =
        SpecialPowers.getCharPref("media.audio_loopback_dev", "");
  if (!navigator.userAgent.includes("Linux")) {
    todo_isnot(audioLoopbackDev, "", "audio_loopback_dev");
    return;
  }
  isnot(audioLoopbackDev, "", "audio_loopback_dev");
  await Promise.all([
    resolveOnEvent(topDevices, "devicechange"),
    pushPrefs(["media.audio_loopback_dev", "none"]),
  ]);
  ok(true,
     "devicechange event IS fired when last audio device is removed and " +
     "gUM has NOT been in use");
  await Promise.all([
    resolveOnEvent(topDevices, "devicechange"),
    pushPrefs(["media.audio_loopback_dev", audioLoopbackDev]),
  ]);
  ok(true,
     "devicechange event IS fired when first audio device is added and " +
     "gUM has NOT been in use");
});

</script>
</body>
</html>
