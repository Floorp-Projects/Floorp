# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 1.1/GPL 2.0/LGPL 2.1
#
# The contents of this file are subject to the Mozilla Public License Version
# 1.1 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Original Code is mozilla.org code.
#
# Contributor(s):
#   Chris Jones <jones.chris.g@gmail.com>
#
# Alternatively, the contents of this file may be used under the terms of
# either of the GNU General Public License Version 2 or later (the "GPL"),
# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
# in which case the provisions of the GPL or the LGPL are applicable instead
# of those above. If you wish to allow use of your version of this file only
# under the terms of either the GPL or the LGPL, and not to allow others to
# use your version of this file under the terms of the MPL, indicate your
# decision by deleting the provisions above and replace them with the notice
# and other provisions required by the GPL or the LGPL. If you do not delete
# the provisions above, a recipient may use your version of this file under
# the terms of any one of the MPL, the GPL or the LGPL.
#
# ***** END LICENSE BLOCK *****

import os
from copy import deepcopy

from ipdl.ast import Visitor, ASYNC, SYNC, RPC, IN, OUT, INOUT
import ipdl.cxx.ast as cxx

EMIT_LOGGING_CODE = False

def _joinProtocolNamespacesName(sep, p, pname):
    return sep.join([ ns.namespace for ns in p.namespaces ] + [ pname ])

def _protocolIncludeGuard(p, pname):
    return _joinProtocolNamespacesName('_', p, pname) +'_h'

def _protocolHeaderFilename(p, pname):
    return _joinProtocolNamespacesName('/', p, pname)+ '.h'

def _protocolHeaderName(pname):
    return pname

def _actorName(pname, side):
    """|pname| is the protocol name. |side| is 'Parent' or 'Child'."""
    return pname + side

def _makeForwardDecl(ptype, side):
    clsname = _actorName(ptype.qname.baseid, side)
    
    fd = cxx.ForwardDecl(clsname, cls=1)
    if 0 == len(ptype.qname.quals):
        return fd

    outerns = cxx.Namespace(ptype.qname.quals[0])
    innerns = outerns
    for ns in ptype.qname.quals[1:]:
        tmpns = cxx.Namespace(ns)
        innerns.addstmt(tmpns)
        innerns = tmpns

    innerns.addstmt(fd)
    return outerns

class _struct: pass

class LowerToCxx:
    def lower(self, tu):
        '''returns a list of cxx.File representing the lowered form of |tu|'''
        pname = _protocolHeaderName(tu.protocol.name)
        pheader = cxx.File(pname +'.h')
        gph = GenerateProtocolHeader()
        gph.lower(tu, pname, pheader)

        parentname = pname +'Parent'
        parentheader = cxx.File(parentname +'.h')
        GenerateProtocolParentHeader().lower(
            tu, pname, parentname, parentheader, gph.typedefs)

        childname = pname +'Child'
        childheader = cxx.File(childname +'.h')
        GenerateProtocolChildHeader().lower(
            tu, pname, childname, childheader, gph.typedefs)

        return pheader, parentheader, childheader


##-----------------------------------------------------------------------------
class GenerateProtocolHeader(Visitor):
    '''creates a "generic" protocol header from an IPDL AST'''
    def __init__(self):
        self.pname = None
        self.file = None
        self.ns = None          # the namespace we toss all this stuff into
        # list of typedefs for the protocol namespace.  these are 
        # produced from various places in the AST and collected here
        self.typedefs = [ ]

    def lower(self, tu, protocol, outcxxfile):
        self.pname = protocol
        self.file = outcxxfile
        tu.accept(self)


    def typedef(self, t, name):
        self.typedefs.append(cxx.Typedef(cxx.Type(t), name))

    def injectTypedefs(self, scope):
        for tdef in self.typedefs:
            scope.addstmt(tdef)

    def visitTranslationUnit(self, tu):
        f = self.file

        f.addthing(cxx.Whitespace('''//
// Automatically generated by ipdlc.
// Edit at your own risk
//

'''))
        includeguard = _protocolIncludeGuard(tu.protocol, self.pname)
        f.addthing(cxx.CppDirective('ifndef', includeguard))
        f.addthing(cxx.CppDirective('define', includeguard))
        f.addthing(cxx.Whitespace.NL)

        Visitor.visitTranslationUnit(self, tu)

        f.addthing(cxx.Whitespace.NL)
        f.addthing(cxx.CppDirective('endif', '// ifndef '+ includeguard))


    def visitCxxInclude(self, inc):
        self.file.addthing(cxx.CppDirective('include', '"'+ inc.file +'"'))


    def visitProtocolInclude(self, inc):
        p = inc.tu.protocol
        self.file.addthing(
            cxx.CppDirective(
                'include',
                '"'+ _protocolHeaderFilename(p, _protocolHeaderName(p.name)) +'"'))


    def visitUnionDecl(self, ud):
        # This Union class basically consists of a type (enum) and a a
        # union for storage, both private.  The union can contain POD
        # and non-POD types.  Each type needs a copy ctor, assignment
        # operator, and destructor.
        #
        # Rather than templating this class and only providing
        # specializations for the types we support, which is slightly
        # "unsafe", we explicitly implement non-templated methods
        # for each supported type.
        #
        # The one complication that arises is that C++, for aracne
        # reasons, does not allow the placement destructor of a
        # builtin type, like int, to be directly invoked.  So we need
        # to hack around this by internally typedef'ing all
        # constituent types.  Sigh.
        #
        # So, for each type, this "Union" class needs:
        # (private)
        #  - entry in the type enum
        #  - entry in the storage union
        #  - [type]ptr() method to get a type* from the underlying union
        #  - same as above to get a const type*
        #  - typedef to hack around placement delete limitations
        # (public)
        #  - placement delete case for dtor
        #  - copy ctor
        #  - case in generic copy ctor
        #  - operator= impl
        #  - case in generic operator=
        #  - operator [type&]
        #  - operator [const type&] const
        #  - [type&] get_[type]()
        #  - [const type&] get_[type]() const
        #
        # We collect all this first, in a loop, then put it back
        # together
        #
        # Actor types are a bit tricky because they have different
        # interfaces in different processes.  We fix this by stuffing
        # interfaces for both processes into this implementation.
        # In the parent process, we only expect the parent to get
        # ActorParent*'s, and similarly in the child.  If this
        # invariant can be broken, we have bigger problems than
        # instantiating illegal IPDL discriminated unions.
        cls = cxx.Class(ud.name, final=1)
        clstyperef = cxx.Type(ud.name, ref=1)
        typetype = cxx.Type('Type')
        valuetype = cxx.Type('Value')
        mtypevar = cxx.ExprVar('mType')
        mvaluevar = cxx.ExprVar('mValue')
        assertsanityvar = cxx.ExprVar('AssertSanity')

        # useful exprs/stmts that can be reused (read-only)
        valuevar = cxx.ExprVar('aValue')
        rhsvar = cxx.ExprVar('aRhs')
        returnthis = cxx.StmtReturn(cxx.ExprDeref(cxx.ExprVar('this')))
        returnfalse = cxx.StmtReturn(cxx.ExprVar('false'))
        returntrue = cxx.StmtReturn(cxx.ExprVar('true'))
        hardabort = cxx.StmtExpr(cxx.ExprCall(
            cxx.ExprVar('NS_RUNTIMEABORT'),
            [ cxx.ExprLiteral.String("catastrophically unexpected type") ]))
            
        enumvs = [ ]
        union = cxx.TypeUnion('Value')
        union.hasActor = False
        ptrmeths = [ ]
        constptrmeths = [ ]
        typedefs = [ ]
        dtorswitch = cxx.StmtSwitch(mtypevar)
        copyctors = [ ]
        copyswitch = cxx.StmtSwitch(mtypevar)
        opeqs = [ ]
        opeqswitch = cxx.StmtSwitch(mtypevar)
        optypes = [ ]
        opconsttypes = [ ]
        gettypes = [ ]
        getconsttypes = [ ]
        writeswitch = cxx.StmtSwitch(
            cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('aParam'), '.', 'type')))
        readswitch = cxx.StmtSwitch(cxx.ExprVar('type'))

        # "templates" copied and altered multiple times below
        basiccopydecl = cxx.ConstructorDecl(
            ud.name,
            params=[ cxx.Decl(cxx.Type('!!DUMMY!!', const=1, ref=1),
                              'aValue') ],
            explicit=1)
        basicopeqdecl = cxx.MethodDecl(
            'operator=',
            params=[ cxx.Decl(cxx.Type('!!DUMMY!!', const=1, ref=1),
                              'aRhs') ],
            ret=cxx.Type(ud.name, ref=1))

        # we generate code for both Parent and Child actors
        cxxtypes = [ ]
        forwarddecls = [ ]              # forward decls of actor types
        usingTypedefs = [ ]             # typedefs of namespaced |using| types
        for t in ud.decl.type.components:
            if t.isIPDL() and t.isActor():
                p = cxx.Type(t.name() +'Parent', ptr=1)
                p._ipdl = t
                p._side = 'Parent'
                c = cxx.Type(t.name() +'Child', ptr=1)
                c._ipdl = t
                c._side = 'Child'
                cxxtypes.append(p)
                cxxtypes.append(c)
                # we shouldn't have *any* actor's definition in scope
                # from within a protocol header.  so forward-declare
                # actor types
                forwarddecls.append(_makeForwardDecl(t.protocol, 'Parent'))
                forwarddecls.append(_makeForwardDecl(t.protocol, 'Child'))
            else:
                ct = cxx.Type(t.name())
                ct._ipdl = None
                ct._side = None
                cxxtypes.append(ct)
                if t.name() != t.fullname():
                    usingTypedefs.append(cxx.Typedef(cxx.Type(t.fullname()),
                                                     t.name()))

        # special, opaque handle used to pack away actor types when unions
        # are sent across the wire
        t = cxx.Type('ActorHandle');  t._ipdl = None; t._side = None
        cxxtypes.append(t)

        for cxxt in cxxtypes:
            cxxtptr = deepcopy(cxxt)
            if cxxt.ptr:
                cxxtptr.ptr = 0
                cxxtptr.ptrptr = 1
            else:
                cxxtptr.ptr = 1
            cxxtconstptr = deepcopy(cxxtptr)
            cxxtconstptr.const = 1
            if cxxt._ipdl is not None:
                cxxtconstptr.ptrptr = 0
                cxxtconstptr.ptrconstptr = 1
            cxxtdefname = cxxt.name +'__tdef'
            typename = cxxt.name
            consttypename = cxxt.name
            if cxxt.ptr:
                typename += '*'
                consttypename += '* const'

            # actor types are pointers, don't use copy semantics
            copyintype = deepcopy(cxxt)
            if cxxt._ipdl is None:
                # not an actor type
                copyintype.const = 1
                copyintype.ref = 1

            enumv = 'T'+ cxxt.name
            enumvar = cxx.ExprVar(enumv)
            unionname = 'V'+ cxxt.name
            caselabel = cxx.CaseLabel(enumv)
            fullcaselabel = cxx.CaseLabel(ud.decl.fullname +'::'+ enumv)
            gettypen = 'get_'+ cxxt.name
            gettypevar = cxx.ExprVar(gettypen)
            returngettype = cxx.StmtReturn(cxx.ExprCall(cxx.ExprVar(gettypen)))

            enumvs.append(enumv)
            cxxt._tag = enumv

            cxxtstorage = cxx.TypeArray(cxx.Type('char'),
                                        cxx.ExprSizeof(cxxt))
            cxxtstorage._realtype = cxxt
            cxxtstorage._tag = cxxt._tag
            cxxtstorage._ipdl = cxxt._ipdl
            cxxtstorage._side = cxxt._side
            union.addComponent(cxxtstorage, unionname)

            ptrmethdecl = cxx.MethodDecl(name='ptr'+ cxxt.name,
                                         ret=cxxtptr)
            callptrmeth = cxx.ExprCall(cxx.ExprVar('ptr'+ cxxt.name))
            ptrmeth = cxx.MethodDefn(ptrmethdecl)
            ptrmeth.addstmt(cxx.StmtReturn(
                cxx.ExprCast(
                    cxx.ExprAddrOf(cxx.ExprSelect(mvaluevar, '.', unionname)),
                    cxxtptr,
                    reinterpret=1)))
            ptrmeths.append(ptrmeth)
            constptrmethdecl = cxx.MethodDecl(name='constptr'+ cxxt.name,
                                              ret=cxxtconstptr,
                                              const=1)
            callconstptrmeth = cxx.ExprCall(cxx.ExprVar('constptr'+ cxxt.name))
            constptrmeth = cxx.MethodDefn(constptrmethdecl)
            constptrmeth.addstmt(cxx.StmtReturn(
                cxx.ExprCast(
                    cxx.ExprAddrOf(cxx.ExprSelect(mvaluevar, '.', unionname)),
                    cxxtconstptr,
                    reinterpret=1)))
            constptrmeths.append(constptrmeth)

            typedefs.append(cxx.Typedef(cxxt, cxxtdefname))

            dtorswitch.addstmt(caselabel)
            dtorswitch.addstmt(cxx.StmtExpr(
                cxx.ExprCall(
                    cxx.ExprSelect(callptrmeth,
                                   '->', '~'+ cxxtdefname))))
            dtorswitch.addstmt(cxx.StmtBreak())

            copyctordecl = deepcopy(basiccopydecl)
            copyctordecl.params[0].type = copyintype
            copyctor = cxx.ConstructorDefn(
                copyctordecl,
                memberinits=[ cxx.ExprMemberInit(mtypevar,
                                                 args=[ enumvar ]) ])
            copyctor.addstmt(cxx.StmtExpr(
                cxx.ExprNew(cxxt,
                            args=[ valuevar ],
                            newargs=[ callptrmeth ])))
            copyctors.append(copyctor)

            copyswitch.addstmt(caselabel)
            copyinval = cxx.ExprCall(cxx.ExprSelect(valuevar, '.', gettypen))
            if cxxt._ipdl is not None:
                # we don't use copy semantics for actor pointers, so
                # we have to const_cast away the access to
                # |(constOther&).getActorPtr()| to get a naked pointer
                # again
                copyinval = cxx.ExprCast(copyinval, cxxt, const=1)
            copyswitch.addstmt(cxx.StmtExpr(
                cxx.ExprNew(cxxt,
                            args=[ copyinval ],
                            newargs=[ callptrmeth ])))
            copyswitch.addstmt(cxx.StmtBreak())

            opeqdecl = deepcopy(basicopeqdecl)
            opeqdecl.params[0].type = copyintype
            opeq = cxx.MethodDefn(opeqdecl)
            opeq.addstmt(cxx.StmtExpr(cxx.ExprAssn(mtypevar, enumvar)))
            opeq.addstmt(cxx.StmtExpr(
                cxx.ExprAssn(cxx.ExprDeref(callptrmeth),
                             rhsvar)))
            opeq.addstmt(returnthis)
            opeqs.append(opeq)

            opeqswitch.addstmt(caselabel)
            opeqswitch.addstmt(cxx.StmtExpr(
                cxx.ExprAssn(cxx.ExprDeref(callptrmeth),
                             cxx.ExprCast(rhsvar, clstyperef, const=1))))
            opeqswitch.addstmt(cxx.StmtBreak())

            optype = cxx.MethodDefn(
                cxx.MethodDecl('operator '+ typename +'&', typeop=1))
            optype.addstmt(returngettype)
            optypes.append(optype)

            opconsttype = cxx.MethodDefn(
                cxx.MethodDecl('operator const '+ consttypename +'&',
                               const=1, typeop=1))
            opconsttype.addstmt(returngettype)
            opconsttypes.append(opconsttype)

            callassertsanetype = cxx.StmtExpr(
                cxx.ExprCall(assertsanityvar,
                             args=[ enumvar ]))

            rettype = deepcopy(cxxt)
            rettype.ref = 1
            gettype = cxx.MethodDefn(cxx.MethodDecl(gettypen,
                                                    ret=rettype))
            gettype.addstmt(callassertsanetype)
            gettype.addstmt(cxx.StmtReturn(cxx.ExprDeref(callptrmeth)))
            gettypes.append(gettype)

            constrettype = deepcopy(rettype)
            constrettype.const = 1
            if cxxt._ipdl is not None:
                constrettype.ptr = 0
                constrettype.ptrconst = 1
            getconsttype = cxx.MethodDefn(cxx.MethodDecl(gettypen,
                                                         ret=constrettype,
                                                         const=1))
            getconsttype.addstmt(callassertsanetype)
            getconsttype.addstmt(cxx.StmtReturn(
                cxx.ExprDeref(callconstptrmeth)))
            getconsttypes.append(getconsttype)

            # only create case if this isn't an IPDL actor type.
            # there are specially serialized in the Send* method
            if cxxt._ipdl is None:
                writeswitch.addstmt(fullcaselabel)
                case = cxx.StmtBlock()
                case.addstmt(cxx.StmtExpr(
                    cxx.ExprCall(
                        cxx.ExprVar('WriteParam'),
                        args=[ cxx.ExprVar('aMsg'),
                               cxx.ExprCall(
                                   cxx.ExprSelect(cxx.ExprVar('aParam'),
                                                  '.', gettypen)) ])))
                case.addstmt(cxx.StmtReturn())
                writeswitch.addstmt(case)

                # actor types are similarly special-cased in the
                # deserializer
                readswitch.addstmt(fullcaselabel)
                case = cxx.StmtBlock()
                case.addstmt(cxx.StmtDecl(cxx.Decl(cxxt, 'val')))
                valvar = cxx.ExprVar('val')
                readval = cxx.ExprCall(
                    cxx.ExprVar('ReadParam'),
                    args=[ cxx.ExprVar('aMsg'),
                           cxx.ExprVar('aIter'),
                           cxx.ExprAddrOf(valvar) ])
                failif = cxx.StmtIf(cxx.ExprPrefixUnop(readval, '!'))
                failif.addifstmt(cxx.StmtReturn(cxx.ExprVar('false')))
                case.addstmt(failif)
                case.addstmt(cxx.StmtExpr(
                    cxx.ExprAssn(cxx.ExprDeref(cxx.ExprVar('aResult')),
                                 valvar)))
                case.addstmt(returntrue)
                readswitch.addstmt(case)
            else:
                union.hasActor = True


        # now put all these decls and defn's together into a class
        cls.addstmt(cxx.Label.PRIVATE)
        for td in usingTypedefs:
            cls.addstmt(td)
        cls.addstmt(cxx.Typedef(cxx.Type('mozilla::ipc::ActorHandle'),
                                'ActorHandle'))
        for tdef in typedefs:
            cls.addstmt(tdef)
        cls.addstmt(cxx.Whitespace.NL)

        cls.addstmt(cxx.Label.PUBLIC)
        tenum = cxx.TypeEnum('Type')
        for enumv in enumvs:
            tenum.addId(enumv)
        tenum.addId('T__First', enumvs[0])
        tenum.addId('T__Last', enumvs[len(enumvs)-1])
        cls.addstmt(cxx.StmtDecl(cxx.Decl(tenum, '')))
        cls.addstmt(cxx.Whitespace.NL)

        cls.addstmt(cxx.Label.PRIVATE)
        cls.addstmt(cxx.StmtDecl(cxx.Decl(union, '')))
        for ptrmeth in ptrmeths:
            cls.addstmt(ptrmeth)
        for constptrmeth in constptrmeths:
            cls.addstmt(constptrmeth)
        cls.addstmt(cxx.Whitespace.NL)

        # sanity checker
        sanity = cxx.MethodDefn(cxx.MethodDecl(assertsanityvar.name,
                                               ret=cxx.Type('void'),
                                               const=1))
        sanity.addstmt(cxx.StmtExpr(
            cxx.ExprCall(cxx.ExprVar('NS_ABORT_IF_FALSE'),
                         [ cxx.ExprBinary(cxx.ExprVar('T__First'),
                                          '<=',
                                          mtypevar),
                           cxx.ExprLiteral.String('invalid type tag') ])))
        sanity.addstmt(cxx.StmtExpr(
            cxx.ExprCall(cxx.ExprVar('NS_ABORT_IF_FALSE'),
                         [ cxx.ExprBinary(mtypevar,
                                          '<=',
                                          cxx.ExprVar('T__Last')),
                           cxx.ExprLiteral.String('invalid type tag') ])))
        cls.addstmt(sanity)
        sanity = cxx.MethodDefn(
            cxx.MethodDecl(assertsanityvar.name,
                           params=[ cxx.Decl(typetype, 'aType') ],
                           ret=cxx.Type('void'),
                           const=1))
        sanity.addstmt(cxx.StmtExpr(cxx.ExprCall(assertsanityvar)))
        sanity.addstmt(cxx.StmtExpr(
            cxx.ExprCall(
                cxx.ExprVar('NS_ABORT_IF_FALSE'),
                [ cxx.ExprBinary(mtypevar, '==', cxx.ExprVar('aType')),
                  cxx.ExprLiteral.String('unexpected type tag') ])))
        cls.addstmt(sanity)
        cls.addstmt(cxx.Whitespace.NL)

        cls.addstmt(cxx.Label.PUBLIC)
        # default ctor
        cls.addstmt(
            cxx.ConstructorDefn(
                cxx.ConstructorDecl(ud.name),
                [ cxx.ExprMemberInit(mtypevar,
                                     [ cxx.ExprCast(cxx.ExprLiteral.ZERO,
                                                    typetype,
                                                    static=1) ]) ]))
        for copyctor in copyctors:
            cls.addstmt(copyctor)
        # copy ctor(const Union&)
        copyctordecl = deepcopy(basiccopydecl)
        copyctordecl.params[0].type.name = ud.name
        copyctor = cxx.MethodDefn(copyctordecl)
        copyctor.addstmt(cxx.StmtExpr(cxx.ExprCall(
            cxx.ExprSelect(valuevar,
                           '.', assertsanityvar.name))))
        copyctor.addstmt(cxx.StmtExpr(
            cxx.ExprAssn(mtypevar,
                         cxx.ExprSelect(valuevar,
                                        '.', 'mType'))))
        copyctor.addstmt(copyswitch)
        cls.addstmt(copyctor)
        cls.addstmt(cxx.Whitespace.NL)

        # dtor
        # we'll hit the default: case if the union var was never assigned
        dtorswitch.addstmt(cxx.DefaultLabel())
        dtorswitch.addstmt(cxx.StmtBreak())
        dtor = cxx.DestructorDefn(cxx.DestructorDecl(ud.name))
        dtor.addstmt(dtorswitch)
        cls.addstmt(dtor)
        cls.addstmt(cxx.Whitespace.NL)

        # operator='s
        for opeq in opeqs:
            cls.addstmt(opeq)
        opeqdecl = deepcopy(basicopeqdecl)
        opeqdecl.params[0].type.name = ud.name
        opeq = cxx.MethodDefn(opeqdecl)
        opeq.addstmt(cxx.StmtExpr(
            cxx.ExprCall(cxx.ExprSelect(rhsvar, '.', assertsanityvar.name))))
        opeq.addstmt(cxx.StmtExpr(
            cxx.ExprAssn(mtypevar, cxx.ExprSelect(rhsvar, '.', 'mType'))))
        opeq.addstmt(opeqswitch)
        opeq.addstmt(cxx.StmtReturn(cxx.ExprDeref(cxx.ExprVar('this'))))
        cls.addstmt(opeq)
        cls.addstmt(cxx.Whitespace.NL)

        # |operator [type]|'s and get_[type]s
        for optype in optypes:
            cls.addstmt(optype)
        for opconsttype in opconsttypes:
            cls.addstmt(opconsttype)
        for gettype in gettypes:
            cls.addstmt(gettype)
        for getconsttype in getconsttypes:
            cls.addstmt(getconsttype)
        cls.addstmt(cxx.Whitespace.NL)

        gettype = cxx.MethodDefn(cxx.MethodDecl('type', ret=typetype, const=1))
        gettype.addstmt(cxx.StmtExpr(cxx.ExprCall(assertsanityvar)))
        gettype.addstmt(cxx.StmtReturn(mtypevar))
        cls.addstmt(gettype)
        cls.addstmt(cxx.Whitespace.NL)

        cls.addstmt(cxx.Label.PRIVATE)
        cls.addstmt(cxx.StmtDecl(cxx.Decl(typetype, 'mType')))
        cls.addstmt(cxx.StmtDecl(cxx.Decl(valuetype, 'mValue')))

        # the "ParamTraits" specialization:
        # serialization, deserialization, and logging
        uniontype = cxx.Type(ud.decl.type.fullname())
        pickle = cxx.Class('ParamTraits', specializes=uniontype, struct=1)
        pickle.addstmt(cxx.Label.PRIVATE)
        for td in usingTypedefs:
            pickle.addstmt(td)
        pickle.addstmt(cxx.Typedef(cxx.Type('mozilla::ipc::ActorHandle'),
                                   'ActorHandle'))
        pickle.addstmt(cxx.Label.PUBLIC)
        pickle.addstmt(cxx.Typedef(uniontype, 'paramType'))
        pickle.addstmt(cxx.Whitespace.NL)

        serialize = cxx.MethodDefn(cxx.MethodDecl(
            'Write',
            params=[ cxx.Decl(cxx.Type('Message', ptr=1), 'aMsg'),
                     cxx.Decl(cxx.Type('paramType', const=1, ref=1), 'aParam') ],
            ret=cxx.Type('void'),
            static=1))
        serialize.addstmt(cxx.StmtExpr(
            cxx.ExprCall(
                cxx.ExprVar('WriteParam'),
                args=[
                    cxx.ExprVar('aMsg'),
                    cxx.ExprCast(
                        cxx.ExprCall(
                            cxx.ExprSelect(cxx.ExprVar('aParam'),
                                           '.', 'type')),
                        cxx.Type('int'),
                        static=1) ])))
        # default: blow up
        writeswitch.addstmt(cxx.DefaultLabel())
        writeswitch.addstmt(hardabort)
        serialize.addstmt(writeswitch)
        pickle.addstmt(serialize)

        deserialize = cxx.MethodDefn(
            cxx.MethodDecl(
                'Read',
                params=[ cxx.Decl(cxx.Type('Message', const=1, ptr=1),
                                  'aMsg'),
                         cxx.Decl(cxx.Type('void', ptrptr=1),
                                  'aIter'),
                         cxx.Decl(cxx.Type('paramType', ptr=1),
                                  'aResult') ],
                ret=cxx.Type('bool'),
                static=1))
        deserialize.addstmt(cxx.StmtDecl(cxx.Decl(cxx.Type('int'), 'type')))
        readtype = cxx.ExprCall(
            cxx.ExprVar('ReadParam'),
            args=[ cxx.ExprVar('aMsg'),
                   cxx.ExprVar('aIter'),
                   cxx.ExprAddrOf(cxx.ExprVar('type')) ])
        failif = cxx.StmtIf(cxx.ExprPrefixUnop(readtype, '!'))
        failif.ifb.addstmt(returnfalse)
        deserialize.addstmt(failif)
        # default: blow up
        readswitch.addstmt(cxx.DefaultLabel())
        readswitch.addstmt(returnfalse)
        deserialize.addstmt(readswitch)
        pickle.addstmt(deserialize)

        logger = cxx.MethodDefn(
            cxx.MethodDecl(
                'Log',
                params=[ cxx.Decl(cxx.Type('paramType', const=1, ref=1),
                                  'aParam'),
                         cxx.Decl(cxx.Type('std::wstring', ptr=1),
                                  'aLog') ],
                static=1))
        # FIXME: real implementation
        logger.addstmt(cxx.StmtExpr(cxx.ExprCall(
            cxx.ExprSelect(cxx.ExprVar('aLog'), '->', 'append'),
            args=[ cxx.ExprLiteral.WString('('+ ud.name +')') ])))
        pickle.addstmt(logger)

        # preserves information about which component types
        # are actors, and what the type tags of those actors
        # are.  we use this info for the special-cased code
        # in Send/Recv methods
        ud.decl.type._cxxunion = union

        # stick generated classes into the right namespaces
        if 0 == len(ud.namespaces):
            nscls = cls
        else:
            nscls = cxx.Namespace(ud.namespaces[0].namespace)
            innerns = nscls
            for ns in ud.namespaces[1:]:
                tmp = cxx.Namespace(ns.namespace)
                innerns.addstmt(tmp)
                innerns = tmp
            innerns.addstmt(cls)

        nspickle = cxx.Namespace('IPC')
        nspickle.addstmt(pickle)

        self.file.addthing(cxx.Whitespace.NL)
        for fd in forwarddecls:
            self.file.addthing(fd)
            self.file.addthing(cxx.Whitespace.NL)
        self.file.addthing(cxx.Whitespace.NL)
        self.file.addthing(nscls)
        self.file.addthing(cxx.Whitespace.NL)
        self.file.addthing(nspickle)
        self.file.addthing(cxx.Whitespace.NL)


    def visitUsingStmt(self, using):
        if using.decl.fullname is not None:
            self.typedef(using.decl.fullname, using.decl.shortname)


    def visitProtocol(self, p):
        self.file.addthing(cxx.Whitespace.NL)

        # construct the namespace into which we'll stick all our decls
        if 0 == len(p.namespaces):
            self.ns = self.file
        else:
            innernamespaces = p.namespaces[1:]
            self.ns = cxx.Namespace(p.namespaces[0].namespace)
            self.file.addthing(self.ns)

            for ns in innernamespaces:
                innerns = cxx.Namespace(ns.namespace)
                self.ns.addstmt(innerns)
                self.ns = innerns

        ns = cxx.Namespace(self.pname)
        self.ns.addstmt(ns)
        self.ns = ns
        ns.addstmt(cxx.Whitespace.NL)
        ns.addstmt(cxx.Whitespace.NL)

        # state information
        stateenum = cxx.TypeEnum('State')
        for ts in p.transitionStmts:
            ts.accept(self)
            stateenum.addId(ts.state.decl._cxxname)
        if len(p.transitionStmts):
            startstate = p.transitionStmts[0].state.decl._cxxname
        else:
            startstate = '0'
        stateenum.addId('StateStart', startstate)
        stateenum.addId('StateError')
        stateenum.addId('StateLast')

        ns.addstmt(cxx.StmtDecl(cxx.Decl(stateenum, '')))
        ns.addstmt(cxx.Whitespace.NL)

        # previsit the messages and stash away some common info used
        # several times later
        for md in p.messageDecls:
            md.accept(self)

        # spit out message type enum and classes
        msgstart = self.pname +'MsgStart << 12'
        msgenum = cxx.TypeEnum('MessageType')
        msgenum.addId(self.pname +'Start', msgstart)
        msgenum.addId(self.pname +'PreStart', '('+ msgstart +') - 1')

        for md in p.messageDecls:
            msgenum.addId(md._cxx.id +'__ID')
            if md.decl.type.hasReply():
                msgenum.addId(md._cxx.replyid +'__ID')            

        msgenum.addId(self.pname +'End')
        ns.addstmt(cxx.StmtDecl(cxx.Decl(msgenum, '')))
        ns.addstmt(cxx.Whitespace.NL)

        for md in p.messageDecls:
            ns.addstmt(generateMessageClass(md, self.injectTypedefs))
            if md.decl.type.hasReply():
                ns.addstmt(generateReplyClass(md, self.injectTypedefs))

        ns.addstmt(cxx.Whitespace.NL)
        ns.addstmt(cxx.Whitespace.NL)


    def visitMessageDecl(self, md):
        # where we squirrel away some common information
        md._cxx = _struct()

        def canonicalType(t):
            cxxt = cxx.Type(t.name())
            if t.isIPDL() and t.isUnion():
                cxxt._union = t._cxxunion
            else:
                cxxt._union = None

            if t.isIPDL() and t.isActor():
                cxxt.actor = 1
                cxxt.ptr = 1

            return cxxt

        def makeCxxDecl(decl):
            return cxx.Decl(canonicalType(decl.type),
                            decl.progname)

        md._cxx.params = [ makeCxxDecl(d) for d in md.inParams ]
        md._cxx.returns = [ makeCxxDecl(d) for d in md.outParams ]

        # generate C++ interface to message sending/handling
        method = cxx.MethodDecl(
            name=md.decl.progname,
            params=[ ],
            ret=cxx.Type('nsresult'),
            virtual=True)
        for param in md._cxx.params:
            pcopy = deepcopy(param)
            pcopy.type.const = True
            if not param.type.actor:
                pcopy.type.ref = True
            method.params.append(pcopy)
        for ret in md._cxx.returns:
            rcopy = deepcopy(ret)
            if rcopy.type.actor:
                rcopy.type.ptrptr = True
            else:
                rcopy.type.ptr = True
            method.params.append(rcopy)
        md._cxx.method = method

        # the ID is used by the IPC layer only
        md._cxx.id = 'Msg_%s'% (md.decl.progname)
        md._cxx.nsid = '%s::%s'% (self.pname, md._cxx.id)
        if md.decl.type.hasReply():
            md._cxx.replyid = 'Reply_%s'% (md.decl.progname)
            md._cxx.nsreplyid = '%s::%s'% (self.pname, md._cxx.replyid)


    def visitTransitionStmt(self, ts):
        ts.state.decl._cxxname = 'State_%s__ID'% (ts.state.decl.progname)


def generateMsgClass(md, clsname, params, typedefInjector):
        cls = cxx.Class(name=clsname,
                        inherits=[ cxx.Inherit('IPC::Message') ])
        cls.addstmt(cxx.Label.PRIVATE)
        typedefInjector(cls)
        cls.addstmt(cxx.Whitespace.NL)

        cls.addstmt(cxx.Label.PUBLIC)

        idenum = cxx.TypeEnum()
        idenum.addId('ID', clsname +'__ID')
        cls.addstmt(cxx.StmtDecl(cxx.Decl(idenum, '')))

        constparams = deepcopy(params)
        writestmts = [ ]
        for cparam in constparams:
            if cparam.type.actor:
                # this is an actor. it goes across the wire as a Handle
                cparam.type = cxx.Type('mozilla::ipc::ActorHandle')
            cparam.type.const = True
            cparam.type.ref = True

        if md.decl.type.hasImplicitActorParam():
            constparams.append(cxx.Decl(
                    cxx.Type('mozilla::ipc::ActorHandle', const=1, ref=1),
                    '__ah'))

        # make the message constructor (serializer)
        ctordecl = cxx.ConstructorDecl(clsname, params=constparams)

        superinit = cxx.ExprMemberInit(
            cxx.ExprVar('IPC::Message'),
            [ cxx.ExprVar('MSG_ROUTING_NONE'),
              cxx.ExprVar('ID'),
              cxx.ExprVar('PRIORITY_NORMAL') ])

        ctor = cxx.ConstructorDefn(ctordecl, [ superinit ])
        for cparam in constparams:
            ctor.addstmt(
                cxx.StmtExpr(cxx.ExprCall(cxx.ExprVar('IPC::WriteParam'),
                                          [ cxx.ExprVar('this'),
                                            cxx.ExprVar(cparam.name) ])))
        cls.addstmt(ctor)
        cls.addstmt(cxx.Whitespace.NL)

        # make the message deserializer
        outparams = deepcopy(params)
        for oparam in outparams:
            if oparam.type.actor:
                # this is an actor. it comes across the wire as a Handle
                oparam.type = cxx.Type('mozilla::ipc::ActorHandle')
            oparam.type.ptr = True

        if md.decl.type.hasImplicitActorParam():
            outparams.append(cxx.Decl(
                    cxx.Type('mozilla::ipc::ActorHandle', ptr=1),
                    '__ah'))

        reader = cxx.MethodDefn(
            cxx.MethodDecl(
                'Read',
                params=([ cxx.Decl(cxx.Type('Message', ptr=True, const=True),
                                   'msg') ]
                        + outparams),
                ret=cxx.Type('bool'),
                static=True))

        # avoid generating an unused variable when we don't deserialize
        # anything.  why generate the method anyway?  it keeps other code
        # consistent, and we might do some checking in here eventually
        if len(outparams):
            # hack
            reader.addstmt(
                cxx.StmtDecl(cxx.Decl(cxx.Type('void', ptr=True), 'iter = 0')))
            reader.addstmt(cxx.Whitespace.NL)

        for oparam in outparams:
            cond = cxx.ExprPrefixUnop(
                cxx.ExprCall(cxx.ExprVar('IPC::ReadParam'),
                             [ cxx.ExprVar('msg'),
                               cxx.ExprAddrOf(cxx.ExprVar('iter')),
                               cxx.ExprVar(oparam.name) ]),
                '!')
            ifstmt = cxx.StmtIf(cond)
            # false isn't a var
            ifstmt.addifstmt(cxx.StmtReturn(cxx.ExprVar('false')))
            reader.addstmt(ifstmt)
            reader.addstmt(cxx.Whitespace.NL)

        # false isn't a var
        reader.addstmt(cxx.StmtReturn(cxx.ExprVar('true')))

        cls.addstmt(reader)
        cls.addstmt(cxx.Whitespace.NL)

        # generate a logging function
        # 'pfx' will be something like "[FooParent] sent"
        logger = cxx.MethodDefn(
            cxx.MethodDecl(
                'Log',
                params=([ cxx.Decl(cxx.Type('std::string', const=1, ref=1),
                                   '__pfx'),
                          cxx.Decl(cxx.Type('FILE', ptr=True), '__outf') ]),
                const=1))
        pfxvar = cxx.ExprVar('__pfx')
        outfvar = cxx.ExprVar('__outf')
        # TODO/cjones: allow selecting what information is printed to 
        # the log
        logger.addstmt(cxx.StmtDecl(cxx.Decl(cxx.Type('std::string'),
                                             '__logmsg')))
        msgvar = cxx.ExprVar('__logmsg')
        def appendToMsg(thing):
            logger.addstmt(cxx.StmtExpr(cxx.ExprCall(
                        cxx.ExprSelect(msgvar, '.', 'append'),
                        [ thing ])))

        # XXX/cjones: OK to stick this before prefix?
        logger.addstmt(cxx.StmtExpr(
                cxx.ExprCall(cxx.ExprVar('StringAppendF'),
                             [ cxx.ExprAddrOf(msgvar),
                               cxx.ExprLiteral.String('[time:%" PRId64 "]'),
                               cxx.ExprCall(cxx.ExprVar('PR_Now')) ])))
        appendToMsg(pfxvar)
        appendToMsg(cxx.ExprLiteral.String(md.decl.progname +'('))
        logger.addstmt(cxx.Whitespace.NL)

        # call the deserializing method we created above
        for oparam in outparams:
            oparam = deepcopy(oparam)
            oparam.type.ptr = 0
            logger.addstmt(cxx.StmtDecl(oparam))
        errif = cxx.StmtIf(cxx.ExprCall(
                    cxx.ExprVar('Read'),
                    ([ cxx.ExprVar('this') ]
                     + [ cxx.ExprAddrOf(cxx.ExprVar(p.name))
                         for p in outparams ])))
        # case where successfully deserialized message

        # XXX we have to do this string/wstring garbage because of 
        # our incompatible compilation of chromium and mozilla string
        # code with gcc
        errif.addifstmt(cxx.StmtDecl(cxx.Decl(cxx.Type('std::wstring'), 
                                            '__param')))
        paramvar = cxx.ExprVar('__param')
        for oparam in outparams:
            # FIXME/cjones: this code doesn't work on gcc/POSIX,
            # because it wprintf()s across the chromium/mozilla boundary.
            # one side has -fshort-wchar, the other doesn't.  not
            # feasible.  either message logging needs to be rewritten, or
            # -fshort-wchar needs to be disabled (again)

            if EMIT_LOGGING_CODE:
                errif.addifstmt(cxx.StmtExpr(cxx.ExprCall(
                            cxx.ExprVar('IPC::LogParam'),
                            [ cxx.ExprVar(oparam.name),
                              cxx.ExprAddrOf(paramvar) ])))
                errif.addifstmt(cxx.StmtExpr(cxx.ExprCall(
                            cxx.ExprSelect(msgvar, '.', 'append'),
                            [ cxx.ExprCall(cxx.ExprVar('WideToUTF8'),
                                           [ paramvar ]) ])))
                errif.addifstmt(cxx.StmtExpr(cxx.ExprCall(
                            cxx.ExprSelect(msgvar, '.', 'append'),
                            [ cxx.ExprLiteral.String(', ') ])))
                errif.addifstmt(cxx.StmtExpr(cxx.ExprCall(
                            cxx.ExprSelect(paramvar, '.', 'clear'))))
            else:
                errif.addifstmt(cxx.StmtExpr(cxx.ExprCall(
                            cxx.ExprSelect(msgvar, '.', 'append'),
                            [ cxx.ExprLiteral.String('FIXME, ') ])))

        # case where we couldn't deserialize the message
        errif.addelsestmt(cxx.StmtExpr(
                cxx.ExprCall(cxx.ExprSelect(msgvar, '.', 'append'),
                             [ cxx.ExprLiteral.String('!!INVALID MSG!!') ])))
        logger.addstmt(errif)

        logger.addstmt(cxx.Whitespace.NL)
        appendToMsg(cxx.ExprLiteral.String(')\\n'))

        # and actually print the log message
        logger.addstmt(cxx.StmtExpr(cxx.ExprCall(
                    cxx.ExprVar('fputs'),
                    [ cxx.ExprCall(cxx.ExprSelect(msgvar, '.', 'c_str')),
                      outfvar ])))

        cls.addstmt(logger)

        return cls

def generateMessageClass(md, typedefInjector):
    return generateMsgClass(md, md._cxx.id, md._cxx.params, typedefInjector)

def generateReplyClass(md, typedefInjector):
    return generateMsgClass(md, md._cxx.replyid, md._cxx.returns, typedefInjector)


##-----------------------------------------------------------------------------
_channelTable = {
    ASYNC: [ 'mozilla', 'ipc', 'AsyncChannel' ],
    SYNC: [ 'mozilla', 'ipc', 'SyncChannel' ],
    RPC: [ 'mozilla', 'ipc', 'RPCChannel' ]
}
_listenerTable = {
    ASYNC: 'AsyncListener',
    SYNC: 'SyncListener',
    RPC: 'RPCListener',
}

# helper functions for converting between actors and actor handles
def _actorToActorHandle(actor, handle, failcode):
    failifnull = cxx.StmtIf(cxx.ExprPrefixUnop(actor, '!'))
    failifnull.addifstmt(cxx.StmtReturn(failcode))
    convert = cxx.StmtExpr(cxx.ExprAssn(
        cxx.ExprSelect(handle, '.', 'mId'),
        cxx.ExprSelect(actor, '->', 'mId')))
    return failifnull, convert

def _actorHandleToActor(handle, actor, actortype, failcode):
    idvar = cxx.ExprSelect(handle, '.', 'mId')
    cast = cxx.ExprCast(
        cxx.ExprCall(cxx.ExprVar('Lookup'), [ idvar ]),
        actortype,
        static=1)
    caststmt = cxx.StmtExpr(cxx.ExprAssn(actor, cast))

    failif = cxx.StmtIf(cxx.ExprPrefixUnop(actor, '!'))
    failif.ifb.addstmt(cxx.StmtReturn(failcode))

    return caststmt, failif


class GenerateProtocolActorHeader(Visitor):
    def __init__(self, myside, otherside):
        self.myside = myside  # "Parent" or "Child"
        self.otherside = otherside
        self.clsname = None
        self.pname = None
        self.file = None
        self.ns = None
        self.typedefs = None

    def lower(self, tu, pname, clsname, cxxHeaderFile, typedefs):
        self.pname = pname
        self.clsname = clsname
        self.file = cxxHeaderFile
        self.typedefs = deepcopy(typedefs)
        tu.accept(self)

    def visitTranslationUnit(self, tu):
        f = self.file

        f.addthing(cxx.Whitespace('''//
// Automatically generated by ipdlc.
// Edit at your own risk
//

'''))
        includeguard = _protocolIncludeGuard(tu.protocol, self.clsname)
        f.addthing(cxx.CppDirective('ifndef', includeguard))
        f.addthing(cxx.CppDirective('define', includeguard))
        f.addthing(cxx.Whitespace.NL)

        mainheader = _protocolHeaderFilename(tu.protocol, self.pname)
        f.addthing(cxx.CppDirective('include', '"'+ mainheader +'"'))

        self.protocol = tu.protocol

        for pinc in tu.protocolIncludes:
            pinc.accept(self)

        tu.protocol.accept(self)

        f.addthing(cxx.Whitespace.NL)
        f.addthing(cxx.CppDirective('endif', '// ifndef '+ includeguard))

    def visitProtocolInclude(self, pi):
        p = pi.tu.protocol

        if self.protocol.decl.type.isManagerOf(p.decl.type):
            header = _protocolHeaderFilename(
                p, _actorName(p.name, self.myside))
            self.file.addthing(cxx.CppDirective('include', '"'+ header +'"'))
        else:
            self.file.addthing(_makeForwardDecl(p.decl.type, self.myside))
            
        if p.decl.fullname is not None:
            self.typedefs.append(cxx.Typedef(
                cxx.Type(_actorName(p.decl.fullname, self.myside)),
                _actorName(p.decl.shortname, self.myside)))

    def visitProtocol(self, p):
        p._cxx = _struct()

        self.file.addthing(cxx.CppDirective('ifdef', 'DEBUG'))
        self.file.addthing(cxx.CppDirective('include', '"prenv.h"'))
        self.file.addthing(cxx.CppDirective('endif', '// DEBUG'))

        # FIXME: all actors impl Iface for now
        if p.decl.type.isManager() or 1:
            self.file.addthing(cxx.CppDirective('include', '"base/id_map.h"'))

        # bug 510041: we need to claim to implement the listener
        # interface for the top-level protocol's channel type, rather
        # for the channel type that this protocol wants
        sendsemantics = p.decl.type.toplevel().sendSemantics
        channel = _channelTable[sendsemantics]
        channellistener = _listenerTable[sendsemantics]
        channelname = '::'.join(channel)
        channelfile = '/'.join(channel) +'.h'
        if p.decl.type.isToplevel():
            self.channelsel = '.'
        else:
            self.channelsel = '->'

        self.file.addthing(cxx.CppDirective('include', '"'+ channelfile +'"'))
        self.file.addthing(cxx.Whitespace.NL)

        # construct the namespace into which we'll stick all our decls
        if 0 == len(p.namespaces):
            self.ns = self.file
        else:
            innernamespaces = p.namespaces[1:]
            self.ns = cxx.Namespace(p.namespaces[0].namespace)
            self.file.addthing(self.ns)

            for ns in innernamespaces:
                innerns = cxx.Namespace(ns.namespace)
                self.ns.addstmt(innerns)
                self.ns = innerns

        self.ns.addstmt(cxx.Whitespace.NL)
        self.ns.addstmt(cxx.Whitespace.NL)

        channellistener = channelname +'::'+ channellistener
        p._cxx.managertype = (
            'mozilla::ipc::IProtocolManager<'+ channellistener +'>')
        if p.decl.type.isToplevel():
            p._cxx.routeidvar = cxx.ExprVar('mLastRouteId')
            if self.myside is 'Parent':
                op = '++'
            else:
                op = '--'
            p._cxx.nextRouteId = cxx.ExprPrefixUnop(p._cxx.routeidvar, op)

        inherits = [ cxx.Inherit(channellistener) ]
        if p.decl.type.isManager():
            inherits.append(cxx.Inherit(p._cxx.managertype))
        cls = cxx.Class(self.clsname, inherits=inherits, abstract=True)

        if p.decl.type.isManaged():
            cls.addstmt(cxx.FriendClassDecl(
                _actorName(p.decl.type.manager.fullname(),
                           self.myside)))
            cls.addstmt(cxx.Whitespace.NL)

        cls.addstmt(cxx.Label.PROTECTED)
        for typedef in self.typedefs:
            cls.addstmt(typedef)
        cls.addstmt(cxx.Whitespace.NL)

        # message handlers the subclass has to impl
        for md in p.messageDecls:
            if md.decl.type.isCtor() or md.decl.type.isDtor():
                objtype = cxx.Type(
                    _actorName(md.decl.type.constructedType().name(),
                               self.myside),
                    ptr=1)
                meth = deepcopy(md._cxx.method)
                for param in meth.params:
                    if param.type.actor:
                        param.type.name = _actorName(param.type.name,
                                                     self.myside)
                meth.pure = True

                actordecl = cxx.Decl(objtype, '__a')
                if md.decl.type.isCtor():
                    meth.ret = objtype
                else:
                    meth.params.insert(0, actordecl)
                cls.addstmt(cxx.StmtDecl(meth))

            if self.receivesMessage(md):
                if md.decl.type.isRpc():  pfx = 'Answer'
                else:                     pfx = 'Recv'
                meth = deepcopy(md._cxx.method)
                for param in meth.params:
                    if param.type.actor:
                        param.type.name = _actorName(param.type.name,
                                                     self.myside)
                meth.name = pfx + meth.name
                if md.decl.type.isCtor() or md.decl.type.isDtor():
                    # allow implementations to receive a notification
                    # of "RecvCtor()" or "RecvDtor()" if they override
                    # this do-nothing virtual method
                    meth.params.insert(0, actordecl)
                    meth.virtual = True
                    dummyimpl = cxx.MethodDefn(meth)
                    dummyimpl.addstmt(cxx.StmtReturn(cxx.ExprVar('NS_OK')))
                    cls.addstmt(dummyimpl)
                else:
                    meth.pure = True
                    cls.addstmt(cxx.StmtDecl(meth))
        cls.addstmt(cxx.Whitespace.NL)

        cls.addstmt(cxx.Label.PRIVATE)
        cls.addstmt(cxx.Typedef(cxx.Type('IPC::Message'),
                                'Message'))
        cls.addstmt(cxx.Typedef(cxx.Type(channelname),
                                'Channel'))
        cls.addstmt(cxx.Typedef(cxx.Type(channellistener),
                                'ChannelListener'))
        cls.addstmt(cxx.Whitespace.NL)
        
        cls.addstmt(cxx.Label.PUBLIC)
        ctor = cxx.ConstructorDefn(cxx.ConstructorDecl(self.clsname))
        if p.decl.type.isToplevel():
            ctor.memberinits = [
                cxx.ExprMemberInit(
                    cxx.ExprVar('mChannel'),
                    [ cxx.ExprCall(
                            cxx.ExprVar('ALLOW_THIS_IN_INITIALIZER_LIST'),
                            [ cxx.ExprVar('this') ]) ]) ]
        ctor.addstmt(cxx.StmtExpr(cxx.ExprCall(cxx.ExprVar('MOZ_COUNT_CTOR'),
                                               [ cxx.ExprVar(self.clsname) ])))
        cls.addstmt(ctor)
        cls.addstmt(cxx.Whitespace.NL)

        dtor = cxx.DestructorDefn(
            cxx.DestructorDecl(self.clsname, virtual=True))
        dtor.addstmt(cxx.StmtExpr(cxx.ExprCall(cxx.ExprVar('MOZ_COUNT_DTOR'),
                                               [ cxx.ExprVar(self.clsname) ])))
        cls.addstmt(dtor)
        cls.addstmt(cxx.Whitespace.NL)

        if p.decl.type.isToplevel():
            # open
            openmeth = cxx.MethodDefn(
                cxx.MethodDecl(
                    'Open',
                    params=[ cxx.Decl(cxx.Type('Channel::Transport', ptr=True),
                                      'aTransport'),
                             cxx.Decl(cxx.Type('MessageLoop', ptr=True),
                                      'aThread = 0') ],
                    ret=cxx.Type('bool')))
            atransportvar = cxx.ExprVar('aTransport')
            mchannelvar = cxx.ExprVar('mChannel')
            openmeth.addstmt(cxx.StmtReturn(
                    cxx.ExprCall(
                        cxx.ExprSelect(mchannelvar, '.', 'Open'),
                        [ atransportvar, cxx.ExprVar('aThread') ])))
            cls.addstmt(openmeth)
            cls.addstmt(cxx.Whitespace.NL)

            # close
            closemeth = cxx.MethodDefn(cxx.MethodDecl('Close'))
            closemeth.addstmt(cxx.StmtExpr(
                    cxx.ExprCall(
                        cxx.ExprSelect(mchannelvar, '.', 'Close'))))
            cls.addstmt(closemeth)
            cls.addstmt(cxx.Whitespace.NL)

        # incoming message dispatchers
        self.asyncswitch = cxx.StmtSwitch(
            cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('msg'), '.', 'type'), [ ]))
        if p.decl.type.toplevel().talksSync():
            self.syncswitch = deepcopy(self.asyncswitch)
            if p.decl.type.toplevel().talksRpc():
                self.rpcswitch = deepcopy(self.syncswitch)

        # implement child iface and add handlers to message switches
        self.cls = cls
        self.p = p
        for md in p.messageDecls:
            self.visitMessageDecl(md)

        # add default cases
        default = cxx.StmtBlock()
        default.addstmt(cxx.StmtReturn(cxx.ExprVar('MsgNotKnown')))
        
        self.asyncswitch.addcase(cxx.DefaultLabel(), default)
        if p.decl.type.toplevel().talksSync():
            self.syncswitch.addcase(cxx.DefaultLabel(), default)
            if p.decl.type.toplevel().talksRpc():
                self.rpcswitch.addcase(cxx.DefaultLabel(), default)

        asynchandler = cxx.MethodDefn(
            cxx.MethodDecl(
                'OnMessageReceived', virtual=True,
                params=[ cxx.Decl(cxx.Type('Message', const=1, ref=1),'msg') ],
                ret=cxx.Type('Result')))

        if p.decl.type.toplevel().talksSync():
            synchandler = deepcopy(asynchandler)
            synchandler.decl.params.append(cxx.Decl(
                    cxx.Type('Message', ref=1, ptr=1), 'reply'))

            if p.decl.type.toplevel().talksRpc():
                rpchandler = deepcopy(synchandler)
                rpchandler.decl.name = 'OnCallReceived'


        def addDispatcher(mdefn, dispatchMethod, params):
            mdefn.addstmt(cxx.StmtDecl(cxx.Decl(cxx.Type('int'), '__route')))
            routevar = cxx.ExprVar('__route')
            mdefn.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                        routevar,
                        cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('msg'),
                                                    '.', 'routing_id')))))
            routeif = cxx.StmtIf(cxx.ExprBinary(
                    cxx.ExprVar('MSG_ROUTING_CONTROL'), '!=', routevar))
            routeif.ifb.addstmt(cxx.StmtDecl(cxx.Decl(
                        cxx.Type('ChannelListener', ptr=1), '__routed')))
            routedvar = cxx.ExprVar('__routed')
            routeif.ifb.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                        routedvar,
                        cxx.ExprCall(cxx.ExprVar('Lookup'), [ routevar ]))))

            failif = cxx.StmtIf(cxx.ExprPrefixUnop(routedvar, '!'))
            failif.ifb.addstmt(cxx.StmtReturn(cxx.ExprVar('MsgRouteError')))
            routeif.ifb.addstmt(failif)

            routeif.ifb.addstmt(cxx.StmtReturn(cxx.ExprCall(
                        cxx.ExprSelect(routedvar, '->', dispatchMethod),
                        params)))
            mdefn.addstmt(routeif)
            mdefn.addstmt(cxx.Whitespace.NL)

        dispatches = p.decl.type.isToplevel() and p.decl.type.isManager()

        if dispatches:
            addDispatcher(asynchandler, 'OnMessageReceived',
                          [ cxx.ExprVar('msg') ])
        # bug 509581: don't generate the switch stmt if there is only the 
        # default case; MSVC doesn't like that
        reterror = cxx.StmtReturn(cxx.ExprVar('MsgNotKnown'))

        if self.asyncswitch.nr_cases > 1:
            asynchandler.addstmt(self.asyncswitch)
        else:
            asynchandler.addstmt(reterror)
        cls.addstmt(asynchandler)
        cls.addstmt(cxx.Whitespace.NL)

        if p.decl.type.toplevel().talksSync():
            if dispatches:
                addDispatcher(synchandler, 'OnMessageReceived',
                              [ cxx.ExprVar('msg'), cxx.ExprVar('reply') ])
            if self.syncswitch.nr_cases > 1:
                synchandler.addstmt(self.syncswitch)
            else:
                synchandler.addstmt(reterror)
            cls.addstmt(synchandler)
            cls.addstmt(cxx.Whitespace.NL)

            if p.decl.type.toplevel().talksRpc():
                if dispatches:
                    addDispatcher(rpchandler, 'OnCallReceived',
                                  [ cxx.ExprVar('msg'), cxx.ExprVar('reply') ])
                if self.rpcswitch.nr_cases > 1:
                    rpchandler.addstmt(self.rpcswitch)
                else:
                    rpchandler.addstmt(reterror)
                cls.addstmt(rpchandler)
                cls.addstmt(cxx.Whitespace.NL)

        # implement IProtocolManager interface.
        #
        # FIXME: only manager protocols and non-manager protocols with
        # union types need Lookup().  we'll give it to all for the
        # time being (simpler)
        if 1 or p.decl.type.isManager():
            register = cxx.MethodDefn(
                cxx.MethodDecl(
                    'Register',
                    [ cxx.Decl(cxx.Type('ChannelListener', ptr=1), 'aRouted') ],
                    ret=cxx.Type('int32'),
                    virtual=1))
            registerid = cxx.MethodDefn(
                cxx.MethodDecl(
                    'RegisterID',
                    [ cxx.Decl(cxx.Type('ChannelListener', ptr=1), 'aRouted'),
                      cxx.Decl(cxx.Type('int32'), 'aId') ],
                    ret=cxx.Type('int32'),
                    virtual=1))
            lookup = cxx.MethodDefn(
                cxx.MethodDecl(
                    'Lookup',
                    [ cxx.Decl(cxx.Type('int32'), 'aId') ],
                    ret=cxx.Type('ChannelListener', ptr=1),
                    virtual=1))
            unregister = cxx.MethodDefn(
                cxx.MethodDecl(
                    'Unregister',
                    [ cxx.Decl(cxx.Type('int32'), 'aId') ],
                    ret=cxx.Type('void'),
                    virtual=1))

            idvar = cxx.ExprVar('aId')
            if p.decl.type.isToplevel():
                register.addstmt(cxx.StmtDecl(cxx.Decl(cxx.Type('int'), 'tmp')))
                tmpvar = cxx.ExprVar('tmp')
                register.addstmt(cxx.StmtExpr(
                        cxx.ExprAssn(tmpvar,
                                     p._cxx.nextRouteId)))
                register.addstmt(cxx.StmtExpr(
                        cxx.ExprCall(
                            cxx.ExprSelect(cxx.ExprVar('mActorMap'),
                                           '.', 'AddWithID'),
                            [ cxx.ExprVar('aRouted'), tmpvar ])))
                register.addstmt(cxx.StmtReturn(tmpvar))

                registerid.addstmt(cxx.StmtExpr(
                        cxx.ExprCall(
                            cxx.ExprSelect(cxx.ExprVar('mActorMap'),
                                           '.', 'AddWithID'),
                            [ cxx.ExprVar('aRouted'), idvar ])))
                registerid.addstmt(cxx.StmtReturn(idvar))

                lookup.addstmt(cxx.StmtReturn(
                    cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('mActorMap'),
                                                '.', 'Lookup'),
                                 [ cxx.ExprVar('aId') ])))
                unregister.addstmt(cxx.StmtReturn(
                        cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('mActorMap'),
                                                    '.', 'Remove'),
                                     [ cxx.ExprVar('aId') ])))
            else:
                register.addstmt(cxx.StmtReturn(
                        cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('mManager'),
                                                    '->', 'Register'),
                                     [ cxx.ExprVar('aRouted') ])))
                registerid.addstmt(cxx.StmtReturn(
                        cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('mManager'),
                                                    '->', 'RegisterID'),
                                     [ cxx.ExprVar('aRouted'), 
                                       cxx.ExprVar('aId') ])))
                lookup.addstmt(cxx.StmtReturn(
                    cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('mManager'),
                                                '->', 'Lookup'),
                                 [ cxx.ExprVar('aId') ])))
                unregister.addstmt(cxx.StmtReturn(
                        cxx.ExprCall(cxx.ExprSelect(cxx.ExprVar('mManager'),
                                                    '->', 'Unregister'),
                                     [ cxx.ExprVar('aId') ])))
            cls.addstmt(register)
            cls.addstmt(registerid)
            cls.addstmt(lookup)
            cls.addstmt(unregister)
            cls.addstmt(cxx.Whitespace.NL)

        # private members and methods
        cls.addstmt(cxx.Label.PRIVATE)
        channeltype = cxx.Type('Channel')
        if p.decl.type.isManaged():
            channeltype.ptr = True # subprotocols inherit this
        cls.addstmt(cxx.StmtDecl(cxx.Decl(channeltype, 'mChannel')))
        # FIXME: all protocols get manager Iface
        if p.decl.type.isToplevel() and (1 or p.decl.type.isManager()):
            cls.addstmt(cxx.StmtDecl(cxx.Decl(
                        cxx.Type('IDMap<ChannelListener>'), 'mActorMap')))
            cls.addstmt(cxx.StmtDecl(cxx.Decl(
                        cxx.Type('int'), p._cxx.routeidvar.name)))
        elif p.decl.type.isManaged():
            cls.addstmt(cxx.StmtDecl(cxx.Decl(cxx.Type('int'), 'mId')))
            cls.addstmt(cxx.StmtDecl(cxx.Decl(cxx.Type('int'), 'mPeerId')))
            cls.addstmt(cxx.StmtDecl(cxx.Decl(
                        cxx.Type(p._cxx.managertype, ptr=1), 'mManager')))
        self.ns.addstmt(cls)
        self.ns.addstmt(cxx.Whitespace.NL)
        self.ns.addstmt(cxx.Whitespace.NL)

        # generate skeleton implementation of abstract actor class
        self.file.addthing(cxx.CppDirective('if', '0'))

        genskeleton = GenerateSkeletonImpl()
        genskeleton.fromclass(cls)
        [ self.file.addthing(thing) for thing in genskeleton.stuff ]

        self.file.addthing(cxx.CppDirective('endif', '// if 0'))


    def visitMessageDecl(self, md):
        def injectLogger(block, msgptr, note):
            block.addstmt(cxx.Whitespace.NL)
            block.addstmt(cxx.CppDirective('ifdef', 'DEBUG'))
            logif = cxx.StmtIf(cxx.ExprCall(
                    cxx.ExprVar('PR_GetEnv'),
                    [ cxx.ExprLiteral.String("MOZ_IPC_MESSAGE_LOG") ]))
            logif.addifstmt(cxx.StmtExpr(cxx.ExprCall(
                        cxx.ExprSelect(msgptr, '->', 'Log'),
                        [ cxx.ExprLiteral.String(
                                '['+ self.clsname +'] '+ note),
                          cxx.ExprVar('stderr') ])))
            block.addstmt(logif)
            block.addstmt(cxx.CppDirective('endif', '// ifdef DEBUG'))
            block.addstmt(cxx.Whitespace.NL)


        if self.sendsMessage(md):
            pfx = None
            if md.decl.type.isRpc():
                pfx = 'Call'
            else:
                pfx = 'Send'

            mdecl = deepcopy(md._cxx.method)
            for param in mdecl.params:
                if param.type.actor:
                    # needs a "side", i.e., Parent/Child
                    param.type.name = _actorName(param.type.name, self.myside)
            mdecl.name = pfx + mdecl.name
            mdecl.virtual = False
            if md.decl.type.hasImplicitActorParam():
                objtype = cxx.Type(
                    _actorName(md.decl.type.constructedType().name(),
                               self.myside),
                    ptr=1)
            if md.decl.type.isCtor():
                mdecl.ret = objtype
            elif md.decl.type.isDtor():
                mdecl.params.insert(0, cxx.Decl(objtype, '__a'))
                objvar = cxx.ExprVar('__a')
            impl = cxx.MethodDefn(mdecl)

            okcode = cxx.ExprVar('NS_OK')
            failerrcode = cxx.ExprVar('NS_ERROR_FAILURE')
            valueerrcode = cxx.ExprVar('NS_ERROR_ILLEGAL_VALUE')

            if md.decl.type.isCtor():
                #
                # for ctor messages, we construct two interface methods:
                #
                #   Actor* SendActorCtor(...)
                #   Actor* SendActorCtor(Actor*, ...)
                #
                # the first uses the ActorCtor() method provided
                # by the subclass implementing this interface,
                # and internally passes through to the second
                # SendActorCtor(Actor*, ...) method
                #
                # the second relies on the user to pass in a valid
                # concrete Actor* instantiation
                #

                # here |impl| is the first ctor interface above
                callctor = cxx.ExprCall(cxx.ExprVar(md._cxx.method.name),
                                        [ cxx.ExprVar(p.name) for
                                          p in md._cxx.method.params ])
                impl.addstmt(cxx.StmtReturn(
                    cxx.ExprCall(cxx.ExprVar(mdecl.name),
                                 ([ callctor ] +
                                  [ cxx.ExprVar(p.name) for
                                    p in md._cxx.method.params ]))))
                self.cls.addstmt(impl)
                self.cls.addstmt(cxx.Whitespace.NL)

                # now we make the second ctor interface
                mdecl = deepcopy(mdecl)
                mdecl.params.insert(0, cxx.Decl(objtype, '__a'))
                impl = cxx.MethodDefn(mdecl)

                objvar = cxx.ExprVar('__a')

                okcode = objvar
                failerrcode = cxx.ExprLiteral.ZERO
                valueerrcode = cxx.ExprLiteral.ZERO

                failif = cxx.StmtIf(cxx.ExprPrefixUnop(objvar, '!'))
                failif.ifb.addstmt(cxx.StmtReturn(cxx.ExprLiteral.ZERO))
                impl.addstmt(failif)

                objid = cxx.ExprSelect(objvar, '->', 'mId')
                impl.addstmt(cxx.StmtExpr(
                        cxx.ExprAssn(objid,
                                     cxx.ExprCall(cxx.ExprVar('Register'),
                                                  [ objvar ]))))

                impl.addstmt(cxx.StmtDecl(
                        cxx.Decl(cxx.Type('mozilla::ipc::ActorHandle'),
                                 '__ah')))
                ahvar = cxx.ExprVar('__ah')
                impl.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                            cxx.ExprSelect(ahvar, '.', 'mId'), objid)))

                impl.addstmt(cxx.Whitespace.NL)

            elif md.decl.type.isDtor():
                failif = cxx.StmtIf(cxx.ExprPrefixUnop(objvar, '!'))
                failif.ifb.addstmt(cxx.StmtReturn(valueerrcode))
                impl.addstmt(failif)

                # verify that this object indeed exists
                objid = cxx.ExprSelect(objvar, '->', 'mId')

                impl.addstmt(cxx.StmtDecl(cxx.Decl(objtype, '__b')))
                bvar = cxx.ExprVar('__b')
                impl.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                            bvar,
                            cxx.ExprCast(
                                cxx.ExprCall(cxx.ExprVar('Lookup'), [ objid ]),
                                objtype, static=1))))
                failif = cxx.StmtIf(cxx.ExprBinary(objvar, '!=', bvar))
                failif.ifb.addstmt(cxx.StmtReturn(valueerrcode))
                impl.addstmt(failif)
                impl.addstmt(cxx.Whitespace.NL)

                impl.addstmt(cxx.StmtDecl(cxx.Decl(
                            cxx.Type('mozilla::ipc::ActorHandle'), '__ah')))
                ahvar = cxx.ExprVar('__ah')
                impl.addstmt(cxx.StmtExpr(
                        cxx.ExprAssn(cxx.ExprSelect(ahvar, '.', 'mId'),
                                     objid)))
                impl.addstmt(cxx.Whitespace.NL)

            hasreply = md.decl.type.hasReply()
            if hasreply:
                impl.addstmt(cxx.StmtDecl(cxx.Decl(cxx.Type('Message'),
                                                   '__reply')))
                replyvar = cxx.ExprVar('__reply')

            impl.addstmt(cxx.StmtDecl(cxx.Decl(cxx.Type(md._cxx.nsid, ptr=1),
                                               '__msg')))
            msgvar = cxx.ExprVar('__msg')

            # special case for explicit actor params: they need to be
            # converted to Handle's before sending
            for param in mdecl.params:
                if not param.type.actor:
                    continue
                pavar = cxx.ExprVar(param.name)
                pahvar = cxx.ExprVar(param.name +'__ah')
                impl.addstmt(cxx.StmtDecl(cxx.Decl(
                    cxx.Type('mozilla::ipc::ActorHandle'), pahvar.name)))
                impl.addstmts(_actorToActorHandle(actor=pavar,
                                                  handle=pahvar,
                                                  failcode=valueerrcode))
            impl.addstmt(cxx.Whitespace.NL)

            # special case for IPDL union types: if a union
            # contains an actor type, we secretly convert
            # it into a serializable representation
            uahvars = [ ]
            wasrepackedvars = [ ]
            ruid = 0
            switches = [ ]
            for p in md._cxx.params:
                if (p.type._union is None
                    or not p.type._union.hasActor):
                    uahvars.append(None)
                    wasrepackedvars.append(None)
                    continue

                pvar = cxx.ExprVar(p.name)
                u = p.type._union

                uahdecl = cxx.StmtDecl(cxx.Decl(
                    cxx.Type('mozilla::ipc::ActorHandle'),
                    '__uah'+ str(ruid)))
                uahvar = cxx.ExprVar('__uah'+ str(ruid))
                uahvars.append( (uahdecl, uahvar) )

                wrvar = cxx.ExprVar('__wr_'+ str(ruid))
                wrdecl = cxx.StmtDecl(cxx.Decl(cxx.Type('bool'), wrvar.name))
                wasrepackedvars.append( (wrdecl, wrvar) )
                ruid += 1
                # if the union currently stores an actor, unpack the
                # pointer and repack it as an ActorHandle
                switch = cxx.StmtSwitch(cxx.ExprCall(
                    cxx.ExprSelect(pvar, '.', 'type')))
                for t, n in u.components:
                    if (t._ipdl is None
                        or self.myside is not t._side):
                        continue
                    switch.addstmt(cxx.CaseLabel(p.type.name +'::'+ t._tag))
                    repack = cxx.StmtBlock()
                    repack.addstmt(cxx.StmtDecl(cxx.Decl(t._realtype, '__ua')))

                    uavar = cxx.ExprVar('__ua')
                    # take the actor out of the union and convert it
                    # to an ActorHandle
                    #
                    # need to const_cast the union because it comes in
                    # as a const&.  we promise to be gentle
                    utype = deepcopy(p.type)
                    utype.ref = 1
                    repack.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                        uavar,
                        cxx.ExprCast(pvar, utype, const=1))))

                    repack.addstmts(_actorToActorHandle(actor=uavar,
                                                       handle=uahvar,
                                                       failcode=valueerrcode))

                    # record that this param indeed did have an actor param
                    repack.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                        wrvar, cxx.ExprVar('true'))))
                    repack.addstmt(cxx.StmtBreak())
                    switch.addstmt(repack)

                # if not actor type, don't care
                switch.addstmt(cxx.DefaultLabel())
                switch.addstmt(cxx.StmtBreak())
                switches.append(switch)

            for udv in uahvars:
                if udv is None: continue
                uahdecl, _ = udv
                impl.addstmt(uahdecl)
            for wrdv in wasrepackedvars:
                if wrdv is None: continue
                wrdecl, wrvar = wrdv
                impl.addstmt(wrdecl)
                impl.addstmt(cxx.StmtExpr(
                    cxx.ExprAssn(wrvar, cxx.ExprVar('false'))))
            impl.addstmt(cxx.Whitespace.NL)
                
            for switch in switches:
                impl.addstmt(switch)
            impl.addstmt(cxx.Whitespace.NL)

            msgctorargs = [ ]
            for i, param in enumerate(md._cxx.params):
                pvar = cxx.ExprVar(param.name)
                wrdv = wasrepackedvars[i]

                if wrdv is None:
                    # not a param with union type
                    if param.type.actor:
                        # explicit actor param.  need to send the Handle
                        pvar.name += '__ah'
                    msgctorargs.append(pvar)
                else:
                    wrvar = wrdv[1]
                    uahvar = uahvars[i][1]
                    # if the union-type variable had an actor value and
                    # was unpacked, send the re-packed ActorHandle.
                    # we rely on implicit conversion from ActorHandle
                    # to the union type
                    msgctorargs.append(
                        cxx.ExprConditional(wrvar, uahvar, pvar))
                
            if md.decl.type.hasImplicitActorParam():
                msgctorargs.append(ahvar)
                
            msgctor = cxx.ExprNew(cxx.Type(md._cxx.nsid), msgctorargs)
                
            if self.p.decl.type.isManaged():
                route = cxx.ExprVar('mId')
            else:
                route = cxx.ExprVar('MSG_ROUTING_CONTROL')

            impl.addstmt(cxx.StmtExpr(cxx.ExprAssn(msgvar, msgctor)))
            impl.addstmt(cxx.StmtExpr(
                    cxx.ExprCall(cxx.ExprSelect(msgvar, '->', 'set_routing_id'),
                                 [ route ])))

            if md.decl.type.isAsync():
                sendmethod = 'Send'
            elif md.decl.type.isSync():
                sendmethod = 'Send'
                impl.addstmt(cxx.StmtExpr(
                        cxx.ExprCall(cxx.ExprSelect(msgvar, '->', 'set_sync'),
                                     [ ])))
            elif md.decl.type.isRpc():
                sendmethod = 'Call'
                impl.addstmt(cxx.StmtExpr(
                        cxx.ExprCall(cxx.ExprSelect(msgvar, '->', 'set_rpc'),
                                     [ ])))
            else:
                assert 0

            # log the message, if DEBUG and the env var is set
            injectLogger(impl, msgvar, sendmethod +' ')
                
            sendcall = cxx.ExprCall(
                cxx.ExprSelect(
                    cxx.ExprVar('mChannel'), self.channelsel, sendmethod),
                [ msgvar ])
            if hasreply:
                sendcall.args.append(cxx.ExprAddrOf(replyvar))

            failif = cxx.StmtIf(cxx.ExprPrefixUnop(sendcall, '!'))
            failif.ifb.addstmt(cxx.StmtReturn(failerrcode))
            impl.addstmt(failif)

            if hasreply:
                # if this message has explicit actor returns, we need
                # to convert them from Handle before returning to C++
                for ret in md._cxx.returns:
                    if not ret.type.actor: continue
                    
                    ravar = cxx.ExprVar(ret.name)
                    rahvar = cxx.ExprVar(ret.name +'__ah')
                    actortype = deepcopy(ret.type)
                    actortype.name = _actorName(actortype.name, self.myside)
                    actortype.ptrptr = 0; actortype.ptr = 1
                    
                    impl.addstmt(cxx.StmtDecl(cxx.Decl(
                        cxx.Type('mozilla::ipc::ActorHandle'), rahvar.name)))
                    impl.addstmts(_actorHandleToActor(handle=rahvar,
                                                      actor=ravar,
                                                      actortype=actortype,
                                                      failcode=valueerrcode))
                impl.addstmt(cxx.Whitespace.NL)

                unpackargs = [ cxx.ExprAddrOf(replyvar) ]
                for ret in md._cxx.returns:
                    rname = ret.name
                    if ret.type.actor:
                        unpackargs.append(cxx.ExprAddrOf(cxx.ExprVar(rname +'__ah')))
                    else:
                        unpackargs.append(cxx.ExprVar(rname))
                if md.decl.type.hasImplicitActorParam():
                    unpackargs.append(cxx.ExprAddrOf(ahvar))

                unpack = cxx.ExprCall(cxx.ExprVar(md._cxx.nsreplyid +'::Read'),
                                      unpackargs)
                errhandle = cxx.StmtIf(cxx.ExprPrefixUnop(unpack, '!'))
                errhandle.ifb.addstmt(cxx.StmtReturn(valueerrcode))
                impl.addstmt(errhandle)

                # see if we need to extract an actor out of a union
                # and re-convert it into an actor pointer
                for r in md._cxx.returns:
                    if (r.type._union is None
                        or not r.type._union.hasActor):
                        continue
                    u = r.type._union
                    for t, n in u.components:
                        if (t._ipdl is None
                            or self.myside is not t._side):
                            continue
                        rvar = cxx.ExprVar(r.name)
                        # FIXME/cjones: we're not special-casing these
                        # enough. currently limited to one actor per
                        # union
                        ifhandle = cxx.StmtIf(
                            cxx.ExprBinary(
                                cxx.ExprVar(r.type.name +'::TActorHandle'),
                                '==',
                                cxx.ExprCall(cxx.ExprSelect(rvar,
                                                            '.', 'type'))))
                        ifhandle.addifstmt(cxx.StmtDecl(
                            cxx.Decl(cxx.Type('mozilla::ipc::ActorHandle'),
                                              '__uah')))
                        uahvar = cxx.ExprVar('__uah')
                        ifhandle.addifstmt(cxx.StmtExpr(cxx.ExprAssn(uahvar,
                                                                     rvar)))
                        # look up and verify the actor handle we got
                        ifhandle.addifstmt(cxx.StmtDecl(cxx.Decl(t._realtype,
                                                                 '__ua')))
                        uavar = cxx.ExprVar('__ua')
                        actorid = cxx.ExprSelect(uahvar, '.', 'mId')
                        cast = cxx.ExprCast(
                            cxx.ExprCall(cxx.ExprVar('Lookup'), [ actorid ]),
                            t._realtype,
                            static=1)
                        ifhandle.addifstmt(cxx.StmtExpr(
                            cxx.ExprAssn(uavar, cast)))
                        failif = cxx.StmtIf(cxx.ExprPrefixUnop(uavar, '!'))
                        failif.addifstmt(cxx.StmtReturn(
                            cxx.ExprVar('MsgValueError')))
                        ifhandle.addifstmt(failif)

                        # finally, slam the actor back into the union
                        ifhandle.addifstmt(cxx.StmtExpr(cxx.ExprAssn(
                            rvar, uavar)))
                        
                        impl.addstmt(ifhandle)

                # log the reply, maybe
                injectLogger(impl,
                             cxx.ExprCast(cxx.ExprAddrOf(replyvar),
                                          cxx.Type(md._cxx.nsreplyid, ptr=1),
                                          static=1),
                             'got reply ')

            if md.decl.type.isCtor():
                impl.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                            cxx.ExprSelect(objvar, '->', 'mManager'),
                            cxx.ExprVar('this'))))
                if self.p.decl.type.isManaged():
                    channelvar = cxx.ExprVar('mChannel')
                else:
                    channelvar = cxx.ExprAddrOf(cxx.ExprVar('mChannel'))
                impl.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                            cxx.ExprSelect(objvar, '->', 'mChannel'),
                            channelvar)))

            elif md.decl.type.isDtor():
                impl.addstmt(cxx.StmtExpr(
                        cxx.ExprCall(cxx.ExprVar('Unregister'), [ objid ])))
                impl.addstmt(cxx.StmtExpr(
                        cxx.ExprAssn(objid, cxx.ExprLiteral.ZERO)))
                impl.addstmt(cxx.StmtExpr(
                        cxx.ExprAssn(
                            cxx.ExprSelect(objvar, '->', 'mManager'),
                            cxx.ExprLiteral.ZERO)))

                calldtor = cxx.ExprCall(
                    cxx.ExprVar(md._cxx.method.name),
                    ([ objvar ]
                     + [ cxx.ExprVar(p.name) for p in md._cxx.params ]
                     + [ cxx.ExprVar(r.name) for r in md._cxx.returns ]))
                failif = cxx.StmtIf(cxx.ExprCall(
                        cxx.ExprVar('NS_FAILED'), [ calldtor ]))
                failif.addifstmt(cxx.StmtReturn(valueerrcode))
                impl.addstmt(failif)

            impl.addstmt(cxx.StmtReturn(okcode))
            self.cls.addstmt(impl)
            self.cls.addstmt(cxx.Whitespace.NL)


        # create case for this message in the big handler switch statement
        if self.receivesMessage(md):
            if md.decl.type.isRpc():  pfx = 'Answer'
            else:                     pfx = 'Recv'

            case = cxx.CaseLabel(md._cxx.nsid +'__ID')
            block = cxx.StmtBlock()
            hasactor = md.decl.type.hasImplicitActorParam()
            if hasactor:
                objtype = cxx.Type(
                    _actorName(md.decl.type.constructedType().name(),
                               self.myside),
                    ptr=1)
                objvar = cxx.ExprVar('__a')
                objid = cxx.ExprSelect(objvar, '->', 'mId')

            for param in md._cxx.params:
                if param.type.actor:
                    param = deepcopy(param)
                    # actors need a "side", i.e., Parent/Child
                    param.type.name = _actorName(param.type.name, self.myside)
                    # and come in as Handles
                    block.addstmt(cxx.StmtDecl(cxx.Decl(
                        cxx.Type('mozilla::ipc::ActorHandle'),
                        param.name +'__ah')))
                block.addstmt(cxx.StmtDecl(param))
            for ret in md._cxx.returns:
                if ret.type.actor:
                    ret = deepcopy(ret)
                    # actors need a "side", i.e., Parent/Child
                    ret.type.name = _actorName(ret.type.name, self.myside)
                    # and go out as Handles
                    block.addstmt(cxx.StmtDecl(cxx.Decl(
                        cxx.Type('mozilla::ipc::ActorHandle'),
                        ret.name +'__ah')))
                block.addstmt(cxx.StmtDecl(ret))
            if hasactor:
                block.addstmt(cxx.StmtDecl(cxx.Decl(
                            cxx.Type('mozilla::ipc::ActorHandle'), '__ah')))
                ahvar = cxx.ExprVar('__ah')
            block.addstmt(cxx.Whitespace.NL)

            msgvar = cxx.ExprVar('msg')
            unpackargs = [ cxx.ExprAddrOf(msgvar) ] # msg to unpack
            for p in md._cxx.params:
                argvar = cxx.ExprVar(p.name)
                if p.type.actor:
                    argvar.name += '__ah'
                unpackargs.append(cxx.ExprAddrOf(argvar))
            if hasactor:
                unpackargs.append(cxx.ExprAddrOf(ahvar))
                
            unpack = cxx.ExprCall(cxx.ExprVar(md._cxx.nsid +'::Read'),
                                  unpackargs)
            errhandle = cxx.StmtIf(cxx.ExprPrefixUnop(unpack, '!'))
            errhandle.ifb.addstmt(cxx.StmtReturn(
                    cxx.ExprVar('MsgPayloadError')))
            block.addstmt(errhandle)

            injectLogger(block, 
                         cxx.ExprCast(cxx.ExprAddrOf(msgvar),
                                      cxx.Type(md._cxx.nsid, ptr=1, const=1),
                                      static=1),
                         pfx +' ')

            # FIXME/cjones: bad copypasta juju
            #
            # if a union stored an actor, it was re-packed as an
            # actor handle.  if so, we need to extract that handle,
            # convert it back to an actor, then stuff it back into
            # the union
            for p in md._cxx.params:
                if (p.type._union is None
                    or not p.type._union.hasActor):
                    continue
                u = p.type._union
                for t, n in u.components:
                    if (t._ipdl is None
                        or self.myside is not t._side):
                        continue
                    pvar = cxx.ExprVar(p.name)
                    # FIXME/cjones: we're not special-casing these
                    # enough. currently limited to one actor per
                    # union
                    ifhandle = cxx.StmtIf(
                        cxx.ExprBinary(
                            cxx.ExprVar(p.type.name +'::TActorHandle'),
                            '==',
                            cxx.ExprCall(cxx.ExprSelect(pvar,
                                                        '.', 'type'))))
                    ifhandle.addifstmt(cxx.StmtDecl(
                        cxx.Decl(cxx.Type('mozilla::ipc::ActorHandle'),
                                 '__uah')))
                    uahvar = cxx.ExprVar('__uah')
                    ifhandle.addifstmt(cxx.StmtExpr(cxx.ExprAssn(uahvar,
                                                                 pvar)))
                    # look up and verify the actor handle we got
                    ifhandle.addifstmt(cxx.StmtDecl(cxx.Decl(t._realtype,
                                                             '__ua')))
                    uavar = cxx.ExprVar('__ua')

                    ifhandle.ifb.addstmts(
                        _actorHandleToActor(
                            handle=uahvar,
                            actor=uavar,
                            actortype=t._realtype,
                            failcode=cxx.ExprVar('MsgValueError')))

                    # finally, slam the actor back into the union
                    ifhandle.addifstmt(cxx.StmtExpr(
                        cxx.ExprAssn(pvar, uavar)))
                        
                    block.addstmt(ifhandle)

            # convert explicit actor params, iced as ActorHandles,
            # back into actors
            for param in md._cxx.params:
                if not param.type.actor: continue

                pavar = cxx.ExprVar(param.name)
                pahvar = cxx.ExprVar(pavar.name +'__ah')
                actortype = deepcopy(param.type)
                actortype.name = _actorName(actortype.name, self.myside)
                block.addstmts(
                    _actorHandleToActor(handle=pahvar,
                                        actor=pavar,
                                        actortype=actortype,
                                        failcode=cxx.ExprVar('MsgPayloadError')))

            if md.decl.type.isCtor():
                block.addstmt(cxx.Whitespace.NL)
                block.addstmt(cxx.StmtDecl(cxx.Decl(objtype, '__a')))

                # call the concrete class's "factory" method to
                # instantiate a concrete actor
                block.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                            objvar,
                            cxx.ExprCall(
                                cxx.ExprVar(md._cxx.method.name),
                                ([ cxx.ExprVar(p.name) for
                                   p in md._cxx.params ]
                                 + [ cxx.ExprAddrOf(cxx.ExprVar(r.name)) for
                                     r in md._cxx.returns ])))))
                errhandle = cxx.StmtIf(cxx.ExprPrefixUnop(objvar, '!'))
                errhandle.ifb.addstmt(cxx.StmtReturn(cxx.ExprVar('MsgValueError')))
                block.addstmt(errhandle)

            elif md.decl.type.isDtor():
                block.addstmt(cxx.StmtDecl(cxx.Decl(objtype, '__a')))

                routevar = cxx.ExprSelect(ahvar, '.', 'mId')
                dcast = cxx.ExprCast(
                    cxx.ExprCall(cxx.ExprVar('Lookup'), [ routevar ]),
                    objtype,
                    static=1)
                block.addstmt(cxx.StmtExpr(cxx.ExprAssn(objvar, dcast)))

                failif = cxx.StmtIf(cxx.ExprPrefixUnop(objvar, '!'))
                failif.ifb.addstmt(cxx.StmtReturn(cxx.ExprVar('MsgValueError')))
                block.addstmt(failif)

            if md.decl.type.isCtor():
                othersideid = cxx.ExprSelect(ahvar, '.', 'mId')
                block.addstmt(cxx.StmtExpr(
                        cxx.ExprAssn(objid,
                                     cxx.ExprCall(cxx.ExprVar('RegisterID'),
                                                  [ objvar, othersideid ]))))
                block.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                            cxx.ExprSelect(objvar, '->', 'mManager'),
                            cxx.ExprVar('this'))))
                if self.p.decl.type.isToplevel():
                    channelvar = cxx.ExprAddrOf(cxx.ExprVar('mChannel'))
                else:
                    channelvar = cxx.ExprVar('mChannel')
                block.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                            cxx.ExprSelect(objvar, '->', 'mChannel'),
                            channelvar)))
                block.addstmt(cxx.Whitespace.NL)

            # call the C++ handler hook
            callimpl = cxx.ExprCall(
                cxx.ExprVar(pfx + md.decl.progname), [ ])
            if md.decl.type.isCtor() or md.decl.type.isDtor():
                callimpl.args += [ objvar ]
            callimpl.args += [ cxx.ExprVar(p.name) for p in md._cxx.params ]
            callimpl.args += [ cxx.ExprAddrOf(cxx.ExprVar(r.name))
                               for r in md._cxx.returns ]
            errhandle = cxx.StmtIf(cxx.ExprCall(
                cxx.ExprVar('NS_FAILED'), [ callimpl ]))
            errhandle.ifb.addstmt(cxx.StmtReturn(
                cxx.ExprVar('MsgValueError')))
            block.addstmt(errhandle)

            block.addstmt(cxx.Whitespace.NL)

            if md.decl.type.isDtor():
                calldtor = cxx.ExprCall(
                    cxx.ExprVar(md._cxx.method.name),
                    ([ objvar ]
                     + [ cxx.ExprVar(p.name) for p in md._cxx.params ]
                     + [ cxx.ExprAddrOf(cxx.ExprVar(r.name)) for
                         r in md._cxx.returns ]))
                failif = cxx.StmtIf(cxx.ExprCall(
                        cxx.ExprVar('NS_FAILED'), [ calldtor ]))
                failif.ifb.addstmt(cxx.StmtReturn(cxx.ExprVar('MsgValueError')))
                block.addstmt(failif)
                block.addstmt(cxx.StmtExpr(
                        cxx.ExprCall(cxx.ExprVar('Unregister'), [ routevar ])))
                block.addstmt(cxx.StmtExpr(
                        cxx.ExprAssn(routevar, cxx.ExprLiteral.ZERO)))

            if md.decl.type.hasReply():
                if not md.decl.type.hasReply():
                    block.addstmt(cxx.StmtDecl(
                            cxx.Decl(cxx.Type('Message', ptr=1), 'reply')))
                replyvar = cxx.ExprVar('reply')

                # FIXME/cjones: yet more copy-n-paste
                #
                # special case for IPDL union types: if this union
                # contains an actor type, we secretly convert
                # it into a serializable representation
                uahvars = [ ]
                wasrepackedvars = [ ]
                ruid = 0
                switches = [ ]
                for r in md._cxx.returns:
                    if (r.type._union is None
                        or not r.type._union.hasActor):
                        uahvars.append(None)
                        wasrepackedvars.append(None)
                        continue

                    rvar = cxx.ExprVar(r.name)
                    u = r.type._union

                    uahdecl = cxx.StmtDecl(cxx.Decl(
                        cxx.Type('mozilla::ipc::ActorHandle'),
                        '__uah'+ str(ruid)))
                    uahvar = cxx.ExprVar('__uah'+ str(ruid))
                    uahvars.append( (uahdecl, uahvar) )

                    wrvar = cxx.ExprVar('__wr_'+ str(ruid))
                    wrdecl = cxx.StmtDecl(cxx.Decl(cxx.Type('bool'),
                                                   wrvar.name))
                    wasrepackedvars.append( (wrdecl, wrvar) )
                    ruid += 1
                    # if the union currently stores an actor, unpack the
                    # pointer and repack it as an ActorHandle
                    switch = cxx.StmtSwitch(cxx.ExprCall(
                        cxx.ExprSelect(rvar, '.', 'type')))
                    for t, n in u.components:
                        if (t._ipdl is None
                            or self.myside is not t._side):
                            continue
                        switch.addstmt(cxx.Label(t._tag))
                        repack = cxx.StmtBlock()
                        repack.addstmt(cxx.StmtDecl(cxx.Decl(t._realtype,
                                                             '__ua')))
                        uavar = cxx.ExprVar('__ua')
                        repack.addstmt(cxx.StmtExpr(cxx.ExprAssn(uavar, rvar)))
                        repack.addstmt(cxx.StmtExpr(
                            cxx.ExprAssn(cxx.ExprSelect(uahvar, '.', 'mId'),
                                         cxx.ExprSelect(uavar, '.', 'mId'))))
                        repack.addstmt(cxx.StmtExpr(cxx.ExprAssn(rvar,
                                                                 uahvar)))
                        repack.addstmt(cxx.StmtExpr(cxx.ExprAssn(
                            wrvar, cxx.ExprVar('true'))))
                        repack.addstmt(cxx.StmtBreak())
                        switch.addstmt(repack)
                    # if it's not an actor, don't care
                    switch.addstmt(cxx.DefaultLabel())
                    switches.append(switch)

                for udv in uahvars:
                    if udv is None: continue
                    uahdecl, _ = udv
                    block.addstmt(uahdecl)
                for wrdv in wasrepackedvars:
                    if wrdv is None: continue
                    wrdecl, wrvar = wrdv
                    block.addstmt(wrdecl)
                    block.addstmt(cxx.StmtExpr(
                        cxx.ExprAssn(wrvar, cxx.ExprVar('false'))))
                for switch in switches:
                    block.addstmt(switch)

                ctorparams = [ ]
                for i, r in enumerate(md._cxx.returns):
                    rvar = cxx.ExprVar(r.name)
                    wrdv = wasrepackedvars[i]
                    if wrdv is None:
                        ctorparams.append(rvar)
                    else:
                        wrvar = wrdv[1]
                        uahvar = uahvars[i][1]
                        ctorparams.append(
                            cxx.ExprConditional(wrvar, uahvar, rvar))

                replymsgctor = cxx.ExprNew(cxx.Type(md._cxx.nsreplyid),
                                           args=ctorparams)
                if md.decl.type.hasImplicitActorParam():
                    replymsgctor.args.append(ahvar)
                block.addstmt(cxx.StmtExpr(cxx.ExprAssn(replyvar,
                                                        replymsgctor)))
                block.addstmt(cxx.StmtExpr(cxx.ExprCall(
                            cxx.ExprSelect(replyvar, '->', 'set_reply'),
                            [ ])))

                if md.decl.type.isSync():
                    block.addstmt(cxx.StmtExpr(cxx.ExprCall(
                            cxx.ExprSelect(replyvar, '->', 'set_sync'),
                            [ ])))
                elif md.decl.type.isRpc():
                    block.addstmt(cxx.StmtExpr(cxx.ExprCall(
                            cxx.ExprSelect(replyvar, '->', 'set_rpc'),
                            [ ])))
                else:
                    assert 0

                injectLogger(block,
                             cxx.ExprCast(replyvar,
                                          cxx.Type(md._cxx.nsreplyid, ptr=1),
                                          static=1),
                             'replying with ')

                if md.decl.type.isAsync(): # => isCtor or isDtor
                    # when this is sync or rpc, we return the reply
                    # message to the dispatcher.  when it's async, 
                    # we have to explicitly send it back
                    if self.p.decl.type.isManaged():
                        sel = '->'
                    else:
                        sel = '.'
                    failif = cxx.StmtIf(cxx.ExprPrefixUnop(
                            cxx.ExprCall(
                                cxx.ExprSelect(cxx.ExprVar('mChannel'), sel, 'Send'),
                                [ replyvar ]),
                            '!'))
                    failif.addifstmt(
                        cxx.StmtReturn(cxx.ExprVar('MsgValueError')))

                    block.addstmt(failif)

            block.addstmt(cxx.StmtReturn(cxx.ExprVar('MsgProcessed')))

            if md.decl.type.isAsync():
                self.asyncswitch.addcase(case, block)
            elif md.decl.type.isSync():
                self.syncswitch.addcase(case, block)
            else:
                self.rpcswitch.addcase(case, block)


class GenerateProtocolParentHeader(GenerateProtocolActorHeader):
    def __init__(self):
        GenerateProtocolActorHeader.__init__(self, 'Parent', 'Child')

    def sendsMessage(self, md):
        return not md.decl.type.isIn()

    def receivesMessage(self, md):
        return md.decl.type.isInout() or md.decl.type.isIn()

class GenerateProtocolChildHeader(GenerateProtocolActorHeader):
    def __init__(self):
        GenerateProtocolActorHeader.__init__(self, 'Child', 'Parent')

    def sendsMessage(self, md):
        return not md.decl.type.isOut()

    def receivesMessage(self, md):
        return md.decl.type.isInout() or md.decl.type.isOut()


class GenerateSkeletonImpl(cxx.Visitor):
    def __init__(self, name='ActorImpl'):
        self.name = name
        self.stuff = [ ]
        self.cls = None
        self.methodimpls = [ ]

    def fromclass(self, cls):
        cls.accept(self)
        self.stuff.append(cxx.Whitespace('''
//-----------------------------------------------------------------------------
// Skeleton implementation of abstract actor class

'''))
        self.stuff.append(cxx.Whitespace('// Header file contents\n'))
        self.stuff.append(self.cls)

        self.stuff.append(cxx.Whitespace.NL)
        self.stuff.append(cxx.Whitespace('\n// C++ file contents\n'))
        self.stuff.extend(self.methodimpls)

    def visitClass(self, cls):
        self.cls = cxx.Class(self.name, inherits=[ cxx.Inherit(cls.name) ])
        cxx.Visitor.visitClass(self, cls)

    def visitMethodDecl(self, md):
        if not md.pure:
            return
        decl = deepcopy(md)
        decl.pure = 0
        impl = cxx.MethodDefn(cxx.MethodDecl(self.implname(md.name),
                                             params=md.params,
                                             ret=md.ret))
        if md.ret.ptr:
            impl.addstmt(cxx.StmtReturn(cxx.ExprLiteral.ZERO))
        else:
            impl.addstmt(cxx.StmtReturn(cxx.ExprVar('NS_ERROR_NOT_IMPLEMENTED')))

        self.cls.addstmt(cxx.StmtDecl(decl))
        self.addmethodimpl(impl)

    def visitConstructorDecl(self, cd):
        self.cls.addstmt(cxx.StmtDecl(cxx.ConstructorDecl(self.name)))
        ctor = cxx.ConstructorDefn(cxx.ConstructorDecl(self.implname(self.name)))
        ctor.addstmt(cxx.StmtExpr(cxx.ExprCall(cxx.ExprVar( 'MOZ_COUNT_CTOR'),
                                               [ cxx.ExprVar(self.name) ])))
        self.addmethodimpl(ctor)
        
    def visitDestructorDecl(self, dd):
        self.cls.addstmt(
            cxx.StmtDecl(cxx.DestructorDecl(self.name, virtual=1)))
        # FIXME/cjones: hack!
        dtor = cxx.DestructorDefn(cxx.ConstructorDecl(self.implname('~' +self.name)))
        dtor.addstmt(cxx.StmtExpr(cxx.ExprCall(cxx.ExprVar( 'MOZ_COUNT_DTOR'),
                                               [ cxx.ExprVar(self.name) ])))
        self.addmethodimpl(dtor)

    def addmethodimpl(self, impl):
        self.methodimpls.append(impl)
        self.methodimpls.append(cxx.Whitespace.NL)

    def implname(self, method):
        return self.name +'::'+ method
