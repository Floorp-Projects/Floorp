# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
import argparse
import codecs
import subprocess
import sys
import tempfile
import yaml

def shell_main():
  parser = argparse.ArgumentParser()
  parser.add_argument('-o', '--output', type=str, required=True,
                      help='Output file')
  parser.add_argument('manifest', type=str,
                      help='Manifest source file')
  args = parser.parse_args()

  with open(args.output, 'w') as out_file:
    process_manifest(out_file, args.manifest)

def main(output_fp, input_filename):
  process_manifest(output_fp, input_filename)

HEADER = """// AUTOGENERATED - DO NOT EDIT
namespace mozilla {
namespace layers {

struct ShaderBytes { const void* mData; size_t mLength; };
"""
FOOTER = """
} // namespace layers
} // namespace mozilla"""

def process_manifest(output_fp, manifest_filename):
  with codecs.open(manifest_filename, 'r', 'UTF-8') as in_fp:
    manifest = yaml.load(in_fp)
  shader_folder, _ = os.path.split(manifest_filename)

  output_fp.write(HEADER)

  for block in manifest:
    if 'type' not in block:
      raise Exception("Expected 'type' key with shader mode")
    if 'file' not in block:
      raise Exception("Expected 'file' key with shader file")
    if 'shaders' not in block:
      raise Exception("Expected 'shaders' key with shader name list")

    shader_model = block['type']
    shader_file = os.path.join(shader_folder, block['file'])
    for shader_name in block['shaders']:
      run_fxc(
        shader_model = shader_model,
        shader_file = shader_file,
        shader_name = shader_name,
        output_fp = output_fp)

  output_fp.write(FOOTER)

def run_fxc(shader_model,
            shader_file,
            shader_name,
            output_fp):
  argv = [
    'fxc',
    '-nologo',
    '-T{0}'.format(shader_model),
    shader_file,
    '-E{0}'.format(shader_name),
    '-Vn{0}'.format(shader_name),
  ]
  if shader_model.startswith('vs_'):
    argv += ['-DVERTEX_SHADER']
  elif shader_model.startswith('ps_'):
    argv += ['-DPIXEL_SHADER']

  with ScopedTempFilename() as temp_filename:
    argv += ['-Fh{0}'.format(temp_filename)]

    sys.stdout.write('{0}\n'.format(' '.join(argv)))
    subprocess.check_call(argv)

    with open(temp_filename, 'r') as temp_fp:
      output_fp.write(temp_fp.read())

  output_fp.write("ShaderBytes s{0} = {{ {0}, sizeof({0}) }};\n".format(
    shader_name))

# Allocate a temporary file name and delete it when done. We need an extra
# wrapper for this since TemporaryNamedFile holds the file open.
class ScopedTempFilename(object):
  def __init__(self):
    self.name = None
  def __enter__(self):
    with tempfile.NamedTemporaryFile(delete = False) as tmp:
      self.name = tmp.name
      return self.name
  def __exit__(self, type, value, traceback):
    if not self.name:
      return
    try:
      os.unlink(self.name)
    except:
      pass

if __name__ == '__main__':
  shell_main()
