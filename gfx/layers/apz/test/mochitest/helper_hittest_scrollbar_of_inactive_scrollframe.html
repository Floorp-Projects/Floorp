<!DOCTYPE HTML>
<html>
<head>
  <title>Hit-test the scrollbar of an inactive will-change scrollframe</title>
  <script type="application/javascript" src="apz_test_utils.js"></script>
  <script type="application/javascript" src="apz_test_native_event_utils.js"></script>
  <script src="/tests/SimpleTest/paint_listener.js"></script>
  <meta name="viewport" content="width=device-width"/>
</head>
<body>
 <div id="scroller" style="width: 300px; height: 100px; will-change: scroll-position; overflow-y: auto">
  <div style="height: 1000px">
    This div is filler to make the enclosing scroller div scrollable, but I'm
    taking the opportunity to explain the test in more detail here.

    The will-change property on the scroller is intended to make the
    ScrollFrameHelper::IsMaybeScrollingActive() function return true,
    which makes the scrollbar data contain the scroller's actual scrolltarget
    (instead of NULL_SCROLL_ID). However, since there's no displayport
    set on the scroller, it ends up with mWillBuildScrollableLayer set to
    false and is not actually scrollable by APZ.

    This means that with WR enabled, APZ never gets the metrics for the
    scroller. Upon hit-testing the scrollthumb with WR enabled, it gets the
    scroll id of the scroller, but doesn't have the metrics for it, resulting
    in an assertion failure.
  </div>
 </div>
 <div id="make_root_scrollable" style="height: 5000px"></div>
</body>
<script type="application/javascript">

function* test(testDriver) {
  var config = getHitTestConfig();
  var utils = config.utils;

  var scroller = document.getElementById("scroller");

  checkHitResult(hitTest(centerOf(scroller)),
                 APZHitResultFlags.VISIBLE |
                 (config.isWebRender ? APZHitResultFlags.INACTIVE_SCROLLFRAME
                                     : APZHitResultFlags.IRREGULAR_AREA),
                 utils.getViewId(scroller),
                 utils.getLayersId(),
                 "inactive will-change scrollframe");

  // The above check ensures that the scroller is *inactive*, but because of
  // the will-change property on it, the scrollbars get layerized as though
  // the scroller is *active*, hence we provide the scroller's viewId and
  // LayerState.ACTIVE as the expected checks below.

  hitTestScrollbar({
    element: scroller,
    directions: { vertical: true, horizontal: false },
    expectedScrollId: utils.getViewId(scroller),
    expectedLayersId: utils.getLayersId(),
    trackLocation: ScrollbarTrackLocation.START,
    expectThumb: true,
    layerState: LayerState.ACTIVE,
  });

  subtestDone();
}

waitUntilApzStable().then(runContinuation(test));

</script>
</html>
