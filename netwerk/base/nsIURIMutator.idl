/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include "nsISupports.idl"
interface nsIURI;
interface nsIObjectInputStream;
interface nsIURIMutator;

%{C++
#include "nsString.h"
#include "nsCOMPtr.h"

#undef SetPort  // XXX Windows!

namespace mozilla {
class Encoding;
}

namespace mozilla {
namespace ipc {
class URIParams;
} // namespace ipc
} // namespace mozilla

template <class T>
class BaseURIMutator
{
// This is the base class that can be extended by implementors of nsIURIMutator
// in order to avoid code duplication
// Class type T should be the type of the class that implements nsIURI
protected:
    nsresult InitFromURI(T* aURI)
    {
        nsCOMPtr<nsIURI> clone;
        nsresult rv = aURI->Clone(getter_AddRefs(clone));
        if (NS_FAILED(rv)) {
            return rv;
        }
        mURI = static_cast<T*>(clone.get());
        return NS_OK;
    }

    nsresult InitFromInputStream(nsIObjectInputStream* aStream)
    {
        RefPtr<T> uri = new T();
        nsresult rv = uri->Read(aStream);
        if (NS_FAILED(rv)) {
            return rv;
        }
        mURI = uri;
        return NS_OK;
    }

    nsresult InitFromIPCParams(const mozilla::ipc::URIParams& aParams)
    {
        RefPtr<T> uri = new T();
        bool ret = uri->Deserialize(aParams);
        if (!ret) {
          return NS_ERROR_FAILURE;
        }
        mURI = uri;
        return NS_OK;
    }

    nsresult InitFromSpec(const nsACString& aSpec)
    {
        RefPtr<T> uri = new T();
        nsresult rv = uri->SetSpec(aSpec);
        if (NS_FAILED(rv)) {
          return rv;
        }
        mURI = uri;
        return NS_OK;
    }

    RefPtr<T> mURI;
};

// Since most implementations of nsIURIMutator would extend BaseURIMutator,
// some methods would have the same implementation. We provide a useful macro
// to avoid code duplication.
#define NS_DEFINE_NSIMUTATOR_COMMON                                           \
  NS_IMETHOD Deserialize(const mozilla::ipc::URIParams& aParams) override     \
    { return InitFromIPCParams(aParams); }                                    \
  NS_IMETHOD Read(nsIObjectInputStream* aStream) override                     \
    { return InitFromInputStream(aStream); }                                  \
  NS_IMETHOD Finalize(nsIURI** aURI) override                                 \
    { mURI.forget(aURI); return NS_OK; }                                      \
  NS_IMETHOD SetSpec(const nsACString & aSpec, nsIURIMutator** aMutator) override \
    { if (aMutator) NS_ADDREF(*aMutator = this); return InitFromSpec(aSpec); }
%}

[ptr] native Encoding(const mozilla::Encoding);
[ref] native const_URIParams_ref(const mozilla::ipc::URIParams);

[scriptable, builtinclass, uuid(1fc53257-898b-4c5e-b69c-05bc84b4cd8f)]
interface nsIURISetSpec : nsISupports
{
  /**
   * This setter is different from all other setters because it may be used to
   * initialize the object. We define it separately allowing mutator implementors
   * to define it separately, while the rest of the setters may be simply
   * forwarded to the mutable URI.
   */
  nsIURIMutator setSpec(in AUTF8String aSpec);
};

/**
 * These methods allow the mutator to change various parts of the URI.
 * They return the same nsIURIMutator so that we may chain setter operations:
 * Example:
 * let newURI = uri.mutate()
 *                 .setSpec("http://example.com")
 *                 .setQuery("hello")
 *                 .finalize();
 */
[scriptable, builtinclass, uuid(5403a6ec-99d7-405e-8b45-9f805bbdfcef)]
interface nsIURISetters : nsIURISetSpec
{
  nsIURIMutator setScheme(in AUTF8String aScheme);
  nsIURIMutator setUserPass(in AUTF8String aUserPass);
  nsIURIMutator setUsername(in AUTF8String aUsername);
  nsIURIMutator setPassword(in AUTF8String aPassword);
  nsIURIMutator setHostPort(in AUTF8String aHostPort);
  nsIURIMutator setHostAndPort(in AUTF8String aHostAndPort);
  nsIURIMutator setHost(in AUTF8String aHost);
  nsIURIMutator setPort(in long aPort);
  nsIURIMutator setPathQueryRef(in AUTF8String aPathQueryRef);
  nsIURIMutator setRef(in AUTF8String aRef);
  nsIURIMutator setFilePath(in AUTF8String aFilePath);
  nsIURIMutator setQuery(in AUTF8String aQuery);
  [noscript] nsIURIMutator setQueryWithEncoding(in AUTF8String query, in Encoding encoding);
};

%{C++

// Using this macro instead of NS_FORWARD_SAFE_NSIURISETTERS makes chaining
// setter operations possible.
#define NS_FORWARD_SAFE_NSIURISETTERS_RET(_to)                                                                                         \
  NS_IMETHOD SetScheme(const nsACString & aScheme, nsIURIMutator** aMutator) override                                                  \
    { if (aMutator) NS_ADDREF(*aMutator = this); return !_to ? NS_ERROR_NULL_POINTER : _to->SetScheme(aScheme); }                      \
  NS_IMETHOD SetUserPass(const nsACString & aUserPass, nsIURIMutator** aMutator) override                                              \
    { if (aMutator) NS_ADDREF(*aMutator = this); return !_to ? NS_ERROR_NULL_POINTER : _to->SetUserPass(aUserPass); }                  \
  NS_IMETHOD SetUsername(const nsACString & aUsername, nsIURIMutator** aMutator) override                                              \
    { if (aMutator) NS_ADDREF(*aMutator = this); return !_to ? NS_ERROR_NULL_POINTER : _to->SetUsername(aUsername); }                  \
  NS_IMETHOD SetPassword(const nsACString & aPassword, nsIURIMutator** aMutator) override                                              \
    { if (aMutator) NS_ADDREF(*aMutator = this); return !_to ? NS_ERROR_NULL_POINTER : _to->SetPassword(aPassword); }                  \
  NS_IMETHOD SetHostPort(const nsACString & aHostPort, nsIURIMutator** aMutator) override                                              \
    { if (aMutator) NS_ADDREF(*aMutator = this); return !_to ? NS_ERROR_NULL_POINTER : _to->SetHostPort(aHostPort); }                  \
  NS_IMETHOD SetHostAndPort(const nsACString & aHostAndPort, nsIURIMutator** aMutator) override                                        \
    { if (aMutator) NS_ADDREF(*aMutator = this); return !_to ? NS_ERROR_NULL_POINTER : _to->SetHostAndPort(aHostAndPort); }            \
  NS_IMETHOD SetHost(const nsACString & aHost, nsIURIMutator** aMutator) override                                                      \
    { if (aMutator) NS_ADDREF(*aMutator = this); return !_to ? NS_ERROR_NULL_POINTER : _to->SetHost(aHost); }                          \
  NS_IMETHOD SetPort(int32_t aPort, nsIURIMutator** aMutator) override                                                                 \
    { if (aMutator) NS_ADDREF(*aMutator = this); return !_to ? NS_ERROR_NULL_POINTER : _to->SetPort(aPort); }                          \
  NS_IMETHOD SetPathQueryRef(const nsACString & aPathQueryRef, nsIURIMutator** aMutator) override                                      \
    { if (aMutator) NS_ADDREF(*aMutator = this); return !_to ? NS_ERROR_NULL_POINTER : _to->SetPathQueryRef(aPathQueryRef); }          \
  NS_IMETHOD SetRef(const nsACString & aRef, nsIURIMutator** aMutator) override                                                        \
    { if (aMutator) NS_ADDREF(*aMutator = this); return !_to ? NS_ERROR_NULL_POINTER : _to->SetRef(aRef); }                            \
  NS_IMETHOD SetFilePath(const nsACString & aFilePath, nsIURIMutator** aMutator) override                                              \
    { if (aMutator) NS_ADDREF(*aMutator = this); return !_to ? NS_ERROR_NULL_POINTER : _to->SetFilePath(aFilePath); }                  \
  NS_IMETHOD SetQuery(const nsACString & aQuery, nsIURIMutator** aMutator) override                                                    \
    { if (aMutator) NS_ADDREF(*aMutator = this); return !_to ? NS_ERROR_NULL_POINTER : _to->SetQuery(aQuery); }                        \
  NS_IMETHOD SetQueryWithEncoding(const nsACString & query, const mozilla::Encoding *encoding, nsIURIMutator** aMutator) override      \
    { if (aMutator) NS_ADDREF(*aMutator = this); return !_to ? NS_ERROR_NULL_POINTER : _to->SetQueryWithEncoding(query, encoding); }

%}

[scriptable, builtinclass, uuid(4d1f3103-1c44-4dcd-b717-5d22a697a7d9)]
interface nsIURIMutator : nsIURISetters
{
  /**
   * Initializes the URI by reading from the input stream.
   * The input stream must contain the serialization of the same object type.
   * See nsISerializable.
   */
  void read(in nsIObjectInputStream aInputStream);

  /**
   * Initalizes the URI by reading IPC URIParams.
   * See nsIIPCSerializableURI.
   */
  [noscript, notxpcom]
  nsresult deserialize(in const_URIParams_ref aParams);

  /**
   * Finishes changing or constructing the URI and returns an immutable URI.
   */
  nsIURI finalize();
};

%{C++

// This class provides a useful helper that allows chaining of setter operations
class MOZ_STACK_CLASS NS_MutateURI
{
public:
  explicit NS_MutateURI(nsIURI* aURI);
  explicit NS_MutateURI(const char * aContractID);

  NS_MutateURI& SetSpec(const nsACString& aSpec)
  {
    NS_ENSURE_SUCCESS(mStatus, *this);
    mStatus = mMutator->SetSpec(aSpec, nullptr);
    return *this;
  }
  NS_MutateURI& SetScheme(const nsACString& aScheme)
  {
    NS_ENSURE_SUCCESS(mStatus, *this);
    mStatus = mMutator->SetScheme(aScheme, nullptr);
    return *this;
  }
  NS_MutateURI& SetUserPass(const nsACString& aUserPass)
  {
    NS_ENSURE_SUCCESS(mStatus, *this);
    mStatus = mMutator->SetUserPass(aUserPass, nullptr);
    return *this;
  }
  NS_MutateURI& SetUsername(const nsACString& aUsername)
  {
    NS_ENSURE_SUCCESS(mStatus, *this);
    mStatus = mMutator->SetUsername(aUsername, nullptr);
    return *this;
  }
  NS_MutateURI& SetPassword(const nsACString& aPassword)
  {
    NS_ENSURE_SUCCESS(mStatus, *this);
    mStatus = mMutator->SetPassword(aPassword, nullptr);
    return *this;
  }
  NS_MutateURI& SetHostPort(const nsACString& aHostPort)
  {
    NS_ENSURE_SUCCESS(mStatus, *this);
    mStatus = mMutator->SetHostPort(aHostPort, nullptr);
    return *this;
  }
  NS_MutateURI& SetHostAndPort(const nsACString& aHostAndPort)
  {
    NS_ENSURE_SUCCESS(mStatus, *this);
    mStatus = mMutator->SetHostAndPort(aHostAndPort, nullptr);
    return *this;
  }
  NS_MutateURI& SetHost(const nsACString& aHost)
  {
    NS_ENSURE_SUCCESS(mStatus, *this);
    mStatus = mMutator->SetHost(aHost, nullptr);
    return *this;
  }
  NS_MutateURI& SetPort(int32_t aPort)
  {
    NS_ENSURE_SUCCESS(mStatus, *this);
    mStatus = mMutator->SetPort(aPort, nullptr);
    return *this;
  }
  NS_MutateURI& SetPathQueryRef(const nsACString& aPathQueryRef)
  {
    NS_ENSURE_SUCCESS(mStatus, *this);
    mStatus = mMutator->SetPathQueryRef(aPathQueryRef, nullptr);
    return *this;
  }
  NS_MutateURI& SetRef(const nsACString& aRef)
  {
    NS_ENSURE_SUCCESS(mStatus, *this);
    mStatus = mMutator->SetRef(aRef, nullptr);
    return *this;
  }
  NS_MutateURI& SetFilePath(const nsACString& aFilePath)
  {
    NS_ENSURE_SUCCESS(mStatus, *this);
    mStatus = mMutator->SetFilePath(aFilePath, nullptr);
    return *this;
  }
  NS_MutateURI& SetQuery(const nsACString& aQuery)
  {
    NS_ENSURE_SUCCESS(mStatus, *this);
    mStatus = mMutator->SetQuery(aQuery, nullptr);
    return *this;
  }
  NS_MutateURI& SetQueryWithEncoding(const nsACString& query, const mozilla::Encoding *encoding)
  {
    NS_ENSURE_SUCCESS(mStatus, *this);
    mStatus = mMutator->SetQueryWithEncoding(query, encoding, nullptr);
    return *this;
  }

  template <class C>
  nsresult Finalize(nsCOMPtr<C>& aURI)
  {
    NS_ENSURE_SUCCESS(mStatus, mStatus);

    nsCOMPtr<nsIURI> uri;
    mStatus = mMutator->Finalize(getter_AddRefs(uri));
    NS_ENSURE_SUCCESS(mStatus, mStatus);

    aURI = do_QueryInterface(uri, &mStatus);
    NS_ENSURE_SUCCESS(mStatus, mStatus);

    return NS_OK;
  }

  // Overload for nsIURI to avoid query interface.
  nsresult Finalize(nsCOMPtr<nsIURI>& aURI)
  {
    NS_ENSURE_SUCCESS(mStatus, mStatus);
    mStatus = mMutator->Finalize(getter_AddRefs(aURI));
    return mStatus;
  }

  template <class C>
  nsresult Finalize(C** aURI)
  {
    NS_ENSURE_SUCCESS(mStatus, mStatus);
    nsCOMPtr<nsIURI> uri;
    mStatus = mMutator->Finalize(getter_AddRefs(uri));
    nsCOMPtr<C> result = do_QueryInterface(uri, &mStatus);
    result.forget(aURI);
    return mStatus;
  }

  nsresult Finalize(nsIURI** aURI)
  {
    NS_ENSURE_SUCCESS(mStatus, mStatus);
    mStatus = mMutator->Finalize(aURI);
    return mStatus;
  }

  nsresult GetStatus() { return mStatus; }
private:
  nsresult mStatus;
  nsCOMPtr<nsIURIMutator> mMutator;
};

%}
