## exception descriptions ##
err.notimplemented = Not implemented
err.required.param = Missing required parameter %1$S
err.invalid.param  = Invalid value for parameter %1$S (%2$S)
# 1 url, 2 fileName, 3 lineNumber, 4 reason
err.subscript.load = Error loading subscript from <%1$S>, %2$S, line %3$S: %4$S
err.no.debugger    = JS Debugger Service is not installed.
err.failure        = Unclassified failure.
err.no.stack       = No Stack

## error messages ##
msg.err.nostack         = No stack
msg.err.nosource        = No source for current script
msg.err.nocommand       = No such command, ``%1$S''
msg.err.notimplemented  = Sorry, ``%1$S'' has not been implemented
msg.err.ambigcommand    = Ambiguous command, ``%1$S'', %2$S commands match [%3$S]
msg.err.bp.noscript     = <%1$S> URL not loaded
msg.err.bp.noline       = <%1$S> contains no code at line %2$S
msg.err.bp.nodice       = No breakpoint set at <%1$S> line %2$S
msg.err.bp.noindex      = No breakpoint at index %1$S
msg.err.source.load.failed = Error loading source for URL <%1$S>
msg.err.startup         = An exception occurred while initializing, please file a bug.\n%1$S
msg.err.cant.close      = Cannot exit, execution in progress.

## "values" ##
msg.val.commasp     = ,%1$S
msg.val.unknown     = <unknown>
msg.val.console     = <console>
msg.val.na          = <not-available>
msg.val.object      = <object>
msg.val.expression  = <expression>
msg.val.proto       = [[Prototype]]
msg.val.parent      = [[Parent]]

## words ##
msg.val.native      = native
msg.val.script      = script
msg.val.this        = this
msg.val.breakpoint  = breakpoint
msg.val.debug       = error handler
msg.val.debugger    = debugger keyword
msg.val.throw       = thrown exception
msg.val.scope       = scope
msg.val.exception   = exception
msg.val.on          = on
msg.val.off         = off
msg.val.tlscript    = __toplevel__

## types ##
msg.type.int        = integer
msg.type.boolean    = boolean
msg.type.double     = double
msg.type.function   = function
msg.type.null       = null
msg.type.object     = object
msg.type.string     = string
msg.type.unknown    = unknown
msg.type.void       = void

msg.class.xpcobj    = XPComponent
msg.blacklist       = Blacklist
msg.break.rec       = Breakpoints
msg.callstack       = Call Stack

## messages ##
msg.status.default   = Welcome to the JavaScript Debugger
msg.status.loading   = Loading source for ``%1$S''
msg.status.marking   = Marking source for ``%1$S''
msg.status.stopped   = Stopped in %1$S, %2$S

msg.stop             = Stopped for %1$S.
msg.cont             = Continuing from %1$S.
msg.subscript.load   = <%1$S> Subscript loaded.
# 1 exception name, 2 fileName, 3 lineNumber
msg.eval.error       = %1$S: <%2$S>, line %3$S
msg.eval.threw       = Caught exception: %1$S
msg.hello            = Welcome to ``Venkman'', the JavaScript debugger. Visit the Venkman homepage <http://www.mozilla.org/projects/venkman/> for more information, or <chrome://venkman/content/tests/testpage.html> for a sample debugging target.
msg.version          = You are running Venkman version %1$S.
msg.tip.help         = Use ``help <command-name>'' for help on specific commands.
msg.no.breakpoints.set = No breakpoints set.
msg.no.fbreaks.set   = No future breakpoints set.
msg.noproperties     = %1$S has no properties.
msg.no-commandmatch  = No commands match ``%1$S''.
msg.commandmatch     = Commands matching ``%1$S'' are [%2$S].
msg.commandmatch.all = Implemented commands are %1$S.
msg.props.header     = Properties of %1$S in debug target scope:
msg.propsd.header    = Properties of %1$S in debugger scope:
msg.bp.header        = %1$S breakpoints set:
# 1 index, 2 file name, 3 line, 4 match count
msg.bp.line          = #%1$S <%2$S> line %3$S (%4$S scripts match.)
msg.bp.created       = Breakpoint at <%1$S> line %2$S created (%3$S scripts match.)
msg.bp.disabled      = Breakpoint at <%1$S> line %2$S disabled (%3$S scripts match.)
msg.bp.cleared       = Breakpoint at <%1$S> line %2$S deleted (%3$S scripts match.)
msg.bp.exists        = Breakpoint at <%1$S> line %2$S already set.
msg.fbp.header       = %1$S future breakpoints set:
# 1 index, 2 file name, 3 line
msg.fbp.line         = #%1$S %2$S:%3$S
msg.fbp.created      = Future breakpoint at <%1$S> line %2$S created.
msg.fbp.disabled     = Future breakpoint at <%1$S> line %2$S deleted.
msg.fbp.exists       = Future breakpoint at <%1$S> line %2$S already set.
msg.source.line      = %1$S: %2$S
msg.tmode.ignore     = Exceptions will now be ignored.
msg.tmode.trace      = Exceptions will now be traced.
msg.tmode.break      = Exceptions will now stop the debug target.
# 1 value, 2 frame
msg.exception.trace  = Exception %1$S thrown from %2$S.

## property value flags ##
vf.enumerable = e
vf.readonly   = r
vf.permanent  = p
vf.alias      = A
vf.argument   = a
vf.variable   = v
vf.hinted     = h

## formatting ##

# 1: argument name, 2: value
fmt.argument = %1$S=%2$S
# 1: property flags, 2: property name, 3: property value
fmt.property = [%1$S] %2$S = %3$S
# 1: function name, 2: filename
fmt.script = function %1$S in <%2$S>
# 1: function name, 2: arguments, 3: filename, 4: line number
fmt.frame = function %1$S(%2$S) in <%3$S> line %4$S
# 1: type, 2: class name, 3: value
fmt.value.long = [%1$S] [class: %2$S] %3$S
# 1: type, 2: value
fmt.value.med  = [%1$S] %2$S
# 1: type, 2: value
fmt.value.short = %1$S:%2$S
# 1: property count
fmt.object = %1$S properties
# 1: JS exception name, 2: error text, 3: file name, 4: line number
fmt.jsexception = %1$S: %2$S @ <%3$S> %4$S
# 1: error number,  2: error text, 3: file name, 4: line number, 5: function name
fmt.badmojo = BadMojo %1$S: %2$S @ <%3$S> line %4$S (%5$S)
# 1: var number, 2: value
fmt.tmp.assign = $[%1$S] = %2$S
# 1: string length
fmt.longstr = %1$S characters
# 1: command name 2: parameters
fmt.usage = %1$S %2$S
# 1: function name
fmt.guessedname = [%1$S]

## commands ##
cmd.break        = break
cmd.break.params = [<file-name> <line-number>]
cmd.break.help   = Set a breakpoint in the file named <file-name> at the line number <line-number>.  <file-name> can be a substring of the actual filename.  If no parameters are specified all active breakpoints will be listed.  See also: clear.

cmd.clear        = clear
cmd.clear.params = <index> | <file-name> <line-number>
cmd.clear.help   = Clears breakpoint at index <index>, or all breakpoints matching <file-name> and <line-number>.  <file-name> can be a substring of the actual filename.  See also: break.

cmd.commands        = commands
cmd.commands.params = [<pattern>]
cmd.commands.help   = Lists all command names matching <pattern>, or all command names if pattern is not specified.

cmd.cont            = cont
cmd.cont.params     = 
cmd.cont.help       = Continue execution of the debug target.

cmd.eval         = eval
cmd.eval.params  = <script>
cmd.eval.help    = Evaluates <script> in the scope of the debug target's current frame.  See also: frame, where, props, and evald.

cmd.evald         = evald
cmd.evald.params  = <script>
cmd.evald.help    = Evaluates <script> in the debugger's scope.  See also: eval.

cmd.fbreak        = fbreak
cmd.fbreak.params = [<file-pattern> <line-number>]
cmd.fbreak.help    = Sets a ``future'' breakpoint.  Any time a script whose file name matches <file-pattern> is loaded, a breakpoint a <line-number> is set.  Setting a breakpoint at line 1 will cause the debugger to break when the script is loaded.  fbreak with no parameters will list all future breakponts.  See also: break

cmd.finish        = finish
cmd.finish.params =
cmd.finish.help   = Execute until the current stack frame returns.

cmd.frame        = frame
cmd.frame.params = [<frame-number>]
cmd.frame.help   = Sets the current frame to the one numbered <frame-number>, and displays a summary of the frame.  If <frame-number> is not provided, a summary of the current frame will be displayed.  Use the where command to list available frames and frame numbers.

cmd.help         = help
cmd.help.params  = [<command>]
cmd.help.help    = Displays help on <command>, which can be a full command name, or the first few characters of the command name.  If <command> matches more than one command, help on all matching commands will be displayed.

cmd.next         = next
cmd.next.params  =
cmd.next.help    = Executes the next line of script.  If a function call is encountered it is traced as a single instruction.
cmd.props        = props
cmd.props.params = <expression>
cmd.props.help   = Lists the properties of the jsdIValue returned by <expression>.  The expression is evaluated in the scope of the debug target's current frame.  See also: where, frame, eval, and propsd.

cmd.propsd        = propsd
cmd.propsd.params = <expression>
cmd.propsd.help   = Lists the properties of the jsdIValue returned by <expression>.  The expression is evaluated in the debugger's scope.  See also: props.

cmd.scope        = scope
cmd.scope.params = 
cmd.scope.help   = Lists the properties of the topmost object in the scope chain for the current frame.

cmd.step        = step
cmd.step.params = 
cmd.step.help   = Executes the next line of script and stops.

cmd.tmode        = tmode
cmd.tmode.params = [ignore|trace|break]
cmd.tmode.help   = Sets what action the debugger should take when an exception is thrown from the debug target.  ``tmode ignore'' ignores all exceptions, ``tmode trace'' shows a log of the exception to the console, and ``tmode break'' stops excecution when an exception is thrown.  ``tmode'' without any parameter will display the current throw mode.  The key combination Control + T can be used to cycle the throw mode.

cmd.where        = where
cmd.where.params = 
cmd.where.help   = Displays a summarized list of stack frames in the current call chain.

cmd.quit         = quit
cmd.quit.params  =
cmd.quit.help    = Close this window.
