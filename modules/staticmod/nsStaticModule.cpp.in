/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * The contents of this file are subject to the Netscape Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.mozilla.org/NPL/
 *
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is Netscape
 * Communications Corporation.  Portions created by Netscape are
 * Copyright (C) 1998 Netscape Communications Corporation. All
 * Rights Reserved.
 *
 * Contributor(s): 
 *   Christopher Seawood <cls@seawood.org> 
 *   Doug Turner <dougt@netscape.com>
 */

#include "nsError.h"
#include "nsIModule.h"
#include "nsIFile.h"
#include "nsIGenericFactory.h"
#include "prmem.h"

#define REGISTER_MODULE_USING(mod) { \
    nsCOMPtr<nsIModule> module; \
    mod##(compMgr, aPath, getter_AddRefs(module)); \
    module->RegisterSelf(compMgr, aPath, "", ""); \
}

struct nsModuleComponentInfoContainer {
    nsModuleComponentInfo		*list;
    PRUint32                    count;
};

@DECLARE_COMPONENT_LIST@

static nsresult
NS_RegisterStaticModules(nsIFile *aPath)
{
    nsresult rv = PR_TRUE;
    nsIComponentManager *compMgr = nsnull;

    rv = NS_GetGlobalComponentManager(&compMgr);
    
    NS_ASSERTION(NS_SUCCEEDED(rv), "Static mods cannot get global component manager.");
    
    @COMPONENT_NS_GET_MODULE@
    
        {};
    
    return rv;
}

void StaticModuleDestructor(nsIModule *self, nsModuleComponentInfo *components)
{
    PR_Free(components);
}


#define NS_STATICMODULE_CID \
{ 0x1926250e, 0xef22, 0x4c8d, { 0x94, 0x37, 0x86, 0xa8, 0x07, 0xeb, 0xe4, 0xca } }

#define NS_STATICMODULE_CONTRACTID "@mozilla.org/staticmodule;1"



class nsStaticModuleImpl : public nsISupports
{
public:
    nsStaticModuleImpl();
    virtual ~nsStaticModuleImpl();
    NS_DECL_ISUPPORTS
};

nsStaticModuleImpl::nsStaticModuleImpl()
{
    NS_INIT_REFCNT();
}

nsStaticModuleImpl::~nsStaticModuleImpl()
{
}

NS_IMPL_ISUPPORTS1(nsStaticModuleImpl, nsISupports);

NS_GENERIC_FACTORY_CONSTRUCTOR(nsStaticModuleImpl)

static NS_METHOD nsStaticModuleRegistrationProc(nsIComponentManager *aCompMgr,
                                          nsIFile *aPath,
                                          const char *registryLocation,
                                          const char *componentType)
{
    NS_RegisterStaticModules(aPath);
    return NS_OK;
}

static NS_METHOD nsStaticModuleUnregistrationProc(nsIComponentManager *aCompMgr,
                                            nsIFile *aPath,
                                            const char *registryLocation)
{
    return NS_OK;
}


static nsModuleComponentInfo components[] =
{
  { "Static Component", 
    NS_STATICMODULE_CID, 
    NS_STATICMODULE_CONTRACTID, 
    nsStaticModuleImplConstructor,
    nsStaticModuleRegistrationProc,
    nsStaticModuleUnregistrationProc
  },
};

static nsModuleComponentInfoContainer componentsList[] = {
    { components, sizeof(components)/sizeof(components[0]) },
    @COMPONENT_LIST@
    { nsnull, 0 }
};

extern "C" NS_EXPORT nsresult NSGetModule(nsIComponentManager *servMgr,      
                                          nsIFile* location,                 
                                          nsIModule** result)                
{                                                                            
    nsModuleComponentInfo *outList = nsnull;
    nsModuleComponentInfoContainer *inList = componentsList;
    PRUint32 count = 0, i = 0, k=0, msize = sizeof(nsModuleComponentInfo);

    while (inList[i].list != nsnull) {
        count += inList[i].count;
        i++;
    }

    outList = (nsModuleComponentInfo *) PR_Calloc(count, sizeof(nsModuleComponentInfo));

    i = 0; k =0;
    while (inList[i].list != nsnull) {
        memcpy(&outList[k], inList[i].list, msize * inList[i].count);
        k+= inList[i].count;
        i++;
    }
    return NS_NewGenericModule("nsStaticModule", count, outList, nsnull, result);
}





