# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this file,
# You can obtain one at http://mozilla.org/MPL/2.0/.

from __future__ import print_function
import buildconfig
import os
import sys
import yaml
from collections import defaultdict
from io import BytesIO
from mozbuild.preprocessor import Preprocessor
from mozbuild.util import ensureParentDir, FileAvoidWrite

VALID_KEYS = {
    'name',
    'type',
    'value',
    'mirror',
    'do_not_use_directly',
    'include',
    'rust',
}

# Each key is a C++ type; its value is the equivalent non-atomic C++ type.
VALID_BOOL_TYPES = {
    'bool': 'bool',
    # These ones are defined in StaticPrefsBase.h.
    'RelaxedAtomicBool': 'bool',
    'ReleaseAcquireAtomicBool': 'bool',
    'SequentiallyConsistentAtomicBool': 'bool',
}

VALID_TYPES = VALID_BOOL_TYPES.copy()
VALID_TYPES.update({
    'int32_t': 'int32_t',
    'uint32_t': 'uint32_t',
    'float': 'float',
    # These ones are defined in StaticPrefsBase.h.
    'RelaxedAtomicInt32': 'int32_t',
    'RelaxedAtomicUint32': 'uint32_t',
    'ReleaseAcquireAtomicInt32': 'int32_t',
    'ReleaseAcquireAtomicUint32': 'uint32_t',
    'SequentiallyConsistentAtomicInt32': 'int32_t',
    'SequentiallyConsistentAtomicUint32': 'uint32_t',
    'AtomicFloat': 'float',
    'String': None,
})

# Map non-atomic C++ types to equivalent Rust types.
RUST_TYPES = {
    'bool': 'bool',
    'int32_t': 'i32',
    'uint32_t': 'u32',
    'float': 'f32',
}

FIRST_LINE = '// This file was generated by generate_static_pref_list.py. DO NOT EDIT.'

MIRROR_TEMPLATES = {
    'never': '''\
NEVER_PREF("{name}", {typ}, {value})
''',

    'once': '''\
ONCE_PREF(
  "{name}",
   {base_id},
   {full_id},
  {typ}, {value}
)
''',

    'always': '''\
ALWAYS_PREF(
  "{name}",
   {base_id},
   {full_id},
  {typ}, {value}
)
''',
}

STATIC_PREFS_GROUP_H_TEMPLATE1 = '''\
// Include it to gain access to StaticPrefs::{group}_*.

#ifndef mozilla_StaticPrefs_{group}_h
#define mozilla_StaticPrefs_{group}_h
'''

STATIC_PREFS_GROUP_H_TEMPLATE2 = '''\
#include "mozilla/StaticPrefListBegin.h"
#include "mozilla/StaticPrefList_{group}.h"
#include "mozilla/StaticPrefListEnd.h"

#endif  // mozilla_StaticPrefs_{group}_h
'''

STATIC_PREFS_C_GETTERS_TEMPLATE = '''\
extern "C" {typ} StaticPrefs_{full_id}() {{
  return mozilla::StaticPrefs::{full_id}();
}}
'''


def error(msg):
    raise ValueError(msg)


def mk_id(name):
    "Replace '.' and '-' with '_', e.g. 'foo.bar-baz' becomes 'foo_bar_baz'."
    return name.replace('.', '_').replace('-', '_')


def mk_group(pref):
    name = pref['name']
    return mk_id(name.split('.', 1)[0])


def check_pref_list(pref_list):
    # Pref names seen so far. Used to detect any duplicates.
    seen_names = set()

    # The previous pref. Used to detect mis-ordered prefs.
    prev_pref = None

    for pref in pref_list:
        # Check all given keys are known ones.
        for key in pref:
            if key not in VALID_KEYS:
                error('invalid key `{}`'.format(key))

        # 'name' must be present, valid, and in the right section.
        if 'name' not in pref:
            error('missing `name` key')
        name = pref['name']
        if type(name) != str:
            error('non-string `name` value `{}`'.format(name))
        if '.' not in name:
            error('`name` value `{}` lacks a \'.\''.format(name))
        if name in seen_names:
            error('`{}` pref is defined more than once'.format(name))
        seen_names.add(name)

        # Prefs must be ordered appropriately.
        if prev_pref:
            if mk_group(prev_pref) > mk_group(pref):
                error('`{}` pref must come before `{}` pref'
                      .format(name, prev_pref['name']))

        # 'type' must be present and valid.
        if 'type' not in pref:
            error('missing `type` key for pref `{}`'.format(name))
        typ = pref['type']
        if typ not in VALID_TYPES:
            error('invalid `type` value `{}` for pref `{}`'.format(typ, name))

        # 'value' must be present and valid.
        if 'value' not in pref:
            error('missing `value` key for pref `{}`'.format(name))
        value = pref['value']
        if typ == 'String':
            if type(value) != str:
                error('non-string `value` value `{}` for `String` pref `{}`; '
                      'add double quotes'
                      .format(value, name))
        elif typ in VALID_BOOL_TYPES:
            if value not in (True, False):
                error('invalid boolean value `{}` for pref `{}`'
                      .format(value, name))

        # 'mirror' must be present and valid.
        if 'mirror' not in pref:
            error('missing `mirror` key for pref `{}`'.format(name))
        mirror = pref['mirror']
        if mirror not in MIRROR_TEMPLATES:
            error('invalid `mirror` value `{}` for pref `{}`'
                  .format(mirror, name))

        # Check 'do_not_use_directly' if present.
        if 'do_not_use_directly' in pref:
            do_not_use_directly = pref['do_not_use_directly']
            if type(do_not_use_directly) != bool:
                error('non-boolean `do_not_use_directly` value `{}` for pref '
                      '`{}`'.format(do_not_use_directly, name))
            if do_not_use_directly and mirror == 'never':
                error('`do_not_use_directly` uselessly set with `mirror` value '
                      '`never` for pref `{}`'.format(pref['name']))

        # Check 'include' if present.
        if 'include' in pref:
            include = pref['include']
            if type(include) != str:
                error('non-string `include` value `{}` for pref `{}`'
                      .format(include, name))
            if include.startswith('<') and not include.endswith('>'):
                error('`include` value `{}` starts with `<` but does not '
                      'end with `>` for pref `{}`'.format(include, name))

        # Check 'rust' if present.
        if 'rust' in pref:
            rust = pref['rust']
            if type(rust) != bool:
                error('non-boolean `rust` value `{}` for pref `{}`'
                      .format(rust, name))
            if rust and mirror == 'never':
                error('`rust` uselessly set with `mirror` value `never` for '
                      'pref `{}`'.format(pref['name']))

        prev_pref = pref


def generate_code(pref_list):
    check_pref_list(pref_list)

    # The required includes for StaticPrefs_<group>.h.
    includes = defaultdict(set)

    # StaticPrefList_<group>.h contains all the pref definitions for this
    # group.
    static_pref_list_group_h = defaultdict(lambda: [FIRST_LINE, ''])

    # StaticPrefsCGetters.cpp contains C getters for all the mirrored prefs,
    # for use by Rust code.
    static_prefs_c_getters_cpp = [FIRST_LINE, '']

    # static_prefs.rs contains C getter declarations and a macro.
    static_prefs_rs_decls = []
    static_prefs_rs_macro = []

    # Generate the per-pref code (spread across multiple files).
    for pref in pref_list:
        name = pref['name']
        typ = pref['type']
        value = pref['value']
        mirror = pref['mirror']
        do_not_use_directly = pref.get('do_not_use_directly')
        include = pref.get('include')
        rust = pref.get('rust')

        base_id = mk_id(pref['name'])
        full_id = base_id
        if mirror == 'once':
            full_id += '_AtStartup'
        if do_not_use_directly:
            full_id += '_DoNotUseDirectly'

        group = mk_group(pref)

        if include:
            if not include.startswith('<'):
                # It's not a system header. Add double quotes.
                include = '"{}"'.format(include)
            includes[group].add(include)

        if typ == 'String':
            # Quote string literals, and escape double-quote chars.
            value = '"{}"'.format(value.replace('"', '\\"'))
        elif typ in VALID_BOOL_TYPES:
            # Convert Python bools to C++ bools.
            if value is True:
                value = 'true'
            elif value is False:
                value = 'false'

        # Append the C++ definition to the relevant output file's code.
        static_pref_list_group_h[group].append(MIRROR_TEMPLATES[mirror].format(
            name=name,
            base_id=base_id,
            full_id=full_id,
            typ=typ,
            value=value,
        ))

        if rust:
            # Generate the C getter.
            static_prefs_c_getters_cpp.append(
                STATIC_PREFS_C_GETTERS_TEMPLATE.format(typ=VALID_TYPES[typ], full_id=full_id))

            # Generate the C getter declaration, in Rust.
            decl = '    pub fn StaticPrefs_{full_id}() -> {typ};'
            static_prefs_rs_decls.append(
                decl.format(full_id=full_id, typ=RUST_TYPES[VALID_TYPES[typ]]))

            # Generate the Rust macro entry.
            macro = '    ("{name}") => (unsafe {{ $crate::StaticPrefs_{full_id}() }});'
            static_prefs_rs_macro.append(macro.format(name=name, full_id=full_id))

        # Delete this so that `group` can be reused below without Flake8
        # complaining.
        del group

    # StaticPrefListAll.h contains one `#include "mozilla/StaticPrefList_X.h`
    # line per pref group.
    static_pref_list_all_h = [FIRST_LINE, '']
    static_pref_list_all_h.extend(
        '#include "mozilla/StaticPrefList_{}.h"'.format(group)
        for group in sorted(static_pref_list_group_h)
    )
    static_pref_list_all_h.append('')

    # StaticPrefsAll.h contains one `#include "mozilla/StaticPrefs_X.h` line per
    # pref group.
    static_prefs_all_h = [FIRST_LINE, '']
    static_prefs_all_h.extend(
        '#include "mozilla/StaticPrefs_{}.h"'.format(group)
        for group in sorted(static_pref_list_group_h)
    )
    static_prefs_all_h.append('')

    # StaticPrefs_<group>.h wraps StaticPrefList_<group>.h. It is the header
    # used directly by application code.
    static_prefs_group_h = defaultdict(list)
    for group in sorted(static_pref_list_group_h):
        static_prefs_group_h[group] = [FIRST_LINE]
        static_prefs_group_h[group].append(STATIC_PREFS_GROUP_H_TEMPLATE1.format(group=group))
        if group in includes:
            # Add any necessary includes, from 'h_include' values.
            for include in sorted(includes[group]):
                static_prefs_group_h[group].append('#include {}'.format(include))
            static_prefs_group_h[group].append('')
        static_prefs_group_h[group].append(STATIC_PREFS_GROUP_H_TEMPLATE2.format(group=group))

    # static_prefs.rs contains the Rust macro getters.
    static_prefs_rs = [FIRST_LINE, '', 'extern "C" {']
    static_prefs_rs.extend(static_prefs_rs_decls)
    static_prefs_rs.extend(['}', '', '#[macro_export]', 'macro_rules! pref {'])
    static_prefs_rs.extend(static_prefs_rs_macro)
    static_prefs_rs.extend(['}', ''])

    def fold(lines):
        return '\n'.join(lines)

    return {
        'static_pref_list_all_h': fold(static_pref_list_all_h),
        'static_prefs_all_h': fold(static_prefs_all_h),
        'static_pref_list_group_h': {k: fold(v) for k, v in static_pref_list_group_h.items()},
        'static_prefs_group_h': {k: fold(v) for k, v in static_prefs_group_h.items()},
        'static_prefs_c_getters_cpp': fold(static_prefs_c_getters_cpp),
        'static_prefs_rs': fold(static_prefs_rs),
    }


def emit_code(fd, pref_list_filename):
    pp = Preprocessor()
    pp.context.update(buildconfig.defines['ALLDEFINES'])

    # A necessary hack until MOZ_DEBUG_FLAGS are part of buildconfig.defines.
    if buildconfig.substs.get('MOZ_DEBUG'):
        pp.context['DEBUG'] = '1'

    pp.out = BytesIO()
    pp.do_filter('substitution')
    pp.do_include(pref_list_filename)

    try:
        pref_list = yaml.safe_load(pp.out.getvalue())
        code = generate_code(pref_list)
    except (IOError, ValueError) as e:
        print('{}: error:\n  {}\n'
              .format(pref_list_filename, e))
        sys.exit(1)

    # When generating multiple files from a script, the build system treats the
    # first named output file (StaticPrefListAll.h in this case) specially -- it
    # is created elsewhere, and written to via `fd`.
    fd.write(code['static_pref_list_all_h'])

    # We must create the remaining output files ourselves. This requires
    # creating the output directory directly if it doesn't already exist.
    ensureParentDir(fd.name)
    init_dirname = os.path.dirname(fd.name)

    with FileAvoidWrite('StaticPrefsAll.h') as fd:
        fd.write(code['static_prefs_all_h'])

    for group, text in sorted(code['static_pref_list_group_h'].items()):
        filename = 'StaticPrefList_{}.h'.format(group)
        with FileAvoidWrite(os.path.join(init_dirname, filename)) as fd:
            fd.write(text)

    for group, text in sorted(code['static_prefs_group_h'].items()):
        filename = 'StaticPrefs_{}.h'.format(group)
        with FileAvoidWrite(filename) as fd:
            fd.write(text)

    with FileAvoidWrite(os.path.join(init_dirname, 'StaticPrefsCGetters.cpp')) as fd:
        fd.write(code['static_prefs_c_getters_cpp'])

    with FileAvoidWrite('static_prefs.rs') as fd:
        fd.write(code['static_prefs_rs'])
