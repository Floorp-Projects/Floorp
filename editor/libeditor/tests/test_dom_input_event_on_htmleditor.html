<html>
<head>
  <title>Test for input event of text editor</title>
  <script src="/tests/SimpleTest/SimpleTest.js"></script>
  <script src="/tests/SimpleTest/EventUtils.js"></script>
  <link rel="stylesheet" type="text/css"
          href="/tests/SimpleTest/test.css" />
</head>
<body>
<div id="display">
  <iframe id="editor1" srcdoc="<html><body contenteditable id='eventTarget'></body></html>"></iframe>
  <iframe id="editor2" srcdoc="<html contenteditable id='eventTarget'><body></body></html>"></iframe>
  <iframe id="editor3" srcdoc="<html><body><div contenteditable id='eventTarget'></div></body></html>"></iframe>
  <iframe id="editor4" srcdoc="<html contenteditable id='eventTarget'><body><div contenteditable></div></body></html>"></iframe>
  <iframe id="editor5" srcdoc="<html><body id='eventTarget'></body><script>document.designMode='on';</script></html>"></iframe>
</div>
<div id="content" style="display: none">

</div>
<pre id="test">
</pre>

<script class="testbody" type="application/javascript">
"use strict";

SimpleTest.waitForExplicitFinish();
SimpleTest.waitForFocus(runTests, window);

const kIsWin = navigator.platform.indexOf("Win") == 0;
const kIsMac = navigator.platform.indexOf("Mac") == 0;

async function runTests() {
  await SpecialPowers.pushPrefEnv({
    set: [["dom.input_events.beforeinput.enabled", true]],
  });

  const kWordSelectEatSpaceToNextWord = SpecialPowers.getBoolPref("layout.word_select.eat_space_to_next_word");

  // eslint-disable-next-line complexity
  function doTests(aDocument, aWindow, aDescription) {
    aDescription += ": ";
    aWindow.focus();

    let body = aDocument.body;
    let selection = aWindow.getSelection();

    function getHTMLEditor() {
      let editingSession = SpecialPowers.wrap(aWindow).docShell.editingSession;
      if (!editingSession) {
        return null;
      }
      let editor = editingSession.getEditorForWindow(aWindow);
      if (!editor) {
        return null;
      }
      return editor.QueryInterface(SpecialPowers.Ci.nsIHTMLEditor);
    }
    let htmlEditor = getHTMLEditor();

    let eventTarget = aDocument.getElementById("eventTarget");
    // The event target must be focusable because it's the editing host.
    eventTarget.focus();

    let editTarget = aDocument.getElementById("editTarget");
    if (!editTarget) {
      editTarget = eventTarget;
    }

    // Root element never can be edit target.  If the editTarget is the root
    // element, replace with its body.
    let isEditTargetIsDescendantOfEditingHost = false;
    if (editTarget == aDocument.documentElement) {
      editTarget = body;
      isEditTargetIsDescendantOfEditingHost = true;
    }

    editTarget.innerHTML = "";

    // If the editTarget isn't its editing host, move caret to the start of it.
    if (eventTarget != editTarget) {
      aDocument.getSelection().collapse(editTarget, 0);
    }

    let beforeInputEvent = null;
    let inputEvent = null;
    let selectionRanges = [];
    function reset() {
      beforeInputEvent = null;
      inputEvent = null;
      selectionRanges = [];
    }
    let cancelBeforeInput = false;
    let action = "";
    let beforeInputHandler = (aEvent) => {
      if (cancelBeforeInput) {
        aEvent.preventDefault();
      }
      ok(!beforeInputEvent, `${aDescription}Multiple "beforeinput" events are fired at ${action} (inputType: "${aEvent.inputType}", data: ${aEvent.data})`);
      ok(aEvent.isTrusted, `${aDescription}"beforeinput" event at ${action} must be trusted`);
      is(aEvent.target, eventTarget, `${aDescription}"beforeinput" event at ${action} is fired on unexpected element: ${aEvent.target.tagName}`);
      ok(aEvent instanceof InputEvent, `${aDescription}"beforeinput" event at ${action} should be dispatched with InputEvent interface`);
      ok(aEvent.bubbles, `${aDescription}"beforeinput" event at ${action} must be bubbles`);
      beforeInputEvent = aEvent;
      selectionRanges = [];
      for (let i = 0; i < selection.rangeCount; i++) {
        let range = selection.getRangeAt(i);
        selectionRanges.push({startContainer: range.startContainer, startOffset: range.startOffset,
                              endContainer: range.endContainer, endOffset: range.endOffset});
      }
    };
    let inputHandler = (aEvent) => {
      ok(!inputEvent, `${aDescription}Multiple "input" events are fired at ${action} (inputType: "${aEvent.inputType}", data: ${aEvent.data})`);
      ok(aEvent.isTrusted, `${aDescription}"input" event at ${action} must be trusted`);
      is(aEvent.target, eventTarget, `${aDescription}"input" event at ${action} is fired on unexpected element: ${aEvent.target.tagName}`);
      ok(aEvent instanceof InputEvent, `${aDescription}"input" event at ${action} should be dispatched with InputEvent interface`);
      ok(!aEvent.cancelable, `${aDescription}"input" event at ${action} must not be cancelable`);
      ok(aEvent.bubbles, `${aDescription}"input" event at ${action} must be bubbles`);
      let duration = Math.abs(window.performance.now() - aEvent.timeStamp);
      ok(duration < 30 * 1000,
         `${aDescription}perhaps, timestamp wasn't set correctly :${aEvent.timeStamp} (expected it to be within 30s of ` +
         `the current time but it differed by ${duration}ms)`);
      inputEvent = aEvent;
    };

    function checkTargetRanges(aEvent, aTargetRanges) {
      let targetRanges = aEvent.getTargetRanges();
      if (aTargetRanges.length === 0) {
        is(targetRanges.length, 0,
           `${aDescription}getTargetRanges() of "${aEvent.type}" event for ${action} should return empty array`);
        return;
      }
      is(targetRanges.length, aTargetRanges.length,
         `${aDescription}getTargetRanges() of "${aEvent.type}" event for ${action} should return array of static range`);
      if (targetRanges.length !== aTargetRanges.length) {
        return;
      }
      for (let i = 0; i < aTargetRanges.length; i++) {
        is(targetRanges[i].startContainer, aTargetRanges[i].startContainer,
           `${aDescription}startContainer of getTargetRanges()[${i}] of "${aEvent.type}" event for ${action} does not match`);
        is(targetRanges[i].startOffset, aTargetRanges[i].startOffset,
           `${aDescription}startOffset of getTargetRanges()[${i}] of "${aEvent.type}" event for ${action} does not match`);
        is(targetRanges[i].endContainer, aTargetRanges[i].endContainer,
           `${aDescription}endContainer of getTargetRanges()[${i}] of "${aEvent.type}" event for ${action} does not match`);
        is(targetRanges[i].endOffset, aTargetRanges[i].endOffset,
           `${aDescription}endOffset of getTargetRanges()[${i}] of "${aEvent.type}" event for ${action} does not match`);
      }
    }

    aWindow.addEventListener("beforeinput", beforeInputHandler, true);
    aWindow.addEventListener("input", inputHandler, true);

    reset();
    cancelBeforeInput = false;
    action = 'inserting "a"';
    synthesizeKey("a", {}, aWindow);
    is(editTarget.innerHTML, "a", `${aDescription}"a" should've been inserted by ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "insertText", `${aDescription}inputType of "beforeinput" event for ${action} should be "insertText"`);
    is(beforeInputEvent.data, "a", `${aDescription}data of "beforeinput" event for ${action} should be "a"`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, "insertText", `${aDescription}inputType of "input" event for ${action} should be "insertText"`);
    is(inputEvent.data, "a", `${aDescription}data of "input" event for ${action} should be "a"`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    reset();
    cancelBeforeInput = true;
    action = 'inserting "b"';
    synthesizeKey("b", {}, aWindow);
    is(editTarget.innerHTML, "a", `${aDescription}"a" shouldn't have been modified by ${action} since "beforeinput" was canceled`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    ok(!inputEvent, `${aDescription}"input" event shouldn't been fired at ${action} since "beforeinput" was canceled`);

    reset();
    cancelBeforeInput = true;
    editTarget.innerHTML = "ab";
    selection.collapse(editTarget.firstChild, 2);
    action = 'removing "a" with "Backspace" (with collapsed selection)';
    synthesizeKey("KEY_Backspace", {}, aWindow);
    is(editTarget.innerHTML, "ab", `${aDescription}"a" shouldn't have been modified by ${action} since "beforeinput" was canceled`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    ok(!inputEvent, `${aDescription}"input" event shouldn't been fired at ${action} since "beforeinput" was canceled`);

    reset();
    cancelBeforeInput = false;
    editTarget.innerHTML = "a";
    selection.collapse(editTarget.firstChild, 1);
    synthesizeKey("KEY_Backspace", {}, aWindow);
    is(editTarget.innerHTML, "<br>", `${aDescription}"a" should've been removed by ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "deleteContentBackward",
      `${aDescription}inputType of "beforeinput" event for ${action} should be "deleteContentBackward"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);  // XXX bug 1618457
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, "deleteContentBackward", `${aDescription}inputType of "input" event for ${action} should be "deleteContentBackward"`);
    is(inputEvent.data, null, `${aDescription}data of "input" event for ${action} should be null`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    reset();
    cancelBeforeInput = false;
    action = 'typing "Backspace" in empty editor';
    synthesizeKey("KEY_Backspace", {}, aWindow);
    is(editTarget.innerHTML, "<br>", `${aDescription}$shouldn't change empty editor by ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should be fired at ${action} even if it won't remove any content`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "deleteContentBackward",
      `${aDescription}inputType of "beforeinput" event for ${action} should be "deleteContentBackward"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);
    if (!isEditTargetIsDescendantOfEditingHost) {
      ok(!inputEvent, `${aDescription}"input" event shouldn't be fired at ${action}`);
    } else {
      todo(!inputEvent, `${aDescription}"input" event should be fired at ${action} but we replace the padding <br> element`);
    }

    reset();
    cancelBeforeInput = false;
    action = 'typing "B"';
    synthesizeKey("B", {shiftKey: true}, aWindow);
    is(editTarget.innerHTML, "B", `${aDescription}"B" should've been inserted by ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "insertText", `${aDescription}inputType of "beforeinput" event for ${action} should be "insertText"`);
    is(beforeInputEvent.data, "B", `${aDescription}data of "beforeinput" event for ${action} should be "B"`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, "insertText", `${aDescription}inputType of "input" event for ${action} should be "insertText"`);
    is(inputEvent.data, "B", `${aDescription}data of "input" event for ${action} should be "B"`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    reset();
    cancelBeforeInput = true;
    action = 'typing "Enter"';
    synthesizeKey("KEY_Enter", {}, aWindow);
    is(editTarget.innerHTML, "B", `${aDescription}shouldn't modify the editor by ${action} since "beforeinput" was canceled`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    ok(!inputEvent, `${aDescription}"input" event shouldn't been fired at ${action} since "beforeinput" was canceled`);

    reset();
    cancelBeforeInput = false;
    action = 'typing "Enter"';
    editTarget.innerHTML = "B";
    selection.collapse(editTarget.firstChild, 1);
    synthesizeKey("KEY_Enter", {}, aWindow);
    if (!isEditTargetIsDescendantOfEditingHost) {
      is(editTarget.innerHTML, "<div>B</div><div><br></div>", `${aDescription}should insert new paragraph by ${action}`);
    } else {
      // XXX Perhaps, this is a bug since we shouldn't change behavior when contenteditable element is <html> or <body>.
      is(editTarget.innerHTML, "B<br><br>", `${aDescription}should insert new paragraph by ${action}`);
    }
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "insertParagraph", `${aDescription}inputType of "beforeinput" event for ${action} should be "insertParagraph"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, "insertParagraph", `${aDescription}inputType of "input" event for ${action} should be "insertParagraph"`);
    is(inputEvent.data, null, `${aDescription}data of "input" event for ${action} should be null`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    reset();
    cancelBeforeInput = false;
    action = 'typing "C" in new paragraph';
    synthesizeKey("C", {shiftKey: true}, aWindow);
    if (!isEditTargetIsDescendantOfEditingHost) {
      is(editTarget.innerHTML, "<div>B</div><div>C</div>", `${aDescription}should insert "C" into the new paragraph by ${action}`);
    } else {
      is(editTarget.innerHTML, "B<br>C", `${aDescription}should insert "C" into the new paragraph by ${action}`);
    }
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "insertText", `${aDescription}inputType of "beforeinput" event for ${action} should be "insertText"`);
    is(beforeInputEvent.data, "C", `${aDescription}data of "beforeinput" event for ${action} should be "C"`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, "insertText", `${aDescription}inputType of "input" event for ${action} should be "insertText"`);
    is(inputEvent.data, "C", `${aDescription}data of "input" event for ${action} should be "C"`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    reset();
    cancelBeforeInput = false;
    action = 'typing "Enter" again';
    synthesizeKey("KEY_Enter", {}, aWindow);
    if (!isEditTargetIsDescendantOfEditingHost) {
      is(editTarget.innerHTML, "<div>B</div><div>C</div><div><br></div>", `${aDescription}should insert new paragraph again by ${action}`);
    } else {
      is(editTarget.innerHTML, "B<br>C<br><br>", `${aDescription}should insert new paragraph again by ${action}`);
    }
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "insertParagraph", `${aDescription}inputType of "beforeinput" event for ${action} should be "insertParagraph"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, "insertParagraph", `${aDescription}inputType of "input" event for ${action} should be "insertParagraph"`);
    is(inputEvent.data, null, `${aDescription}data of "input" event for ${action} should be null`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    reset();
    editTarget.innerHTML = "foo-bar";
    ok(!beforeInputEvent, `${aDescription}"beforeinput" event should not be fired when setting value`);
    ok(!inputEvent, `${aDescription}"input" event should not be fired when setting value`);

    reset();
    editTarget.innerHTML = "";
    ok(!beforeInputEvent, `${aDescription}"beforeinput" event should not be fired when setting empty value`);
    ok(!inputEvent, `${aDescription}"input" event should not be fired when setting empty value`);

    reset();
    action = 'inserting " " into empty editor';
    synthesizeKey(" ", {}, aWindow);
    is(editTarget.innerHTML, "&nbsp;", `${aDescription}" " should've been inserted by ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "insertText", `${aDescription}inputType of "beforeinput" event for ${action} should be "insertText"`);
    is(beforeInputEvent.data, " ", `${aDescription}data of "beforeinput" event for ${action} should be " "`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, "insertText", `${aDescription}inputType of "input" event for ${action} should be "insertText"`);
    is(inputEvent.data, " ", `${aDescription}data of "input" event for ${action} should be " "`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    reset();
    action = 'typing "Delete" at end';
    synthesizeKey("KEY_Delete", {}, aWindow);
    is(editTarget.innerHTML, "&nbsp;", `${aDescription}shouldn't modify the editor by ${action} since there is no content to remove`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should be fired at ${action} even if it won't remove any content`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "deleteContentForward", `${aDescription}inputType of "beforeinput" event for ${action} should be "deleteContentForward"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);
    ok(!inputEvent, `${aDescription}${action} should not fire "input" event since no content has been removed`);

    reset();
    action = 'typing "ArrowLeft"';
    synthesizeKey("KEY_ArrowLeft", {}, aWindow);
    ok(!beforeInputEvent, `${aDescription}${action} should not fire "beforeinput" event since no content has been modified`);
    ok(!inputEvent, `${aDescription}${action} should not fire "input" event since no content has been modified`);

    reset();
    cancelBeforeInput = true;
    action = 'typing "Delete"';
    synthesizeKey("KEY_Delete", {}, aWindow);
    is(editTarget.innerHTML, "&nbsp;", `${aDescription}"\u00A0" shouldn't have been removed by ${action} since "beforeinput" was canceled`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    ok(!inputEvent, `${aDescription}"input" event shouldn't been fired at ${action} since "beforeinput" was canceled`);

    // Reset undo/redo transaction for the following undo/redo tests.
    htmlEditor.enableUndo(false);
    htmlEditor.enableUndo(true);

    reset();
    cancelBeforeInput = false;
    editTarget.innerHTML = "\u00A0";
    selection.collapse(editTarget.firstChild, 0);
    synthesizeKey("KEY_Delete", {}, aWindow);
    is(editTarget.innerHTML, "<br>", `${aDescription}" " should've been removed by ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "deleteContentForward", `${aDescription}inputType of "beforeinput" event for ${action} should be "deleteContentForward"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);  // XXX bug 1618457
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, "deleteContentForward", `${aDescription}inputType of "input" event for ${action} should be "deleteContentForward"`);
    is(inputEvent.data, null, `${aDescription}data of "input" event for ${action} should be null`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    reset();
    cancelBeforeInput = true;
    action = 'doing "Undo"';
    synthesizeKey("z", {accelKey: true}, aWindow);
    is(editTarget.innerHTML, "<br>", `${aDescription}" " shouldn't have been restored by ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "historyUndo", `${aDescription}inputType of "beforeinput" event for ${action} should be "historyUndo"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, []);
    ok(!inputEvent, `${aDescription}"input" event shouldn't have been fired at ${action} since "beforeinput" was canceled`);

    reset();
    cancelBeforeInput = false;
    action = 'doing "Undo"';
    synthesizeKey("z", {accelKey: true}, aWindow);
    is(editTarget.innerHTML, "&nbsp;", `${aDescription}" " should've been restored by ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "historyUndo", `${aDescription}inputType of "beforeinput" event for ${action} should be "historyUndo"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, []);
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, "historyUndo", `${aDescription}inputType of "input" event for ${action} should be "historyUndo"`);
    is(inputEvent.data, null, `${aDescription}data of "input" event for ${action} should be null`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    reset();
    action = 'doing "Undo" again';
    synthesizeKey("z", {accelKey: true}, aWindow);
    is(editTarget.innerHTML, "&nbsp;", `${aDescription}the editor shouldn't have been modified by ${action} since there is no undo transaction`);
    ok(!beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action} since there is no undo transaction`);
    ok(!inputEvent, `${aDescription}"input" event shouldn't have been fired at ${action} since there is no undo transaction`);

    reset();
    cancelBeforeInput = true;
    action = 'doing "Redo"';
    synthesizeKey("z", {accelKey: true, shiftKey: true}, aWindow);
    is(editTarget.innerHTML, "&nbsp;", `${aDescription}" " shouldn't have been restored by ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "historyRedo", `${aDescription}inputType of "beforeinput" event for ${action} should be "historyRedo"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, []);
    ok(!inputEvent, `${aDescription}"input" event shouldn't have been fired at ${action} since "beforeinput" was canceled`);

    reset();
    cancelBeforeInput = false;
    action = 'doing "Redo"';
    synthesizeKey("z", {accelKey: true, shiftKey: true}, aWindow);
    is(editTarget.innerHTML, "<br>", `${aDescription}the padding <br> should've been restored by ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "historyRedo", `${aDescription}inputType of "beforeinput" event for ${action} should be "historyRedo"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, []);
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, "historyRedo", `${aDescription}inputType of "input" event for ${action} should be "historyRedo"`);
    is(inputEvent.data, null, `${aDescription}data of "input" event for ${action} should be null`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    reset();
    action = 'doing "Redo" again';
    synthesizeKey("z", {accelKey: true, shiftKey: true}, aWindow);
    is(editTarget.innerHTML, "<br>", `${aDescription}the editor shouldn't have been modified by ${action} since there is no redo transaction`);
    ok(!beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action} since there is no redo transaction`);
    ok(!inputEvent, `${aDescription}"input" event shouldn't have been fired at ${action} since there is no redo transaction`);

    reset();
    cancelBeforeInput = true;
    action = "inserting a line break";
    synthesizeKey("KEY_Enter", {shiftKey: true}, aWindow);
    is(editTarget.innerHTML, "<br>", `${aDescription}shouldn't modify the editor by ${action} since "beforeinput" was canceled`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    ok(!inputEvent, `${aDescription}"input" event shouldn't been fired at ${action} since "beforeinput" was canceled`);

    reset();
    cancelBeforeInput = false;
    editTarget.innerHTML = "<br>";
    selection.collapse(editTarget, 0);
    synthesizeKey("KEY_Enter", {shiftKey: true}, aWindow);
    is(editTarget.innerHTML, "<br><br>", `${aDescription}should insert new <br> element by ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "insertLineBreak", `${aDescription}inputType of "beforeinput" event for ${action} should be "insertLineBreak"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, "insertLineBreak", `${aDescription}inputType of "input" event for ${action} should be "insertLineBreak"`);
    is(inputEvent.data, null, `${aDescription}data of "input" event for ${action} should be null`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    // Backspace/Delete with non-collapsed selection.
    editTarget.innerHTML = "a";
    editTarget.focus();
    selection.selectAllChildren(editTarget);
    reset();
    cancelBeforeInput = true;
    action = 'removing "a" with "Backspace" (with selection)';
    synthesizeKey("KEY_Backspace", {}, aWindow);
    is(editTarget.innerHTML, "a", `${aDescription}"a" shouldn't have been removed by ${action} since "beforeinput" was canceled`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    ok(!inputEvent, `${aDescription}"input" event shouldn't been fired at ${action} since "beforeinput" was canceled`);

    editTarget.innerHTML = "a";
    editTarget.focus();
    selection.selectAllChildren(editTarget);
    reset();
    cancelBeforeInput = false;
    synthesizeKey("KEY_Backspace", {}, aWindow);
    is(editTarget.innerHTML, "<br>", `${aDescription}"a" should've been removed by ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "deleteContentBackward",
       `${aDescription}inputType of "beforeinput" event for ${action} should be "deleteContentBackward"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, "deleteContentBackward", `${aDescription}inputType of "input" event for ${action} should be "deleteContentBackward"`);
    is(inputEvent.data, null, `${aDescription}data of "input" event for ${action} should be null`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    editTarget.innerHTML = "a";
    editTarget.focus();
    selection.selectAllChildren(editTarget);
    reset();
    cancelBeforeInput = true;
    action = 'removing "a" with "Delete" (with selection)';
    synthesizeKey("KEY_Delete", {}, aWindow);
    is(editTarget.innerHTML, "a", `${aDescription}"a" should've been removed by ${action} since "beforeinput" was canceled`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should be fired at ${action} even if it won't remove any content`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "deleteContentForward", `${aDescription}inputType of "beforeinput" event for ${action} should be "deleteContentForward"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);
    ok(!inputEvent, `${aDescription}${action} should not fire "input" event since "beforeinput" was canceled`);

    editTarget.innerHTML = "a";
    editTarget.focus();
    selection.selectAllChildren(editTarget);
    reset();
    cancelBeforeInput = false;
    action = 'removing "a" with "Delete" (with selection)';
    synthesizeKey("KEY_Delete", {}, aWindow);
    is(editTarget.innerHTML, "<br>", `${aDescription}" " should've been removed by ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "deleteContentForward", `${aDescription}inputType of "beforeinput" event for ${action} should be "deleteContentForward"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, "deleteContentForward", `${aDescription}inputType of "input" event for ${action} should be "deleteContentForward"`);
    is(inputEvent.data, null, `${aDescription}data of "input" event for ${action} should be null`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    // Delete to previous/next word boundary with collapsed selection.
    editTarget.innerHTML = "abc def";
    editTarget.focus();
    selection.collapse(editTarget.firstChild, "abc def".length);
    reset();
    cancelBeforeInput = true;
    action = 'removing last word, "def", with backward deletion from its end';
    SpecialPowers.doCommand(aWindow, "cmd_deleteWordBackward");
    is(editTarget.innerHTML, "abc def", `${aDescription}"def" shouldn't have been removed by ${action} since "beforeinput" was canceled`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    ok(!inputEvent, `${aDescription}"input" event shouldn't been fired at ${action} since "beforeinput" was canceled`);

    editTarget.innerHTML = "abc def";
    editTarget.focus();
    selection.collapse(editTarget.firstChild, "abc def".length);
    reset();
    cancelBeforeInput = false;
    SpecialPowers.doCommand(aWindow, "cmd_deleteWordBackward");
    is(editTarget.innerHTML, "abc ", `${aDescription}"def" should've been removed by ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "deleteWordBackward", `${aDescription}inputType of "beforeinput" event for ${action} should be "deleteWordBackward"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);  // XXX bug 1618457
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, "deleteWordBackward", `${aDescription}inputType of "input" event for ${action} should be "deleteWordBackward"`);
    is(inputEvent.data, null, `${aDescription}data of "input" event for ${action} should be null`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    editTarget.innerHTML = "abc def";
    editTarget.focus();
    selection.collapse(editTarget.firstChild, 0);
    reset();
    cancelBeforeInput = true;
    action = `removing first word, "${kWordSelectEatSpaceToNextWord ? "abc" : "abc "}", with forward deletion from its start`;
    SpecialPowers.doCommand(aWindow, "cmd_deleteWordForward");
    is(editTarget.innerHTML, "abc def", `${aDescription}"abc" shouldn't have been removed by ${action} since "beforeinput" was canceled`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    ok(!inputEvent, `${aDescription}"input" event shouldn't been fired at ${action} since "beforeinput" was canceled`);

    editTarget.innerHTML = "abc def";
    editTarget.focus();
    selection.collapse(editTarget.firstChild, 0);
    reset();
    cancelBeforeInput = false;
    SpecialPowers.doCommand(aWindow, "cmd_deleteWordForward");
    is(editTarget.innerHTML, kWordSelectEatSpaceToNextWord ? "def" : " def",
       `${aDescription}"${kWordSelectEatSpaceToNextWord ? "abc " : "abc"}" should've been removed by ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "deleteWordForward", `${aDescription}inputType of "beforeinput" event for ${action} should be "deleteWordForward"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);  // XXX bug 1618457
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, "deleteWordForward", `${aDescription}inputType of "input" event for ${action} should be "deleteWordForward"`);
    is(inputEvent.data, null, `${aDescription}data of "input" event for ${action} should be null`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    // Delete to previous/next word boundary with non-collapsed selection.
    editTarget.innerHTML = "abc def";
    editTarget.focus();
    selection.setBaseAndExtent(editTarget.firstChild, "abc d".length, editTarget.firstChild, "abc de".length);
    reset();
    cancelBeforeInput = false;
    action = "removing characters backward from middle of second word";
    SpecialPowers.doCommand(aWindow, "cmd_deleteWordBackward");
    // Only on Windows, we collapse selection to start before handling this command.
    let expectedInputType = kIsWin ? "deleteWordBackward" : "deleteContentBackward";
    is(editTarget.innerHTML, kIsWin ? "abc ef" : "abc df",
      `${aDescription}${kIsWin ? "characters between current word start and selection start" : "selected characters"} should've been removed by ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, expectedInputType, `${aDescription}inputType of "beforeinput" event for ${action} should be "${expectedInputType}"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    if (kIsWin) {
      checkTargetRanges(beforeInputEvent, selectionRanges);  // XXX bug 1618457
    } else {
      checkTargetRanges(beforeInputEvent, selectionRanges);
    }

    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, expectedInputType, `${aDescription}inputType of "input" event for ${action} should be "${expectedInputType}"`);
    is(inputEvent.data, null, `${aDescription}data of "input" event for ${action} should be null`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    editTarget.innerHTML = "abc def";
    editTarget.focus();
    selection.setBaseAndExtent(editTarget.firstChild, "a".length, editTarget.firstChild, "ab".length);
    reset();
    cancelBeforeInput = false;
    action = "removing characters forward from middle of first word";
    SpecialPowers.doCommand(aWindow, "cmd_deleteWordForward");
    // Only on Windows, we collapse selection to start before handling this command.
    expectedInputType = kIsWin ? "deleteWordForward" : "deleteContentForward";
    let expectedValue = "ac def";
    if (kIsWin) {
      expectedValue = kWordSelectEatSpaceToNextWord ? "adef" : "a def";
    }
    is(editTarget.innerHTML, expectedValue,
      `${aDescription}${kIsWin ? "characters between selection start and next word start" : "selected characters"} should've been removed by ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, expectedInputType, `${aDescription}inputType of "beforeinput" event for ${action} should be "${expectedInputType}"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    if (kIsWin) {
      checkTargetRanges(beforeInputEvent, selectionRanges);  // XXX bug 1618457
    } else {
      checkTargetRanges(beforeInputEvent, selectionRanges);
    }
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, expectedInputType, `${aDescription}inputType of "input" event for ${action} should be "${expectedInputType}"`);
    is(inputEvent.data, null, `${aDescription}data of "input" event for ${action} should be null`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    // Delete to previous/next visual line boundary with collapsed selection.
    editTarget.innerHTML = "abc def";
    editTarget.focus();
    selection.collapse(editTarget.firstChild, "abc d".length);
    reset();
    cancelBeforeInput = false;
    action = "removing characters backward to start of line";
    SpecialPowers.doCommand(aWindow, "cmd_deleteToBeginningOfLine");
    is(editTarget.innerHTML, "ef", `${aDescription}characters between start of line and caret should've been removed by ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "deleteSoftLineBackward",
       `${aDescription}inputType of "beforeinput" event for ${action} should be "deleteSoftLineBackward"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);  // XXX bug 1618457
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, "deleteSoftLineBackward", `${aDescription}inputType of "input" event for ${action} should be "deleteSoftLineBackward"`);
    is(inputEvent.data, null, `${aDescription}data of "input" event for ${action} should be null`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    editTarget.innerHTML = "abc def";
    editTarget.focus();
    selection.collapse(editTarget.firstChild, "ab".length);
    reset();
    cancelBeforeInput = false;
    action = "removing characters forward to end of line";
    SpecialPowers.doCommand(aWindow, "cmd_deleteToEndOfLine");
    is(editTarget.innerHTML, "ab", `${aDescription}characters between caret and end of line should've been removed by ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "deleteSoftLineForward",
       `${aDescription}inputType of "beforeinput" event for ${action} should be "deleteSoftLineForward"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);  // XXX bug 1618457
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, "deleteSoftLineForward", `${aDescription}inputType of "input" event for ${action} should be "deleteSoftLineForward"`);
    is(inputEvent.data, null, `${aDescription}data of "input" event for ${action} should be null`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    // Delete to previous/next visual line boundary with non-collapsed selection.
    editTarget.innerHTML = "abc def";
    editTarget.focus();
    selection.setBaseAndExtent(editTarget.firstChild, "abc d".length, editTarget.firstChild, "abc_de".length);
    reset();
    cancelBeforeInput = false;
    action = "removing characters backward to start of line (with selection in second word)";
    SpecialPowers.doCommand(aWindow, "cmd_deleteToBeginningOfLine");
    // Only on Windows, we collapse selection to start before handling this command.
    expectedInputType = kIsWin ? "deleteSoftLineBackward" : "deleteContentBackward";
    is(editTarget.innerHTML, kIsWin ? "ef" : "abc df",
      `${aDescription}${kIsWin ? "characters between start of line and caret" : "selected characters"} should've been removed by ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, expectedInputType, `${aDescription}inputType of "beforeinput" event for ${action} should be "${expectedInputType}"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    if (kIsWin) {
      checkTargetRanges(beforeInputEvent, selectionRanges);  // XXX bug 1618457
    } else {
      checkTargetRanges(beforeInputEvent, selectionRanges);
    }
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, expectedInputType, `${aDescription}inputType of "input" event for ${action} should be "${expectedInputType}"`);
    is(inputEvent.data, null, `${aDescription}data of "input" event for ${action} should be null`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    editTarget.innerHTML = "abc def";
    editTarget.focus();
    selection.setBaseAndExtent(editTarget.firstChild, "a".length, editTarget.firstChild, "ab".length);
    reset();
    cancelBeforeInput = false;
    action = "removing characters forward to end of line (with selection in second word)";
    SpecialPowers.doCommand(aWindow, "cmd_deleteToEndOfLine");
    // Only on Windows, we collapse selection to start before handling this command.
    expectedInputType = kIsWin ? "deleteSoftLineForward" : "deleteContentForward";
    is(editTarget.innerHTML, kIsWin ? "a" : "ac def",
      `${aDescription}${kIsWin ? "characters between caret anc end of line" : "selected characters"} should've been removed by ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, expectedInputType, `${aDescription}inputType of "beforeinput" event for ${action} should be "${expectedInputType}"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    if (kIsWin) {
      checkTargetRanges(beforeInputEvent, selectionRanges);  // XXX bug 1618457
    } else {
      checkTargetRanges(beforeInputEvent, selectionRanges);
    }
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, expectedInputType, `${aDescription}inputType of "input" event for ${action} should be "${expectedInputType}"`);
    is(inputEvent.data, null, `${aDescription}data of "input" event for ${action} should be null`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    // Toggling text direction
    editTarget.focus();
    reset();
    cancelBeforeInput = true;
    action = 'switching text direction from "ltr" to "rtl"';
    SpecialPowers.doCommand(aWindow, "cmd_switchTextDirection");
    // XXX If editing host is a descendant of `<body>`, this must be a bug.
    is(body.getAttribute("dir"), null, `${aDescription}dir attribute of <body> should not be set" by ${action} since "beforeinput" was canceled`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "formatSetBlockTextDirection",
       `${aDescription}inputType of "beforeinput" event for ${action} should be "formatSetBlockTextDirection"`);
    is(beforeInputEvent.data, "rtl", `${aDescription}data of "beforeinput" event for ${action} should be "rtl"`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, []);
    ok(!inputEvent, `${aDescription}"input" event should not have been fired at ${action} since "beforeinput" was canceled`);

    body.setAttribute("dir", "rtl");
    htmlEditor.flags &= ~SpecialPowers.Ci.nsIEditor.eEditorLeftToRight;
    htmlEditor.flags |= SpecialPowers.Ci.nsIEditor.eEditorRightToLeft; // XXX flags update is required, must be a bug.
    aDocument.documentElement.scrollTop; // XXX Update the body frame
    editTarget.focus();
    reset();
    cancelBeforeInput = true;
    action = 'switching text direction from "rtl" to "ltr"';
    SpecialPowers.doCommand(aWindow, "cmd_switchTextDirection");
    // XXX If editing host is a descendant of `<body>`, this must be a bug.
    is(body.getAttribute("dir"), "rtl",
       `${aDescription}dir attribute of <body> should not have been modified by ${action} since "beforeinput" was canceled`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "formatSetBlockTextDirection",
       `${aDescription}inputType of "beforeinput" event for ${action} should be "formatSetBlockTextDirection"`);
    is(beforeInputEvent.data, "ltr", `${aDescription}data of "beforeinput" event for ${action} should be "ltr"`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, []);
    ok(!inputEvent, `${aDescription}"input" event should not have been fired at ${action} since "beforeinput" was canceled`);

    body.removeAttribute("dir");
    htmlEditor.flags &= ~SpecialPowers.Ci.nsIEditor.eEditorRightToLeft;
    htmlEditor.flags |= SpecialPowers.Ci.nsIEditor.eEditorLeftToRight; // XXX flags update is required, must be a bug.
    aDocument.documentElement.scrollTop; // XXX Update the body frame
    editTarget.focus();
    reset();
    cancelBeforeInput = false;
    action = 'switching text direction from "ltr" to "rtl"';
    SpecialPowers.doCommand(aWindow, "cmd_switchTextDirection");
    // XXX If editing host is a descendant of `<body>`, this must be a bug.
    is(body.getAttribute("dir"), "rtl", `${aDescription}dir attribute of <body> should've been set to "rtl" by ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "formatSetBlockTextDirection",
       `${aDescription}inputType of "beforeinput" event for ${action} should be "formatSetBlockTextDirection"`);
    is(beforeInputEvent.data, "rtl", `${aDescription}data of "beforeinput" event for ${action} should be "rtl"`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, []);
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, "formatSetBlockTextDirection", `${aDescription}inputType of "input" event for ${action} should be "formatSetBlockTextDirection"`);
    is(inputEvent.data, "rtl", `${aDescription}data of "input" event for ${action} should be "rtl"`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    editTarget.focus();
    reset();
    cancelBeforeInput = false;
    action = 'switching text direction from "rtl" to "ltr"';
    SpecialPowers.doCommand(aWindow, "cmd_switchTextDirection");
    // XXX If editing host is a descendant of `<body>`, this must be a bug.
    is(body.getAttribute("dir"), "ltr", `${aDescription}dir attribute of <body> should've been set to "ltr" by ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "formatSetBlockTextDirection",
       `${aDescription}inputType of "beforeinput" event for ${action} should be "formatSetBlockTextDirection"`);
    is(beforeInputEvent.data, "ltr", `${aDescription}data of "beforeinput" event for ${action} should be "ltr"`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, []);
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, "formatSetBlockTextDirection", `${aDescription}inputType of "input" event for ${action} should be "formatSetBlockTextDirection"`);
    is(inputEvent.data, "ltr", `${aDescription}data of "input" event for ${action} should be "ltr"`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    // Inserting link
    editTarget.innerHTML = "link";
    editTarget.focus();
    selection.selectAllChildren(editTarget);
    reset();
    cancelBeforeInput = true;
    action = "setting link with absolute URL";
    SpecialPowers.doCommand(aWindow, "cmd_insertLinkNoUI", "https://example.com/foo/bar.html");
    is(editTarget.innerHTML, "link", `${aDescription}the text should not habe been modified by ${action} since "beforeinput" was canceled`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "insertLink", `${aDescription}inputType of "beforeinput" event for ${action} should be "insertLink"`);
    is(beforeInputEvent.data, "https://example.com/foo/bar.html",
       `${aDescription}data of "beforeinput" event for ${action} should be "https://example.com/foo/bar.html"`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);
    ok(!inputEvent, `${aDescription}"input" event shouldn't have been fired at ${action} since "beforeinput" was canceled`);

    editTarget.innerHTML = "link";
    editTarget.focus();
    selection.selectAllChildren(editTarget);
    reset();
    cancelBeforeInput = false;
    action = "setting link with absolute URL";
    SpecialPowers.doCommand(aWindow, "cmd_insertLinkNoUI", "https://example.com/foo/bar.html");
    is(editTarget.innerHTML, '<a href="https://example.com/foo/bar.html">link</a>',
       `${aDescription}the text should've been wrapped by <a href> element by ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "insertLink", `${aDescription}inputType of "beforeinput" event for ${action} should be "insertLink"`);
    is(beforeInputEvent.data, "https://example.com/foo/bar.html",
       `${aDescription}data of "beforeinput" event for ${action} should be "https://example.com/foo/bar.html"`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, "insertLink", `${aDescription}inputType of "input" event for ${action} should be "insertLink"`);
    is(inputEvent.data, "https://example.com/foo/bar.html", `${aDescription}data of "input" event for ${action} should be "https://example.com/foo/bar.html"`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    editTarget.innerHTML = "link";
    selection.selectAllChildren(editTarget);
    reset();
    cancelBeforeInput = false;
    action = "setting link with relative URL";
    SpecialPowers.doCommand(aWindow, "cmd_insertLinkNoUI", "foo/bar.html");
    is(editTarget.innerHTML, '<a href="foo/bar.html">link</a>', `${aDescription}the text should've been wrapped by <a href> element by ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "insertLink", `${aDescription}inputType of "beforeinput" event for ${action} should be "insertLink"`);
    is(beforeInputEvent.data, "foo/bar.html", `${aDescription}data of "beforeinput" event for ${action} should be "foo/bar.html"`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.inputType, "insertLink", `${aDescription}inputType of "input" event for ${action} should be "insertLink"`);
    is(inputEvent.data, "foo/bar.html", `${aDescription}data of "input" event for ${action} should be "foo/bar.html"`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    // Format commands, which we might support with shortcut keys.
    for (let test of [{command: "cmd_bold",
                       tag: "b",
                       otherRemoveTags: ["strong"],
                       inputType: "formatBold"},
                      {command: "cmd_italic",
                       tag: "i",
                       otherRemoveTags: ["em"],
                       inputType: "formatItalic"},
                      {command: "cmd_underline",
                       tag: "u",
                       inputType: "formatUnderline"},
                      {command: "cmd_strikethrough",
                       tag: "strike",
                       otherRemoveTags: ["s"],
                       inputType: "formatStrikeThrough"},
                      {command: "cmd_subscript",
                       tag: "sub",
                       exclusiveTags: ["sup"],
                       inputType: "formatSubscript"},
                      {command: "cmd_superscript",
                       tag: "sup",
                       exclusiveTags: ["sub"],
                       inputType: "formatSuperscript"}]) {
      editTarget.innerHTML = "format";
      editTarget.focus();
      selection.selectAllChildren(editTarget);
      reset();
      cancelBeforeInput = false;
      action = `formatting with "${test.command}"`;
      SpecialPowers.doCommand(aWindow, test.command);
      is(editTarget.innerHTML, `<${test.tag}>format</${test.tag}>`,
         `${aDescription}all text should be wrapped with <${test.tag}> element at ${action}`);
      ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
      is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
      is(beforeInputEvent.inputType, test.inputType, `${aDescription}inputType of "beforeinput" event should be "${test.inputType}"`);
      is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
      is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
      checkTargetRanges(beforeInputEvent, selectionRanges);
      ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
      is(inputEvent.cancelable, false, `${aDescription}"input" event for ${action} should never be cancelable`);
      is(inputEvent.inputType, test.inputType, `${aDescription}inputType of "input" event should be "${test.inputType}"`);
      is(inputEvent.data, null, `${aDescription}data of "input" event for ${action} should be null`);
      is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
      checkTargetRanges(inputEvent, []);

      selection.selectAllChildren(editTarget);
      reset();
      cancelBeforeInput = false;
      action = `removing format with "${test.command}"`;
      SpecialPowers.doCommand(aWindow, test.command);
      is(editTarget.innerHTML, "format",
         `${aDescription}<${test.tag}> element should be unwrapped by ${action}`);
      ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
      is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
      is(beforeInputEvent.inputType, test.inputType, `${aDescription}inputType of "beforeinput" event should be "${test.inputType}"`);
      is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
      is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
      checkTargetRanges(beforeInputEvent, selectionRanges);
      ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
      is(inputEvent.cancelable, false, `${aDescription}"input" event for ${action} should never be cancelable`);
      is(inputEvent.inputType, test.inputType, `${aDescription}inputType of "input" event should be "${test.inputType}"`);
      is(inputEvent.data, null, `${aDescription}data of "input" event for ${action} should be null`);
      is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
      checkTargetRanges(inputEvent, []);

      selection.selectAllChildren(editTarget);
      reset();
      cancelBeforeInput = true;
      action = `formatting with "${test.command}" but "beforeinput" is canceled`;
      SpecialPowers.doCommand(aWindow, test.command);
      is(editTarget.innerHTML, "format",
         `${aDescription}text shouldn't have been modified at ${action}`);
      ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
      is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
      is(beforeInputEvent.inputType, test.inputType, `${aDescription}inputType of "beforeinput" event should be "${test.inputType}"`);
      is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
      is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
      checkTargetRanges(beforeInputEvent, selectionRanges);
      ok(!inputEvent, `${aDescription}"input" event shouldn't have been fired at ${action}`);

      editTarget.innerHTML = `<${test.tag}>format</${test.tag}>`;
      editTarget.focus();
      selection.selectAllChildren(editTarget);
      reset();
      cancelBeforeInput = true;
      action = `removing format with "${test.command}" but "beforeinput" is canceled`;
      SpecialPowers.doCommand(aWindow, test.command);
      is(editTarget.innerHTML, `<${test.tag}>format</${test.tag}>`,
         `${aDescription}text shouldn't have been modified at ${action}`);
      ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
      is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
      is(beforeInputEvent.inputType, test.inputType, `${aDescription}inputType of "beforeinput" event should be "${test.inputType}"`);
      is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
      is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
      checkTargetRanges(beforeInputEvent, selectionRanges);
      ok(!inputEvent, `${aDescription}"input" event shouldn't have been fired at ${action}`);

      if (test.otherRemoveTags) {
        for (let anotherTag of test.otherRemoveTags) {
          editTarget.innerHTML = `<${anotherTag}>format</${anotherTag}>`;
          editTarget.focus();
          selection.selectAllChildren(editTarget);
          reset();
          cancelBeforeInput = false;
          action = `removing <${anotherTag}> element with "${test.command}"`;
          SpecialPowers.doCommand(aWindow, test.command);
          is(editTarget.innerHTML, `format`,
             `${aDescription}<${anotherTag}> element should be unwrapped by ${action}`);
          ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
          is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
          is(beforeInputEvent.inputType, test.inputType, `${aDescription}inputType of "beforeinput" event should be "${test.inputType}"`);
          is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
          is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
          checkTargetRanges(beforeInputEvent, selectionRanges);
          ok(inputEvent, `${aDescription}"input" event shouldn't have been fired at ${action}`);
          is(inputEvent.cancelable, false, `${aDescription}"input" event for ${action} should never be cancelable`);
          is(inputEvent.inputType, test.inputType, `${aDescription}inputType of "input" event should be "${test.inputType}"`);
          is(inputEvent.data, null, `${aDescription}data of "input" event for ${action} should be null`);
          is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
          checkTargetRanges(inputEvent, []);

          editTarget.innerHTML = `<${anotherTag}>format</${anotherTag}>`;
          editTarget.focus();
          selection.selectAllChildren(editTarget);
          reset();
          cancelBeforeInput = true;
          action = `removing <${anotherTag}> element with "${test.command}" but "beforeinput" is canceled`;
          SpecialPowers.doCommand(aWindow, test.command);
          is(editTarget.innerHTML, `<${anotherTag}>format</${anotherTag}>`,
             `${aDescription}text shouldn't have been modified at ${action}`);
          ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
          is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
          is(beforeInputEvent.inputType, test.inputType, `${aDescription}inputType of "beforeinput" event should be "${test.inputType}"`);
          is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
          is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
          checkTargetRanges(beforeInputEvent, selectionRanges);
          ok(!inputEvent, `${aDescription}"input" event shouldn't have been fired at ${action}`);

          editTarget.innerHTML = `<${test.tag}><${anotherTag}>format</${anotherTag}></${test.tag}>`;
          editTarget.focus();
          selection.selectAllChildren(editTarget);
          reset();
          cancelBeforeInput = false;
          action = `removing both <${test.tag}> and <${anotherTag}> elements with "${test.command}"`;
          SpecialPowers.doCommand(aWindow, test.command);
          is(editTarget.innerHTML, `format`,
             `${aDescription}Both <${test.tag}> and <${anotherTag}> elements should be unwrapped by ${action}`);
          ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
          is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
          is(beforeInputEvent.inputType, test.inputType, `${aDescription}inputType of "beforeinput" event should be "${test.inputType}"`);
          is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
          is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
          checkTargetRanges(beforeInputEvent, selectionRanges);
          ok(inputEvent, `${aDescription}"input" event shouldn't have been fired at ${action}`);
          is(inputEvent.cancelable, false, `${aDescription}"input" event for ${action} should never be cancelable`);
          is(inputEvent.inputType, test.inputType, `${aDescription}inputType of "input" event should be "${test.inputType}"`);
          is(inputEvent.data, null, `${aDescription}data of "input" event for ${action} should be null`);
          is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
          checkTargetRanges(inputEvent, []);

          editTarget.innerHTML = `<${test.tag}><${anotherTag}>format</${anotherTag}></${test.tag}>`;
          editTarget.focus();
          selection.selectAllChildren(editTarget);
          reset();
          cancelBeforeInput = true;
          action = `removing both <${test.tag}> and <${anotherTag}> elements with "${test.command}" but "beforeinput" is canceled`;
          SpecialPowers.doCommand(aWindow, test.command);
          is(editTarget.innerHTML, `<${test.tag}><${anotherTag}>format</${anotherTag}></${test.tag}>`,
             `${aDescription}text shouldn't have been modified at ${action}`);
          ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
          is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
          is(beforeInputEvent.inputType, test.inputType, `${aDescription}inputType of "beforeinput" event should be "${test.inputType}"`);
          is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
          is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
          checkTargetRanges(beforeInputEvent, selectionRanges);
          ok(!inputEvent, `${aDescription}"input" event shouldn't have been fired at ${action}`);
        }
      }
      if (test.exclusiveTags) {
        for (let exclusiveTag of test.exclusiveTags) {
          editTarget.innerHTML = `<${exclusiveTag}>format</${exclusiveTag}>`;
          editTarget.focus();
          selection.selectAllChildren(editTarget);
          reset();
          cancelBeforeInput = false;
          action = `removing <${exclusiveTag}> element with formatting with "${test.command}"`;
          SpecialPowers.doCommand(aWindow, test.command);
          is(editTarget.innerHTML, `<${test.tag}>format</${test.tag}>`,
             `${aDescription}<${exclusiveTag}> element should be replaced with <${test.tag}> element by ${action}`);
          ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
          is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
          is(beforeInputEvent.inputType, test.inputType, `${aDescription}inputType of "beforeinput" event should be "${test.inputType}"`);
          is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
          is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
          checkTargetRanges(beforeInputEvent, selectionRanges);
          ok(inputEvent, `${aDescription}"input" event shouldn't have been fired at ${action}`);
          is(inputEvent.cancelable, false, `${aDescription}"input" event for ${action} should never be cancelable`);
          is(inputEvent.inputType, test.inputType, `${aDescription}inputType of "input" event should be "${test.inputType}"`);
          is(inputEvent.data, null, `${aDescription}data of "input" event for ${action} should be null`);
          is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
          checkTargetRanges(inputEvent, []);

          editTarget.innerHTML = `<${exclusiveTag}>format</${exclusiveTag}>`;
          editTarget.focus();
          selection.selectAllChildren(editTarget);
          reset();
          cancelBeforeInput = true;
          action = `removing <${exclusiveTag}> element with formatting with "${test.command}" but "beforeinput" is canceled`;
          SpecialPowers.doCommand(aWindow, test.command);
          is(editTarget.innerHTML, `<${exclusiveTag}>format</${exclusiveTag}>`,
             `${aDescription}text shouldn't have been modified at ${action}`);
          ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
          is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
          is(beforeInputEvent.inputType, test.inputType, `${aDescription}inputType of "beforeinput" event should be "${test.inputType}"`);
          is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
          is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
          checkTargetRanges(beforeInputEvent, selectionRanges);
          ok(!inputEvent, `${aDescription}"input" event shouldn't have been fired at ${action}`);
        }
      }
    }

    // Indent and Outdent
    editTarget.innerHTML = "format";
    editTarget.focus();
    selection.selectAllChildren(editTarget);
    reset();
    cancelBeforeInput = false;
    action = `indenting with "cmd_indent"`;
    SpecialPowers.doCommand(aWindow, "cmd_indent");
    is(editTarget.innerHTML, `<blockquote>format</blockquote>`,
       `${aDescription}all text should be wrapped with <blockquote> element at ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "formatIndent", `${aDescription}inputType of "beforeinput" event should be "formatIndent"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.cancelable, false, `${aDescription}"input" event for ${action} should never be cancelable`);
    is(inputEvent.inputType, "formatIndent", `${aDescription}inputType of "input" event should be "formatIndent"`);
    is(inputEvent.data, null, `${aDescription}data of "input" event for ${action} should be null`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    selection.selectAllChildren(editTarget);
    reset();
    cancelBeforeInput = false;
    action = `outdenting with "cmd_outdent"`;
    SpecialPowers.doCommand(aWindow, "cmd_outdent");
    is(editTarget.innerHTML, "format",
       `${aDescription}<blockquote> element should be unwrapped by ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "formatOutdent", `${aDescription}inputType of "beforeinput" event should be "formatOutdent"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);
    ok(inputEvent, `${aDescription}"input" event should've been fired at ${action}`);
    is(inputEvent.cancelable, false, `${aDescription}"input" event for ${action} should never be cancelable`);
    is(inputEvent.inputType, "formatOutdent", `${aDescription}inputType of "input" event should be "formatOutdent"`);
    is(inputEvent.data, null, `${aDescription}data of "input" event for ${action} should be null`);
    is(inputEvent.dataTransfer, null, `${aDescription}dataTransfer of "input" event for ${action} should be null`);
    checkTargetRanges(inputEvent, []);

    selection.selectAllChildren(editTarget);
    reset();
    cancelBeforeInput = true;
    action = `indenting with "cmd_indent" but "beforeinput" is canceled`;
    SpecialPowers.doCommand(aWindow, "cmd_indent");
    is(editTarget.innerHTML, "format",
       `${aDescription}text shouldn't have been modified at ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "formatIndent", `${aDescription}inputType of "beforeinput" event should be "formatIndent"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);
    ok(!inputEvent, `${aDescription}"input" event shouldn't have been fired at ${action}`);

    editTarget.innerHTML = `<blockquote>format</blockquote>`;
    editTarget.focus();
    selection.selectAllChildren(editTarget);
    reset();
    cancelBeforeInput = true;
    action = `outdenting with "cmd_outdent" but "beforeinput" is canceled`;
    SpecialPowers.doCommand(aWindow, "cmd_outdent");
    is(editTarget.innerHTML, `<blockquote>format</blockquote>`,
       `${aDescription}text shouldn't have been modified at ${action}`);
    ok(beforeInputEvent, `${aDescription}"beforeinput" event should've been fired at ${action}`);
    is(beforeInputEvent.cancelable, true, `${aDescription}"beforeinput" event for ${action} should be cancelable`);
    is(beforeInputEvent.inputType, "formatOutdent", `${aDescription}inputType of "beforeinput" event should be "formatOutdent"`);
    is(beforeInputEvent.data, null, `${aDescription}data of "beforeinput" event for ${action} should be null`);
    is(beforeInputEvent.dataTransfer, null, `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
    checkTargetRanges(beforeInputEvent, selectionRanges);
    ok(!inputEvent, `${aDescription}"input" event shouldn't have been fired at ${action}`);

    aWindow.removeEventListener("beforeinput", beforeInputHandler, true);
    aWindow.removeEventListener("input", inputHandler, true);
  }

  doTests(document.getElementById("editor1").contentDocument,
          document.getElementById("editor1").contentWindow,
          "Editor1, body has contenteditable attribute");
  doTests(document.getElementById("editor2").contentDocument,
          document.getElementById("editor2").contentWindow,
          "Editor2, html has contenteditable attribute");
  doTests(document.getElementById("editor3").contentDocument,
          document.getElementById("editor3").contentWindow,
          "Editor3, div has contenteditable attribute");
  doTests(document.getElementById("editor4").contentDocument,
          document.getElementById("editor4").contentWindow,
          "Editor4, html and div has contenteditable attribute");
  doTests(document.getElementById("editor5").contentDocument,
          document.getElementById("editor5").contentWindow,
          "Editor5, html and div has contenteditable attribute");

  SimpleTest.finish();
}

</script>
</body>

</html>
