<html>
<head>
  <title>Test for input event of text editor</title>
  <script src="/tests/SimpleTest/SimpleTest.js"></script>
  <script src="/tests/SimpleTest/EventUtils.js"></script>
  <link rel="stylesheet" type="text/css"
          href="/tests/SimpleTest/test.css" />
</head>
<body>
<div id="display">
  <iframe id="editor1" srcdoc="<html><body contenteditable id='eventTarget'></body></html>"></iframe>
  <iframe id="editor2" srcdoc="<html contenteditable id='eventTarget'><body></body></html>"></iframe>
  <iframe id="editor3" srcdoc="<html><body><div contenteditable id='eventTarget'></div></body></html>"></iframe>
  <iframe id="editor4" srcdoc="<html contenteditable id='eventTarget'><body><div contenteditable></div></body></html>"></iframe>
  <iframe id="editor5" srcdoc="<html><body id='eventTarget'></body><script>document.designMode='on';</script></html>"></iframe>
</div>
<div id="content" style="display: none">

</div>
<pre id="test">
</pre>

<script class="testbody" type="application/javascript">
"use strict";

SimpleTest.waitForExplicitFinish();
SimpleTest.waitForFocus(runTests, window);

const kIsWin = navigator.platform.indexOf("Win") == 0;
const kIsMac = navigator.platform.indexOf("Mac") == 0;

async function runTests() {
  await SpecialPowers.pushPrefEnv({
    set: [["dom.input_events.beforeinput.enabled", true]],
  });

  const kWordSelectEatSpaceToNextWord = SpecialPowers.getBoolPref("layout.word_select.eat_space_to_next_word");
  const kImgURL =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAYAAABytg0kAAAAEElEQVR42mNgaGD4D8YwBgAw9AX9Y9zBwwAAAABJRU5ErkJggg==";

  // eslint-disable-next-line complexity
  function doTests(aDocument, aWindow, aDescription) {
    aDescription += ": ";
    aWindow.focus();

    let body = aDocument.body;
    let selection = aWindow.getSelection();

    function getHTMLEditor() {
      let editingSession = SpecialPowers.wrap(aWindow).docShell.editingSession;
      if (!editingSession) {
        return null;
      }
      let editor = editingSession.getEditorForWindow(aWindow);
      if (!editor) {
        return null;
      }
      return editor.QueryInterface(SpecialPowers.Ci.nsIHTMLEditor);
    }
    let htmlEditor = getHTMLEditor();

    let eventTarget = aDocument.getElementById("eventTarget");
    // The event target must be focusable because it's the editing host.
    eventTarget.focus();

    let editTarget = aDocument.getElementById("editTarget");
    if (!editTarget) {
      editTarget = eventTarget;
    }

    // Root element never can be edit target.  If the editTarget is the root
    // element, replace with its body.
    let isEditTargetIsDescendantOfEditingHost = false;
    if (editTarget == aDocument.documentElement) {
      editTarget = body;
      isEditTargetIsDescendantOfEditingHost = true;
    }

    editTarget.innerHTML = "";

    // If the editTarget isn't its editing host, move caret to the start of it.
    if (eventTarget != editTarget) {
      aDocument.getSelection().collapse(editTarget, 0);
    }

    let initializing = false;
    let beforeInputEvent = null;
    let inputEvent = null;
    let selectionRanges = [];
    function reset() {
      beforeInputEvent = null;
      inputEvent = null;
      selectionRanges = [];
    }
    let cancelBeforeInput = false;
    let action = "";
    let beforeInputHandler = (aEvent) => {
      if (initializing) {
        return;
      }
      if (cancelBeforeInput) {
        aEvent.preventDefault();
      }
      ok(!beforeInputEvent,
        `${aDescription}Multiple "beforeinput" events are fired at ${action} (inputType: "${aEvent.inputType}", data: ${aEvent.data})`);
      ok(aEvent.isTrusted,
        `${aDescription}"beforeinput" event at ${action} must be trusted`);
      is(aEvent.target, eventTarget,
        `${aDescription}"beforeinput" event at ${action} is fired on unexpected element: ${aEvent.target.tagName}`);
      ok(aEvent instanceof InputEvent,
        `${aDescription}"beforeinput" event at ${action} should be dispatched with InputEvent interface`);
      ok(aEvent.bubbles,
        `${aDescription}"beforeinput" event at ${action} must be bubbles`);
      beforeInputEvent = aEvent;
      selectionRanges = [];
      for (let i = 0; i < selection.rangeCount; i++) {
        let range = selection.getRangeAt(i);
        selectionRanges.push({startContainer: range.startContainer, startOffset: range.startOffset,
                              endContainer: range.endContainer, endOffset: range.endOffset});
      }
    };
    let inputHandler = (aEvent) => {
      if (initializing) {
        return;
      }
      ok(!inputEvent,
        `${aDescription}Multiple "input" events are fired at ${action} (inputType: "${aEvent.inputType}", data: ${aEvent.data})`);
      ok(aEvent.isTrusted,
        `${aDescription}"input" event at ${action} must be trusted`);
      is(aEvent.target, eventTarget,
        `${aDescription}"input" event at ${action} is fired on unexpected element: ${aEvent.target.tagName}`);
      ok(aEvent instanceof InputEvent,
        `${aDescription}"input" event at ${action} should be dispatched with InputEvent interface`);
      ok(!aEvent.cancelable,
        `${aDescription}"input" event at ${action} must not be cancelable`);
      ok(aEvent.bubbles,
        `${aDescription}"input" event at ${action} must be bubbles`);
      let duration = Math.abs(window.performance.now() - aEvent.timeStamp);
      ok(duration < 30 * 1000,
        `${aDescription}perhaps, timestamp wasn't set correctly :${aEvent.timeStamp} (expected it to be within 30s of ` +
        `the current time but it differed by ${duration}ms)`);
      inputEvent = aEvent;
    };

    function checkTargetRanges(aEvent, aTargetRanges) {
      let targetRanges = aEvent.getTargetRanges();
      if (aTargetRanges.length === 0) {
        is(targetRanges.length, 0,
          `${aDescription}getTargetRanges() of "${aEvent.type}" event for ${action} should return empty array`);
        return;
      }
      is(targetRanges.length, aTargetRanges.length,
        `${aDescription}getTargetRanges() of "${aEvent.type}" event for ${action} should return array of static range`);
      if (targetRanges.length !== aTargetRanges.length) {
        return;
      }
      for (let i = 0; i < aTargetRanges.length; i++) {
        is(targetRanges[i].startContainer, aTargetRanges[i].startContainer,
          `${aDescription}startContainer of getTargetRanges()[${i}] of "${aEvent.type}" event for ${action} does not match`);
        is(targetRanges[i].startOffset, aTargetRanges[i].startOffset,
          `${aDescription}startOffset of getTargetRanges()[${i}] of "${aEvent.type}" event for ${action} does not match`);
        is(targetRanges[i].endContainer, aTargetRanges[i].endContainer,
          `${aDescription}endContainer of getTargetRanges()[${i}] of "${aEvent.type}" event for ${action} does not match`);
        is(targetRanges[i].endOffset, aTargetRanges[i].endOffset,
          `${aDescription}endOffset of getTargetRanges()[${i}] of "${aEvent.type}" event for ${action} does not match`);
      }
    }

    aWindow.addEventListener("beforeinput", beforeInputHandler, true);
    aWindow.addEventListener("input", inputHandler, true);

    (function test_typing_a_in_empty_editor() {
      reset();
      cancelBeforeInput = false;
      action = 'inserting "a"';
      synthesizeKey("a", {}, aWindow);
      is(editTarget.innerHTML, "a",
        `${aDescription}"a" should've been inserted by ${action}`);
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${action}`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${action} should be cancelable`);
      is(beforeInputEvent.inputType, "insertText",
        `${aDescription}inputType of "beforeinput" event for ${action} should be "insertText"`);
      is(beforeInputEvent.data, "a",
        `${aDescription}data of "beforeinput" event for ${action} should be "a"`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
      checkTargetRanges(beforeInputEvent, selectionRanges);
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${action}`);
      is(inputEvent.inputType, "insertText",
        `${aDescription}inputType of "input" event for ${action} should be "insertText"`);
      is(inputEvent.data, "a",
        `${aDescription}data of "input" event for ${action} should be "a"`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${action} should be null`);
      checkTargetRanges(inputEvent, []);
    })();

    function test_typing_b_at_end_of_editor(aTestData) {
      reset();
      cancelBeforeInput = aTestData.cancelBeforeInput;
      editTarget.innerHTML = "a";
      selection.collapse(editTarget.firstChild, 1);
      action = aTestData.action;
      synthesizeKey("b", {}, aWindow);
      let expectedValue = aTestData.cancelBeforeInput ? "a" : "ab";
      is(editTarget.innerHTML, expectedValue,
        `${aDescription}innerHTML should be"${expectedValue}" after ${aTestData.action}`);
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${aTestData.action}`);
      if (aTestData.cancelBeforeInput) {
        ok(!inputEvent,
          `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
        return;
      }
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${aTestData.action}`);
    }
    test_typing_b_at_end_of_editor({
      action: 'typing "b" after "a" and canceling "beforeinput"',
      cancelBeforeInput: true,
    });
    test_typing_b_at_end_of_editor({
      action: 'typing "b" after "a"',
      cancelBeforeInput: false,
    });

    function test_typing_backspace_to_delete_last_character(aTestData) {
      reset();
      cancelBeforeInput = aTestData.cancelBeforeInput;
      action = aTestData.action;
      editTarget.innerHTML = "a";
      selection.collapse(editTarget.firstChild, 1);
      synthesizeKey("KEY_Backspace", {}, aWindow);
      let expectedValue = aTestData.cancelBeforeInput ? "a" : "<br>";
      is(editTarget.innerHTML, expectedValue,
        `${aDescription}innerHTML should be"${expectedValue}" after ${aTestData.action}`);
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${aTestData.action}`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${aTestData.action} should be cancelable`);
      is(beforeInputEvent.inputType, "deleteContentBackward",
        `${aDescription}inputType of "beforeinput" event for ${aTestData.action} should be "deleteContentBackward"`);
      is(beforeInputEvent.data, null,
        `${aDescription}data of "beforeinput" event for ${aTestData.action} should be null`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${aTestData.action} should be null`);
      checkTargetRanges(beforeInputEvent, [{startContainer: selectionRanges[0].endContainer,
                                            startOffset: selectionRanges[0].endOffset - 1,
                                            endContainer: selectionRanges[0].endContainer,
                                            endOffset: selectionRanges[0].endOffset}]);
      if (aTestData.cancelBeforeInput) {
        ok(!inputEvent,
          `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
        return;
      }
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${aTestData.action}`);
      is(inputEvent.inputType, "deleteContentBackward",
        `${aDescription}inputType of "input" event for ${aTestData.action} should be "deleteContentBackward"`);
      is(inputEvent.data, null,
        `${aDescription}data of "input" event for ${aTestData.action} should be null`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${aTestData.action} should be null`);
      checkTargetRanges(inputEvent, []);
    }
    test_typing_backspace_to_delete_last_character({
      action: 'typing "Backspace" to delete the last character and canceling "beforeinput"',
      cancelBeforeInput: true,
    });
    test_typing_backspace_to_delete_last_character({
      action: 'typing "Backspace" to delete the last character',
      cancelBeforeInput: false,
    });

    (function test_typing_backspace_in_empty_editor() {
      reset();
      cancelBeforeInput = false;
      action = 'typing "Backspace" in empty editor';
      synthesizeKey("KEY_Backspace", {}, aWindow);
      is(editTarget.innerHTML, "<br>",
        `${aDescription}$shouldn't change empty editor by ${action}`);
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should be fired at ${action} even if it won't remove any content`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${action} should be cancelable`);
      is(beforeInputEvent.inputType, "deleteContentBackward",
        `${aDescription}inputType of "beforeinput" event for ${action} should be "deleteContentBackward"`);
      is(beforeInputEvent.data, null,
        `${aDescription}data of "beforeinput" event for ${action} should be null`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
      checkTargetRanges(beforeInputEvent, selectionRanges);
      ok(!inputEvent,
        `${aDescription}"input" event shouldn't be fired at ${action}`);
    })();

    function test_typing_enter_at_end_of_editor(aTestData) {
      reset();
      cancelBeforeInput = aTestData.cancelBeforeInput;
      action = aTestData.action;
      editTarget.innerHTML = "B";
      selection.collapse(editTarget.firstChild, 1);
      synthesizeKey("KEY_Enter", {}, aWindow);
      if (aTestData.cancelBeforeInput) {
        is(editTarget.innerHTML, "B",
          `${aDescription}innerHTML should be "B" after ${aTestData.action}`);
      } else if (!isEditTargetIsDescendantOfEditingHost) {
        is(editTarget.innerHTML, "<div>B</div><div><br></div>",
          `${aDescription}innerHTML should be "<div>B</div><div><br></div>" after ${aTestData.action}`);
      } else {
        // XXX Perhaps, this is a bug since we shouldn't change behavior when contenteditable element is <html> or <body>.
        is(editTarget.innerHTML, "B<br><br>",
          `${aDescription}innerHTML should be "B<br><br>" after ${aTestData.action}`);
      }
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${aTestData.action} should be cancelable`);
      is(beforeInputEvent.inputType, "insertParagraph",
        `${aDescription}inputType of "beforeinput" event for ${aTestData.action} should be "insertParagraph"`);
      is(beforeInputEvent.data, null,
        `${aDescription}data of "beforeinput" event for ${aTestData.action} should be null`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${aTestData.action} should be null`);
      checkTargetRanges(beforeInputEvent, selectionRanges);
      if (aTestData.cancelBeforeInput) {
        ok(!inputEvent,
          `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
        return;
      }
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${aTestData.action}`);
      is(inputEvent.inputType, "insertParagraph",
        `${aDescription}inputType of "input" event for ${aTestData.action} should be "insertParagraph"`);
      is(inputEvent.data, null,
        `${aDescription}data of "input" event for ${aTestData.action} should be null`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${aTestData.action} should be null`);
      checkTargetRanges(inputEvent, []);
    }
    test_typing_enter_at_end_of_editor({
      action: 'typing "Enter" at end of editor and canceling "beforeinput"',
      cancelBeforeInput: true,
    });
    test_typing_enter_at_end_of_editor({
      action: 'typing "Enter" at end of editor',
      cancelBeforeInput: false,
    });

    function test_typing_C_in_empty_last_line(aTestData) {
      reset();
      cancelBeforeInput = aTestData.cancelBeforeInput;
      action = aTestData.action;
      if (!isEditTargetIsDescendantOfEditingHost) {
        editTarget.innerHTML = "<div>B</div><div><br></div>";
        selection.collapse(editTarget.querySelector("div + div"), 0);
      } else {
        editTarget.innerHTML = "B<br><br>";
        selection.collapse(editTarget, 2);
      }
      synthesizeKey("C", {shiftKey: true}, aWindow);
      if (!isEditTargetIsDescendantOfEditingHost) {
        let expectedValue = aTestData.cancelBeforeInput
                              ? "<div>B</div><div><br></div>"
                              : "<div>B</div><div>C<br></div>";
        is(editTarget.innerHTML, expectedValue,
          `${aDescription}innerHTML should be "${expectedValue}" after ${aTestData.action}`);
      } else {
        let expectedValue = aTestData.cancelBeforeInput
                              ? "B<br><br>"
                              : "B<br>C<br>";
        is(editTarget.innerHTML, expectedValue,
          `${aDescription}innerHTML should be "${expectedValue}" after ${aTestData.action}`);
      }
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${aTestData.action} should be cancelable`);
      is(beforeInputEvent.inputType, "insertText",
        `${aDescription}inputType of "beforeinput" event for ${aTestData.action} should be "insertText"`);
      is(beforeInputEvent.data, "C",
        `${aDescription}data of "beforeinput" event for ${aTestData.action} should be "C"`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${aTestData.action} should be null`);
      checkTargetRanges(beforeInputEvent, selectionRanges);
      if (aTestData.cancelBeforeInput) {
        ok(!inputEvent,
          `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
        return;
      }
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${aTestData.action}`);
      is(inputEvent.inputType, "insertText",
        `${aDescription}inputType of "input" event for ${aTestData.action} should be "insertText"`);
      is(inputEvent.data, "C",
        `${aDescription}data of "input" event for ${aTestData.action} should be "C"`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${aTestData.action} should be null`);
      checkTargetRanges(inputEvent, []);
    }
    test_typing_C_in_empty_last_line({
      action: 'typing "C" in empty last line and canceling "beforeinput"',
      cancelBeforeInput: true,
    });
    test_typing_C_in_empty_last_line({
      action: 'typing "C" in empty last line',
      cancelBeforeInput: false,
    });

    function test_typing_enter_in_non_empty_last_line(aTestData) {
      reset();
      cancelBeforeInput = aTestData.cancelBeforeInput;
      action = aTestData.action;
      if (!isEditTargetIsDescendantOfEditingHost) {
        editTarget.innerHTML = "<div>B</div><div>C<br></div>";
        selection.collapse(editTarget.querySelector("div + div").firstChild, 1);
      } else {
        editTarget.innerHTML = "B<br>C<br>";
        selection.collapse(editTarget.querySelector("br").nextSibling, 1);
      }
      synthesizeKey("KEY_Enter", {}, aWindow);
      if (!isEditTargetIsDescendantOfEditingHost) {
        let expectedValue = aTestData.cancelBeforeInput
                              ? "<div>B</div><div>C<br></div>"
                              : "<div>B</div><div>C</div><div><br></div>";
        is(editTarget.innerHTML, expectedValue,
          `${aDescription}innerHTML should be "${expectedValue}" after ${aTestData.action}`);
      } else {
        let expectedValue = aTestData.cancelBeforeInput
                              ? "B<br>C<br>"
                              : "B<br>C<br><br>";
        is(editTarget.innerHTML, expectedValue,
          `${aDescription}innerHTML should be "${expectedValue}" after ${aTestData.action}`);
      }
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${action} should be cancelable`);
      is(beforeInputEvent.inputType, "insertParagraph",
        `${aDescription}inputType of "beforeinput" event for ${action} should be "insertParagraph"`);
      is(beforeInputEvent.data, null,
        `${aDescription}data of "beforeinput" event for ${action} should be null`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
      checkTargetRanges(beforeInputEvent, selectionRanges);
      if (aTestData.cancelBeforeInput) {
        ok(!inputEvent,
          `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
        return;
      }
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${action}`);
      is(inputEvent.inputType, "insertParagraph",
        `${aDescription}inputType of "input" event for ${action} should be "insertParagraph"`);
      is(inputEvent.data, null,
        `${aDescription}data of "input" event for ${action} should be null`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${action} should be null`);
      checkTargetRanges(inputEvent, []);
    }
    test_typing_enter_in_non_empty_last_line({
      action: 'typing "Enter" at end of non-empty line and canceling "beforeinput"',
      cancelBeforeInput: true,
    });
    test_typing_enter_in_non_empty_last_line({
      action: 'typing "Enter" at end of non-empty line',
      cancelBeforeInput: false,
    });

    (function test_setting_innerHTML() {
      reset();
      editTarget.innerHTML = "foo-bar";
      ok(!beforeInputEvent,
        `${aDescription}"beforeinput" event should not be fired when setting value`);
      ok(!inputEvent,
        `${aDescription}"input" event should not be fired when setting value`);
    })();

    (function test_setting_innerHTML_to_empty() {
      reset();
      editTarget.innerHTML = "";
      ok(!beforeInputEvent,
        `${aDescription}"beforeinput" event should not be fired when setting empty value`);
      ok(!inputEvent,
        `${aDescription}"input" event should not be fired when setting empty value`);
    })();

    function test_typing_white_space_in_empty_editor(aTestData) {
      reset();
      editTarget.innerHTML = "";
      cancelBeforeInput = aTestData.cancelBeforeInput;
      action = aTestData.action;
      synthesizeKey(" ", {}, aWindow);
      let expectedValue = aTestData.cancelBeforeInput ? "" : "&nbsp;";
      is(editTarget.innerHTML, expectedValue,
        `${aDescription}innerHTML should be "${expectedValue}" after ${aTestData.action}`);
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${aTestData.action}`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${aTestData.action} should be cancelable`);
      is(beforeInputEvent.inputType, "insertText",
        `${aDescription}inputType of "beforeinput" event for ${aTestData.action} should be "insertText"`);
      is(beforeInputEvent.data, " ",
        `${aDescription}data of "beforeinput" event for ${aTestData.action} should be " "`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${aTestData.action} should be null`);
      checkTargetRanges(beforeInputEvent, selectionRanges);
      if (aTestData.cancelBeforeInput) {
        ok(!inputEvent,
          `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
        return;
      }
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${aTestData.action}`);
      is(inputEvent.inputType, "insertText",
        `${aDescription}inputType of "input" event for ${aTestData.action} should be "insertText"`);
      is(inputEvent.data, " ",
        `${aDescription}data of "input" event for ${aTestData.action} should be " "`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${aTestData.action} should be null`);
      checkTargetRanges(inputEvent, []);
    }
    test_typing_white_space_in_empty_editor({
      action: 'typing space in empty editor and canceling "beforeinput"',
      cancelBeforeInput: true,
    });
    test_typing_white_space_in_empty_editor({
      action: "typing space in empty editor",
      cancelBeforeInput: false,
    });

    (function test_typing_delete_at_end_of_editor() {
      reset();
      action = 'typing "Delete" at end';
      synthesizeKey("KEY_Delete", {}, aWindow);
      is(editTarget.innerHTML, "&nbsp;",
        `${aDescription}shouldn't modify the editor by ${action} since there is no content to remove`);
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should be fired at ${action} even if it won't remove any content`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${action} should be cancelable`);
      is(beforeInputEvent.inputType, "deleteContentForward",
        `${aDescription}inputType of "beforeinput" event for ${action} should be "deleteContentForward"`);
      is(beforeInputEvent.data, null,
        `${aDescription}data of "beforeinput" event for ${action} should be null`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
      checkTargetRanges(beforeInputEvent, selectionRanges);
      ok(!inputEvent,
        `${aDescription}${action} should not fire "input" event since no content has been removed`);
    })();

    (function test_typing_arrow_left_to_move_caret() {
      reset();
      action = 'typing "ArrowLeft"';
      synthesizeKey("KEY_ArrowLeft", {}, aWindow);
      ok(!beforeInputEvent,
        `${aDescription}${action} should not fire "beforeinput" event since no content has been modified`);
      ok(!inputEvent,
        `${aDescription}${action} should not fire "input" event since no content has been modified`);
    })();

    function test_typing_delete_to_delete_last_character(aTestData) {
      reset();
      cancelBeforeInput = aTestData.cancelBeforeInput;
      action = aTestData.action;
      editTarget.innerHTML = "\u00A0";
      selection.collapse(editTarget.firstChild, 0);
      synthesizeKey("KEY_Delete", {}, aWindow);
      let expectedValue = aTestData.cancelBeforeInput ? "&nbsp;" : "<br>";
      is(editTarget.innerHTML, expectedValue,
        `${aDescription}innerHTML should be "${expectedValue}" after ${aTestData.action}`);
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${aTestData.action}`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${aTestData.action} should be cancelable`);
      is(beforeInputEvent.inputType, "deleteContentForward",
        `${aDescription}inputType of "beforeinput" event for ${aTestData.action} should be "deleteContentForward"`);
      is(beforeInputEvent.data, null,
        `${aDescription}data of "beforeinput" event for ${aTestData.action} should be null`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${aTestData.action} should be null`);
      checkTargetRanges(beforeInputEvent, [{startContainer: selectionRanges[0].startContainer,
                                            startOffset: selectionRanges[0].startOffset,
                                            endContainer: selectionRanges[0].startContainer,
                                            endOffset: selectionRanges[0].startOffset + 1}]);
      if (aTestData.cancelBeforeInput) {
        ok(!inputEvent,
          `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
        return;
      }
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${aTestData.action}`);
      is(inputEvent.inputType, "deleteContentForward",
        `${aDescription}inputType of "input" event for ${aTestData.action} should be "deleteContentForward"`);
      is(inputEvent.data, null,
        `${aDescription}data of "input" event for ${aTestData.action} should be null`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${aTestData.action} should be null`);
      checkTargetRanges(inputEvent, []);
    }
    test_typing_delete_to_delete_last_character({
      action: 'typing "Delete" to delete last character (NBSP) and canceling "beforeinput"',
      cancelBeforeInput: true,
    });
    test_typing_delete_to_delete_last_character({
      action: 'typing "Delete" to delete last character (NBSP)',
      cancelBeforeInput: false,
    });

    function test_undoing_deleting_last_character(aTestData) {
      reset();
      initializing = true;
      editTarget.innerHTML = "\u00A0";
      selection.collapse(editTarget.firstChild, 0);
      synthesizeKey("KEY_Delete", {}, aWindow);
      initializing = false;

      cancelBeforeInput = aTestData.cancelBeforeInput;
      action = aTestData.action;
      synthesizeKey("z", {accelKey: true}, aWindow);
      let expectedValue = aTestData.cancelBeforeInput ? "<br>" : "&nbsp;";
      is(editTarget.innerHTML, expectedValue,
        `${aDescription}innerHTML should be "${expectedValue}" after ${aTestData.action}`);
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${aTestData.action}`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${aTestData.action} should be cancelable`);
      is(beforeInputEvent.inputType, "historyUndo",
        `${aDescription}inputType of "beforeinput" event for ${aTestData.action} should be "historyUndo"`);
      is(beforeInputEvent.data, null,
        `${aDescription}data of "beforeinput" event for ${aTestData.action} should be null`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${aTestData.action} should be null`);
      checkTargetRanges(beforeInputEvent, []);
      if (aTestData.cancelBeforeInput) {
        ok(!inputEvent,
          `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
        return;
      }
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${aTestData.action}`);
      is(inputEvent.inputType, "historyUndo",
        `${aDescription}inputType of "input" event for ${aTestData.action} should be "historyUndo"`);
      is(inputEvent.data, null,
        `${aDescription}data of "input" event for ${aTestData.action} should be null`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${aTestData.action} should be null`);
      checkTargetRanges(inputEvent, []);
    }
    test_undoing_deleting_last_character({
      action: 'undoing deleting last character and canceling "beforeinput"',
      cancelBeforeInput: true,
    });
    test_undoing_deleting_last_character({
      action: 'undoing deleting last character',
      cancelBeforeInput: false,
    });

    (function test_undoing_without_undoable_transaction() {
      reset();
      initializing = true;
      htmlEditor.enableUndo(false);
      htmlEditor.enableUndo(true);
      editTarget.innerHTML = "\u00A0";
      selection.collapse(editTarget.firstChild, 0);
      synthesizeKey("KEY_Delete", {}, aWindow);
      synthesizeKey("z", {accelKey: true}, aWindow);
      initializing = false;

      action = 'doing "Undo" again';
      synthesizeKey("z", {accelKey: true}, aWindow);
      is(editTarget.innerHTML, "&nbsp;",
        `${aDescription}the editor shouldn't have been modified by ${action} since there is no undo transaction`);
      ok(!beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${action} since there is no undo transaction`);
      ok(!inputEvent,
        `${aDescription}"input" event shouldn't have been fired at ${action} since there is no undo transaction`);
    })();

    function test_redoing_deleting_last_character(aTestData) {
      reset();
      initializing = true;
      htmlEditor.enableUndo(false);
      htmlEditor.enableUndo(true);
      editTarget.innerHTML = "\u00A0";
      selection.collapse(editTarget.firstChild, 0);
      synthesizeKey("KEY_Delete", {}, aWindow);
      synthesizeKey("z", {accelKey: true}, aWindow);
      initializing = false;

      cancelBeforeInput = aTestData.cancelBeforeInput;
      action = aTestData.action;
      synthesizeKey("z", {accelKey: true, shiftKey: true}, aWindow);
      let expectedValue = aTestData.cancelBeforeInput ? "&nbsp;" : "<br>";
      is(editTarget.innerHTML, expectedValue,
        `${aDescription}innerHTML should be "${expectedValue}" after ${aTestData.action}`);
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${aTestData.action}`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${aTestData.action} should be cancelable`);
      is(beforeInputEvent.inputType, "historyRedo",
        `${aDescription}inputType of "beforeinput" event for ${aTestData.action} should be "historyRedo"`);
      is(beforeInputEvent.data, null,
        `${aDescription}data of "beforeinput" event for ${aTestData.action} should be null`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${aTestData.action} should be null`);
      checkTargetRanges(beforeInputEvent, []);
      if (aTestData.cancelBeforeInput) {
        ok(!inputEvent,
          `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
        return;
      }
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${aTestData.action}`);
      is(inputEvent.inputType, "historyRedo",
        `${aDescription}inputType of "input" event for ${aTestData.action} should be "historyRedo"`);
      is(inputEvent.data, null,
        `${aDescription}data of "input" event for ${aTestData.action} should be null`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${aTestData.action} should be null`);
      checkTargetRanges(inputEvent, []);
    }
    test_redoing_deleting_last_character({
      action: 'redoing deleting last character and canceling "beforeinput"',
      cancelBeforeInput: true,
    });
    test_redoing_deleting_last_character({
      action: 'redoing deleting last character',
      cancelBeforeInput: false,
    });

    (function test_redoing_without_redoable_transaction() {
      reset();
      initializing = true;
      htmlEditor.enableUndo(false);
      htmlEditor.enableUndo(true);
      editTarget.innerHTML = "\u00A0";
      selection.collapse(editTarget.firstChild, 0);
      synthesizeKey("KEY_Delete", {}, aWindow);
      synthesizeKey("z", {accelKey: true}, aWindow);
      synthesizeKey("z", {accelKey: true, shiftKey: true}, aWindow);
      initializing = false;

      action = 'doing "Redo" again';
      synthesizeKey("z", {accelKey: true, shiftKey: true}, aWindow);
      is(editTarget.innerHTML, "<br>",
        `${aDescription}the editor shouldn't have been modified by ${action} since there is no redo transaction`);
      ok(!beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${action} since there is no redo transaction`);
      ok(!inputEvent,
        `${aDescription}"input" event shouldn't have been fired at ${action} since there is no redo transaction`);
    })();

    function test_inserting_linebreak(aTestData) {
      reset();
      cancelBeforeInput = aTestData.cancelBeforeInput;
      action = aTestData.action;
      editTarget.innerHTML = "<br>";
      selection.collapse(editTarget, 0);
      synthesizeKey("KEY_Enter", {shiftKey: true}, aWindow);
      let expectedValue = aTestData.cancelBeforeInput ? "<br>" : "<br><br>";
      is(editTarget.innerHTML, expectedValue,
        `${aDescription}innerHTML should be "${expectedValue}" after ${aTestData.action}`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${aTestData.action} should be cancelable`);
      is(beforeInputEvent.inputType, "insertLineBreak",
        `${aDescription}inputType of "beforeinput" event for ${aTestData.action} should be "insertLineBreak"`);
      is(beforeInputEvent.data, null,
        `${aDescription}data of "beforeinput" event for ${aTestData.action} should be null`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${aTestData.action} should be null`);
      checkTargetRanges(beforeInputEvent, selectionRanges);
      if (aTestData.cancelBeforeInput) {
        ok(!inputEvent,
          `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
        return;
      }
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${aTestData.action}`);
      is(inputEvent.inputType, "insertLineBreak",
        `${aDescription}inputType of "input" event for ${aTestData.action} should be "insertLineBreak"`);
      is(inputEvent.data, null,
        `${aDescription}data of "input" event for ${aTestData.action} should be null`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${aTestData.action} should be null`);
      checkTargetRanges(inputEvent, []);
    }
    test_inserting_linebreak({
      action: 'inserting a linebreak and canceling "beforeinput"',
      cancelBeforeInput: true,
    });
    test_inserting_linebreak({
      action: "inserting a linebreak",
      cancelBeforeInput: false,
    });

    function test_typing_backspace_to_delete_selected_characters(aTestData) {
      editTarget.innerHTML = "a";
      editTarget.focus();
      selection.selectAllChildren(editTarget);
      reset();
      cancelBeforeInput = aTestData.cancelBeforeInput;
      action = aTestData.action;
      let expectedTargetRanges = [{
        startContainer: editTarget.firstChild,
        startOffset: 0,
        endContainer: editTarget.firstChild,
        endOffset: editTarget.firstChild.length,
      }];
      synthesizeKey("KEY_Backspace", {}, aWindow);
      let expectedValue = aTestData.cancelBeforeInput ? "a" : "<br>";
      is(editTarget.innerHTML, expectedValue,
        `${aDescription}innerHTML should be "${expectedValue}" after ${aTestData.action}`);
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${aTestData.action}`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${aTestData.action} should be cancelable`);
      is(beforeInputEvent.inputType, "deleteContentBackward",
        `${aDescription}inputType of "beforeinput" event for ${aTestData.action} should be "deleteContentBackward"`);
      is(beforeInputEvent.data, null,
        `${aDescription}data of "beforeinput" event for ${aTestData.action} should be null`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${aTestData.action} should be null`);
      checkTargetRanges(beforeInputEvent, expectedTargetRanges);
      if (aTestData.cancelBeforeInput) {
        ok(!inputEvent,
          `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
        return;
      }
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${aTestData.action}`);
      is(inputEvent.inputType, "deleteContentBackward",
        `${aDescription}inputType of "input" event for ${aTestData.action} should be "deleteContentBackward"`);
      is(inputEvent.data, null,
        `${aDescription}data of "input" event for ${aTestData.action} should be null`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${aTestData.action} should be null`);
      checkTargetRanges(inputEvent, []);
    }
    test_typing_backspace_to_delete_selected_characters({
      action: 'typing "Backspace" to delete selected characters and canceling "beforeinput"',
      cancelBeforeInput: true,
    });
    test_typing_backspace_to_delete_selected_characters({
      action: 'typing "Backspace" to delete selected characters',
      cancelBeforeInput: false,
    });

    function test_typing_delete_to_delete_selected_characters(aTestData) {
      editTarget.innerHTML = "a";
      editTarget.focus();
      selection.selectAllChildren(editTarget);
      reset();
      cancelBeforeInput = aTestData.cancelBeforeInput;
      action = aTestData.action;
      let expectedTargetRanges = [{
        startContainer: editTarget.firstChild,
        startOffset: 0,
        endContainer: editTarget.firstChild,
        endOffset: editTarget.firstChild.length,
      }];
      synthesizeKey("KEY_Delete", {}, aWindow);
      let expectedValue = aTestData.cancelBeforeInput ? "a" : "<br>";
      is(editTarget.innerHTML, expectedValue,
        `${aDescription}innerHTML should be "${expectedValue}" after ${aTestData.action}`);
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${aTestData.action}`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${aTestData.action} should be cancelable`);
      is(beforeInputEvent.inputType, "deleteContentForward",
        `${aDescription}inputType of "beforeinput" event for ${aTestData.action} should be "deleteContentForward"`);
      is(beforeInputEvent.data, null,
        `${aDescription}data of "beforeinput" event for ${aTestData.action} should be null`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${aTestData.action} should be null`);
      checkTargetRanges(beforeInputEvent, expectedTargetRanges);
      if (aTestData.cancelBeforeInput) {
        ok(!inputEvent,
          `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
        return;
      }
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${aTestData.action}`);
      is(inputEvent.inputType, "deleteContentForward",
        `${aDescription}inputType of "input" event for ${aTestData.action} should be "deleteContentForward"`);
      is(inputEvent.data, null,
        `${aDescription}data of "input" event for ${aTestData.action} should be null`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${aTestData.action} should be null`);
      checkTargetRanges(inputEvent, []);
    }
    test_typing_delete_to_delete_selected_characters({
      action: 'typing "Delete" to delete selected characters and canceling "beforeinput"',
      cancelBeforeInput: true,
    });
    test_typing_delete_to_delete_selected_characters({
      action: 'typing "Delete" to delete selected characters',
      cancelBeforeInput: false,
    });

    function test_deleting_word_backward_from_its_end(aTestData) {
      editTarget.innerHTML = "abc def";
      editTarget.focus();
      selection.collapse(editTarget.firstChild, "abc def".length);
      reset();
      cancelBeforeInput = aTestData.cancelBeforeInput;
      action = aTestData.action;
      SpecialPowers.doCommand(aWindow, "cmd_deleteWordBackward");
      let expectedValue = aTestData.cancelBeforeInput ? "abc def" : "abc ";
      is(editTarget.innerHTML, expectedValue,
        `${aDescription}innerHTML should be "${expectedValue}" after ${aTestData.action}`);
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${aTestData.action}`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${aTestData.action} should be cancelable`);
      is(beforeInputEvent.inputType, "deleteWordBackward",
        `${aDescription}inputType of "beforeinput" event for ${aTestData.action} should be "deleteWordBackward"`);
      is(beforeInputEvent.data, null,
        `${aDescription}data of "beforeinput" event for ${aTestData.action} should be null`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${aTestData.action} should be null`);
      checkTargetRanges(beforeInputEvent, [{startContainer: selectionRanges[0].endContainer,
                                            startOffset: selectionRanges[0].endOffset - "def".length,
                                            endContainer: selectionRanges[0].endContainer,
                                            endOffset: selectionRanges[0].endOffset}]);
      if (aTestData.cancelBeforeInput) {
        ok(!inputEvent,
          `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
        return;
      }
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${aTestData.action}`);
      is(inputEvent.inputType, "deleteWordBackward",
        `${aDescription}inputType of "input" event for ${aTestData.action} should be "deleteWordBackward"`);
      is(inputEvent.data, null,
        `${aDescription}data of "input" event for ${aTestData.action} should be null`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${aTestData.action} should be null`);
      checkTargetRanges(inputEvent, []);
    }
    test_deleting_word_backward_from_its_end({
      action: 'deleting word backward from its end and canceling "beforeinput"',
      cancelBeforeInput: true,
    });
    test_deleting_word_backward_from_its_end({
      action: "deleting word backward from its end",
      cancelBeforeInput: false,
    });

    function test_deleting_word_forward_from_its_start(aTestData) {
      editTarget.innerHTML = "abc def";
      editTarget.focus();
      selection.collapse(editTarget.firstChild, 0);
      reset();
      cancelBeforeInput = aTestData.cancelBeforeInput;
      action = aTestData.action;
      SpecialPowers.doCommand(aWindow, "cmd_deleteWordForward");
      if (aTestData.cancelBeforeInput) {
        is(editTarget.innerHTML, "abc def",
          `${aDescription}innerHTML should be "abc def" after ${aTestData.action}`);
      } else {
        let expectedValue = kWordSelectEatSpaceToNextWord ? "def" : " def";
        is(editTarget.innerHTML, expectedValue,
          `${aDescription}innerHTML should be "${expectedValue}" after ${aTestData.action}`);
      }
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${aTestData.action}`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${aTestData.action} should be cancelable`);
      is(beforeInputEvent.inputType, "deleteWordForward",
        `${aDescription}inputType of "beforeinput" event for ${aTestData.action} should be "deleteWordForward"`);
      is(beforeInputEvent.data, null,
        `${aDescription}data of "beforeinput" event for ${aTestData.action} should be null`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${aTestData.action} should be null`);
      checkTargetRanges(beforeInputEvent, [{startContainer: selectionRanges[0].startContainer,
                                            startOffset: selectionRanges[0].startOffset,
                                            endContainer: selectionRanges[0].startContainer,
                                            endOffset: selectionRanges[0].startOffset +
                                                (kWordSelectEatSpaceToNextWord ? "abc ".length : "abc".length)}]);
      if (aTestData.cancelBeforeInput) {
        ok(!inputEvent,
          `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
        return;
      }
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${aTestData.action}`);
      is(inputEvent.inputType, "deleteWordForward",
        `${aDescription}inputType of "input" event for ${aTestData.action} should be "deleteWordForward"`);
      is(inputEvent.data, null,
        `${aDescription}data of "input" event for ${aTestData.action} should be null`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${aTestData.action} should be null`);
      checkTargetRanges(inputEvent, []);
    }
    test_deleting_word_forward_from_its_start({
      action: 'deleting word forward from its start and canceling "beforeinput"',
      cancelBeforeInput: true,
    });
    test_deleting_word_forward_from_its_start({
      action: "deleting word forward from its start",
      cancelBeforeInput: false,
    });

    (function test_deleting_word_backward_from_middle_of_second_word() {
      editTarget.innerHTML = "abc def";
      editTarget.focus();
      selection.setBaseAndExtent(editTarget.firstChild, "abc d".length, editTarget.firstChild, "abc de".length);
      reset();
      cancelBeforeInput = false;
      action = "removing characters backward from middle of second word";
      SpecialPowers.doCommand(aWindow, "cmd_deleteWordBackward");
      // Only on Windows, we collapse selection to start before handling this command.
      let expectedInputType = kIsWin ? "deleteWordBackward" : "deleteContentBackward";
      is(editTarget.innerHTML, kIsWin ? "abc ef" : "abc df",
        `${aDescription}${kIsWin ? "characters between current word start and selection start" : "selected characters"} should've been removed by ${action}`);
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${action}`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${action} should be cancelable`);
      is(beforeInputEvent.inputType, expectedInputType,
        `${aDescription}inputType of "beforeinput" event for ${action} should be "${expectedInputType}"`);
      is(beforeInputEvent.data, null,
        `${aDescription}data of "beforeinput" event for ${action} should be null`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
      if (kIsWin) {
        checkTargetRanges(beforeInputEvent, [{startContainer: selectionRanges[0].endContainer,
                                              startOffset: "abc ".length,
                                              endContainer: selectionRanges[0].endContainer,
                                              endOffset: selectionRanges[0].endOffset}]);
      } else {
        checkTargetRanges(beforeInputEvent, selectionRanges);
      }
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${action}`);
      is(inputEvent.inputType, expectedInputType,
        `${aDescription}inputType of "input" event for ${action} should be "${expectedInputType}"`);
      is(inputEvent.data, null,
        `${aDescription}data of "input" event for ${action} should be null`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${action} should be null`);
      checkTargetRanges(inputEvent, []);
    })();

    (function test_deleting_word_forward_from_middle_of_first_word() {
      editTarget.innerHTML = "abc def";
      editTarget.focus();
      selection.setBaseAndExtent(editTarget.firstChild, "a".length, editTarget.firstChild, "ab".length);
      reset();
      cancelBeforeInput = false;
      action = "removing characters forward from middle of first word";
      SpecialPowers.doCommand(aWindow, "cmd_deleteWordForward");
      // Only on Windows, we collapse selection to start before handling this command.
      let expectedInputType = kIsWin ? "deleteWordForward" : "deleteContentForward";
      let expectedValue = "ac def";
      if (kIsWin) {
        expectedValue = kWordSelectEatSpaceToNextWord ? "adef" : "a def";
      }
      is(editTarget.innerHTML, expectedValue,
        `${aDescription}${kIsWin ? "characters between selection start and next word start" : "selected characters"} should've been removed by ${action}`);
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${action}`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${action} should be cancelable`);
      is(beforeInputEvent.inputType, expectedInputType,
        `${aDescription}inputType of "beforeinput" event for ${action} should be "${expectedInputType}"`);
      is(beforeInputEvent.data, null,
        `${aDescription}data of "beforeinput" event for ${action} should be null`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
      if (kIsWin) {
        checkTargetRanges(beforeInputEvent, [{startContainer: selectionRanges[0].startContainer,
                                              startOffset: selectionRanges[0].startOffset,
                                              endContainer: selectionRanges[0].endContainer,
                                              endOffset: kWordSelectEatSpaceToNextWord ? "abc ".length : "abc".length}]);
      } else {
        checkTargetRanges(beforeInputEvent, selectionRanges);
      }
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${action}`);
      is(inputEvent.inputType, expectedInputType,
        `${aDescription}inputType of "input" event for ${action} should be "${expectedInputType}"`);
      is(inputEvent.data, null,
        `${aDescription}data of "input" event for ${action} should be null`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${action} should be null`);
      checkTargetRanges(inputEvent, []);
    })();

    (function test_deleting_characters_backward_to_start_of_line() {
      editTarget.innerHTML = "abc def";
      editTarget.focus();
      selection.collapse(editTarget.firstChild, "abc d".length);
      reset();
      cancelBeforeInput = false;
      action = "removing characters backward to start of line";
      SpecialPowers.doCommand(aWindow, "cmd_deleteToBeginningOfLine");
      is(editTarget.innerHTML, "ef",
        `${aDescription}characters between start of line and caret should've been removed by ${action}`);
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${action}`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${action} should be cancelable`);
      is(beforeInputEvent.inputType, "deleteSoftLineBackward",
        `${aDescription}inputType of "beforeinput" event for ${action} should be "deleteSoftLineBackward"`);
      is(beforeInputEvent.data, null,
        `${aDescription}data of "beforeinput" event for ${action} should be null`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
      checkTargetRanges(beforeInputEvent, [{startContainer: selectionRanges[0].endContainer,
                                            startOffset: 0,
                                            endContainer: selectionRanges[0].endContainer,
                                            endOffset: selectionRanges[0].endOffset}]);
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${action}`);
      is(inputEvent.inputType, "deleteSoftLineBackward",
        `${aDescription}inputType of "input" event for ${action} should be "deleteSoftLineBackward"`);
      is(inputEvent.data, null,
        `${aDescription}data of "input" event for ${action} should be null`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${action} should be null`);
      checkTargetRanges(inputEvent, []);
    })();

    (function test_deleting_characters_forward_to_end_of_line() {
      editTarget.innerHTML = "abc def";
      editTarget.focus();
      selection.collapse(editTarget.firstChild, "ab".length);
      reset();
      cancelBeforeInput = false;
      action = "removing characters forward to end of line";
      SpecialPowers.doCommand(aWindow, "cmd_deleteToEndOfLine");
      is(editTarget.innerHTML, "ab",
        `${aDescription}characters between caret and end of line should've been removed by ${action}`);
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${action}`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${action} should be cancelable`);
      is(beforeInputEvent.inputType, "deleteSoftLineForward",
        `${aDescription}inputType of "beforeinput" event for ${action} should be "deleteSoftLineForward"`);
      is(beforeInputEvent.data, null,
        `${aDescription}data of "beforeinput" event for ${action} should be null`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
      checkTargetRanges(beforeInputEvent, [{startContainer: selectionRanges[0].startContainer,
                                            startOffset: selectionRanges[0].startOffset,
                                            endContainer: selectionRanges[0].startContainer,
                                            endOffset: "abc def".length}]);
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${action}`);
      is(inputEvent.inputType, "deleteSoftLineForward",
        `${aDescription}inputType of "input" event for ${action} should be "deleteSoftLineForward"`);
      is(inputEvent.data, null,
        `${aDescription}data of "input" event for ${action} should be null`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${action} should be null`);
      checkTargetRanges(inputEvent, []);
    })();

    (function test_deleting_characters_backward_to_start_of_line_with_non_collapsed_selection() {
      editTarget.innerHTML = "abc def";
      editTarget.focus();
      selection.setBaseAndExtent(editTarget.firstChild, "abc d".length, editTarget.firstChild, "abc_de".length);
      reset();
      cancelBeforeInput = false;
      action = "removing characters backward to start of line (with selection in second word)";
      SpecialPowers.doCommand(aWindow, "cmd_deleteToBeginningOfLine");
      // Only on Windows, we collapse selection to start before handling this command.
      let expectedInputType = kIsWin ? "deleteSoftLineBackward" : "deleteContentBackward";
      is(editTarget.innerHTML, kIsWin ? "ef" : "abc df",
        `${aDescription}${kIsWin ? "characters between start of line and caret" : "selected characters"} should've been removed by ${action}`);
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${action}`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${action} should be cancelable`);
      is(beforeInputEvent.inputType, expectedInputType,
        `${aDescription}inputType of "beforeinput" event for ${action} should be "${expectedInputType}"`);
      is(beforeInputEvent.data, null,
        `${aDescription}data of "beforeinput" event for ${action} should be null`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
      if (kIsWin) {
        checkTargetRanges(beforeInputEvent, [{startContainer: selectionRanges[0].endContainer,
                                              startOffset: 0,
                                              endContainer: selectionRanges[0].endContainer,
                                              endOffset: selectionRanges[0].endOffset}]);
      } else {
        checkTargetRanges(beforeInputEvent, selectionRanges);
      }
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${action}`);
      is(inputEvent.inputType, expectedInputType,
        `${aDescription}inputType of "input" event for ${action} should be "${expectedInputType}"`);
      is(inputEvent.data, null,
        `${aDescription}data of "input" event for ${action} should be null`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${action} should be null`);
      checkTargetRanges(inputEvent, []);
    })();

    (function test_deleting_characters_forward_to_end_of_line_with_non_collapsed_selection() {
      editTarget.innerHTML = "abc def";
      editTarget.focus();
      selection.setBaseAndExtent(editTarget.firstChild, "a".length, editTarget.firstChild, "ab".length);
      reset();
      cancelBeforeInput = false;
      action = "removing characters forward to end of line (with selection in second word)";
      SpecialPowers.doCommand(aWindow, "cmd_deleteToEndOfLine");
      // Only on Windows, we collapse selection to start before handling this command.
      let expectedInputType = kIsWin ? "deleteSoftLineForward" : "deleteContentForward";
      is(editTarget.innerHTML, kIsWin ? "a" : "ac def",
        `${aDescription}${kIsWin ? "characters between caret anc end of line" : "selected characters"} should've been removed by ${action}`);
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${action}`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${action} should be cancelable`);
      is(beforeInputEvent.inputType, expectedInputType,
        `${aDescription}inputType of "beforeinput" event for ${action} should be "${expectedInputType}"`);
      is(beforeInputEvent.data, null,
        `${aDescription}data of "beforeinput" event for ${action} should be null`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
      if (kIsWin) {
        checkTargetRanges(beforeInputEvent, [{startContainer: selectionRanges[0].startContainer,
                                              startOffset: selectionRanges[0].startOffset,
                                              endContainer: selectionRanges[0].endContainer,
                                              endOffset: "abc def".length}]);
      } else {
        checkTargetRanges(beforeInputEvent, selectionRanges);
      }
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${action}`);
      is(inputEvent.inputType, expectedInputType,
        `${aDescription}inputType of "input" event for ${action} should be "${expectedInputType}"`);
      is(inputEvent.data, null,
        `${aDescription}data of "input" event for ${action} should be null`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${action} should be null`);
      checkTargetRanges(inputEvent, []);
    })();

    function test_switching_text_direction_from_default(aTestData) {
      try {
        body.removeAttribute("dir");
        htmlEditor.flags &= ~SpecialPowers.Ci.nsIEditor.eEditorRightToLeft;
        htmlEditor.flags |= SpecialPowers.Ci.nsIEditor.eEditorLeftToRight; // XXX flags update is required, must be a bug.
        aDocument.documentElement.scrollTop; // XXX Update the body frame
        editTarget.focus();
        reset();
        cancelBeforeInput = aTestData.cancelBeforeInput;
        action = aTestData.action;
        SpecialPowers.doCommand(aWindow, "cmd_switchTextDirection");
        // XXX If editing host is a descendant of `<body>`, this must be a bug.
        if (aTestData.cancelBeforeInput) {
          is(body.getAttribute("dir"), null,
            `${aDescription}dir attribute of the element shouldn't have been set by ${aTestData.action}`);
        } else {
          is(body.getAttribute("dir"), "rtl",
            `${aDescription}dir attribute of the element should've been set to "rtl" by ${aTestData.action}`);
        }
        ok(beforeInputEvent,
          `${aDescription}"beforeinput" event should've been fired at ${aTestData.action}`);
        is(beforeInputEvent.cancelable, true,
          `${aDescription}"beforeinput" event for ${aTestData.action} should be cancelable`);
        is(beforeInputEvent.inputType, "formatSetBlockTextDirection",
          `${aDescription}inputType of "beforeinput" event for ${aTestData.action} should be "formatSetBlockTextDirection"`);
        is(beforeInputEvent.data, "rtl",
          `${aDescription}data of "beforeinput" event for ${aTestData.action} should be "rtl"`);
        is(beforeInputEvent.dataTransfer, null,
          `${aDescription}dataTransfer of "beforeinput" event for ${aTestData.action} should be null`);
        checkTargetRanges(beforeInputEvent, []);
        if (aTestData.cancelBeforeInput) {
          ok(!inputEvent,
            `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
          return;
        }
        ok(inputEvent,
          `${aDescription}"input" event should've been fired at ${aTestData.action}`);
        is(inputEvent.inputType, "formatSetBlockTextDirection",
          `${aDescription}inputType of "input" event for ${aTestData.action} should be "formatSetBlockTextDirection"`);
        is(inputEvent.data, "rtl",
          `${aDescription}data of "input" event for ${aTestData.action} should be "rtl"`);
        is(inputEvent.dataTransfer, null,
          `${aDescription}dataTransfer of "input" event for ${aTestData.action} should be null`);
        checkTargetRanges(inputEvent, []);
      } finally {
        body.removeAttribute("dir");
        htmlEditor.flags &= ~SpecialPowers.Ci.nsIEditor.eEditorRightToLeft;
        htmlEditor.flags |= SpecialPowers.Ci.nsIEditor.eEditorLeftToRight; // XXX flags update is required, must be a bug.
        aDocument.documentElement.scrollTop; // XXX Update the body frame
      }
    }
    test_switching_text_direction_from_default({
      action: 'switching text direction from default to "rtl" and canceling "beforeinput"',
      cancelBeforeInput: true,
    });
    test_switching_text_direction_from_default({
      action: 'switching text direction from default to "rtl"',
      cancelBeforeInput: false,
    });

    function test_switching_text_direction_from_rtl_to_ltr(aTestData) {
      try {
        body.setAttribute("dir", "rtl");
        htmlEditor.flags &= ~SpecialPowers.Ci.nsIEditor.eEditorLeftToRight;
        htmlEditor.flags |= SpecialPowers.Ci.nsIEditor.eEditorRightToLeft; // XXX flags update is required, must be a bug.
        aDocument.documentElement.scrollTop; // XXX Update the body frame
        editTarget.focus();
        reset();
        cancelBeforeInput = aTestData.cancelBeforeInput;
        action = aTestData.action;
        SpecialPowers.doCommand(aWindow, "cmd_switchTextDirection");
        // XXX If editing host is a descendant of `<body>`, this must be a bug.
        let expectedDirValue = aTestData.cancelBeforeInput ? "rtl" : "ltr";
        is(body.getAttribute("dir"), expectedDirValue,
          `${aDescription}dir attribute of the element should be "${expectedDirValue}" after ${aTestData.action}`);
        ok(beforeInputEvent,
          `${aDescription}"beforeinput" event should've been fired at ${aTestData.action}`);
        is(beforeInputEvent.cancelable, true,
          `${aDescription}"beforeinput" event for ${aTestData.action} should be cancelable`);
        is(beforeInputEvent.inputType, "formatSetBlockTextDirection",
          `${aDescription}inputType of "beforeinput" event for ${aTestData.action} should be "formatSetBlockTextDirection"`);
        is(beforeInputEvent.data, "ltr",
          `${aDescription}data of "beforeinput" event for ${aTestData.action} should be "ltr"`);
        is(beforeInputEvent.dataTransfer, null,
          `${aDescription}dataTransfer of "beforeinput" event for ${aTestData.action} should be null`);
        checkTargetRanges(beforeInputEvent, []);
        if (aTestData.cancelBeforeInput) {
          ok(!inputEvent,
            `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
          return;
        }
        ok(inputEvent,
          `${aDescription}"input" event should've been fired at ${aTestData.action}`);
        is(inputEvent.inputType, "formatSetBlockTextDirection",
          `${aDescription}inputType of "input" event for ${aTestData.action} should be "formatSetBlockTextDirection"`);
        is(inputEvent.data, "ltr",
          `${aDescription}data of "input" event for ${aTestData.action} should be "ltr"`);
        is(inputEvent.dataTransfer, null,
          `${aDescription}dataTransfer of "input" event for ${aTestData.action} should be null`);
        checkTargetRanges(inputEvent, []);
      } finally {
        body.removeAttribute("dir");
        htmlEditor.flags &= ~SpecialPowers.Ci.nsIEditor.eEditorRightToLeft;
        htmlEditor.flags |= SpecialPowers.Ci.nsIEditor.eEditorLeftToRight; // XXX flags update is required, must be a bug.
        aDocument.documentElement.scrollTop; // XXX Update the body frame
      }
    }
    test_switching_text_direction_from_rtl_to_ltr({
      action: 'switching text direction from "rtl" to "ltr" and canceling "beforeinput"',
      cancelBeforeInput: true,
    });
    test_switching_text_direction_from_rtl_to_ltr({
      action: 'switching text direction from "rtl" to "ltr" and canceling "beforeinput"',
      cancelBeforeInput: false,
    });


    function test_inserting_link(aTestData) {
      editTarget.innerHTML = "link";
      editTarget.focus();
      selection.selectAllChildren(editTarget);
      reset();
      cancelBeforeInput = aTestData.cancelBeforeInput;
      action = aTestData.action;
      SpecialPowers.doCommand(aWindow, "cmd_insertLinkNoUI", "https://example.com/foo/bar.html");
      let expectedValue = aTestData.cancelBeforeInput ? "link" : '<a href="https://example.com/foo/bar.html">link</a>';
      is(editTarget.innerHTML, expectedValue,
        `${aDescription}innerHTML should be "${expectedValue}" after ${aTestData.action}`);
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${aTestData.action}`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${aTestData.action} should be cancelable`);
      is(beforeInputEvent.inputType, "insertLink",
        `${aDescription}inputType of "beforeinput" event for ${aTestData.action} should be "insertLink"`);
      is(beforeInputEvent.data, "https://example.com/foo/bar.html",
        `${aDescription}data of "beforeinput" event for ${aTestData.action} should be "https://example.com/foo/bar.html"`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${aTestData.action} should be null`);
      checkTargetRanges(beforeInputEvent, selectionRanges);
      if (aTestData.cancelBeforeInput) {
        ok(!inputEvent,
          `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
        return;
      }
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${aTestData.action}`);
      is(inputEvent.inputType, "insertLink",
        `${aDescription}inputType of "input" event for ${aTestData.action} should be "insertLink"`);
      is(inputEvent.data, "https://example.com/foo/bar.html",
        `${aDescription}data of "input" event for ${aTestData.action} should be "https://example.com/foo/bar.html"`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${aTestData.action} should be null`);
      checkTargetRanges(inputEvent, []);
    }
    test_inserting_link({
      action: 'setting link with absolute URL and canceling "beforeinput"',
      cancelBeforeInput: true,
    });
    test_inserting_link({
      action: "setting link with absolute URL",
      cancelBeforeInput: false,
    });

    (function test_inserting_link_with_relative_url() {
      editTarget.innerHTML = "link";
      selection.selectAllChildren(editTarget);
      reset();
      cancelBeforeInput = false;
      action = "setting link with relative URL";
      SpecialPowers.doCommand(aWindow, "cmd_insertLinkNoUI", "foo/bar.html");
      is(editTarget.innerHTML, '<a href="foo/bar.html">link</a>',
        `${aDescription}the text should've been wrapped by <a href> element by ${action}`);
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${action}`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${action} should be cancelable`);
      is(beforeInputEvent.inputType, "insertLink",
        `${aDescription}inputType of "beforeinput" event for ${action} should be "insertLink"`);
      is(beforeInputEvent.data, "foo/bar.html",
        `${aDescription}data of "beforeinput" event for ${action} should be "foo/bar.html"`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${action} should be null`);
      checkTargetRanges(beforeInputEvent, selectionRanges);
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${action}`);
      is(inputEvent.inputType, "insertLink",
        `${aDescription}inputType of "input" event for ${action} should be "insertLink"`);
      is(inputEvent.data, "foo/bar.html",
        `${aDescription}data of "input" event for ${action} should be "foo/bar.html"`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${action} should be null`);
      checkTargetRanges(inputEvent, []);
    })();

    (function test_format_commands() {
      for (let test of [{command: "cmd_bold",
                        tag: "b",
                        otherRemoveTags: ["strong"],
                        inputType: "formatBold"},
                        {command: "cmd_italic",
                        tag: "i",
                        otherRemoveTags: ["em"],
                        inputType: "formatItalic"},
                        {command: "cmd_underline",
                        tag: "u",
                        inputType: "formatUnderline"},
                        {command: "cmd_strikethrough",
                        tag: "strike",
                        otherRemoveTags: ["s"],
                        inputType: "formatStrikeThrough"},
                        {command: "cmd_subscript",
                        tag: "sub",
                        exclusiveTags: ["sup"],
                        inputType: "formatSubscript"},
                        {command: "cmd_superscript",
                        tag: "sup",
                        exclusiveTags: ["sub"],
                        inputType: "formatSuperscript"}]) {
        function test_formatting_text(aTestData) {
          editTarget.innerHTML = "format";
          editTarget.focus();
          selection.selectAllChildren(editTarget);
          reset();
          cancelBeforeInput = aTestData.cancelBeforeInput;
          action = aTestData.action;
          SpecialPowers.doCommand(aWindow, test.command);
          let expectedValue = aTestData.cancelBeforeInput
                                ? "format"
                                : `<${test.tag}>format</${test.tag}>`;
          is(editTarget.innerHTML, expectedValue,
            `${aDescription}innerHTML should be "${expectedValue}" after ${aTestData.action}`);
          ok(beforeInputEvent,
            `${aDescription}"beforeinput" event should've been fired at ${aTestData.action}`);
          is(beforeInputEvent.cancelable, true,
            `${aDescription}"beforeinput" event for ${aTestData.action} should be cancelable`);
          is(beforeInputEvent.inputType, test.inputType,
            `${aDescription}inputType of "beforeinput" event should be "${test.inputType}"`);
          is(beforeInputEvent.data, null,
            `${aDescription}data of "beforeinput" event for ${aTestData.action} should be null`);
          is(beforeInputEvent.dataTransfer, null,
            `${aDescription}dataTransfer of "beforeinput" event for ${aTestData.action} should be null`);
          checkTargetRanges(beforeInputEvent, selectionRanges);
          if (aTestData.cancelBeforeInput) {
            ok(!inputEvent,
              `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
            return;
          }
          ok(inputEvent,
            `${aDescription}"input" event should've been fired at ${aTestData.action}`);
          is(inputEvent.cancelable, false,
            `${aDescription}"input" event for ${aTestData.action} should never be cancelable`);
          is(inputEvent.inputType, test.inputType,
            `${aDescription}inputType of "input" event should be "${test.inputType}"`);
          is(inputEvent.data, null,
            `${aDescription}data of "input" event for ${aTestData.action} should be null`);
          is(inputEvent.dataTransfer, null,
            `${aDescription}dataTransfer of "input" event for ${aTestData.action} should be null`);
          checkTargetRanges(inputEvent, []);
        }
        test_formatting_text({
          action: `formatting with "${test.command}" and canceling "beforeinput"`,
          cancelBeforeInput: true,
        });
        test_formatting_text({
          action: `formatting with "${test.command}" and canceling "beforeinput"`,
          cancelBeforeInput: false,
        });

        function test_removing_format_text(aTestData) {
          editTarget.innerHTML = `<${test.tag}>format</${test.tag}>`;
          selection.selectAllChildren(editTarget);
          reset();
          cancelBeforeInput = aTestData.cancelBeforeInput;
          action = aTestData.action;
          SpecialPowers.doCommand(aWindow, test.command);
          let expectedValue = aTestData.cancelBeforeInput
                                ? `<${test.tag}>format</${test.tag}>`
                                : "format";
          is(editTarget.innerHTML, expectedValue,
            `${aDescription}innerHTML should be "${expectedValue}" after ${aTestData.action}`);
          ok(beforeInputEvent,
            `${aDescription}"beforeinput" event should've been fired at ${aTestData.action}`);
          is(beforeInputEvent.cancelable, true,
            `${aDescription}"beforeinput" event for ${aTestData.action} should be cancelable`);
          is(beforeInputEvent.inputType, test.inputType,
            `${aDescription}inputType of "beforeinput" event should be "${test.inputType}"`);
          is(beforeInputEvent.data, null,
            `${aDescription}data of "beforeinput" event for ${aTestData.action} should be null`);
          is(beforeInputEvent.dataTransfer, null,
            `${aDescription}dataTransfer of "beforeinput" event for ${aTestData.action} should be null`);
          checkTargetRanges(beforeInputEvent, selectionRanges);
          if (aTestData.cancelBeforeInput) {
            ok(!inputEvent,
              `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
            return;
          }
          ok(inputEvent,
            `${aDescription}"input" event should've been fired at ${aTestData.action}`);
          is(inputEvent.cancelable, false,
            `${aDescription}"input" event for ${aTestData.action} should never be cancelable`);
          is(inputEvent.inputType, test.inputType,
            `${aDescription}inputType of "input" event should be "${test.inputType}"`);
          is(inputEvent.data, null,
            `${aDescription}data of "input" event for ${aTestData.action} should be null`);
          is(inputEvent.dataTransfer, null,
            `${aDescription}dataTransfer of "input" event for ${aTestData.action} should be null`);
          checkTargetRanges(inputEvent, []);
        }
        test_removing_format_text({
          action: `removing format with "${test.command}" and canceling "beforeinput"`,
          cancelBeforeInput: true,
        });
        test_removing_format_text({
          action: `removing format with "${test.command}" and canceling "beforeinput"`,
          cancelBeforeInput: false,
        });

        (function test_removing_format_styled_by_others() {
          if (!test.otherRemoveTags) {
            return;
          }
          for (let anotherTag of test.otherRemoveTags) {
            function test_removing_format_styled_by_another_element(aTestData) {
              editTarget.innerHTML = `<${anotherTag}>format</${anotherTag}>`;
              editTarget.focus();
              selection.selectAllChildren(editTarget);
              reset();
              cancelBeforeInput = aTestData.cancelBeforeInput;
              action = aTestData.action;
              SpecialPowers.doCommand(aWindow, test.command);
              let expectedValue = aTestData.cancelBeforeInput
                                    ? `<${anotherTag}>format</${anotherTag}>`
                                    : "format";
              is(editTarget.innerHTML, expectedValue,
                `${aDescription}innerHTML should be "${expectedValue}" after ${aTestData.action}`);
              ok(beforeInputEvent,
                `${aDescription}"beforeinput" event should've been fired at ${aTestData.action}`);
              is(beforeInputEvent.cancelable, true,
                `${aDescription}"beforeinput" event for ${aTestData.action} should be cancelable`);
              is(beforeInputEvent.inputType, test.inputType,
                `${aDescription}inputType of "beforeinput" event should be "${test.inputType}"`);
              is(beforeInputEvent.data, null,
                `${aDescription}data of "beforeinput" event for ${aTestData.action} should be null`);
              is(beforeInputEvent.dataTransfer, null,
                `${aDescription}dataTransfer of "beforeinput" event for ${aTestData.action} should be null`);
              checkTargetRanges(beforeInputEvent, selectionRanges);
              if (aTestData.cancelBeforeInput) {
                ok(!inputEvent,
                  `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
                return;
              }
              ok(inputEvent,
                `${aDescription}"input" event shouldn't have been fired at ${aTestData.action}`);
              is(inputEvent.cancelable, false,
                `${aDescription}"input" event for ${aTestData.action} should never be cancelable`);
              is(inputEvent.inputType, test.inputType,
                `${aDescription}inputType of "input" event should be "${test.inputType}"`);
              is(inputEvent.data, null,
                `${aDescription}data of "input" event for ${aTestData.action} should be null`);
              is(inputEvent.dataTransfer, null,
                `${aDescription}dataTransfer of "input" event for ${aTestData.action} should be null`);
              checkTargetRanges(inputEvent, []);
            }
            test_removing_format_styled_by_another_element({
              action: `removing <${anotherTag}> element with "${test.command}" and canceling "beforeinput"`,
              cancelBeforeInput: true,
            });
            test_removing_format_styled_by_another_element({
              action: `removing <${anotherTag}> element with "${test.command}"`,
              cancelBeforeInput: false,
            });

            function test_removing_format_styled_by_both_primary_one_and_another_one(aTestData) {
              editTarget.innerHTML = `<${test.tag}><${anotherTag}>format</${anotherTag}></${test.tag}>`;
              editTarget.focus();
              selection.selectAllChildren(editTarget);
              reset();
              cancelBeforeInput = aTestData.cancelBeforeInput;
              action = aTestData.action;
              SpecialPowers.doCommand(aWindow, test.command);
              let expectedValue = aTestData.cancelBeforeInput
                                    ? `<${test.tag}><${anotherTag}>format</${anotherTag}></${test.tag}>`
                                    : "format";
              is(editTarget.innerHTML, expectedValue,
                `${aDescription}innerHTML should be "${expectedValue}" after ${aTestData.action}`);
              ok(beforeInputEvent,
                `${aDescription}"beforeinput" event should've been fired at ${aTestData.action}`);
              is(beforeInputEvent.cancelable, true,
                `${aDescription}"beforeinput" event for ${aTestData.action} should be cancelable`);
              is(beforeInputEvent.inputType, test.inputType,
                `${aDescription}inputType of "beforeinput" event should be "${test.inputType}"`);
              is(beforeInputEvent.data, null,
                `${aDescription}data of "beforeinput" event for ${aTestData.action} should be null`);
              is(beforeInputEvent.dataTransfer, null,
                `${aDescription}dataTransfer of "beforeinput" event for ${aTestData.action} should be null`);
              checkTargetRanges(beforeInputEvent, selectionRanges);
              if (aTestData.cancelBeforeInput) {
                ok(!inputEvent,
                  `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
                return;
              }
              ok(inputEvent,
                `${aDescription}"input" event shouldn't have been fired at ${aTestData.action}`);
              is(inputEvent.cancelable, false,
                `${aDescription}"input" event for ${aTestData.action} should never be cancelable`);
              is(inputEvent.inputType, test.inputType,
                `${aDescription}inputType of "input" event should be "${test.inputType}"`);
              is(inputEvent.data, null,
                `${aDescription}data of "input" event for ${aTestData.action} should be null`);
              is(inputEvent.dataTransfer, null,
                `${aDescription}dataTransfer of "input" event for ${aTestData.action} should be null`);
              checkTargetRanges(inputEvent, []);
            }
            test_removing_format_styled_by_both_primary_one_and_another_one({
              action: `removing both <${test.tag}> and <${anotherTag}> elements with "${test.command}" and canceling "beforeinput"`,
              cancelBeforeInput: true,
            });
            test_removing_format_styled_by_both_primary_one_and_another_one({
              action: `removing both <${test.tag}> and <${anotherTag}> elements with "${test.command}"`,
              cancelBeforeInput: false,
            });
          }
        })();
        (function test_formatting_text_styled_by_exclusive_elements() {
          if (!test.exclusiveTags) {
            return;
          }
          for (let exclusiveTag of test.exclusiveTags) {
            function test_formatting_text_styled_by_exclusive_element(aTestData) {
              editTarget.innerHTML = `<${exclusiveTag}>format</${exclusiveTag}>`;
              editTarget.focus();
              selection.selectAllChildren(editTarget);
              reset();
              cancelBeforeInput = aTestData.cancelBeforeInput;
              action = aTestData.action;
              SpecialPowers.doCommand(aWindow, test.command);
              let expectedValue = aTestData.cancelBeforeInput
                                    ? `<${exclusiveTag}>format</${exclusiveTag}>`
                                    : `<${test.tag}>format</${test.tag}>`;
              is(editTarget.innerHTML, expectedValue,
                `${aDescription}innerHTML should be "${expectedValue}" after ${aTestData.action}`);
              ok(beforeInputEvent,
                `${aDescription}"beforeinput" event should've been fired at ${aTestData.action}`);
              is(beforeInputEvent.cancelable, true,
                `${aDescription}"beforeinput" event for ${aTestData.action} should be cancelable`);
              is(beforeInputEvent.inputType, test.inputType,
                `${aDescription}inputType of "beforeinput" event should be "${test.inputType}"`);
              is(beforeInputEvent.data, null,
                `${aDescription}data of "beforeinput" event for ${aTestData.action} should be null`);
              is(beforeInputEvent.dataTransfer, null,
                `${aDescription}dataTransfer of "beforeinput" event for ${aTestData.action} should be null`);
              checkTargetRanges(beforeInputEvent, selectionRanges);
              if (aTestData.cancelBeforeInput) {
                ok(!inputEvent,
                  `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
                return;
              }
              ok(inputEvent,
                `${aDescription}"input" event shouldn't have been fired at ${aTestData.action}`);
              is(inputEvent.cancelable, false,
                `${aDescription}"input" event for ${aTestData.action} should never be cancelable`);
              is(inputEvent.inputType, test.inputType,
                `${aDescription}inputType of "input" event should be "${test.inputType}"`);
              is(inputEvent.data, null,
                `${aDescription}data of "input" event for ${aTestData.action} should be null`);
              is(inputEvent.dataTransfer, null,
                `${aDescription}dataTransfer of "input" event for ${aTestData.action} should be null`);
              checkTargetRanges(inputEvent, []);
            }
            test_formatting_text_styled_by_exclusive_element({
              action: `removing <${exclusiveTag}> element with formatting with "${test.command}" and canceling "beforeinput"`,
              cancelBeforeInput: true,
            });
            test_formatting_text_styled_by_exclusive_element({
              action: `removing <${exclusiveTag}> element with formatting with "${test.command}"`,
              cancelBeforeInput: false,
            });
          }
        })();
      }
    })();

    function test_indenting_text(aTestData) {
      editTarget.innerHTML = "format";
      editTarget.focus();
      selection.selectAllChildren(editTarget);
      reset();
      cancelBeforeInput = aTestData.cancelBeforeInput;
      action = aTestData.action;
      SpecialPowers.doCommand(aWindow, "cmd_indent");
      let expectedValue = aTestData.cancelBeforeInput
                            ? "format"
                            : "<blockquote>format</blockquote>";
      is(editTarget.innerHTML, expectedValue,
        `${aDescription}innerHTML should be "${expectedValue}" after ${aTestData.action}`);
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${aTestData.action}`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${aTestData.action} should be cancelable`);
      is(beforeInputEvent.inputType, "formatIndent",
        `${aDescription}inputType of "beforeinput" event should be "formatIndent"`);
      is(beforeInputEvent.data, null,
        `${aDescription}data of "beforeinput" event for ${aTestData.action} should be null`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${aTestData.action} should be null`);
      checkTargetRanges(beforeInputEvent, selectionRanges);
      if (aTestData.cancelBeforeInput) {
        ok(!inputEvent,
          `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
        return;
      }
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${aTestData.action}`);
      is(inputEvent.cancelable, false,
        `${aDescription}"input" event for ${aTestData.action} should never be cancelable`);
      is(inputEvent.inputType, "formatIndent",
        `${aDescription}inputType of "input" event should be "formatIndent"`);
      is(inputEvent.data, null,
        `${aDescription}data of "input" event for ${aTestData.action} should be null`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${aTestData.action} should be null`);
      checkTargetRanges(inputEvent, []);
    }
    test_indenting_text({
      action: 'indenting text and canceling "beforeinput"',
      cancelBeforeInput: true,
    });
    test_indenting_text({
      action: 'indenting text',
      cancelBeforeInput: false,
    });

    function test_outdenting_blockquote(aTestData) {
      editTarget.innerHTML = "<blockquote>format</blockquote>";
      selection.selectAllChildren(editTarget.firstChild);
      reset();
      cancelBeforeInput = aTestData.cancelBeforeInput;
      action = aTestData.action;
      SpecialPowers.doCommand(aWindow, "cmd_outdent");
      let expectedValue = aTestData.cancelBeforeInput
                            ? "<blockquote>format</blockquote>"
                            : "format";
      is(editTarget.innerHTML, expectedValue,
        `${aDescription}innerHTML should be "${expectedValue}" after ${aTestData.action}`);
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${aTestData.action}`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${aTestData.action} should be cancelable`);
      is(beforeInputEvent.inputType, "formatOutdent",
        `${aDescription}inputType of "beforeinput" event should be "formatOutdent"`);
      is(beforeInputEvent.data, null,
        `${aDescription}data of "beforeinput" event for ${aTestData.action} should be null`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${aTestData.action} should be null`);
      checkTargetRanges(beforeInputEvent, selectionRanges);
      if (aTestData.cancelBeforeInput) {
        ok(!inputEvent,
          `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
        return;
      }
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${aTestData.action}`);
      is(inputEvent.cancelable, false,
        `${aDescription}"input" event for ${aTestData.action} should never be cancelable`);
      is(inputEvent.inputType, "formatOutdent",
        `${aDescription}inputType of "input" event should be "formatOutdent"`);
      is(inputEvent.data, null,
        `${aDescription}data of "input" event for ${aTestData.action} should be null`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${aTestData.action} should be null`);
      checkTargetRanges(inputEvent, []);
    }
    test_outdenting_blockquote({
      action: 'outdenting blockquote and canceling "beforeinput"',
      cancelBeforeInput: true,
    });
    test_outdenting_blockquote({
      action: 'outdenting blockquote',
      cancelBeforeInput: false,
    });

    function test_typing_delete_to_delete_img(aTestData) {
      editTarget.innerHTML = `<img src="${kImgURL}">`;
      editTarget.focus();
      selection.collapse(editTarget, 0);
      reset();
      cancelBeforeInput = aTestData.cancelBeforeInput;
      action = aTestData.action;
      synthesizeKey("KEY_Delete", {}, aWindow);
      let expectedValue = aTestData.cancelBeforeInput ? `<img src="${kImgURL}">` : "<br>";
      is(editTarget.innerHTML, expectedValue,
        `${aDescription}innerHTML should be "${expectedValue}" after ${aTestData.action}`);
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${aTestData.action}`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${aTestData.action} should be cancelable`);
      is(beforeInputEvent.inputType, "deleteContentForward",
        `${aDescription}inputType of "beforeinput" event should be "deleteContentForward"`);
      is(beforeInputEvent.data, null,
        `${aDescription}data of "beforeinput" event for ${aTestData.action} should be null`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${aTestData.action} should be null`);
      checkTargetRanges(beforeInputEvent, [{startContainer: editTarget,
                                            startOffset: 0,
                                            endContainer: editTarget,
                                            endOffset: 1}]);
      if (aTestData.cancelBeforeInput) {
        ok(!inputEvent,
          `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
        return;
      }
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${aTestData.action}`);
      is(inputEvent.cancelable, false,
        `${aDescription}"input" event for ${aTestData.action} should never be cancelable`);
      is(inputEvent.inputType, "deleteContentForward",
        `${aDescription}inputType of "input" event should be "deleteContentForward"`);
      is(inputEvent.data, null,
        `${aDescription}data of "input" event for ${aTestData.action} should be null`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${aTestData.action} should be null`);
      checkTargetRanges(inputEvent, []);
    }
    test_typing_delete_to_delete_img({
      action: 'typing "Delete" to delete the <img> element and canceling "beforeinput"',
      cancelBeforeInput: true,
    });
    test_typing_delete_to_delete_img({
      action: 'typing "Delete" to delete the <img> element',
      cancelBeforeInput: false,
    });

    function test_typing_backspace_to_delete_img(aTestData) {
      editTarget.innerHTML = `<img src="${kImgURL}">`;
      editTarget.focus();
      selection.collapse(editTarget, 1);
      reset();
      cancelBeforeInput = aTestData.cancelBeforeInput;
      action = aTestData.action;
      synthesizeKey("KEY_Backspace", {}, aWindow);
      let expectedValue = aTestData.cancelBeforeInput ? `<img src="${kImgURL}">` : "<br>";
      is(editTarget.innerHTML, expectedValue,
        `${aDescription}innerHTML should be "${expectedValue}" after ${aTestData.action}`);
      ok(beforeInputEvent,
        `${aDescription}"beforeinput" event should've been fired at ${aTestData.action}`);
      is(beforeInputEvent.cancelable, true,
        `${aDescription}"beforeinput" event for ${aTestData.action} should be cancelable`);
      is(beforeInputEvent.inputType, "deleteContentBackward",
        `${aDescription}inputType of "beforeinput" event should be "deleteContentBackward"`);
      is(beforeInputEvent.data, null,
        `${aDescription}data of "beforeinput" event for ${aTestData.action} should be null`);
      is(beforeInputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "beforeinput" event for ${aTestData.action} should be null`);
      checkTargetRanges(beforeInputEvent, [{startContainer: editTarget,
                                            startOffset: 0,
                                            endContainer: editTarget,
                                            endOffset: 1}]);
      if (aTestData.cancelBeforeInput) {
        ok(!inputEvent,
          `${aDescription}"input" event shouldn't been fired at ${aTestData.action}`);
        return;
      }
      ok(inputEvent,
        `${aDescription}"input" event should've been fired at ${aTestData.action}`);
      is(inputEvent.cancelable, false,
        `${aDescription}"input" event for ${aTestData.action} should never be cancelable`);
      is(inputEvent.inputType, "deleteContentBackward",
        `${aDescription}inputType of "input" event should be "deleteContentBackward"`);
      is(inputEvent.data, null,
        `${aDescription}data of "input" event for ${aTestData.action} should be null`);
      is(inputEvent.dataTransfer, null,
        `${aDescription}dataTransfer of "input" event for ${aTestData.action} should be null`);
      checkTargetRanges(inputEvent, []);
    }
    test_typing_backspace_to_delete_img({
      action: 'typing "Backspace" to delete the <img> element and canceling "beforeinput"',
      cancelBeforeInput: true,
    });
    test_typing_backspace_to_delete_img({
      action: 'typing "Backspace" to delete the <img> element',
      cancelBeforeInput: false,
    });

    aWindow.removeEventListener("beforeinput", beforeInputHandler, true);
    aWindow.removeEventListener("input", inputHandler, true);
  }

  doTests(document.getElementById("editor1").contentDocument,
          document.getElementById("editor1").contentWindow,
          "Editor1, body has contenteditable attribute");
  doTests(document.getElementById("editor2").contentDocument,
          document.getElementById("editor2").contentWindow,
          "Editor2, html has contenteditable attribute");
  doTests(document.getElementById("editor3").contentDocument,
          document.getElementById("editor3").contentWindow,
          "Editor3, div has contenteditable attribute");
  doTests(document.getElementById("editor4").contentDocument,
          document.getElementById("editor4").contentWindow,
          "Editor4, html and div have contenteditable attribute");
  doTests(document.getElementById("editor5").contentDocument,
          document.getElementById("editor5").contentWindow,
          "Editor5, html and div have contenteditable attribute");

  SimpleTest.finish();
}

</script>
</body>

</html>
