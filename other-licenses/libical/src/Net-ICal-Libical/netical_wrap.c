/*
 * FILE : netical_wrap.c
 * 
 * This file was automatically generated by :
 * Simplified Wrapper and Interface Generator (SWIG)
 * Version 1.1 (Patch 5)
 * 
 * Portions Copyright (c) 1995-1998
 * The University of Utah and The Regents of the University of California.
 * Permission is granted to distribute this file in any manner provided
 * this notice remains intact.
 * 
 * Do not make changes to this file--changes will be lost!
 *
 */


#define SWIGCODE
/* Implementation : PERL 5 */

#define SWIGPERL
#define SWIGPERL5
#ifdef __cplusplus
#include <math.h>
#include <stdlib.h>
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#undef free
#undef malloc
#include <string.h>
#ifdef __cplusplus
}
#endif
/* Definitions for compiling Perl extensions on a variety of machines */

#if defined(WIN32) || defined(__WIN32__)
#   if defined(_MSC_VER)
#	define SWIGEXPORT(a,b) __declspec(dllexport) a b
#   else
#	if defined(__BORLANDC__)
#	    define SWIGEXPORT(a,b) a _export b
#	else
#	    define SWIGEXPORT(a,b) a b
#	endif
#   endif
#else
#   define SWIGEXPORT(a,b) a b
#endif

#ifdef PERL_OBJECT
#define MAGIC_PPERL  CPerl *pPerl = (CPerl *) this;
#define MAGIC_CAST   (int (CPerl::*)(SV *, MAGIC *))
#define SWIGCLASS_STATIC 
#else
#define MAGIC_PPERL
#define MAGIC_CAST
#define SWIGCLASS_STATIC static
#endif


/*****************************************************************************
 * $Header: /home/hwine/cvs_conversion/cvsroot/mozilla/other-licenses/libical/src/Net-ICal-Libical/Attic/netical_wrap.c,v 1.1 2001/12/21 19:21:13 mikep%oeone.com Exp $
 *
 * perl5ptr.swg
 *
 * This file contains supporting code for the SWIG run-time type checking
 * mechanism.  The following functions are available :
 *
 * SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *));
 *
 *      Registers a new type-mapping with the type-checker.  origtype is the
 *      original datatype and newtype is an equivalent type.  cast is optional
 *      pointer to a function to cast pointer values between types (this
 *      is only used to cast pointers from derived classes to base classes in C++)
 *      
 * SWIG_MakePtr(char *buffer, void *ptr, char *typestring);
 *     
 *      Makes a pointer string from a pointer and typestring.  The result is returned
 *      in buffer.
 *
 * char * SWIG_GetPtr(SV *obj, void **ptr, char *type)
 *
 *      Gets a pointer value from a Perl5 scalar value.  If there is a 
 *      type-mismatch, returns a character string to the received type.  
 *      On success, returns NULL.
 *
 *
 * You can remap these functions by making a file called "swigptr.swg" in
 * your the same directory as the interface file you are wrapping.
 *
 * These functions are normally declared static, but this file can be
 * can be used in a multi-module environment by redefining the symbol
 * SWIGSTATIC.
 *
 * $Log: netical_wrap.c,v $
 * Revision 1.1  2001/12/21 19:21:13  mikep%oeone.com
 * Adding in files for second import of libical.
 *
 * Revision 1.6  2001/04/02 18:17:40  ebusboom
 * Get perl extension compiling again.
 *
 * Revision 1.1  1996/12/26 22:17:29  beazley
 * Initial revision
 *
 *****************************************************************************/

#include <stdlib.h>

#ifdef SWIG_GLOBAL
#ifdef __cplusplus
#define SWIGSTATIC extern "C"
#else
#define SWIGSTATIC
#endif
#endif

#ifndef SWIGSTATIC
#define SWIGSTATIC static
#endif

/* These are internal variables.   Should be static */

typedef struct SwigPtrType {
  char               *name;
  int                 len;
  void               *(*cast)(void *);
  struct SwigPtrType *next;
} SwigPtrType;

/* Pointer cache structure */

typedef struct {
  int                 stat;               /* Status (valid) bit             */
  SwigPtrType        *tp;                 /* Pointer to type structure      */
  char                name[256];          /* Given datatype name            */
  char                mapped[256];        /* Equivalent name                */
} SwigCacheType;

static int SwigPtrMax  = 64;           /* Max entries that can be currently held */
static int SwigPtrN    = 0;            /* Current number of entries              */
static int SwigPtrSort = 0;            /* Status flag indicating sort            */
static SwigPtrType *SwigPtrTable = 0;  /* Table containing pointer equivalences  */
static int SwigStart[256];             /* Table containing starting positions    */

/* Cached values */

#define SWIG_CACHESIZE  8
#define SWIG_CACHEMASK  0x7
static SwigCacheType SwigCache[SWIG_CACHESIZE];  
static int SwigCacheIndex = 0;
static int SwigLastCache = 0;

/* Sort comparison function */
static int swigsort(const void *data1, const void *data2) {
	SwigPtrType *d1 = (SwigPtrType *) data1;
	SwigPtrType *d2 = (SwigPtrType *) data2;
	return strcmp(d1->name,d2->name);
}

/* Binary Search function */
static int swigcmp(const void *key, const void *data) {
  char *k = (char *) key;
  SwigPtrType *d = (SwigPtrType *) data;
  return strncmp(k,d->name,d->len);
}

/* Register a new datatype with the type-checker */

#ifndef PERL_OBJECT
SWIGSTATIC 
void SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *)) {
#else
SWIGSTATIC
#define SWIG_RegisterMapping(a,b,c) _SWIG_RegisterMapping(pPerl, a,b,c)
void _SWIG_RegisterMapping(CPerl *pPerl, char *origtype, char *newtype, void *(*cast)(void *)) {
#endif

  int i;
  SwigPtrType *t = 0, *t1;

  if (!SwigPtrTable) {     
    SwigPtrTable = (SwigPtrType *) malloc(SwigPtrMax*sizeof(SwigPtrType));
    SwigPtrN = 0;
  }
  if (SwigPtrN >= SwigPtrMax) {
    SwigPtrMax = 2*SwigPtrMax;
    SwigPtrTable = (SwigPtrType *) realloc(SwigPtrTable,SwigPtrMax*sizeof(SwigPtrType));
  }
  for (i = 0; i < SwigPtrN; i++)
    if (strcmp(SwigPtrTable[i].name,origtype) == 0) {
      t = &SwigPtrTable[i];
      break;
    }
  if (!t) {
    t = &SwigPtrTable[SwigPtrN];
    t->name = origtype;
    t->len = strlen(t->name);
    t->cast = 0;
    t->next = 0;
    SwigPtrN++;
  }
  while (t->next) {
    if (strcmp(t->name,newtype) == 0) {
      if (cast) t->cast = cast;
      return;
    }
    t = t->next;
  }
  t1 = (SwigPtrType *) malloc(sizeof(SwigPtrType));
  t1->name = newtype;
  t1->len = strlen(t1->name);
  t1->cast = cast;
  t1->next = 0;
  t->next = t1;
  SwigPtrSort = 0;
}

/* Make a pointer value string */

SWIGSTATIC 
void SWIG_MakePtr(char *_c, const void *_ptr, char *type) {
  static char _hex[16] =
  {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
   'a', 'b', 'c', 'd', 'e', 'f'};
  unsigned long _p, _s;
  char _result[20], *_r;    /* Note : a 64-bit hex number = 16 digits */
  _r = _result;
  _p = (unsigned long) _ptr;
  if (_p > 0) {
    while (_p > 0) {
      _s = _p & 0xf;
      *(_r++) = _hex[_s];
      _p = _p >> 4;
    }
    *_r = '_';
    while (_r >= _result)
      *(_c++) = *(_r--);
  } else {
    strcpy (_c, "NULL");
  }
  if (_ptr)
    strcpy (_c, type);
}

/* Define for backwards compatibility */

#define _swig_make_hex   SWIG_MakePtr 

/* Function for getting a pointer value */

#ifndef PERL_OBJECT
SWIGSTATIC 
char *SWIG_GetPtr(SV *sv, void **ptr, char *_t)
#else
SWIGSTATIC
#define SWIG_GetPtr(a,b,c) _SWIG_GetPtr(pPerl,a,b,c)
char *_SWIG_GetPtr(CPerl *pPerl, SV *sv, void **ptr, char *_t)
#endif
{
  char temp_type[256];
  char *name,*_c;
  int  len,i,start,end;
  IV   tmp;
  SwigPtrType *sp,*tp;
  SwigCacheType *cache;

  /* If magical, apply more magic */

  if (SvGMAGICAL(sv))
    mg_get(sv);

  /* Check to see if this is an object */
  if (sv_isobject(sv)) {
    SV *tsv = (SV*) SvRV(sv);
    if ((SvTYPE(tsv) == SVt_PVHV)) {
      MAGIC *mg;
      if (SvMAGICAL(tsv)) {
	mg = mg_find(tsv,'P');
	if (mg) {
	  SV *rsv = mg->mg_obj;
	  if (sv_isobject(rsv)) {
	    tmp = SvIV((SV*)SvRV(rsv));
	  }
	}
      } else {
	return "Not a valid pointer value";
      }
    } else {
      tmp = SvIV((SV*)SvRV(sv));
    }
    if (!_t) {
      *(ptr) = (void *) tmp;
      return (char *) 0;
    }
  } else if (sv == &sv_undef) {            /* Check for undef */
    *(ptr) = (void *) 0;
    return (char *) 0;
  } else if (SvTYPE(sv) == SVt_RV) {       /* Check for NULL pointer */
    *(ptr) = (void *) 0;
    if (!SvROK(sv)) 
      return (char *) 0;
    else
      return "Not a valid pointer value";
  } else {                                 /* Don't know what it is */
      *(ptr) = (void *) 0;
      return "Not a valid pointer value";
  }
  if (_t) {
    /* Now see if the types match */      

    if (!sv_isa(sv,_t)) {
      _c = HvNAME(SvSTASH(SvRV(sv)));
      if (!SwigPtrSort) {
	qsort((void *) SwigPtrTable, SwigPtrN, sizeof(SwigPtrType), swigsort);  
	for (i = 0; i < 256; i++) {
	  SwigStart[i] = SwigPtrN;
	}
	for (i = SwigPtrN-1; i >= 0; i--) {
	  SwigStart[SwigPtrTable[i].name[0]] = i;
	}
	for (i = 255; i >= 1; i--) {
	  if (SwigStart[i-1] > SwigStart[i])
	    SwigStart[i-1] = SwigStart[i];
	}
	SwigPtrSort = 1;
	for (i = 0; i < SWIG_CACHESIZE; i++)  
	  SwigCache[i].stat = 0;
      }
      /* First check cache for matches.  Uses last cache value as starting point */
      cache = &SwigCache[SwigLastCache];
      for (i = 0; i < SWIG_CACHESIZE; i++) {
	if (cache->stat) {
	  if (strcmp(_t,cache->name) == 0) {
	    if (strcmp(_c,cache->mapped) == 0) {
	      cache->stat++;
	      *ptr = (void *) tmp;
	      if (cache->tp->cast) *ptr = (*(cache->tp->cast))(*ptr);
	      return (char *) 0;
	    }
	  }
	}
	SwigLastCache = (SwigLastCache+1) & SWIG_CACHEMASK;
	if (!SwigLastCache) cache = SwigCache;
	else cache++;
      }

      start = SwigStart[_t[0]];
      end = SwigStart[_t[0]+1];
      sp = &SwigPtrTable[start];
      while (start < end) {
	if (swigcmp(_t,sp) == 0) break;
	sp++;
	start++;
      }
      if (start >= end) sp = 0;
      if (sp) {
	while (swigcmp(_t,sp) == 0) {
	  name = sp->name;
	  len = sp->len;
	  tp = sp->next;
	  while(tp) {
	    if (tp->len >= 255) {
	      return _c;
	    }
	    strcpy(temp_type,tp->name);
	    strncat(temp_type,_t+len,255-tp->len);
	    if (sv_isa(sv,temp_type)) {
	      /* Get pointer value */
	      *ptr = (void *) tmp;
	      if (tp->cast) *ptr = (*(tp->cast))(*ptr);

	      strcpy(SwigCache[SwigCacheIndex].mapped,_c);
	      strcpy(SwigCache[SwigCacheIndex].name,_t);
	      SwigCache[SwigCacheIndex].stat = 1;
	      SwigCache[SwigCacheIndex].tp = tp;
	      SwigCacheIndex = SwigCacheIndex & SWIG_CACHEMASK;
	      return (char *) 0;
	    }
	    tp = tp->next;
	  } 
	  /* Hmmm. Didn't find it this time */
 	  sp++;
	}
      }
      /* Didn't find any sort of match for this data.  
	 Get the pointer value and return the received type */
      *ptr = (void *) tmp;
      return _c;
    } else {
      /* Found a match on the first try.  Return pointer value */
      *ptr = (void *) tmp;
      return (char *) 0;
    }
  } 
  *ptr = (void *) tmp;
  return (char *) 0;
}

/* Compatibility mode */

#define _swig_get_hex  SWIG_GetPtr
/* Magic variable code */
#ifndef PERL_OBJECT
#define swig_create_magic(s,a,b,c) _swig_create_magic(s,a,b,c)
static void _swig_create_magic(SV *sv, char *name, int (*set)(SV *, MAGIC *), int (*get)(SV *,MAGIC *)) {
#else
#define swig_create_magic(s,a,b,c) _swig_create_magic(pPerl,s,a,b,c)
static void _swig_create_magic(CPerl *pPerl, SV *sv, char *name, int (CPerl::*set)(SV *, MAGIC *), int (CPerl::*get)(SV *, MAGIC *)) {
#endif
  MAGIC *mg;
  sv_magic(sv,sv,'U',name,strlen(name));
  mg = mg_find(sv,'U');
  mg->mg_virtual = (MGVTBL *) malloc(sizeof(MGVTBL));
  mg->mg_virtual->svt_get = get;
  mg->mg_virtual->svt_set = set;
  mg->mg_virtual->svt_len = 0;
  mg->mg_virtual->svt_clear = 0;
  mg->mg_virtual->svt_free = 0;
}

#define SWIG_init    boot_Net__ICal__Libical

#define SWIG_name   "Net::ICal::Libical::boot_Net__ICal__Libical"
#define SWIG_varinit "Net::ICal::Libical::var_Net__ICal__Libical_init();"
#ifdef __cplusplus
extern "C"
#endif
#ifndef PERL_OBJECT
SWIGEXPORT(void,boot_Net__ICal__Libical)(CV* cv);
#else
SWIGEXPORT(void,boot_Net__ICal__Libical)(CPerl *, CV *cv);
#endif

#include "ical.h"

#include <sys/types.h> /* for size_t */
#include <time.h>

#ifndef PERL_OBJECT
#define swig_setiv(a,b) _swig_setiv(a,b)
static void _swig_setiv(char *name, long value) { 
#else
#define swig_setiv(a,b) _swig_setiv(pPerl,a,b)
static void _swig_setiv(CPerl *pPerl, char *name, long value) { 
#endif
     SV *sv; 
     sv = perl_get_sv(name,TRUE | 0x2);
     sv_setiv(sv, (IV) value);
     SvREADONLY_on(sv);
}

#ifndef PERL_OBJECT
#define swig_setpv(a,b) _swig_setpv(a,b)
static void _swig_setpv(char *name, char *value) { 
#else
#define swig_setpv(a,b) _swig_setpv(pPerl,a,b)
static void _swig_setpv(CPerl *pPerl, char *name, char *value) { 
#endif
     SV *sv; 
     sv = perl_get_sv(name,TRUE | 0x2);
     sv_setpv(sv, value);
     SvREADONLY_on(sv);
}

#ifdef PERL_OBJECT
#define MAGIC_CLASS _wrap_Net__ICal__Libical_var::
class _wrap_Net__ICal__Libical_var : public CPerl {
public:
#else
#define MAGIC_CLASS
#endif
SWIGCLASS_STATIC int swig_magic_readonly(SV *sv, MAGIC *mg) {
    MAGIC_PPERL
    sv = sv; mg = mg;
    croak("Value is read-only.");
    return 0;
}


#ifdef PERL_OBJECT
};
#endif

XS(_wrap_icalparser_parse_string) {

    icalcomponent * _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalparser_parse_string(str);");
    _arg0 = (char *) SvPV(ST(0),na);
    _result = (icalcomponent *)icalparser_parse_string(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"icalcomponentPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalcomponent_new) {

    icalcomponent * _result;
    icalcomponent_kind * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalcomponent_new(kind);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"icalcomponent_kindPtr")) {
        croak("Type error in argument 1 of icalcomponent_new. Expected icalcomponent_kindPtr.");
        XSRETURN(1);
    }
    _result = (icalcomponent *)icalcomponent_new(*_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"icalcomponentPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalcomponent_new_clone) {

    icalcomponent * _result;
    icalcomponent * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalcomponent_new_clone(component);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icalcomponent_new_clone. Expected icalcomponentPtr.");
        XSRETURN(1);
    }
    _result = (icalcomponent *)icalcomponent_new_clone(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"icalcomponentPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalcomponent_new_from_string) {

    icalcomponent * _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalcomponent_new_from_string(str);");
    _arg0 = (char *) SvPV(ST(0),na);
    _result = (icalcomponent *)icalcomponent_new_from_string(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"icalcomponentPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalcomponent_as_ical_string) {

    char * _result;
    icalcomponent * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalcomponent_as_ical_string(component);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icalcomponent_as_ical_string. Expected icalcomponentPtr.");
        XSRETURN(1);
    }
    _result = (char *)icalcomponent_as_ical_string(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalcomponent_free) {

    icalcomponent * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalcomponent_free(component);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icalcomponent_free. Expected icalcomponentPtr.");
        XSRETURN(1);
    }
    icalcomponent_free(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_icalcomponent_count_errors) {

    int  _result;
    icalcomponent * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalcomponent_count_errors(component);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icalcomponent_count_errors. Expected icalcomponentPtr.");
        XSRETURN(1);
    }
    _result = (int )icalcomponent_count_errors(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalcomponent_strip_errors) {

    icalcomponent * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalcomponent_strip_errors(component);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icalcomponent_strip_errors. Expected icalcomponentPtr.");
        XSRETURN(1);
    }
    icalcomponent_strip_errors(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_icalcomponent_convert_errors) {

    icalcomponent * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalcomponent_convert_errors(component);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icalcomponent_convert_errors. Expected icalcomponentPtr.");
        XSRETURN(1);
    }
    icalcomponent_convert_errors(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_icalcomponent_get_current_property) {

    icalproperty * _result;
    icalcomponent * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalcomponent_get_current_property(component);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icalcomponent_get_current_property. Expected icalcomponentPtr.");
        XSRETURN(1);
    }
    _result = (icalproperty *)icalcomponent_get_current_property(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"icalpropertyPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalcomponent_get_first_property) {

    icalproperty * _result;
    icalcomponent * _arg0;
    icalproperty_kind * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icalcomponent_get_first_property(component,kind);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icalcomponent_get_first_property. Expected icalcomponentPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"icalproperty_kindPtr")) {
        croak("Type error in argument 2 of icalcomponent_get_first_property. Expected icalproperty_kindPtr.");
        XSRETURN(1);
    }
    _result = (icalproperty *)icalcomponent_get_first_property(_arg0,*_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"icalpropertyPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalcomponent_get_next_property) {

    icalproperty * _result;
    icalcomponent * _arg0;
    icalproperty_kind * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icalcomponent_get_next_property(component,kind);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icalcomponent_get_next_property. Expected icalcomponentPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"icalproperty_kindPtr")) {
        croak("Type error in argument 2 of icalcomponent_get_next_property. Expected icalproperty_kindPtr.");
        XSRETURN(1);
    }
    _result = (icalproperty *)icalcomponent_get_next_property(_arg0,*_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"icalpropertyPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalcomponent_get_current_component) {

    icalcomponent * _result;
    icalcomponent * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalcomponent_get_current_component(component);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icalcomponent_get_current_component. Expected icalcomponentPtr.");
        XSRETURN(1);
    }
    _result = (icalcomponent *)icalcomponent_get_current_component(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"icalcomponentPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalcomponent_get_first_component) {

    icalcomponent * _result;
    icalcomponent * _arg0;
    icalcomponent_kind * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icalcomponent_get_first_component(component,kind);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icalcomponent_get_first_component. Expected icalcomponentPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"icalcomponent_kindPtr")) {
        croak("Type error in argument 2 of icalcomponent_get_first_component. Expected icalcomponent_kindPtr.");
        XSRETURN(1);
    }
    _result = (icalcomponent *)icalcomponent_get_first_component(_arg0,*_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"icalcomponentPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalcomponent_get_next_component) {

    icalcomponent * _result;
    icalcomponent * _arg0;
    icalcomponent_kind * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icalcomponent_get_next_component(component,kind);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icalcomponent_get_next_component. Expected icalcomponentPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"icalcomponent_kindPtr")) {
        croak("Type error in argument 2 of icalcomponent_get_next_component. Expected icalcomponent_kindPtr.");
        XSRETURN(1);
    }
    _result = (icalcomponent *)icalcomponent_get_next_component(_arg0,*_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"icalcomponentPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalcomponent_add_property) {

    icalcomponent * _arg0;
    icalproperty * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icalcomponent_add_property(component,property);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icalcomponent_add_property. Expected icalcomponentPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,(char *) 0 )) {
        croak("Type error in argument 2 of icalcomponent_add_property. Expected icalpropertyPtr.");
        XSRETURN(1);
    }
    icalcomponent_add_property(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_icalcomponent_remove_property) {

    icalcomponent * _arg0;
    icalproperty * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icalcomponent_remove_property(component,property);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icalcomponent_remove_property. Expected icalcomponentPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,(char *) 0 )) {
        croak("Type error in argument 2 of icalcomponent_remove_property. Expected icalpropertyPtr.");
        XSRETURN(1);
    }
    icalcomponent_remove_property(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_icalcomponent_get_parent) {

    icalcomponent * _result;
    icalcomponent * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalcomponent_get_parent(component);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icalcomponent_get_parent. Expected icalcomponentPtr.");
        XSRETURN(1);
    }
    _result = (icalcomponent *)icalcomponent_get_parent(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"icalcomponentPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalcomponent_isa) {

    icalcomponent_kind * _result;
    icalcomponent * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalcomponent_isa(component);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icalcomponent_isa. Expected icalcomponentPtr.");
        XSRETURN(1);
    }
    _result = (icalcomponent_kind *) malloc(sizeof(icalcomponent_kind ));
    *(_result) = icalcomponent_isa(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"icalcomponent_kindPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalrestriction_check) {

    int  _result;
    icalcomponent * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalrestriction_check(comp);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icalrestriction_check. Expected icalcomponentPtr.");
        XSRETURN(1);
    }
    _result = (int )icalrestriction_check(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalproperty_string_to_kind) {

    int  _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalproperty_string_to_kind(string);");
    _arg0 = (char *) SvPV(ST(0),na);
    _result = (int )icalproperty_string_to_kind(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalproperty_new) {

    icalproperty * _result;
    int  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalproperty_new(kind);");
    _arg0 = (int )SvIV(ST(0));
    _result = (icalproperty *)icalproperty_new(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"icalpropertyPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalproperty_new_from_string) {

    icalproperty * _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalproperty_new_from_string(str);");
    _arg0 = (char *) SvPV(ST(0),na);
    _result = (icalproperty *)icalproperty_new_from_string(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"icalpropertyPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalproperty_as_ical_string) {

    char * _result;
    icalproperty * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalproperty_as_ical_string(prop);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icalproperty_as_ical_string. Expected icalpropertyPtr.");
        XSRETURN(1);
    }
    _result = (char *)icalproperty_as_ical_string(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalproperty_set_parameter_from_string) {

    icalproperty * _arg0;
    char * _arg1;
    char * _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: icalproperty_set_parameter_from_string(prop,name,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icalproperty_set_parameter_from_string. Expected icalpropertyPtr.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    _arg2 = (char *) SvPV(ST(2),na);
    icalproperty_set_parameter_from_string(_arg0,_arg1,_arg2);
    XSRETURN(argvi);
}

XS(_wrap_icalproperty_set_value_from_string) {

    icalproperty * _arg0;
    char * _arg1;
    char * _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: icalproperty_set_value_from_string(prop,value,kind);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icalproperty_set_value_from_string. Expected icalpropertyPtr.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    _arg2 = (char *) SvPV(ST(2),na);
    icalproperty_set_value_from_string(_arg0,_arg1,_arg2);
    XSRETURN(argvi);
}

XS(_wrap_icalproperty_get_value_as_string) {

    char * _result;
    icalproperty * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalproperty_get_value_as_string(prop);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icalproperty_get_value_as_string. Expected icalpropertyPtr.");
        XSRETURN(1);
    }
    _result = (char *)icalproperty_get_value_as_string(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalproperty_get_parameter_as_string) {

    char * _result;
    icalproperty * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icalproperty_get_parameter_as_string(prop,name);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icalproperty_get_parameter_as_string. Expected icalpropertyPtr.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    _result = (char *)icalproperty_get_parameter_as_string(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalproperty_get_parent) {

    icalcomponent * _result;
    icalproperty * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalproperty_get_parent(property);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icalproperty_get_parent. Expected icalpropertyPtr.");
        XSRETURN(1);
    }
    _result = (icalcomponent *)icalproperty_get_parent(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"icalcomponentPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalerror_set_error_state) {

    icalerrorenum  _arg0;
    icalerrorstate  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icalerror_set_error_state(error,icalerrorstate );");
    _arg0 = (icalerrorenum )SvIV(ST(0));
    _arg1 = (icalerrorstate )SvIV(ST(1));
    icalerror_set_error_state(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_icalerror_get_error_state) {

    icalerrorstate  _result;
    icalerrorenum  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalerror_get_error_state(error);");
    _arg0 = (icalerrorenum )SvIV(ST(0));
    _result = (icalerrorstate )icalerror_get_error_state(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalenum_property_kind_to_string) {

    char * _result;
    icalproperty_kind * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalenum_property_kind_to_string(kind);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"icalproperty_kindPtr")) {
        croak("Type error in argument 1 of icalenum_property_kind_to_string. Expected icalproperty_kindPtr.");
        XSRETURN(1);
    }
    _result = (char *)icalenum_property_kind_to_string(*_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalenum_string_to_property_kind) {

    icalproperty_kind * _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalenum_string_to_property_kind(string);");
    _arg0 = (char *) SvPV(ST(0),na);
    _result = (icalproperty_kind *) malloc(sizeof(icalproperty_kind ));
    *(_result) = icalenum_string_to_property_kind(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"icalproperty_kindPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalenum_value_kind_to_string) {

    char * _result;
    icalvalue_kind * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalenum_value_kind_to_string(kind);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"icalvalue_kindPtr")) {
        croak("Type error in argument 1 of icalenum_value_kind_to_string. Expected icalvalue_kindPtr.");
        XSRETURN(1);
    }
    _result = (char *)icalenum_value_kind_to_string(*_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalenum_parameter_kind_to_string) {

    char * _result;
    icalparameter_kind * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalenum_parameter_kind_to_string(kind);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"icalparameter_kindPtr")) {
        croak("Type error in argument 1 of icalenum_parameter_kind_to_string. Expected icalparameter_kindPtr.");
        XSRETURN(1);
    }
    _result = (char *)icalenum_parameter_kind_to_string(*_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalenum_string_to_parameter_kind) {

    icalparameter_kind * _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalenum_string_to_parameter_kind(string);");
    _arg0 = (char *) SvPV(ST(0),na);
    _result = (icalparameter_kind *) malloc(sizeof(icalparameter_kind ));
    *(_result) = icalenum_string_to_parameter_kind(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"icalparameter_kindPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalenum_component_kind_to_string) {

    char * _result;
    icalcomponent_kind * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalenum_component_kind_to_string(kind);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"icalcomponent_kindPtr")) {
        croak("Type error in argument 1 of icalenum_component_kind_to_string. Expected icalcomponent_kindPtr.");
        XSRETURN(1);
    }
    _result = (char *)icalenum_component_kind_to_string(*_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalenum_string_to_component_kind) {

    icalcomponent_kind * _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalenum_string_to_component_kind(string);");
    _arg0 = (char *) SvPV(ST(0),na);
    _result = (icalcomponent_kind *) malloc(sizeof(icalcomponent_kind ));
    *(_result) = icalenum_string_to_component_kind(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"icalcomponent_kindPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalenum_property_kind_to_value_kind) {

    icalvalue_kind * _result;
    icalproperty_kind * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalenum_property_kind_to_value_kind(kind);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"icalproperty_kindPtr")) {
        croak("Type error in argument 1 of icalenum_property_kind_to_value_kind. Expected icalproperty_kindPtr.");
        XSRETURN(1);
    }
    _result = (icalvalue_kind *) malloc(sizeof(icalvalue_kind ));
    *(_result) = icalenum_property_kind_to_value_kind(*_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"icalvalue_kindPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icallangbind_new_array) {

    int * _result;
    int  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icallangbind_new_array(size);");
    _arg0 = (int )SvIV(ST(0));
    _result = (int *)icallangbind_new_array(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"intPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icallangbind_free_array) {

    int * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icallangbind_free_array(array);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"intPtr")) {
        croak("Type error in argument 1 of icallangbind_free_array. Expected intPtr.");
        XSRETURN(1);
    }
    icallangbind_free_array(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_icallangbind_access_array) {

    int  _result;
    int * _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icallangbind_access_array(array,index);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"intPtr")) {
        croak("Type error in argument 1 of icallangbind_access_array. Expected intPtr.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _result = (int )icallangbind_access_array(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalrecur_expand_recurrence) {

    int  _result;
    char * _arg0;
    int  _arg1;
    int  _arg2;
    int * _arg3;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: icalrecur_expand_recurrence(rule,start,count,array);");
    _arg0 = (char *) SvPV(ST(0),na);
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (int )SvIV(ST(2));
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"intPtr")) {
        croak("Type error in argument 4 of icalrecur_expand_recurrence. Expected intPtr.");
        XSRETURN(1);
    }
    _result = (int )icalrecur_expand_recurrence(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_icallangbind_get_first_property) {

    icalproperty * _result;
    icalcomponent * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icallangbind_get_first_property(c,prop);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icallangbind_get_first_property. Expected icalcomponentPtr.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    _result = (icalproperty *)icallangbind_get_first_property(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"icalpropertyPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icallangbind_get_next_property) {

    icalproperty * _result;
    icalcomponent * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icallangbind_get_next_property(c,prop);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icallangbind_get_next_property. Expected icalcomponentPtr.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    _result = (icalproperty *)icallangbind_get_next_property(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"icalpropertyPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icallangbind_get_first_component) {

    icalcomponent * _result;
    icalcomponent * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icallangbind_get_first_component(c,comp);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icallangbind_get_first_component. Expected icalcomponentPtr.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    _result = (icalcomponent *)icallangbind_get_first_component(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"icalcomponentPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icallangbind_get_next_component) {

    icalcomponent * _result;
    icalcomponent * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icallangbind_get_next_component(c,comp);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icallangbind_get_next_component. Expected icalcomponentPtr.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    _result = (icalcomponent *)icallangbind_get_next_component(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"icalcomponentPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icallangbind_property_eval_string) {

    char * _result;
    icalproperty * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icallangbind_property_eval_string(prop,sep);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of icallangbind_property_eval_string. Expected icalpropertyPtr.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    _result = (char *)icallangbind_property_eval_string(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaltime_from_timet) {

    struct icaltimetype * _result;
    int  _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icaltime_from_timet(v,is_date);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _result = (struct icaltimetype *) malloc(sizeof(struct icaltimetype ));
    *(_result) = icaltime_from_timet(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"struct icaltimetypePtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaltime_as_timet) {

    int  _result;
    struct icaltimetype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaltime_as_timet(struct icaltimetype *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltime_as_timet. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _result = (int )icaltime_as_timet(*_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaltime_as_ical_string) {

    char * _result;
    struct icaltimetype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaltime_as_ical_string(tt);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltime_as_ical_string. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _result = (char *)icaltime_as_ical_string(*_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaltime_from_string) {

    struct icaltimetype * _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaltime_from_string(str);");
    _arg0 = (char *) SvPV(ST(0),na);
    _result = (struct icaltimetype *) malloc(sizeof(struct icaltimetype ));
    *(_result) = icaltime_from_string(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"struct icaltimetypePtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaltime_utc_offset) {

    int  _result;
    struct icaltimetype * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icaltime_utc_offset(tt,tzid);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltime_utc_offset. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    _result = (int )icaltime_utc_offset(*_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaltime_as_utc) {

    struct icaltimetype * _result;
    struct icaltimetype * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icaltime_as_utc(tt,tzid);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltime_as_utc. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    _result = (struct icaltimetype *) malloc(sizeof(struct icaltimetype ));
    *(_result) = icaltime_as_utc(*_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"struct icaltimetypePtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaltime_as_zone) {

    struct icaltimetype * _result;
    struct icaltimetype * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icaltime_as_zone(tt,tzid);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltime_as_zone. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    _result = (struct icaltimetype *) malloc(sizeof(struct icaltimetype ));
    *(_result) = icaltime_as_zone(*_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"struct icaltimetypePtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaltime_null_time) {

    struct icaltimetype * _result;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: icaltime_null_time();");
    _result = (struct icaltimetype *) malloc(sizeof(struct icaltimetype ));
    *(_result) = icaltime_null_time();
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"struct icaltimetypePtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaltime_is_null_time) {

    int  _result;
    struct icaltimetype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaltime_is_null_time(t);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltime_is_null_time. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _result = (int )icaltime_is_null_time(*_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaltime_is_valid_time) {

    int  _result;
    struct icaltimetype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaltime_is_valid_time(t);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltime_is_valid_time. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _result = (int )icaltime_is_valid_time(*_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaltime_normalize) {

    struct icaltimetype * _result;
    struct icaltimetype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaltime_normalize(t);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltime_normalize. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _result = (struct icaltimetype *) malloc(sizeof(struct icaltimetype ));
    *(_result) = icaltime_normalize(*_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"struct icaltimetypePtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaltime_day_of_year) {

    short  _result;
    struct icaltimetype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaltime_day_of_year(t);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltime_day_of_year. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _result = (short )icaltime_day_of_year(*_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaltime_from_day_of_year) {

    struct icaltimetype * _result;
    short  _arg0;
    short  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icaltime_from_day_of_year(doy,year);");
    _arg0 = (short )SvIV(ST(0));
    _arg1 = (short )SvIV(ST(1));
    _result = (struct icaltimetype *) malloc(sizeof(struct icaltimetype ));
    *(_result) = icaltime_from_day_of_year(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"struct icaltimetypePtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaltime_day_of_week) {

    short  _result;
    struct icaltimetype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaltime_day_of_week(t);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltime_day_of_week. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _result = (short )icaltime_day_of_week(*_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaltime_start_doy_of_week) {

    short  _result;
    struct icaltimetype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaltime_start_doy_of_week(t);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltime_start_doy_of_week. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _result = (short )icaltime_start_doy_of_week(*_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaltime_as_ctime) {

    char * _result;
    struct icaltimetype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaltime_as_ctime(struct icaltimetype *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltime_as_ctime. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _result = (char *)icaltime_as_ctime(*_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaltime_week_number) {

    short  _result;
    struct icaltimetype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaltime_week_number(t);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltime_week_number. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _result = (short )icaltime_week_number(*_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaltime_compare) {

    int  _result;
    struct icaltimetype * _arg0;
    struct icaltimetype * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icaltime_compare(a,b);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltime_compare. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"struct icaltimetypePtr")) {
        croak("Type error in argument 2 of icaltime_compare. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _result = (int )icaltime_compare(*_arg0,*_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaltime_compare_date_only) {

    int  _result;
    struct icaltimetype * _arg0;
    struct icaltimetype * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icaltime_compare_date_only(a,b);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltime_compare_date_only. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"struct icaltimetypePtr")) {
        croak("Type error in argument 2 of icaltime_compare_date_only. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _result = (int )icaltime_compare_date_only(*_arg0,*_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaltime_days_in_month) {

    short  _result;
    short  _arg0;
    short  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icaltime_days_in_month(month,year);");
    _arg0 = (short )SvIV(ST(0));
    _arg1 = (short )SvIV(ST(1));
    _result = (short )icaltime_days_in_month(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaldurationtype_from_int) {

    struct icaldurationtype * _result;
    int  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaldurationtype_from_int(t);");
    _arg0 = (int )SvIV(ST(0));
    _result = (struct icaldurationtype *) malloc(sizeof(struct icaldurationtype ));
    *(_result) = icaldurationtype_from_int(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"struct icaldurationtypePtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaldurationtype_from_string) {

    struct icaldurationtype * _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaldurationtype_from_string(char *);");
    _arg0 = (char *) SvPV(ST(0),na);
    _result = (struct icaldurationtype *) malloc(sizeof(struct icaldurationtype ));
    *(_result) = icaldurationtype_from_string(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"struct icaldurationtypePtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaldurationtype_as_int) {

    int  _result;
    struct icaldurationtype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaldurationtype_as_int(duration);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaldurationtypePtr")) {
        croak("Type error in argument 1 of icaldurationtype_as_int. Expected struct icaldurationtypePtr.");
        XSRETURN(1);
    }
    _result = (int )icaldurationtype_as_int(*_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaldurationtype_as_ical_string) {

    char * _result;
    struct icaldurationtype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaldurationtype_as_ical_string(d);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaldurationtypePtr")) {
        croak("Type error in argument 1 of icaldurationtype_as_ical_string. Expected struct icaldurationtypePtr.");
        XSRETURN(1);
    }
    _result = (char *)icaldurationtype_as_ical_string(*_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaldurationtype_null_duration) {

    struct icaldurationtype * _result;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: icaldurationtype_null_duration();");
    _result = (struct icaldurationtype *) malloc(sizeof(struct icaldurationtype ));
    *(_result) = icaldurationtype_null_duration();
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"struct icaldurationtypePtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaldurationtype_is_null_duration) {

    int  _result;
    struct icaldurationtype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaldurationtype_is_null_duration(d);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaldurationtypePtr")) {
        croak("Type error in argument 1 of icaldurationtype_is_null_duration. Expected struct icaldurationtypePtr.");
        XSRETURN(1);
    }
    _result = (int )icaldurationtype_is_null_duration(*_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaltime_add) {

    struct icaltimetype * _result;
    struct icaltimetype * _arg0;
    struct icaldurationtype * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icaltime_add(t,d);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltime_add. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"struct icaldurationtypePtr")) {
        croak("Type error in argument 2 of icaltime_add. Expected struct icaldurationtypePtr.");
        XSRETURN(1);
    }
    _result = (struct icaltimetype *) malloc(sizeof(struct icaltimetype ));
    *(_result) = icaltime_add(*_arg0,*_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"struct icaltimetypePtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icaltime_subtract) {

    struct icaldurationtype * _result;
    struct icaltimetype * _arg0;
    struct icaltimetype * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icaltime_subtract(t1,t2);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltime_subtract. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"struct icaltimetypePtr")) {
        croak("Type error in argument 2 of icaltime_subtract. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _result = (struct icaldurationtype *) malloc(sizeof(struct icaldurationtype ));
    *(_result) = icaltime_subtract(*_arg0,*_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"struct icaldurationtypePtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalperiodtype_from_string) {

    struct icalperiodtype * _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalperiodtype_from_string(str);");
    _arg0 = (char *) SvPV(ST(0),na);
    _result = (struct icalperiodtype *) malloc(sizeof(struct icalperiodtype ));
    *(_result) = icalperiodtype_from_string(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"struct icalperiodtypePtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalperiodtype_as_ical_string) {

    char * _result;
    struct icalperiodtype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalperiodtype_as_ical_string(p);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icalperiodtypePtr")) {
        croak("Type error in argument 1 of icalperiodtype_as_ical_string. Expected struct icalperiodtypePtr.");
        XSRETURN(1);
    }
    _result = (char *)icalperiodtype_as_ical_string(*_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalperiodtype_null_period) {

    struct icalperiodtype * _result;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: icalperiodtype_null_period();");
    _result = (struct icalperiodtype *) malloc(sizeof(struct icalperiodtype ));
    *(_result) = icalperiodtype_null_period();
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"struct icalperiodtypePtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalperiodtype_is_null_period) {

    int  _result;
    struct icalperiodtype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalperiodtype_is_null_period(p);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icalperiodtypePtr")) {
        croak("Type error in argument 1 of icalperiodtype_is_null_period. Expected struct icalperiodtypePtr.");
        XSRETURN(1);
    }
    _result = (int )icalperiodtype_is_null_period(*_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_icalperiodtype_is_valid_period) {

    int  _result;
    struct icalperiodtype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalperiodtype_is_valid_period(p);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icalperiodtypePtr")) {
        croak("Type error in argument 1 of icalperiodtype_is_valid_period. Expected struct icalperiodtypePtr.");
        XSRETURN(1);
    }
    _result = (int )icalperiodtype_is_valid_period(*_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaltimetype_year_set(_swigobj,_swigval) (_swigobj->year = _swigval,_swigval)
XS(_wrap_icaltimetype_year_set) {

    int  _result;
    struct icaltimetype * _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icaltimetype_year_set(struct icaltimetype *,int );");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltimetype_year_set. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _result = (int )icaltimetype_year_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaltimetype_year_get(_swigobj) ((int ) _swigobj->year)
XS(_wrap_icaltimetype_year_get) {

    int  _result;
    struct icaltimetype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaltimetype_year_get(struct icaltimetype *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltimetype_year_get. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _result = (int )icaltimetype_year_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaltimetype_month_set(_swigobj,_swigval) (_swigobj->month = _swigval,_swigval)
XS(_wrap_icaltimetype_month_set) {

    int  _result;
    struct icaltimetype * _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icaltimetype_month_set(struct icaltimetype *,int );");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltimetype_month_set. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _result = (int )icaltimetype_month_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaltimetype_month_get(_swigobj) ((int ) _swigobj->month)
XS(_wrap_icaltimetype_month_get) {

    int  _result;
    struct icaltimetype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaltimetype_month_get(struct icaltimetype *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltimetype_month_get. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _result = (int )icaltimetype_month_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaltimetype_day_set(_swigobj,_swigval) (_swigobj->day = _swigval,_swigval)
XS(_wrap_icaltimetype_day_set) {

    int  _result;
    struct icaltimetype * _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icaltimetype_day_set(struct icaltimetype *,int );");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltimetype_day_set. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _result = (int )icaltimetype_day_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaltimetype_day_get(_swigobj) ((int ) _swigobj->day)
XS(_wrap_icaltimetype_day_get) {

    int  _result;
    struct icaltimetype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaltimetype_day_get(struct icaltimetype *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltimetype_day_get. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _result = (int )icaltimetype_day_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaltimetype_hour_set(_swigobj,_swigval) (_swigobj->hour = _swigval,_swigval)
XS(_wrap_icaltimetype_hour_set) {

    int  _result;
    struct icaltimetype * _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icaltimetype_hour_set(struct icaltimetype *,int );");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltimetype_hour_set. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _result = (int )icaltimetype_hour_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaltimetype_hour_get(_swigobj) ((int ) _swigobj->hour)
XS(_wrap_icaltimetype_hour_get) {

    int  _result;
    struct icaltimetype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaltimetype_hour_get(struct icaltimetype *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltimetype_hour_get. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _result = (int )icaltimetype_hour_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaltimetype_minute_set(_swigobj,_swigval) (_swigobj->minute = _swigval,_swigval)
XS(_wrap_icaltimetype_minute_set) {

    int  _result;
    struct icaltimetype * _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icaltimetype_minute_set(struct icaltimetype *,int );");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltimetype_minute_set. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _result = (int )icaltimetype_minute_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaltimetype_minute_get(_swigobj) ((int ) _swigobj->minute)
XS(_wrap_icaltimetype_minute_get) {

    int  _result;
    struct icaltimetype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaltimetype_minute_get(struct icaltimetype *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltimetype_minute_get. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _result = (int )icaltimetype_minute_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaltimetype_second_set(_swigobj,_swigval) (_swigobj->second = _swigval,_swigval)
XS(_wrap_icaltimetype_second_set) {

    int  _result;
    struct icaltimetype * _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icaltimetype_second_set(struct icaltimetype *,int );");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltimetype_second_set. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _result = (int )icaltimetype_second_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaltimetype_second_get(_swigobj) ((int ) _swigobj->second)
XS(_wrap_icaltimetype_second_get) {

    int  _result;
    struct icaltimetype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaltimetype_second_get(struct icaltimetype *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltimetype_second_get. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _result = (int )icaltimetype_second_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaltimetype_is_utc_set(_swigobj,_swigval) (_swigobj->is_utc = _swigval,_swigval)
XS(_wrap_icaltimetype_is_utc_set) {

    int  _result;
    struct icaltimetype * _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icaltimetype_is_utc_set(struct icaltimetype *,int );");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltimetype_is_utc_set. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _result = (int )icaltimetype_is_utc_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaltimetype_is_utc_get(_swigobj) ((int ) _swigobj->is_utc)
XS(_wrap_icaltimetype_is_utc_get) {

    int  _result;
    struct icaltimetype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaltimetype_is_utc_get(struct icaltimetype *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltimetype_is_utc_get. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _result = (int )icaltimetype_is_utc_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaltimetype_is_date_set(_swigobj,_swigval) (_swigobj->is_date = _swigval,_swigval)
XS(_wrap_icaltimetype_is_date_set) {

    int  _result;
    struct icaltimetype * _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icaltimetype_is_date_set(struct icaltimetype *,int );");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltimetype_is_date_set. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _result = (int )icaltimetype_is_date_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaltimetype_is_date_get(_swigobj) ((int ) _swigobj->is_date)
XS(_wrap_icaltimetype_is_date_get) {

    int  _result;
    struct icaltimetype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaltimetype_is_date_get(struct icaltimetype *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaltimetypePtr")) {
        croak("Type error in argument 1 of icaltimetype_is_date_get. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _result = (int )icaltimetype_is_date_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaldurationtype_is_neg_set(_swigobj,_swigval) (_swigobj->is_neg = _swigval,_swigval)
XS(_wrap_icaldurationtype_is_neg_set) {

    int  _result;
    struct icaldurationtype * _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icaldurationtype_is_neg_set(struct icaldurationtype *,int );");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaldurationtypePtr")) {
        croak("Type error in argument 1 of icaldurationtype_is_neg_set. Expected struct icaldurationtypePtr.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _result = (int )icaldurationtype_is_neg_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaldurationtype_is_neg_get(_swigobj) ((int ) _swigobj->is_neg)
XS(_wrap_icaldurationtype_is_neg_get) {

    int  _result;
    struct icaldurationtype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaldurationtype_is_neg_get(struct icaldurationtype *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaldurationtypePtr")) {
        croak("Type error in argument 1 of icaldurationtype_is_neg_get. Expected struct icaldurationtypePtr.");
        XSRETURN(1);
    }
    _result = (int )icaldurationtype_is_neg_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaldurationtype_days_set(_swigobj,_swigval) (_swigobj->days = _swigval,_swigval)
XS(_wrap_icaldurationtype_days_set) {

    unsigned int  _result;
    struct icaldurationtype * _arg0;
    unsigned int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icaldurationtype_days_set(struct icaldurationtype *,unsigned int );");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaldurationtypePtr")) {
        croak("Type error in argument 1 of icaldurationtype_days_set. Expected struct icaldurationtypePtr.");
        XSRETURN(1);
    }
    _arg1 = (unsigned int )SvIV(ST(1));
    _result = (unsigned int )icaldurationtype_days_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaldurationtype_days_get(_swigobj) ((unsigned int ) _swigobj->days)
XS(_wrap_icaldurationtype_days_get) {

    unsigned int  _result;
    struct icaldurationtype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaldurationtype_days_get(struct icaldurationtype *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaldurationtypePtr")) {
        croak("Type error in argument 1 of icaldurationtype_days_get. Expected struct icaldurationtypePtr.");
        XSRETURN(1);
    }
    _result = (unsigned int )icaldurationtype_days_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaldurationtype_weeks_set(_swigobj,_swigval) (_swigobj->weeks = _swigval,_swigval)
XS(_wrap_icaldurationtype_weeks_set) {

    unsigned int  _result;
    struct icaldurationtype * _arg0;
    unsigned int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icaldurationtype_weeks_set(struct icaldurationtype *,unsigned int );");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaldurationtypePtr")) {
        croak("Type error in argument 1 of icaldurationtype_weeks_set. Expected struct icaldurationtypePtr.");
        XSRETURN(1);
    }
    _arg1 = (unsigned int )SvIV(ST(1));
    _result = (unsigned int )icaldurationtype_weeks_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaldurationtype_weeks_get(_swigobj) ((unsigned int ) _swigobj->weeks)
XS(_wrap_icaldurationtype_weeks_get) {

    unsigned int  _result;
    struct icaldurationtype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaldurationtype_weeks_get(struct icaldurationtype *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaldurationtypePtr")) {
        croak("Type error in argument 1 of icaldurationtype_weeks_get. Expected struct icaldurationtypePtr.");
        XSRETURN(1);
    }
    _result = (unsigned int )icaldurationtype_weeks_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaldurationtype_hours_set(_swigobj,_swigval) (_swigobj->hours = _swigval,_swigval)
XS(_wrap_icaldurationtype_hours_set) {

    unsigned int  _result;
    struct icaldurationtype * _arg0;
    unsigned int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icaldurationtype_hours_set(struct icaldurationtype *,unsigned int );");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaldurationtypePtr")) {
        croak("Type error in argument 1 of icaldurationtype_hours_set. Expected struct icaldurationtypePtr.");
        XSRETURN(1);
    }
    _arg1 = (unsigned int )SvIV(ST(1));
    _result = (unsigned int )icaldurationtype_hours_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaldurationtype_hours_get(_swigobj) ((unsigned int ) _swigobj->hours)
XS(_wrap_icaldurationtype_hours_get) {

    unsigned int  _result;
    struct icaldurationtype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaldurationtype_hours_get(struct icaldurationtype *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaldurationtypePtr")) {
        croak("Type error in argument 1 of icaldurationtype_hours_get. Expected struct icaldurationtypePtr.");
        XSRETURN(1);
    }
    _result = (unsigned int )icaldurationtype_hours_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaldurationtype_minutes_set(_swigobj,_swigval) (_swigobj->minutes = _swigval,_swigval)
XS(_wrap_icaldurationtype_minutes_set) {

    unsigned int  _result;
    struct icaldurationtype * _arg0;
    unsigned int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icaldurationtype_minutes_set(struct icaldurationtype *,unsigned int );");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaldurationtypePtr")) {
        croak("Type error in argument 1 of icaldurationtype_minutes_set. Expected struct icaldurationtypePtr.");
        XSRETURN(1);
    }
    _arg1 = (unsigned int )SvIV(ST(1));
    _result = (unsigned int )icaldurationtype_minutes_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaldurationtype_minutes_get(_swigobj) ((unsigned int ) _swigobj->minutes)
XS(_wrap_icaldurationtype_minutes_get) {

    unsigned int  _result;
    struct icaldurationtype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaldurationtype_minutes_get(struct icaldurationtype *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaldurationtypePtr")) {
        croak("Type error in argument 1 of icaldurationtype_minutes_get. Expected struct icaldurationtypePtr.");
        XSRETURN(1);
    }
    _result = (unsigned int )icaldurationtype_minutes_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaldurationtype_seconds_set(_swigobj,_swigval) (_swigobj->seconds = _swigval,_swigval)
XS(_wrap_icaldurationtype_seconds_set) {

    unsigned int  _result;
    struct icaldurationtype * _arg0;
    unsigned int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icaldurationtype_seconds_set(struct icaldurationtype *,unsigned int );");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaldurationtypePtr")) {
        croak("Type error in argument 1 of icaldurationtype_seconds_set. Expected struct icaldurationtypePtr.");
        XSRETURN(1);
    }
    _arg1 = (unsigned int )SvIV(ST(1));
    _result = (unsigned int )icaldurationtype_seconds_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icaldurationtype_seconds_get(_swigobj) ((unsigned int ) _swigobj->seconds)
XS(_wrap_icaldurationtype_seconds_get) {

    unsigned int  _result;
    struct icaldurationtype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icaldurationtype_seconds_get(struct icaldurationtype *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icaldurationtypePtr")) {
        croak("Type error in argument 1 of icaldurationtype_seconds_get. Expected struct icaldurationtypePtr.");
        XSRETURN(1);
    }
    _result = (unsigned int )icaldurationtype_seconds_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define icalperiodtype_start_set(_swigobj,_swigval) (_swigobj->start = *(_swigval),_swigval)
XS(_wrap_icalperiodtype_start_set) {

    struct icaltimetype * _result;
    struct icalperiodtype * _arg0;
    struct icaltimetype * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icalperiodtype_start_set(struct icalperiodtype *,struct icaltimetype *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icalperiodtypePtr")) {
        croak("Type error in argument 1 of icalperiodtype_start_set. Expected struct icalperiodtypePtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"struct icaltimetypePtr")) {
        croak("Type error in argument 2 of icalperiodtype_start_set. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _result = (struct icaltimetype *)icalperiodtype_start_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"struct icaltimetypePtr", (void *) _result);
    XSRETURN(argvi);
}

#define icalperiodtype_start_get(_swigobj) (&_swigobj->start)
XS(_wrap_icalperiodtype_start_get) {

    struct icaltimetype * _result;
    struct icalperiodtype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalperiodtype_start_get(struct icalperiodtype *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icalperiodtypePtr")) {
        croak("Type error in argument 1 of icalperiodtype_start_get. Expected struct icalperiodtypePtr.");
        XSRETURN(1);
    }
    _result = (struct icaltimetype *)icalperiodtype_start_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"struct icaltimetypePtr", (void *) _result);
    XSRETURN(argvi);
}

#define icalperiodtype_end_set(_swigobj,_swigval) (_swigobj->end = *(_swigval),_swigval)
XS(_wrap_icalperiodtype_end_set) {

    struct icaltimetype * _result;
    struct icalperiodtype * _arg0;
    struct icaltimetype * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icalperiodtype_end_set(struct icalperiodtype *,struct icaltimetype *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icalperiodtypePtr")) {
        croak("Type error in argument 1 of icalperiodtype_end_set. Expected struct icalperiodtypePtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"struct icaltimetypePtr")) {
        croak("Type error in argument 2 of icalperiodtype_end_set. Expected struct icaltimetypePtr.");
        XSRETURN(1);
    }
    _result = (struct icaltimetype *)icalperiodtype_end_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"struct icaltimetypePtr", (void *) _result);
    XSRETURN(argvi);
}

#define icalperiodtype_end_get(_swigobj) (&_swigobj->end)
XS(_wrap_icalperiodtype_end_get) {

    struct icaltimetype * _result;
    struct icalperiodtype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalperiodtype_end_get(struct icalperiodtype *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icalperiodtypePtr")) {
        croak("Type error in argument 1 of icalperiodtype_end_get. Expected struct icalperiodtypePtr.");
        XSRETURN(1);
    }
    _result = (struct icaltimetype *)icalperiodtype_end_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"struct icaltimetypePtr", (void *) _result);
    XSRETURN(argvi);
}

#define icalperiodtype_duration_set(_swigobj,_swigval) (_swigobj->duration = *(_swigval),_swigval)
XS(_wrap_icalperiodtype_duration_set) {

    struct icaldurationtype * _result;
    struct icalperiodtype * _arg0;
    struct icaldurationtype * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: icalperiodtype_duration_set(struct icalperiodtype *,struct icaldurationtype *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icalperiodtypePtr")) {
        croak("Type error in argument 1 of icalperiodtype_duration_set. Expected struct icalperiodtypePtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"struct icaldurationtypePtr")) {
        croak("Type error in argument 2 of icalperiodtype_duration_set. Expected struct icaldurationtypePtr.");
        XSRETURN(1);
    }
    _result = (struct icaldurationtype *)icalperiodtype_duration_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"struct icaldurationtypePtr", (void *) _result);
    XSRETURN(argvi);
}

#define icalperiodtype_duration_get(_swigobj) (&_swigobj->duration)
XS(_wrap_icalperiodtype_duration_get) {

    struct icaldurationtype * _result;
    struct icalperiodtype * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: icalperiodtype_duration_get(struct icalperiodtype *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct icalperiodtypePtr")) {
        croak("Type error in argument 1 of icalperiodtype_duration_get. Expected struct icalperiodtypePtr.");
        XSRETURN(1);
    }
    _result = (struct icaldurationtype *)icalperiodtype_duration_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"struct icaldurationtypePtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_perl5_Net__ICal__Libical_var_init) {
    dXSARGS;
    SV *sv;
    cv = cv; items = items;
    swig_setiv("ICAL_BADARG_ERROR", (long) ICAL_BADARG_ERROR);
    swig_setiv("ICAL_NEWFAILED_ERROR", (long) ICAL_NEWFAILED_ERROR);
    swig_setiv("ICAL_MALFORMEDDATA_ERROR", (long) ICAL_MALFORMEDDATA_ERROR);
    swig_setiv("ICAL_PARSE_ERROR", (long) ICAL_PARSE_ERROR);
    swig_setiv("ICAL_INTERNAL_ERROR", (long) ICAL_INTERNAL_ERROR);
    swig_setiv("ICAL_FILE_ERROR", (long) ICAL_FILE_ERROR);
    swig_setiv("ICAL_ALLOCATION_ERROR", (long) ICAL_ALLOCATION_ERROR);
    swig_setiv("ICAL_USAGE_ERROR", (long) ICAL_USAGE_ERROR);
    swig_setiv("ICAL_NO_ERROR", (long) ICAL_NO_ERROR);
    swig_setiv("ICAL_UNKNOWN_ERROR", (long) ICAL_UNKNOWN_ERROR);
    swig_setiv("ICAL_ERROR_FATAL", (long) ICAL_ERROR_FATAL);
    swig_setiv("ICAL_ERROR_NONFATAL", (long) ICAL_ERROR_NONFATAL);
    swig_setiv("ICAL_ERROR_DEFAULT", (long) ICAL_ERROR_DEFAULT);
    swig_setiv("ICAL_ERROR_UNKNOWN", (long) ICAL_ERROR_UNKNOWN);
    swig_setpv("icaltimetype_zone", "icaltimetype::zone");
    XSRETURN(1);
}
#ifdef __cplusplus
extern "C"
#endif
XS(boot_Net__ICal__Libical) {
	 dXSARGS;
	 char *file = __FILE__;
	 cv = cv; items = items;
	 newXS("Net::ICal::Libical::var_Net__ICal__Libical_init", _wrap_perl5_Net__ICal__Libical_var_init, file);
	 newXS("Net::ICal::Libical::icalparser_parse_string", _wrap_icalparser_parse_string, file);
	 newXS("Net::ICal::Libical::icalcomponent_new", _wrap_icalcomponent_new, file);
	 newXS("Net::ICal::Libical::icalcomponent_new_clone", _wrap_icalcomponent_new_clone, file);
	 newXS("Net::ICal::Libical::icalcomponent_new_from_string", _wrap_icalcomponent_new_from_string, file);
	 newXS("Net::ICal::Libical::icalcomponent_as_ical_string", _wrap_icalcomponent_as_ical_string, file);
	 newXS("Net::ICal::Libical::icalcomponent_free", _wrap_icalcomponent_free, file);
	 newXS("Net::ICal::Libical::icalcomponent_count_errors", _wrap_icalcomponent_count_errors, file);
	 newXS("Net::ICal::Libical::icalcomponent_strip_errors", _wrap_icalcomponent_strip_errors, file);
	 newXS("Net::ICal::Libical::icalcomponent_convert_errors", _wrap_icalcomponent_convert_errors, file);
	 newXS("Net::ICal::Libical::icalcomponent_get_current_property", _wrap_icalcomponent_get_current_property, file);
	 newXS("Net::ICal::Libical::icalcomponent_get_first_property", _wrap_icalcomponent_get_first_property, file);
	 newXS("Net::ICal::Libical::icalcomponent_get_next_property", _wrap_icalcomponent_get_next_property, file);
	 newXS("Net::ICal::Libical::icalcomponent_get_current_component", _wrap_icalcomponent_get_current_component, file);
	 newXS("Net::ICal::Libical::icalcomponent_get_first_component", _wrap_icalcomponent_get_first_component, file);
	 newXS("Net::ICal::Libical::icalcomponent_get_next_component", _wrap_icalcomponent_get_next_component, file);
	 newXS("Net::ICal::Libical::icalcomponent_add_property", _wrap_icalcomponent_add_property, file);
	 newXS("Net::ICal::Libical::icalcomponent_remove_property", _wrap_icalcomponent_remove_property, file);
	 newXS("Net::ICal::Libical::icalcomponent_get_parent", _wrap_icalcomponent_get_parent, file);
	 newXS("Net::ICal::Libical::icalcomponent_isa", _wrap_icalcomponent_isa, file);
	 newXS("Net::ICal::Libical::icalrestriction_check", _wrap_icalrestriction_check, file);
	 newXS("Net::ICal::Libical::icalproperty_string_to_kind", _wrap_icalproperty_string_to_kind, file);
	 newXS("Net::ICal::Libical::icalproperty_new", _wrap_icalproperty_new, file);
	 newXS("Net::ICal::Libical::icalproperty_new_from_string", _wrap_icalproperty_new_from_string, file);
	 newXS("Net::ICal::Libical::icalproperty_as_ical_string", _wrap_icalproperty_as_ical_string, file);
	 newXS("Net::ICal::Libical::icalproperty_set_parameter_from_string", _wrap_icalproperty_set_parameter_from_string, file);
	 newXS("Net::ICal::Libical::icalproperty_set_value_from_string", _wrap_icalproperty_set_value_from_string, file);
	 newXS("Net::ICal::Libical::icalproperty_get_value_as_string", _wrap_icalproperty_get_value_as_string, file);
	 newXS("Net::ICal::Libical::icalproperty_get_parameter_as_string", _wrap_icalproperty_get_parameter_as_string, file);
	 newXS("Net::ICal::Libical::icalproperty_get_parent", _wrap_icalproperty_get_parent, file);
	 newXS("Net::ICal::Libical::icalerror_set_error_state", _wrap_icalerror_set_error_state, file);
	 newXS("Net::ICal::Libical::icalerror_get_error_state", _wrap_icalerror_get_error_state, file);
	 newXS("Net::ICal::Libical::icalenum_property_kind_to_string", _wrap_icalenum_property_kind_to_string, file);
	 newXS("Net::ICal::Libical::icalenum_string_to_property_kind", _wrap_icalenum_string_to_property_kind, file);
	 newXS("Net::ICal::Libical::icalenum_value_kind_to_string", _wrap_icalenum_value_kind_to_string, file);
	 newXS("Net::ICal::Libical::icalenum_parameter_kind_to_string", _wrap_icalenum_parameter_kind_to_string, file);
	 newXS("Net::ICal::Libical::icalenum_string_to_parameter_kind", _wrap_icalenum_string_to_parameter_kind, file);
	 newXS("Net::ICal::Libical::icalenum_component_kind_to_string", _wrap_icalenum_component_kind_to_string, file);
	 newXS("Net::ICal::Libical::icalenum_string_to_component_kind", _wrap_icalenum_string_to_component_kind, file);
	 newXS("Net::ICal::Libical::icalenum_property_kind_to_value_kind", _wrap_icalenum_property_kind_to_value_kind, file);
	 newXS("Net::ICal::Libical::icallangbind_new_array", _wrap_icallangbind_new_array, file);
	 newXS("Net::ICal::Libical::icallangbind_free_array", _wrap_icallangbind_free_array, file);
	 newXS("Net::ICal::Libical::icallangbind_access_array", _wrap_icallangbind_access_array, file);
	 newXS("Net::ICal::Libical::icalrecur_expand_recurrence", _wrap_icalrecur_expand_recurrence, file);
	 newXS("Net::ICal::Libical::icallangbind_get_first_property", _wrap_icallangbind_get_first_property, file);
	 newXS("Net::ICal::Libical::icallangbind_get_next_property", _wrap_icallangbind_get_next_property, file);
	 newXS("Net::ICal::Libical::icallangbind_get_first_component", _wrap_icallangbind_get_first_component, file);
	 newXS("Net::ICal::Libical::icallangbind_get_next_component", _wrap_icallangbind_get_next_component, file);
	 newXS("Net::ICal::Libical::icallangbind_property_eval_string", _wrap_icallangbind_property_eval_string, file);
	 newXS("Net::ICal::Libical::icaltime_from_timet", _wrap_icaltime_from_timet, file);
	 newXS("Net::ICal::Libical::icaltime_as_timet", _wrap_icaltime_as_timet, file);
	 newXS("Net::ICal::Libical::icaltime_as_ical_string", _wrap_icaltime_as_ical_string, file);
	 newXS("Net::ICal::Libical::icaltime_from_string", _wrap_icaltime_from_string, file);
	 newXS("Net::ICal::Libical::icaltime_utc_offset", _wrap_icaltime_utc_offset, file);
	 newXS("Net::ICal::Libical::icaltime_as_utc", _wrap_icaltime_as_utc, file);
	 newXS("Net::ICal::Libical::icaltime_as_zone", _wrap_icaltime_as_zone, file);
	 newXS("Net::ICal::Libical::icaltime_null_time", _wrap_icaltime_null_time, file);
	 newXS("Net::ICal::Libical::icaltime_is_null_time", _wrap_icaltime_is_null_time, file);
	 newXS("Net::ICal::Libical::icaltime_is_valid_time", _wrap_icaltime_is_valid_time, file);
	 newXS("Net::ICal::Libical::icaltime_normalize", _wrap_icaltime_normalize, file);
	 newXS("Net::ICal::Libical::icaltime_day_of_year", _wrap_icaltime_day_of_year, file);
	 newXS("Net::ICal::Libical::icaltime_from_day_of_year", _wrap_icaltime_from_day_of_year, file);
	 newXS("Net::ICal::Libical::icaltime_day_of_week", _wrap_icaltime_day_of_week, file);
	 newXS("Net::ICal::Libical::icaltime_start_doy_of_week", _wrap_icaltime_start_doy_of_week, file);
	 newXS("Net::ICal::Libical::icaltime_as_ctime", _wrap_icaltime_as_ctime, file);
	 newXS("Net::ICal::Libical::icaltime_week_number", _wrap_icaltime_week_number, file);
	 newXS("Net::ICal::Libical::icaltime_compare", _wrap_icaltime_compare, file);
	 newXS("Net::ICal::Libical::icaltime_compare_date_only", _wrap_icaltime_compare_date_only, file);
	 newXS("Net::ICal::Libical::icaltime_days_in_month", _wrap_icaltime_days_in_month, file);
	 newXS("Net::ICal::Libical::icaldurationtype_from_int", _wrap_icaldurationtype_from_int, file);
	 newXS("Net::ICal::Libical::icaldurationtype_from_string", _wrap_icaldurationtype_from_string, file);
	 newXS("Net::ICal::Libical::icaldurationtype_as_int", _wrap_icaldurationtype_as_int, file);
	 newXS("Net::ICal::Libical::icaldurationtype_as_ical_string", _wrap_icaldurationtype_as_ical_string, file);
	 newXS("Net::ICal::Libical::icaldurationtype_null_duration", _wrap_icaldurationtype_null_duration, file);
	 newXS("Net::ICal::Libical::icaldurationtype_is_null_duration", _wrap_icaldurationtype_is_null_duration, file);
	 newXS("Net::ICal::Libical::icaltime_add", _wrap_icaltime_add, file);
	 newXS("Net::ICal::Libical::icaltime_subtract", _wrap_icaltime_subtract, file);
	 newXS("Net::ICal::Libical::icalperiodtype_from_string", _wrap_icalperiodtype_from_string, file);
	 newXS("Net::ICal::Libical::icalperiodtype_as_ical_string", _wrap_icalperiodtype_as_ical_string, file);
	 newXS("Net::ICal::Libical::icalperiodtype_null_period", _wrap_icalperiodtype_null_period, file);
	 newXS("Net::ICal::Libical::icalperiodtype_is_null_period", _wrap_icalperiodtype_is_null_period, file);
	 newXS("Net::ICal::Libical::icalperiodtype_is_valid_period", _wrap_icalperiodtype_is_valid_period, file);
	 newXS("Net::ICal::Libical::icaltimetype_year_set", _wrap_icaltimetype_year_set, file);
	 newXS("Net::ICal::Libical::icaltimetype_year_get", _wrap_icaltimetype_year_get, file);
	 newXS("Net::ICal::Libical::icaltimetype_month_set", _wrap_icaltimetype_month_set, file);
	 newXS("Net::ICal::Libical::icaltimetype_month_get", _wrap_icaltimetype_month_get, file);
	 newXS("Net::ICal::Libical::icaltimetype_day_set", _wrap_icaltimetype_day_set, file);
	 newXS("Net::ICal::Libical::icaltimetype_day_get", _wrap_icaltimetype_day_get, file);
	 newXS("Net::ICal::Libical::icaltimetype_hour_set", _wrap_icaltimetype_hour_set, file);
	 newXS("Net::ICal::Libical::icaltimetype_hour_get", _wrap_icaltimetype_hour_get, file);
	 newXS("Net::ICal::Libical::icaltimetype_minute_set", _wrap_icaltimetype_minute_set, file);
	 newXS("Net::ICal::Libical::icaltimetype_minute_get", _wrap_icaltimetype_minute_get, file);
	 newXS("Net::ICal::Libical::icaltimetype_second_set", _wrap_icaltimetype_second_set, file);
	 newXS("Net::ICal::Libical::icaltimetype_second_get", _wrap_icaltimetype_second_get, file);
	 newXS("Net::ICal::Libical::icaltimetype_is_utc_set", _wrap_icaltimetype_is_utc_set, file);
	 newXS("Net::ICal::Libical::icaltimetype_is_utc_get", _wrap_icaltimetype_is_utc_get, file);
	 newXS("Net::ICal::Libical::icaltimetype_is_date_set", _wrap_icaltimetype_is_date_set, file);
	 newXS("Net::ICal::Libical::icaltimetype_is_date_get", _wrap_icaltimetype_is_date_get, file);
	 newXS("Net::ICal::Libical::icaldurationtype_is_neg_set", _wrap_icaldurationtype_is_neg_set, file);
	 newXS("Net::ICal::Libical::icaldurationtype_is_neg_get", _wrap_icaldurationtype_is_neg_get, file);
	 newXS("Net::ICal::Libical::icaldurationtype_days_set", _wrap_icaldurationtype_days_set, file);
	 newXS("Net::ICal::Libical::icaldurationtype_days_get", _wrap_icaldurationtype_days_get, file);
	 newXS("Net::ICal::Libical::icaldurationtype_weeks_set", _wrap_icaldurationtype_weeks_set, file);
	 newXS("Net::ICal::Libical::icaldurationtype_weeks_get", _wrap_icaldurationtype_weeks_get, file);
	 newXS("Net::ICal::Libical::icaldurationtype_hours_set", _wrap_icaldurationtype_hours_set, file);
	 newXS("Net::ICal::Libical::icaldurationtype_hours_get", _wrap_icaldurationtype_hours_get, file);
	 newXS("Net::ICal::Libical::icaldurationtype_minutes_set", _wrap_icaldurationtype_minutes_set, file);
	 newXS("Net::ICal::Libical::icaldurationtype_minutes_get", _wrap_icaldurationtype_minutes_get, file);
	 newXS("Net::ICal::Libical::icaldurationtype_seconds_set", _wrap_icaldurationtype_seconds_set, file);
	 newXS("Net::ICal::Libical::icaldurationtype_seconds_get", _wrap_icaldurationtype_seconds_get, file);
	 newXS("Net::ICal::Libical::icalperiodtype_start_set", _wrap_icalperiodtype_start_set, file);
	 newXS("Net::ICal::Libical::icalperiodtype_start_get", _wrap_icalperiodtype_start_get, file);
	 newXS("Net::ICal::Libical::icalperiodtype_end_set", _wrap_icalperiodtype_end_set, file);
	 newXS("Net::ICal::Libical::icalperiodtype_end_get", _wrap_icalperiodtype_end_get, file);
	 newXS("Net::ICal::Libical::icalperiodtype_duration_set", _wrap_icalperiodtype_duration_set, file);
	 newXS("Net::ICal::Libical::icalperiodtype_duration_get", _wrap_icalperiodtype_duration_get, file);
/*
 * These are the pointer type-equivalency mappings. 
 * (Used by the SWIG pointer type-checker).
 */
	 SWIG_RegisterMapping("unsigned short","short",0);
	 SWIG_RegisterMapping("struct icaldurationtype","icaldurationtype",0);
	 SWIG_RegisterMapping("icalperiodtype","struct icalperiodtype",0);
	 SWIG_RegisterMapping("long","unsigned long",0);
	 SWIG_RegisterMapping("long","signed long",0);
	 SWIG_RegisterMapping("struct icaltimetype","icaltimetype",0);
	 SWIG_RegisterMapping("icaldurationtype","struct icaldurationtype",0);
	 SWIG_RegisterMapping("signed short","short",0);
	 SWIG_RegisterMapping("struct icalperiodtype","icalperiodtype",0);
	 SWIG_RegisterMapping("signed int","int",0);
	 SWIG_RegisterMapping("short","unsigned short",0);
	 SWIG_RegisterMapping("short","signed short",0);
	 SWIG_RegisterMapping("unsigned long","long",0);
	 SWIG_RegisterMapping("int","unsigned int",0);
	 SWIG_RegisterMapping("int","signed int",0);
	 SWIG_RegisterMapping("unsigned int","int",0);
	 SWIG_RegisterMapping("icaltimetype","struct icaltimetype",0);
	 SWIG_RegisterMapping("signed long","long",0);
	 ST(0) = &sv_yes;
	 XSRETURN(1);
}
