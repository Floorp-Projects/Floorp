name: "(P) Publish Linux DEB to PPA (reusable/dispatchable)"

on:
  workflow_call:
    inputs:
      nr_version:
        type: string
        required: false
      artifact_run_id:
        type: string
        required: false
    secrets:
      KEYMASK:
        required: true
      GPG_SEC:
        required: true
      GPG_SSB:
        required: true
      PPA_FTP_URL:
        required: true
      PPA_FTP_USER:
        required: true
      PPA_FTP_PASS:
        required: true
      CLOUDFLARE_API_TOKEN_FOR_PURGE:
        required: false
      CLOUDFLARE_ZONE_ID:
        required: false
  workflow_dispatch:
    inputs:
      deb_url:
        description: "Direct download URL for the floorp-<version>.deb to publish"
        type: string
        required: true
      nr_version:
        description: "Version string (e.g. 12.3.4)"
        type: string
        required: true

jobs:
  publish_deb:
    runs-on: ubuntu-latest
    steps:
      - name: Download Linux DEB artifact (PPA) from provided run
        if: ${{ inputs.artifact_run_id != '' }}
        uses: actions/download-artifact@v4
        with:
          name: floorp-Linux-x64-deb
          run-id: ${{ inputs.artifact_run_id }}
          github-token: ${{ github.token }}
          path: ~/noraneko-publish/linux-deb

      - name: Download Linux DEB artifact (PPA) from current run
        if: ${{ inputs.artifact_run_id == '' && inputs.deb_url == '' }}
        uses: actions/download-artifact@v4
        with:
          name: floorp-Linux-x64-deb
          path: ~/noraneko-publish/linux-deb

      - name: Download Linux DEB from URL
        # Only run this when explicitly triggered via workflow_dispatch AND a deb_url was provided.
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.deb_url != '' }}
        run: |
          set -eux
          # inputs.deb_url is required for this branch; guard is present in the if above but
          # double-check here to produce a clear error if the expression evaluation differs.
          if [ -z "${{ inputs.deb_url }}" ]; then
            echo "deb_url input is required when running via workflow_dispatch" >&2
            exit 1
          fi
          mkdir -p ~/noraneko-publish/linux-deb
          cd ~/noraneko-publish/linux-deb
          TARGET="floorp-${{ inputs.nr_version }}.deb"
          curl -L --fail -o "$TARGET" "${{ inputs.deb_url }}"
          sha256sum "$TARGET" > "$TARGET.sha256"

      - name: Validate legacy DEB filename
        # Ensure we only accept the historical floorp-<version_display>.deb naming.
        run: |
          set -eux
          NR_VERSION="${{ inputs.nr_version }}"
          mkdir -p ~/noraneko-publish/linux-deb
          cd ~/noraneko-publish/linux-deb

          # If an uploaded zip exists (dist.zip or similar), unzip it to extract the .deb
          if ls *.zip >/dev/null 2>&1; then
            unzip -o *.zip || true
          fi

          mapfile -t LEGACY_DEBS < <(find . -maxdepth 1 -type f -name "floorp-*.deb" | sort)
          if [ "${#LEGACY_DEBS[@]}" -eq 0 ]; then
            echo "Expected legacy-named floorp-<version_display>.deb in ~/noraneko-publish/linux-deb" >&2
            ls -la . || true
            exit 1
          fi
          if [ "${#LEGACY_DEBS[@]}" -gt 1 ]; then
            echo "Multiple legacy floorp-*.deb files detected; refusing to continue" >&2
            printf '%s\n' "${LEGACY_DEBS[@]}"
            exit 1
          fi

          DEB_FILE="${LEGACY_DEBS[0]}"
          echo "Found legacy DEB: $DEB_FILE"

          if [ -n "$NR_VERSION" ]; then
            EXPECTED="./floorp-${NR_VERSION}.deb"
            if [ "$DEB_FILE" != "$EXPECTED" ]; then
              echo "inputs.nr_version=$NR_VERSION but legacy artifact is $(basename "$DEB_FILE"); mismatch detected" >&2
              exit 1
            fi
          fi

      - name: Install PPA tooling
        run: |
          sudo apt-get update
          sudo apt-get install -y dpkg-dev ftp gnupg apt-utils lftp

      - name: Publish Linux DEB to PPA
        env:
          KEYMASK: ${{ secrets.KEYMASK }}
          GPG_SEC: ${{ secrets.GPG_SEC }}
          GPG_SSB: ${{ secrets.GPG_SSB }}
          PPA_FTP_URL: ${{ secrets.PPA_FTP_URL }}
          PPA_FTP_USER: ${{ secrets.PPA_FTP_USER }}
          PPA_FTP_PASS: ${{ secrets.PPA_FTP_PASS }}
          CF_API_TOKEN: ${{ secrets.CLOULDFLARE_API_TOKEN_FOR_PURGE }}
          CF_ZONE_ID: ${{ secrets.CLOULDFLARE_ZONE_ID }}
        run: |
          set -euo pipefail
          echo "::add-mask::$KEYMASK"

          WORKDIR="$HOME/ppa"
          ARTIFACT_DIR="$HOME/noraneko-publish/linux-deb"

          if [ ! -d "$ARTIFACT_DIR" ]; then
            echo "Artifact directory $ARTIFACT_DIR missing" >&2
            exit 1
          fi

          DEB_FILE=$(find "$ARTIFACT_DIR" -maxdepth 1 -name "*.deb" | head -n 1)
          if [ -z "$DEB_FILE" ]; then
            echo "No .deb file found for PPA publishing" >&2
            ls -la "$ARTIFACT_DIR" || true
            exit 1
          fi

          mkdir -p "$WORKDIR/publish"
          cp "$DEB_FILE" "$WORKDIR/publish/"
          cp "$ARTIFACT_DIR"/*.sha256 "$WORKDIR/publish/" 2>/dev/null || true

          echo "[publish_ppa] Local publish directory contents before signing:"
          ls -la "$WORKDIR/publish"

          echo "$GPG_SEC" > "$WORKDIR/Floorp_sec.asc"
          gpg --batch --import "$WORKDIR/Floorp_sec.asc"

          # Build FTP init/finish scripts from PPA credentials (masked via secrets)
          # These scripts will be placed at $WORKDIR/{init_script.txt,finish_script.txt}
          echo "open $PPA_FTP_URL" | tee -a "$WORKDIR/init_script.txt" "$WORKDIR/finish_script.txt" > /dev/null
          echo "user $PPA_FTP_USER $PPA_FTP_PASS" | tee -a "$WORKDIR/init_script.txt" "$WORKDIR/finish_script.txt" > /dev/null
          echo "prompt" | tee -a "$WORKDIR/init_script.txt" "$WORKDIR/finish_script.txt" > /dev/null
          echo "cd amd64" | tee -a "$WORKDIR/init_script.txt" "$WORKDIR/finish_script.txt" > /dev/null
          # Ensure binary transfer mode for .deb and compressed files
          echo "binary" | tee -a "$WORKDIR/init_script.txt" "$WORKDIR/finish_script.txt" > /dev/null
          echo "mget floorp-*.deb" >> "$WORKDIR/init_script.txt"

          # Also prepare lftp-compatible scripts for debug (lftp has better debug output)
          echo "set ftp:passive-mode true" | tee -a "$WORKDIR/init_lftp.txt" "$WORKDIR/finish_lftp.txt" > /dev/null
          echo "cd amd64" | tee -a "$WORKDIR/init_lftp.txt" "$WORKDIR/finish_lftp.txt" > /dev/null
          echo "mget floorp-*.deb" >> "$WORKDIR/init_lftp.txt"

          # Upload files to temporary names then rename to ensure atomic swaps
          DEB_NAME="${DEB_FILE##*/}"
          echo "put $DEB_NAME tmp.$DEB_NAME" >> "$WORKDIR/finish_script.txt"
          echo "rename tmp.$DEB_NAME $DEB_NAME" >> "$WORKDIR/finish_script.txt"

          echo "put Packages.gz tmp.Packages.gz" >> "$WORKDIR/finish_script.txt"
          echo "rename tmp.Packages.gz Packages.gz" >> "$WORKDIR/finish_script.txt"

          echo "put Packages tmp.Packages" >> "$WORKDIR/finish_script.txt"
          echo "rename tmp.Packages Packages" >> "$WORKDIR/finish_script.txt"

          # Upload Release to tmp and rename, then place signatures last
          echo "put Release tmp.Release" >> "$WORKDIR/finish_script.txt"
          echo "rename tmp.Release Release" >> "$WORKDIR/finish_script.txt"

          echo "put Release.gpg" >> "$WORKDIR/finish_script.txt"
          echo "put InRelease" >> "$WORKDIR/finish_script.txt"

          # Build lftp finish script (commands compatible with lftp)
          echo "set ftp:passive-mode true" > "$WORKDIR/finish_lftp.txt"
          echo "cd amd64" >> "$WORKDIR/finish_lftp.txt"
          echo "put $DEB_NAME -o tmp.$DEB_NAME" >> "$WORKDIR/finish_lftp.txt"
          echo "mv tmp.$DEB_NAME $DEB_NAME" >> "$WORKDIR/finish_lftp.txt"
          echo "put Packages.gz -o tmp.Packages.gz" >> "$WORKDIR/finish_lftp.txt"
          echo "mv tmp.Packages.gz Packages.gz" >> "$WORKDIR/finish_lftp.txt"
          echo "put Packages -o tmp.Packages" >> "$WORKDIR/finish_lftp.txt"
          echo "mv tmp.Packages Packages" >> "$WORKDIR/finish_lftp.txt"
          echo "put Release -o tmp.Release" >> "$WORKDIR/finish_lftp.txt"
          echo "mv tmp.Release Release" >> "$WORKDIR/finish_lftp.txt"
          echo "put Release.gpg" >> "$WORKDIR/finish_lftp.txt"
          echo "put InRelease" >> "$WORKDIR/finish_lftp.txt"
          echo "quit" >> "$WORKDIR/finish_lftp.txt"

          redact_script() {
            local file="$1"
            if [ -f "$file" ]; then
              perl -pe 's/((user|USER|pass|PASS)(\s+))[^\s]+/\1****/g' "$file"
            fi
          }

          echo "[publish_ppa] init_script preview (credentials masked):"
          redact_script "$WORKDIR/init_script.txt" || true
          echo "[publish_ppa] finish_script preview (credentials masked):"
          redact_script "$WORKDIR/finish_script.txt" || true

          cd "$WORKDIR/publish"
          echo "[publish_ppa] Working directory ls (pre-ftp init):"
          ls -la .
          echo "[publish_ppa] Starting FTP init script (lftp debug)..."
          lftp -d -u "$PPA_FTP_USER","$PPA_FTP_PASS" "$PPA_FTP_URL" -e "source ../init_lftp.txt; quit" || true

          dpkg-scanpackages --multiversion . > Packages
          gzip -k -f Packages
          apt-ftparchive release . > Release
          gpg --default-key "$GPG_SSB" -abs -o - Release > Release.gpg
          gpg --default-key "$GPG_SSB" --clearsign -o - Release > InRelease

          # Compute expected metadata fingerprints so we can verify CDN propagation later
          EXPECTED_SIZE=$(stat -c%s Packages.gz || true)
          EXPECTED_SHA256=$(sha256sum Packages.gz | cut -d' ' -f1 || true)
          CHECK_URL="https://ppa.floorp.app/amd64/Packages.gz"

          echo "[publish_ppa] Generated metadata files:"
          ls -la Packages* Release* InRelease || true

          echo "[publish_ppa] Starting FTP finish script (lftp debug)..."
          lftp -d -u "$PPA_FTP_USER","$PPA_FTP_PASS" "$PPA_FTP_URL" -e "source ../finish_lftp.txt; quit" || true

          # If Cloudflare credentials are provided, request a URL purge for Packages.gz
          if [ -n "${CF_API_TOKEN:-}" ] && [ -n "${CF_ZONE_ID:-}" ]; then
            echo "[publish_ppa] Cloudflare credentials found — requesting purge for $CHECK_URL"
            PAYLOAD=$(printf '{"files":["%s"]}' "$CHECK_URL")
            if curl -sS -X POST "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/purge_cache" \
              -H "Authorization: Bearer $CF_API_TOKEN" -H "Content-Type: application/json" --data "$PAYLOAD" >/dev/null 2>&1; then
              echo "[publish_ppa] Cloudflare purge request sent (response logged)."
            else
              echo "[publish_ppa] Cloudflare purge request failed (non-fatal)."
            fi
            # Give the CDN a moment
            sleep 3
          else
            echo "[publish_ppa] No Cloudflare credentials provided — skipping purge (will poll passively)."
          fi

          # Poll the public URL until size+sha256 match expected (up to ~10 minutes)
          ok=0
          for i in $(seq 1 120); do
            echo "[publish_ppa] Poll attempt $i: fetching $CHECK_URL"
            TMPF=$(mktemp)
            if curl -sSfL -o "$TMPF" "$CHECK_URL"; then
              S=$(stat -c%s "$TMPF" || echo 0)
              if [ "$S" -eq "$EXPECTED_SIZE" ]; then
                REMOTE_SHA=$(sha256sum "$TMPF" | cut -d' ' -f1)
                if [ "$REMOTE_SHA" = "$EXPECTED_SHA256" ]; then
                  echo "[publish_ppa] Remote Packages.gz matches expected (size and sha256)."
                  ok=1
                  rm -f "$TMPF"
                  break
                else
                  echo "[publish_ppa] Remote file size matches but sha256 differs (remote=$REMOTE_SHA expected=$EXPECTED_SHA256)"
                fi
              else
                echo "[publish_ppa] Remote size $S != expected $EXPECTED_SIZE"
              fi
            else
              echo "[publish_ppa] curl failed to fetch Packages.gz (attempt $i)"
            fi
            rm -f "$TMPF"
            sleep 5
          done
          if [ "$ok" -ne 1 ]; then
            echo "[publish_ppa] ERROR: Published Packages.gz did not propagate to CDN within timeout." >&2
            exit 1
          fi

          cd "$WORKDIR"
          echo "[publish_ppa] Cleanup directory listing:" 
          ls -la "$WORKDIR" || true
          rm -f init_script.txt finish_script.txt Floorp_sec.asc
