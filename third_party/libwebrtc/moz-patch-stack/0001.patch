From: Andreas Pehrson <apehrson@mozilla.com>
Date: Thu, 4 Apr 2024 00:16:21 +0200
Subject: (tmp-cherry-pick) Revert "Remove post-decode VAD" (687ef0a136)
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This reverts commit 89cf26f1e0532130745f648cf16b1fb8af2f6b4f.

Reason for revert: breaking upstream projects

Original change's description:
> Remove post-decode VAD
>
> Bug: webrtc:15806
> Change-Id: I6acf8734a70703085cfc1ccf82a79ee0931f59a4
> Reviewed-on: https://webrtc-review.googlesource.com/c/src/+/336460
> Reviewed-by: Sam Zackrisson <saza@webrtc.org>
> Commit-Queue: Tomas Lundqvist <tomasl@google.com>
> Reviewed-by: Jakob Ivarsson‎ <jakobi@webrtc.org>
> Cr-Commit-Position: refs/heads/main@{#41653}

Bug: webrtc:15806
Change-Id: I20e383a6b6d625d86830ecec1be01b42b22e86a2
No-Presubmit: true
No-Tree-Checks: true
No-Try: true
Reviewed-on: https://webrtc-review.googlesource.com/c/src/+/337420
Bot-Commit: rubber-stamper@appspot.gserviceaccount.com <rubber-stamper@appspot.gserviceaccount.com>
Owners-Override: Jeremy Leconte <jleconte@google.com>
Commit-Queue: Jeremy Leconte <jleconte@google.com>
Reviewed-by: Jakob Ivarsson‎ <jakobi@webrtc.org>
Cr-Commit-Position: refs/heads/main@{#41657}
---
 api/neteq/neteq.cc                            |  3 +-
 api/neteq/neteq.h                             |  8 ++
 modules/audio_coding/BUILD.gn                 |  3 +
 modules/audio_coding/acm2/acm_receiver.cc     |  6 +-
 .../acm2/acm_receiver_unittest.cc             | 59 ++++++++++++
 .../audio_coding/neteq/background_noise.cc    | 29 +++---
 modules/audio_coding/neteq/background_noise.h |  4 +-
 modules/audio_coding/neteq/neteq_impl.cc      | 71 +++++++++++++--
 modules/audio_coding/neteq/neteq_impl.h       | 11 +++
 modules/audio_coding/neteq/post_decode_vad.cc | 90 +++++++++++++++++++
 modules/audio_coding/neteq/post_decode_vad.h  | 71 +++++++++++++++
 .../neteq/post_decode_vad_unittest.cc         | 25 ++++++
 test/fuzzers/neteq_signal_fuzzer.cc           |  1 +
 13 files changed, 358 insertions(+), 23 deletions(-)
 create mode 100644 modules/audio_coding/neteq/post_decode_vad.cc
 create mode 100644 modules/audio_coding/neteq/post_decode_vad.h
 create mode 100644 modules/audio_coding/neteq/post_decode_vad_unittest.cc

diff --git a/api/neteq/neteq.cc b/api/neteq/neteq.cc
index d237def23a..155ddf2cf3 100644
--- a/api/neteq/neteq.cc
+++ b/api/neteq/neteq.cc
@@ -24,7 +24,8 @@ NetEq::Config& NetEq::Config::operator=(Config&&) = default;
 std::string NetEq::Config::ToString() const {
   char buf[1024];
   rtc::SimpleStringBuilder ss(buf);
-  ss << "sample_rate_hz=" << sample_rate_hz
+  ss << "sample_rate_hz=" << sample_rate_hz << ", enable_post_decode_vad="
+     << (enable_post_decode_vad ? "true" : "false")
      << ", max_packets_in_buffer=" << max_packets_in_buffer
      << ", min_delay_ms=" << min_delay_ms << ", enable_fast_accelerate="
      << (enable_fast_accelerate ? "true" : "false")
diff --git a/api/neteq/neteq.h b/api/neteq/neteq.h
index fc0c090254..43e0e09784 100644
--- a/api/neteq/neteq.h
+++ b/api/neteq/neteq.h
@@ -130,6 +130,7 @@ class NetEq {
     std::string ToString() const;
 
     int sample_rate_hz = 48000;  // Initial value. Will change with input data.
+    bool enable_post_decode_vad = false;
     size_t max_packets_in_buffer = 200;
     int max_delay_ms = 0;
     int min_delay_ms = 0;
@@ -277,6 +278,13 @@ class NetEq {
   // statistics are never reset.
   virtual NetEqOperationsAndState GetOperationsAndState() const = 0;
 
+  // Enables post-decode VAD. When enabled, GetAudio() will return
+  // kOutputVADPassive when the signal contains no speech.
+  virtual void EnableVad() = 0;
+
+  // Disables post-decode VAD.
+  virtual void DisableVad() = 0;
+
   // Returns the RTP timestamp for the last sample delivered by GetAudio().
   // The return value will be empty if no valid timestamp is available.
   virtual absl::optional<uint32_t> GetPlayoutTimestamp() const = 0;
diff --git a/modules/audio_coding/BUILD.gn b/modules/audio_coding/BUILD.gn
index 8b23955d5b..5de99efa45 100644
--- a/modules/audio_coding/BUILD.gn
+++ b/modules/audio_coding/BUILD.gn
@@ -689,6 +689,8 @@ rtc_library("neteq") {
     "neteq/packet_arrival_history.h",
     "neteq/packet_buffer.cc",
     "neteq/packet_buffer.h",
+    "neteq/post_decode_vad.cc",
+    "neteq/post_decode_vad.h",
     "neteq/preemptive_expand.cc",
     "neteq/preemptive_expand.h",
     "neteq/random_vector.cc",
@@ -1653,6 +1655,7 @@ if (rtc_include_tests) {
         "neteq/normal_unittest.cc",
         "neteq/packet_arrival_history_unittest.cc",
         "neteq/packet_buffer_unittest.cc",
+        "neteq/post_decode_vad_unittest.cc",
         "neteq/random_vector_unittest.cc",
         "neteq/red_payload_splitter_unittest.cc",
         "neteq/reorder_optimizer_unittest.cc",
diff --git a/modules/audio_coding/acm2/acm_receiver.cc b/modules/audio_coding/acm2/acm_receiver.cc
index 24a49024c8..a77e472ec1 100644
--- a/modules/audio_coding/acm2/acm_receiver.cc
+++ b/modules/audio_coding/acm2/acm_receiver.cc
@@ -50,7 +50,11 @@ std::unique_ptr<NetEq> CreateNetEq(
 
 AcmReceiver::Config::Config(
     rtc::scoped_refptr<AudioDecoderFactory> decoder_factory)
-    : clock(*Clock::GetRealTimeClock()), decoder_factory(decoder_factory) {}
+    : clock(*Clock::GetRealTimeClock()), decoder_factory(decoder_factory) {
+  // Post-decode VAD is disabled by default in NetEq, however, Audio
+  // Conference Mixer relies on VAD decisions and fails without them.
+  neteq_config.enable_post_decode_vad = true;
+}
 
 AcmReceiver::Config::Config(const Config&) = default;
 AcmReceiver::Config::~Config() = default;
diff --git a/modules/audio_coding/acm2/acm_receiver_unittest.cc b/modules/audio_coding/acm2/acm_receiver_unittest.cc
index 8b35f4a621..cda6688157 100644
--- a/modules/audio_coding/acm2/acm_receiver_unittest.cc
+++ b/modules/audio_coding/acm2/acm_receiver_unittest.cc
@@ -190,6 +190,9 @@ class AcmReceiverTestFaxModeOldApi : public AcmReceiverTestOldApi {
     const size_t output_channels = info.num_channels;
     const size_t samples_per_ms = rtc::checked_cast<size_t>(
         rtc::CheckedDivExact(output_sample_rate_hz, 1000));
+    const AudioFrame::VADActivity expected_vad_activity =
+        output_sample_rate_hz > 16000 ? AudioFrame::kVadActive
+                                      : AudioFrame::kVadPassive;
 
     // Expect the first output timestamp to be 5*fs/8000 samples before the
     // first inserted timestamp (because of NetEq's look-ahead). (This value is
@@ -214,6 +217,7 @@ class AcmReceiverTestFaxModeOldApi : public AcmReceiverTestOldApi {
         EXPECT_EQ(output_sample_rate_hz, frame.sample_rate_hz_);
         EXPECT_EQ(output_channels, frame.num_channels_);
         EXPECT_EQ(AudioFrame::kNormalSpeech, frame.speech_type_);
+        EXPECT_EQ(expected_vad_activity, frame.vad_activity_);
         EXPECT_FALSE(muted);
       }
     }
@@ -238,6 +242,61 @@ TEST_F(AcmReceiverTestFaxModeOldApi, MAYBE_VerifyAudioFrameOpus) {
   RunVerifyAudioFrame({"opus", 48000, 2});
 }
 
+#if defined(WEBRTC_ANDROID)
+#define MAYBE_PostdecodingVad DISABLED_PostdecodingVad
+#else
+#define MAYBE_PostdecodingVad PostdecodingVad
+#endif
+TEST_F(AcmReceiverTestOldApi, MAYBE_PostdecodingVad) {
+  EXPECT_TRUE(config_.neteq_config.enable_post_decode_vad);
+  constexpr int payload_type = 34;
+  const SdpAudioFormat codec = {"L16", 16000, 1};
+  const AudioCodecInfo info = SetEncoder(payload_type, codec);
+  receiver_->SetCodecs({{payload_type, codec}});
+  constexpr int kNumPackets = 5;
+  AudioFrame frame;
+  for (int n = 0; n < kNumPackets; ++n) {
+    const int num_10ms_frames = InsertOnePacketOfSilence(info);
+    for (int k = 0; k < num_10ms_frames; ++k) {
+      bool muted;
+      ASSERT_EQ(0, receiver_->GetAudio(info.sample_rate_hz, &frame, &muted));
+    }
+  }
+  EXPECT_EQ(AudioFrame::kVadPassive, frame.vad_activity_);
+}
+
+class AcmReceiverTestPostDecodeVadPassiveOldApi : public AcmReceiverTestOldApi {
+ protected:
+  AcmReceiverTestPostDecodeVadPassiveOldApi() {
+    config_.neteq_config.enable_post_decode_vad = false;
+  }
+};
+
+#if defined(WEBRTC_ANDROID)
+#define MAYBE_PostdecodingVad DISABLED_PostdecodingVad
+#else
+#define MAYBE_PostdecodingVad PostdecodingVad
+#endif
+TEST_F(AcmReceiverTestPostDecodeVadPassiveOldApi, MAYBE_PostdecodingVad) {
+  EXPECT_FALSE(config_.neteq_config.enable_post_decode_vad);
+  constexpr int payload_type = 34;
+  const SdpAudioFormat codec = {"L16", 16000, 1};
+  const AudioCodecInfo info = SetEncoder(payload_type, codec);
+  auto const value = encoder_factory_->QueryAudioEncoder(codec);
+  ASSERT_TRUE(value.has_value());
+  receiver_->SetCodecs({{payload_type, codec}});
+  const int kNumPackets = 5;
+  AudioFrame frame;
+  for (int n = 0; n < kNumPackets; ++n) {
+    const int num_10ms_frames = InsertOnePacketOfSilence(info);
+    for (int k = 0; k < num_10ms_frames; ++k) {
+      bool muted;
+      ASSERT_EQ(0, receiver_->GetAudio(info.sample_rate_hz, &frame, &muted));
+    }
+  }
+  EXPECT_EQ(AudioFrame::kVadUnknown, frame.vad_activity_);
+}
+
 #if defined(WEBRTC_ANDROID)
 #define MAYBE_LastAudioCodec DISABLED_LastAudioCodec
 #else
diff --git a/modules/audio_coding/neteq/background_noise.cc b/modules/audio_coding/neteq/background_noise.cc
index 0c33dba47a..2c95d3b390 100644
--- a/modules/audio_coding/neteq/background_noise.cc
+++ b/modules/audio_coding/neteq/background_noise.cc
@@ -17,6 +17,7 @@
 #include "common_audio/signal_processing/include/signal_processing_library.h"
 #include "modules/audio_coding/neteq/audio_multi_vector.h"
 #include "modules/audio_coding/neteq/cross_correlation.h"
+#include "modules/audio_coding/neteq/post_decode_vad.h"
 
 namespace webrtc {
 namespace {
@@ -43,11 +44,17 @@ void BackgroundNoise::Reset() {
   }
 }
 
-bool BackgroundNoise::Update(const AudioMultiVector& sync_buffer) {
+bool BackgroundNoise::Update(const AudioMultiVector& input,
+                             const PostDecodeVad& vad) {
   bool filter_params_saved = false;
+  if (vad.running() && vad.active_speech()) {
+    // Do not update the background noise parameters if we know that the signal
+    // is active speech.
+    return filter_params_saved;
+  }
 
   int32_t auto_correlation[kMaxLpcOrder + 1];
-  int16_t filter_output[kMaxLpcOrder + kResidualLength];
+  int16_t fiter_output[kMaxLpcOrder + kResidualLength];
   int16_t reflection_coefficients[kMaxLpcOrder];
   int16_t lpc_coefficients[kMaxLpcOrder + 1];
 
@@ -55,13 +62,14 @@ bool BackgroundNoise::Update(const AudioMultiVector& sync_buffer) {
     ChannelParameters& parameters = channel_parameters_[channel_ix];
     int16_t temp_signal_array[kVecLen + kMaxLpcOrder] = {0};
     int16_t* temp_signal = &temp_signal_array[kMaxLpcOrder];
-    RTC_DCHECK_GE(sync_buffer.Size(), kVecLen);
-    sync_buffer[channel_ix].CopyTo(kVecLen, sync_buffer.Size() - kVecLen,
-                                   temp_signal);
+    RTC_DCHECK_GE(input.Size(), kVecLen);
+    input[channel_ix].CopyTo(kVecLen, input.Size() - kVecLen, temp_signal);
     int32_t sample_energy =
         CalculateAutoCorrelation(temp_signal, kVecLen, auto_correlation);
 
-    if (sample_energy < parameters.energy_update_threshold) {
+    if ((!vad.running() &&
+         sample_energy < parameters.energy_update_threshold) ||
+        (vad.running() && !vad.active_speech())) {
       // Generate LPC coefficients.
       if (auto_correlation[0] <= 0) {
         // Center value in auto-correlation is not positive. Do not update.
@@ -87,10 +95,10 @@ bool BackgroundNoise::Update(const AudioMultiVector& sync_buffer) {
 
       // Generate the CNG gain factor by looking at the energy of the residual.
       WebRtcSpl_FilterMAFastQ12(temp_signal + kVecLen - kResidualLength,
-                                filter_output, lpc_coefficients,
+                                fiter_output, lpc_coefficients,
                                 kMaxLpcOrder + 1, kResidualLength);
       int32_t residual_energy = WebRtcSpl_DotProductWithScale(
-          filter_output, filter_output, kResidualLength, 0);
+          fiter_output, fiter_output, kResidualLength, 0);
 
       // Check spectral flatness.
       // Comparing the residual variance with the input signal variance tells
@@ -109,8 +117,9 @@ bool BackgroundNoise::Update(const AudioMultiVector& sync_buffer) {
         filter_params_saved = true;
       }
     } else {
-      // Will only happen if `sample_energy` is not low enough. Increase the
-      // threshold for update so that it increases by a factor 4 in 4 seconds.
+      // Will only happen if post-decode VAD is disabled and `sample_energy` is
+      // not low enough. Increase the threshold for update so that it increases
+      // by a factor 4 in 4 seconds.
       IncrementEnergyThreshold(channel_ix, sample_energy);
     }
   }
diff --git a/modules/audio_coding/neteq/background_noise.h b/modules/audio_coding/neteq/background_noise.h
index 9ef0131c92..8e6d5890a0 100644
--- a/modules/audio_coding/neteq/background_noise.h
+++ b/modules/audio_coding/neteq/background_noise.h
@@ -39,9 +39,9 @@ class BackgroundNoise {
   void Reset();
 
   // Updates the parameter estimates based on the signal currently in the
-  // `sync_buffer`.
+  // `sync_buffer`, and on the latest decision in `vad` if it is running.
   // Returns true if the filter parameters are updated.
-  bool Update(const AudioMultiVector& sync_buffer);
+  bool Update(const AudioMultiVector& sync_buffer, const PostDecodeVad& vad);
 
   // Generates background noise given a random vector and writes the output to
   // `buffer`.
diff --git a/modules/audio_coding/neteq/neteq_impl.cc b/modules/audio_coding/neteq/neteq_impl.cc
index 81b46e20e2..e5c8bf6c08 100644
--- a/modules/audio_coding/neteq/neteq_impl.cc
+++ b/modules/audio_coding/neteq/neteq_impl.cc
@@ -36,6 +36,7 @@
 #include "modules/audio_coding/neteq/normal.h"
 #include "modules/audio_coding/neteq/packet.h"
 #include "modules/audio_coding/neteq/packet_buffer.h"
+#include "modules/audio_coding/neteq/post_decode_vad.h"
 #include "modules/audio_coding/neteq/preemptive_expand.h"
 #include "modules/audio_coding/neteq/red_payload_splitter.h"
 #include "modules/audio_coding/neteq/statistics_calculator.h"
@@ -69,26 +70,49 @@ std::unique_ptr<NetEqController> CreateNetEqController(
   return controller_factory.CreateNetEqController(config);
 }
 
-AudioFrame::SpeechType ToSpeechType(NetEqImpl::OutputType type) {
+void SetAudioFrameActivityAndType(bool vad_enabled,
+                                  NetEqImpl::OutputType type,
+                                  AudioFrame::VADActivity last_vad_activity,
+                                  AudioFrame* audio_frame) {
   switch (type) {
     case NetEqImpl::OutputType::kNormalSpeech: {
-      return AudioFrame::kNormalSpeech;
+      audio_frame->speech_type_ = AudioFrame::kNormalSpeech;
+      audio_frame->vad_activity_ = AudioFrame::kVadActive;
+      break;
+    }
+    case NetEqImpl::OutputType::kVadPassive: {
+      // This should only be reached if the VAD is enabled.
+      RTC_DCHECK(vad_enabled);
+      audio_frame->speech_type_ = AudioFrame::kNormalSpeech;
+      audio_frame->vad_activity_ = AudioFrame::kVadPassive;
+      break;
     }
     case NetEqImpl::OutputType::kCNG: {
-      return AudioFrame::kCNG;
+      audio_frame->speech_type_ = AudioFrame::kCNG;
+      audio_frame->vad_activity_ = AudioFrame::kVadPassive;
+      break;
     }
     case NetEqImpl::OutputType::kPLC: {
-      return AudioFrame::kPLC;
+      audio_frame->speech_type_ = AudioFrame::kPLC;
+      audio_frame->vad_activity_ = last_vad_activity;
+      break;
     }
     case NetEqImpl::OutputType::kPLCCNG: {
-      return AudioFrame::kPLCCNG;
+      audio_frame->speech_type_ = AudioFrame::kPLCCNG;
+      audio_frame->vad_activity_ = AudioFrame::kVadPassive;
+      break;
     }
     case NetEqImpl::OutputType::kCodecPLC: {
-      return AudioFrame::kCodecPLC;
+      audio_frame->speech_type_ = AudioFrame::kCodecPLC;
+      audio_frame->vad_activity_ = last_vad_activity;
+      break;
     }
     default:
       RTC_DCHECK_NOTREACHED();
-      return AudioFrame::kUndefined;
+  }
+  if (!vad_enabled) {
+    // Always set kVadUnknown when receive VAD is inactive.
+    audio_frame->vad_activity_ = AudioFrame::kVadUnknown;
   }
 }
 
@@ -145,6 +169,7 @@ NetEqImpl::NetEqImpl(const NetEq::Config& config,
       packet_buffer_(std::move(deps.packet_buffer)),
       red_payload_splitter_(std::move(deps.red_payload_splitter)),
       timestamp_scaler_(std::move(deps.timestamp_scaler)),
+      vad_(new PostDecodeVad()),
       expand_factory_(std::move(deps.expand_factory)),
       accelerate_factory_(std::move(deps.accelerate_factory)),
       preemptive_expand_factory_(std::move(deps.preemptive_expand_factory)),
@@ -186,6 +211,10 @@ NetEqImpl::NetEqImpl(const NetEq::Config& config,
   if (create_components) {
     SetSampleRateAndChannels(fs, 1);  // Default is 1 channel.
   }
+  RTC_DCHECK(!vad_->enabled());
+  if (config.enable_post_decode_vad) {
+    vad_->Enable();
+  }
 }
 
 NetEqImpl::~NetEqImpl() = default;
@@ -223,7 +252,9 @@ int NetEqImpl::GetAudio(AudioFrame* audio_frame,
       audio_frame->sample_rate_hz_,
       rtc::dchecked_cast<int>(audio_frame->samples_per_channel_ * 100));
   RTC_DCHECK_EQ(*muted, audio_frame->muted());
-  audio_frame->speech_type_ = ToSpeechType(LastOutputType());
+  SetAudioFrameActivityAndType(vad_->enabled(), LastOutputType(),
+                               last_vad_activity_, audio_frame);
+  last_vad_activity_ = audio_frame->vad_activity_;
   last_output_sample_rate_hz_ = audio_frame->sample_rate_hz_;
   RTC_DCHECK(last_output_sample_rate_hz_ == 8000 ||
              last_output_sample_rate_hz_ == 16000 ||
@@ -367,6 +398,18 @@ NetEqOperationsAndState NetEqImpl::GetOperationsAndState() const {
   return result;
 }
 
+void NetEqImpl::EnableVad() {
+  MutexLock lock(&mutex_);
+  RTC_DCHECK(vad_.get());
+  vad_->Enable();
+}
+
+void NetEqImpl::DisableVad() {
+  MutexLock lock(&mutex_);
+  RTC_DCHECK(vad_.get());
+  vad_->Disable();
+}
+
 absl::optional<uint32_t> NetEqImpl::GetPlayoutTimestamp() const {
   MutexLock lock(&mutex_);
   if (first_packet_ || last_mode_ == Mode::kRfc3389Cng ||
@@ -815,8 +858,11 @@ int NetEqImpl::GetAudioInternal(AudioFrame* audio_frame,
     last_decoded_type_ = speech_type;
   }
 
+  RTC_DCHECK(vad_.get());
   bool sid_frame_available =
       (operation == Operation::kRfc3389Cng && !packet_list.empty());
+  vad_->Update(decoded_buffer_.get(), static_cast<size_t>(length), speech_type,
+               sid_frame_available, fs_hz_);
 
   // This is the criterion that we did decode some data through the speech
   // decoder, and the operation resulted in comfort noise.
@@ -966,7 +1012,7 @@ int NetEqImpl::GetAudioInternal(AudioFrame* audio_frame,
       (last_mode_ == Mode::kPreemptiveExpandFail) ||
       (last_mode_ == Mode::kRfc3389Cng) ||
       (last_mode_ == Mode::kCodecInternalCng)) {
-    background_noise_->Update(*sync_buffer_);
+    background_noise_->Update(*sync_buffer_, *vad_.get());
   }
 
   if (operation == Operation::kDtmf) {
@@ -2042,6 +2088,10 @@ void NetEqImpl::SetSampleRateAndChannels(int fs_hz, size_t channels) {
   if (cng_decoder)
     cng_decoder->Reset();
 
+  // Reinit post-decode VAD with new sample rate.
+  RTC_DCHECK(vad_.get());  // Cannot be NULL here.
+  vad_->Init();
+
   // Delete algorithm buffer and create a new one.
   algorithm_buffer_.reset(new AudioMultiVector(channels));
 
@@ -2082,6 +2132,7 @@ void NetEqImpl::SetSampleRateAndChannels(int fs_hz, size_t channels) {
 }
 
 NetEqImpl::OutputType NetEqImpl::LastOutputType() {
+  RTC_DCHECK(vad_.get());
   RTC_DCHECK(expand_.get());
   if (last_mode_ == Mode::kCodecInternalCng ||
       last_mode_ == Mode::kRfc3389Cng) {
@@ -2091,6 +2142,8 @@ NetEqImpl::OutputType NetEqImpl::LastOutputType() {
     return OutputType::kPLCCNG;
   } else if (last_mode_ == Mode::kExpand) {
     return OutputType::kPLC;
+  } else if (vad_->running() && !vad_->active_speech()) {
+    return OutputType::kVadPassive;
   } else if (last_mode_ == Mode::kCodecPlc) {
     return OutputType::kCodecPLC;
   } else {
diff --git a/modules/audio_coding/neteq/neteq_impl.h b/modules/audio_coding/neteq/neteq_impl.h
index 6ccbde7293..f8f2b06410 100644
--- a/modules/audio_coding/neteq/neteq_impl.h
+++ b/modules/audio_coding/neteq/neteq_impl.h
@@ -48,6 +48,7 @@ class Merge;
 class NackTracker;
 class Normal;
 class RedPayloadSplitter;
+class PostDecodeVad;
 class PreemptiveExpand;
 class RandomVector;
 class SyncBuffer;
@@ -170,6 +171,13 @@ class NetEqImpl : public webrtc::NetEq {
 
   NetEqOperationsAndState GetOperationsAndState() const override;
 
+  // Enables post-decode VAD. When enabled, GetAudio() will return
+  // kOutputVADPassive when the signal contains no speech.
+  void EnableVad() override;
+
+  // Disables post-decode VAD.
+  void DisableVad() override;
+
   absl::optional<uint32_t> GetPlayoutTimestamp() const override;
 
   int last_output_sample_rate_hz() const override;
@@ -348,6 +356,7 @@ class NetEqImpl : public webrtc::NetEq {
       RTC_GUARDED_BY(mutex_);
   const std::unique_ptr<TimestampScaler> timestamp_scaler_
       RTC_GUARDED_BY(mutex_);
+  const std::unique_ptr<PostDecodeVad> vad_ RTC_GUARDED_BY(mutex_);
   const std::unique_ptr<ExpandFactory> expand_factory_ RTC_GUARDED_BY(mutex_);
   const std::unique_ptr<AccelerateFactory> accelerate_factory_
       RTC_GUARDED_BY(mutex_);
@@ -388,6 +397,8 @@ class NetEqImpl : public webrtc::NetEq {
   std::unique_ptr<NackTracker> nack_ RTC_GUARDED_BY(mutex_);
   bool nack_enabled_ RTC_GUARDED_BY(mutex_);
   const bool enable_muted_state_ RTC_GUARDED_BY(mutex_);
+  AudioFrame::VADActivity last_vad_activity_ RTC_GUARDED_BY(mutex_) =
+      AudioFrame::kVadPassive;
   std::unique_ptr<TickTimer::Stopwatch> generated_noise_stopwatch_
       RTC_GUARDED_BY(mutex_);
   std::vector<RtpPacketInfo> last_decoded_packet_infos_ RTC_GUARDED_BY(mutex_);
diff --git a/modules/audio_coding/neteq/post_decode_vad.cc b/modules/audio_coding/neteq/post_decode_vad.cc
new file mode 100644
index 0000000000..9999d6764b
--- /dev/null
+++ b/modules/audio_coding/neteq/post_decode_vad.cc
@@ -0,0 +1,90 @@
+/*
+ *  Copyright (c) 2013 The WebRTC project authors. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ */
+
+#include "modules/audio_coding/neteq/post_decode_vad.h"
+
+namespace webrtc {
+
+PostDecodeVad::~PostDecodeVad() {
+  if (vad_instance_)
+    WebRtcVad_Free(vad_instance_);
+}
+
+void PostDecodeVad::Enable() {
+  if (!vad_instance_) {
+    // Create the instance.
+    vad_instance_ = WebRtcVad_Create();
+    if (vad_instance_ == nullptr) {
+      // Failed to create instance.
+      Disable();
+      return;
+    }
+  }
+  Init();
+  enabled_ = true;
+}
+
+void PostDecodeVad::Disable() {
+  enabled_ = false;
+  running_ = false;
+}
+
+void PostDecodeVad::Init() {
+  running_ = false;
+  if (vad_instance_) {
+    WebRtcVad_Init(vad_instance_);
+    WebRtcVad_set_mode(vad_instance_, kVadMode);
+    running_ = true;
+  }
+}
+
+void PostDecodeVad::Update(int16_t* signal,
+                           size_t length,
+                           AudioDecoder::SpeechType speech_type,
+                           bool sid_frame,
+                           int fs_hz) {
+  if (!vad_instance_ || !enabled_) {
+    return;
+  }
+
+  if (speech_type == AudioDecoder::kComfortNoise || sid_frame ||
+      fs_hz > 16000) {
+    // TODO(hlundin): Remove restriction on fs_hz.
+    running_ = false;
+    active_speech_ = true;
+    sid_interval_counter_ = 0;
+  } else if (!running_) {
+    ++sid_interval_counter_;
+  }
+
+  if (sid_interval_counter_ >= kVadAutoEnable) {
+    Init();
+  }
+
+  if (length > 0 && running_) {
+    size_t vad_sample_index = 0;
+    active_speech_ = false;
+    // Loop through frame sizes 30, 20, and 10 ms.
+    for (int vad_frame_size_ms = 30; vad_frame_size_ms >= 10;
+         vad_frame_size_ms -= 10) {
+      size_t vad_frame_size_samples =
+          static_cast<size_t>(vad_frame_size_ms * fs_hz / 1000);
+      while (length - vad_sample_index >= vad_frame_size_samples) {
+        int vad_return =
+            WebRtcVad_Process(vad_instance_, fs_hz, &signal[vad_sample_index],
+                              vad_frame_size_samples);
+        active_speech_ |= (vad_return == 1);
+        vad_sample_index += vad_frame_size_samples;
+      }
+    }
+  }
+}
+
+}  // namespace webrtc
diff --git a/modules/audio_coding/neteq/post_decode_vad.h b/modules/audio_coding/neteq/post_decode_vad.h
new file mode 100644
index 0000000000..3bd91b9edb
--- /dev/null
+++ b/modules/audio_coding/neteq/post_decode_vad.h
@@ -0,0 +1,71 @@
+/*
+ *  Copyright (c) 2013 The WebRTC project authors. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ */
+
+#ifndef MODULES_AUDIO_CODING_NETEQ_POST_DECODE_VAD_H_
+#define MODULES_AUDIO_CODING_NETEQ_POST_DECODE_VAD_H_
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include "api/audio_codecs/audio_decoder.h"
+#include "common_audio/vad/include/webrtc_vad.h"
+
+namespace webrtc {
+
+class PostDecodeVad {
+ public:
+  PostDecodeVad()
+      : enabled_(false),
+        running_(false),
+        active_speech_(true),
+        sid_interval_counter_(0),
+        vad_instance_(NULL) {}
+
+  virtual ~PostDecodeVad();
+
+  PostDecodeVad(const PostDecodeVad&) = delete;
+  PostDecodeVad& operator=(const PostDecodeVad&) = delete;
+
+  // Enables post-decode VAD.
+  void Enable();
+
+  // Disables post-decode VAD.
+  void Disable();
+
+  // Initializes post-decode VAD.
+  void Init();
+
+  // Updates post-decode VAD with the audio data in `signal` having `length`
+  // samples. The data is of type `speech_type`, at the sample rate `fs_hz`.
+  void Update(int16_t* signal,
+              size_t length,
+              AudioDecoder::SpeechType speech_type,
+              bool sid_frame,
+              int fs_hz);
+
+  // Accessors.
+  bool enabled() const { return enabled_; }
+  bool running() const { return running_; }
+  bool active_speech() const { return active_speech_; }
+
+ private:
+  static const int kVadMode = 0;  // Sets aggressiveness to "Normal".
+  // Number of Update() calls without CNG/SID before re-enabling VAD.
+  static const int kVadAutoEnable = 3000;
+
+  bool enabled_;
+  bool running_;
+  bool active_speech_;
+  int sid_interval_counter_;
+  ::VadInst* vad_instance_;
+};
+
+}  // namespace webrtc
+#endif  // MODULES_AUDIO_CODING_NETEQ_POST_DECODE_VAD_H_
diff --git a/modules/audio_coding/neteq/post_decode_vad_unittest.cc b/modules/audio_coding/neteq/post_decode_vad_unittest.cc
new file mode 100644
index 0000000000..da3e4e864e
--- /dev/null
+++ b/modules/audio_coding/neteq/post_decode_vad_unittest.cc
@@ -0,0 +1,25 @@
+/*
+ *  Copyright (c) 2013 The WebRTC project authors. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ */
+
+// Unit tests for PostDecodeVad class.
+
+#include "modules/audio_coding/neteq/post_decode_vad.h"
+
+#include "test/gtest.h"
+
+namespace webrtc {
+
+TEST(PostDecodeVad, CreateAndDestroy) {
+  PostDecodeVad vad;
+}
+
+// TODO(hlundin): Write more tests.
+
+}  // namespace webrtc
diff --git a/test/fuzzers/neteq_signal_fuzzer.cc b/test/fuzzers/neteq_signal_fuzzer.cc
index 3b1f70cdb4..485c38085e 100644
--- a/test/fuzzers/neteq_signal_fuzzer.cc
+++ b/test/fuzzers/neteq_signal_fuzzer.cc
@@ -179,6 +179,7 @@ void FuzzOneInputTest(const uint8_t* data, size_t size) {
   // Configure NetEq and the NetEqTest object.
   NetEqTest::Callbacks callbacks;
   NetEq::Config config;
+  config.enable_post_decode_vad = true;
   config.enable_fast_accelerate = true;
   auto codecs = NetEqTest::StandardDecoderMap();
   // rate_types contains the payload types that will be used for encoding.
