From: Nicolas Grunbaum <ngrunbaum@mozilla.com>
Date: Mon, 29 Apr 2024 20:32:34 -0700
Subject: (tmp-cherry-pick) Revert "Deprecate old constructors and set_type()
 in Candidate and Port" (ed8390d21a)

This reverts commit aaa6851d53741179a591d79fc82c4dd6651a7ba5.

Reason for revert: breaks chromium webrtc import

Original change's description:
> Deprecate old constructors and set_type() in Candidate and Port
>
> * Deprecates constructors that use string based `type`
> * Deprecates string based type functions in favor of enum based.
> * Restrict possible values of Candidate::type. Ensure a valid value
>   is assigned at construction.
> * Make Port constructors protected to limit their use to subclasses.
>   - The reason for this is to make sure that use of SharedSocket()
>     is controlled (it adds a bit of complexity).
> * Simplify construction of Port (remove Construct() etc)
>
> Bug: webrtc:15846
> Change-Id: If24ed674e175642efa49da37fd2bc847dd14f613
> Reviewed-on: https://webrtc-review.googlesource.com/c/src/+/339860
> Reviewed-by: Harald Alvestrand <hta@webrtc.org>
> Commit-Queue: Tomas Gunnarsson <tommi@webrtc.org>
> Cr-Commit-Position: refs/heads/main@{#41865}

Bug: webrtc:15846
Change-Id: Ic8b7cba97f8fb207ef51a88900e704658ade28b7
No-Presubmit: true
No-Tree-Checks: true
No-Try: true
Reviewed-on: https://webrtc-review.googlesource.com/c/src/+/342140
Auto-Submit: Ilya Nikolaevskiy <ilnik@webrtc.org>
Owners-Override: Ilya Nikolaevskiy <ilnik@webrtc.org>
Commit-Queue: Ilya Nikolaevskiy <ilnik@webrtc.org>
Bot-Commit: rubber-stamper@appspot.gserviceaccount.com <rubber-stamper@appspot.gserviceaccount.com>
Cr-Commit-Position: refs/heads/main@{#41867}
---
 api/candidate.h                            |  33 ++--
 p2p/base/connection.cc                     |  14 +-
 p2p/base/fake_port_allocator.h             |   2 +-
 p2p/base/p2p_transport_channel.cc          |  20 +-
 p2p/base/p2p_transport_channel_unittest.cc | 219 ++++++++-------------
 p2p/base/port.cc                           |  79 ++++----
 p2p/base/port.h                            | 107 ++--------
 p2p/base/port_allocator_unittest.cc        |  14 +-
 p2p/base/port_interface.h                  |   1 -
 p2p/base/port_unittest.cc                  |  30 ++-
 p2p/base/stun_port.cc                      |  11 +-
 p2p/base/stun_port.h                       |  14 +-
 p2p/base/tcp_port.cc                       |  14 +-
 p2p/base/turn_port.cc                      |  10 +-
 p2p/base/turn_port_unittest.cc             |   4 +-
 pc/jsep_session_description_unittest.cc    |  34 ++--
 pc/legacy_stats_collector_unittest.cc      |   4 +-
 pc/peer_connection_bundle_unittest.cc      |   1 +
 pc/peer_connection_ice_unittest.cc         |   2 +-
 pc/rtc_stats_collector_unittest.cc         |  40 ++--
 pc/webrtc_sdp.cc                           |  10 +-
 pc/webrtc_sdp_unittest.cc                  |  53 ++---
 22 files changed, 291 insertions(+), 425 deletions(-)

diff --git a/api/candidate.h b/api/candidate.h
index 149da35fc6..95359620c4 100644
--- a/api/candidate.h
+++ b/api/candidate.h
@@ -57,18 +57,18 @@ class RTC_EXPORT Candidate {
             absl::string_view foundation,
             uint16_t network_id = 0,
             uint16_t network_cost = 0);
-  [[deprecated("Use IceCandidateType version")]] Candidate(
-      int component,
-      absl::string_view protocol,
-      const rtc::SocketAddress& address,
-      uint32_t priority,
-      absl::string_view username,
-      absl::string_view password,
-      absl::string_view type ABSL_ATTRIBUTE_LIFETIME_BOUND,
-      uint32_t generation,
-      absl::string_view foundation,
-      uint16_t network_id = 0,
-      uint16_t network_cost = 0);
+  // TODO(tommi): Deprecate.
+  Candidate(int component,
+            absl::string_view protocol,
+            const rtc::SocketAddress& address,
+            uint32_t priority,
+            absl::string_view username,
+            absl::string_view password,
+            absl::string_view type ABSL_ATTRIBUTE_LIFETIME_BOUND,
+            uint32_t generation,
+            absl::string_view foundation,
+            uint16_t network_id = 0,
+            uint16_t network_cost = 0);
   Candidate(const Candidate&);
   ~Candidate();
 
@@ -77,10 +77,7 @@ class RTC_EXPORT Candidate {
   // Generates a new, 8 character long, id.
   void generate_id();
   // TODO(tommi): Callers should use generate_id(). Remove.
-  [[deprecated("Use IceCandidateType version")]] void set_id(
-      absl::string_view id) {
-    Assign(id_, id);
-  }
+  [[deprecated]] void set_id(absl::string_view id) { Assign(id_, id); }
 
   int component() const { return component_; }
   void set_component(int component) { component_ = component; }
@@ -127,8 +124,8 @@ class RTC_EXPORT Candidate {
   // things down. See also the `Port` class.
   void set_type(webrtc::IceCandidateType type) { type_ = type; }
 
-  [[deprecated("Use IceCandidateType version")]] void set_type(
-      absl::string_view type ABSL_ATTRIBUTE_LIFETIME_BOUND);
+  // TODO(tommi): Deprecate.
+  void set_type(absl::string_view type ABSL_ATTRIBUTE_LIFETIME_BOUND);
 
   // Simple checkers for checking the candidate type without dependency on the
   // IceCandidateType enum. The `is_local()` and `is_stun()` names are legacy
diff --git a/p2p/base/connection.cc b/p2p/base/connection.cc
index 996ea995c2..b601940667 100644
--- a/p2p/base/connection.cc
+++ b/p2p/base/connection.cc
@@ -43,8 +43,6 @@
 namespace cricket {
 namespace {
 
-using webrtc::IceCandidateType;
-
 // Determines whether we have seen at least the given maximum number of
 // pings fail to have a response.
 inline bool TooManyFailures(
@@ -77,16 +75,16 @@ inline bool TooLongWithoutResponse(
 
 // Helper methods for converting string values of log description fields to
 // enum.
-IceCandidateType GetRtcEventLogCandidateType(const Candidate& c) {
+webrtc::IceCandidateType GetRtcEventLogCandidateType(const Candidate& c) {
   if (c.is_local()) {
-    return IceCandidateType::kHost;
+    return webrtc::IceCandidateType::kHost;
   } else if (c.is_stun()) {
-    return IceCandidateType::kSrflx;
+    return webrtc::IceCandidateType::kSrflx;
   } else if (c.is_prflx()) {
-    return IceCandidateType::kPrflx;
+    return webrtc::IceCandidateType::kPrflx;
   }
   RTC_DCHECK(c.is_relay());
-  return IceCandidateType::kRelay;
+  return webrtc::IceCandidateType::kRelay;
 }
 
 webrtc::IceCandidatePairProtocol GetProtocolByString(
@@ -1694,7 +1692,7 @@ void Connection::MaybeUpdateLocalCandidate(StunRequest* request,
 
   // Create a peer-reflexive candidate based on the local candidate.
   local_candidate_.generate_id();
-  local_candidate_.set_type(IceCandidateType::kPrflx);
+  local_candidate_.set_type(PRFLX_PORT_TYPE);
   // Set the related address and foundation attributes before changing the
   // address.
   local_candidate_.set_related_address(local_candidate_.address());
diff --git a/p2p/base/fake_port_allocator.h b/p2p/base/fake_port_allocator.h
index 9372c5ada0..a51a7ca4ee 100644
--- a/p2p/base/fake_port_allocator.h
+++ b/p2p/base/fake_port_allocator.h
@@ -64,7 +64,7 @@ class TestUDPPort : public UDPPort {
               bool emit_localhost_for_anyaddress,
               const webrtc::FieldTrialsView* field_trials)
       : UDPPort(thread,
-                webrtc::IceCandidateType::kHost,
+                LOCAL_PORT_TYPE,
                 factory,
                 network,
                 min_port,
diff --git a/p2p/base/p2p_transport_channel.cc b/p2p/base/p2p_transport_channel.cc
index 07b6d2eb2d..bd6f0bdb3a 100644
--- a/p2p/base/p2p_transport_channel.cc
+++ b/p2p/base/p2p_transport_channel.cc
@@ -53,6 +53,18 @@ using ::webrtc::RTCErrorType;
 using ::webrtc::SafeTask;
 using ::webrtc::TimeDelta;
 
+IceCandidateType PortTypeToIceCandidateType(PortInterface* port) {
+  auto type = port->Type();
+  if (type == LOCAL_PORT_TYPE)
+    return IceCandidateType::kHost;
+  if (type == STUN_PORT_TYPE)
+    return IceCandidateType::kSrflx;
+  if (type == PRFLX_PORT_TYPE)
+    return IceCandidateType::kPrflx;
+  RTC_DCHECK_EQ(type, RELAY_PORT_TYPE);
+  return IceCandidateType::kRelay;
+}
+
 cricket::PortInterface::CandidateOrigin GetOrigin(
     cricket::PortInterface* port,
     cricket::PortInterface* origin_port) {
@@ -1071,8 +1083,8 @@ void P2PTransportChannel::OnUnknownAddress(PortInterface* port,
     // candidate.
     remote_candidate = Candidate(
         component(), ProtoToString(proto), address, remote_candidate_priority,
-        remote_username, remote_password, IceCandidateType::kPrflx,
-        remote_generation, "", network_id, network_cost);
+        remote_username, remote_password, PRFLX_PORT_TYPE, remote_generation,
+        "", network_id, network_cost);
     if (proto == PROTO_TCP) {
       remote_candidate.set_tcptype(TCPTYPE_ACTIVE_STR);
     }
@@ -1410,12 +1422,12 @@ bool P2PTransportChannel::CreateConnection(PortInterface* port,
   }
 
   if (ice_field_trials_.skip_relay_to_non_relay_connections) {
-    IceCandidateType port_type = PortTypeToIceCandidateType(port->Type());
+    IceCandidateType port_type = PortTypeToIceCandidateType(port);
     if ((port_type != remote_candidate.type()) &&
         (port_type == IceCandidateType::kRelay ||
          remote_candidate.is_relay())) {
       RTC_LOG(LS_INFO) << ToString() << ": skip creating connection "
-                       << webrtc::IceCandidateTypeToString(port_type) << " to "
+                       << port->Type() << " to "
                        << remote_candidate.type_name();
       return false;
     }
diff --git a/p2p/base/p2p_transport_channel_unittest.cc b/p2p/base/p2p_transport_channel_unittest.cc
index e689ab0ad0..69ea4287e8 100644
--- a/p2p/base/p2p_transport_channel_unittest.cc
+++ b/p2p/base/p2p_transport_channel_unittest.cc
@@ -154,7 +154,7 @@ cricket::IceConfig CreateIceConfig(
   return config;
 }
 
-cricket::Candidate CreateUdpCandidate(IceCandidateType type,
+cricket::Candidate CreateUdpCandidate(absl::string_view type,
                                       absl::string_view ip,
                                       int port,
                                       int priority,
@@ -2128,9 +2128,9 @@ TEST_F(P2PTransportChannelTest, TurnToTurnPresumedWritable) {
   // Add two remote candidates; a host candidate (with higher priority)
   // and TURN candidate.
   ep1_ch1()->AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 100));
+      CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 100));
   ep1_ch1()->AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kRelay, "2.2.2.2", 2, 0));
+      CreateUdpCandidate(RELAY_PORT_TYPE, "2.2.2.2", 2, 0));
   // Expect that the TURN-TURN candidate pair will be prioritized since it's
   // "probably writable".
   EXPECT_TRUE_WAIT(ep1_ch1()->selected_connection() != nullptr, kShortTimeout);
@@ -2226,7 +2226,7 @@ TEST_F(P2PTransportChannelTest, PresumedWritablePreferredOverUnreliable) {
   // Add a remote TURN candidate. The first channel should still have a TURN
   // port available to make a TURN<->TURN pair that's presumed writable.
   ep1_ch1()->AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kRelay, "2.2.2.2", 2, 0));
+      CreateUdpCandidate(RELAY_PORT_TYPE, "2.2.2.2", 2, 0));
   EXPECT_TRUE(LocalCandidate(ep1_ch1())->is_relay());
   EXPECT_TRUE(RemoteCandidate(ep1_ch1())->is_relay());
   EXPECT_TRUE(ep1_ch1()->writable());
@@ -2252,7 +2252,7 @@ TEST_F(P2PTransportChannelTest, SignalReadyToSendWithPresumedWritable) {
   EXPECT_EQ_WAIT(IceGatheringState::kIceGatheringComplete,
                  ep1_ch1()->gathering_state(), kDefaultTimeout);
   ep1_ch1()->AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kRelay, "1.1.1.1", 1, 0));
+      CreateUdpCandidate(RELAY_PORT_TYPE, "1.1.1.1", 1, 0));
   // Sanity checking the type of the connection.
   EXPECT_TRUE_WAIT(ep1_ch1()->selected_connection() != nullptr, kShortTimeout);
   EXPECT_TRUE(LocalCandidate(ep1_ch1())->is_relay());
@@ -3422,7 +3422,7 @@ class P2PTransportChannelPingTest : public ::testing::Test,
                                             int priority,
                                             bool writable) {
     channel->AddRemoteCandidate(
-        CreateUdpCandidate(IceCandidateType::kHost, ip_addr, port, priority));
+        CreateUdpCandidate(LOCAL_PORT_TYPE, ip_addr, port, priority));
     EXPECT_TRUE_SIMULATED_WAIT(
         GetConnectionTo(channel, ip_addr, port) != nullptr, kMediumTimeout,
         *clock);
@@ -3567,10 +3567,8 @@ TEST_F(P2PTransportChannelPingTest, TestTriggeredChecks) {
   P2PTransportChannel ch("trigger checks", 1, &pa, &field_trials_);
   PrepareChannel(&ch);
   ch.MaybeStartGathering();
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 1));
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "2.2.2.2", 2, 2));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "2.2.2.2", 2, 2));
 
   Connection* conn1 = WaitForConnectionTo(&ch, "1.1.1.1", 1);
   Connection* conn2 = WaitForConnectionTo(&ch, "2.2.2.2", 2);
@@ -3594,10 +3592,8 @@ TEST_F(P2PTransportChannelPingTest, TestAllConnectionsPingedSufficiently) {
   P2PTransportChannel ch("ping sufficiently", 1, &pa, &field_trials_);
   PrepareChannel(&ch);
   ch.MaybeStartGathering();
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 1));
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "2.2.2.2", 2, 2));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "2.2.2.2", 2, 2));
 
   Connection* conn1 = WaitForConnectionTo(&ch, "1.1.1.1", 1);
   Connection* conn2 = WaitForConnectionTo(&ch, "2.2.2.2", 2);
@@ -3625,8 +3621,7 @@ TEST_F(P2PTransportChannelPingTest, TestStunPingIntervals) {
   P2PTransportChannel ch("TestChannel", 1, &pa, &field_trials_);
   PrepareChannel(&ch);
   ch.MaybeStartGathering();
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 1));
   Connection* conn = WaitForConnectionTo(&ch, "1.1.1.1", 1);
 
   ASSERT_TRUE(conn != nullptr);
@@ -3755,10 +3750,8 @@ TEST_F(P2PTransportChannelPingTest, TestNoTriggeredChecksWhenWritable) {
   P2PTransportChannel ch("trigger checks", 1, &pa, &field_trials_);
   PrepareChannel(&ch);
   ch.MaybeStartGathering();
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 1));
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "2.2.2.2", 2, 2));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "2.2.2.2", 2, 2));
 
   Connection* conn1 = WaitForConnectionTo(&ch, "1.1.1.1", 1);
   Connection* conn2 = WaitForConnectionTo(&ch, "2.2.2.2", 2);
@@ -3784,8 +3777,7 @@ TEST_F(P2PTransportChannelPingTest, TestFailedConnectionNotPingable) {
                          &field_trials_);
   PrepareChannel(&ch);
   ch.MaybeStartGathering();
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 1));
 
   Connection* conn1 = WaitForConnectionTo(&ch, "1.1.1.1", 1);
   ASSERT_TRUE(conn1 != nullptr);
@@ -3803,8 +3795,7 @@ TEST_F(P2PTransportChannelPingTest, TestSignalStateChanged) {
   P2PTransportChannel ch("state change", 1, &pa, &field_trials_);
   PrepareChannel(&ch);
   ch.MaybeStartGathering();
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 1));
   Connection* conn1 = WaitForConnectionTo(&ch, "1.1.1.1", 1);
   ASSERT_TRUE(conn1 != nullptr);
   // Pruning the connection reduces the set of active connections and changes
@@ -3827,8 +3818,8 @@ TEST_F(P2PTransportChannelPingTest, TestAddRemoteCandidateWithVariousUfrags) {
   PrepareChannel(&ch);
   ch.MaybeStartGathering();
   // Add a candidate with a future ufrag.
-  ch.AddRemoteCandidate(CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1",
-                                           1, 1, kIceUfrag[2]));
+  ch.AddRemoteCandidate(
+      CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 1, kIceUfrag[2]));
   Connection* conn1 = WaitForConnectionTo(&ch, "1.1.1.1", 1);
   ASSERT_TRUE(conn1 != nullptr);
   const Candidate& candidate = conn1->remote_candidate();
@@ -3845,15 +3836,15 @@ TEST_F(P2PTransportChannelPingTest, TestAddRemoteCandidateWithVariousUfrags) {
   EXPECT_EQ(conn1, FindNextPingableConnectionAndPingIt(&ch));
 
   // Add a candidate with an old ufrag. No connection will be created.
-  ch.AddRemoteCandidate(CreateUdpCandidate(IceCandidateType::kHost, "2.2.2.2",
-                                           2, 2, kIceUfrag[1]));
+  ch.AddRemoteCandidate(
+      CreateUdpCandidate(LOCAL_PORT_TYPE, "2.2.2.2", 2, 2, kIceUfrag[1]));
   rtc::Thread::Current()->ProcessMessages(500);
   EXPECT_TRUE(GetConnectionTo(&ch, "2.2.2.2", 2) == nullptr);
 
   // Add a candidate with the current ufrag, its pwd and generation will be
   // assigned, even if the generation is not set.
-  ch.AddRemoteCandidate(CreateUdpCandidate(IceCandidateType::kHost, "3.3.3.3",
-                                           3, 0, kIceUfrag[2]));
+  ch.AddRemoteCandidate(
+      CreateUdpCandidate(LOCAL_PORT_TYPE, "3.3.3.3", 3, 0, kIceUfrag[2]));
   Connection* conn3 = nullptr;
   ASSERT_TRUE_WAIT((conn3 = GetConnectionTo(&ch, "3.3.3.3", 3)) != nullptr,
                    kMediumTimeout);
@@ -3881,16 +3872,14 @@ TEST_F(P2PTransportChannelPingTest, ConnectionResurrection) {
   ch.MaybeStartGathering();
 
   // Create conn1 and keep track of original candidate priority.
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 1));
   Connection* conn1 = WaitForConnectionTo(&ch, "1.1.1.1", 1);
   ASSERT_TRUE(conn1 != nullptr);
   uint32_t remote_priority = conn1->remote_candidate().priority();
 
   // Create a higher priority candidate and make the connection
   // receiving/writable. This will prune conn1.
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "2.2.2.2", 2, 2));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "2.2.2.2", 2, 2));
   Connection* conn2 = WaitForConnectionTo(&ch, "2.2.2.2", 2);
   ASSERT_TRUE(conn2 != nullptr);
   conn2->ReceivedPing();
@@ -3942,8 +3931,7 @@ TEST_F(P2PTransportChannelPingTest, TestReceivingStateChange) {
   EXPECT_EQ(500, ch.config().receiving_timeout_or_default());
   EXPECT_EQ(50, ch.check_receiving_interval());
   ch.MaybeStartGathering();
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 1));
   Connection* conn1 = WaitForConnectionTo(&ch, "1.1.1.1", 1, &clock);
   ASSERT_TRUE(conn1 != nullptr);
 
@@ -3969,8 +3957,7 @@ TEST_F(P2PTransportChannelPingTest, TestSelectConnectionBeforeNomination) {
   PrepareChannel(&ch);
   ch.SetIceRole(ICEROLE_CONTROLLED);
   ch.MaybeStartGathering();
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 1));
   Connection* conn1 = WaitForConnectionTo(&ch, "1.1.1.1", 1);
   ASSERT_TRUE(conn1 != nullptr);
   // Channel is not ready to send because it is not writable.
@@ -3991,8 +3978,7 @@ TEST_F(P2PTransportChannelPingTest, TestSelectConnectionBeforeNomination) {
 
   // When a higher priority candidate comes in, the new connection is chosen
   // as the selected connection.
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "2.2.2.2", 2, 10));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "2.2.2.2", 2, 10));
   Connection* conn2 = WaitForConnectionTo(&ch, "2.2.2.2", 2);
   ASSERT_TRUE(conn2 != nullptr);
   conn2->ReceivedPingResponse(LOW_RTT, "id");
@@ -4007,8 +3993,7 @@ TEST_F(P2PTransportChannelPingTest, TestSelectConnectionBeforeNomination) {
   // connection will be set as the selected connection, even though
   // its priority is lower.
   EXPECT_EQ(len, SendData(&ch, data, len, ++last_packet_id));
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "3.3.3.3", 3, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "3.3.3.3", 3, 1));
   Connection* conn3 = WaitForConnectionTo(&ch, "3.3.3.3", 3);
   ASSERT_TRUE(conn3 != nullptr);
   // Because it has a lower priority, the selected connection is still conn2.
@@ -4029,8 +4014,7 @@ TEST_F(P2PTransportChannelPingTest, TestSelectConnectionBeforeNomination) {
   // the selected connection because the selected connection is nominated by
   // the controlling side.
   EXPECT_EQ(len, SendData(&ch, data, len, ++last_packet_id));
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "4.4.4.4", 4, 100));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "4.4.4.4", 4, 100));
   Connection* conn4 = WaitForConnectionTo(&ch, "4.4.4.4", 4);
   ASSERT_TRUE(conn4 != nullptr);
   EXPECT_EQ(conn3, ch.selected_connection());
@@ -4065,8 +4049,7 @@ TEST_F(P2PTransportChannelPingTest, TestPingOnNomination) {
   ch.SetIceConfig(ch.config());
   ch.SetIceRole(ICEROLE_CONTROLLED);
   ch.MaybeStartGathering();
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 1));
   Connection* conn1 = WaitForConnectionTo(&ch, "1.1.1.1", 1);
   ASSERT_TRUE(conn1 != nullptr);
 
@@ -4077,8 +4060,7 @@ TEST_F(P2PTransportChannelPingTest, TestPingOnNomination) {
 
   // When a higher priority candidate comes in, the new connection is chosen
   // as the selected connection.
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "2.2.2.2", 2, 10));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "2.2.2.2", 2, 10));
   Connection* conn2 = WaitForConnectionTo(&ch, "2.2.2.2", 2);
   ASSERT_TRUE(conn2 != nullptr);
   conn2->ReceivedPingResponse(LOW_RTT, "id");
@@ -4109,8 +4091,7 @@ TEST_F(P2PTransportChannelPingTest, TestPingOnSwitch) {
   ch.SetIceConfig(ch.config());
   ch.SetIceRole(ICEROLE_CONTROLLING);
   ch.MaybeStartGathering();
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 1));
   Connection* conn1 = WaitForConnectionTo(&ch, "1.1.1.1", 1);
   ASSERT_TRUE(conn1 != nullptr);
 
@@ -4121,8 +4102,7 @@ TEST_F(P2PTransportChannelPingTest, TestPingOnSwitch) {
 
   // When a higher priority candidate comes in, the new connection is chosen
   // as the selected connection.
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "2.2.2.2", 2, 10));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "2.2.2.2", 2, 10));
   Connection* conn2 = WaitForConnectionTo(&ch, "2.2.2.2", 2);
   ASSERT_TRUE(conn2 != nullptr);
 
@@ -4150,8 +4130,7 @@ TEST_F(P2PTransportChannelPingTest, TestPingOnSelected) {
   ch.SetIceConfig(ch.config());
   ch.SetIceRole(ICEROLE_CONTROLLING);
   ch.MaybeStartGathering();
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 1));
   Connection* conn1 = WaitForConnectionTo(&ch, "1.1.1.1", 1);
   ASSERT_TRUE(conn1 != nullptr);
 
@@ -4197,8 +4176,7 @@ TEST_F(P2PTransportChannelPingTest, TestSelectConnectionFromUnknownAddress) {
   EXPECT_EQ_WAIT(conn1, ch.selected_connection(), kDefaultTimeout);
 
   // Another connection is nominated via use_candidate.
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "2.2.2.2", 2, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "2.2.2.2", 2, 1));
   Connection* conn2 = WaitForConnectionTo(&ch, "2.2.2.2", 2);
   ASSERT_TRUE(conn2 != nullptr);
   // Because it has a lower priority, the selected connection is still conn1.
@@ -4258,8 +4236,7 @@ TEST_F(P2PTransportChannelPingTest, TestSelectConnectionBasedOnMediaReceived) {
   PrepareChannel(&ch);
   ch.SetIceRole(ICEROLE_CONTROLLED);
   ch.MaybeStartGathering();
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 10));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 10));
   Connection* conn1 = WaitForConnectionTo(&ch, "1.1.1.1", 1);
   ASSERT_TRUE(conn1 != nullptr);
   conn1->ReceivedPingResponse(LOW_RTT, "id");
@@ -4268,8 +4245,7 @@ TEST_F(P2PTransportChannelPingTest, TestSelectConnectionBasedOnMediaReceived) {
   // If a data packet is received on conn2, the selected connection should
   // switch to conn2 because the controlled side must mirror the media path
   // chosen by the controlling side.
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "2.2.2.2", 2, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "2.2.2.2", 2, 1));
   Connection* conn2 = WaitForConnectionTo(&ch, "2.2.2.2", 2);
   ASSERT_TRUE(conn2 != nullptr);
   conn2->ReceivedPingResponse(LOW_RTT, "id");  // Become writable and receiving.
@@ -4585,8 +4561,8 @@ TEST_F(P2PTransportChannelPingTest, TestAddRemoteCandidateWithAddressReuse) {
   const int port_num = 1;
 
   // kIceUfrag[1] is the current generation ufrag.
-  Candidate candidate = CreateUdpCandidate(
-      IceCandidateType::kHost, host_address, port_num, 1, kIceUfrag[1]);
+  Candidate candidate = CreateUdpCandidate(LOCAL_PORT_TYPE, host_address,
+                                           port_num, 1, kIceUfrag[1]);
   ch.AddRemoteCandidate(candidate);
   Connection* conn1 = WaitForConnectionTo(&ch, host_address, port_num);
   ASSERT_TRUE(conn1 != nullptr);
@@ -4623,8 +4599,7 @@ TEST_F(P2PTransportChannelPingTest, TestDontPruneWhenWeak) {
   PrepareChannel(&ch);
   ch.SetIceRole(ICEROLE_CONTROLLED);
   ch.MaybeStartGathering();
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 1));
   Connection* conn1 = WaitForConnectionTo(&ch, "1.1.1.1", 1);
   ASSERT_TRUE(conn1 != nullptr);
   EXPECT_EQ(nullptr, ch.selected_connection());
@@ -4632,8 +4607,7 @@ TEST_F(P2PTransportChannelPingTest, TestDontPruneWhenWeak) {
 
   // When a higher-priority, nominated candidate comes in, the connections with
   // lower-priority are pruned.
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "2.2.2.2", 2, 10));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "2.2.2.2", 2, 10));
   Connection* conn2 = WaitForConnectionTo(&ch, "2.2.2.2", 2, &clock);
   ASSERT_TRUE(conn2 != nullptr);
   conn2->ReceivedPingResponse(LOW_RTT, "id");  // Becomes writable and receiving
@@ -4644,8 +4618,7 @@ TEST_F(P2PTransportChannelPingTest, TestDontPruneWhenWeak) {
   // Wait until conn2 becomes not receiving.
   EXPECT_TRUE_SIMULATED_WAIT(!conn2->receiving(), kMediumTimeout, clock);
 
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "3.3.3.3", 3, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "3.3.3.3", 3, 1));
   Connection* conn3 = WaitForConnectionTo(&ch, "3.3.3.3", 3, &clock);
   ASSERT_TRUE(conn3 != nullptr);
   // The selected connection should still be conn2. Even through conn3 has lower
@@ -4693,10 +4666,8 @@ TEST_F(P2PTransportChannelPingTest, TestGetState) {
   // any connections yet.
   EXPECT_EQ(webrtc::IceTransportState::kNew, ch.GetIceTransportState());
   EXPECT_EQ(IceTransportState::STATE_INIT, ch.GetState());
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 100));
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "2.2.2.2", 2, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 100));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "2.2.2.2", 2, 1));
   // Checking candidates that have been added with gathered candidates.
   ASSERT_GT(ch.connections().size(), 0u);
   EXPECT_EQ(webrtc::IceTransportState::kChecking, ch.GetIceTransportState());
@@ -4735,8 +4706,7 @@ TEST_F(P2PTransportChannelPingTest, TestConnectionPrunedAgain) {
   config.receiving_switching_delay = 800;
   ch.SetIceConfig(config);
   ch.MaybeStartGathering();
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 100));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 100));
   Connection* conn1 = WaitForConnectionTo(&ch, "1.1.1.1", 1, &clock);
   ASSERT_TRUE(conn1 != nullptr);
   EXPECT_EQ(nullptr, ch.selected_connection());
@@ -4748,8 +4718,7 @@ TEST_F(P2PTransportChannelPingTest, TestConnectionPrunedAgain) {
   // not be deleted right away. Once the current selected connection becomes not
   // receiving, `conn2` will start to ping and upon receiving the ping response,
   // it will become the selected connection.
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "2.2.2.2", 2, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "2.2.2.2", 2, 1));
   Connection* conn2 = WaitForConnectionTo(&ch, "2.2.2.2", 2, &clock);
   ASSERT_TRUE(conn2 != nullptr);
   EXPECT_TRUE_SIMULATED_WAIT(!conn2->active(), kDefaultTimeout, clock);
@@ -4786,8 +4755,7 @@ TEST_F(P2PTransportChannelPingTest, TestDeleteConnectionsIfAllWriteTimedout) {
   PrepareChannel(&ch);
   ch.MaybeStartGathering();
   // Have one connection only but later becomes write-time-out.
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 100));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 100));
   Connection* conn1 = WaitForConnectionTo(&ch, "1.1.1.1", 1, &clock);
   ASSERT_TRUE(conn1 != nullptr);
   conn1->ReceivedPing();  // Becomes receiving
@@ -4795,13 +4763,11 @@ TEST_F(P2PTransportChannelPingTest, TestDeleteConnectionsIfAllWriteTimedout) {
   EXPECT_TRUE_SIMULATED_WAIT(ch.connections().empty(), kShortTimeout, clock);
 
   // Have two connections but both become write-time-out later.
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "2.2.2.2", 2, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "2.2.2.2", 2, 1));
   Connection* conn2 = WaitForConnectionTo(&ch, "2.2.2.2", 2, &clock);
   ASSERT_TRUE(conn2 != nullptr);
   conn2->ReceivedPing();  // Becomes receiving
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "3.3.3.3", 3, 2));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "3.3.3.3", 3, 2));
   Connection* conn3 = WaitForConnectionTo(&ch, "3.3.3.3", 3, &clock);
   ASSERT_TRUE(conn3 != nullptr);
   conn3->ReceivedPing();  // Becomes receiving
@@ -4822,8 +4788,7 @@ TEST_F(P2PTransportChannelPingTest, TestStopPortAllocatorSessions) {
   PrepareChannel(&ch);
   ch.SetIceConfig(CreateIceConfig(2000, GATHER_ONCE));
   ch.MaybeStartGathering();
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 100));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 100));
   Connection* conn1 = WaitForConnectionTo(&ch, "1.1.1.1", 1);
   ASSERT_TRUE(conn1 != nullptr);
   conn1->ReceivedPingResponse(LOW_RTT, "id");  // Becomes writable and receiving
@@ -4840,8 +4805,7 @@ TEST_F(P2PTransportChannelPingTest, TestStopPortAllocatorSessions) {
 
   // But if a new connection created from the new session becomes writable,
   // it will stop the current session.
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "2.2.2.2", 2, 100));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "2.2.2.2", 2, 100));
   Connection* conn2 = WaitForConnectionTo(&ch, "2.2.2.2", 2);
   ASSERT_TRUE(conn2 != nullptr);
   conn2->ReceivedPingResponse(LOW_RTT, "id");  // Becomes writable and receiving
@@ -4861,8 +4825,7 @@ TEST_F(P2PTransportChannelPingTest, TestIceRoleUpdatedOnRemovedPort) {
   IceConfig config = CreateIceConfig(1000, GATHER_CONTINUALLY);
   ch.SetIceConfig(config);
   ch.MaybeStartGathering();
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 1));
 
   Connection* conn = WaitForConnectionTo(&ch, "1.1.1.1", 1);
   ASSERT_TRUE(conn != nullptr);
@@ -4887,8 +4850,7 @@ TEST_F(P2PTransportChannelPingTest, TestIceRoleUpdatedOnPortAfterIceRestart) {
   // Starts with ICEROLE_CONTROLLING.
   PrepareChannel(&ch);
   ch.MaybeStartGathering();
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 1));
 
   Connection* conn = WaitForConnectionTo(&ch, "1.1.1.1", 1);
   ASSERT_TRUE(conn != nullptr);
@@ -4914,8 +4876,7 @@ TEST_F(P2PTransportChannelPingTest, TestPortDestroyedAfterTimeoutAndPruned) {
   PrepareChannel(&ch);
   ch.SetIceRole(ICEROLE_CONTROLLED);
   ch.MaybeStartGathering();
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 1));
 
   Connection* conn = WaitForConnectionTo(&ch, "1.1.1.1", 1);
   ASSERT_TRUE(conn != nullptr);
@@ -4945,10 +4906,8 @@ TEST_F(P2PTransportChannelPingTest, TestMaxOutstandingPingsFieldTrial) {
   ch.SetIceConfig(ch.config());
   PrepareChannel(&ch);
   ch.MaybeStartGathering();
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 1));
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "2.2.2.2", 2, 2));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "2.2.2.2", 2, 2));
 
   Connection* conn1 = WaitForConnectionTo(&ch, "1.1.1.1", 1);
   Connection* conn2 = WaitForConnectionTo(&ch, "2.2.2.2", 2);
@@ -5034,10 +4993,8 @@ TEST_F(P2PTransportChannelMostLikelyToWorkFirstTest,
   EXPECT_EQ(ch.ports()[0]->Type(), LOCAL_PORT_TYPE);
   EXPECT_EQ(ch.ports()[1]->Type(), RELAY_PORT_TYPE);
 
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kRelay, "1.1.1.1", 1, 1));
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "2.2.2.2", 2, 2));
+  ch.AddRemoteCandidate(CreateUdpCandidate(RELAY_PORT_TYPE, "1.1.1.1", 1, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "2.2.2.2", 2, 2));
 
   EXPECT_TRUE_WAIT(ch.connections().size() == 4, kDefaultTimeout);
 
@@ -5095,8 +5052,7 @@ TEST_F(P2PTransportChannelMostLikelyToWorkFirstTest,
   EXPECT_EQ(ch.ports()[0]->Type(), LOCAL_PORT_TYPE);
   EXPECT_EQ(ch.ports()[1]->Type(), RELAY_PORT_TYPE);
 
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 1));
   EXPECT_TRUE_WAIT(ch.connections().size() == 2, kDefaultTimeout);
 
   // Initially, only have Local/Local and Local/Relay.
@@ -5106,8 +5062,7 @@ TEST_F(P2PTransportChannelMostLikelyToWorkFirstTest,
                                IceCandidateType::kHost);
 
   // Remote Relay candidate arrives.
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kRelay, "2.2.2.2", 2, 2));
+  ch.AddRemoteCandidate(CreateUdpCandidate(RELAY_PORT_TYPE, "2.2.2.2", 2, 2));
   EXPECT_TRUE_WAIT(ch.connections().size() == 4, kDefaultTimeout);
 
   // Relay/Relay should be the first since it hasn't been pinged before.
@@ -5133,8 +5088,7 @@ TEST_F(P2PTransportChannelMostLikelyToWorkFirstTest,
   EXPECT_EQ(ch.ports()[0]->Type(), LOCAL_PORT_TYPE);
   EXPECT_EQ(ch.ports()[1]->Type(), RELAY_PORT_TYPE);
 
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kRelay, "1.1.1.1", 1, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(RELAY_PORT_TYPE, "1.1.1.1", 1, 1));
   EXPECT_TRUE_WAIT(ch.connections().size() == 2, kDefaultTimeout);
 
   // Initially, only have Relay/Relay and Local/Relay. Ping Relay/Relay first.
@@ -5146,8 +5100,7 @@ TEST_F(P2PTransportChannelMostLikelyToWorkFirstTest,
                                IceCandidateType::kRelay);
 
   // Remote Local candidate arrives.
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "2.2.2.2", 2, 2));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "2.2.2.2", 2, 2));
   EXPECT_TRUE_WAIT(ch.connections().size() == 4, kDefaultTimeout);
 
   // Local/Local should be the first since it hasn't been pinged before.
@@ -5177,13 +5130,11 @@ TEST_F(P2PTransportChannelMostLikelyToWorkFirstTest,
   EXPECT_EQ(ch.ports()[1]->Type(), RELAY_PORT_TYPE);
 
   // Remote Relay candidate arrives.
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kRelay, "1.1.1.1", 1, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(RELAY_PORT_TYPE, "1.1.1.1", 1, 1));
   EXPECT_TRUE_WAIT(ch.connections().size() == 1, kDefaultTimeout);
 
   // Remote Local candidate arrives.
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "2.2.2.2", 2, 2));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "2.2.2.2", 2, 2));
   EXPECT_TRUE_WAIT(ch.connections().size() == 2, kDefaultTimeout);
 }
 
@@ -5204,8 +5155,7 @@ TEST_F(P2PTransportChannelMostLikelyToWorkFirstTest, TestTcpTurn) {
   EXPECT_EQ(ch.ports()[2]->Type(), RELAY_PORT_TYPE);
 
   // Remote Relay candidate arrives.
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kRelay, "1.1.1.1", 1, 1));
+  ch.AddRemoteCandidate(CreateUdpCandidate(RELAY_PORT_TYPE, "1.1.1.1", 1, 1));
   EXPECT_TRUE_WAIT(ch.connections().size() == 3, kDefaultTimeout);
 
   // UDP Relay/Relay should be pinged first.
@@ -5659,19 +5609,16 @@ TEST_F(P2PTransportChannelTest,
   // host, srflx and relay types. Note that the candidates differ in their
   // ports.
   cricket::Candidate host_candidate = CreateUdpCandidate(
-      IceCandidateType::kHost, "1.1.1.1", 1 /* port */, 0 /* priority */);
+      LOCAL_PORT_TYPE, "1.1.1.1", 1 /* port */, 0 /* priority */);
   ep1_ch1()->AddRemoteCandidate(host_candidate);
 
   std::vector<cricket::Candidate> mdns_candidates;
-  mdns_candidates.push_back(CreateUdpCandidate(IceCandidateType::kHost,
-                                               "example.local", 2 /* port */,
-                                               0 /* priority */));
-  mdns_candidates.push_back(CreateUdpCandidate(IceCandidateType::kSrflx,
-                                               "example.local", 3 /* port */,
-                                               0 /* priority */));
-  mdns_candidates.push_back(CreateUdpCandidate(IceCandidateType::kRelay,
-                                               "example.local", 4 /* port */,
-                                               0 /* priority */));
+  mdns_candidates.push_back(CreateUdpCandidate(LOCAL_PORT_TYPE, "example.local",
+                                               2 /* port */, 0 /* priority */));
+  mdns_candidates.push_back(CreateUdpCandidate(STUN_PORT_TYPE, "example.local",
+                                               3 /* port */, 0 /* priority */));
+  mdns_candidates.push_back(CreateUdpCandidate(RELAY_PORT_TYPE, "example.local",
+                                               4 /* port */, 0 /* priority */));
   // We just resolve the hostname to 1.1.1.1, and add the candidates with this
   // address directly to simulate the process of adding remote candidates with
   // the name resolution.
@@ -6046,8 +5993,7 @@ TEST_F(P2PTransportChannelPingTest, TestInitialSelectDampening0) {
   ch.SetIceConfig(ch.config());
   ch.MaybeStartGathering();
 
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 100));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 100));
   Connection* conn1 = WaitForConnectionTo(&ch, "1.1.1.1", 1, &clock);
   ASSERT_TRUE(conn1 != nullptr);
   EXPECT_EQ(nullptr, ch.selected_connection());
@@ -6072,8 +6018,7 @@ TEST_F(P2PTransportChannelPingTest, TestInitialSelectDampening) {
   ch.SetIceConfig(ch.config());
   ch.MaybeStartGathering();
 
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 100));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 100));
   Connection* conn1 = WaitForConnectionTo(&ch, "1.1.1.1", 1, &clock);
   ASSERT_TRUE(conn1 != nullptr);
   EXPECT_EQ(nullptr, ch.selected_connection());
@@ -6099,8 +6044,7 @@ TEST_F(P2PTransportChannelPingTest, TestInitialSelectDampeningPingReceived) {
   ch.SetIceConfig(ch.config());
   ch.MaybeStartGathering();
 
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 100));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 100));
   Connection* conn1 = WaitForConnectionTo(&ch, "1.1.1.1", 1, &clock);
   ASSERT_TRUE(conn1 != nullptr);
   EXPECT_EQ(nullptr, ch.selected_connection());
@@ -6129,8 +6073,7 @@ TEST_F(P2PTransportChannelPingTest, TestInitialSelectDampeningBoth) {
   ch.SetIceConfig(ch.config());
   ch.MaybeStartGathering();
 
-  ch.AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 100));
+  ch.AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 100));
   Connection* conn1 = WaitForConnectionTo(&ch, "1.1.1.1", 1, &clock);
   ASSERT_TRUE(conn1 != nullptr);
   EXPECT_EQ(nullptr, ch.selected_connection());
@@ -6234,10 +6177,8 @@ TEST_F(P2PTransportChannelPingTest, TestForgetLearnedState) {
 
   PrepareChannel(ch.get());
   ch->MaybeStartGathering();
-  ch->AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "1.1.1.1", 1, 1));
-  ch->AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "2.2.2.2", 2, 2));
+  ch->AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "1.1.1.1", 1, 1));
+  ch->AddRemoteCandidate(CreateUdpCandidate(LOCAL_PORT_TYPE, "2.2.2.2", 2, 2));
 
   Connection* conn1 = WaitForConnectionTo(ch.get(), "1.1.1.1", 1);
   Connection* conn2 = WaitForConnectionTo(ch.get(), "2.2.2.2", 2);
@@ -6282,7 +6223,7 @@ TEST_F(P2PTransportChannelTest, DisableDnsLookupsWithTransportPolicyRelay) {
   CreateChannels();
 
   ep1_ch1()->AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "hostname.test", 1, 100));
+      CreateUdpCandidate(LOCAL_PORT_TYPE, "hostname.test", 1, 100));
 
   DestroyChannels();
 }
@@ -6308,7 +6249,7 @@ TEST_F(P2PTransportChannelTest, DisableDnsLookupsWithTransportPolicyNone) {
   CreateChannels();
 
   ep1_ch1()->AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "hostname.test", 1, 100));
+      CreateUdpCandidate(LOCAL_PORT_TYPE, "hostname.test", 1, 100));
 
   DestroyChannels();
 }
@@ -6335,7 +6276,7 @@ TEST_F(P2PTransportChannelTest, EnableDnsLookupsWithTransportPolicyNoHost) {
   CreateChannels();
 
   ep1_ch1()->AddRemoteCandidate(
-      CreateUdpCandidate(IceCandidateType::kHost, "hostname.test", 1, 100));
+      CreateUdpCandidate(LOCAL_PORT_TYPE, "hostname.test", 1, 100));
 
   EXPECT_TRUE(lookup_started);
 
diff --git a/p2p/base/port.cc b/p2p/base/port.cc
index 057ba741a3..917167c864 100644
--- a/p2p/base/port.cc
+++ b/p2p/base/port.cc
@@ -39,12 +39,9 @@
 #include "rtc_base/time_utils.h"
 #include "rtc_base/trace_event.h"
 
-using webrtc::IceCandidateType;
-
 namespace cricket {
 namespace {
 
-using ::webrtc::IceCandidateType;
 using ::webrtc::RTCError;
 using ::webrtc::RTCErrorType;
 using ::webrtc::TaskQueueBase;
@@ -89,17 +86,6 @@ absl::optional<ProtocolType> StringToProto(absl::string_view proto_name) {
   return absl::nullopt;
 }
 
-IceCandidateType PortTypeToIceCandidateType(const absl::string_view type) {
-  if (type == "host" || type == LOCAL_PORT_TYPE)
-    return IceCandidateType::kHost;
-  if (type == "srflx" || type == STUN_PORT_TYPE)
-    return IceCandidateType::kSrflx;
-  if (type == PRFLX_PORT_TYPE)
-    return IceCandidateType::kPrflx;
-  RTC_DCHECK_EQ(type, RELAY_PORT_TYPE);
-  return IceCandidateType::kRelay;
-}
-
 // RFC 6544, TCP candidate encoding rules.
 const int DISCARD_PORT = 9;
 const char TCPTYPE_ACTIVE_STR[] = "active";
@@ -107,36 +93,45 @@ const char TCPTYPE_PASSIVE_STR[] = "passive";
 const char TCPTYPE_SIMOPEN_STR[] = "so";
 
 Port::Port(TaskQueueBase* thread,
-           webrtc::IceCandidateType type,
+           absl::string_view type,
            rtc::PacketSocketFactory* factory,
            const rtc::Network* network,
            absl::string_view username_fragment,
            absl::string_view password,
            const webrtc::FieldTrialsView* field_trials)
-    : Port(thread,
-           type,
-           factory,
-           network,
-           0,
-           0,
-           username_fragment,
-           password,
-           field_trials,
-           true) {}
+    : thread_(thread),
+      factory_(factory),
+      type_(type),
+      send_retransmit_count_attribute_(false),
+      network_(network),
+      min_port_(0),
+      max_port_(0),
+      component_(ICE_CANDIDATE_COMPONENT_DEFAULT),
+      generation_(0),
+      ice_username_fragment_(username_fragment),
+      password_(password),
+      timeout_delay_(kPortTimeoutDelay),
+      enable_port_packets_(false),
+      ice_role_(ICEROLE_UNKNOWN),
+      tiebreaker_(0),
+      shared_socket_(true),
+      weak_factory_(this),
+      field_trials_(field_trials) {
+  RTC_DCHECK(factory_ != NULL);
+  Construct();
+}
 
 Port::Port(TaskQueueBase* thread,
-           webrtc::IceCandidateType type,
+           absl::string_view type,
            rtc::PacketSocketFactory* factory,
            const rtc::Network* network,
            uint16_t min_port,
            uint16_t max_port,
            absl::string_view username_fragment,
            absl::string_view password,
-           const webrtc::FieldTrialsView* field_trials,
-           bool shared_socket /*= false*/)
+           const webrtc::FieldTrialsView* field_trials)
     : thread_(thread),
       factory_(factory),
-      field_trials_(field_trials),
       type_(type),
       send_retransmit_count_attribute_(false),
       network_(network),
@@ -150,11 +145,15 @@ Port::Port(TaskQueueBase* thread,
       enable_port_packets_(false),
       ice_role_(ICEROLE_UNKNOWN),
       tiebreaker_(0),
-      shared_socket_(shared_socket),
-      network_cost_(network->GetCost(*field_trials_)),
-      weak_factory_(this) {
+      shared_socket_(false),
+      weak_factory_(this),
+      field_trials_(field_trials) {
+  RTC_DCHECK(factory_ != NULL);
+  Construct();
+}
+
+void Port::Construct() {
   RTC_DCHECK_RUN_ON(thread_);
-  RTC_DCHECK(factory_ != nullptr);
   // TODO(pthatcher): Remove this old behavior once we're sure no one
   // relies on it.  If the username_fragment and password are empty,
   // we should just create one.
@@ -164,6 +163,7 @@ Port::Port(TaskQueueBase* thread,
     password_ = rtc::CreateRandomString(ICE_PWD_LENGTH);
   }
   network_->SignalTypeChanged.connect(this, &Port::OnNetworkTypeChanged);
+  network_cost_ = network_->GetCost(field_trials());
 
   PostDestroyIfDead(/*delayed=*/true);
   RTC_LOG(LS_INFO) << ToString() << ": Port created with network cost "
@@ -177,11 +177,7 @@ Port::~Port() {
 }
 
 const absl::string_view Port::Type() const {
-  if (type_ == webrtc::IceCandidateType::kHost)
-    return "local";
-  if (type_ == webrtc::IceCandidateType::kSrflx)
-    return "stun";
-  return webrtc::IceCandidateTypeToString(type_);
+  return type_;
 }
 const rtc::Network* Port::Network() const {
   return network_;
@@ -245,7 +241,7 @@ void Port::AddAddress(const rtc::SocketAddress& address,
                       absl::string_view protocol,
                       absl::string_view relay_protocol,
                       absl::string_view tcptype,
-                      IceCandidateType type,
+                      absl::string_view type,
                       uint32_t type_preference,
                       uint32_t relay_preference,
                       absl::string_view url,
@@ -877,9 +873,8 @@ void Port::OnNetworkTypeChanged(const rtc::Network* network) {
 std::string Port::ToString() const {
   rtc::StringBuilder ss;
   ss << "Port[" << rtc::ToHex(reinterpret_cast<uintptr_t>(this)) << ":"
-     << content_name_ << ":" << component_ << ":" << generation_ << ":"
-     << webrtc::IceCandidateTypeToString(type_) << ":" << network_->ToString()
-     << "]";
+     << content_name_ << ":" << component_ << ":" << generation_ << ":" << type_
+     << ":" << network_->ToString() << "]";
   return ss.Release();
 }
 
diff --git a/p2p/base/port.h b/p2p/base/port.h
index 40e8679351..4021c250fb 100644
--- a/p2p/base/port.h
+++ b/p2p/base/port.h
@@ -123,8 +123,6 @@ typedef std::vector<CandidateStats> CandidateStatsList;
 
 const char* ProtoToString(ProtocolType proto);
 absl::optional<ProtocolType> StringToProto(absl::string_view proto_name);
-webrtc::IceCandidateType PortTypeToIceCandidateType(
-    const absl::string_view type);
 
 struct ProtocolAddress {
   rtc::SocketAddress address;
@@ -173,67 +171,29 @@ typedef std::set<rtc::SocketAddress> ServerAddresses;
 // connections to similar mechanisms of the other client.  Subclasses of this
 // one add support for specific mechanisms like local UDP ports.
 class RTC_EXPORT Port : public PortInterface, public sigslot::has_slots<> {
- protected:
-  // Constructors for use only by via constructors in derived classes.
+ public:
+  // INIT: The state when a port is just created.
+  // KEEP_ALIVE_UNTIL_PRUNED: A port should not be destroyed even if no
+  // connection is using it.
+  // PRUNED: It will be destroyed if no connection is using it for a period of
+  // 30 seconds.
+  enum class State { INIT, KEEP_ALIVE_UNTIL_PRUNED, PRUNED };
   Port(webrtc::TaskQueueBase* thread,
-       webrtc::IceCandidateType type,
+       absl::string_view type ABSL_ATTRIBUTE_LIFETIME_BOUND,
        rtc::PacketSocketFactory* factory,
        const rtc::Network* network,
        absl::string_view username_fragment,
        absl::string_view password,
        const webrtc::FieldTrialsView* field_trials = nullptr);
   Port(webrtc::TaskQueueBase* thread,
-       webrtc::IceCandidateType type,
+       absl::string_view type ABSL_ATTRIBUTE_LIFETIME_BOUND,
        rtc::PacketSocketFactory* factory,
        const rtc::Network* network,
        uint16_t min_port,
        uint16_t max_port,
        absl::string_view username_fragment,
        absl::string_view password,
-       const webrtc::FieldTrialsView* field_trials = nullptr,
-       bool shared_socket = false);
-
-  // // TODO: bugs.webrtc.org/15846 - Remove.
-  [[deprecated("Use IceCandidateType version")]] Port(
-      webrtc::TaskQueueBase* thread,
-      absl::string_view type ABSL_ATTRIBUTE_LIFETIME_BOUND,
-      rtc::PacketSocketFactory* factory,
-      const rtc::Network* network,
-      uint16_t min_port,
-      uint16_t max_port,
-      absl::string_view username_fragment,
-      absl::string_view password,
-      const webrtc::FieldTrialsView* field_trials = nullptr,
-      bool shared_socket = false)
-      : Port(thread,
-             PortTypeToIceCandidateType(type),
-             factory,
-             network,
-             min_port,
-             max_port,
-             username_fragment,
-             password,
-             field_trials,
-             shared_socket) {}
-
-  // // TODO: bugs.webrtc.org/15846 - Remove.
-  [[deprecated("Use IceCandidateType version")]] Port(
-      webrtc::TaskQueueBase* thread,
-      absl::string_view type ABSL_ATTRIBUTE_LIFETIME_BOUND,
-      rtc::PacketSocketFactory* factory,
-      const rtc::Network* network,
-      absl::string_view username_fragment,
-      absl::string_view password,
-      const webrtc::FieldTrialsView* field_trials = nullptr)
-      : Port(thread,
-             PortTypeToIceCandidateType(type),
-             factory,
-             network,
-             username_fragment,
-             password,
-             field_trials) {}
-
- public:
+       const webrtc::FieldTrialsView* field_trials = nullptr);
   ~Port() override;
 
   // Note that the port type does NOT uniquely identify different subclasses of
@@ -419,31 +379,13 @@ class RTC_EXPORT Port : public PortInterface, public sigslot::has_slots<> {
 
   rtc::WeakPtr<Port> NewWeakPtr() { return weak_factory_.GetWeakPtr(); }
 
-  // TODO: bugs.webrtc.org/15846 - Remove.
-  [[deprecated("Use IceCandidateType version")]] void AddAddress(
-      const rtc::SocketAddress& address,
-      const rtc::SocketAddress& base_address,
-      const rtc::SocketAddress& related_address,
-      absl::string_view protocol,
-      absl::string_view relay_protocol,
-      absl::string_view tcptype,
-      absl::string_view type,
-      uint32_t type_preference,
-      uint32_t relay_preference,
-      absl::string_view url,
-      bool is_final) {
-    AddAddress(address, base_address, related_address, protocol, relay_protocol,
-               tcptype, PortTypeToIceCandidateType(type), type_preference,
-               relay_preference, url, is_final);
-  }
-
   void AddAddress(const rtc::SocketAddress& address,
                   const rtc::SocketAddress& base_address,
                   const rtc::SocketAddress& related_address,
                   absl::string_view protocol,
                   absl::string_view relay_protocol,
                   absl::string_view tcptype,
-                  webrtc::IceCandidateType type,
+                  absl::string_view type,
                   uint32_t type_preference,
                   uint32_t relay_preference,
                   absl::string_view url,
@@ -509,11 +451,8 @@ class RTC_EXPORT Port : public PortInterface, public sigslot::has_slots<> {
 
   const webrtc::FieldTrialsView& field_trials() const { return *field_trials_; }
 
-  webrtc::IceCandidateType type() const { return type_; }
-
  private:
-  bool MaybeObfuscateAddress(const Candidate& c, bool is_final)
-      RTC_RUN_ON(thread_);
+  void Construct();
 
   void PostDestroyIfDead(bool delayed);
   void DestroyIfDead();
@@ -535,10 +474,7 @@ class RTC_EXPORT Port : public PortInterface, public sigslot::has_slots<> {
 
   webrtc::TaskQueueBase* const thread_;
   rtc::PacketSocketFactory* const factory_;
-  webrtc::AlwaysValidPointer<const webrtc::FieldTrialsView,
-                             webrtc::FieldTrialBasedConfig>
-      field_trials_;
-  const webrtc::IceCandidateType type_;
+  const absl::string_view type_;
   bool send_retransmit_count_attribute_;
   const rtc::Network* network_;
   uint16_t min_port_;
@@ -567,21 +503,20 @@ class RTC_EXPORT Port : public PortInterface, public sigslot::has_slots<> {
   // (WiFi. vs. Cellular). It takes precedence over the priority when
   // comparing two connections.
   int16_t network_cost_;
-  // INIT: The state when a port is just created.
-  // KEEP_ALIVE_UNTIL_PRUNED: A port should not be destroyed even if no
-  // connection is using it.
-  // PRUNED: It will be destroyed if no connection is using it for a period of
-  // 30 seconds.
-  enum class State { INIT, KEEP_ALIVE_UNTIL_PRUNED, PRUNED };
   State state_ = State::INIT;
   int64_t last_time_all_connections_removed_ = 0;
   MdnsNameRegistrationStatus mdns_name_registration_status_ =
       MdnsNameRegistrationStatus::kNotStarted;
 
-  webrtc::CallbackList<PortInterface*> port_destroyed_callback_list_;
-
-  // Keep as the last member variable.
   rtc::WeakPtrFactory<Port> weak_factory_;
+  webrtc::AlwaysValidPointer<const webrtc::FieldTrialsView,
+                             webrtc::FieldTrialBasedConfig>
+      field_trials_;
+
+  bool MaybeObfuscateAddress(const Candidate& c, bool is_final)
+      RTC_RUN_ON(thread_);
+
+  webrtc::CallbackList<PortInterface*> port_destroyed_callback_list_;
 };
 
 }  // namespace cricket
diff --git a/p2p/base/port_allocator_unittest.cc b/p2p/base/port_allocator_unittest.cc
index 1b5584e2e8..2df8662f62 100644
--- a/p2p/base/port_allocator_unittest.cc
+++ b/p2p/base/port_allocator_unittest.cc
@@ -19,8 +19,6 @@
 #include "test/gtest.h"
 #include "test/scoped_key_value_config.h"
 
-using webrtc::IceCandidateType;
-
 static const char kContentName[] = "test content";
 // Based on ICE_UFRAG_LENGTH
 static const char kIceUfrag[] = "UF00";
@@ -296,7 +294,7 @@ TEST_F(PortAllocatorTest, SanitizeEmptyCandidateDefaultConfig) {
 
 TEST_F(PortAllocatorTest, SanitizeIpv4CandidateDefaultConfig) {
   cricket::Candidate input(1, "udp", rtc::SocketAddress(kIpv4Address, 443), 1,
-                           "username", "password", IceCandidateType::kHost, 1,
+                           "username", "password", cricket::LOCAL_PORT_TYPE, 1,
                            "foundation", 1, 1);
   cricket::Candidate output = allocator_->SanitizeCandidate(input);
   EXPECT_EQ(kIpv4AddressWithPort, output.address().ToString());
@@ -306,7 +304,7 @@ TEST_F(PortAllocatorTest, SanitizeIpv4CandidateDefaultConfig) {
 TEST_F(PortAllocatorTest, SanitizeIpv4CandidateMdnsObfuscationEnabled) {
   allocator_->SetMdnsObfuscationEnabledForTesting(true);
   cricket::Candidate input(1, "udp", rtc::SocketAddress(kIpv4Address, 443), 1,
-                           "username", "password", IceCandidateType::kHost, 1,
+                           "username", "password", cricket::LOCAL_PORT_TYPE, 1,
                            "foundation", 1, 1);
   cricket::Candidate output = allocator_->SanitizeCandidate(input);
   EXPECT_NE(kIpv4AddressWithPort, output.address().ToString());
@@ -317,7 +315,7 @@ TEST_F(PortAllocatorTest, SanitizePrflxCandidateMdnsObfuscationEnabled) {
   allocator_->SetMdnsObfuscationEnabledForTesting(true);
   // Create the candidate from an IP literal. This populates the hostname.
   cricket::Candidate input(1, "udp", rtc::SocketAddress(kIpv4Address, 443), 1,
-                           "username", "password", IceCandidateType::kPrflx, 1,
+                           "username", "password", cricket::PRFLX_PORT_TYPE, 1,
                            "foundation", 1, 1);
   cricket::Candidate output = allocator_->SanitizeCandidate(input);
   EXPECT_NE(kIpv4AddressWithPort, output.address().ToString());
@@ -329,7 +327,7 @@ TEST_F(PortAllocatorTest,
   allocator_->SetMdnsObfuscationEnabledForTesting(true);
   // Create the candidate from an IP literal. This populates the hostname.
   cricket::Candidate input(1, "udp", rtc::SocketAddress(kIpv4Address, 443), 1,
-                           "username", "password", IceCandidateType::kPrflx, 1,
+                           "username", "password", cricket::PRFLX_PORT_TYPE, 1,
                            "foundation", 1, 1);
 
   cricket::Candidate output = allocator_->SanitizeCandidate(input);
@@ -345,8 +343,8 @@ TEST_F(PortAllocatorTest, SanitizeIpv4NonLiteralMdnsObfuscationEnabled) {
   rtc::IPAddress ip;
   EXPECT_TRUE(IPFromString(kIpv4Address, &ip));
   cricket::Candidate input(1, "udp", rtc::SocketAddress(ip, 443), 1, "username",
-                           "password", IceCandidateType::kHost, 1, "foundation",
-                           1, 1);
+                           "password", cricket::LOCAL_PORT_TYPE, 1,
+                           "foundation", 1, 1);
   cricket::Candidate output = allocator_->SanitizeCandidate(input);
   EXPECT_NE(kIpv4AddressWithPort, output.address().ToString());
   EXPECT_EQ("", output.address().ipaddr().ToString());
diff --git a/p2p/base/port_interface.h b/p2p/base/port_interface.h
index de68306acc..8a1d18d8ba 100644
--- a/p2p/base/port_interface.h
+++ b/p2p/base/port_interface.h
@@ -52,7 +52,6 @@ class PortInterface {
  public:
   virtual ~PortInterface();
 
-  // TODO: bugs.webrtc.org/15846 - Change return type to IceCandidateType.
   virtual const absl::string_view Type() const = 0;
   virtual const rtc::Network* Network() const = 0;
 
diff --git a/p2p/base/port_unittest.cc b/p2p/base/port_unittest.cc
index 8e049b7145..ab3ff86fd1 100644
--- a/p2p/base/port_unittest.cc
+++ b/p2p/base/port_unittest.cc
@@ -82,7 +82,6 @@ using rtc::NATType;
 using rtc::PacketSocketFactory;
 using rtc::Socket;
 using rtc::SocketAddress;
-using webrtc::IceCandidateType;
 
 namespace cricket {
 namespace {
@@ -142,6 +141,7 @@ bool WriteStunMessage(const StunMessage& msg, ByteBufferWriter* buf) {
 class TestPort : public Port {
  public:
   TestPort(rtc::Thread* thread,
+           absl::string_view type,
            rtc::PacketSocketFactory* factory,
            const rtc::Network* network,
            uint16_t min_port,
@@ -150,7 +150,7 @@ class TestPort : public Port {
            absl::string_view password,
            const webrtc::FieldTrialsView* field_trials = nullptr)
       : Port(thread,
-             IceCandidateType::kHost,
+             type,
              factory,
              network,
              min_port,
@@ -185,7 +185,7 @@ class TestPort : public Port {
     // Act as if the socket was bound to the best IP on the network, to the
     // first port in the allowed range.
     rtc::SocketAddress addr(Network()->GetBestIP(), min_port());
-    AddAddress(addr, addr, rtc::SocketAddress(), "udp", "", "", type(),
+    AddAddress(addr, addr, rtc::SocketAddress(), "udp", "", "", Type(),
                ICE_TYPE_PREFERENCE_HOST, 0, "", true);
   }
 
@@ -197,12 +197,12 @@ class TestPort : public Port {
 
   // Exposed for testing candidate building.
   void AddCandidateAddress(const rtc::SocketAddress& addr) {
-    AddAddress(addr, addr, rtc::SocketAddress(), "udp", "", "", type(),
+    AddAddress(addr, addr, rtc::SocketAddress(), "udp", "", "", Type(),
                type_preference_, 0, "", false);
   }
   void AddCandidateAddress(const rtc::SocketAddress& addr,
                            const rtc::SocketAddress& base_address,
-                           IceCandidateType type,
+                           absl::string_view type,
                            int type_preference,
                            bool final) {
     AddAddress(addr, base_address, rtc::SocketAddress(), "udp", "", "", type,
@@ -825,9 +825,9 @@ class PortTest : public ::testing::Test, public sigslot::has_slots<> {
       absl::string_view username,
       absl::string_view password,
       const webrtc::FieldTrialsView* field_trials = nullptr) {
-    auto port =
-        std::make_unique<TestPort>(&main_, &socket_factory_, MakeNetwork(addr),
-                                   0, 0, username, password, field_trials);
+    auto port = std::make_unique<TestPort>(
+        &main_, cricket::LOCAL_PORT_TYPE, &socket_factory_, MakeNetwork(addr),
+        0, 0, username, password, field_trials);
     port->SignalRoleConflict.connect(this, &PortTest::OnRoleConflict);
     return port;
   }
@@ -845,8 +845,9 @@ class PortTest : public ::testing::Test, public sigslot::has_slots<> {
   std::unique_ptr<TestPort> CreateTestPort(const rtc::Network* network,
                                            absl::string_view username,
                                            absl::string_view password) {
-    auto port = std::make_unique<TestPort>(&main_, &socket_factory_, network, 0,
-                                           0, username, password);
+    auto port = std::make_unique<TestPort>(&main_, cricket::LOCAL_PORT_TYPE,
+                                           &socket_factory_, network, 0, 0,
+                                           username, password);
     port->SignalRoleConflict.connect(this, &PortTest::OnRoleConflict);
     return port;
   }
@@ -2703,11 +2704,9 @@ TEST_F(PortTest, TestComputeCandidatePriorityWithPriorityAdjustment) {
 TEST_F(PortTest, TestFoundation) {
   auto testport = CreateTestPort(kLocalAddr1, "name", "pass");
   testport->SetIceTiebreaker(kTiebreakerDefault);
-  testport->AddCandidateAddress(kLocalAddr1, kLocalAddr1,
-                                IceCandidateType::kHost,
+  testport->AddCandidateAddress(kLocalAddr1, kLocalAddr1, LOCAL_PORT_TYPE,
                                 cricket::ICE_TYPE_PREFERENCE_HOST, false);
-  testport->AddCandidateAddress(kLocalAddr2, kLocalAddr1,
-                                IceCandidateType::kSrflx,
+  testport->AddCandidateAddress(kLocalAddr2, kLocalAddr1, STUN_PORT_TYPE,
                                 cricket::ICE_TYPE_PREFERENCE_SRFLX, true);
   EXPECT_NE(testport->Candidates()[0].foundation(),
             testport->Candidates()[1].foundation());
@@ -3776,8 +3775,7 @@ TEST_F(PortTest, TestAddConnectionWithSameAddress) {
   port->PrepareAddress();
   EXPECT_EQ(1u, port->Candidates().size());
   rtc::SocketAddress address("1.1.1.1", 5000);
-  cricket::Candidate candidate(1, "udp", address, 0, "", "",
-                               IceCandidateType::kRelay, 0, "");
+  cricket::Candidate candidate(1, "udp", address, 0, "", "", "relay", 0, "");
   cricket::Connection* conn1 =
       port->CreateConnection(candidate, Port::ORIGIN_MESSAGE);
   cricket::Connection* conn_in_use = port->GetConnection(address);
diff --git a/p2p/base/stun_port.cc b/p2p/base/stun_port.cc
index cf8830afff..648933fd9e 100644
--- a/p2p/base/stun_port.cc
+++ b/p2p/base/stun_port.cc
@@ -160,7 +160,7 @@ bool UDPPort::AddressResolver::GetResolvedAddress(
 }
 
 UDPPort::UDPPort(rtc::Thread* thread,
-                 webrtc::IceCandidateType type,
+                 absl::string_view type,
                  rtc::PacketSocketFactory* factory,
                  const rtc::Network* network,
                  rtc::AsyncPacketSocket* socket,
@@ -182,7 +182,7 @@ UDPPort::UDPPort(rtc::Thread* thread,
       emit_local_for_anyaddress_(emit_local_for_anyaddress) {}
 
 UDPPort::UDPPort(rtc::Thread* thread,
-                 webrtc::IceCandidateType type,
+                 absl::string_view type,
                  rtc::PacketSocketFactory* factory,
                  const rtc::Network* network,
                  uint16_t min_port,
@@ -380,8 +380,7 @@ void UDPPort::OnLocalAddressReady(rtc::AsyncPacketSocket* socket,
   MaybeSetDefaultLocalAddress(&addr);
 
   AddAddress(addr, addr, rtc::SocketAddress(), UDP_PROTOCOL_NAME, "", "",
-             webrtc::IceCandidateType::kHost, ICE_TYPE_PREFERENCE_HOST, 0, "",
-             false);
+             LOCAL_PORT_TYPE, ICE_TYPE_PREFERENCE_HOST, 0, "", false);
   MaybePrepareStunCandidate();
 }
 
@@ -542,7 +541,7 @@ void UDPPort::OnStunBindingRequestSucceeded(
     url << "stun:" << stun_server_addr.hostname() << ":"
         << stun_server_addr.port();
     AddAddress(stun_reflected_addr, socket_->GetLocalAddress(), related_address,
-               UDP_PROTOCOL_NAME, "", "", webrtc::IceCandidateType::kSrflx,
+               UDP_PROTOCOL_NAME, "", "", STUN_PORT_TYPE,
                ICE_TYPE_PREFERENCE_SRFLX, 0, url.str(), false);
   }
   MaybeSetPortCompleteOrError();
@@ -655,7 +654,7 @@ StunPort::StunPort(rtc::Thread* thread,
                    const ServerAddresses& servers,
                    const webrtc::FieldTrialsView* field_trials)
     : UDPPort(thread,
-              webrtc::IceCandidateType::kSrflx,
+              STUN_PORT_TYPE,
               factory,
               network,
               min_port,
diff --git a/p2p/base/stun_port.h b/p2p/base/stun_port.h
index f558b9266f..a28983b040 100644
--- a/p2p/base/stun_port.h
+++ b/p2p/base/stun_port.h
@@ -46,9 +46,9 @@ class RTC_EXPORT UDPPort : public Port {
       absl::optional<int> stun_keepalive_interval,
       const webrtc::FieldTrialsView* field_trials = nullptr) {
     // Using `new` to access a non-public constructor.
-    auto port = absl::WrapUnique(new UDPPort(
-        thread, webrtc::IceCandidateType::kHost, factory, network, socket,
-        username, password, emit_local_for_anyaddress, field_trials));
+    auto port = absl::WrapUnique(
+        new UDPPort(thread, LOCAL_PORT_TYPE, factory, network, socket, username,
+                    password, emit_local_for_anyaddress, field_trials));
     port->set_stun_keepalive_delay(stun_keepalive_interval);
     if (!port->Init()) {
       return nullptr;
@@ -69,8 +69,8 @@ class RTC_EXPORT UDPPort : public Port {
       const webrtc::FieldTrialsView* field_trials = nullptr) {
     // Using `new` to access a non-public constructor.
     auto port = absl::WrapUnique(new UDPPort(
-        thread, webrtc::IceCandidateType::kHost, factory, network, min_port,
-        max_port, username, password, emit_local_for_anyaddress, field_trials));
+        thread, LOCAL_PORT_TYPE, factory, network, min_port, max_port, username,
+        password, emit_local_for_anyaddress, field_trials));
     port->set_stun_keepalive_delay(stun_keepalive_interval);
     if (!port->Init()) {
       return nullptr;
@@ -118,7 +118,7 @@ class RTC_EXPORT UDPPort : public Port {
 
  protected:
   UDPPort(rtc::Thread* thread,
-          webrtc::IceCandidateType type,
+          absl::string_view type,
           rtc::PacketSocketFactory* factory,
           const rtc::Network* network,
           uint16_t min_port,
@@ -129,7 +129,7 @@ class RTC_EXPORT UDPPort : public Port {
           const webrtc::FieldTrialsView* field_trials);
 
   UDPPort(rtc::Thread* thread,
-          webrtc::IceCandidateType type,
+          absl::string_view type,
           rtc::PacketSocketFactory* factory,
           const rtc::Network* network,
           rtc::AsyncPacketSocket* socket,
diff --git a/p2p/base/tcp_port.cc b/p2p/base/tcp_port.cc
index b1c94a6be7..948849800c 100644
--- a/p2p/base/tcp_port.cc
+++ b/p2p/base/tcp_port.cc
@@ -86,7 +86,6 @@
 #include "rtc_base/thread.h"
 
 namespace cricket {
-using ::webrtc::IceCandidateType;
 using ::webrtc::SafeTask;
 using ::webrtc::TimeDelta;
 
@@ -100,7 +99,7 @@ TCPPort::TCPPort(rtc::Thread* thread,
                  bool allow_listen,
                  const webrtc::FieldTrialsView* field_trials)
     : Port(thread,
-           IceCandidateType::kHost,
+           LOCAL_PORT_TYPE,
            factory,
            network,
            min_port,
@@ -182,10 +181,10 @@ void TCPPort::PrepareAddress() {
     // failed, we still want to add the socket address.
     RTC_LOG(LS_VERBOSE) << "Preparing TCP address, current state: "
                         << static_cast<int>(listen_socket_->GetState());
-    AddAddress(
-        listen_socket_->GetLocalAddress(), listen_socket_->GetLocalAddress(),
-        rtc::SocketAddress(), TCP_PROTOCOL_NAME, "", TCPTYPE_PASSIVE_STR,
-        IceCandidateType::kHost, ICE_TYPE_PREFERENCE_HOST_TCP, 0, "", true);
+    AddAddress(listen_socket_->GetLocalAddress(),
+               listen_socket_->GetLocalAddress(), rtc::SocketAddress(),
+               TCP_PROTOCOL_NAME, "", TCPTYPE_PASSIVE_STR, LOCAL_PORT_TYPE,
+               ICE_TYPE_PREFERENCE_HOST_TCP, 0, "", true);
   } else {
     RTC_LOG(LS_INFO) << ToString()
                      << ": Not listening due to firewall restrictions.";
@@ -200,8 +199,7 @@ void TCPPort::PrepareAddress() {
     AddAddress(rtc::SocketAddress(Network()->GetBestIP(), DISCARD_PORT),
                rtc::SocketAddress(Network()->GetBestIP(), 0),
                rtc::SocketAddress(), TCP_PROTOCOL_NAME, "", TCPTYPE_ACTIVE_STR,
-               IceCandidateType::kHost, ICE_TYPE_PREFERENCE_HOST_TCP, 0, "",
-               true);
+               LOCAL_PORT_TYPE, ICE_TYPE_PREFERENCE_HOST_TCP, 0, "", true);
   }
 }
 
diff --git a/p2p/base/turn_port.cc b/p2p/base/turn_port.cc
index 965a68b3a3..bc35a2250a 100644
--- a/p2p/base/turn_port.cc
+++ b/p2p/base/turn_port.cc
@@ -37,7 +37,6 @@
 
 namespace cricket {
 
-using ::webrtc::IceCandidateType;
 using ::webrtc::SafeTask;
 using ::webrtc::TaskQueueBase;
 using ::webrtc::TimeDelta;
@@ -223,7 +222,7 @@ TurnPort::TurnPort(TaskQueueBase* thread,
                    rtc::SSLCertificateVerifier* tls_cert_verifier,
                    const webrtc::FieldTrialsView* field_trials)
     : Port(thread,
-           IceCandidateType::kRelay,
+           RELAY_PORT_TYPE,
            factory,
            network,
            username,
@@ -265,7 +264,7 @@ TurnPort::TurnPort(TaskQueueBase* thread,
                    rtc::SSLCertificateVerifier* tls_cert_verifier,
                    const webrtc::FieldTrialsView* field_trials)
     : Port(thread,
-           IceCandidateType::kRelay,
+           RELAY_PORT_TYPE,
            factory,
            network,
            min_port,
@@ -888,9 +887,8 @@ void TurnPort::OnAllocateSuccess(const rtc::SocketAddress& address,
              UDP_PROTOCOL_NAME,
              ProtoToString(server_address_.proto),  // The first hop protocol.
              "",  // TCP candidate type, empty for turn candidates.
-             IceCandidateType::kRelay,
-             GetRelayPreference(server_address_.proto), server_priority_,
-             server_url_, true);
+             RELAY_PORT_TYPE, GetRelayPreference(server_address_.proto),
+             server_priority_, server_url_, true);
 }
 
 void TurnPort::OnAllocateError(int error_code, absl::string_view reason) {
diff --git a/p2p/base/turn_port_unittest.cc b/p2p/base/turn_port_unittest.cc
index eaf28e4ce4..169467d76c 100644
--- a/p2p/base/turn_port_unittest.cc
+++ b/p2p/base/turn_port_unittest.cc
@@ -57,7 +57,6 @@ using ::testing::DoAll;
 using ::testing::Return;
 using ::testing::ReturnPointee;
 using ::testing::SetArgPointee;
-using ::webrtc::IceCandidateType;
 
 static const SocketAddress kLocalAddr1("11.11.11.11", 0);
 static const SocketAddress kLocalAddr2("22.22.22.22", 0);
@@ -1599,8 +1598,7 @@ TEST_F(TurnPortTest, TestCandidateAddressFamilyMatch) {
 
   // Create an IPv4 candidate. It will match the TURN candidate.
   Candidate remote_candidate(ICE_CANDIDATE_COMPONENT_RTP, "udp", kLocalAddr2, 0,
-                             "", "", IceCandidateType::kHost, 0,
-                             kCandidateFoundation);
+                             "", "", "local", 0, kCandidateFoundation);
   remote_candidate.set_address(kLocalAddr2);
   Connection* conn =
       turn_port_->CreateConnection(remote_candidate, Port::ORIGIN_MESSAGE);
diff --git a/pc/jsep_session_description_unittest.cc b/pc/jsep_session_description_unittest.cc
index c3e1f330e4..c4b993d687 100644
--- a/pc/jsep_session_description_unittest.cc
+++ b/pc/jsep_session_description_unittest.cc
@@ -36,7 +36,6 @@ using cricket::MediaProtocolType;
 using ::testing::Values;
 using webrtc::IceCandidateCollection;
 using webrtc::IceCandidateInterface;
-using webrtc::IceCandidateType;
 using webrtc::JsepIceCandidate;
 using webrtc::JsepSessionDescription;
 using webrtc::SdpType;
@@ -90,8 +89,7 @@ class JsepSessionDescriptionTest : public ::testing::Test {
     int port = 1234;
     rtc::SocketAddress address("127.0.0.1", port++);
     cricket::Candidate candidate(cricket::ICE_CANDIDATE_COMPONENT_RTP, "udp",
-                                 address, 1, "", "", IceCandidateType::kHost, 0,
-                                 "1");
+                                 address, 1, "", "", "local", 0, "1");
     candidate_ = candidate;
     const std::string session_id = rtc::ToString(rtc::CreateRandomId64());
     const std::string session_version = rtc::ToString(rtc::CreateRandomId());
@@ -140,11 +138,11 @@ TEST_F(JsepSessionDescriptionTest, CloneWithCandidates) {
   cricket::Candidate candidate_v4(
       cricket::ICE_CANDIDATE_COMPONENT_RTP, "udp",
       rtc::SocketAddress("192.168.1.5", 1234), kCandidatePriority, "", "",
-      IceCandidateType::kSrflx, kCandidateGeneration, kCandidateFoundation);
+      cricket::STUN_PORT_TYPE, kCandidateGeneration, kCandidateFoundation);
   cricket::Candidate candidate_v6(
       cricket::ICE_CANDIDATE_COMPONENT_RTP, "udp",
       rtc::SocketAddress("::1", 1234), kCandidatePriority, "", "",
-      IceCandidateType::kHost, kCandidateGeneration, kCandidateFoundation);
+      cricket::LOCAL_PORT_TYPE, kCandidateGeneration, kCandidateFoundation);
 
   JsepIceCandidate jice_v4("audio", 0, candidate_v4);
   JsepIceCandidate jice_v6("audio", 0, candidate_v6);
@@ -267,7 +265,7 @@ TEST_F(JsepSessionDescriptionTest, AddHostnameCandidate) {
   c.set_component(cricket::ICE_CANDIDATE_COMPONENT_RTP);
   c.set_protocol(cricket::UDP_PROTOCOL_NAME);
   c.set_address(rtc::SocketAddress("example.local", 1234));
-  c.set_type(IceCandidateType::kHost);
+  c.set_type(cricket::LOCAL_PORT_TYPE);
   const size_t audio_index = 0;
   JsepIceCandidate hostname_candidate("audio", audio_index, c);
   EXPECT_TRUE(jsep_desc_->AddCandidate(&hostname_candidate));
@@ -298,7 +296,7 @@ TEST_F(JsepSessionDescriptionTest, SerializeDeserializeWithHostnameCandidate) {
   c.set_component(cricket::ICE_CANDIDATE_COMPONENT_RTP);
   c.set_protocol(cricket::UDP_PROTOCOL_NAME);
   c.set_address(rtc::SocketAddress("example.local", 1234));
-  c.set_type(IceCandidateType::kHost);
+  c.set_type(cricket::LOCAL_PORT_TYPE);
   const size_t audio_index = 0;
   const size_t video_index = 1;
   JsepIceCandidate hostname_candidate_audio("audio", audio_index, c);
@@ -350,11 +348,11 @@ TEST_F(JsepSessionDescriptionTest, SerializeSessionDescriptionWithIPv6Only) {
   cricket::Candidate candidate1(
       cricket::ICE_CANDIDATE_COMPONENT_RTP, "udp",
       rtc::SocketAddress("::1", 1234), kCandidatePriority, "", "",
-      IceCandidateType::kSrflx, kCandidateGeneration, kCandidateFoundation);
+      cricket::STUN_PORT_TYPE, kCandidateGeneration, kCandidateFoundation);
   cricket::Candidate candidate2(
       cricket::ICE_CANDIDATE_COMPONENT_RTP, "udp",
       rtc::SocketAddress("::2", 1235), kCandidatePriority, "", "",
-      IceCandidateType::kHost, kCandidateGeneration, kCandidateFoundation);
+      cricket::LOCAL_PORT_TYPE, kCandidateGeneration, kCandidateFoundation);
 
   JsepIceCandidate jice1("audio", 0, candidate1);
   JsepIceCandidate jice2("audio", 0, candidate2);
@@ -380,11 +378,11 @@ TEST_F(JsepSessionDescriptionTest,
   cricket::Candidate candidate_v4(
       cricket::ICE_CANDIDATE_COMPONENT_RTP, "udp",
       rtc::SocketAddress("192.168.1.5", 1234), kCandidatePriority, "", "",
-      IceCandidateType::kSrflx, kCandidateGeneration, kCandidateFoundation);
+      cricket::STUN_PORT_TYPE, kCandidateGeneration, kCandidateFoundation);
   cricket::Candidate candidate_v6(
       cricket::ICE_CANDIDATE_COMPONENT_RTP, "udp",
       rtc::SocketAddress("::1", 1234), kCandidatePriority, "", "",
-      IceCandidateType::kHost, kCandidateGeneration, kCandidateFoundation);
+      cricket::LOCAL_PORT_TYPE, kCandidateGeneration, kCandidateFoundation);
 
   JsepIceCandidate jice_v4("audio", 0, candidate_v4);
   JsepIceCandidate jice_v6("audio", 0, candidate_v6);
@@ -411,11 +409,11 @@ TEST_F(JsepSessionDescriptionTest,
   cricket::Candidate candidate1(
       cricket::ICE_CANDIDATE_COMPONENT_RTP, "tcp",
       rtc::SocketAddress("::1", 1234), kCandidatePriority, "", "",
-      IceCandidateType::kSrflx, kCandidateGeneration, kCandidateFoundation);
+      cricket::STUN_PORT_TYPE, kCandidateGeneration, kCandidateFoundation);
   cricket::Candidate candidate2(
       cricket::ICE_CANDIDATE_COMPONENT_RTP, "udp",
       rtc::SocketAddress("fe80::1234:5678:abcd:ef12", 1235), kCandidatePriority,
-      "", "", IceCandidateType::kHost, kCandidateGeneration,
+      "", "", cricket::LOCAL_PORT_TYPE, kCandidateGeneration,
       kCandidateFoundation);
 
   JsepIceCandidate jice1("audio", 0, candidate1);
@@ -442,11 +440,11 @@ TEST_F(JsepSessionDescriptionTest, SerializeSessionDescriptionWithTCPOnly) {
   cricket::Candidate candidate1(
       cricket::ICE_CANDIDATE_COMPONENT_RTP, "tcp",
       rtc::SocketAddress("::1", 1234), kCandidatePriority, "", "",
-      IceCandidateType::kSrflx, kCandidateGeneration, kCandidateFoundation);
+      cricket::STUN_PORT_TYPE, kCandidateGeneration, kCandidateFoundation);
   cricket::Candidate candidate2(
       cricket::ICE_CANDIDATE_COMPONENT_RTP, "tcp",
       rtc::SocketAddress("::2", 1235), kCandidatePriority, "", "",
-      IceCandidateType::kHost, kCandidateGeneration, kCandidateFoundation);
+      cricket::LOCAL_PORT_TYPE, kCandidateGeneration, kCandidateFoundation);
 
   JsepIceCandidate jice1("audio", 0, candidate1);
   JsepIceCandidate jice2("audio", 0, candidate2);
@@ -469,19 +467,19 @@ TEST_F(JsepSessionDescriptionTest, RemoveCandidateAndSetConnectionAddress) {
   cricket::Candidate candidate1(
       cricket::ICE_CANDIDATE_COMPONENT_RTP, "udp",
       rtc::SocketAddress("::1", 1234), kCandidatePriority, "", "",
-      IceCandidateType::kHost, kCandidateGeneration, kCandidateFoundation);
+      cricket::LOCAL_PORT_TYPE, kCandidateGeneration, kCandidateFoundation);
   candidate1.set_transport_name("audio");
 
   cricket::Candidate candidate2(
       cricket::ICE_CANDIDATE_COMPONENT_RTP, "tcp",
       rtc::SocketAddress("::2", 1235), kCandidatePriority, "", "",
-      IceCandidateType::kHost, kCandidateGeneration, kCandidateFoundation);
+      cricket::LOCAL_PORT_TYPE, kCandidateGeneration, kCandidateFoundation);
   candidate2.set_transport_name("audio");
 
   cricket::Candidate candidate3(
       cricket::ICE_CANDIDATE_COMPONENT_RTP, "udp",
       rtc::SocketAddress("192.168.1.1", 1236), kCandidatePriority, "", "",
-      IceCandidateType::kHost, kCandidateGeneration, kCandidateFoundation);
+      cricket::LOCAL_PORT_TYPE, kCandidateGeneration, kCandidateFoundation);
   candidate3.set_transport_name("audio");
 
   JsepIceCandidate jice1("audio", 0, candidate1);
diff --git a/pc/legacy_stats_collector_unittest.cc b/pc/legacy_stats_collector_unittest.cc
index af3d3038e1..5f6140da54 100644
--- a/pc/legacy_stats_collector_unittest.cc
+++ b/pc/legacy_stats_collector_unittest.cc
@@ -1342,7 +1342,7 @@ TEST_F(LegacyStatsCollectorTest, IceCandidateReport) {
 
   cricket::Candidate local;
   EXPECT_GT(local.id().length(), 0u);
-  RTC_DCHECK_EQ(local.type(), IceCandidateType::kHost);
+  local.set_type(cricket::LOCAL_PORT_TYPE);
   local.set_protocol(cricket::UDP_PROTOCOL_NAME);
   local.set_address(kLocalAddress);
   local.set_priority(kPriority);
@@ -1350,7 +1350,7 @@ TEST_F(LegacyStatsCollectorTest, IceCandidateReport) {
 
   cricket::Candidate remote;
   EXPECT_GT(remote.id().length(), 0u);
-  remote.set_type(IceCandidateType::kPrflx);
+  remote.set_type(cricket::PRFLX_PORT_TYPE);
   remote.set_protocol(cricket::UDP_PROTOCOL_NAME);
   remote.set_address(kRemoteAddress);
   remote.set_priority(kPriority);
diff --git a/pc/peer_connection_bundle_unittest.cc b/pc/peer_connection_bundle_unittest.cc
index 12ab99440e..0db401276a 100644
--- a/pc/peer_connection_bundle_unittest.cc
+++ b/pc/peer_connection_bundle_unittest.cc
@@ -278,6 +278,7 @@ class PeerConnectionBundleBaseTest : public ::testing::Test {
     candidate.set_component(cricket::ICE_CANDIDATE_COMPONENT_DEFAULT);
     candidate.set_protocol(cricket::UDP_PROTOCOL_NAME);
     candidate.set_address(address);
+    candidate.set_type(cricket::LOCAL_PORT_TYPE);
     return candidate;
   }
 
diff --git a/pc/peer_connection_ice_unittest.cc b/pc/peer_connection_ice_unittest.cc
index 78d3103ab9..267cca4959 100644
--- a/pc/peer_connection_ice_unittest.cc
+++ b/pc/peer_connection_ice_unittest.cc
@@ -214,10 +214,10 @@ class PeerConnectionIceBaseTest : public ::testing::Test {
   cricket::Candidate CreateLocalUdpCandidate(
       const rtc::SocketAddress& address) {
     cricket::Candidate candidate;
-    RTC_DCHECK_EQ(candidate.type(), IceCandidateType::kHost);
     candidate.set_component(cricket::ICE_CANDIDATE_COMPONENT_DEFAULT);
     candidate.set_protocol(cricket::UDP_PROTOCOL_NAME);
     candidate.set_address(address);
+    candidate.set_type(cricket::LOCAL_PORT_TYPE);
     return candidate;
   }
 
diff --git a/pc/rtc_stats_collector_unittest.cc b/pc/rtc_stats_collector_unittest.cc
index 6c4cd69ea2..71542ca4bf 100644
--- a/pc/rtc_stats_collector_unittest.cc
+++ b/pc/rtc_stats_collector_unittest.cc
@@ -212,7 +212,7 @@ std::unique_ptr<cricket::Candidate> CreateFakeCandidate(
     int port,
     const std::string& protocol,
     const rtc::AdapterType adapter_type,
-    IceCandidateType candidate_type,
+    const absl::string_view candidate_type,
     uint32_t priority,
     const rtc::AdapterType underlying_type_for_vpn =
         rtc::ADAPTER_TYPE_UNKNOWN) {
@@ -1660,7 +1660,7 @@ TEST_F(RTCStatsCollectorTest, CollectRTCIceCandidateStats) {
   // Candidates in the first transport stats.
   std::unique_ptr<cricket::Candidate> a_local_host = CreateFakeCandidate(
       "1.2.3.4", 5, "a_local_host's protocol", rtc::ADAPTER_TYPE_VPN,
-      IceCandidateType::kHost, 0, rtc::ADAPTER_TYPE_ETHERNET);
+      cricket::LOCAL_PORT_TYPE, 0, rtc::ADAPTER_TYPE_ETHERNET);
   RTCLocalIceCandidateStats expected_a_local_host("I" + a_local_host->id(),
                                                   Timestamp::Zero());
   expected_a_local_host.transport_id = "Ta0";
@@ -1678,7 +1678,7 @@ TEST_F(RTCStatsCollectorTest, CollectRTCIceCandidateStats) {
 
   std::unique_ptr<cricket::Candidate> a_remote_srflx = CreateFakeCandidate(
       "6.7.8.9", 10, "remote_srflx's protocol", rtc::ADAPTER_TYPE_UNKNOWN,
-      IceCandidateType::kSrflx, 1);
+      cricket::STUN_PORT_TYPE, 1);
   RTCRemoteIceCandidateStats expected_a_remote_srflx("I" + a_remote_srflx->id(),
                                                      Timestamp::Zero());
   expected_a_remote_srflx.transport_id = "Ta0";
@@ -1693,7 +1693,7 @@ TEST_F(RTCStatsCollectorTest, CollectRTCIceCandidateStats) {
 
   std::unique_ptr<cricket::Candidate> a_local_prflx = CreateFakeCandidate(
       "11.12.13.14", 15, "a_local_prflx's protocol",
-      rtc::ADAPTER_TYPE_CELLULAR_2G, IceCandidateType::kPrflx, 2);
+      rtc::ADAPTER_TYPE_CELLULAR_2G, cricket::PRFLX_PORT_TYPE, 2);
   RTCLocalIceCandidateStats expected_a_local_prflx("I" + a_local_prflx->id(),
                                                    Timestamp::Zero());
   expected_a_local_prflx.transport_id = "Ta0";
@@ -1711,7 +1711,7 @@ TEST_F(RTCStatsCollectorTest, CollectRTCIceCandidateStats) {
 
   std::unique_ptr<cricket::Candidate> a_remote_relay = CreateFakeCandidate(
       "16.17.18.19", 20, "a_remote_relay's protocol", rtc::ADAPTER_TYPE_UNKNOWN,
-      IceCandidateType::kRelay, 3);
+      cricket::RELAY_PORT_TYPE, 3);
   RTCRemoteIceCandidateStats expected_a_remote_relay("I" + a_remote_relay->id(),
                                                      Timestamp::Zero());
   expected_a_remote_relay.transport_id = "Ta0";
@@ -1726,7 +1726,7 @@ TEST_F(RTCStatsCollectorTest, CollectRTCIceCandidateStats) {
 
   std::unique_ptr<cricket::Candidate> a_local_relay = CreateFakeCandidate(
       "16.17.18.19", 21, "a_local_relay's protocol", rtc::ADAPTER_TYPE_UNKNOWN,
-      IceCandidateType::kRelay, 1);
+      cricket::RELAY_PORT_TYPE, 1);
   a_local_relay->set_relay_protocol("tcp");
   a_local_relay->set_url("turn:url1");
 
@@ -1749,7 +1749,7 @@ TEST_F(RTCStatsCollectorTest, CollectRTCIceCandidateStats) {
 
   std::unique_ptr<cricket::Candidate> a_local_relay_prflx = CreateFakeCandidate(
       "11.12.13.20", 22, "a_local_relay_prflx's protocol",
-      rtc::ADAPTER_TYPE_UNKNOWN, IceCandidateType::kPrflx, 1);
+      rtc::ADAPTER_TYPE_UNKNOWN, cricket::PRFLX_PORT_TYPE, 1);
   a_local_relay_prflx->set_relay_protocol("udp");
 
   RTCLocalIceCandidateStats expected_a_local_relay_prflx(
@@ -1771,7 +1771,7 @@ TEST_F(RTCStatsCollectorTest, CollectRTCIceCandidateStats) {
   // A non-paired local candidate.
   std::unique_ptr<cricket::Candidate> a_local_host_not_paired =
       CreateFakeCandidate("1.2.3.4", 4404, "a_local_host_not_paired's protocol",
-                          rtc::ADAPTER_TYPE_VPN, IceCandidateType::kHost, 0,
+                          rtc::ADAPTER_TYPE_VPN, cricket::LOCAL_PORT_TYPE, 0,
                           rtc::ADAPTER_TYPE_ETHERNET);
   RTCLocalIceCandidateStats expected_a_local_host_not_paired(
       "I" + a_local_host_not_paired->id(), Timestamp::Zero());
@@ -1792,7 +1792,7 @@ TEST_F(RTCStatsCollectorTest, CollectRTCIceCandidateStats) {
   // Candidates in the second transport stats.
   std::unique_ptr<cricket::Candidate> b_local =
       CreateFakeCandidate("42.42.42.42", 42, "b_local's protocol",
-                          rtc::ADAPTER_TYPE_WIFI, IceCandidateType::kHost, 42);
+                          rtc::ADAPTER_TYPE_WIFI, cricket::LOCAL_PORT_TYPE, 42);
   RTCLocalIceCandidateStats expected_b_local("I" + b_local->id(),
                                              Timestamp::Zero());
   expected_b_local.transport_id = "Tb0";
@@ -1810,7 +1810,7 @@ TEST_F(RTCStatsCollectorTest, CollectRTCIceCandidateStats) {
 
   std::unique_ptr<cricket::Candidate> b_remote = CreateFakeCandidate(
       "42.42.42.42", 42, "b_remote's protocol", rtc::ADAPTER_TYPE_UNKNOWN,
-      IceCandidateType::kHost, 42);
+      cricket::LOCAL_PORT_TYPE, 42);
   RTCRemoteIceCandidateStats expected_b_remote("I" + b_remote->id(),
                                                Timestamp::Zero());
   expected_b_remote.transport_id = "Tb0";
@@ -1911,12 +1911,12 @@ TEST_F(RTCStatsCollectorTest, CollectRTCIceCandidatePairStats) {
 
   std::unique_ptr<cricket::Candidate> local_candidate =
       CreateFakeCandidate("42.42.42.42", 42, "protocol", rtc::ADAPTER_TYPE_WIFI,
-                          IceCandidateType::kHost, 42);
+                          cricket::LOCAL_PORT_TYPE, 42);
   local_candidate->set_username("local_iceusernamefragment");
 
   std::unique_ptr<cricket::Candidate> remote_candidate = CreateFakeCandidate(
       "42.42.42.42", 42, "protocol", rtc::ADAPTER_TYPE_UNKNOWN,
-      IceCandidateType::kSrflx, 42);
+      cricket::STUN_PORT_TYPE, 42);
   remote_candidate->set_related_address(rtc::SocketAddress("192.168.2.1", 43));
   remote_candidate->set_username("remote_iceusernamefragment");
 
@@ -2735,17 +2735,17 @@ TEST_F(RTCStatsCollectorTest, CollectRTCTransportStats) {
 
   std::unique_ptr<cricket::Candidate> rtp_local_candidate =
       CreateFakeCandidate("42.42.42.42", 42, "protocol", rtc::ADAPTER_TYPE_WIFI,
-                          IceCandidateType::kHost, 42);
+                          cricket::LOCAL_PORT_TYPE, 42);
   std::unique_ptr<cricket::Candidate> rtp_remote_candidate =
       CreateFakeCandidate("42.42.42.42", 42, "protocol",
-                          rtc::ADAPTER_TYPE_UNKNOWN, IceCandidateType::kHost,
+                          rtc::ADAPTER_TYPE_UNKNOWN, cricket::LOCAL_PORT_TYPE,
                           42);
   std::unique_ptr<cricket::Candidate> rtcp_local_candidate =
       CreateFakeCandidate("42.42.42.42", 42, "protocol", rtc::ADAPTER_TYPE_WIFI,
-                          IceCandidateType::kHost, 42);
+                          cricket::LOCAL_PORT_TYPE, 42);
   std::unique_ptr<cricket::Candidate> rtcp_remote_candidate =
       CreateFakeCandidate("42.42.42.42", 42, "protocol",
-                          rtc::ADAPTER_TYPE_UNKNOWN, IceCandidateType::kHost,
+                          rtc::ADAPTER_TYPE_UNKNOWN, cricket::LOCAL_PORT_TYPE,
                           42);
 
   cricket::ConnectionInfo rtp_connection_info;
@@ -2907,17 +2907,17 @@ TEST_F(RTCStatsCollectorTest, CollectRTCTransportStatsWithCrypto) {
 
   std::unique_ptr<cricket::Candidate> rtp_local_candidate =
       CreateFakeCandidate("42.42.42.42", 42, "protocol", rtc::ADAPTER_TYPE_WIFI,
-                          IceCandidateType::kHost, 42);
+                          cricket::LOCAL_PORT_TYPE, 42);
   std::unique_ptr<cricket::Candidate> rtp_remote_candidate =
       CreateFakeCandidate("42.42.42.42", 42, "protocol",
-                          rtc::ADAPTER_TYPE_UNKNOWN, IceCandidateType::kHost,
+                          rtc::ADAPTER_TYPE_UNKNOWN, cricket::LOCAL_PORT_TYPE,
                           42);
   std::unique_ptr<cricket::Candidate> rtcp_local_candidate =
       CreateFakeCandidate("42.42.42.42", 42, "protocol", rtc::ADAPTER_TYPE_WIFI,
-                          IceCandidateType::kHost, 42);
+                          cricket::LOCAL_PORT_TYPE, 42);
   std::unique_ptr<cricket::Candidate> rtcp_remote_candidate =
       CreateFakeCandidate("42.42.42.42", 42, "protocol",
-                          rtc::ADAPTER_TYPE_UNKNOWN, IceCandidateType::kHost,
+                          rtc::ADAPTER_TYPE_UNKNOWN, cricket::LOCAL_PORT_TYPE,
                           42);
 
   cricket::ConnectionInfo rtp_connection_info;
diff --git a/pc/webrtc_sdp.cc b/pc/webrtc_sdp.cc
index b6cea4dfbf..ea9c8580cd 100644
--- a/pc/webrtc_sdp.cc
+++ b/pc/webrtc_sdp.cc
@@ -1120,16 +1120,16 @@ bool ParseCandidate(absl::string_view message,
       return ParseFailed(first_line, "Unsupported transport type.", error);
   }
 
-  IceCandidateType candidate_type;
+  absl::string_view candidate_type;
   const absl::string_view type = fields[7];
   if (type == kCandidateHost) {
-    candidate_type = IceCandidateType::kHost;
+    candidate_type = cricket::LOCAL_PORT_TYPE;
   } else if (type == kCandidateSrflx) {
-    candidate_type = IceCandidateType::kSrflx;
+    candidate_type = cricket::STUN_PORT_TYPE;
   } else if (type == kCandidateRelay) {
-    candidate_type = IceCandidateType::kRelay;
+    candidate_type = cricket::RELAY_PORT_TYPE;
   } else if (type == kCandidatePrflx) {
-    candidate_type = IceCandidateType::kPrflx;
+    candidate_type = cricket::PRFLX_PORT_TYPE;
   } else {
     return ParseFailed(first_line, "Unsupported candidate type.", error);
   }
diff --git a/pc/webrtc_sdp_unittest.cc b/pc/webrtc_sdp_unittest.cc
index afa2304666..999f0b6b26 100644
--- a/pc/webrtc_sdp_unittest.cc
+++ b/pc/webrtc_sdp_unittest.cc
@@ -61,7 +61,9 @@ using cricket::ContentInfo;
 using cricket::ICE_CANDIDATE_COMPONENT_RTCP;
 using cricket::ICE_CANDIDATE_COMPONENT_RTP;
 using cricket::kFecSsrcGroupSemantics;
+using cricket::LOCAL_PORT_TYPE;
 using cricket::MediaProtocolType;
+using cricket::RELAY_PORT_TYPE;
 using cricket::RidDescription;
 using cricket::RidDirection;
 using cricket::SctpDataContentDescription;
@@ -69,6 +71,7 @@ using cricket::SessionDescription;
 using cricket::SimulcastDescription;
 using cricket::SimulcastLayer;
 using cricket::StreamParams;
+using cricket::STUN_PORT_TYPE;
 using cricket::TransportDescription;
 using cricket::TransportInfo;
 using cricket::VideoContentDescription;
@@ -76,7 +79,6 @@ using ::testing::ElementsAre;
 using ::testing::Field;
 using webrtc::IceCandidateCollection;
 using webrtc::IceCandidateInterface;
-using webrtc::IceCandidateType;
 using webrtc::JsepIceCandidate;
 using webrtc::JsepSessionDescription;
 using webrtc::RtpExtension;
@@ -1002,42 +1004,42 @@ class WebRtcSdpTest : public ::testing::Test {
     int port = 1234;
     rtc::SocketAddress address("192.168.1.5", port++);
     Candidate candidate1(ICE_CANDIDATE_COMPONENT_RTP, "udp", address,
-                         kCandidatePriority, "", "", IceCandidateType::kHost,
+                         kCandidatePriority, "", "", LOCAL_PORT_TYPE,
                          kCandidateGeneration, kCandidateFoundation1);
     address.SetPort(port++);
     Candidate candidate2(ICE_CANDIDATE_COMPONENT_RTCP, "udp", address,
-                         kCandidatePriority, "", "", IceCandidateType::kHost,
+                         kCandidatePriority, "", "", LOCAL_PORT_TYPE,
                          kCandidateGeneration, kCandidateFoundation1);
     address.SetPort(port++);
     Candidate candidate3(ICE_CANDIDATE_COMPONENT_RTCP, "udp", address,
-                         kCandidatePriority, "", "", IceCandidateType::kHost,
+                         kCandidatePriority, "", "", LOCAL_PORT_TYPE,
                          kCandidateGeneration, kCandidateFoundation1);
     address.SetPort(port++);
     Candidate candidate4(ICE_CANDIDATE_COMPONENT_RTP, "udp", address,
-                         kCandidatePriority, "", "", IceCandidateType::kHost,
+                         kCandidatePriority, "", "", LOCAL_PORT_TYPE,
                          kCandidateGeneration, kCandidateFoundation1);
 
     // v6 host
     rtc::SocketAddress v6_address("::1", port++);
     cricket::Candidate candidate5(cricket::ICE_CANDIDATE_COMPONENT_RTP, "udp",
                                   v6_address, kCandidatePriority, "", "",
-                                  IceCandidateType::kHost, kCandidateGeneration,
-                                  kCandidateFoundation2);
+                                  cricket::LOCAL_PORT_TYPE,
+                                  kCandidateGeneration, kCandidateFoundation2);
     v6_address.SetPort(port++);
     cricket::Candidate candidate6(cricket::ICE_CANDIDATE_COMPONENT_RTCP, "udp",
                                   v6_address, kCandidatePriority, "", "",
-                                  IceCandidateType::kHost, kCandidateGeneration,
-                                  kCandidateFoundation2);
+                                  cricket::LOCAL_PORT_TYPE,
+                                  kCandidateGeneration, kCandidateFoundation2);
     v6_address.SetPort(port++);
     cricket::Candidate candidate7(cricket::ICE_CANDIDATE_COMPONENT_RTCP, "udp",
                                   v6_address, kCandidatePriority, "", "",
-                                  IceCandidateType::kHost, kCandidateGeneration,
-                                  kCandidateFoundation2);
+                                  cricket::LOCAL_PORT_TYPE,
+                                  kCandidateGeneration, kCandidateFoundation2);
     v6_address.SetPort(port++);
     cricket::Candidate candidate8(cricket::ICE_CANDIDATE_COMPONENT_RTP, "udp",
                                   v6_address, kCandidatePriority, "", "",
-                                  IceCandidateType::kHost, kCandidateGeneration,
-                                  kCandidateFoundation2);
+                                  cricket::LOCAL_PORT_TYPE,
+                                  kCandidateGeneration, kCandidateFoundation2);
 
     // stun
     int port_stun = 2345;
@@ -1045,16 +1047,16 @@ class WebRtcSdpTest : public ::testing::Test {
     rtc::SocketAddress rel_address_stun("192.168.1.5", port_stun++);
     cricket::Candidate candidate9(cricket::ICE_CANDIDATE_COMPONENT_RTP, "udp",
                                   address_stun, kCandidatePriority, "", "",
-                                  IceCandidateType::kSrflx,
-                                  kCandidateGeneration, kCandidateFoundation3);
+                                  STUN_PORT_TYPE, kCandidateGeneration,
+                                  kCandidateFoundation3);
     candidate9.set_related_address(rel_address_stun);
 
     address_stun.SetPort(port_stun++);
     rel_address_stun.SetPort(port_stun++);
     cricket::Candidate candidate10(cricket::ICE_CANDIDATE_COMPONENT_RTCP, "udp",
                                    address_stun, kCandidatePriority, "", "",
-                                   IceCandidateType::kSrflx,
-                                   kCandidateGeneration, kCandidateFoundation3);
+                                   STUN_PORT_TYPE, kCandidateGeneration,
+                                   kCandidateFoundation3);
     candidate10.set_related_address(rel_address_stun);
 
     // relay
@@ -1062,13 +1064,13 @@ class WebRtcSdpTest : public ::testing::Test {
     rtc::SocketAddress address_relay("74.125.224.39", port_relay++);
     cricket::Candidate candidate11(cricket::ICE_CANDIDATE_COMPONENT_RTCP, "udp",
                                    address_relay, kCandidatePriority, "", "",
-                                   IceCandidateType::kRelay,
+                                   cricket::RELAY_PORT_TYPE,
                                    kCandidateGeneration, kCandidateFoundation4);
     address_relay.SetPort(port_relay++);
     cricket::Candidate candidate12(cricket::ICE_CANDIDATE_COMPONENT_RTP, "udp",
                                    address_relay, kCandidatePriority, "", "",
-                                   IceCandidateType::kRelay,
-                                   kCandidateGeneration, kCandidateFoundation4);
+                                   RELAY_PORT_TYPE, kCandidateGeneration,
+                                   kCandidateFoundation4);
 
     // voice
     candidates_.push_back(candidate1);
@@ -2231,10 +2233,9 @@ TEST_F(WebRtcSdpTest, SerializeCandidates) {
 
 TEST_F(WebRtcSdpTest, SerializeHostnameCandidate) {
   rtc::SocketAddress address("a.test", 1234);
-  cricket::Candidate candidate(cricket::ICE_CANDIDATE_COMPONENT_RTP, "udp",
-                               address, kCandidatePriority, "", "",
-                               IceCandidateType::kHost, kCandidateGeneration,
-                               kCandidateFoundation1);
+  cricket::Candidate candidate(
+      cricket::ICE_CANDIDATE_COMPONENT_RTP, "udp", address, kCandidatePriority,
+      "", "", LOCAL_PORT_TYPE, kCandidateGeneration, kCandidateFoundation1);
   JsepIceCandidate jcandidate(std::string("audio_content_name"), 0, candidate);
   std::string message = webrtc::SdpSerializeCandidate(jcandidate);
   EXPECT_EQ(std::string(kRawHostnameCandidate), message);
@@ -2243,7 +2244,7 @@ TEST_F(WebRtcSdpTest, SerializeHostnameCandidate) {
 TEST_F(WebRtcSdpTest, SerializeTcpCandidates) {
   Candidate candidate(ICE_CANDIDATE_COMPONENT_RTP, "tcp",
                       rtc::SocketAddress("192.168.1.5", 9), kCandidatePriority,
-                      "", "", IceCandidateType::kHost, kCandidateGeneration,
+                      "", "", LOCAL_PORT_TYPE, kCandidateGeneration,
                       kCandidateFoundation1);
   candidate.set_tcptype(cricket::TCPTYPE_ACTIVE_STR);
   std::unique_ptr<IceCandidateInterface> jcandidate(
@@ -2647,7 +2648,7 @@ TEST_F(WebRtcSdpTest, DeserializeCandidate) {
   // Make a cricket::Candidate equivalent to kSdpTcpCandidate string.
   Candidate candidate(ICE_CANDIDATE_COMPONENT_RTP, "tcp",
                       rtc::SocketAddress("192.168.1.5", 9), kCandidatePriority,
-                      "", "", IceCandidateType::kHost, kCandidateGeneration,
+                      "", "", LOCAL_PORT_TYPE, kCandidateGeneration,
                       kCandidateFoundation1);
   std::unique_ptr<IceCandidateInterface> jcandidate_template(
       new JsepIceCandidate(std::string("audio_content_name"), 0, candidate));
