From: =?UTF-8?q?Henrik=20Bostr=C3=B6m?= <hbos@webrtc.org>
Date: Thu, 15 Jun 2023 12:49:26 +0200
Subject: =?UTF-8?q?(cherry-pick-branch-heads/5790)=20[M115]=C2=A0Fix=20L1T?=
 =?UTF-8?q?x=20target=20bitrate=20bug=20when=20the=20standard=20API=20is?=
 =?UTF-8?q?=20used.?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

There are now multiple ways to configure VP9 L1Tx:
- Legacy API: configure legacy SVC and disable encodings, this gets
  interpreted as disabling spatial layers (non-standard API hack).
- Standard API: configure scalability_mode. This can be done either
  with a single encoding or multiple encodings. As long as only one
  encoding is active we get a single L1Tx ssrc, same as legacy API.

Due to a bug, the ApplySpatialLayerBitrateLimits() logic which tweaks
bitrates was only applied in the legacy API code path, not the standard
API code path, despite both code paths configuring L1Tx.

The issue is that IsSimulcastOrMultipleSpatialLayers() was checking if
`number_of_streams == 1`. This is true in legacy code path but not
standard code path. The fix is to look at
`numberOfSimulcastStreams == 1` instead, which is set to the correct
value regardless of code path used.

This CL adds comments documenting the difference between
`number_of_streams` and `numberOfSimulcastStreams` to reduce the risk
of more mistakes like this in the future.

(cherry picked from commit 2fec64484f0c1355db1dde236c3c205985a30a30)

Bug: chromium:1455039, b:279161263
Change-Id: I69789b68cc5d45ef1b3becd310687c8dec8e7c87
Reviewed-on: https://webrtc-review.googlesource.com/c/src/+/308722
Reviewed-by: Ilya Nikolaevskiy <ilnik@webrtc.org>
Commit-Queue: Henrik Boström <hbos@webrtc.org>
Reviewed-by: Erik Språng <sprang@webrtc.org>
Cr-Original-Commit-Position: refs/heads/main@{#40287}
Reviewed-on: https://webrtc-review.googlesource.com/c/src/+/308920
Cr-Commit-Position: refs/branch-heads/5790@{#3}
Cr-Branched-From: 2eacbbc03a4a41ea658661225eb1c8fc07884c33-refs/heads/main@{#40122}
---
 api/video_codecs/video_codec.h                |   9 ++
 pc/BUILD.gn                                   |   1 +
 ...er_connection_encodings_integrationtest.cc | 104 ++++++++++++++++++
 video/adaptation/bitrate_constraint.cc        |   3 +-
 .../adaptation/bitrate_constraint_unittest.cc |   2 +-
 .../video_stream_encoder_resource_manager.cc  |   5 +-
 .../video_stream_encoder_resource_manager.h   |   3 +-
 video/config/video_encoder_config.h           |   6 +
 video/video_stream_encoder.cc                 |   2 +-
 9 files changed, 129 insertions(+), 6 deletions(-)

diff --git a/api/video_codecs/video_codec.h b/api/video_codecs/video_codec.h
index 10bceda0d2..496cfb5e22 100644
--- a/api/video_codecs/video_codec.h
+++ b/api/video_codecs/video_codec.h
@@ -148,6 +148,15 @@ class RTC_EXPORT VideoCodec {
   bool active;
 
   unsigned int qpMax;
+  // The actual number of simulcast streams. This is <= 1 in singlecast (it can
+  // be 0 in old code paths), but it is also 1 in the {active,inactive,inactive}
+  // "single RTP simulcast" use case and the legacy kSVC use case. In all other
+  // cases this is the same as the number of encodings (which may include
+  // inactive encodings). In other words:
+  // - `numberOfSimulcastStreams <= 1` in singlecast and singlecast-like setups
+  //   including legacy kSVC (encodings interpreted as spatial layers) or
+  //   standard kSVC (1 active encoding).
+  // - `numberOfSimulcastStreams > 1` in simulcast of 2+ active encodings.
   unsigned char numberOfSimulcastStreams;
   SimulcastStream simulcastStream[kMaxSimulcastStreams];
   SpatialLayer spatialLayers[kMaxSpatialLayers];
diff --git a/pc/BUILD.gn b/pc/BUILD.gn
index a89e8a6908..2f671d2694 100644
--- a/pc/BUILD.gn
+++ b/pc/BUILD.gn
@@ -2435,6 +2435,7 @@ if (rtc_include_tests && !build_with_chromium) {
       "../api/transport:field_trial_based_config",
       "../api/transport:sctp_transport_factory_interface",
       "../api/transport/rtp:rtp_source",
+      "../api/units:data_rate",
       "../api/units:time_delta",
       "../api/units:timestamp",
       "../api/video:builtin_video_bitrate_allocator_factory",
diff --git a/pc/peer_connection_encodings_integrationtest.cc b/pc/peer_connection_encodings_integrationtest.cc
index 8e86724179..4ebcc0a17e 100644
--- a/pc/peer_connection_encodings_integrationtest.cc
+++ b/pc/peer_connection_encodings_integrationtest.cc
@@ -17,6 +17,7 @@
 #include "api/audio_codecs/opus_audio_encoder_factory.h"
 #include "api/rtp_parameters.h"
 #include "api/stats/rtcstats_objects.h"
+#include "api/units/data_rate.h"
 #include "api/video_codecs/video_decoder_factory_template.h"
 #include "api/video_codecs/video_decoder_factory_template_dav1d_adapter.h"
 #include "api/video_codecs/video_decoder_factory_template_libvpx_vp8_adapter.h"
@@ -55,6 +56,12 @@ constexpr TimeDelta kDefaultTimeout = TimeDelta::Seconds(5);
 // using simulated time.
 constexpr TimeDelta kLongTimeoutForRampingUp = TimeDelta::Minutes(1);
 
+// The max bitrate 1500 kbps may be subject to change in the future. What we're
+// interested in here is that all code paths that result in L1T3 result in the
+// same target bitrate which does not exceed this limit.
+constexpr DataRate kVp9ExpectedMaxBitrateForL1T3 =
+    DataRate::KilobitsPerSec(1500);
+
 struct StringParamToString {
   std::string operator()(const ::testing::TestParamInfo<std::string>& info) {
     return info.param;
@@ -792,6 +799,103 @@ TEST_F(PeerConnectionEncodingsIntegrationTest,
   EXPECT_EQ(*outbound_rtps[2]->bytes_sent, 0u);
 }
 
+TEST_F(PeerConnectionEncodingsIntegrationTest, VP9_TargetBitrate_LegacyL1T3) {
+  rtc::scoped_refptr<PeerConnectionTestWrapper> local_pc_wrapper = CreatePc();
+  rtc::scoped_refptr<PeerConnectionTestWrapper> remote_pc_wrapper = CreatePc();
+  ExchangeIceCandidates(local_pc_wrapper, remote_pc_wrapper);
+
+  std::vector<cricket::SimulcastLayer> layers =
+      CreateLayers({"f", "h", "q"}, /*active=*/true);
+  rtc::scoped_refptr<RtpTransceiverInterface> transceiver =
+      AddTransceiverWithSimulcastLayers(local_pc_wrapper, remote_pc_wrapper,
+                                        layers);
+  std::vector<RtpCodecCapability> codecs =
+      GetCapabilitiesAndRestrictToCodec(local_pc_wrapper, "VP9");
+  transceiver->SetCodecPreferences(codecs);
+
+  // In legacy SVC, disabling the bottom two layers encodings is interpreted as
+  // disabling the bottom two spatial layers resulting in L1T3.
+  rtc::scoped_refptr<RtpSenderInterface> sender = transceiver->sender();
+  RtpParameters parameters = sender->GetParameters();
+  parameters.encodings[0].active = false;
+  parameters.encodings[1].active = false;
+  parameters.encodings[2].active = true;
+  sender->SetParameters(parameters);
+
+  NegotiateWithSimulcastTweaks(local_pc_wrapper, remote_pc_wrapper, layers);
+  local_pc_wrapper->WaitForConnection();
+  remote_pc_wrapper->WaitForConnection();
+
+  // Wait until 720p L1T3 has ramped up to 720p. It may take additional time
+  // for the target bitrate to reach its maximum.
+  ASSERT_TRUE_WAIT(HasOutboundRtpWithRidAndScalabilityMode(local_pc_wrapper,
+                                                           "f", "L1T3", 720),
+                   kLongTimeoutForRampingUp.ms());
+
+  // The target bitrate typically reaches `kVp9ExpectedMaxBitrateForL1T3`
+  // in a short period of time. However to reduce risk of flakiness in bot
+  // environments, this test only fails if we we exceed the expected target.
+  rtc::Thread::Current()->SleepMs(1000);
+  rtc::scoped_refptr<const RTCStatsReport> report = GetStats(local_pc_wrapper);
+  std::vector<const RTCOutboundRtpStreamStats*> outbound_rtps =
+      report->GetStatsOfType<RTCOutboundRtpStreamStats>();
+  ASSERT_THAT(outbound_rtps, SizeIs(1));
+  DataRate target_bitrate =
+      DataRate::BitsPerSec(*outbound_rtps[0]->target_bitrate);
+  EXPECT_LE(target_bitrate.kbps(), kVp9ExpectedMaxBitrateForL1T3.kbps());
+}
+
+// Test coverage for https://crbug.com/1455039.
+TEST_F(PeerConnectionEncodingsIntegrationTest, VP9_TargetBitrate_StandardL1T3) {
+  rtc::scoped_refptr<PeerConnectionTestWrapper> local_pc_wrapper = CreatePc();
+  rtc::scoped_refptr<PeerConnectionTestWrapper> remote_pc_wrapper = CreatePc();
+  ExchangeIceCandidates(local_pc_wrapper, remote_pc_wrapper);
+
+  std::vector<cricket::SimulcastLayer> layers =
+      CreateLayers({"f", "h", "q"}, /*active=*/true);
+  rtc::scoped_refptr<RtpTransceiverInterface> transceiver =
+      AddTransceiverWithSimulcastLayers(local_pc_wrapper, remote_pc_wrapper,
+                                        layers);
+  std::vector<RtpCodecCapability> codecs =
+      GetCapabilitiesAndRestrictToCodec(local_pc_wrapper, "VP9");
+  transceiver->SetCodecPreferences(codecs);
+
+  // With standard APIs, L1T3 is explicitly specified and the encodings refers
+  // to the RTP streams, not the spatial layers. The end result should be
+  // equivalent to the legacy L1T3 case.
+  rtc::scoped_refptr<RtpSenderInterface> sender = transceiver->sender();
+  RtpParameters parameters = sender->GetParameters();
+  parameters.encodings[0].active = true;
+  parameters.encodings[0].scale_resolution_down_by = 1.0;
+  parameters.encodings[0].scalability_mode = "L1T3";
+  parameters.encodings[1].active = false;
+  parameters.encodings[2].active = false;
+  sender->SetParameters(parameters);
+
+  NegotiateWithSimulcastTweaks(local_pc_wrapper, remote_pc_wrapper, layers);
+  local_pc_wrapper->WaitForConnection();
+  remote_pc_wrapper->WaitForConnection();
+
+  // Wait until 720p L1T3 has ramped up to 720p. It may take additional time
+  // for the target bitrate to reach its maximum.
+  ASSERT_TRUE_WAIT(HasOutboundRtpWithRidAndScalabilityMode(local_pc_wrapper,
+                                                           "f", "L1T3", 720),
+                   kLongTimeoutForRampingUp.ms());
+
+  // The target bitrate typically reaches `kVp9ExpectedMaxBitrateForL1T3`
+  // in a short period of time. However to reduce risk of flakiness in bot
+  // environments, this test only fails if we we exceed the expected target.
+  rtc::Thread::Current()->SleepMs(1000);
+  rtc::scoped_refptr<const RTCStatsReport> report = GetStats(local_pc_wrapper);
+  std::vector<const RTCOutboundRtpStreamStats*> outbound_rtps =
+      report->GetStatsOfType<RTCOutboundRtpStreamStats>();
+  ASSERT_THAT(outbound_rtps, SizeIs(3));
+  auto* outbound_rtp = FindOutboundRtpByRid(outbound_rtps, "f");
+  ASSERT_TRUE(outbound_rtp);
+  DataRate target_bitrate = DataRate::BitsPerSec(*outbound_rtp->target_bitrate);
+  EXPECT_LE(target_bitrate.kbps(), kVp9ExpectedMaxBitrateForL1T3.kbps());
+}
+
 // Tests that use the standard path (specifying both `scalability_mode` and
 // `scale_resolution_down_by`) should pass for all codecs.
 class PeerConnectionEncodingsIntegrationParameterizedTest
diff --git a/video/adaptation/bitrate_constraint.cc b/video/adaptation/bitrate_constraint.cc
index bc36723d48..2f92095b2b 100644
--- a/video/adaptation/bitrate_constraint.cc
+++ b/video/adaptation/bitrate_constraint.cc
@@ -58,7 +58,8 @@ bool BitrateConstraint::IsAdaptationUpAllowed(
     }
 
     if (VideoStreamEncoderResourceManager::IsSimulcastOrMultipleSpatialLayers(
-            encoder_settings_->encoder_config())) {
+            encoder_settings_->encoder_config(),
+            encoder_settings_->video_codec())) {
       // Resolution bitrate limits usage is restricted to singlecast.
       return true;
     }
diff --git a/video/adaptation/bitrate_constraint_unittest.cc b/video/adaptation/bitrate_constraint_unittest.cc
index f9cb87e3c1..8a416db1fa 100644
--- a/video/adaptation/bitrate_constraint_unittest.cc
+++ b/video/adaptation/bitrate_constraint_unittest.cc
@@ -47,7 +47,7 @@ void FillCodecConfig(VideoCodec* video_codec,
                      bool svc) {
   size_t num_layers = params.size();
   video_codec->codecType = kVideoCodecVP8;
-  video_codec->numberOfSimulcastStreams = num_layers;
+  video_codec->numberOfSimulcastStreams = svc ? 1 : num_layers;
 
   encoder_config->number_of_streams = svc ? 1 : num_layers;
   encoder_config->simulcast_layers.resize(num_layers);
diff --git a/video/adaptation/video_stream_encoder_resource_manager.cc b/video/adaptation/video_stream_encoder_resource_manager.cc
index 0dcbc01ab6..46db686703 100644
--- a/video/adaptation/video_stream_encoder_resource_manager.cc
+++ b/video/adaptation/video_stream_encoder_resource_manager.cc
@@ -815,7 +815,8 @@ void VideoStreamEncoderResourceManager::OnQualityRampUp() {
 }
 
 bool VideoStreamEncoderResourceManager::IsSimulcastOrMultipleSpatialLayers(
-    const VideoEncoderConfig& encoder_config) {
+    const VideoEncoderConfig& encoder_config,
+    const VideoCodec& video_codec) {
   const std::vector<VideoStream>& simulcast_layers =
       encoder_config.simulcast_layers;
   if (simulcast_layers.empty()) {
@@ -824,7 +825,7 @@ bool VideoStreamEncoderResourceManager::IsSimulcastOrMultipleSpatialLayers(
 
   absl::optional<int> num_spatial_layers;
   if (simulcast_layers[0].scalability_mode.has_value() &&
-      encoder_config.number_of_streams == 1) {
+      video_codec.numberOfSimulcastStreams == 1) {
     num_spatial_layers = ScalabilityModeToNumSpatialLayers(
         *simulcast_layers[0].scalability_mode);
   }
diff --git a/video/adaptation/video_stream_encoder_resource_manager.h b/video/adaptation/video_stream_encoder_resource_manager.h
index e0de3f7d19..8925157bcf 100644
--- a/video/adaptation/video_stream_encoder_resource_manager.h
+++ b/video/adaptation/video_stream_encoder_resource_manager.h
@@ -153,7 +153,8 @@ class VideoStreamEncoderResourceManager
   void OnQualityRampUp() override;
 
   static bool IsSimulcastOrMultipleSpatialLayers(
-      const VideoEncoderConfig& encoder_config);
+      const VideoEncoderConfig& encoder_config,
+      const VideoCodec& video_codec);
 
  private:
   class InitialFrameDropper;
diff --git a/video/config/video_encoder_config.h b/video/config/video_encoder_config.h
index 5a79d58cbf..59c9a39f82 100644
--- a/video/config/video_encoder_config.h
+++ b/video/config/video_encoder_config.h
@@ -181,9 +181,15 @@ class VideoEncoderConfig {
   // down to lower layers for the video encoding.
   // `simulcast_layers` is also used for configuring non-simulcast (when there
   // is a single VideoStream).
+  // We have the same number of `simulcast_layers` as we have negotiated
+  // encodings, for example 3 are used in both simulcast and legacy kSVC.
   std::vector<VideoStream> simulcast_layers;
 
   // Max number of encoded VideoStreams to produce.
+  // This is the same as the number of encodings negotiated (i.e. SSRCs),
+  // whether or not those encodings are `active`, except for when legacy kSVC
+  // is used. In this case we have three SSRCs but `number_of_streams` is
+  // changed to 1 to tell lower layers to limit the number of streams.
   size_t number_of_streams;
 
   // Legacy Google conference mode flag for simulcast screenshare
diff --git a/video/video_stream_encoder.cc b/video/video_stream_encoder.cc
index 44fdbaa86b..c3d855c1c6 100644
--- a/video/video_stream_encoder.cc
+++ b/video/video_stream_encoder.cc
@@ -405,7 +405,7 @@ void ApplySpatialLayerBitrateLimits(
     return;
   }
   if (VideoStreamEncoderResourceManager::IsSimulcastOrMultipleSpatialLayers(
-          encoder_config) ||
+          encoder_config, *codec) ||
       encoder_config.simulcast_layers.size() <= 1) {
     // Resolution bitrate limits usage is restricted to singlecast.
     return;
-- 
2.37.3

