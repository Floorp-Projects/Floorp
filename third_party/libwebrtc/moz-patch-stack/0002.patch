From: Victor Boivie <boivie@webrtc.org>
Date: Wed, 13 Dec 2023 12:41:55 +0100
Subject: (cherry-pick-branch-heads/6167) dcsctp: Fix not using iteraters after
 NackItem

OutstandingData::NackItem nacks a chunk, and if that chunk reaches its
partial reliability critera, it will abandon the entire message. If that
message hasn't been sent in full, a placeholder "end" message is
inserted (see https://crbug.com/webrtc/12812). And when the message is
inserted, any iterators may be invalidated (if e.g. std::deque would
want to grow the deque).

So ensure that there are no iterators used after having called NackItem.
By changing the interface of NackItem, and not passing an Item, but just
the TSN, this is encouraged. NackAll was rewritten as a two-pass
algorithm to first collect TSNs, then iterating that list, looking up
the items in the second pass (constant complexity).

(cherry picked from commit 161d2c84528ec9eb0c19bfb51024bca54353abc4)

No-Try: True
Bug: chromium:1510364
Change-Id: I5156b6d6a683184f290e71c98f16bc68ea2a562f
Reviewed-on: https://webrtc-review.googlesource.com/c/src/+/331320
Reviewed-by: Harald Alvestrand <hta@webrtc.org>
Commit-Queue: Victor Boivie <boivie@webrtc.org>
Reviewed-by: Sam Zackrisson <saza@webrtc.org>
Cr-Original-Commit-Position: refs/heads/main@{#41374}
Reviewed-on: https://webrtc-review.googlesource.com/c/src/+/331960
Reviewed-by: Mirko Bonadei <mbonadei@webrtc.org>
Cr-Commit-Position: refs/branch-heads/6167@{#2}
Cr-Branched-From: ece5cb83715dea85617114b6d4e981fdee2623ba-refs/heads/main@{#41315}
---
 net/dcsctp/tx/outstanding_data.cc | 16 +++++++++++-----
 net/dcsctp/tx/outstanding_data.h  |  9 +++++----
 2 files changed, 16 insertions(+), 9 deletions(-)

diff --git a/net/dcsctp/tx/outstanding_data.cc b/net/dcsctp/tx/outstanding_data.cc
index 4972fc5f10..ca639abc54 100644
--- a/net/dcsctp/tx/outstanding_data.cc
+++ b/net/dcsctp/tx/outstanding_data.cc
@@ -240,9 +240,8 @@ void OutstandingData::NackBetweenAckBlocks(
     for (UnwrappedTSN tsn = prev_block_last_acked.next_value();
          tsn < cur_block_first_acked && tsn <= max_tsn_to_nack;
          tsn = tsn.next_value()) {
-      Item& item = GetItem(tsn);
       ack_info.has_packet_loss |=
-          NackItem(tsn, item, /*retransmit_now=*/false,
+          NackItem(tsn, /*retransmit_now=*/false,
                    /*do_fast_retransmit=*/!is_in_fast_recovery);
     }
     prev_block_last_acked = UnwrappedTSN::AddTo(cumulative_tsn_ack, block.end);
@@ -255,9 +254,9 @@ void OutstandingData::NackBetweenAckBlocks(
 }
 
 bool OutstandingData::NackItem(UnwrappedTSN tsn,
-                               Item& item,
                                bool retransmit_now,
                                bool do_fast_retransmit) {
+  Item& item = GetItem(tsn);
   if (item.is_outstanding()) {
     unacked_bytes_ -= GetSerializedChunkSize(item.data());
     --unacked_items_;
@@ -446,13 +445,20 @@ absl::optional<UnwrappedTSN> OutstandingData::Insert(
 
 void OutstandingData::NackAll() {
   UnwrappedTSN tsn = last_cumulative_tsn_ack_;
+  // A two-pass algorithm is needed, as NackItem will invalidate iterators.
+  std::vector<UnwrappedTSN> tsns_to_nack;
   for (Item& item : outstanding_data_) {
     tsn.Increment();
     if (!item.is_acked()) {
-      NackItem(tsn, item, /*retransmit_now=*/true,
-               /*do_fast_retransmit=*/false);
+      tsns_to_nack.push_back(tsn);
     }
   }
+
+  for (UnwrappedTSN tsn : tsns_to_nack) {
+    NackItem(tsn, /*retransmit_now=*/true,
+             /*do_fast_retransmit=*/false);
+  }
+
   RTC_DCHECK(IsConsistent());
 }
 
diff --git a/net/dcsctp/tx/outstanding_data.h b/net/dcsctp/tx/outstanding_data.h
index 82e78337b8..2a214975e6 100644
--- a/net/dcsctp/tx/outstanding_data.h
+++ b/net/dcsctp/tx/outstanding_data.h
@@ -330,10 +330,11 @@ class OutstandingData {
   // many times so that it should be retransmitted, this will schedule it to be
   // "fast retransmitted". This is only done just before going into fast
   // recovery.
-  bool NackItem(UnwrappedTSN tsn,
-                Item& item,
-                bool retransmit_now,
-                bool do_fast_retransmit);
+  //
+  // Note that since nacking an item may result in it becoming abandoned, which
+  // in turn could alter `outstanding_data_`, any iterators are invalidated
+  // after having called this method.
+  bool NackItem(UnwrappedTSN tsn, bool retransmit_now, bool do_fast_retransmit);
 
   // Given that a message fragment, `item` has been abandoned, abandon all other
   // fragments that share the same message - both never-before-sent fragments
