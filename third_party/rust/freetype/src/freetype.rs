/* automatically generated by rust-bindgen */

pub type FT_Int16 = i16;
pub type FT_UInt16 = u16;
pub type FT_Int32 = i32;
pub type FT_UInt32 = u32;
pub type FT_Int64= i64;
pub type FT_UInt64= u64;
pub use FT_Error;

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const FT_RENDER_POOL_SIZE: ::std::os::raw::c_uint = 16384;
pub const FT_MAX_MODULES: ::std::os::raw::c_uint = 32;
pub const FT_OUTLINE_NONE: ::std::os::raw::c_uint = 0;
pub const FT_OUTLINE_OWNER: ::std::os::raw::c_uint = 1;
pub const FT_OUTLINE_EVEN_ODD_FILL: ::std::os::raw::c_uint = 2;
pub const FT_OUTLINE_REVERSE_FILL: ::std::os::raw::c_uint = 4;
pub const FT_OUTLINE_IGNORE_DROPOUTS: ::std::os::raw::c_uint = 8;
pub const FT_OUTLINE_SMART_DROPOUTS: ::std::os::raw::c_uint = 16;
pub const FT_OUTLINE_INCLUDE_STUBS: ::std::os::raw::c_uint = 32;
pub const FT_OUTLINE_HIGH_PRECISION: ::std::os::raw::c_uint = 256;
pub const FT_OUTLINE_SINGLE_PASS: ::std::os::raw::c_uint = 512;
pub const FT_CURVE_TAG_ON: ::std::os::raw::c_uint = 1;
pub const FT_CURVE_TAG_CONIC: ::std::os::raw::c_uint = 0;
pub const FT_CURVE_TAG_CUBIC: ::std::os::raw::c_uint = 2;
pub const FT_CURVE_TAG_HAS_SCANMODE: ::std::os::raw::c_uint = 4;
pub const FT_CURVE_TAG_TOUCH_X: ::std::os::raw::c_uint = 8;
pub const FT_CURVE_TAG_TOUCH_Y: ::std::os::raw::c_uint = 16;
pub const FT_CURVE_TAG_TOUCH_BOTH: ::std::os::raw::c_uint = 24;
pub const FT_Curve_Tag_On: ::std::os::raw::c_uint = 1;
pub const FT_Curve_Tag_Conic: ::std::os::raw::c_uint = 0;
pub const FT_Curve_Tag_Cubic: ::std::os::raw::c_uint = 2;
pub const FT_Curve_Tag_Touch_X: ::std::os::raw::c_uint = 8;
pub const FT_Curve_Tag_Touch_Y: ::std::os::raw::c_uint = 16;
pub const FT_RASTER_FLAG_DEFAULT: ::std::os::raw::c_uint = 0;
pub const FT_RASTER_FLAG_AA: ::std::os::raw::c_uint = 1;
pub const FT_RASTER_FLAG_DIRECT: ::std::os::raw::c_uint = 2;
pub const FT_RASTER_FLAG_CLIP: ::std::os::raw::c_uint = 4;
pub const FT_ERR_BASE: ::std::os::raw::c_uint = 0;
pub const FT_FACE_FLAG_SCALABLE: ::std::os::raw::c_uint = 1;
pub const FT_FACE_FLAG_FIXED_SIZES: ::std::os::raw::c_uint = 2;
pub const FT_FACE_FLAG_FIXED_WIDTH: ::std::os::raw::c_uint = 4;
pub const FT_FACE_FLAG_SFNT: ::std::os::raw::c_uint = 8;
pub const FT_FACE_FLAG_HORIZONTAL: ::std::os::raw::c_uint = 16;
pub const FT_FACE_FLAG_VERTICAL: ::std::os::raw::c_uint = 32;
pub const FT_FACE_FLAG_KERNING: ::std::os::raw::c_uint = 64;
pub const FT_FACE_FLAG_FAST_GLYPHS: ::std::os::raw::c_uint = 128;
pub const FT_FACE_FLAG_MULTIPLE_MASTERS: ::std::os::raw::c_uint = 256;
pub const FT_FACE_FLAG_GLYPH_NAMES: ::std::os::raw::c_uint = 512;
pub const FT_FACE_FLAG_EXTERNAL_STREAM: ::std::os::raw::c_uint = 1024;
pub const FT_FACE_FLAG_HINTER: ::std::os::raw::c_uint = 2048;
pub const FT_FACE_FLAG_CID_KEYED: ::std::os::raw::c_uint = 4096;
pub const FT_FACE_FLAG_TRICKY: ::std::os::raw::c_uint = 8192;
pub const FT_FACE_FLAG_COLOR: ::std::os::raw::c_uint = 16384;
pub const FT_STYLE_FLAG_ITALIC: ::std::os::raw::c_uint = 1;
pub const FT_STYLE_FLAG_BOLD: ::std::os::raw::c_uint = 2;
pub const FT_OPEN_MEMORY: ::std::os::raw::c_uint = 1;
pub const FT_OPEN_STREAM: ::std::os::raw::c_uint = 2;
pub const FT_OPEN_PATHNAME: ::std::os::raw::c_uint = 4;
pub const FT_OPEN_DRIVER: ::std::os::raw::c_uint = 8;
pub const FT_OPEN_PARAMS: ::std::os::raw::c_uint = 16;
pub const FT_LOAD_DEFAULT: ::std::os::raw::c_uint = 0;
pub const FT_LOAD_NO_SCALE: ::std::os::raw::c_uint = 1;
pub const FT_LOAD_NO_HINTING: ::std::os::raw::c_uint = 2;
pub const FT_LOAD_RENDER: ::std::os::raw::c_uint = 4;
pub const FT_LOAD_NO_BITMAP: ::std::os::raw::c_uint = 8;
pub const FT_LOAD_VERTICAL_LAYOUT: ::std::os::raw::c_uint = 16;
pub const FT_LOAD_FORCE_AUTOHINT: ::std::os::raw::c_uint = 32;
pub const FT_LOAD_CROP_BITMAP: ::std::os::raw::c_uint = 64;
pub const FT_LOAD_PEDANTIC: ::std::os::raw::c_uint = 128;
pub const FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH: ::std::os::raw::c_uint = 512;
pub const FT_LOAD_NO_RECURSE: ::std::os::raw::c_uint = 1024;
pub const FT_LOAD_IGNORE_TRANSFORM: ::std::os::raw::c_uint = 2048;
pub const FT_LOAD_MONOCHROME: ::std::os::raw::c_uint = 4096;
pub const FT_LOAD_LINEAR_DESIGN: ::std::os::raw::c_uint = 8192;
pub const FT_LOAD_NO_AUTOHINT: ::std::os::raw::c_uint = 32768;
pub const FT_LOAD_COLOR: ::std::os::raw::c_uint = 1048576;
pub const FT_LOAD_COMPUTE_METRICS: ::std::os::raw::c_uint = 2097152;
pub const FT_LOAD_ADVANCE_ONLY: ::std::os::raw::c_uint = 256;
pub const FT_LOAD_SBITS_ONLY: ::std::os::raw::c_uint = 16384;
pub const FT_SUBGLYPH_FLAG_ARGS_ARE_WORDS: ::std::os::raw::c_uint = 1;
pub const FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES: ::std::os::raw::c_uint = 2;
pub const FT_SUBGLYPH_FLAG_ROUND_XY_TO_GRID: ::std::os::raw::c_uint = 4;
pub const FT_SUBGLYPH_FLAG_SCALE: ::std::os::raw::c_uint = 8;
pub const FT_SUBGLYPH_FLAG_XY_SCALE: ::std::os::raw::c_uint = 64;
pub const FT_SUBGLYPH_FLAG_2X2: ::std::os::raw::c_uint = 128;
pub const FT_SUBGLYPH_FLAG_USE_MY_METRICS: ::std::os::raw::c_uint = 512;
pub const FT_FSTYPE_INSTALLABLE_EMBEDDING: ::std::os::raw::c_uint = 0;
pub const FT_FSTYPE_RESTRICTED_LICENSE_EMBEDDING: ::std::os::raw::c_uint = 2;
pub const FT_FSTYPE_PREVIEW_AND_PRINT_EMBEDDING: ::std::os::raw::c_uint = 4;
pub const FT_FSTYPE_EDITABLE_EMBEDDING: ::std::os::raw::c_uint = 8;
pub const FT_FSTYPE_NO_SUBSETTING: ::std::os::raw::c_uint = 256;
pub const FT_FSTYPE_BITMAP_EMBEDDING_ONLY: ::std::os::raw::c_uint = 512;
pub const FT_MODULE_FONT_DRIVER: ::std::os::raw::c_uint = 1;
pub const FT_MODULE_RENDERER: ::std::os::raw::c_uint = 2;
pub const FT_MODULE_HINTER: ::std::os::raw::c_uint = 4;
pub const FT_MODULE_STYLER: ::std::os::raw::c_uint = 8;
pub const FT_MODULE_DRIVER_SCALABLE: ::std::os::raw::c_uint = 256;
pub const FT_MODULE_DRIVER_NO_OUTLINES: ::std::os::raw::c_uint = 512;
pub const FT_MODULE_DRIVER_HAS_HINTER: ::std::os::raw::c_uint = 1024;
pub const FT_MODULE_DRIVER_HINTS_LIGHTLY: ::std::os::raw::c_uint = 2048;
pub type FT_Fast = ::std::os::raw::c_int;
pub type FT_UFast = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_MemoryRec_ {
    pub user: *mut ::std::os::raw::c_void,
    pub alloc: FT_Alloc_Func,
    pub free: FT_Free_Func,
    pub realloc: FT_Realloc_Func,
}
#[test]
fn bindgen_test_layout_FT_MemoryRec_() {
    assert_eq!(::std::mem::size_of::<FT_MemoryRec_>() , 32usize , concat ! (
               "Size of: " , stringify ! ( FT_MemoryRec_ ) ));
    assert_eq! (::std::mem::align_of::<FT_MemoryRec_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_MemoryRec_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_MemoryRec_ ) ) . user as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_MemoryRec_ ) , "::"
                , stringify ! ( user ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_MemoryRec_ ) ) . alloc as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_MemoryRec_ ) , "::"
                , stringify ! ( alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_MemoryRec_ ) ) . free as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_MemoryRec_ ) , "::"
                , stringify ! ( free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_MemoryRec_ ) ) . realloc as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_MemoryRec_ ) , "::"
                , stringify ! ( realloc ) ));
}
impl Clone for FT_MemoryRec_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Memory = *mut FT_MemoryRec_;
pub type FT_Alloc_Func =
    ::std::option::Option<unsafe extern "C" fn(memory: FT_Memory,
                                               size: ::std::os::raw::c_long)
                              -> *mut ::std::os::raw::c_void>;
pub type FT_Free_Func =
    ::std::option::Option<unsafe extern "C" fn(memory: FT_Memory,
                                               block:
                                                   *mut ::std::os::raw::c_void)>;
pub type FT_Realloc_Func =
    ::std::option::Option<unsafe extern "C" fn(memory: FT_Memory,
                                               cur_size:
                                                   ::std::os::raw::c_long,
                                               new_size:
                                                   ::std::os::raw::c_long,
                                               block:
                                                   *mut ::std::os::raw::c_void)
                              -> *mut ::std::os::raw::c_void>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_StreamRec_ {
    pub base: *mut ::std::os::raw::c_uchar,
    pub size: ::std::os::raw::c_ulong,
    pub pos: ::std::os::raw::c_ulong,
    pub descriptor: FT_StreamDesc,
    pub pathname: FT_StreamDesc,
    pub read: FT_Stream_IoFunc,
    pub close: FT_Stream_CloseFunc,
    pub memory: FT_Memory,
    pub cursor: *mut ::std::os::raw::c_uchar,
    pub limit: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_FT_StreamRec_() {
    assert_eq!(::std::mem::size_of::<FT_StreamRec_>() , 80usize , concat ! (
               "Size of: " , stringify ! ( FT_StreamRec_ ) ));
    assert_eq! (::std::mem::align_of::<FT_StreamRec_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_StreamRec_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_StreamRec_ ) ) . base as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_StreamRec_ ) , "::"
                , stringify ! ( base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_StreamRec_ ) ) . size as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_StreamRec_ ) , "::"
                , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_StreamRec_ ) ) . pos as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_StreamRec_ ) , "::"
                , stringify ! ( pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_StreamRec_ ) ) . descriptor as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_StreamRec_ ) , "::"
                , stringify ! ( descriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_StreamRec_ ) ) . pathname as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_StreamRec_ ) , "::"
                , stringify ! ( pathname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_StreamRec_ ) ) . read as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_StreamRec_ ) , "::"
                , stringify ! ( read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_StreamRec_ ) ) . close as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_StreamRec_ ) , "::"
                , stringify ! ( close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_StreamRec_ ) ) . memory as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_StreamRec_ ) , "::"
                , stringify ! ( memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_StreamRec_ ) ) . cursor as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_StreamRec_ ) , "::"
                , stringify ! ( cursor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_StreamRec_ ) ) . limit as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_StreamRec_ ) , "::"
                , stringify ! ( limit ) ));
}
impl Clone for FT_StreamRec_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Stream = *mut FT_StreamRec_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_StreamDesc_ {
    pub value: __BindgenUnionField<::std::os::raw::c_long>,
    pub pointer: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_FT_StreamDesc_() {
    assert_eq!(::std::mem::size_of::<FT_StreamDesc_>() , 8usize , concat ! (
               "Size of: " , stringify ! ( FT_StreamDesc_ ) ));
    assert_eq! (::std::mem::align_of::<FT_StreamDesc_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_StreamDesc_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_StreamDesc_ ) ) . value as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_StreamDesc_ ) , "::"
                , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_StreamDesc_ ) ) . pointer as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_StreamDesc_ ) , "::"
                , stringify ! ( pointer ) ));
}
impl Clone for FT_StreamDesc_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_StreamDesc = FT_StreamDesc_;
pub type FT_Stream_IoFunc =
    ::std::option::Option<unsafe extern "C" fn(stream: FT_Stream,
                                               offset:
                                                   ::std::os::raw::c_ulong,
                                               buffer:
                                                   *mut ::std::os::raw::c_uchar,
                                               count: ::std::os::raw::c_ulong)
                              -> ::std::os::raw::c_ulong>;
pub type FT_Stream_CloseFunc =
    ::std::option::Option<unsafe extern "C" fn(stream: FT_Stream)>;
pub type FT_StreamRec = FT_StreamRec_;
pub type FT_Pos = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Vector_ {
    pub x: FT_Pos,
    pub y: FT_Pos,
}
#[test]
fn bindgen_test_layout_FT_Vector_() {
    assert_eq!(::std::mem::size_of::<FT_Vector_>() , 16usize , concat ! (
               "Size of: " , stringify ! ( FT_Vector_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Vector_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_Vector_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Vector_ ) ) . x as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Vector_ ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Vector_ ) ) . y as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Vector_ ) , "::" ,
                stringify ! ( y ) ));
}
impl Clone for FT_Vector_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Vector = FT_Vector_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_BBox_ {
    pub xMin: FT_Pos,
    pub yMin: FT_Pos,
    pub xMax: FT_Pos,
    pub yMax: FT_Pos,
}
#[test]
fn bindgen_test_layout_FT_BBox_() {
    assert_eq!(::std::mem::size_of::<FT_BBox_>() , 32usize , concat ! (
               "Size of: " , stringify ! ( FT_BBox_ ) ));
    assert_eq! (::std::mem::align_of::<FT_BBox_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_BBox_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_BBox_ ) ) . xMin as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_BBox_ ) , "::" ,
                stringify ! ( xMin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_BBox_ ) ) . yMin as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_BBox_ ) , "::" ,
                stringify ! ( yMin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_BBox_ ) ) . xMax as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_BBox_ ) , "::" ,
                stringify ! ( xMax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_BBox_ ) ) . yMax as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_BBox_ ) , "::" ,
                stringify ! ( yMax ) ));
}
impl Clone for FT_BBox_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_BBox = FT_BBox_;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FT_Pixel_Mode_ {
    FT_PIXEL_MODE_NONE = 0,
    FT_PIXEL_MODE_MONO = 1,
    FT_PIXEL_MODE_GRAY = 2,
    FT_PIXEL_MODE_GRAY2 = 3,
    FT_PIXEL_MODE_GRAY4 = 4,
    FT_PIXEL_MODE_LCD = 5,
    FT_PIXEL_MODE_LCD_V = 6,
    FT_PIXEL_MODE_BGRA = 7,
    FT_PIXEL_MODE_MAX = 8,
}
pub use self::FT_Pixel_Mode_ as FT_Pixel_Mode;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Bitmap_ {
    pub rows: ::std::os::raw::c_uint,
    pub width: ::std::os::raw::c_uint,
    pub pitch: ::std::os::raw::c_int,
    pub buffer: *mut ::std::os::raw::c_uchar,
    pub num_grays: ::std::os::raw::c_ushort,
    pub pixel_mode: ::std::os::raw::c_uchar,
    pub palette_mode: ::std::os::raw::c_uchar,
    pub palette: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FT_Bitmap_() {
    assert_eq!(::std::mem::size_of::<FT_Bitmap_>() , 40usize , concat ! (
               "Size of: " , stringify ! ( FT_Bitmap_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Bitmap_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_Bitmap_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_ ) ) . rows as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_ ) , "::" ,
                stringify ! ( rows ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_ ) ) . width as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_ ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_ ) ) . pitch as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_ ) , "::" ,
                stringify ! ( pitch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_ ) ) . buffer as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_ ) , "::" ,
                stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_ ) ) . num_grays as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_ ) , "::" ,
                stringify ! ( num_grays ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_ ) ) . pixel_mode as * const _
                as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_ ) , "::" ,
                stringify ! ( pixel_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_ ) ) . palette_mode as * const
                _ as usize } , 27usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_ ) , "::" ,
                stringify ! ( palette_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_ ) ) . palette as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_ ) , "::" ,
                stringify ! ( palette ) ));
}
impl Clone for FT_Bitmap_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Bitmap = FT_Bitmap_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Outline_ {
    pub n_contours: ::std::os::raw::c_short,
    pub n_points: ::std::os::raw::c_short,
    pub points: *mut FT_Vector,
    pub tags: *mut ::std::os::raw::c_char,
    pub contours: *mut ::std::os::raw::c_short,
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_FT_Outline_() {
    assert_eq!(::std::mem::size_of::<FT_Outline_>() , 40usize , concat ! (
               "Size of: " , stringify ! ( FT_Outline_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Outline_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_Outline_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Outline_ ) ) . n_contours as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Outline_ ) , "::" ,
                stringify ! ( n_contours ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Outline_ ) ) . n_points as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Outline_ ) , "::" ,
                stringify ! ( n_points ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Outline_ ) ) . points as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Outline_ ) , "::" ,
                stringify ! ( points ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Outline_ ) ) . tags as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Outline_ ) , "::" ,
                stringify ! ( tags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Outline_ ) ) . contours as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Outline_ ) , "::" ,
                stringify ! ( contours ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Outline_ ) ) . flags as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Outline_ ) , "::" ,
                stringify ! ( flags ) ));
}
impl Clone for FT_Outline_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Outline = FT_Outline_;
pub type FT_Outline_MoveToFunc =
    ::std::option::Option<unsafe extern "C" fn(to: *const FT_Vector,
                                               user:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type FT_Outline_LineToFunc =
    ::std::option::Option<unsafe extern "C" fn(to: *const FT_Vector,
                                               user:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type FT_Outline_ConicToFunc =
    ::std::option::Option<unsafe extern "C" fn(control: *const FT_Vector,
                                               to: *const FT_Vector,
                                               user:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type FT_Outline_CubicToFunc =
    ::std::option::Option<unsafe extern "C" fn(control1: *const FT_Vector,
                                               control2: *const FT_Vector,
                                               to: *const FT_Vector,
                                               user:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Outline_Funcs_ {
    pub move_to: FT_Outline_MoveToFunc,
    pub line_to: FT_Outline_LineToFunc,
    pub conic_to: FT_Outline_ConicToFunc,
    pub cubic_to: FT_Outline_CubicToFunc,
    pub shift: ::std::os::raw::c_int,
    pub delta: FT_Pos,
}
#[test]
fn bindgen_test_layout_FT_Outline_Funcs_() {
    assert_eq!(::std::mem::size_of::<FT_Outline_Funcs_>() , 48usize , concat !
               ( "Size of: " , stringify ! ( FT_Outline_Funcs_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Outline_Funcs_>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( FT_Outline_Funcs_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Outline_Funcs_ ) ) . move_to as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Outline_Funcs_ ) ,
                "::" , stringify ! ( move_to ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Outline_Funcs_ ) ) . line_to as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Outline_Funcs_ ) ,
                "::" , stringify ! ( line_to ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Outline_Funcs_ ) ) . conic_to as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Outline_Funcs_ ) ,
                "::" , stringify ! ( conic_to ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Outline_Funcs_ ) ) . cubic_to as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Outline_Funcs_ ) ,
                "::" , stringify ! ( cubic_to ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Outline_Funcs_ ) ) . shift as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Outline_Funcs_ ) ,
                "::" , stringify ! ( shift ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Outline_Funcs_ ) ) . delta as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Outline_Funcs_ ) ,
                "::" , stringify ! ( delta ) ));
}
impl Clone for FT_Outline_Funcs_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Outline_Funcs = FT_Outline_Funcs_;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FT_Glyph_Format_ {
    FT_GLYPH_FORMAT_NONE = 0,
    FT_GLYPH_FORMAT_COMPOSITE = 1668246896,
    FT_GLYPH_FORMAT_BITMAP = 1651078259,
    FT_GLYPH_FORMAT_OUTLINE = 1869968492,
    FT_GLYPH_FORMAT_PLOTTER = 1886154612,
}
pub use self::FT_Glyph_Format_ as FT_Glyph_Format;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_RasterRec_ {
    _unused: [u8; 0],
}
pub type FT_Raster = *mut FT_RasterRec_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Span_ {
    pub x: ::std::os::raw::c_short,
    pub len: ::std::os::raw::c_ushort,
    pub coverage: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_FT_Span_() {
    assert_eq!(::std::mem::size_of::<FT_Span_>() , 6usize , concat ! (
               "Size of: " , stringify ! ( FT_Span_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Span_>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( FT_Span_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Span_ ) ) . x as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Span_ ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Span_ ) ) . len as * const _ as usize
                } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Span_ ) , "::" ,
                stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Span_ ) ) . coverage as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Span_ ) , "::" ,
                stringify ! ( coverage ) ));
}
impl Clone for FT_Span_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Span = FT_Span_;
pub type FT_SpanFunc =
    ::std::option::Option<unsafe extern "C" fn(y: ::std::os::raw::c_int,
                                               count: ::std::os::raw::c_int,
                                               spans: *const FT_Span,
                                               user:
                                                   *mut ::std::os::raw::c_void)>;
pub type FT_Raster_BitTest_Func =
    ::std::option::Option<unsafe extern "C" fn(y: ::std::os::raw::c_int,
                                               x: ::std::os::raw::c_int,
                                               user:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type FT_Raster_BitSet_Func =
    ::std::option::Option<unsafe extern "C" fn(y: ::std::os::raw::c_int,
                                               x: ::std::os::raw::c_int,
                                               user:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Raster_Params_ {
    pub target: *const FT_Bitmap,
    pub source: *const ::std::os::raw::c_void,
    pub flags: ::std::os::raw::c_int,
    pub gray_spans: FT_SpanFunc,
    pub black_spans: FT_SpanFunc,
    pub bit_test: FT_Raster_BitTest_Func,
    pub bit_set: FT_Raster_BitSet_Func,
    pub user: *mut ::std::os::raw::c_void,
    pub clip_box: FT_BBox,
}
#[test]
fn bindgen_test_layout_FT_Raster_Params_() {
    assert_eq!(::std::mem::size_of::<FT_Raster_Params_>() , 96usize , concat !
               ( "Size of: " , stringify ! ( FT_Raster_Params_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Raster_Params_>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( FT_Raster_Params_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Params_ ) ) . target as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Params_ ) ,
                "::" , stringify ! ( target ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Params_ ) ) . source as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Params_ ) ,
                "::" , stringify ! ( source ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Params_ ) ) . flags as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Params_ ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Params_ ) ) . gray_spans as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Params_ ) ,
                "::" , stringify ! ( gray_spans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Params_ ) ) . black_spans as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Params_ ) ,
                "::" , stringify ! ( black_spans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Params_ ) ) . bit_test as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Params_ ) ,
                "::" , stringify ! ( bit_test ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Params_ ) ) . bit_set as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Params_ ) ,
                "::" , stringify ! ( bit_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Params_ ) ) . user as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Params_ ) ,
                "::" , stringify ! ( user ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Params_ ) ) . clip_box as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Params_ ) ,
                "::" , stringify ! ( clip_box ) ));
}
impl Clone for FT_Raster_Params_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Raster_Params = FT_Raster_Params_;
pub type FT_Raster_NewFunc =
    ::std::option::Option<unsafe extern "C" fn(memory:
                                                   *mut ::std::os::raw::c_void,
                                               raster: *mut FT_Raster)
                              -> ::std::os::raw::c_int>;
pub type FT_Raster_DoneFunc =
    ::std::option::Option<unsafe extern "C" fn(raster: FT_Raster)>;
pub type FT_Raster_ResetFunc =
    ::std::option::Option<unsafe extern "C" fn(raster: FT_Raster,
                                               pool_base:
                                                   *mut ::std::os::raw::c_uchar,
                                               pool_size:
                                                   ::std::os::raw::c_ulong)>;
pub type FT_Raster_SetModeFunc =
    ::std::option::Option<unsafe extern "C" fn(raster: FT_Raster,
                                               mode: ::std::os::raw::c_ulong,
                                               args:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type FT_Raster_RenderFunc =
    ::std::option::Option<unsafe extern "C" fn(raster: FT_Raster,
                                               params:
                                                   *const FT_Raster_Params)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Raster_Funcs_ {
    pub glyph_format: FT_Glyph_Format,
    pub raster_new: FT_Raster_NewFunc,
    pub raster_reset: FT_Raster_ResetFunc,
    pub raster_set_mode: FT_Raster_SetModeFunc,
    pub raster_render: FT_Raster_RenderFunc,
    pub raster_done: FT_Raster_DoneFunc,
}
#[test]
fn bindgen_test_layout_FT_Raster_Funcs_() {
    assert_eq!(::std::mem::size_of::<FT_Raster_Funcs_>() , 48usize , concat !
               ( "Size of: " , stringify ! ( FT_Raster_Funcs_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Raster_Funcs_>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( FT_Raster_Funcs_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Funcs_ ) ) . glyph_format as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Funcs_ ) ,
                "::" , stringify ! ( glyph_format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Funcs_ ) ) . raster_new as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Funcs_ ) ,
                "::" , stringify ! ( raster_new ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Funcs_ ) ) . raster_reset as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Funcs_ ) ,
                "::" , stringify ! ( raster_reset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Funcs_ ) ) . raster_set_mode as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Funcs_ ) ,
                "::" , stringify ! ( raster_set_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Funcs_ ) ) . raster_render as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Funcs_ ) ,
                "::" , stringify ! ( raster_render ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Funcs_ ) ) . raster_done as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Funcs_ ) ,
                "::" , stringify ! ( raster_done ) ));
}
impl Clone for FT_Raster_Funcs_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Raster_Funcs = FT_Raster_Funcs_;
pub type FT_Bool = ::std::os::raw::c_uchar;
pub type FT_FWord = ::std::os::raw::c_short;
pub type FT_UFWord = ::std::os::raw::c_ushort;
pub type FT_Char = ::std::os::raw::c_schar;
pub type FT_Byte = ::std::os::raw::c_uchar;
pub type FT_Bytes = *const FT_Byte;
pub type FT_Tag = FT_UInt32;
pub type FT_String = ::std::os::raw::c_char;
pub type FT_Short = ::std::os::raw::c_short;
pub type FT_UShort = ::std::os::raw::c_ushort;
pub type FT_Int = ::std::os::raw::c_int;
pub type FT_UInt = ::std::os::raw::c_uint;
pub type FT_Long = ::std::os::raw::c_long;
pub type FT_ULong = ::std::os::raw::c_ulong;
pub type FT_F2Dot14 = ::std::os::raw::c_short;
pub type FT_F26Dot6 = ::std::os::raw::c_long;
pub type FT_Fixed = ::std::os::raw::c_long;
pub type FT_Pointer = *mut ::std::os::raw::c_void;
pub type FT_Offset = usize;
pub type FT_PtrDist = isize;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_UnitVector_ {
    pub x: FT_F2Dot14,
    pub y: FT_F2Dot14,
}
#[test]
fn bindgen_test_layout_FT_UnitVector_() {
    assert_eq!(::std::mem::size_of::<FT_UnitVector_>() , 4usize , concat ! (
               "Size of: " , stringify ! ( FT_UnitVector_ ) ));
    assert_eq! (::std::mem::align_of::<FT_UnitVector_>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( FT_UnitVector_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_UnitVector_ ) ) . x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_UnitVector_ ) , "::"
                , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_UnitVector_ ) ) . y as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_UnitVector_ ) , "::"
                , stringify ! ( y ) ));
}
impl Clone for FT_UnitVector_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_UnitVector = FT_UnitVector_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Matrix_ {
    pub xx: FT_Fixed,
    pub xy: FT_Fixed,
    pub yx: FT_Fixed,
    pub yy: FT_Fixed,
}
#[test]
fn bindgen_test_layout_FT_Matrix_() {
    assert_eq!(::std::mem::size_of::<FT_Matrix_>() , 32usize , concat ! (
               "Size of: " , stringify ! ( FT_Matrix_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Matrix_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_Matrix_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Matrix_ ) ) . xx as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Matrix_ ) , "::" ,
                stringify ! ( xx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Matrix_ ) ) . xy as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Matrix_ ) , "::" ,
                stringify ! ( xy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Matrix_ ) ) . yx as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Matrix_ ) , "::" ,
                stringify ! ( yx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Matrix_ ) ) . yy as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Matrix_ ) , "::" ,
                stringify ! ( yy ) ));
}
impl Clone for FT_Matrix_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Matrix = FT_Matrix_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Data_ {
    pub pointer: *const FT_Byte,
    pub length: FT_Int,
}
#[test]
fn bindgen_test_layout_FT_Data_() {
    assert_eq!(::std::mem::size_of::<FT_Data_>() , 16usize , concat ! (
               "Size of: " , stringify ! ( FT_Data_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Data_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_Data_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Data_ ) ) . pointer as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Data_ ) , "::" ,
                stringify ! ( pointer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Data_ ) ) . length as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Data_ ) , "::" ,
                stringify ! ( length ) ));
}
impl Clone for FT_Data_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Data = FT_Data_;
pub type FT_Generic_Finalizer =
    ::std::option::Option<unsafe extern "C" fn(object:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Generic_ {
    pub data: *mut ::std::os::raw::c_void,
    pub finalizer: FT_Generic_Finalizer,
}
#[test]
fn bindgen_test_layout_FT_Generic_() {
    assert_eq!(::std::mem::size_of::<FT_Generic_>() , 16usize , concat ! (
               "Size of: " , stringify ! ( FT_Generic_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Generic_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_Generic_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Generic_ ) ) . data as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Generic_ ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Generic_ ) ) . finalizer as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Generic_ ) , "::" ,
                stringify ! ( finalizer ) ));
}
impl Clone for FT_Generic_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Generic = FT_Generic_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_ListNodeRec_ {
    pub prev: FT_ListNode,
    pub next: FT_ListNode,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FT_ListNodeRec_() {
    assert_eq!(::std::mem::size_of::<FT_ListNodeRec_>() , 24usize , concat ! (
               "Size of: " , stringify ! ( FT_ListNodeRec_ ) ));
    assert_eq! (::std::mem::align_of::<FT_ListNodeRec_>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( FT_ListNodeRec_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_ListNodeRec_ ) ) . prev as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_ListNodeRec_ ) ,
                "::" , stringify ! ( prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_ListNodeRec_ ) ) . next as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_ListNodeRec_ ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_ListNodeRec_ ) ) . data as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_ListNodeRec_ ) ,
                "::" , stringify ! ( data ) ));
}
impl Clone for FT_ListNodeRec_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_ListNode = *mut FT_ListNodeRec_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_ListRec_ {
    pub head: FT_ListNode,
    pub tail: FT_ListNode,
}
#[test]
fn bindgen_test_layout_FT_ListRec_() {
    assert_eq!(::std::mem::size_of::<FT_ListRec_>() , 16usize , concat ! (
               "Size of: " , stringify ! ( FT_ListRec_ ) ));
    assert_eq! (::std::mem::align_of::<FT_ListRec_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_ListRec_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_ListRec_ ) ) . head as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_ListRec_ ) , "::" ,
                stringify ! ( head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_ListRec_ ) ) . tail as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_ListRec_ ) , "::" ,
                stringify ! ( tail ) ));
}
impl Clone for FT_ListRec_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_List = *mut FT_ListRec_;
pub type FT_ListNodeRec = FT_ListNodeRec_;
pub type FT_ListRec = FT_ListRec_;
pub const FT_Mod_Err_Base: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_Autofit: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_BDF: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_Bzip2: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_Cache: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_CFF: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_CID: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_Gzip: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_LZW: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_OTvalid: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_PCF: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_PFR: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_PSaux: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_PShinter: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_PSnames: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_Raster: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_SFNT: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_Smooth: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_TrueType: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_Type1: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_Type42: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_Winfonts: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_GXvalid: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_Max: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Max;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 { FT_Mod_Err_Base = 0, FT_Mod_Err_Max = 1, }
pub const FT_Err_Ok: _bindgen_ty_2 = _bindgen_ty_2::FT_Err_Ok;
pub const FT_Err_Cannot_Open_Resource: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Cannot_Open_Resource;
pub const FT_Err_Unknown_File_Format: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Unknown_File_Format;
pub const FT_Err_Invalid_File_Format: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_File_Format;
pub const FT_Err_Invalid_Version: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Version;
pub const FT_Err_Lower_Module_Version: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Lower_Module_Version;
pub const FT_Err_Invalid_Argument: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Argument;
pub const FT_Err_Unimplemented_Feature: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Unimplemented_Feature;
pub const FT_Err_Invalid_Table: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Table;
pub const FT_Err_Invalid_Offset: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Offset;
pub const FT_Err_Array_Too_Large: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Array_Too_Large;
pub const FT_Err_Missing_Module: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Missing_Module;
pub const FT_Err_Missing_Property: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Missing_Property;
pub const FT_Err_Invalid_Glyph_Index: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Glyph_Index;
pub const FT_Err_Invalid_Character_Code: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Character_Code;
pub const FT_Err_Invalid_Glyph_Format: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Glyph_Format;
pub const FT_Err_Cannot_Render_Glyph: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Cannot_Render_Glyph;
pub const FT_Err_Invalid_Outline: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Outline;
pub const FT_Err_Invalid_Composite: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Composite;
pub const FT_Err_Too_Many_Hints: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Too_Many_Hints;
pub const FT_Err_Invalid_Pixel_Size: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Pixel_Size;
pub const FT_Err_Invalid_Handle: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Handle;
pub const FT_Err_Invalid_Library_Handle: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Library_Handle;
pub const FT_Err_Invalid_Driver_Handle: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Driver_Handle;
pub const FT_Err_Invalid_Face_Handle: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Face_Handle;
pub const FT_Err_Invalid_Size_Handle: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Size_Handle;
pub const FT_Err_Invalid_Slot_Handle: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Slot_Handle;
pub const FT_Err_Invalid_CharMap_Handle: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_CharMap_Handle;
pub const FT_Err_Invalid_Cache_Handle: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Cache_Handle;
pub const FT_Err_Invalid_Stream_Handle: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Stream_Handle;
pub const FT_Err_Too_Many_Drivers: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Too_Many_Drivers;
pub const FT_Err_Too_Many_Extensions: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Too_Many_Extensions;
pub const FT_Err_Out_Of_Memory: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Out_Of_Memory;
pub const FT_Err_Unlisted_Object: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Unlisted_Object;
pub const FT_Err_Cannot_Open_Stream: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Cannot_Open_Stream;
pub const FT_Err_Invalid_Stream_Seek: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Stream_Seek;
pub const FT_Err_Invalid_Stream_Skip: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Stream_Skip;
pub const FT_Err_Invalid_Stream_Read: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Stream_Read;
pub const FT_Err_Invalid_Stream_Operation: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Stream_Operation;
pub const FT_Err_Invalid_Frame_Operation: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Frame_Operation;
pub const FT_Err_Nested_Frame_Access: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Nested_Frame_Access;
pub const FT_Err_Invalid_Frame_Read: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Frame_Read;
pub const FT_Err_Raster_Uninitialized: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Raster_Uninitialized;
pub const FT_Err_Raster_Corrupted: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Raster_Corrupted;
pub const FT_Err_Raster_Overflow: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Raster_Overflow;
pub const FT_Err_Raster_Negative_Height: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Raster_Negative_Height;
pub const FT_Err_Too_Many_Caches: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Too_Many_Caches;
pub const FT_Err_Invalid_Opcode: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Opcode;
pub const FT_Err_Too_Few_Arguments: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Too_Few_Arguments;
pub const FT_Err_Stack_Overflow: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Stack_Overflow;
pub const FT_Err_Code_Overflow: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Code_Overflow;
pub const FT_Err_Bad_Argument: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Bad_Argument;
pub const FT_Err_Divide_By_Zero: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Divide_By_Zero;
pub const FT_Err_Invalid_Reference: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Reference;
pub const FT_Err_Debug_OpCode: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Debug_OpCode;
pub const FT_Err_ENDF_In_Exec_Stream: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_ENDF_In_Exec_Stream;
pub const FT_Err_Nested_DEFS: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Nested_DEFS;
pub const FT_Err_Invalid_CodeRange: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_CodeRange;
pub const FT_Err_Execution_Too_Long: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Execution_Too_Long;
pub const FT_Err_Too_Many_Function_Defs: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Too_Many_Function_Defs;
pub const FT_Err_Too_Many_Instruction_Defs: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Too_Many_Instruction_Defs;
pub const FT_Err_Table_Missing: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Table_Missing;
pub const FT_Err_Horiz_Header_Missing: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Horiz_Header_Missing;
pub const FT_Err_Locations_Missing: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Locations_Missing;
pub const FT_Err_Name_Table_Missing: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Name_Table_Missing;
pub const FT_Err_CMap_Table_Missing: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_CMap_Table_Missing;
pub const FT_Err_Hmtx_Table_Missing: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Hmtx_Table_Missing;
pub const FT_Err_Post_Table_Missing: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Post_Table_Missing;
pub const FT_Err_Invalid_Horiz_Metrics: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Horiz_Metrics;
pub const FT_Err_Invalid_CharMap_Format: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_CharMap_Format;
pub const FT_Err_Invalid_PPem: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_PPem;
pub const FT_Err_Invalid_Vert_Metrics: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Vert_Metrics;
pub const FT_Err_Could_Not_Find_Context: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Could_Not_Find_Context;
pub const FT_Err_Invalid_Post_Table_Format: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Post_Table_Format;
pub const FT_Err_Invalid_Post_Table: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Post_Table;
pub const FT_Err_Syntax_Error: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Syntax_Error;
pub const FT_Err_Stack_Underflow: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Stack_Underflow;
pub const FT_Err_Ignore: _bindgen_ty_2 = _bindgen_ty_2::FT_Err_Ignore;
pub const FT_Err_No_Unicode_Glyph_Name: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_No_Unicode_Glyph_Name;
pub const FT_Err_Glyph_Too_Big: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Glyph_Too_Big;
pub const FT_Err_Missing_Startfont_Field: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Missing_Startfont_Field;
pub const FT_Err_Missing_Font_Field: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Missing_Font_Field;
pub const FT_Err_Missing_Size_Field: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Missing_Size_Field;
pub const FT_Err_Missing_Fontboundingbox_Field: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Missing_Fontboundingbox_Field;
pub const FT_Err_Missing_Chars_Field: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Missing_Chars_Field;
pub const FT_Err_Missing_Startchar_Field: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Missing_Startchar_Field;
pub const FT_Err_Missing_Encoding_Field: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Missing_Encoding_Field;
pub const FT_Err_Missing_Bbx_Field: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Missing_Bbx_Field;
pub const FT_Err_Bbx_Too_Big: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Bbx_Too_Big;
pub const FT_Err_Corrupted_Font_Header: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Corrupted_Font_Header;
pub const FT_Err_Corrupted_Font_Glyphs: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Corrupted_Font_Glyphs;
pub const FT_Err_Max: _bindgen_ty_2 = _bindgen_ty_2::FT_Err_Max;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    FT_Err_Ok = 0,
    FT_Err_Cannot_Open_Resource = 1,
    FT_Err_Unknown_File_Format = 2,
    FT_Err_Invalid_File_Format = 3,
    FT_Err_Invalid_Version = 4,
    FT_Err_Lower_Module_Version = 5,
    FT_Err_Invalid_Argument = 6,
    FT_Err_Unimplemented_Feature = 7,
    FT_Err_Invalid_Table = 8,
    FT_Err_Invalid_Offset = 9,
    FT_Err_Array_Too_Large = 10,
    FT_Err_Missing_Module = 11,
    FT_Err_Missing_Property = 12,
    FT_Err_Invalid_Glyph_Index = 16,
    FT_Err_Invalid_Character_Code = 17,
    FT_Err_Invalid_Glyph_Format = 18,
    FT_Err_Cannot_Render_Glyph = 19,
    FT_Err_Invalid_Outline = 20,
    FT_Err_Invalid_Composite = 21,
    FT_Err_Too_Many_Hints = 22,
    FT_Err_Invalid_Pixel_Size = 23,
    FT_Err_Invalid_Handle = 32,
    FT_Err_Invalid_Library_Handle = 33,
    FT_Err_Invalid_Driver_Handle = 34,
    FT_Err_Invalid_Face_Handle = 35,
    FT_Err_Invalid_Size_Handle = 36,
    FT_Err_Invalid_Slot_Handle = 37,
    FT_Err_Invalid_CharMap_Handle = 38,
    FT_Err_Invalid_Cache_Handle = 39,
    FT_Err_Invalid_Stream_Handle = 40,
    FT_Err_Too_Many_Drivers = 48,
    FT_Err_Too_Many_Extensions = 49,
    FT_Err_Out_Of_Memory = 64,
    FT_Err_Unlisted_Object = 65,
    FT_Err_Cannot_Open_Stream = 81,
    FT_Err_Invalid_Stream_Seek = 82,
    FT_Err_Invalid_Stream_Skip = 83,
    FT_Err_Invalid_Stream_Read = 84,
    FT_Err_Invalid_Stream_Operation = 85,
    FT_Err_Invalid_Frame_Operation = 86,
    FT_Err_Nested_Frame_Access = 87,
    FT_Err_Invalid_Frame_Read = 88,
    FT_Err_Raster_Uninitialized = 96,
    FT_Err_Raster_Corrupted = 97,
    FT_Err_Raster_Overflow = 98,
    FT_Err_Raster_Negative_Height = 99,
    FT_Err_Too_Many_Caches = 112,
    FT_Err_Invalid_Opcode = 128,
    FT_Err_Too_Few_Arguments = 129,
    FT_Err_Stack_Overflow = 130,
    FT_Err_Code_Overflow = 131,
    FT_Err_Bad_Argument = 132,
    FT_Err_Divide_By_Zero = 133,
    FT_Err_Invalid_Reference = 134,
    FT_Err_Debug_OpCode = 135,
    FT_Err_ENDF_In_Exec_Stream = 136,
    FT_Err_Nested_DEFS = 137,
    FT_Err_Invalid_CodeRange = 138,
    FT_Err_Execution_Too_Long = 139,
    FT_Err_Too_Many_Function_Defs = 140,
    FT_Err_Too_Many_Instruction_Defs = 141,
    FT_Err_Table_Missing = 142,
    FT_Err_Horiz_Header_Missing = 143,
    FT_Err_Locations_Missing = 144,
    FT_Err_Name_Table_Missing = 145,
    FT_Err_CMap_Table_Missing = 146,
    FT_Err_Hmtx_Table_Missing = 147,
    FT_Err_Post_Table_Missing = 148,
    FT_Err_Invalid_Horiz_Metrics = 149,
    FT_Err_Invalid_CharMap_Format = 150,
    FT_Err_Invalid_PPem = 151,
    FT_Err_Invalid_Vert_Metrics = 152,
    FT_Err_Could_Not_Find_Context = 153,
    FT_Err_Invalid_Post_Table_Format = 154,
    FT_Err_Invalid_Post_Table = 155,
    FT_Err_Syntax_Error = 160,
    FT_Err_Stack_Underflow = 161,
    FT_Err_Ignore = 162,
    FT_Err_No_Unicode_Glyph_Name = 163,
    FT_Err_Glyph_Too_Big = 164,
    FT_Err_Missing_Startfont_Field = 176,
    FT_Err_Missing_Font_Field = 177,
    FT_Err_Missing_Size_Field = 178,
    FT_Err_Missing_Fontboundingbox_Field = 179,
    FT_Err_Missing_Chars_Field = 180,
    FT_Err_Missing_Startchar_Field = 181,
    FT_Err_Missing_Encoding_Field = 182,
    FT_Err_Missing_Bbx_Field = 183,
    FT_Err_Bbx_Too_Big = 184,
    FT_Err_Corrupted_Font_Header = 185,
    FT_Err_Corrupted_Font_Glyphs = 186,
    FT_Err_Max = 187,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Glyph_Metrics_ {
    pub width: FT_Pos,
    pub height: FT_Pos,
    pub horiBearingX: FT_Pos,
    pub horiBearingY: FT_Pos,
    pub horiAdvance: FT_Pos,
    pub vertBearingX: FT_Pos,
    pub vertBearingY: FT_Pos,
    pub vertAdvance: FT_Pos,
}
#[test]
fn bindgen_test_layout_FT_Glyph_Metrics_() {
    assert_eq!(::std::mem::size_of::<FT_Glyph_Metrics_>() , 64usize , concat !
               ( "Size of: " , stringify ! ( FT_Glyph_Metrics_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Glyph_Metrics_>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( FT_Glyph_Metrics_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Glyph_Metrics_ ) ) . width as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Glyph_Metrics_ ) ,
                "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Glyph_Metrics_ ) ) . height as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Glyph_Metrics_ ) ,
                "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Glyph_Metrics_ ) ) . horiBearingX as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Glyph_Metrics_ ) ,
                "::" , stringify ! ( horiBearingX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Glyph_Metrics_ ) ) . horiBearingY as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Glyph_Metrics_ ) ,
                "::" , stringify ! ( horiBearingY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Glyph_Metrics_ ) ) . horiAdvance as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Glyph_Metrics_ ) ,
                "::" , stringify ! ( horiAdvance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Glyph_Metrics_ ) ) . vertBearingX as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Glyph_Metrics_ ) ,
                "::" , stringify ! ( vertBearingX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Glyph_Metrics_ ) ) . vertBearingY as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Glyph_Metrics_ ) ,
                "::" , stringify ! ( vertBearingY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Glyph_Metrics_ ) ) . vertAdvance as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Glyph_Metrics_ ) ,
                "::" , stringify ! ( vertAdvance ) ));
}
impl Clone for FT_Glyph_Metrics_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Glyph_Metrics = FT_Glyph_Metrics_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Bitmap_Size_ {
    pub height: FT_Short,
    pub width: FT_Short,
    pub size: FT_Pos,
    pub x_ppem: FT_Pos,
    pub y_ppem: FT_Pos,
}
#[test]
fn bindgen_test_layout_FT_Bitmap_Size_() {
    assert_eq!(::std::mem::size_of::<FT_Bitmap_Size_>() , 32usize , concat ! (
               "Size of: " , stringify ! ( FT_Bitmap_Size_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Bitmap_Size_>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( FT_Bitmap_Size_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_Size_ ) ) . height as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_Size_ ) ,
                "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_Size_ ) ) . width as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_Size_ ) ,
                "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_Size_ ) ) . size as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_Size_ ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_Size_ ) ) . x_ppem as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_Size_ ) ,
                "::" , stringify ! ( x_ppem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_Size_ ) ) . y_ppem as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_Size_ ) ,
                "::" , stringify ! ( y_ppem ) ));
}
impl Clone for FT_Bitmap_Size_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Bitmap_Size = FT_Bitmap_Size_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_LibraryRec_ {
    _unused: [u8; 0],
}
pub type FT_Library = *mut FT_LibraryRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_ModuleRec_ {
    _unused: [u8; 0],
}
pub type FT_Module = *mut FT_ModuleRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_DriverRec_ {
    _unused: [u8; 0],
}
pub type FT_Driver = *mut FT_DriverRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_RendererRec_ {
    _unused: [u8; 0],
}
pub type FT_Renderer = *mut FT_RendererRec_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_FaceRec_ {
    pub num_faces: FT_Long,
    pub face_index: FT_Long,
    pub face_flags: FT_Long,
    pub style_flags: FT_Long,
    pub num_glyphs: FT_Long,
    pub family_name: *mut FT_String,
    pub style_name: *mut FT_String,
    pub num_fixed_sizes: FT_Int,
    pub available_sizes: *mut FT_Bitmap_Size,
    pub num_charmaps: FT_Int,
    pub charmaps: *mut FT_CharMap,
    pub generic: FT_Generic,
    pub bbox: FT_BBox,
    pub units_per_EM: FT_UShort,
    pub ascender: FT_Short,
    pub descender: FT_Short,
    pub height: FT_Short,
    pub max_advance_width: FT_Short,
    pub max_advance_height: FT_Short,
    pub underline_position: FT_Short,
    pub underline_thickness: FT_Short,
    pub glyph: FT_GlyphSlot,
    pub size: FT_Size,
    pub charmap: FT_CharMap,
    pub driver: FT_Driver,
    pub memory: FT_Memory,
    pub stream: FT_Stream,
    pub sizes_list: FT_ListRec,
    pub autohint: FT_Generic,
    pub extensions: *mut ::std::os::raw::c_void,
    pub internal: FT_Face_Internal,
}
#[test]
fn bindgen_test_layout_FT_FaceRec_() {
    assert_eq!(::std::mem::size_of::<FT_FaceRec_>() , 248usize , concat ! (
               "Size of: " , stringify ! ( FT_FaceRec_ ) ));
    assert_eq! (::std::mem::align_of::<FT_FaceRec_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_FaceRec_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . num_faces as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( num_faces ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . face_index as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( face_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . face_flags as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( face_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . style_flags as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( style_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . num_glyphs as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( num_glyphs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . family_name as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( family_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . style_name as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( style_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . num_fixed_sizes as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( num_fixed_sizes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . available_sizes as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( available_sizes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . num_charmaps as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( num_charmaps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . charmaps as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( charmaps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . generic as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( generic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . bbox as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( bbox ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . units_per_EM as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( units_per_EM ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . ascender as * const _
                as usize } , 138usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( ascender ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . descender as * const _
                as usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( descender ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . height as * const _ as
                usize } , 142usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . max_advance_width as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( max_advance_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . max_advance_height as *
                const _ as usize } , 146usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( max_advance_height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . underline_position as *
                const _ as usize } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( underline_position ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . underline_thickness as
                * const _ as usize } , 150usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( underline_thickness ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . glyph as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( glyph ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . size as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . charmap as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( charmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . driver as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( driver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . memory as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . stream as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( stream ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . sizes_list as * const _
                as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( sizes_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . autohint as * const _
                as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( autohint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . extensions as * const _
                as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( extensions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . internal as * const _
                as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( internal ) ));
}
impl Clone for FT_FaceRec_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Face = *mut FT_FaceRec_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_SizeRec_ {
    pub face: FT_Face,
    pub generic: FT_Generic,
    pub metrics: FT_Size_Metrics,
    pub internal: FT_Size_Internal,
}
#[test]
fn bindgen_test_layout_FT_SizeRec_() {
    assert_eq!(::std::mem::size_of::<FT_SizeRec_>() , 88usize , concat ! (
               "Size of: " , stringify ! ( FT_SizeRec_ ) ));
    assert_eq! (::std::mem::align_of::<FT_SizeRec_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_SizeRec_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_SizeRec_ ) ) . face as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_SizeRec_ ) , "::" ,
                stringify ! ( face ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_SizeRec_ ) ) . generic as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_SizeRec_ ) , "::" ,
                stringify ! ( generic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_SizeRec_ ) ) . metrics as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_SizeRec_ ) , "::" ,
                stringify ! ( metrics ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_SizeRec_ ) ) . internal as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_SizeRec_ ) , "::" ,
                stringify ! ( internal ) ));
}
impl Clone for FT_SizeRec_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Size = *mut FT_SizeRec_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_GlyphSlotRec_ {
    pub library: FT_Library,
    pub face: FT_Face,
    pub next: FT_GlyphSlot,
    pub reserved: FT_UInt,
    pub generic: FT_Generic,
    pub metrics: FT_Glyph_Metrics,
    pub linearHoriAdvance: FT_Fixed,
    pub linearVertAdvance: FT_Fixed,
    pub advance: FT_Vector,
    pub format: FT_Glyph_Format,
    pub bitmap: FT_Bitmap,
    pub bitmap_left: FT_Int,
    pub bitmap_top: FT_Int,
    pub outline: FT_Outline,
    pub num_subglyphs: FT_UInt,
    pub subglyphs: FT_SubGlyph,
    pub control_data: *mut ::std::os::raw::c_void,
    pub control_len: ::std::os::raw::c_long,
    pub lsb_delta: FT_Pos,
    pub rsb_delta: FT_Pos,
    pub other: *mut ::std::os::raw::c_void,
    pub internal: FT_Slot_Internal,
}
#[test]
fn bindgen_test_layout_FT_GlyphSlotRec_() {
    assert_eq!(::std::mem::size_of::<FT_GlyphSlotRec_>() , 304usize , concat !
               ( "Size of: " , stringify ! ( FT_GlyphSlotRec_ ) ));
    assert_eq! (::std::mem::align_of::<FT_GlyphSlotRec_>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( FT_GlyphSlotRec_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . library as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( library ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . face as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( face ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . next as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . reserved as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . generic as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( generic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . metrics as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( metrics ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . linearHoriAdvance
                as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( linearHoriAdvance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . linearVertAdvance
                as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( linearVertAdvance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . advance as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( advance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . format as * const
                _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . bitmap as * const
                _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( bitmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . bitmap_left as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( bitmap_left ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . bitmap_top as *
                const _ as usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( bitmap_top ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . outline as * const
                _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( outline ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . num_subglyphs as *
                const _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( num_subglyphs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . subglyphs as *
                const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( subglyphs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . control_data as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( control_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . control_len as *
                const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( control_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . lsb_delta as *
                const _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( lsb_delta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . rsb_delta as *
                const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( rsb_delta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . other as * const _
                as usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( other ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . internal as *
                const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( internal ) ));
}
impl Clone for FT_GlyphSlotRec_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_GlyphSlot = *mut FT_GlyphSlotRec_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_CharMapRec_ {
    pub face: FT_Face,
    pub encoding: FT_Encoding,
    pub platform_id: FT_UShort,
    pub encoding_id: FT_UShort,
}
#[test]
fn bindgen_test_layout_FT_CharMapRec_() {
    assert_eq!(::std::mem::size_of::<FT_CharMapRec_>() , 16usize , concat ! (
               "Size of: " , stringify ! ( FT_CharMapRec_ ) ));
    assert_eq! (::std::mem::align_of::<FT_CharMapRec_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_CharMapRec_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_CharMapRec_ ) ) . face as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_CharMapRec_ ) , "::"
                , stringify ! ( face ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_CharMapRec_ ) ) . encoding as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_CharMapRec_ ) , "::"
                , stringify ! ( encoding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_CharMapRec_ ) ) . platform_id as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_CharMapRec_ ) , "::"
                , stringify ! ( platform_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_CharMapRec_ ) ) . encoding_id as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_CharMapRec_ ) , "::"
                , stringify ! ( encoding_id ) ));
}
impl Clone for FT_CharMapRec_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_CharMap = *mut FT_CharMapRec_;
pub const FT_Encoding__FT_ENCODING_MS_SJIS: FT_Encoding_ =
    FT_Encoding_::FT_ENCODING_SJIS;
pub const FT_Encoding__FT_ENCODING_MS_GB2312: FT_Encoding_ =
    FT_Encoding_::FT_ENCODING_GB2312;
pub const FT_Encoding__FT_ENCODING_MS_BIG5: FT_Encoding_ =
    FT_Encoding_::FT_ENCODING_BIG5;
pub const FT_Encoding__FT_ENCODING_MS_WANSUNG: FT_Encoding_ =
    FT_Encoding_::FT_ENCODING_WANSUNG;
pub const FT_Encoding__FT_ENCODING_MS_JOHAB: FT_Encoding_ =
    FT_Encoding_::FT_ENCODING_JOHAB;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FT_Encoding_ {
    FT_ENCODING_NONE = 0,
    FT_ENCODING_MS_SYMBOL = 1937337698,
    FT_ENCODING_UNICODE = 1970170211,
    FT_ENCODING_SJIS = 1936353651,
    FT_ENCODING_GB2312 = 1734484000,
    FT_ENCODING_BIG5 = 1651074869,
    FT_ENCODING_WANSUNG = 2002873971,
    FT_ENCODING_JOHAB = 1785686113,
    FT_ENCODING_ADOBE_STANDARD = 1094995778,
    FT_ENCODING_ADOBE_EXPERT = 1094992453,
    FT_ENCODING_ADOBE_CUSTOM = 1094992451,
    FT_ENCODING_ADOBE_LATIN_1 = 1818326065,
    FT_ENCODING_OLD_LATIN_2 = 1818326066,
    FT_ENCODING_APPLE_ROMAN = 1634889070,
}
pub use self::FT_Encoding_ as FT_Encoding;
pub type FT_CharMapRec = FT_CharMapRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Face_InternalRec_ {
    _unused: [u8; 0],
}
pub type FT_Face_Internal = *mut FT_Face_InternalRec_;
pub type FT_FaceRec = FT_FaceRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Size_InternalRec_ {
    _unused: [u8; 0],
}
pub type FT_Size_Internal = *mut FT_Size_InternalRec_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Size_Metrics_ {
    pub x_ppem: FT_UShort,
    pub y_ppem: FT_UShort,
    pub x_scale: FT_Fixed,
    pub y_scale: FT_Fixed,
    pub ascender: FT_Pos,
    pub descender: FT_Pos,
    pub height: FT_Pos,
    pub max_advance: FT_Pos,
}
#[test]
fn bindgen_test_layout_FT_Size_Metrics_() {
    assert_eq!(::std::mem::size_of::<FT_Size_Metrics_>() , 56usize , concat !
               ( "Size of: " , stringify ! ( FT_Size_Metrics_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Size_Metrics_>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( FT_Size_Metrics_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_Metrics_ ) ) . x_ppem as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_Metrics_ ) ,
                "::" , stringify ! ( x_ppem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_Metrics_ ) ) . y_ppem as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_Metrics_ ) ,
                "::" , stringify ! ( y_ppem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_Metrics_ ) ) . x_scale as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_Metrics_ ) ,
                "::" , stringify ! ( x_scale ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_Metrics_ ) ) . y_scale as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_Metrics_ ) ,
                "::" , stringify ! ( y_scale ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_Metrics_ ) ) . ascender as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_Metrics_ ) ,
                "::" , stringify ! ( ascender ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_Metrics_ ) ) . descender as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_Metrics_ ) ,
                "::" , stringify ! ( descender ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_Metrics_ ) ) . height as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_Metrics_ ) ,
                "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_Metrics_ ) ) . max_advance as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_Metrics_ ) ,
                "::" , stringify ! ( max_advance ) ));
}
impl Clone for FT_Size_Metrics_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Size_Metrics = FT_Size_Metrics_;
pub type FT_SizeRec = FT_SizeRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_SubGlyphRec_ {
    _unused: [u8; 0],
}
pub type FT_SubGlyph = *mut FT_SubGlyphRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Slot_InternalRec_ {
    _unused: [u8; 0],
}
pub type FT_Slot_Internal = *mut FT_Slot_InternalRec_;
pub type FT_GlyphSlotRec = FT_GlyphSlotRec_;
extern "C" {
    pub fn FT_Init_FreeType(alibrary: *mut FT_Library) -> FT_Error;
}
extern "C" {
    pub fn FT_Done_FreeType(library: FT_Library) -> FT_Error;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Parameter_ {
    pub tag: FT_ULong,
    pub data: FT_Pointer,
}
#[test]
fn bindgen_test_layout_FT_Parameter_() {
    assert_eq!(::std::mem::size_of::<FT_Parameter_>() , 16usize , concat ! (
               "Size of: " , stringify ! ( FT_Parameter_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Parameter_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_Parameter_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Parameter_ ) ) . tag as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Parameter_ ) , "::"
                , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Parameter_ ) ) . data as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Parameter_ ) , "::"
                , stringify ! ( data ) ));
}
impl Clone for FT_Parameter_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Parameter = FT_Parameter_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Open_Args_ {
    pub flags: FT_UInt,
    pub memory_base: *const FT_Byte,
    pub memory_size: FT_Long,
    pub pathname: *mut FT_String,
    pub stream: FT_Stream,
    pub driver: FT_Module,
    pub num_params: FT_Int,
    pub params: *mut FT_Parameter,
}
#[test]
fn bindgen_test_layout_FT_Open_Args_() {
    assert_eq!(::std::mem::size_of::<FT_Open_Args_>() , 64usize , concat ! (
               "Size of: " , stringify ! ( FT_Open_Args_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Open_Args_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_Open_Args_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Open_Args_ ) ) . flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Open_Args_ ) , "::"
                , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Open_Args_ ) ) . memory_base as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Open_Args_ ) , "::"
                , stringify ! ( memory_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Open_Args_ ) ) . memory_size as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Open_Args_ ) , "::"
                , stringify ! ( memory_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Open_Args_ ) ) . pathname as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Open_Args_ ) , "::"
                , stringify ! ( pathname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Open_Args_ ) ) . stream as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Open_Args_ ) , "::"
                , stringify ! ( stream ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Open_Args_ ) ) . driver as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Open_Args_ ) , "::"
                , stringify ! ( driver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Open_Args_ ) ) . num_params as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Open_Args_ ) , "::"
                , stringify ! ( num_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Open_Args_ ) ) . params as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Open_Args_ ) , "::"
                , stringify ! ( params ) ));
}
impl Clone for FT_Open_Args_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Open_Args = FT_Open_Args_;
extern "C" {
    pub fn FT_New_Face(library: FT_Library,
                       filepathname: *const ::std::os::raw::c_char,
                       face_index: FT_Long, aface: *mut FT_Face) -> FT_Error;
}
extern "C" {
    pub fn FT_New_Memory_Face(library: FT_Library, file_base: *const FT_Byte,
                              file_size: FT_Long, face_index: FT_Long,
                              aface: *mut FT_Face) -> FT_Error;
}
extern "C" {
    pub fn FT_Open_Face(library: FT_Library, args: *const FT_Open_Args,
                        face_index: FT_Long, aface: *mut FT_Face) -> FT_Error;
}
extern "C" {
    pub fn FT_Attach_File(face: FT_Face,
                          filepathname: *const ::std::os::raw::c_char)
     -> FT_Error;
}
extern "C" {
    pub fn FT_Attach_Stream(face: FT_Face, parameters: *mut FT_Open_Args)
     -> FT_Error;
}
extern "C" {
    pub fn FT_Reference_Face(face: FT_Face) -> FT_Error;
}
extern "C" {
    pub fn FT_Done_Face(face: FT_Face) -> FT_Error;
}
extern "C" {
    pub fn FT_Select_Size(face: FT_Face, strike_index: FT_Int) -> FT_Error;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FT_Size_Request_Type_ {
    FT_SIZE_REQUEST_TYPE_NOMINAL = 0,
    FT_SIZE_REQUEST_TYPE_REAL_DIM = 1,
    FT_SIZE_REQUEST_TYPE_BBOX = 2,
    FT_SIZE_REQUEST_TYPE_CELL = 3,
    FT_SIZE_REQUEST_TYPE_SCALES = 4,
    FT_SIZE_REQUEST_TYPE_MAX = 5,
}
pub use self::FT_Size_Request_Type_ as FT_Size_Request_Type;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Size_RequestRec_ {
    pub type_: FT_Size_Request_Type,
    pub width: FT_Long,
    pub height: FT_Long,
    pub horiResolution: FT_UInt,
    pub vertResolution: FT_UInt,
}
#[test]
fn bindgen_test_layout_FT_Size_RequestRec_() {
    assert_eq!(::std::mem::size_of::<FT_Size_RequestRec_>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( FT_Size_RequestRec_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Size_RequestRec_>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( FT_Size_RequestRec_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_RequestRec_ ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_RequestRec_ ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_RequestRec_ ) ) . width as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_RequestRec_ ) ,
                "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_RequestRec_ ) ) . height as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_RequestRec_ ) ,
                "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_RequestRec_ ) ) . horiResolution
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_RequestRec_ ) ,
                "::" , stringify ! ( horiResolution ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_RequestRec_ ) ) . vertResolution
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_RequestRec_ ) ,
                "::" , stringify ! ( vertResolution ) ));
}
impl Clone for FT_Size_RequestRec_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Size_RequestRec = FT_Size_RequestRec_;
pub type FT_Size_Request = *mut FT_Size_RequestRec_;
extern "C" {
    pub fn FT_Request_Size(face: FT_Face, req: FT_Size_Request) -> FT_Error;
}
extern "C" {
    pub fn FT_Set_Char_Size(face: FT_Face, char_width: FT_F26Dot6,
                            char_height: FT_F26Dot6, horz_resolution: FT_UInt,
                            vert_resolution: FT_UInt) -> FT_Error;
}
extern "C" {
    pub fn FT_Set_Pixel_Sizes(face: FT_Face, pixel_width: FT_UInt,
                              pixel_height: FT_UInt) -> FT_Error;
}
extern "C" {
    pub fn FT_Load_Glyph(face: FT_Face, glyph_index: FT_UInt,
                         load_flags: FT_Int32) -> FT_Error;
}
extern "C" {
    pub fn FT_Load_Char(face: FT_Face, char_code: FT_ULong,
                        load_flags: FT_Int32) -> FT_Error;
}
extern "C" {
    pub fn FT_Set_Transform(face: FT_Face, matrix: *mut FT_Matrix,
                            delta: *mut FT_Vector);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FT_Render_Mode_ {
    FT_RENDER_MODE_NORMAL = 0,
    FT_RENDER_MODE_LIGHT = 1,
    FT_RENDER_MODE_MONO = 2,
    FT_RENDER_MODE_LCD = 3,
    FT_RENDER_MODE_LCD_V = 4,
    FT_RENDER_MODE_MAX = 5,
}
pub use self::FT_Render_Mode_ as FT_Render_Mode;
extern "C" {
    pub fn FT_Render_Glyph(slot: FT_GlyphSlot, render_mode: FT_Render_Mode)
     -> FT_Error;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FT_Kerning_Mode_ {
    FT_KERNING_DEFAULT = 0,
    FT_KERNING_UNFITTED = 1,
    FT_KERNING_UNSCALED = 2,
}
pub use self::FT_Kerning_Mode_ as FT_Kerning_Mode;
extern "C" {
    pub fn FT_Get_Kerning(face: FT_Face, left_glyph: FT_UInt,
                          right_glyph: FT_UInt, kern_mode: FT_UInt,
                          akerning: *mut FT_Vector) -> FT_Error;
}
extern "C" {
    pub fn FT_Get_Track_Kerning(face: FT_Face, point_size: FT_Fixed,
                                degree: FT_Int, akerning: *mut FT_Fixed)
     -> FT_Error;
}
extern "C" {
    pub fn FT_Get_Glyph_Name(face: FT_Face, glyph_index: FT_UInt,
                             buffer: FT_Pointer, buffer_max: FT_UInt)
     -> FT_Error;
}
extern "C" {
    pub fn FT_Get_Postscript_Name(face: FT_Face)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn FT_Select_Charmap(face: FT_Face, encoding: FT_Encoding)
     -> FT_Error;
}
extern "C" {
    pub fn FT_Set_Charmap(face: FT_Face, charmap: FT_CharMap) -> FT_Error;
}
extern "C" {
    pub fn FT_Get_Charmap_Index(charmap: FT_CharMap) -> FT_Int;
}
extern "C" {
    pub fn FT_Get_Char_Index(face: FT_Face, charcode: FT_ULong) -> FT_UInt;
}
extern "C" {
    pub fn FT_Get_First_Char(face: FT_Face, agindex: *mut FT_UInt)
     -> FT_ULong;
}
extern "C" {
    pub fn FT_Get_Next_Char(face: FT_Face, char_code: FT_ULong,
                            agindex: *mut FT_UInt) -> FT_ULong;
}
extern "C" {
    pub fn FT_Get_Name_Index(face: FT_Face, glyph_name: *mut FT_String)
     -> FT_UInt;
}
extern "C" {
    pub fn FT_Get_SubGlyph_Info(glyph: FT_GlyphSlot, sub_index: FT_UInt,
                                p_index: *mut FT_Int, p_flags: *mut FT_UInt,
                                p_arg1: *mut FT_Int, p_arg2: *mut FT_Int,
                                p_transform: *mut FT_Matrix) -> FT_Error;
}
extern "C" {
    pub fn FT_Get_FSType_Flags(face: FT_Face) -> FT_UShort;
}
extern "C" {
    pub fn FT_Face_GetCharVariantIndex(face: FT_Face, charcode: FT_ULong,
                                       variantSelector: FT_ULong) -> FT_UInt;
}
extern "C" {
    pub fn FT_Face_GetCharVariantIsDefault(face: FT_Face, charcode: FT_ULong,
                                           variantSelector: FT_ULong)
     -> FT_Int;
}
extern "C" {
    pub fn FT_Face_GetVariantSelectors(face: FT_Face) -> *mut FT_UInt32;
}
extern "C" {
    pub fn FT_Face_GetVariantsOfChar(face: FT_Face, charcode: FT_ULong)
     -> *mut FT_UInt32;
}
extern "C" {
    pub fn FT_Face_GetCharsOfVariant(face: FT_Face, variantSelector: FT_ULong)
     -> *mut FT_UInt32;
}
extern "C" {
    pub fn FT_MulDiv(a: FT_Long, b: FT_Long, c: FT_Long) -> FT_Long;
}
extern "C" {
    pub fn FT_MulFix(a: FT_Long, b: FT_Long) -> FT_Long;
}
extern "C" {
    pub fn FT_DivFix(a: FT_Long, b: FT_Long) -> FT_Long;
}
extern "C" {
    pub fn FT_RoundFix(a: FT_Fixed) -> FT_Fixed;
}
extern "C" {
    pub fn FT_CeilFix(a: FT_Fixed) -> FT_Fixed;
}
extern "C" {
    pub fn FT_FloorFix(a: FT_Fixed) -> FT_Fixed;
}
extern "C" {
    pub fn FT_Vector_Transform(vec: *mut FT_Vector, matrix: *const FT_Matrix);
}
extern "C" {
    pub fn FT_Library_Version(library: FT_Library, amajor: *mut FT_Int,
                              aminor: *mut FT_Int, apatch: *mut FT_Int);
}
extern "C" {
    pub fn FT_Face_CheckTrueTypePatents(face: FT_Face) -> FT_Bool;
}
extern "C" {
    pub fn FT_Face_SetUnpatentedHinting(face: FT_Face, value: FT_Bool)
     -> FT_Bool;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FT_LcdFilter_ {
    FT_LCD_FILTER_NONE = 0,
    FT_LCD_FILTER_DEFAULT = 1,
    FT_LCD_FILTER_LIGHT = 2,
    FT_LCD_FILTER_LEGACY1 = 3,
    FT_LCD_FILTER_LEGACY = 16,
    FT_LCD_FILTER_MAX = 17,
}
pub use self::FT_LcdFilter_ as FT_LcdFilter;
extern "C" {
    pub fn FT_Library_SetLcdFilter(library: FT_Library, filter: FT_LcdFilter)
     -> FT_Error;
}
extern "C" {
    pub fn FT_Library_SetLcdFilterWeights(library: FT_Library,
                                          weights:
                                              *mut ::std::os::raw::c_uchar)
     -> FT_Error;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FT_Sfnt_Tag_ {
    FT_SFNT_HEAD = 0,
    FT_SFNT_MAXP = 1,
    FT_SFNT_OS2 = 2,
    FT_SFNT_HHEA = 3,
    FT_SFNT_VHEA = 4,
    FT_SFNT_POST = 5,
    FT_SFNT_PCLT = 6,
    FT_SFNT_MAX = 7,
}
pub use self::FT_Sfnt_Tag_ as FT_Sfnt_Tag;
extern "C" {
    pub fn FT_Get_Sfnt_Table(face: FT_Face, tag: FT_Sfnt_Tag)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn FT_Load_Sfnt_Table(face: FT_Face, tag: FT_ULong, offset: FT_Long,
                              buffer: *mut FT_Byte, length: *mut FT_ULong)
     -> FT_Error;
}
extern "C" {
    pub fn FT_Sfnt_Table_Info(face: FT_Face, table_index: FT_UInt,
                              tag: *mut FT_ULong, length: *mut FT_ULong)
     -> FT_Error;
}
extern "C" {
    pub fn FT_Get_CMap_Language_ID(charmap: FT_CharMap) -> FT_ULong;
}
extern "C" {
    pub fn FT_Get_CMap_Format(charmap: FT_CharMap) -> FT_Long;
}
pub type FT_Module_Interface = FT_Pointer;
pub type FT_Module_Constructor =
    ::std::option::Option<unsafe extern "C" fn(module: FT_Module)
                              -> FT_Error>;
pub type FT_Module_Destructor =
    ::std::option::Option<unsafe extern "C" fn(module: FT_Module)>;
pub type FT_Module_Requester =
    ::std::option::Option<unsafe extern "C" fn(module: FT_Module,
                                               name:
                                                   *const ::std::os::raw::c_char)
                              -> FT_Module_Interface>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Module_Class_ {
    pub module_flags: FT_ULong,
    pub module_size: FT_Long,
    pub module_name: *const FT_String,
    pub module_version: FT_Fixed,
    pub module_requires: FT_Fixed,
    pub module_interface: *const ::std::os::raw::c_void,
    pub module_init: FT_Module_Constructor,
    pub module_done: FT_Module_Destructor,
    pub get_interface: FT_Module_Requester,
}
#[test]
fn bindgen_test_layout_FT_Module_Class_() {
    assert_eq!(::std::mem::size_of::<FT_Module_Class_>() , 72usize , concat !
               ( "Size of: " , stringify ! ( FT_Module_Class_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Module_Class_>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( FT_Module_Class_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Module_Class_ ) ) . module_flags as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Module_Class_ ) ,
                "::" , stringify ! ( module_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Module_Class_ ) ) . module_size as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Module_Class_ ) ,
                "::" , stringify ! ( module_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Module_Class_ ) ) . module_name as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Module_Class_ ) ,
                "::" , stringify ! ( module_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Module_Class_ ) ) . module_version as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Module_Class_ ) ,
                "::" , stringify ! ( module_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Module_Class_ ) ) . module_requires as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Module_Class_ ) ,
                "::" , stringify ! ( module_requires ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Module_Class_ ) ) . module_interface
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Module_Class_ ) ,
                "::" , stringify ! ( module_interface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Module_Class_ ) ) . module_init as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Module_Class_ ) ,
                "::" , stringify ! ( module_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Module_Class_ ) ) . module_done as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Module_Class_ ) ,
                "::" , stringify ! ( module_done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Module_Class_ ) ) . get_interface as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Module_Class_ ) ,
                "::" , stringify ! ( get_interface ) ));
}
impl Clone for FT_Module_Class_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Module_Class = FT_Module_Class_;
extern "C" {
    pub fn FT_Add_Module(library: FT_Library, clazz: *const FT_Module_Class)
     -> FT_Error;
}
extern "C" {
    pub fn FT_Get_Module(library: FT_Library,
                         module_name: *const ::std::os::raw::c_char)
     -> FT_Module;
}
extern "C" {
    pub fn FT_Remove_Module(library: FT_Library, module: FT_Module)
     -> FT_Error;
}
extern "C" {
    pub fn FT_Property_Set(library: FT_Library, module_name: *const FT_String,
                           property_name: *const FT_String,
                           value: *const ::std::os::raw::c_void) -> FT_Error;
}
extern "C" {
    pub fn FT_Property_Get(library: FT_Library, module_name: *const FT_String,
                           property_name: *const FT_String,
                           value: *mut ::std::os::raw::c_void) -> FT_Error;
}
extern "C" {
    pub fn FT_Reference_Library(library: FT_Library) -> FT_Error;
}
extern "C" {
    pub fn FT_New_Library(memory: FT_Memory, alibrary: *mut FT_Library)
     -> FT_Error;
}
extern "C" {
    pub fn FT_Done_Library(library: FT_Library) -> FT_Error;
}
pub type FT_DebugHook_Func =
    ::std::option::Option<unsafe extern "C" fn(arg:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn FT_Set_Debug_Hook(library: FT_Library, hook_index: FT_UInt,
                             debug_hook: FT_DebugHook_Func);
}
extern "C" {
    pub fn FT_Add_Default_Modules(library: FT_Library);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FT_TrueTypeEngineType_ {
    FT_TRUETYPE_ENGINE_TYPE_NONE = 0,
    FT_TRUETYPE_ENGINE_TYPE_UNPATENTED = 1,
    FT_TRUETYPE_ENGINE_TYPE_PATENTED = 2,
}
pub use self::FT_TrueTypeEngineType_ as FT_TrueTypeEngineType;
extern "C" {
    pub fn FT_Get_TrueType_Engine_Type(library: FT_Library)
     -> FT_TrueTypeEngineType;
}
extern "C" {
    pub fn FT_Outline_Decompose(outline: *mut FT_Outline,
                                func_interface: *const FT_Outline_Funcs,
                                user: *mut ::std::os::raw::c_void)
     -> FT_Error;
}
extern "C" {
    pub fn FT_Outline_New(library: FT_Library, numPoints: FT_UInt,
                          numContours: FT_Int, anoutline: *mut FT_Outline)
     -> FT_Error;
}
extern "C" {
    pub fn FT_Outline_New_Internal(memory: FT_Memory, numPoints: FT_UInt,
                                   numContours: FT_Int,
                                   anoutline: *mut FT_Outline) -> FT_Error;
}
extern "C" {
    pub fn FT_Outline_Done(library: FT_Library, outline: *mut FT_Outline)
     -> FT_Error;
}
extern "C" {
    pub fn FT_Outline_Done_Internal(memory: FT_Memory,
                                    outline: *mut FT_Outline) -> FT_Error;
}
extern "C" {
    pub fn FT_Outline_Check(outline: *mut FT_Outline) -> FT_Error;
}
extern "C" {
    pub fn FT_Outline_Get_CBox(outline: *const FT_Outline,
                               acbox: *mut FT_BBox);
}
extern "C" {
    pub fn FT_Outline_Translate(outline: *const FT_Outline, xOffset: FT_Pos,
                                yOffset: FT_Pos);
}
extern "C" {
    pub fn FT_Outline_Copy(source: *const FT_Outline, target: *mut FT_Outline)
     -> FT_Error;
}
extern "C" {
    pub fn FT_Outline_Transform(outline: *const FT_Outline,
                                matrix: *const FT_Matrix);
}
extern "C" {
    pub fn FT_Outline_Embolden(outline: *mut FT_Outline, strength: FT_Pos)
     -> FT_Error;
}
extern "C" {
    pub fn FT_Outline_EmboldenXY(outline: *mut FT_Outline, xstrength: FT_Pos,
                                 ystrength: FT_Pos) -> FT_Error;
}
extern "C" {
    pub fn FT_Outline_Reverse(outline: *mut FT_Outline);
}
extern "C" {
    pub fn FT_Outline_Get_Bitmap(library: FT_Library,
                                 outline: *mut FT_Outline,
                                 abitmap: *const FT_Bitmap) -> FT_Error;
}
extern "C" {
    pub fn FT_Outline_Render(library: FT_Library, outline: *mut FT_Outline,
                             params: *mut FT_Raster_Params) -> FT_Error;
}
pub const FT_Orientation__FT_ORIENTATION_FILL_RIGHT: FT_Orientation_ =
    FT_Orientation_::FT_ORIENTATION_TRUETYPE;
pub const FT_Orientation__FT_ORIENTATION_FILL_LEFT: FT_Orientation_ =
    FT_Orientation_::FT_ORIENTATION_POSTSCRIPT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FT_Orientation_ {
    FT_ORIENTATION_TRUETYPE = 0,
    FT_ORIENTATION_POSTSCRIPT = 1,
    FT_ORIENTATION_NONE = 2,
}
pub use self::FT_Orientation_ as FT_Orientation;
extern "C" {
    pub fn FT_Outline_Get_Orientation(outline: *mut FT_Outline)
     -> FT_Orientation;
}
