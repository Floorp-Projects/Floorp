// This file is @generated by syn-internal-codegen.
// It is not intended for manual editing.

use super::{Lite, RefCast};
use std::fmt::{self, Debug, Display};
impl Debug for Lite<syn::Abi> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Abi");
        if let Some(val) = &_val.name {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::LitStr);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("name", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::AngleBracketedGenericArguments> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("AngleBracketedGenericArguments");
        if let Some(val) = &_val.colon2_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon2);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("colon2_token", Print::ref_cast(val));
        }
        if !_val.args.is_empty() {
            formatter.field("args", Lite(&_val.args));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::Arm> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Arm");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("pat", Lite(&_val.pat));
        if let Some(val) = &_val.guard {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::token::If, Box<syn::Expr>));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.1), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("guard", Print::ref_cast(val));
        }
        formatter.field("body", Lite(&_val.body));
        if let Some(val) = &_val.comma {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Comma);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("comma", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::AttrStyle> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::AttrStyle::Outer => formatter.write_str("Outer"),
            syn::AttrStyle::Inner(_val) => {
                formatter.write_str("Inner")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::Attribute> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Attribute");
        formatter.field("style", Lite(&_val.style));
        formatter.field("path", Lite(&_val.path));
        formatter.field("tokens", Lite(&_val.tokens));
        formatter.finish()
    }
}
impl Debug for Lite<syn::BareFnArg> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("BareFnArg");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if let Some(val) = &_val.name {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((proc_macro2::Ident, syn::token::Colon));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.0), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("name", Print::ref_cast(val));
        }
        formatter.field("ty", Lite(&_val.ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::BinOp> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::BinOp::Add(_val) => {
                formatter.write_str("Add")?;
                Ok(())
            }
            syn::BinOp::Sub(_val) => {
                formatter.write_str("Sub")?;
                Ok(())
            }
            syn::BinOp::Mul(_val) => {
                formatter.write_str("Mul")?;
                Ok(())
            }
            syn::BinOp::Div(_val) => {
                formatter.write_str("Div")?;
                Ok(())
            }
            syn::BinOp::Rem(_val) => {
                formatter.write_str("Rem")?;
                Ok(())
            }
            syn::BinOp::And(_val) => {
                formatter.write_str("And")?;
                Ok(())
            }
            syn::BinOp::Or(_val) => {
                formatter.write_str("Or")?;
                Ok(())
            }
            syn::BinOp::BitXor(_val) => {
                formatter.write_str("BitXor")?;
                Ok(())
            }
            syn::BinOp::BitAnd(_val) => {
                formatter.write_str("BitAnd")?;
                Ok(())
            }
            syn::BinOp::BitOr(_val) => {
                formatter.write_str("BitOr")?;
                Ok(())
            }
            syn::BinOp::Shl(_val) => {
                formatter.write_str("Shl")?;
                Ok(())
            }
            syn::BinOp::Shr(_val) => {
                formatter.write_str("Shr")?;
                Ok(())
            }
            syn::BinOp::Eq(_val) => {
                formatter.write_str("Eq")?;
                Ok(())
            }
            syn::BinOp::Lt(_val) => {
                formatter.write_str("Lt")?;
                Ok(())
            }
            syn::BinOp::Le(_val) => {
                formatter.write_str("Le")?;
                Ok(())
            }
            syn::BinOp::Ne(_val) => {
                formatter.write_str("Ne")?;
                Ok(())
            }
            syn::BinOp::Ge(_val) => {
                formatter.write_str("Ge")?;
                Ok(())
            }
            syn::BinOp::Gt(_val) => {
                formatter.write_str("Gt")?;
                Ok(())
            }
            syn::BinOp::AddEq(_val) => {
                formatter.write_str("AddEq")?;
                Ok(())
            }
            syn::BinOp::SubEq(_val) => {
                formatter.write_str("SubEq")?;
                Ok(())
            }
            syn::BinOp::MulEq(_val) => {
                formatter.write_str("MulEq")?;
                Ok(())
            }
            syn::BinOp::DivEq(_val) => {
                formatter.write_str("DivEq")?;
                Ok(())
            }
            syn::BinOp::RemEq(_val) => {
                formatter.write_str("RemEq")?;
                Ok(())
            }
            syn::BinOp::BitXorEq(_val) => {
                formatter.write_str("BitXorEq")?;
                Ok(())
            }
            syn::BinOp::BitAndEq(_val) => {
                formatter.write_str("BitAndEq")?;
                Ok(())
            }
            syn::BinOp::BitOrEq(_val) => {
                formatter.write_str("BitOrEq")?;
                Ok(())
            }
            syn::BinOp::ShlEq(_val) => {
                formatter.write_str("ShlEq")?;
                Ok(())
            }
            syn::BinOp::ShrEq(_val) => {
                formatter.write_str("ShrEq")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::Binding> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Binding");
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("ty", Lite(&_val.ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Block> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Block");
        if !_val.stmts.is_empty() {
            formatter.field("stmts", Lite(&_val.stmts));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::BoundLifetimes> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("BoundLifetimes");
        if !_val.lifetimes.is_empty() {
            formatter.field("lifetimes", Lite(&_val.lifetimes));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ConstParam> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ConstParam");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("ty", Lite(&_val.ty));
        if let Some(val) = &_val.eq_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Eq);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("eq_token", Print::ref_cast(val));
        }
        if let Some(val) = &_val.default {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Expr);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("default", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::Constraint> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Constraint");
        formatter.field("ident", Lite(&_val.ident));
        if !_val.bounds.is_empty() {
            formatter.field("bounds", Lite(&_val.bounds));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::Data> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::Data::Struct(_val) => {
                let mut formatter = formatter.debug_struct("Data::Struct");
                formatter.field("fields", Lite(&_val.fields));
                if let Some(val) = &_val.semi_token {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Semi);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("semi_token", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::Data::Enum(_val) => {
                let mut formatter = formatter.debug_struct("Data::Enum");
                if !_val.variants.is_empty() {
                    formatter.field("variants", Lite(&_val.variants));
                }
                formatter.finish()
            }
            syn::Data::Union(_val) => {
                let mut formatter = formatter.debug_struct("Data::Union");
                formatter.field("fields", Lite(&_val.fields));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::DataEnum> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("DataEnum");
        if !_val.variants.is_empty() {
            formatter.field("variants", Lite(&_val.variants));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::DataStruct> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("DataStruct");
        formatter.field("fields", Lite(&_val.fields));
        if let Some(val) = &_val.semi_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Semi);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("semi_token", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::DataUnion> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("DataUnion");
        formatter.field("fields", Lite(&_val.fields));
        formatter.finish()
    }
}
impl Debug for Lite<syn::DeriveInput> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("DeriveInput");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("vis", Lite(&_val.vis));
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("generics", Lite(&_val.generics));
        formatter.field("data", Lite(&_val.data));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Expr> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::Expr::Array(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Array");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                if !_val.elems.is_empty() {
                    formatter.field("elems", Lite(&_val.elems));
                }
                formatter.finish()
            }
            syn::Expr::Assign(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Assign");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("left", Lite(&_val.left));
                formatter.field("right", Lite(&_val.right));
                formatter.finish()
            }
            syn::Expr::AssignOp(_val) => {
                let mut formatter = formatter.debug_struct("Expr::AssignOp");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("left", Lite(&_val.left));
                formatter.field("op", Lite(&_val.op));
                formatter.field("right", Lite(&_val.right));
                formatter.finish()
            }
            syn::Expr::Async(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Async");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                if let Some(val) = &_val.capture {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Move);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("capture", Print::ref_cast(val));
                }
                formatter.field("block", Lite(&_val.block));
                formatter.finish()
            }
            syn::Expr::Await(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Await");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("base", Lite(&_val.base));
                formatter.finish()
            }
            syn::Expr::Binary(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Binary");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("left", Lite(&_val.left));
                formatter.field("op", Lite(&_val.op));
                formatter.field("right", Lite(&_val.right));
                formatter.finish()
            }
            syn::Expr::Block(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Block");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                if let Some(val) = &_val.label {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::Label);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("label", Print::ref_cast(val));
                }
                formatter.field("block", Lite(&_val.block));
                formatter.finish()
            }
            syn::Expr::Box(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Box");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("expr", Lite(&_val.expr));
                formatter.finish()
            }
            syn::Expr::Break(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Break");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                if let Some(val) = &_val.label {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::Lifetime);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("label", Print::ref_cast(val));
                }
                if let Some(val) = &_val.expr {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(Box<syn::Expr>);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("expr", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::Expr::Call(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Call");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("func", Lite(&_val.func));
                if !_val.args.is_empty() {
                    formatter.field("args", Lite(&_val.args));
                }
                formatter.finish()
            }
            syn::Expr::Cast(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Cast");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("expr", Lite(&_val.expr));
                formatter.field("ty", Lite(&_val.ty));
                formatter.finish()
            }
            syn::Expr::Closure(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Closure");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                if let Some(val) = &_val.asyncness {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Async);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("asyncness", Print::ref_cast(val));
                }
                if let Some(val) = &_val.movability {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Static);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("movability", Print::ref_cast(val));
                }
                if let Some(val) = &_val.capture {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Move);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("capture", Print::ref_cast(val));
                }
                if !_val.inputs.is_empty() {
                    formatter.field("inputs", Lite(&_val.inputs));
                }
                formatter.field("output", Lite(&_val.output));
                formatter.field("body", Lite(&_val.body));
                formatter.finish()
            }
            syn::Expr::Continue(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Continue");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                if let Some(val) = &_val.label {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::Lifetime);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("label", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::Expr::Field(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Field");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("base", Lite(&_val.base));
                formatter.field("member", Lite(&_val.member));
                formatter.finish()
            }
            syn::Expr::ForLoop(_val) => {
                let mut formatter = formatter.debug_struct("Expr::ForLoop");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                if let Some(val) = &_val.label {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::Label);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("label", Print::ref_cast(val));
                }
                formatter.field("pat", Lite(&_val.pat));
                formatter.field("expr", Lite(&_val.expr));
                formatter.field("body", Lite(&_val.body));
                formatter.finish()
            }
            syn::Expr::Group(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Group");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("expr", Lite(&_val.expr));
                formatter.finish()
            }
            syn::Expr::If(_val) => {
                let mut formatter = formatter.debug_struct("Expr::If");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("cond", Lite(&_val.cond));
                formatter.field("then_branch", Lite(&_val.then_branch));
                if let Some(val) = &_val.else_branch {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print((syn::token::Else, Box<syn::Expr>));
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(&_val.1), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("else_branch", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::Expr::Index(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Index");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("expr", Lite(&_val.expr));
                formatter.field("index", Lite(&_val.index));
                formatter.finish()
            }
            syn::Expr::Let(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Let");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("pat", Lite(&_val.pat));
                formatter.field("expr", Lite(&_val.expr));
                formatter.finish()
            }
            syn::Expr::Lit(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Lit");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("lit", Lite(&_val.lit));
                formatter.finish()
            }
            syn::Expr::Loop(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Loop");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                if let Some(val) = &_val.label {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::Label);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("label", Print::ref_cast(val));
                }
                formatter.field("body", Lite(&_val.body));
                formatter.finish()
            }
            syn::Expr::Macro(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Macro");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("mac", Lite(&_val.mac));
                formatter.finish()
            }
            syn::Expr::Match(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Match");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("expr", Lite(&_val.expr));
                if !_val.arms.is_empty() {
                    formatter.field("arms", Lite(&_val.arms));
                }
                formatter.finish()
            }
            syn::Expr::MethodCall(_val) => {
                let mut formatter = formatter.debug_struct("Expr::MethodCall");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("receiver", Lite(&_val.receiver));
                formatter.field("method", Lite(&_val.method));
                if let Some(val) = &_val.turbofish {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::MethodTurbofish);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("turbofish", Print::ref_cast(val));
                }
                if !_val.args.is_empty() {
                    formatter.field("args", Lite(&_val.args));
                }
                formatter.finish()
            }
            syn::Expr::Paren(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Paren");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("expr", Lite(&_val.expr));
                formatter.finish()
            }
            syn::Expr::Path(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Path");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                if let Some(val) = &_val.qself {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::QSelf);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("qself", Print::ref_cast(val));
                }
                formatter.field("path", Lite(&_val.path));
                formatter.finish()
            }
            syn::Expr::Range(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Range");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                if let Some(val) = &_val.from {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(Box<syn::Expr>);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("from", Print::ref_cast(val));
                }
                formatter.field("limits", Lite(&_val.limits));
                if let Some(val) = &_val.to {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(Box<syn::Expr>);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("to", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::Expr::Reference(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Reference");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                if let Some(val) = &_val.mutability {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Mut);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("mutability", Print::ref_cast(val));
                }
                formatter.field("expr", Lite(&_val.expr));
                formatter.finish()
            }
            syn::Expr::Repeat(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Repeat");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("expr", Lite(&_val.expr));
                formatter.field("len", Lite(&_val.len));
                formatter.finish()
            }
            syn::Expr::Return(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Return");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                if let Some(val) = &_val.expr {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(Box<syn::Expr>);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("expr", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::Expr::Struct(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Struct");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("path", Lite(&_val.path));
                if !_val.fields.is_empty() {
                    formatter.field("fields", Lite(&_val.fields));
                }
                if let Some(val) = &_val.dot2_token {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Dot2);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("dot2_token", Print::ref_cast(val));
                }
                if let Some(val) = &_val.rest {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(Box<syn::Expr>);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("rest", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::Expr::Try(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Try");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("expr", Lite(&_val.expr));
                formatter.finish()
            }
            syn::Expr::TryBlock(_val) => {
                let mut formatter = formatter.debug_struct("Expr::TryBlock");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("block", Lite(&_val.block));
                formatter.finish()
            }
            syn::Expr::Tuple(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Tuple");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                if !_val.elems.is_empty() {
                    formatter.field("elems", Lite(&_val.elems));
                }
                formatter.finish()
            }
            syn::Expr::Type(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Type");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("expr", Lite(&_val.expr));
                formatter.field("ty", Lite(&_val.ty));
                formatter.finish()
            }
            syn::Expr::Unary(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Unary");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("op", Lite(&_val.op));
                formatter.field("expr", Lite(&_val.expr));
                formatter.finish()
            }
            syn::Expr::Unsafe(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Unsafe");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("block", Lite(&_val.block));
                formatter.finish()
            }
            syn::Expr::Verbatim(_val) => {
                formatter.write_str("Verbatim")?;
                formatter.write_str("(`")?;
                Display::fmt(_val, formatter)?;
                formatter.write_str("`)")?;
                Ok(())
            }
            syn::Expr::While(_val) => {
                let mut formatter = formatter.debug_struct("Expr::While");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                if let Some(val) = &_val.label {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::Label);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("label", Print::ref_cast(val));
                }
                formatter.field("cond", Lite(&_val.cond));
                formatter.field("body", Lite(&_val.body));
                formatter.finish()
            }
            syn::Expr::Yield(_val) => {
                let mut formatter = formatter.debug_struct("Expr::Yield");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                if let Some(val) = &_val.expr {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(Box<syn::Expr>);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("expr", Print::ref_cast(val));
                }
                formatter.finish()
            }
            _ => unreachable!(),
        }
    }
}
impl Debug for Lite<syn::ExprArray> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprArray");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if !_val.elems.is_empty() {
            formatter.field("elems", Lite(&_val.elems));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprAssign> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprAssign");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("left", Lite(&_val.left));
        formatter.field("right", Lite(&_val.right));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprAssignOp> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprAssignOp");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("left", Lite(&_val.left));
        formatter.field("op", Lite(&_val.op));
        formatter.field("right", Lite(&_val.right));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprAsync> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprAsync");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if let Some(val) = &_val.capture {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Move);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("capture", Print::ref_cast(val));
        }
        formatter.field("block", Lite(&_val.block));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprAwait> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprAwait");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("base", Lite(&_val.base));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprBinary> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprBinary");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("left", Lite(&_val.left));
        formatter.field("op", Lite(&_val.op));
        formatter.field("right", Lite(&_val.right));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprBlock> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprBlock");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if let Some(val) = &_val.label {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Label);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("label", Print::ref_cast(val));
        }
        formatter.field("block", Lite(&_val.block));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprBox> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprBox");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("expr", Lite(&_val.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprBreak> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprBreak");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if let Some(val) = &_val.label {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Lifetime);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("label", Print::ref_cast(val));
        }
        if let Some(val) = &_val.expr {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(Box<syn::Expr>);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("expr", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprCall> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprCall");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("func", Lite(&_val.func));
        if !_val.args.is_empty() {
            formatter.field("args", Lite(&_val.args));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprCast> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprCast");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("expr", Lite(&_val.expr));
        formatter.field("ty", Lite(&_val.ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprClosure> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprClosure");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if let Some(val) = &_val.asyncness {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Async);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("asyncness", Print::ref_cast(val));
        }
        if let Some(val) = &_val.movability {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Static);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("movability", Print::ref_cast(val));
        }
        if let Some(val) = &_val.capture {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Move);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("capture", Print::ref_cast(val));
        }
        if !_val.inputs.is_empty() {
            formatter.field("inputs", Lite(&_val.inputs));
        }
        formatter.field("output", Lite(&_val.output));
        formatter.field("body", Lite(&_val.body));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprContinue> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprContinue");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if let Some(val) = &_val.label {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Lifetime);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("label", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprField> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprField");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("base", Lite(&_val.base));
        formatter.field("member", Lite(&_val.member));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprForLoop> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprForLoop");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if let Some(val) = &_val.label {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Label);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("label", Print::ref_cast(val));
        }
        formatter.field("pat", Lite(&_val.pat));
        formatter.field("expr", Lite(&_val.expr));
        formatter.field("body", Lite(&_val.body));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprGroup> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprGroup");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("expr", Lite(&_val.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprIf> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprIf");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("cond", Lite(&_val.cond));
        formatter.field("then_branch", Lite(&_val.then_branch));
        if let Some(val) = &_val.else_branch {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::token::Else, Box<syn::Expr>));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.1), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("else_branch", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprIndex> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprIndex");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("expr", Lite(&_val.expr));
        formatter.field("index", Lite(&_val.index));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprLet> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprLet");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("pat", Lite(&_val.pat));
        formatter.field("expr", Lite(&_val.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprLit> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprLit");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("lit", Lite(&_val.lit));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprLoop> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprLoop");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if let Some(val) = &_val.label {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Label);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("label", Print::ref_cast(val));
        }
        formatter.field("body", Lite(&_val.body));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprMacro> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprMacro");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("mac", Lite(&_val.mac));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprMatch> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprMatch");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("expr", Lite(&_val.expr));
        if !_val.arms.is_empty() {
            formatter.field("arms", Lite(&_val.arms));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprMethodCall> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprMethodCall");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("receiver", Lite(&_val.receiver));
        formatter.field("method", Lite(&_val.method));
        if let Some(val) = &_val.turbofish {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::MethodTurbofish);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("turbofish", Print::ref_cast(val));
        }
        if !_val.args.is_empty() {
            formatter.field("args", Lite(&_val.args));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprParen> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprParen");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("expr", Lite(&_val.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprPath> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprPath");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if let Some(val) = &_val.qself {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::QSelf);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("qself", Print::ref_cast(val));
        }
        formatter.field("path", Lite(&_val.path));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprRange> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprRange");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if let Some(val) = &_val.from {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(Box<syn::Expr>);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("from", Print::ref_cast(val));
        }
        formatter.field("limits", Lite(&_val.limits));
        if let Some(val) = &_val.to {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(Box<syn::Expr>);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("to", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprReference> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprReference");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if let Some(val) = &_val.mutability {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Mut);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("mutability", Print::ref_cast(val));
        }
        formatter.field("expr", Lite(&_val.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprRepeat> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprRepeat");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("expr", Lite(&_val.expr));
        formatter.field("len", Lite(&_val.len));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprReturn> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprReturn");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if let Some(val) = &_val.expr {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(Box<syn::Expr>);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("expr", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprStruct> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprStruct");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("path", Lite(&_val.path));
        if !_val.fields.is_empty() {
            formatter.field("fields", Lite(&_val.fields));
        }
        if let Some(val) = &_val.dot2_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Dot2);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("dot2_token", Print::ref_cast(val));
        }
        if let Some(val) = &_val.rest {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(Box<syn::Expr>);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("rest", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprTry> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprTry");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("expr", Lite(&_val.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprTryBlock> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprTryBlock");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("block", Lite(&_val.block));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprTuple> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprTuple");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if !_val.elems.is_empty() {
            formatter.field("elems", Lite(&_val.elems));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprType> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprType");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("expr", Lite(&_val.expr));
        formatter.field("ty", Lite(&_val.ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprUnary> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprUnary");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("op", Lite(&_val.op));
        formatter.field("expr", Lite(&_val.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprUnsafe> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprUnsafe");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("block", Lite(&_val.block));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprWhile> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprWhile");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if let Some(val) = &_val.label {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Label);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("label", Print::ref_cast(val));
        }
        formatter.field("cond", Lite(&_val.cond));
        formatter.field("body", Lite(&_val.body));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ExprYield> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ExprYield");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if let Some(val) = &_val.expr {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(Box<syn::Expr>);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("expr", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::Field> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Field");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("vis", Lite(&_val.vis));
        if let Some(val) = &_val.ident {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(proc_macro2::Ident);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("ident", Print::ref_cast(val));
        }
        if let Some(val) = &_val.colon_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("colon_token", Print::ref_cast(val));
        }
        formatter.field("ty", Lite(&_val.ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::FieldPat> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("FieldPat");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("member", Lite(&_val.member));
        if let Some(val) = &_val.colon_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("colon_token", Print::ref_cast(val));
        }
        formatter.field("pat", Lite(&_val.pat));
        formatter.finish()
    }
}
impl Debug for Lite<syn::FieldValue> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("FieldValue");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("member", Lite(&_val.member));
        if let Some(val) = &_val.colon_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("colon_token", Print::ref_cast(val));
        }
        formatter.field("expr", Lite(&_val.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Fields> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::Fields::Named(_val) => {
                let mut formatter = formatter.debug_struct("Fields::Named");
                if !_val.named.is_empty() {
                    formatter.field("named", Lite(&_val.named));
                }
                formatter.finish()
            }
            syn::Fields::Unnamed(_val) => {
                let mut formatter = formatter.debug_struct("Fields::Unnamed");
                if !_val.unnamed.is_empty() {
                    formatter.field("unnamed", Lite(&_val.unnamed));
                }
                formatter.finish()
            }
            syn::Fields::Unit => formatter.write_str("Unit"),
        }
    }
}
impl Debug for Lite<syn::FieldsNamed> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("FieldsNamed");
        if !_val.named.is_empty() {
            formatter.field("named", Lite(&_val.named));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::FieldsUnnamed> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("FieldsUnnamed");
        if !_val.unnamed.is_empty() {
            formatter.field("unnamed", Lite(&_val.unnamed));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::File> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("File");
        if let Some(val) = &_val.shebang {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(String);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("shebang", Print::ref_cast(val));
        }
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if !_val.items.is_empty() {
            formatter.field("items", Lite(&_val.items));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::FnArg> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::FnArg::Receiver(_val) => {
                formatter.write_str("Receiver")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::FnArg::Typed(_val) => {
                formatter.write_str("Typed")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::ForeignItem> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::ForeignItem::Fn(_val) => {
                let mut formatter = formatter.debug_struct("ForeignItem::Fn");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("vis", Lite(&_val.vis));
                formatter.field("sig", Lite(&_val.sig));
                formatter.finish()
            }
            syn::ForeignItem::Static(_val) => {
                let mut formatter = formatter.debug_struct("ForeignItem::Static");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("vis", Lite(&_val.vis));
                if let Some(val) = &_val.mutability {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Mut);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("mutability", Print::ref_cast(val));
                }
                formatter.field("ident", Lite(&_val.ident));
                formatter.field("ty", Lite(&_val.ty));
                formatter.finish()
            }
            syn::ForeignItem::Type(_val) => {
                let mut formatter = formatter.debug_struct("ForeignItem::Type");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("vis", Lite(&_val.vis));
                formatter.field("ident", Lite(&_val.ident));
                formatter.finish()
            }
            syn::ForeignItem::Macro(_val) => {
                let mut formatter = formatter.debug_struct("ForeignItem::Macro");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("mac", Lite(&_val.mac));
                if let Some(val) = &_val.semi_token {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Semi);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("semi_token", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::ForeignItem::Verbatim(_val) => {
                formatter.write_str("Verbatim")?;
                formatter.write_str("(`")?;
                Display::fmt(_val, formatter)?;
                formatter.write_str("`)")?;
                Ok(())
            }
            _ => unreachable!(),
        }
    }
}
impl Debug for Lite<syn::ForeignItemFn> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ForeignItemFn");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("vis", Lite(&_val.vis));
        formatter.field("sig", Lite(&_val.sig));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ForeignItemMacro> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ForeignItemMacro");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("mac", Lite(&_val.mac));
        if let Some(val) = &_val.semi_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Semi);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("semi_token", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ForeignItemStatic> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ForeignItemStatic");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("vis", Lite(&_val.vis));
        if let Some(val) = &_val.mutability {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Mut);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("mutability", Print::ref_cast(val));
        }
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("ty", Lite(&_val.ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ForeignItemType> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ForeignItemType");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("vis", Lite(&_val.vis));
        formatter.field("ident", Lite(&_val.ident));
        formatter.finish()
    }
}
impl Debug for Lite<syn::GenericArgument> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::GenericArgument::Lifetime(_val) => {
                formatter.write_str("Lifetime")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::GenericArgument::Type(_val) => {
                formatter.write_str("Type")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::GenericArgument::Binding(_val) => {
                formatter.write_str("Binding")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::GenericArgument::Constraint(_val) => {
                formatter.write_str("Constraint")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::GenericArgument::Const(_val) => {
                formatter.write_str("Const")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::GenericMethodArgument> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::GenericMethodArgument::Type(_val) => {
                formatter.write_str("Type")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::GenericMethodArgument::Const(_val) => {
                formatter.write_str("Const")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::GenericParam> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::GenericParam::Type(_val) => {
                formatter.write_str("Type")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::GenericParam::Lifetime(_val) => {
                formatter.write_str("Lifetime")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::GenericParam::Const(_val) => {
                formatter.write_str("Const")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::Generics> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Generics");
        if let Some(val) = &_val.lt_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Lt);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("lt_token", Print::ref_cast(val));
        }
        if !_val.params.is_empty() {
            formatter.field("params", Lite(&_val.params));
        }
        if let Some(val) = &_val.gt_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Gt);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("gt_token", Print::ref_cast(val));
        }
        if let Some(val) = &_val.where_clause {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::WhereClause);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("where_clause", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ImplItem> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::ImplItem::Const(_val) => {
                let mut formatter = formatter.debug_struct("ImplItem::Const");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("vis", Lite(&_val.vis));
                if let Some(val) = &_val.defaultness {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Default);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("defaultness", Print::ref_cast(val));
                }
                formatter.field("ident", Lite(&_val.ident));
                formatter.field("ty", Lite(&_val.ty));
                formatter.field("expr", Lite(&_val.expr));
                formatter.finish()
            }
            syn::ImplItem::Method(_val) => {
                let mut formatter = formatter.debug_struct("ImplItem::Method");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("vis", Lite(&_val.vis));
                if let Some(val) = &_val.defaultness {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Default);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("defaultness", Print::ref_cast(val));
                }
                formatter.field("sig", Lite(&_val.sig));
                formatter.field("block", Lite(&_val.block));
                formatter.finish()
            }
            syn::ImplItem::Type(_val) => {
                let mut formatter = formatter.debug_struct("ImplItem::Type");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("vis", Lite(&_val.vis));
                if let Some(val) = &_val.defaultness {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Default);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("defaultness", Print::ref_cast(val));
                }
                formatter.field("ident", Lite(&_val.ident));
                formatter.field("generics", Lite(&_val.generics));
                formatter.field("ty", Lite(&_val.ty));
                formatter.finish()
            }
            syn::ImplItem::Macro(_val) => {
                let mut formatter = formatter.debug_struct("ImplItem::Macro");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("mac", Lite(&_val.mac));
                if let Some(val) = &_val.semi_token {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Semi);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("semi_token", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::ImplItem::Verbatim(_val) => {
                formatter.write_str("Verbatim")?;
                formatter.write_str("(`")?;
                Display::fmt(_val, formatter)?;
                formatter.write_str("`)")?;
                Ok(())
            }
            _ => unreachable!(),
        }
    }
}
impl Debug for Lite<syn::ImplItemConst> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ImplItemConst");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("vis", Lite(&_val.vis));
        if let Some(val) = &_val.defaultness {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Default);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("defaultness", Print::ref_cast(val));
        }
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("ty", Lite(&_val.ty));
        formatter.field("expr", Lite(&_val.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ImplItemMacro> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ImplItemMacro");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("mac", Lite(&_val.mac));
        if let Some(val) = &_val.semi_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Semi);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("semi_token", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ImplItemMethod> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ImplItemMethod");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("vis", Lite(&_val.vis));
        if let Some(val) = &_val.defaultness {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Default);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("defaultness", Print::ref_cast(val));
        }
        formatter.field("sig", Lite(&_val.sig));
        formatter.field("block", Lite(&_val.block));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ImplItemType> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ImplItemType");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("vis", Lite(&_val.vis));
        if let Some(val) = &_val.defaultness {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Default);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("defaultness", Print::ref_cast(val));
        }
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("generics", Lite(&_val.generics));
        formatter.field("ty", Lite(&_val.ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Index> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Index");
        formatter.field("index", Lite(&_val.index));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Item> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::Item::Const(_val) => {
                let mut formatter = formatter.debug_struct("Item::Const");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("vis", Lite(&_val.vis));
                formatter.field("ident", Lite(&_val.ident));
                formatter.field("ty", Lite(&_val.ty));
                formatter.field("expr", Lite(&_val.expr));
                formatter.finish()
            }
            syn::Item::Enum(_val) => {
                let mut formatter = formatter.debug_struct("Item::Enum");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("vis", Lite(&_val.vis));
                formatter.field("ident", Lite(&_val.ident));
                formatter.field("generics", Lite(&_val.generics));
                if !_val.variants.is_empty() {
                    formatter.field("variants", Lite(&_val.variants));
                }
                formatter.finish()
            }
            syn::Item::ExternCrate(_val) => {
                let mut formatter = formatter.debug_struct("Item::ExternCrate");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("vis", Lite(&_val.vis));
                formatter.field("ident", Lite(&_val.ident));
                if let Some(val) = &_val.rename {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print((syn::token::As, proc_macro2::Ident));
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(&_val.1), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("rename", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::Item::Fn(_val) => {
                let mut formatter = formatter.debug_struct("Item::Fn");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("vis", Lite(&_val.vis));
                formatter.field("sig", Lite(&_val.sig));
                formatter.field("block", Lite(&_val.block));
                formatter.finish()
            }
            syn::Item::ForeignMod(_val) => {
                let mut formatter = formatter.debug_struct("Item::ForeignMod");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("abi", Lite(&_val.abi));
                if !_val.items.is_empty() {
                    formatter.field("items", Lite(&_val.items));
                }
                formatter.finish()
            }
            syn::Item::Impl(_val) => {
                let mut formatter = formatter.debug_struct("Item::Impl");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                if let Some(val) = &_val.defaultness {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Default);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("defaultness", Print::ref_cast(val));
                }
                if let Some(val) = &_val.unsafety {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Unsafe);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("unsafety", Print::ref_cast(val));
                }
                formatter.field("generics", Lite(&_val.generics));
                if let Some(val) = &_val.trait_ {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print((Option<syn::token::Bang>, syn::Path, syn::token::For));
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(
                                &(
                                    {
                                        #[derive(RefCast)]
                                        #[repr(transparent)]
                                        struct Print(Option<syn::token::Bang>);
                                        impl Debug for Print {
                                            fn fmt(
                                                &self,
                                                formatter: &mut fmt::Formatter,
                                            ) -> fmt::Result
                                            {
                                                match &self.0 {
                                                    Some(_val) => {
                                                        formatter.write_str("Some")?;
                                                        Ok(())
                                                    }
                                                    None => formatter.write_str("None"),
                                                }
                                            }
                                        }
                                        Print::ref_cast(&_val.0)
                                    },
                                    Lite(&_val.1),
                                ),
                                formatter,
                            )?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("trait_", Print::ref_cast(val));
                }
                formatter.field("self_ty", Lite(&_val.self_ty));
                if !_val.items.is_empty() {
                    formatter.field("items", Lite(&_val.items));
                }
                formatter.finish()
            }
            syn::Item::Macro(_val) => {
                let mut formatter = formatter.debug_struct("Item::Macro");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                if let Some(val) = &_val.ident {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(proc_macro2::Ident);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("ident", Print::ref_cast(val));
                }
                formatter.field("mac", Lite(&_val.mac));
                if let Some(val) = &_val.semi_token {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Semi);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("semi_token", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::Item::Macro2(_val) => {
                let mut formatter = formatter.debug_struct("Item::Macro2");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("vis", Lite(&_val.vis));
                formatter.field("ident", Lite(&_val.ident));
                formatter.field("rules", Lite(&_val.rules));
                formatter.finish()
            }
            syn::Item::Mod(_val) => {
                let mut formatter = formatter.debug_struct("Item::Mod");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("vis", Lite(&_val.vis));
                formatter.field("ident", Lite(&_val.ident));
                if let Some(val) = &_val.content {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print((syn::token::Brace, Vec<syn::Item>));
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(&_val.1), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("content", Print::ref_cast(val));
                }
                if let Some(val) = &_val.semi {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Semi);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("semi", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::Item::Static(_val) => {
                let mut formatter = formatter.debug_struct("Item::Static");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("vis", Lite(&_val.vis));
                if let Some(val) = &_val.mutability {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Mut);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("mutability", Print::ref_cast(val));
                }
                formatter.field("ident", Lite(&_val.ident));
                formatter.field("ty", Lite(&_val.ty));
                formatter.field("expr", Lite(&_val.expr));
                formatter.finish()
            }
            syn::Item::Struct(_val) => {
                let mut formatter = formatter.debug_struct("Item::Struct");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("vis", Lite(&_val.vis));
                formatter.field("ident", Lite(&_val.ident));
                formatter.field("generics", Lite(&_val.generics));
                formatter.field("fields", Lite(&_val.fields));
                if let Some(val) = &_val.semi_token {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Semi);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("semi_token", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::Item::Trait(_val) => {
                let mut formatter = formatter.debug_struct("Item::Trait");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("vis", Lite(&_val.vis));
                if let Some(val) = &_val.unsafety {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Unsafe);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("unsafety", Print::ref_cast(val));
                }
                if let Some(val) = &_val.auto_token {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Auto);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("auto_token", Print::ref_cast(val));
                }
                formatter.field("ident", Lite(&_val.ident));
                formatter.field("generics", Lite(&_val.generics));
                if let Some(val) = &_val.colon_token {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Colon);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("colon_token", Print::ref_cast(val));
                }
                if !_val.supertraits.is_empty() {
                    formatter.field("supertraits", Lite(&_val.supertraits));
                }
                if !_val.items.is_empty() {
                    formatter.field("items", Lite(&_val.items));
                }
                formatter.finish()
            }
            syn::Item::TraitAlias(_val) => {
                let mut formatter = formatter.debug_struct("Item::TraitAlias");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("vis", Lite(&_val.vis));
                formatter.field("ident", Lite(&_val.ident));
                formatter.field("generics", Lite(&_val.generics));
                if !_val.bounds.is_empty() {
                    formatter.field("bounds", Lite(&_val.bounds));
                }
                formatter.finish()
            }
            syn::Item::Type(_val) => {
                let mut formatter = formatter.debug_struct("Item::Type");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("vis", Lite(&_val.vis));
                formatter.field("ident", Lite(&_val.ident));
                formatter.field("generics", Lite(&_val.generics));
                formatter.field("ty", Lite(&_val.ty));
                formatter.finish()
            }
            syn::Item::Union(_val) => {
                let mut formatter = formatter.debug_struct("Item::Union");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("vis", Lite(&_val.vis));
                formatter.field("ident", Lite(&_val.ident));
                formatter.field("generics", Lite(&_val.generics));
                formatter.field("fields", Lite(&_val.fields));
                formatter.finish()
            }
            syn::Item::Use(_val) => {
                let mut formatter = formatter.debug_struct("Item::Use");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("vis", Lite(&_val.vis));
                if let Some(val) = &_val.leading_colon {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Colon2);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("leading_colon", Print::ref_cast(val));
                }
                formatter.field("tree", Lite(&_val.tree));
                formatter.finish()
            }
            syn::Item::Verbatim(_val) => {
                formatter.write_str("Verbatim")?;
                formatter.write_str("(`")?;
                Display::fmt(_val, formatter)?;
                formatter.write_str("`)")?;
                Ok(())
            }
            _ => unreachable!(),
        }
    }
}
impl Debug for Lite<syn::ItemConst> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ItemConst");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("vis", Lite(&_val.vis));
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("ty", Lite(&_val.ty));
        formatter.field("expr", Lite(&_val.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemEnum> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ItemEnum");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("vis", Lite(&_val.vis));
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("generics", Lite(&_val.generics));
        if !_val.variants.is_empty() {
            formatter.field("variants", Lite(&_val.variants));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemExternCrate> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ItemExternCrate");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("vis", Lite(&_val.vis));
        formatter.field("ident", Lite(&_val.ident));
        if let Some(val) = &_val.rename {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::token::As, proc_macro2::Ident));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.1), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("rename", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemFn> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ItemFn");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("vis", Lite(&_val.vis));
        formatter.field("sig", Lite(&_val.sig));
        formatter.field("block", Lite(&_val.block));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemForeignMod> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ItemForeignMod");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("abi", Lite(&_val.abi));
        if !_val.items.is_empty() {
            formatter.field("items", Lite(&_val.items));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemImpl> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ItemImpl");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if let Some(val) = &_val.defaultness {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Default);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("defaultness", Print::ref_cast(val));
        }
        if let Some(val) = &_val.unsafety {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Unsafe);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("unsafety", Print::ref_cast(val));
        }
        formatter.field("generics", Lite(&_val.generics));
        if let Some(val) = &_val.trait_ {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((Option<syn::token::Bang>, syn::Path, syn::token::For));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(
                        &(
                            {
                                #[derive(RefCast)]
                                #[repr(transparent)]
                                struct Print(Option<syn::token::Bang>);
                                impl Debug for Print {
                                    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                                        match &self.0 {
                                            Some(_val) => {
                                                formatter.write_str("Some")?;
                                                Ok(())
                                            }
                                            None => formatter.write_str("None"),
                                        }
                                    }
                                }
                                Print::ref_cast(&_val.0)
                            },
                            Lite(&_val.1),
                        ),
                        formatter,
                    )?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("trait_", Print::ref_cast(val));
        }
        formatter.field("self_ty", Lite(&_val.self_ty));
        if !_val.items.is_empty() {
            formatter.field("items", Lite(&_val.items));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemMacro> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ItemMacro");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if let Some(val) = &_val.ident {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(proc_macro2::Ident);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("ident", Print::ref_cast(val));
        }
        formatter.field("mac", Lite(&_val.mac));
        if let Some(val) = &_val.semi_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Semi);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("semi_token", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemMacro2> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ItemMacro2");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("vis", Lite(&_val.vis));
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("rules", Lite(&_val.rules));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemMod> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ItemMod");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("vis", Lite(&_val.vis));
        formatter.field("ident", Lite(&_val.ident));
        if let Some(val) = &_val.content {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::token::Brace, Vec<syn::Item>));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.1), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("content", Print::ref_cast(val));
        }
        if let Some(val) = &_val.semi {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Semi);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("semi", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemStatic> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ItemStatic");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("vis", Lite(&_val.vis));
        if let Some(val) = &_val.mutability {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Mut);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("mutability", Print::ref_cast(val));
        }
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("ty", Lite(&_val.ty));
        formatter.field("expr", Lite(&_val.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemStruct> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ItemStruct");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("vis", Lite(&_val.vis));
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("generics", Lite(&_val.generics));
        formatter.field("fields", Lite(&_val.fields));
        if let Some(val) = &_val.semi_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Semi);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("semi_token", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemTrait> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ItemTrait");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("vis", Lite(&_val.vis));
        if let Some(val) = &_val.unsafety {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Unsafe);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("unsafety", Print::ref_cast(val));
        }
        if let Some(val) = &_val.auto_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Auto);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("auto_token", Print::ref_cast(val));
        }
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("generics", Lite(&_val.generics));
        if let Some(val) = &_val.colon_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("colon_token", Print::ref_cast(val));
        }
        if !_val.supertraits.is_empty() {
            formatter.field("supertraits", Lite(&_val.supertraits));
        }
        if !_val.items.is_empty() {
            formatter.field("items", Lite(&_val.items));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemTraitAlias> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ItemTraitAlias");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("vis", Lite(&_val.vis));
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("generics", Lite(&_val.generics));
        if !_val.bounds.is_empty() {
            formatter.field("bounds", Lite(&_val.bounds));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemType> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ItemType");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("vis", Lite(&_val.vis));
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("generics", Lite(&_val.generics));
        formatter.field("ty", Lite(&_val.ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemUnion> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ItemUnion");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("vis", Lite(&_val.vis));
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("generics", Lite(&_val.generics));
        formatter.field("fields", Lite(&_val.fields));
        formatter.finish()
    }
}
impl Debug for Lite<syn::ItemUse> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ItemUse");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("vis", Lite(&_val.vis));
        if let Some(val) = &_val.leading_colon {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon2);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("leading_colon", Print::ref_cast(val));
        }
        formatter.field("tree", Lite(&_val.tree));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Label> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Label");
        formatter.field("name", Lite(&_val.name));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Lifetime> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Lifetime");
        formatter.field("ident", Lite(&_val.ident));
        formatter.finish()
    }
}
impl Debug for Lite<syn::LifetimeDef> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("LifetimeDef");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("lifetime", Lite(&_val.lifetime));
        if let Some(val) = &_val.colon_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("colon_token", Print::ref_cast(val));
        }
        if !_val.bounds.is_empty() {
            formatter.field("bounds", Lite(&_val.bounds));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::Lit> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::Lit::Str(_val) => {
                write!(formatter, "{:?}", _val.value())
            }
            syn::Lit::ByteStr(_val) => {
                write!(formatter, "{:?}", _val.value())
            }
            syn::Lit::Byte(_val) => {
                write!(formatter, "{:?}", _val.value())
            }
            syn::Lit::Char(_val) => {
                write!(formatter, "{:?}", _val.value())
            }
            syn::Lit::Int(_val) => {
                write!(formatter, "{}", _val)
            }
            syn::Lit::Float(_val) => {
                write!(formatter, "{}", _val)
            }
            syn::Lit::Bool(_val) => {
                let mut formatter = formatter.debug_struct("Lit::Bool");
                formatter.field("value", Lite(&_val.value));
                formatter.finish()
            }
            syn::Lit::Verbatim(_val) => {
                formatter.write_str("Verbatim")?;
                formatter.write_str("(`")?;
                Display::fmt(_val, formatter)?;
                formatter.write_str("`)")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::LitBool> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("LitBool");
        formatter.field("value", Lite(&_val.value));
        formatter.finish()
    }
}
impl Debug for Lite<syn::LitByte> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        write!(formatter, "{:?}", _val.value())
    }
}
impl Debug for Lite<syn::LitByteStr> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        write!(formatter, "{:?}", _val.value())
    }
}
impl Debug for Lite<syn::LitChar> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        write!(formatter, "{:?}", _val.value())
    }
}
impl Debug for Lite<syn::LitFloat> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        write!(formatter, "{}", _val)
    }
}
impl Debug for Lite<syn::LitInt> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        write!(formatter, "{}", _val)
    }
}
impl Debug for Lite<syn::LitStr> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        write!(formatter, "{:?}", _val.value())
    }
}
impl Debug for Lite<syn::Local> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Local");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("pat", Lite(&_val.pat));
        if let Some(val) = &_val.init {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::token::Eq, Box<syn::Expr>));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.1), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("init", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::Macro> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Macro");
        formatter.field("path", Lite(&_val.path));
        formatter.field("delimiter", Lite(&_val.delimiter));
        formatter.field("tokens", Lite(&_val.tokens));
        formatter.finish()
    }
}
impl Debug for Lite<syn::MacroDelimiter> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::MacroDelimiter::Paren(_val) => {
                formatter.write_str("Paren")?;
                Ok(())
            }
            syn::MacroDelimiter::Brace(_val) => {
                formatter.write_str("Brace")?;
                Ok(())
            }
            syn::MacroDelimiter::Bracket(_val) => {
                formatter.write_str("Bracket")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::Member> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::Member::Named(_val) => {
                formatter.write_str("Named")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::Member::Unnamed(_val) => {
                formatter.write_str("Unnamed")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::Meta> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::Meta::Path(_val) => {
                formatter.write_str("Path")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::Meta::List(_val) => {
                let mut formatter = formatter.debug_struct("Meta::List");
                formatter.field("path", Lite(&_val.path));
                if !_val.nested.is_empty() {
                    formatter.field("nested", Lite(&_val.nested));
                }
                formatter.finish()
            }
            syn::Meta::NameValue(_val) => {
                let mut formatter = formatter.debug_struct("Meta::NameValue");
                formatter.field("path", Lite(&_val.path));
                formatter.field("lit", Lite(&_val.lit));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::MetaList> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("MetaList");
        formatter.field("path", Lite(&_val.path));
        if !_val.nested.is_empty() {
            formatter.field("nested", Lite(&_val.nested));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::MetaNameValue> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("MetaNameValue");
        formatter.field("path", Lite(&_val.path));
        formatter.field("lit", Lite(&_val.lit));
        formatter.finish()
    }
}
impl Debug for Lite<syn::MethodTurbofish> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("MethodTurbofish");
        if !_val.args.is_empty() {
            formatter.field("args", Lite(&_val.args));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::NestedMeta> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::NestedMeta::Meta(_val) => {
                formatter.write_str("Meta")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::NestedMeta::Lit(_val) => {
                formatter.write_str("Lit")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::ParenthesizedGenericArguments> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("ParenthesizedGenericArguments");
        if !_val.inputs.is_empty() {
            formatter.field("inputs", Lite(&_val.inputs));
        }
        formatter.field("output", Lite(&_val.output));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Pat> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::Pat::Box(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Box");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("pat", Lite(&_val.pat));
                formatter.finish()
            }
            syn::Pat::Ident(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Ident");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                if let Some(val) = &_val.by_ref {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Ref);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("by_ref", Print::ref_cast(val));
                }
                if let Some(val) = &_val.mutability {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Mut);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("mutability", Print::ref_cast(val));
                }
                formatter.field("ident", Lite(&_val.ident));
                if let Some(val) = &_val.subpat {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print((syn::token::At, Box<syn::Pat>));
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(&_val.1), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("subpat", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::Pat::Lit(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Lit");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("expr", Lite(&_val.expr));
                formatter.finish()
            }
            syn::Pat::Macro(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Macro");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("mac", Lite(&_val.mac));
                formatter.finish()
            }
            syn::Pat::Or(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Or");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                if let Some(val) = &_val.leading_vert {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Or);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("leading_vert", Print::ref_cast(val));
                }
                if !_val.cases.is_empty() {
                    formatter.field("cases", Lite(&_val.cases));
                }
                formatter.finish()
            }
            syn::Pat::Path(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Path");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                if let Some(val) = &_val.qself {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::QSelf);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("qself", Print::ref_cast(val));
                }
                formatter.field("path", Lite(&_val.path));
                formatter.finish()
            }
            syn::Pat::Range(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Range");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("lo", Lite(&_val.lo));
                formatter.field("limits", Lite(&_val.limits));
                formatter.field("hi", Lite(&_val.hi));
                formatter.finish()
            }
            syn::Pat::Reference(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Reference");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                if let Some(val) = &_val.mutability {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Mut);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("mutability", Print::ref_cast(val));
                }
                formatter.field("pat", Lite(&_val.pat));
                formatter.finish()
            }
            syn::Pat::Rest(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Rest");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.finish()
            }
            syn::Pat::Slice(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Slice");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                if !_val.elems.is_empty() {
                    formatter.field("elems", Lite(&_val.elems));
                }
                formatter.finish()
            }
            syn::Pat::Struct(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Struct");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("path", Lite(&_val.path));
                if !_val.fields.is_empty() {
                    formatter.field("fields", Lite(&_val.fields));
                }
                if let Some(val) = &_val.dot2_token {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Dot2);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("dot2_token", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::Pat::Tuple(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Tuple");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                if !_val.elems.is_empty() {
                    formatter.field("elems", Lite(&_val.elems));
                }
                formatter.finish()
            }
            syn::Pat::TupleStruct(_val) => {
                let mut formatter = formatter.debug_struct("Pat::TupleStruct");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("path", Lite(&_val.path));
                formatter.field("pat", Lite(&_val.pat));
                formatter.finish()
            }
            syn::Pat::Type(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Type");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("pat", Lite(&_val.pat));
                formatter.field("ty", Lite(&_val.ty));
                formatter.finish()
            }
            syn::Pat::Verbatim(_val) => {
                formatter.write_str("Verbatim")?;
                formatter.write_str("(`")?;
                Display::fmt(_val, formatter)?;
                formatter.write_str("`)")?;
                Ok(())
            }
            syn::Pat::Wild(_val) => {
                let mut formatter = formatter.debug_struct("Pat::Wild");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.finish()
            }
            _ => unreachable!(),
        }
    }
}
impl Debug for Lite<syn::PatBox> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatBox");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("pat", Lite(&_val.pat));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatIdent> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatIdent");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if let Some(val) = &_val.by_ref {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Ref);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("by_ref", Print::ref_cast(val));
        }
        if let Some(val) = &_val.mutability {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Mut);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("mutability", Print::ref_cast(val));
        }
        formatter.field("ident", Lite(&_val.ident));
        if let Some(val) = &_val.subpat {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::token::At, Box<syn::Pat>));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.1), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("subpat", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatLit> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatLit");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("expr", Lite(&_val.expr));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatMacro> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatMacro");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("mac", Lite(&_val.mac));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatOr> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatOr");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if let Some(val) = &_val.leading_vert {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Or);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("leading_vert", Print::ref_cast(val));
        }
        if !_val.cases.is_empty() {
            formatter.field("cases", Lite(&_val.cases));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatPath> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatPath");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if let Some(val) = &_val.qself {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::QSelf);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("qself", Print::ref_cast(val));
        }
        formatter.field("path", Lite(&_val.path));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatRange> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatRange");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("lo", Lite(&_val.lo));
        formatter.field("limits", Lite(&_val.limits));
        formatter.field("hi", Lite(&_val.hi));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatReference> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatReference");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if let Some(val) = &_val.mutability {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Mut);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("mutability", Print::ref_cast(val));
        }
        formatter.field("pat", Lite(&_val.pat));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatRest> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatRest");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatSlice> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatSlice");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if !_val.elems.is_empty() {
            formatter.field("elems", Lite(&_val.elems));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatStruct> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatStruct");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("path", Lite(&_val.path));
        if !_val.fields.is_empty() {
            formatter.field("fields", Lite(&_val.fields));
        }
        if let Some(val) = &_val.dot2_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Dot2);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("dot2_token", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatTuple> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatTuple");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if !_val.elems.is_empty() {
            formatter.field("elems", Lite(&_val.elems));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatTupleStruct> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatTupleStruct");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("path", Lite(&_val.path));
        formatter.field("pat", Lite(&_val.pat));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatType> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatType");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("pat", Lite(&_val.pat));
        formatter.field("ty", Lite(&_val.ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PatWild> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PatWild");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::Path> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Path");
        if let Some(val) = &_val.leading_colon {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon2);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("leading_colon", Print::ref_cast(val));
        }
        if !_val.segments.is_empty() {
            formatter.field("segments", Lite(&_val.segments));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::PathArguments> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::PathArguments::None => formatter.write_str("None"),
            syn::PathArguments::AngleBracketed(_val) => {
                let mut formatter = formatter.debug_struct("PathArguments::AngleBracketed");
                if let Some(val) = &_val.colon2_token {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Colon2);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("colon2_token", Print::ref_cast(val));
                }
                if !_val.args.is_empty() {
                    formatter.field("args", Lite(&_val.args));
                }
                formatter.finish()
            }
            syn::PathArguments::Parenthesized(_val) => {
                let mut formatter = formatter.debug_struct("PathArguments::Parenthesized");
                if !_val.inputs.is_empty() {
                    formatter.field("inputs", Lite(&_val.inputs));
                }
                formatter.field("output", Lite(&_val.output));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::PathSegment> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PathSegment");
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("arguments", Lite(&_val.arguments));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PredicateEq> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PredicateEq");
        formatter.field("lhs_ty", Lite(&_val.lhs_ty));
        formatter.field("rhs_ty", Lite(&_val.rhs_ty));
        formatter.finish()
    }
}
impl Debug for Lite<syn::PredicateLifetime> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PredicateLifetime");
        formatter.field("lifetime", Lite(&_val.lifetime));
        if !_val.bounds.is_empty() {
            formatter.field("bounds", Lite(&_val.bounds));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::PredicateType> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("PredicateType");
        if let Some(val) = &_val.lifetimes {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::BoundLifetimes);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("lifetimes", Print::ref_cast(val));
        }
        formatter.field("bounded_ty", Lite(&_val.bounded_ty));
        if !_val.bounds.is_empty() {
            formatter.field("bounds", Lite(&_val.bounds));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::QSelf> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("QSelf");
        formatter.field("ty", Lite(&_val.ty));
        formatter.field("position", Lite(&_val.position));
        if let Some(val) = &_val.as_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::As);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("as_token", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::RangeLimits> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::RangeLimits::HalfOpen(_val) => {
                formatter.write_str("HalfOpen")?;
                Ok(())
            }
            syn::RangeLimits::Closed(_val) => {
                formatter.write_str("Closed")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::Receiver> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Receiver");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        if let Some(val) = &_val.reference {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::token::And, Option<syn::Lifetime>));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(
                        {
                            #[derive(RefCast)]
                            #[repr(transparent)]
                            struct Print(Option<syn::Lifetime>);
                            impl Debug for Print {
                                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                                    match &self.0 {
                                        Some(_val) => {
                                            formatter.write_str("Some")?;
                                            formatter.write_str("(")?;
                                            Debug::fmt(Lite(_val), formatter)?;
                                            formatter.write_str(")")?;
                                            Ok(())
                                        }
                                        None => formatter.write_str("None"),
                                    }
                                }
                            }
                            Print::ref_cast(&_val.1)
                        },
                        formatter,
                    )?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("reference", Print::ref_cast(val));
        }
        if let Some(val) = &_val.mutability {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Mut);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("mutability", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::ReturnType> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::ReturnType::Default => formatter.write_str("Default"),
            syn::ReturnType::Type(_v0, _v1) => {
                let mut formatter = formatter.debug_tuple("Type");
                formatter.field(Lite(_v1));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::Signature> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Signature");
        if let Some(val) = &_val.constness {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Const);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("constness", Print::ref_cast(val));
        }
        if let Some(val) = &_val.asyncness {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Async);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("asyncness", Print::ref_cast(val));
        }
        if let Some(val) = &_val.unsafety {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Unsafe);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("unsafety", Print::ref_cast(val));
        }
        if let Some(val) = &_val.abi {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Abi);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("abi", Print::ref_cast(val));
        }
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("generics", Lite(&_val.generics));
        if !_val.inputs.is_empty() {
            formatter.field("inputs", Lite(&_val.inputs));
        }
        if let Some(val) = &_val.variadic {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Variadic);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("variadic", Print::ref_cast(val));
        }
        formatter.field("output", Lite(&_val.output));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Stmt> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::Stmt::Local(_val) => {
                formatter.write_str("Local")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::Stmt::Item(_val) => {
                formatter.write_str("Item")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::Stmt::Expr(_val) => {
                formatter.write_str("Expr")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::Stmt::Semi(_v0, _v1) => {
                let mut formatter = formatter.debug_tuple("Semi");
                formatter.field(Lite(_v0));
                formatter.finish()
            }
        }
    }
}
impl Debug for Lite<syn::TraitBound> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TraitBound");
        if let Some(val) = &_val.paren_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Paren);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("paren_token", Print::ref_cast(val));
        }
        formatter.field("modifier", Lite(&_val.modifier));
        if let Some(val) = &_val.lifetimes {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::BoundLifetimes);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("lifetimes", Print::ref_cast(val));
        }
        formatter.field("path", Lite(&_val.path));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TraitBoundModifier> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::TraitBoundModifier::None => formatter.write_str("None"),
            syn::TraitBoundModifier::Maybe(_val) => {
                formatter.write_str("Maybe")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::TraitItem> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::TraitItem::Const(_val) => {
                let mut formatter = formatter.debug_struct("TraitItem::Const");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("ident", Lite(&_val.ident));
                formatter.field("ty", Lite(&_val.ty));
                if let Some(val) = &_val.default {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print((syn::token::Eq, syn::Expr));
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(&_val.1), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("default", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::TraitItem::Method(_val) => {
                let mut formatter = formatter.debug_struct("TraitItem::Method");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("sig", Lite(&_val.sig));
                if let Some(val) = &_val.default {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::Block);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("default", Print::ref_cast(val));
                }
                if let Some(val) = &_val.semi_token {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Semi);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("semi_token", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::TraitItem::Type(_val) => {
                let mut formatter = formatter.debug_struct("TraitItem::Type");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("ident", Lite(&_val.ident));
                formatter.field("generics", Lite(&_val.generics));
                if let Some(val) = &_val.colon_token {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Colon);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("colon_token", Print::ref_cast(val));
                }
                if !_val.bounds.is_empty() {
                    formatter.field("bounds", Lite(&_val.bounds));
                }
                if let Some(val) = &_val.default {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print((syn::token::Eq, syn::Type));
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(&_val.1), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("default", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::TraitItem::Macro(_val) => {
                let mut formatter = formatter.debug_struct("TraitItem::Macro");
                if !_val.attrs.is_empty() {
                    formatter.field("attrs", Lite(&_val.attrs));
                }
                formatter.field("mac", Lite(&_val.mac));
                if let Some(val) = &_val.semi_token {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Semi);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("semi_token", Print::ref_cast(val));
                }
                formatter.finish()
            }
            syn::TraitItem::Verbatim(_val) => {
                formatter.write_str("Verbatim")?;
                formatter.write_str("(`")?;
                Display::fmt(_val, formatter)?;
                formatter.write_str("`)")?;
                Ok(())
            }
            _ => unreachable!(),
        }
    }
}
impl Debug for Lite<syn::TraitItemConst> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TraitItemConst");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("ty", Lite(&_val.ty));
        if let Some(val) = &_val.default {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::token::Eq, syn::Expr));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.1), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("default", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::TraitItemMacro> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TraitItemMacro");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("mac", Lite(&_val.mac));
        if let Some(val) = &_val.semi_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Semi);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("semi_token", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::TraitItemMethod> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TraitItemMethod");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("sig", Lite(&_val.sig));
        if let Some(val) = &_val.default {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Block);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("default", Print::ref_cast(val));
        }
        if let Some(val) = &_val.semi_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Semi);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("semi_token", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::TraitItemType> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TraitItemType");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("generics", Lite(&_val.generics));
        if let Some(val) = &_val.colon_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("colon_token", Print::ref_cast(val));
        }
        if !_val.bounds.is_empty() {
            formatter.field("bounds", Lite(&_val.bounds));
        }
        if let Some(val) = &_val.default {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::token::Eq, syn::Type));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.1), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("default", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::Type> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::Type::Array(_val) => {
                let mut formatter = formatter.debug_struct("Type::Array");
                formatter.field("elem", Lite(&_val.elem));
                formatter.field("len", Lite(&_val.len));
                formatter.finish()
            }
            syn::Type::BareFn(_val) => {
                let mut formatter = formatter.debug_struct("Type::BareFn");
                if let Some(val) = &_val.lifetimes {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::BoundLifetimes);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("lifetimes", Print::ref_cast(val));
                }
                if let Some(val) = &_val.unsafety {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Unsafe);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("unsafety", Print::ref_cast(val));
                }
                if let Some(val) = &_val.abi {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::Abi);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("abi", Print::ref_cast(val));
                }
                if !_val.inputs.is_empty() {
                    formatter.field("inputs", Lite(&_val.inputs));
                }
                if let Some(val) = &_val.variadic {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::Variadic);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("variadic", Print::ref_cast(val));
                }
                formatter.field("output", Lite(&_val.output));
                formatter.finish()
            }
            syn::Type::Group(_val) => {
                let mut formatter = formatter.debug_struct("Type::Group");
                formatter.field("elem", Lite(&_val.elem));
                formatter.finish()
            }
            syn::Type::ImplTrait(_val) => {
                let mut formatter = formatter.debug_struct("Type::ImplTrait");
                if !_val.bounds.is_empty() {
                    formatter.field("bounds", Lite(&_val.bounds));
                }
                formatter.finish()
            }
            syn::Type::Infer(_val) => {
                let mut formatter = formatter.debug_struct("Type::Infer");
                formatter.finish()
            }
            syn::Type::Macro(_val) => {
                let mut formatter = formatter.debug_struct("Type::Macro");
                formatter.field("mac", Lite(&_val.mac));
                formatter.finish()
            }
            syn::Type::Never(_val) => {
                let mut formatter = formatter.debug_struct("Type::Never");
                formatter.finish()
            }
            syn::Type::Paren(_val) => {
                let mut formatter = formatter.debug_struct("Type::Paren");
                formatter.field("elem", Lite(&_val.elem));
                formatter.finish()
            }
            syn::Type::Path(_val) => {
                let mut formatter = formatter.debug_struct("Type::Path");
                if let Some(val) = &_val.qself {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::QSelf);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("qself", Print::ref_cast(val));
                }
                formatter.field("path", Lite(&_val.path));
                formatter.finish()
            }
            syn::Type::Ptr(_val) => {
                let mut formatter = formatter.debug_struct("Type::Ptr");
                if let Some(val) = &_val.const_token {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Const);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("const_token", Print::ref_cast(val));
                }
                if let Some(val) = &_val.mutability {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Mut);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("mutability", Print::ref_cast(val));
                }
                formatter.field("elem", Lite(&_val.elem));
                formatter.finish()
            }
            syn::Type::Reference(_val) => {
                let mut formatter = formatter.debug_struct("Type::Reference");
                if let Some(val) = &_val.lifetime {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::Lifetime);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            let _val = &self.0;
                            formatter.write_str("(")?;
                            Debug::fmt(Lite(_val), formatter)?;
                            formatter.write_str(")")?;
                            Ok(())
                        }
                    }
                    formatter.field("lifetime", Print::ref_cast(val));
                }
                if let Some(val) = &_val.mutability {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Mut);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("mutability", Print::ref_cast(val));
                }
                formatter.field("elem", Lite(&_val.elem));
                formatter.finish()
            }
            syn::Type::Slice(_val) => {
                let mut formatter = formatter.debug_struct("Type::Slice");
                formatter.field("elem", Lite(&_val.elem));
                formatter.finish()
            }
            syn::Type::TraitObject(_val) => {
                let mut formatter = formatter.debug_struct("Type::TraitObject");
                if let Some(val) = &_val.dyn_token {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::Dyn);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("dyn_token", Print::ref_cast(val));
                }
                if !_val.bounds.is_empty() {
                    formatter.field("bounds", Lite(&_val.bounds));
                }
                formatter.finish()
            }
            syn::Type::Tuple(_val) => {
                let mut formatter = formatter.debug_struct("Type::Tuple");
                if !_val.elems.is_empty() {
                    formatter.field("elems", Lite(&_val.elems));
                }
                formatter.finish()
            }
            syn::Type::Verbatim(_val) => {
                formatter.write_str("Verbatim")?;
                formatter.write_str("(`")?;
                Display::fmt(_val, formatter)?;
                formatter.write_str("`)")?;
                Ok(())
            }
            _ => unreachable!(),
        }
    }
}
impl Debug for Lite<syn::TypeArray> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeArray");
        formatter.field("elem", Lite(&_val.elem));
        formatter.field("len", Lite(&_val.len));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeBareFn> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeBareFn");
        if let Some(val) = &_val.lifetimes {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::BoundLifetimes);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("lifetimes", Print::ref_cast(val));
        }
        if let Some(val) = &_val.unsafety {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Unsafe);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("unsafety", Print::ref_cast(val));
        }
        if let Some(val) = &_val.abi {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Abi);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("abi", Print::ref_cast(val));
        }
        if !_val.inputs.is_empty() {
            formatter.field("inputs", Lite(&_val.inputs));
        }
        if let Some(val) = &_val.variadic {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Variadic);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("variadic", Print::ref_cast(val));
        }
        formatter.field("output", Lite(&_val.output));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeGroup> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeGroup");
        formatter.field("elem", Lite(&_val.elem));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeImplTrait> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeImplTrait");
        if !_val.bounds.is_empty() {
            formatter.field("bounds", Lite(&_val.bounds));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeInfer> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeInfer");
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeMacro> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeMacro");
        formatter.field("mac", Lite(&_val.mac));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeNever> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeNever");
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeParam> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeParam");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("ident", Lite(&_val.ident));
        if let Some(val) = &_val.colon_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Colon);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("colon_token", Print::ref_cast(val));
        }
        if !_val.bounds.is_empty() {
            formatter.field("bounds", Lite(&_val.bounds));
        }
        if let Some(val) = &_val.eq_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Eq);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("eq_token", Print::ref_cast(val));
        }
        if let Some(val) = &_val.default {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Type);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("default", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeParamBound> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::TypeParamBound::Trait(_val) => {
                formatter.write_str("Trait")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::TypeParamBound::Lifetime(_val) => {
                formatter.write_str("Lifetime")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::TypeParen> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeParen");
        formatter.field("elem", Lite(&_val.elem));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypePath> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypePath");
        if let Some(val) = &_val.qself {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::QSelf);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("qself", Print::ref_cast(val));
        }
        formatter.field("path", Lite(&_val.path));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypePtr> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypePtr");
        if let Some(val) = &_val.const_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Const);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("const_token", Print::ref_cast(val));
        }
        if let Some(val) = &_val.mutability {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Mut);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("mutability", Print::ref_cast(val));
        }
        formatter.field("elem", Lite(&_val.elem));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeReference> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeReference");
        if let Some(val) = &_val.lifetime {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::Lifetime);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(_val), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("lifetime", Print::ref_cast(val));
        }
        if let Some(val) = &_val.mutability {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Mut);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("mutability", Print::ref_cast(val));
        }
        formatter.field("elem", Lite(&_val.elem));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeSlice> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeSlice");
        formatter.field("elem", Lite(&_val.elem));
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeTraitObject> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeTraitObject");
        if let Some(val) = &_val.dyn_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::Dyn);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("dyn_token", Print::ref_cast(val));
        }
        if !_val.bounds.is_empty() {
            formatter.field("bounds", Lite(&_val.bounds));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::TypeTuple> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("TypeTuple");
        if !_val.elems.is_empty() {
            formatter.field("elems", Lite(&_val.elems));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::UnOp> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::UnOp::Deref(_val) => {
                formatter.write_str("Deref")?;
                Ok(())
            }
            syn::UnOp::Not(_val) => {
                formatter.write_str("Not")?;
                Ok(())
            }
            syn::UnOp::Neg(_val) => {
                formatter.write_str("Neg")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::UseGlob> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("UseGlob");
        formatter.finish()
    }
}
impl Debug for Lite<syn::UseGroup> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("UseGroup");
        if !_val.items.is_empty() {
            formatter.field("items", Lite(&_val.items));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::UseName> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("UseName");
        formatter.field("ident", Lite(&_val.ident));
        formatter.finish()
    }
}
impl Debug for Lite<syn::UsePath> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("UsePath");
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("tree", Lite(&_val.tree));
        formatter.finish()
    }
}
impl Debug for Lite<syn::UseRename> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("UseRename");
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("rename", Lite(&_val.rename));
        formatter.finish()
    }
}
impl Debug for Lite<syn::UseTree> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::UseTree::Path(_val) => {
                formatter.write_str("Path")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::UseTree::Name(_val) => {
                formatter.write_str("Name")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::UseTree::Rename(_val) => {
                formatter.write_str("Rename")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::UseTree::Glob(_val) => {
                formatter.write_str("Glob")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::UseTree::Group(_val) => {
                formatter.write_str("Group")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
        }
    }
}
impl Debug for Lite<syn::Variadic> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Variadic");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::Variant> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("Variant");
        if !_val.attrs.is_empty() {
            formatter.field("attrs", Lite(&_val.attrs));
        }
        formatter.field("ident", Lite(&_val.ident));
        formatter.field("fields", Lite(&_val.fields));
        if let Some(val) = &_val.discriminant {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print((syn::token::Eq, syn::Expr));
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    let _val = &self.0;
                    formatter.write_str("(")?;
                    Debug::fmt(Lite(&_val.1), formatter)?;
                    formatter.write_str(")")?;
                    Ok(())
                }
            }
            formatter.field("discriminant", Print::ref_cast(val));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::VisCrate> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("VisCrate");
        formatter.finish()
    }
}
impl Debug for Lite<syn::VisPublic> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("VisPublic");
        formatter.finish()
    }
}
impl Debug for Lite<syn::VisRestricted> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("VisRestricted");
        if let Some(val) = &_val.in_token {
            #[derive(RefCast)]
            #[repr(transparent)]
            struct Print(syn::token::In);
            impl Debug for Print {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Some")?;
                    Ok(())
                }
            }
            formatter.field("in_token", Print::ref_cast(val));
        }
        formatter.field("path", Lite(&_val.path));
        formatter.finish()
    }
}
impl Debug for Lite<syn::Visibility> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::Visibility::Public(_val) => {
                let mut formatter = formatter.debug_struct("Visibility::Public");
                formatter.finish()
            }
            syn::Visibility::Crate(_val) => {
                let mut formatter = formatter.debug_struct("Visibility::Crate");
                formatter.finish()
            }
            syn::Visibility::Restricted(_val) => {
                let mut formatter = formatter.debug_struct("Visibility::Restricted");
                if let Some(val) = &_val.in_token {
                    #[derive(RefCast)]
                    #[repr(transparent)]
                    struct Print(syn::token::In);
                    impl Debug for Print {
                        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                            formatter.write_str("Some")?;
                            Ok(())
                        }
                    }
                    formatter.field("in_token", Print::ref_cast(val));
                }
                formatter.field("path", Lite(&_val.path));
                formatter.finish()
            }
            syn::Visibility::Inherited => formatter.write_str("Inherited"),
        }
    }
}
impl Debug for Lite<syn::WhereClause> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        let mut formatter = formatter.debug_struct("WhereClause");
        if !_val.predicates.is_empty() {
            formatter.field("predicates", Lite(&_val.predicates));
        }
        formatter.finish()
    }
}
impl Debug for Lite<syn::WherePredicate> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let _val = &self.value;
        match _val {
            syn::WherePredicate::Type(_val) => {
                formatter.write_str("Type")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::WherePredicate::Lifetime(_val) => {
                formatter.write_str("Lifetime")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
            syn::WherePredicate::Eq(_val) => {
                formatter.write_str("Eq")?;
                formatter.write_str("(")?;
                Debug::fmt(Lite(_val), formatter)?;
                formatter.write_str(")")?;
                Ok(())
            }
        }
    }
}
