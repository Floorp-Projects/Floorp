// THIS FILE IS AUTOMATICALLY GENERATED; DO NOT EDIT

#![cfg_attr(rustfmt, rustfmt_skip)]

// Unreachable code is generated sometimes without the full feature.
#![allow(unreachable_code)]
#![cfg_attr(feature = "cargo-clippy", allow(needless_pass_by_value))]

use *;
#[cfg(any(feature = "full", feature = "derive"))]
use token::{Brace, Bracket, Paren, Group};
use proc_macro2::Span;
#[cfg(any(feature = "full", feature = "derive"))]
use gen::helper::fold::*;


#[cfg(feature = "full")]
macro_rules! full {
    ($e:expr) => { $e }
}

#[cfg(all(feature = "derive", not(feature = "full")))]
macro_rules! full {
    ($e:expr) => { unreachable!() }
}


/// Syntax tree traversal to transform the nodes of an owned syntax tree.
///
/// See the [module documentation] for details.
///
/// [module documentation]: index.html
///
/// *This trait is available if Syn is built with the `"fold"` feature.*
pub trait Fold {
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_abi(&mut self, i: Abi) -> Abi { fold_abi(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_angle_bracketed_generic_arguments(&mut self, i: AngleBracketedGenericArguments) -> AngleBracketedGenericArguments { fold_angle_bracketed_generic_arguments(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_arg_captured(&mut self, i: ArgCaptured) -> ArgCaptured { fold_arg_captured(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_arg_self(&mut self, i: ArgSelf) -> ArgSelf { fold_arg_self(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_arg_self_ref(&mut self, i: ArgSelfRef) -> ArgSelfRef { fold_arg_self_ref(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
fn fold_arm(&mut self, i: Arm) -> Arm { fold_arm(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_attr_style(&mut self, i: AttrStyle) -> AttrStyle { fold_attr_style(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_attribute(&mut self, i: Attribute) -> Attribute { fold_attribute(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_bare_fn_arg(&mut self, i: BareFnArg) -> BareFnArg { fold_bare_fn_arg(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_bare_fn_arg_name(&mut self, i: BareFnArgName) -> BareFnArgName { fold_bare_fn_arg_name(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_bin_op(&mut self, i: BinOp) -> BinOp { fold_bin_op(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_binding(&mut self, i: Binding) -> Binding { fold_binding(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
fn fold_block(&mut self, i: Block) -> Block { fold_block(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_bound_lifetimes(&mut self, i: BoundLifetimes) -> BoundLifetimes { fold_bound_lifetimes(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_const_param(&mut self, i: ConstParam) -> ConstParam { fold_const_param(self, i) }
# [ cfg ( feature = "derive" ) ]
fn fold_data(&mut self, i: Data) -> Data { fold_data(self, i) }
# [ cfg ( feature = "derive" ) ]
fn fold_data_enum(&mut self, i: DataEnum) -> DataEnum { fold_data_enum(self, i) }
# [ cfg ( feature = "derive" ) ]
fn fold_data_struct(&mut self, i: DataStruct) -> DataStruct { fold_data_struct(self, i) }
# [ cfg ( feature = "derive" ) ]
fn fold_data_union(&mut self, i: DataUnion) -> DataUnion { fold_data_union(self, i) }
# [ cfg ( feature = "derive" ) ]
fn fold_derive_input(&mut self, i: DeriveInput) -> DeriveInput { fold_derive_input(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr(&mut self, i: Expr) -> Expr { fold_expr(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_array(&mut self, i: ExprArray) -> ExprArray { fold_expr_array(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_assign(&mut self, i: ExprAssign) -> ExprAssign { fold_expr_assign(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_assign_op(&mut self, i: ExprAssignOp) -> ExprAssignOp { fold_expr_assign_op(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_binary(&mut self, i: ExprBinary) -> ExprBinary { fold_expr_binary(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_block(&mut self, i: ExprBlock) -> ExprBlock { fold_expr_block(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_box(&mut self, i: ExprBox) -> ExprBox { fold_expr_box(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_break(&mut self, i: ExprBreak) -> ExprBreak { fold_expr_break(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_call(&mut self, i: ExprCall) -> ExprCall { fold_expr_call(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_cast(&mut self, i: ExprCast) -> ExprCast { fold_expr_cast(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_catch(&mut self, i: ExprCatch) -> ExprCatch { fold_expr_catch(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_closure(&mut self, i: ExprClosure) -> ExprClosure { fold_expr_closure(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_continue(&mut self, i: ExprContinue) -> ExprContinue { fold_expr_continue(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_field(&mut self, i: ExprField) -> ExprField { fold_expr_field(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_for_loop(&mut self, i: ExprForLoop) -> ExprForLoop { fold_expr_for_loop(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_group(&mut self, i: ExprGroup) -> ExprGroup { fold_expr_group(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_if(&mut self, i: ExprIf) -> ExprIf { fold_expr_if(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_if_let(&mut self, i: ExprIfLet) -> ExprIfLet { fold_expr_if_let(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_in_place(&mut self, i: ExprInPlace) -> ExprInPlace { fold_expr_in_place(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_index(&mut self, i: ExprIndex) -> ExprIndex { fold_expr_index(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_lit(&mut self, i: ExprLit) -> ExprLit { fold_expr_lit(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_loop(&mut self, i: ExprLoop) -> ExprLoop { fold_expr_loop(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_macro(&mut self, i: ExprMacro) -> ExprMacro { fold_expr_macro(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_match(&mut self, i: ExprMatch) -> ExprMatch { fold_expr_match(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_method_call(&mut self, i: ExprMethodCall) -> ExprMethodCall { fold_expr_method_call(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_paren(&mut self, i: ExprParen) -> ExprParen { fold_expr_paren(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_path(&mut self, i: ExprPath) -> ExprPath { fold_expr_path(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_range(&mut self, i: ExprRange) -> ExprRange { fold_expr_range(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_reference(&mut self, i: ExprReference) -> ExprReference { fold_expr_reference(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_repeat(&mut self, i: ExprRepeat) -> ExprRepeat { fold_expr_repeat(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_return(&mut self, i: ExprReturn) -> ExprReturn { fold_expr_return(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_struct(&mut self, i: ExprStruct) -> ExprStruct { fold_expr_struct(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_try(&mut self, i: ExprTry) -> ExprTry { fold_expr_try(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_tuple(&mut self, i: ExprTuple) -> ExprTuple { fold_expr_tuple(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_type(&mut self, i: ExprType) -> ExprType { fold_expr_type(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_unary(&mut self, i: ExprUnary) -> ExprUnary { fold_expr_unary(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_unsafe(&mut self, i: ExprUnsafe) -> ExprUnsafe { fold_expr_unsafe(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_verbatim(&mut self, i: ExprVerbatim) -> ExprVerbatim { fold_expr_verbatim(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_while(&mut self, i: ExprWhile) -> ExprWhile { fold_expr_while(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_while_let(&mut self, i: ExprWhileLet) -> ExprWhileLet { fold_expr_while_let(self, i) }
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_expr_yield(&mut self, i: ExprYield) -> ExprYield { fold_expr_yield(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_field(&mut self, i: Field) -> Field { fold_field(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
fn fold_field_pat(&mut self, i: FieldPat) -> FieldPat { fold_field_pat(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
fn fold_field_value(&mut self, i: FieldValue) -> FieldValue { fold_field_value(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_fields(&mut self, i: Fields) -> Fields { fold_fields(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_fields_named(&mut self, i: FieldsNamed) -> FieldsNamed { fold_fields_named(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_fields_unnamed(&mut self, i: FieldsUnnamed) -> FieldsUnnamed { fold_fields_unnamed(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_file(&mut self, i: File) -> File { fold_file(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_fn_arg(&mut self, i: FnArg) -> FnArg { fold_fn_arg(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_fn_decl(&mut self, i: FnDecl) -> FnDecl { fold_fn_decl(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_foreign_item(&mut self, i: ForeignItem) -> ForeignItem { fold_foreign_item(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_foreign_item_fn(&mut self, i: ForeignItemFn) -> ForeignItemFn { fold_foreign_item_fn(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_foreign_item_static(&mut self, i: ForeignItemStatic) -> ForeignItemStatic { fold_foreign_item_static(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_foreign_item_type(&mut self, i: ForeignItemType) -> ForeignItemType { fold_foreign_item_type(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_foreign_item_verbatim(&mut self, i: ForeignItemVerbatim) -> ForeignItemVerbatim { fold_foreign_item_verbatim(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_generic_argument(&mut self, i: GenericArgument) -> GenericArgument { fold_generic_argument(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
fn fold_generic_method_argument(&mut self, i: GenericMethodArgument) -> GenericMethodArgument { fold_generic_method_argument(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_generic_param(&mut self, i: GenericParam) -> GenericParam { fold_generic_param(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_generics(&mut self, i: Generics) -> Generics { fold_generics(self, i) }

fn fold_ident(&mut self, i: Ident) -> Ident { fold_ident(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_impl_item(&mut self, i: ImplItem) -> ImplItem { fold_impl_item(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_impl_item_const(&mut self, i: ImplItemConst) -> ImplItemConst { fold_impl_item_const(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_impl_item_macro(&mut self, i: ImplItemMacro) -> ImplItemMacro { fold_impl_item_macro(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_impl_item_method(&mut self, i: ImplItemMethod) -> ImplItemMethod { fold_impl_item_method(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_impl_item_type(&mut self, i: ImplItemType) -> ImplItemType { fold_impl_item_type(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_impl_item_verbatim(&mut self, i: ImplItemVerbatim) -> ImplItemVerbatim { fold_impl_item_verbatim(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_index(&mut self, i: Index) -> Index { fold_index(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item(&mut self, i: Item) -> Item { fold_item(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_const(&mut self, i: ItemConst) -> ItemConst { fold_item_const(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_enum(&mut self, i: ItemEnum) -> ItemEnum { fold_item_enum(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_extern_crate(&mut self, i: ItemExternCrate) -> ItemExternCrate { fold_item_extern_crate(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_fn(&mut self, i: ItemFn) -> ItemFn { fold_item_fn(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_foreign_mod(&mut self, i: ItemForeignMod) -> ItemForeignMod { fold_item_foreign_mod(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_impl(&mut self, i: ItemImpl) -> ItemImpl { fold_item_impl(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_macro(&mut self, i: ItemMacro) -> ItemMacro { fold_item_macro(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_macro2(&mut self, i: ItemMacro2) -> ItemMacro2 { fold_item_macro2(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_mod(&mut self, i: ItemMod) -> ItemMod { fold_item_mod(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_static(&mut self, i: ItemStatic) -> ItemStatic { fold_item_static(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_struct(&mut self, i: ItemStruct) -> ItemStruct { fold_item_struct(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_trait(&mut self, i: ItemTrait) -> ItemTrait { fold_item_trait(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_type(&mut self, i: ItemType) -> ItemType { fold_item_type(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_union(&mut self, i: ItemUnion) -> ItemUnion { fold_item_union(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_use(&mut self, i: ItemUse) -> ItemUse { fold_item_use(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_item_verbatim(&mut self, i: ItemVerbatim) -> ItemVerbatim { fold_item_verbatim(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
fn fold_label(&mut self, i: Label) -> Label { fold_label(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_lifetime(&mut self, i: Lifetime) -> Lifetime { fold_lifetime(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_lifetime_def(&mut self, i: LifetimeDef) -> LifetimeDef { fold_lifetime_def(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_lit(&mut self, i: Lit) -> Lit { fold_lit(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_lit_bool(&mut self, i: LitBool) -> LitBool { fold_lit_bool(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_lit_byte(&mut self, i: LitByte) -> LitByte { fold_lit_byte(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_lit_byte_str(&mut self, i: LitByteStr) -> LitByteStr { fold_lit_byte_str(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_lit_char(&mut self, i: LitChar) -> LitChar { fold_lit_char(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_lit_float(&mut self, i: LitFloat) -> LitFloat { fold_lit_float(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_lit_int(&mut self, i: LitInt) -> LitInt { fold_lit_int(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_lit_str(&mut self, i: LitStr) -> LitStr { fold_lit_str(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_lit_verbatim(&mut self, i: LitVerbatim) -> LitVerbatim { fold_lit_verbatim(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
fn fold_local(&mut self, i: Local) -> Local { fold_local(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_macro(&mut self, i: Macro) -> Macro { fold_macro(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_macro_delimiter(&mut self, i: MacroDelimiter) -> MacroDelimiter { fold_macro_delimiter(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_member(&mut self, i: Member) -> Member { fold_member(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_meta(&mut self, i: Meta) -> Meta { fold_meta(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_meta_list(&mut self, i: MetaList) -> MetaList { fold_meta_list(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_meta_name_value(&mut self, i: MetaNameValue) -> MetaNameValue { fold_meta_name_value(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_method_sig(&mut self, i: MethodSig) -> MethodSig { fold_method_sig(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
fn fold_method_turbofish(&mut self, i: MethodTurbofish) -> MethodTurbofish { fold_method_turbofish(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_nested_meta(&mut self, i: NestedMeta) -> NestedMeta { fold_nested_meta(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_parenthesized_generic_arguments(&mut self, i: ParenthesizedGenericArguments) -> ParenthesizedGenericArguments { fold_parenthesized_generic_arguments(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
fn fold_pat(&mut self, i: Pat) -> Pat { fold_pat(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
fn fold_pat_box(&mut self, i: PatBox) -> PatBox { fold_pat_box(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
fn fold_pat_ident(&mut self, i: PatIdent) -> PatIdent { fold_pat_ident(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
fn fold_pat_lit(&mut self, i: PatLit) -> PatLit { fold_pat_lit(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
fn fold_pat_macro(&mut self, i: PatMacro) -> PatMacro { fold_pat_macro(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
fn fold_pat_path(&mut self, i: PatPath) -> PatPath { fold_pat_path(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
fn fold_pat_range(&mut self, i: PatRange) -> PatRange { fold_pat_range(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
fn fold_pat_ref(&mut self, i: PatRef) -> PatRef { fold_pat_ref(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
fn fold_pat_slice(&mut self, i: PatSlice) -> PatSlice { fold_pat_slice(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
fn fold_pat_struct(&mut self, i: PatStruct) -> PatStruct { fold_pat_struct(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
fn fold_pat_tuple(&mut self, i: PatTuple) -> PatTuple { fold_pat_tuple(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
fn fold_pat_tuple_struct(&mut self, i: PatTupleStruct) -> PatTupleStruct { fold_pat_tuple_struct(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
fn fold_pat_verbatim(&mut self, i: PatVerbatim) -> PatVerbatim { fold_pat_verbatim(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
fn fold_pat_wild(&mut self, i: PatWild) -> PatWild { fold_pat_wild(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_path(&mut self, i: Path) -> Path { fold_path(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_path_arguments(&mut self, i: PathArguments) -> PathArguments { fold_path_arguments(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_path_segment(&mut self, i: PathSegment) -> PathSegment { fold_path_segment(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_predicate_eq(&mut self, i: PredicateEq) -> PredicateEq { fold_predicate_eq(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_predicate_lifetime(&mut self, i: PredicateLifetime) -> PredicateLifetime { fold_predicate_lifetime(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_predicate_type(&mut self, i: PredicateType) -> PredicateType { fold_predicate_type(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_qself(&mut self, i: QSelf) -> QSelf { fold_qself(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
fn fold_range_limits(&mut self, i: RangeLimits) -> RangeLimits { fold_range_limits(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_return_type(&mut self, i: ReturnType) -> ReturnType { fold_return_type(self, i) }

fn fold_span(&mut self, i: Span) -> Span { fold_span(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
fn fold_stmt(&mut self, i: Stmt) -> Stmt { fold_stmt(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_trait_bound(&mut self, i: TraitBound) -> TraitBound { fold_trait_bound(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_trait_bound_modifier(&mut self, i: TraitBoundModifier) -> TraitBoundModifier { fold_trait_bound_modifier(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_trait_item(&mut self, i: TraitItem) -> TraitItem { fold_trait_item(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_trait_item_const(&mut self, i: TraitItemConst) -> TraitItemConst { fold_trait_item_const(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_trait_item_macro(&mut self, i: TraitItemMacro) -> TraitItemMacro { fold_trait_item_macro(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_trait_item_method(&mut self, i: TraitItemMethod) -> TraitItemMethod { fold_trait_item_method(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_trait_item_type(&mut self, i: TraitItemType) -> TraitItemType { fold_trait_item_type(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_trait_item_verbatim(&mut self, i: TraitItemVerbatim) -> TraitItemVerbatim { fold_trait_item_verbatim(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_type(&mut self, i: Type) -> Type { fold_type(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_type_array(&mut self, i: TypeArray) -> TypeArray { fold_type_array(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_type_bare_fn(&mut self, i: TypeBareFn) -> TypeBareFn { fold_type_bare_fn(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_type_group(&mut self, i: TypeGroup) -> TypeGroup { fold_type_group(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_type_impl_trait(&mut self, i: TypeImplTrait) -> TypeImplTrait { fold_type_impl_trait(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_type_infer(&mut self, i: TypeInfer) -> TypeInfer { fold_type_infer(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_type_macro(&mut self, i: TypeMacro) -> TypeMacro { fold_type_macro(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_type_never(&mut self, i: TypeNever) -> TypeNever { fold_type_never(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_type_param(&mut self, i: TypeParam) -> TypeParam { fold_type_param(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_type_param_bound(&mut self, i: TypeParamBound) -> TypeParamBound { fold_type_param_bound(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_type_paren(&mut self, i: TypeParen) -> TypeParen { fold_type_paren(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_type_path(&mut self, i: TypePath) -> TypePath { fold_type_path(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_type_ptr(&mut self, i: TypePtr) -> TypePtr { fold_type_ptr(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_type_reference(&mut self, i: TypeReference) -> TypeReference { fold_type_reference(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_type_slice(&mut self, i: TypeSlice) -> TypeSlice { fold_type_slice(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_type_trait_object(&mut self, i: TypeTraitObject) -> TypeTraitObject { fold_type_trait_object(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_type_tuple(&mut self, i: TypeTuple) -> TypeTuple { fold_type_tuple(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_type_verbatim(&mut self, i: TypeVerbatim) -> TypeVerbatim { fold_type_verbatim(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_un_op(&mut self, i: UnOp) -> UnOp { fold_un_op(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_use_glob(&mut self, i: UseGlob) -> UseGlob { fold_use_glob(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_use_group(&mut self, i: UseGroup) -> UseGroup { fold_use_group(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_use_name(&mut self, i: UseName) -> UseName { fold_use_name(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_use_path(&mut self, i: UsePath) -> UsePath { fold_use_path(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_use_rename(&mut self, i: UseRename) -> UseRename { fold_use_rename(self, i) }
# [ cfg ( feature = "full" ) ]
fn fold_use_tree(&mut self, i: UseTree) -> UseTree { fold_use_tree(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_variant(&mut self, i: Variant) -> Variant { fold_variant(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_vis_crate(&mut self, i: VisCrate) -> VisCrate { fold_vis_crate(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_vis_public(&mut self, i: VisPublic) -> VisPublic { fold_vis_public(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_vis_restricted(&mut self, i: VisRestricted) -> VisRestricted { fold_vis_restricted(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_visibility(&mut self, i: Visibility) -> Visibility { fold_visibility(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_where_clause(&mut self, i: WhereClause) -> WhereClause { fold_where_clause(self, i) }
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
fn fold_where_predicate(&mut self, i: WherePredicate) -> WherePredicate { fold_where_predicate(self, i) }

}

macro_rules! fold_span_only {
    ($f:ident : $t:ident) => {
        pub fn $f<V: Fold + ?Sized>(_visitor: &mut V, mut _i: $t) -> $t {
            let span = _visitor.fold_span(_i.span());
            _i.set_span(span);
            _i
        }
    }
}

fold_span_only!(fold_ident: Ident);
#[cfg(any(feature = "full", feature = "derive"))]
fold_span_only!(fold_lifetime: Lifetime);
#[cfg(any(feature = "full", feature = "derive"))]
fold_span_only!(fold_lit_byte: LitByte);
#[cfg(any(feature = "full", feature = "derive"))]
fold_span_only!(fold_lit_byte_str: LitByteStr);
#[cfg(any(feature = "full", feature = "derive"))]
fold_span_only!(fold_lit_char: LitChar);
#[cfg(any(feature = "full", feature = "derive"))]
fold_span_only!(fold_lit_float: LitFloat);
#[cfg(any(feature = "full", feature = "derive"))]
fold_span_only!(fold_lit_int: LitInt);
#[cfg(any(feature = "full", feature = "derive"))]
fold_span_only!(fold_lit_str: LitStr);

# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_abi<V: Fold + ?Sized>(_visitor: &mut V, _i: Abi) -> Abi {
    Abi {
        extern_token: Token ! [ extern ](tokens_helper(_visitor, &(_i . extern_token).0)),
        name: (_i . name).map(|it| { _visitor.fold_lit_str(it) }),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_angle_bracketed_generic_arguments<V: Fold + ?Sized>(_visitor: &mut V, _i: AngleBracketedGenericArguments) -> AngleBracketedGenericArguments {
    AngleBracketedGenericArguments {
        colon2_token: (_i . colon2_token).map(|it| { Token ! [ :: ](tokens_helper(_visitor, &(it).0)) }),
        lt_token: Token ! [ < ](tokens_helper(_visitor, &(_i . lt_token).0)),
        args: FoldHelper::lift(_i . args, |it| { _visitor.fold_generic_argument(it) }),
        gt_token: Token ! [ > ](tokens_helper(_visitor, &(_i . gt_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_arg_captured<V: Fold + ?Sized>(_visitor: &mut V, _i: ArgCaptured) -> ArgCaptured {
    ArgCaptured {
        pat: _visitor.fold_pat(_i . pat),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &(_i . colon_token).0)),
        ty: _visitor.fold_type(_i . ty),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_arg_self<V: Fold + ?Sized>(_visitor: &mut V, _i: ArgSelf) -> ArgSelf {
    ArgSelf {
        mutability: (_i . mutability).map(|it| { Token ! [ mut ](tokens_helper(_visitor, &(it).0)) }),
        self_token: Token ! [ self ](tokens_helper(_visitor, &(_i . self_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_arg_self_ref<V: Fold + ?Sized>(_visitor: &mut V, _i: ArgSelfRef) -> ArgSelfRef {
    ArgSelfRef {
        and_token: Token ! [ & ](tokens_helper(_visitor, &(_i . and_token).0)),
        lifetime: (_i . lifetime).map(|it| { _visitor.fold_lifetime(it) }),
        mutability: (_i . mutability).map(|it| { Token ! [ mut ](tokens_helper(_visitor, &(it).0)) }),
        self_token: Token ! [ self ](tokens_helper(_visitor, &(_i . self_token).0)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
pub fn fold_arm<V: Fold + ?Sized>(_visitor: &mut V, _i: Arm) -> Arm {
    Arm {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        leading_vert: (_i . leading_vert).map(|it| { Token ! [ | ](tokens_helper(_visitor, &(it).0)) }),
        pats: FoldHelper::lift(_i . pats, |it| { _visitor.fold_pat(it) }),
        guard: (_i . guard).map(|it| { (
            Token ! [ if ](tokens_helper(_visitor, &(( it ) . 0).0)),
            Box::new(_visitor.fold_expr(* ( it ) . 1)),
        ) }),
        fat_arrow_token: Token ! [ => ](tokens_helper(_visitor, &(_i . fat_arrow_token).0)),
        body: Box::new(_visitor.fold_expr(* _i . body)),
        comma: (_i . comma).map(|it| { Token ! [ , ](tokens_helper(_visitor, &(it).0)) }),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_attr_style<V: Fold + ?Sized>(_visitor: &mut V, _i: AttrStyle) -> AttrStyle {
    match _i {
        AttrStyle::Outer => { AttrStyle::Outer }
        AttrStyle::Inner(_binding_0, ) => {
            AttrStyle::Inner (
                Token ! [ ! ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_attribute<V: Fold + ?Sized>(_visitor: &mut V, _i: Attribute) -> Attribute {
    Attribute {
        pound_token: Token ! [ # ](tokens_helper(_visitor, &(_i . pound_token).0)),
        style: _visitor.fold_attr_style(_i . style),
        bracket_token: Bracket(tokens_helper(_visitor, &(_i . bracket_token).0)),
        path: _visitor.fold_path(_i . path),
        tts: _i . tts,
        is_sugared_doc: _i . is_sugared_doc,
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_bare_fn_arg<V: Fold + ?Sized>(_visitor: &mut V, _i: BareFnArg) -> BareFnArg {
    BareFnArg {
        name: (_i . name).map(|it| { (
            _visitor.fold_bare_fn_arg_name(( it ) . 0),
            Token ! [ : ](tokens_helper(_visitor, &(( it ) . 1).0)),
        ) }),
        ty: _visitor.fold_type(_i . ty),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_bare_fn_arg_name<V: Fold + ?Sized>(_visitor: &mut V, _i: BareFnArgName) -> BareFnArgName {
    match _i {
        BareFnArgName::Named(_binding_0, ) => {
            BareFnArgName::Named (
                _visitor.fold_ident(_binding_0),
            )
        }
        BareFnArgName::Wild(_binding_0, ) => {
            BareFnArgName::Wild (
                Token ! [ _ ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_bin_op<V: Fold + ?Sized>(_visitor: &mut V, _i: BinOp) -> BinOp {
    match _i {
        BinOp::Add(_binding_0, ) => {
            BinOp::Add (
                Token ! [ + ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::Sub(_binding_0, ) => {
            BinOp::Sub (
                Token ! [ - ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::Mul(_binding_0, ) => {
            BinOp::Mul (
                Token ! [ * ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::Div(_binding_0, ) => {
            BinOp::Div (
                Token ! [ / ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::Rem(_binding_0, ) => {
            BinOp::Rem (
                Token ! [ % ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::And(_binding_0, ) => {
            BinOp::And (
                Token ! [ && ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::Or(_binding_0, ) => {
            BinOp::Or (
                Token ! [ || ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::BitXor(_binding_0, ) => {
            BinOp::BitXor (
                Token ! [ ^ ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::BitAnd(_binding_0, ) => {
            BinOp::BitAnd (
                Token ! [ & ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::BitOr(_binding_0, ) => {
            BinOp::BitOr (
                Token ! [ | ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::Shl(_binding_0, ) => {
            BinOp::Shl (
                Token ! [ << ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::Shr(_binding_0, ) => {
            BinOp::Shr (
                Token ! [ >> ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::Eq(_binding_0, ) => {
            BinOp::Eq (
                Token ! [ == ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::Lt(_binding_0, ) => {
            BinOp::Lt (
                Token ! [ < ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::Le(_binding_0, ) => {
            BinOp::Le (
                Token ! [ <= ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::Ne(_binding_0, ) => {
            BinOp::Ne (
                Token ! [ != ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::Ge(_binding_0, ) => {
            BinOp::Ge (
                Token ! [ >= ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::Gt(_binding_0, ) => {
            BinOp::Gt (
                Token ! [ > ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::AddEq(_binding_0, ) => {
            BinOp::AddEq (
                Token ! [ += ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::SubEq(_binding_0, ) => {
            BinOp::SubEq (
                Token ! [ -= ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::MulEq(_binding_0, ) => {
            BinOp::MulEq (
                Token ! [ *= ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::DivEq(_binding_0, ) => {
            BinOp::DivEq (
                Token ! [ /= ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::RemEq(_binding_0, ) => {
            BinOp::RemEq (
                Token ! [ %= ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::BitXorEq(_binding_0, ) => {
            BinOp::BitXorEq (
                Token ! [ ^= ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::BitAndEq(_binding_0, ) => {
            BinOp::BitAndEq (
                Token ! [ &= ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::BitOrEq(_binding_0, ) => {
            BinOp::BitOrEq (
                Token ! [ |= ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::ShlEq(_binding_0, ) => {
            BinOp::ShlEq (
                Token ! [ <<= ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        BinOp::ShrEq(_binding_0, ) => {
            BinOp::ShrEq (
                Token ! [ >>= ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_binding<V: Fold + ?Sized>(_visitor: &mut V, _i: Binding) -> Binding {
    Binding {
        ident: _visitor.fold_ident(_i . ident),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &(_i . eq_token).0)),
        ty: _visitor.fold_type(_i . ty),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
pub fn fold_block<V: Fold + ?Sized>(_visitor: &mut V, _i: Block) -> Block {
    Block {
        brace_token: Brace(tokens_helper(_visitor, &(_i . brace_token).0)),
        stmts: FoldHelper::lift(_i . stmts, |it| { _visitor.fold_stmt(it) }),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_bound_lifetimes<V: Fold + ?Sized>(_visitor: &mut V, _i: BoundLifetimes) -> BoundLifetimes {
    BoundLifetimes {
        for_token: Token ! [ for ](tokens_helper(_visitor, &(_i . for_token).0)),
        lt_token: Token ! [ < ](tokens_helper(_visitor, &(_i . lt_token).0)),
        lifetimes: FoldHelper::lift(_i . lifetimes, |it| { _visitor.fold_lifetime_def(it) }),
        gt_token: Token ! [ > ](tokens_helper(_visitor, &(_i . gt_token).0)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_const_param<V: Fold + ?Sized>(_visitor: &mut V, _i: ConstParam) -> ConstParam {
    ConstParam {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        const_token: Token ! [ const ](tokens_helper(_visitor, &(_i . const_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &(_i . colon_token).0)),
        ty: _visitor.fold_type(_i . ty),
        eq_token: (_i . eq_token).map(|it| { Token ! [ = ](tokens_helper(_visitor, &(it).0)) }),
        default: (_i . default).map(|it| { _visitor.fold_expr(it) }),
    }
}
# [ cfg ( feature = "derive" ) ]
pub fn fold_data<V: Fold + ?Sized>(_visitor: &mut V, _i: Data) -> Data {
    match _i {
        Data::Struct(_binding_0, ) => {
            Data::Struct (
                _visitor.fold_data_struct(_binding_0),
            )
        }
        Data::Enum(_binding_0, ) => {
            Data::Enum (
                _visitor.fold_data_enum(_binding_0),
            )
        }
        Data::Union(_binding_0, ) => {
            Data::Union (
                _visitor.fold_data_union(_binding_0),
            )
        }
    }
}
# [ cfg ( feature = "derive" ) ]
pub fn fold_data_enum<V: Fold + ?Sized>(_visitor: &mut V, _i: DataEnum) -> DataEnum {
    DataEnum {
        enum_token: Token ! [ enum ](tokens_helper(_visitor, &(_i . enum_token).0)),
        brace_token: Brace(tokens_helper(_visitor, &(_i . brace_token).0)),
        variants: FoldHelper::lift(_i . variants, |it| { _visitor.fold_variant(it) }),
    }
}
# [ cfg ( feature = "derive" ) ]
pub fn fold_data_struct<V: Fold + ?Sized>(_visitor: &mut V, _i: DataStruct) -> DataStruct {
    DataStruct {
        struct_token: Token ! [ struct ](tokens_helper(_visitor, &(_i . struct_token).0)),
        fields: _visitor.fold_fields(_i . fields),
        semi_token: (_i . semi_token).map(|it| { Token ! [ ; ](tokens_helper(_visitor, &(it).0)) }),
    }
}
# [ cfg ( feature = "derive" ) ]
pub fn fold_data_union<V: Fold + ?Sized>(_visitor: &mut V, _i: DataUnion) -> DataUnion {
    DataUnion {
        union_token: Token ! [ union ](tokens_helper(_visitor, &(_i . union_token).0)),
        fields: _visitor.fold_fields_named(_i . fields),
    }
}
# [ cfg ( feature = "derive" ) ]
pub fn fold_derive_input<V: Fold + ?Sized>(_visitor: &mut V, _i: DeriveInput) -> DeriveInput {
    DeriveInput {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        ident: _visitor.fold_ident(_i . ident),
        generics: _visitor.fold_generics(_i . generics),
        data: _visitor.fold_data(_i . data),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr<V: Fold + ?Sized>(_visitor: &mut V, _i: Expr) -> Expr {
    match _i {
        Expr::Box(_binding_0, ) => {
            Expr::Box (
                full!(_visitor.fold_expr_box(_binding_0)),
            )
        }
        Expr::InPlace(_binding_0, ) => {
            Expr::InPlace (
                full!(_visitor.fold_expr_in_place(_binding_0)),
            )
        }
        Expr::Array(_binding_0, ) => {
            Expr::Array (
                full!(_visitor.fold_expr_array(_binding_0)),
            )
        }
        Expr::Call(_binding_0, ) => {
            Expr::Call (
                _visitor.fold_expr_call(_binding_0),
            )
        }
        Expr::MethodCall(_binding_0, ) => {
            Expr::MethodCall (
                full!(_visitor.fold_expr_method_call(_binding_0)),
            )
        }
        Expr::Tuple(_binding_0, ) => {
            Expr::Tuple (
                full!(_visitor.fold_expr_tuple(_binding_0)),
            )
        }
        Expr::Binary(_binding_0, ) => {
            Expr::Binary (
                _visitor.fold_expr_binary(_binding_0),
            )
        }
        Expr::Unary(_binding_0, ) => {
            Expr::Unary (
                _visitor.fold_expr_unary(_binding_0),
            )
        }
        Expr::Lit(_binding_0, ) => {
            Expr::Lit (
                _visitor.fold_expr_lit(_binding_0),
            )
        }
        Expr::Cast(_binding_0, ) => {
            Expr::Cast (
                _visitor.fold_expr_cast(_binding_0),
            )
        }
        Expr::Type(_binding_0, ) => {
            Expr::Type (
                full!(_visitor.fold_expr_type(_binding_0)),
            )
        }
        Expr::If(_binding_0, ) => {
            Expr::If (
                full!(_visitor.fold_expr_if(_binding_0)),
            )
        }
        Expr::IfLet(_binding_0, ) => {
            Expr::IfLet (
                full!(_visitor.fold_expr_if_let(_binding_0)),
            )
        }
        Expr::While(_binding_0, ) => {
            Expr::While (
                full!(_visitor.fold_expr_while(_binding_0)),
            )
        }
        Expr::WhileLet(_binding_0, ) => {
            Expr::WhileLet (
                full!(_visitor.fold_expr_while_let(_binding_0)),
            )
        }
        Expr::ForLoop(_binding_0, ) => {
            Expr::ForLoop (
                full!(_visitor.fold_expr_for_loop(_binding_0)),
            )
        }
        Expr::Loop(_binding_0, ) => {
            Expr::Loop (
                full!(_visitor.fold_expr_loop(_binding_0)),
            )
        }
        Expr::Match(_binding_0, ) => {
            Expr::Match (
                full!(_visitor.fold_expr_match(_binding_0)),
            )
        }
        Expr::Closure(_binding_0, ) => {
            Expr::Closure (
                full!(_visitor.fold_expr_closure(_binding_0)),
            )
        }
        Expr::Unsafe(_binding_0, ) => {
            Expr::Unsafe (
                full!(_visitor.fold_expr_unsafe(_binding_0)),
            )
        }
        Expr::Block(_binding_0, ) => {
            Expr::Block (
                full!(_visitor.fold_expr_block(_binding_0)),
            )
        }
        Expr::Assign(_binding_0, ) => {
            Expr::Assign (
                full!(_visitor.fold_expr_assign(_binding_0)),
            )
        }
        Expr::AssignOp(_binding_0, ) => {
            Expr::AssignOp (
                full!(_visitor.fold_expr_assign_op(_binding_0)),
            )
        }
        Expr::Field(_binding_0, ) => {
            Expr::Field (
                full!(_visitor.fold_expr_field(_binding_0)),
            )
        }
        Expr::Index(_binding_0, ) => {
            Expr::Index (
                _visitor.fold_expr_index(_binding_0),
            )
        }
        Expr::Range(_binding_0, ) => {
            Expr::Range (
                full!(_visitor.fold_expr_range(_binding_0)),
            )
        }
        Expr::Path(_binding_0, ) => {
            Expr::Path (
                _visitor.fold_expr_path(_binding_0),
            )
        }
        Expr::Reference(_binding_0, ) => {
            Expr::Reference (
                full!(_visitor.fold_expr_reference(_binding_0)),
            )
        }
        Expr::Break(_binding_0, ) => {
            Expr::Break (
                full!(_visitor.fold_expr_break(_binding_0)),
            )
        }
        Expr::Continue(_binding_0, ) => {
            Expr::Continue (
                full!(_visitor.fold_expr_continue(_binding_0)),
            )
        }
        Expr::Return(_binding_0, ) => {
            Expr::Return (
                full!(_visitor.fold_expr_return(_binding_0)),
            )
        }
        Expr::Macro(_binding_0, ) => {
            Expr::Macro (
                full!(_visitor.fold_expr_macro(_binding_0)),
            )
        }
        Expr::Struct(_binding_0, ) => {
            Expr::Struct (
                full!(_visitor.fold_expr_struct(_binding_0)),
            )
        }
        Expr::Repeat(_binding_0, ) => {
            Expr::Repeat (
                full!(_visitor.fold_expr_repeat(_binding_0)),
            )
        }
        Expr::Paren(_binding_0, ) => {
            Expr::Paren (
                _visitor.fold_expr_paren(_binding_0),
            )
        }
        Expr::Group(_binding_0, ) => {
            Expr::Group (
                full!(_visitor.fold_expr_group(_binding_0)),
            )
        }
        Expr::Try(_binding_0, ) => {
            Expr::Try (
                full!(_visitor.fold_expr_try(_binding_0)),
            )
        }
        Expr::Catch(_binding_0, ) => {
            Expr::Catch (
                full!(_visitor.fold_expr_catch(_binding_0)),
            )
        }
        Expr::Yield(_binding_0, ) => {
            Expr::Yield (
                full!(_visitor.fold_expr_yield(_binding_0)),
            )
        }
        Expr::Verbatim(_binding_0, ) => {
            Expr::Verbatim (
                _visitor.fold_expr_verbatim(_binding_0),
            )
        }
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_array<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprArray) -> ExprArray {
    ExprArray {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        bracket_token: Bracket(tokens_helper(_visitor, &(_i . bracket_token).0)),
        elems: FoldHelper::lift(_i . elems, |it| { _visitor.fold_expr(it) }),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_assign<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprAssign) -> ExprAssign {
    ExprAssign {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        left: Box::new(_visitor.fold_expr(* _i . left)),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &(_i . eq_token).0)),
        right: Box::new(_visitor.fold_expr(* _i . right)),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_assign_op<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprAssignOp) -> ExprAssignOp {
    ExprAssignOp {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        left: Box::new(_visitor.fold_expr(* _i . left)),
        op: _visitor.fold_bin_op(_i . op),
        right: Box::new(_visitor.fold_expr(* _i . right)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_binary<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprBinary) -> ExprBinary {
    ExprBinary {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        left: Box::new(_visitor.fold_expr(* _i . left)),
        op: _visitor.fold_bin_op(_i . op),
        right: Box::new(_visitor.fold_expr(* _i . right)),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_block<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprBlock) -> ExprBlock {
    ExprBlock {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        block: _visitor.fold_block(_i . block),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_box<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprBox) -> ExprBox {
    ExprBox {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        box_token: Token ! [ box ](tokens_helper(_visitor, &(_i . box_token).0)),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_break<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprBreak) -> ExprBreak {
    ExprBreak {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        break_token: Token ! [ break ](tokens_helper(_visitor, &(_i . break_token).0)),
        label: (_i . label).map(|it| { _visitor.fold_lifetime(it) }),
        expr: (_i . expr).map(|it| { Box::new(_visitor.fold_expr(* it)) }),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_call<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprCall) -> ExprCall {
    ExprCall {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        func: Box::new(_visitor.fold_expr(* _i . func)),
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
        args: FoldHelper::lift(_i . args, |it| { _visitor.fold_expr(it) }),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_cast<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprCast) -> ExprCast {
    ExprCast {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        as_token: Token ! [ as ](tokens_helper(_visitor, &(_i . as_token).0)),
        ty: Box::new(_visitor.fold_type(* _i . ty)),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_catch<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprCatch) -> ExprCatch {
    ExprCatch {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        do_token: Token ! [ do ](tokens_helper(_visitor, &(_i . do_token).0)),
        catch_token: Token ! [ catch ](tokens_helper(_visitor, &(_i . catch_token).0)),
        block: _visitor.fold_block(_i . block),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_closure<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprClosure) -> ExprClosure {
    ExprClosure {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        movability: (_i . movability).map(|it| { Token ! [ static ](tokens_helper(_visitor, &(it).0)) }),
        capture: (_i . capture).map(|it| { Token ! [ move ](tokens_helper(_visitor, &(it).0)) }),
        or1_token: Token ! [ | ](tokens_helper(_visitor, &(_i . or1_token).0)),
        inputs: FoldHelper::lift(_i . inputs, |it| { _visitor.fold_fn_arg(it) }),
        or2_token: Token ! [ | ](tokens_helper(_visitor, &(_i . or2_token).0)),
        output: _visitor.fold_return_type(_i . output),
        body: Box::new(_visitor.fold_expr(* _i . body)),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_continue<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprContinue) -> ExprContinue {
    ExprContinue {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        continue_token: Token ! [ continue ](tokens_helper(_visitor, &(_i . continue_token).0)),
        label: (_i . label).map(|it| { _visitor.fold_lifetime(it) }),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_field<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprField) -> ExprField {
    ExprField {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        base: Box::new(_visitor.fold_expr(* _i . base)),
        dot_token: Token ! [ . ](tokens_helper(_visitor, &(_i . dot_token).0)),
        member: _visitor.fold_member(_i . member),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_for_loop<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprForLoop) -> ExprForLoop {
    ExprForLoop {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        label: (_i . label).map(|it| { _visitor.fold_label(it) }),
        for_token: Token ! [ for ](tokens_helper(_visitor, &(_i . for_token).0)),
        pat: Box::new(_visitor.fold_pat(* _i . pat)),
        in_token: Token ! [ in ](tokens_helper(_visitor, &(_i . in_token).0)),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        body: _visitor.fold_block(_i . body),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_group<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprGroup) -> ExprGroup {
    ExprGroup {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        group_token: Group(tokens_helper(_visitor, &(_i . group_token).0)),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_if<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprIf) -> ExprIf {
    ExprIf {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        if_token: Token ! [ if ](tokens_helper(_visitor, &(_i . if_token).0)),
        cond: Box::new(_visitor.fold_expr(* _i . cond)),
        then_branch: _visitor.fold_block(_i . then_branch),
        else_branch: (_i . else_branch).map(|it| { (
            Token ! [ else ](tokens_helper(_visitor, &(( it ) . 0).0)),
            Box::new(_visitor.fold_expr(* ( it ) . 1)),
        ) }),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_if_let<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprIfLet) -> ExprIfLet {
    ExprIfLet {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        if_token: Token ! [ if ](tokens_helper(_visitor, &(_i . if_token).0)),
        let_token: Token ! [ let ](tokens_helper(_visitor, &(_i . let_token).0)),
        pats: FoldHelper::lift(_i . pats, |it| { _visitor.fold_pat(it) }),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &(_i . eq_token).0)),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        then_branch: _visitor.fold_block(_i . then_branch),
        else_branch: (_i . else_branch).map(|it| { (
            Token ! [ else ](tokens_helper(_visitor, &(( it ) . 0).0)),
            Box::new(_visitor.fold_expr(* ( it ) . 1)),
        ) }),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_in_place<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprInPlace) -> ExprInPlace {
    ExprInPlace {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        place: Box::new(_visitor.fold_expr(* _i . place)),
        arrow_token: Token ! [ <- ](tokens_helper(_visitor, &(_i . arrow_token).0)),
        value: Box::new(_visitor.fold_expr(* _i . value)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_index<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprIndex) -> ExprIndex {
    ExprIndex {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        bracket_token: Bracket(tokens_helper(_visitor, &(_i . bracket_token).0)),
        index: Box::new(_visitor.fold_expr(* _i . index)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_lit<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprLit) -> ExprLit {
    ExprLit {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        lit: _visitor.fold_lit(_i . lit),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_loop<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprLoop) -> ExprLoop {
    ExprLoop {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        label: (_i . label).map(|it| { _visitor.fold_label(it) }),
        loop_token: Token ! [ loop ](tokens_helper(_visitor, &(_i . loop_token).0)),
        body: _visitor.fold_block(_i . body),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_macro<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprMacro) -> ExprMacro {
    ExprMacro {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        mac: _visitor.fold_macro(_i . mac),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_match<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprMatch) -> ExprMatch {
    ExprMatch {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        match_token: Token ! [ match ](tokens_helper(_visitor, &(_i . match_token).0)),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        brace_token: Brace(tokens_helper(_visitor, &(_i . brace_token).0)),
        arms: FoldHelper::lift(_i . arms, |it| { _visitor.fold_arm(it) }),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_method_call<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprMethodCall) -> ExprMethodCall {
    ExprMethodCall {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        receiver: Box::new(_visitor.fold_expr(* _i . receiver)),
        dot_token: Token ! [ . ](tokens_helper(_visitor, &(_i . dot_token).0)),
        method: _visitor.fold_ident(_i . method),
        turbofish: (_i . turbofish).map(|it| { _visitor.fold_method_turbofish(it) }),
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
        args: FoldHelper::lift(_i . args, |it| { _visitor.fold_expr(it) }),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_paren<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprParen) -> ExprParen {
    ExprParen {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_path<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprPath) -> ExprPath {
    ExprPath {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        qself: (_i . qself).map(|it| { _visitor.fold_qself(it) }),
        path: _visitor.fold_path(_i . path),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_range<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprRange) -> ExprRange {
    ExprRange {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        from: (_i . from).map(|it| { Box::new(_visitor.fold_expr(* it)) }),
        limits: _visitor.fold_range_limits(_i . limits),
        to: (_i . to).map(|it| { Box::new(_visitor.fold_expr(* it)) }),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_reference<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprReference) -> ExprReference {
    ExprReference {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        and_token: Token ! [ & ](tokens_helper(_visitor, &(_i . and_token).0)),
        mutability: (_i . mutability).map(|it| { Token ! [ mut ](tokens_helper(_visitor, &(it).0)) }),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_repeat<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprRepeat) -> ExprRepeat {
    ExprRepeat {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        bracket_token: Bracket(tokens_helper(_visitor, &(_i . bracket_token).0)),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
        len: Box::new(_visitor.fold_expr(* _i . len)),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_return<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprReturn) -> ExprReturn {
    ExprReturn {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        return_token: Token ! [ return ](tokens_helper(_visitor, &(_i . return_token).0)),
        expr: (_i . expr).map(|it| { Box::new(_visitor.fold_expr(* it)) }),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_struct<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprStruct) -> ExprStruct {
    ExprStruct {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        path: _visitor.fold_path(_i . path),
        brace_token: Brace(tokens_helper(_visitor, &(_i . brace_token).0)),
        fields: FoldHelper::lift(_i . fields, |it| { _visitor.fold_field_value(it) }),
        dot2_token: (_i . dot2_token).map(|it| { Token ! [ .. ](tokens_helper(_visitor, &(it).0)) }),
        rest: (_i . rest).map(|it| { Box::new(_visitor.fold_expr(* it)) }),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_try<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprTry) -> ExprTry {
    ExprTry {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        question_token: Token ! [ ? ](tokens_helper(_visitor, &(_i . question_token).0)),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_tuple<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprTuple) -> ExprTuple {
    ExprTuple {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
        elems: FoldHelper::lift(_i . elems, |it| { _visitor.fold_expr(it) }),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_type<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprType) -> ExprType {
    ExprType {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &(_i . colon_token).0)),
        ty: Box::new(_visitor.fold_type(* _i . ty)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_unary<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprUnary) -> ExprUnary {
    ExprUnary {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        op: _visitor.fold_un_op(_i . op),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_unsafe<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprUnsafe) -> ExprUnsafe {
    ExprUnsafe {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        unsafe_token: Token ! [ unsafe ](tokens_helper(_visitor, &(_i . unsafe_token).0)),
        block: _visitor.fold_block(_i . block),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_verbatim<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprVerbatim) -> ExprVerbatim {
    ExprVerbatim {
        tts: _i . tts,
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_while<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprWhile) -> ExprWhile {
    ExprWhile {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        label: (_i . label).map(|it| { _visitor.fold_label(it) }),
        while_token: Token ! [ while ](tokens_helper(_visitor, &(_i . while_token).0)),
        cond: Box::new(_visitor.fold_expr(* _i . cond)),
        body: _visitor.fold_block(_i . body),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_while_let<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprWhileLet) -> ExprWhileLet {
    ExprWhileLet {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        label: (_i . label).map(|it| { _visitor.fold_label(it) }),
        while_token: Token ! [ while ](tokens_helper(_visitor, &(_i . while_token).0)),
        let_token: Token ! [ let ](tokens_helper(_visitor, &(_i . let_token).0)),
        pats: FoldHelper::lift(_i . pats, |it| { _visitor.fold_pat(it) }),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &(_i . eq_token).0)),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        body: _visitor.fold_block(_i . body),
    }
}
# [ cfg ( feature = "full" ) ] # [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_expr_yield<V: Fold + ?Sized>(_visitor: &mut V, _i: ExprYield) -> ExprYield {
    ExprYield {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        yield_token: Token ! [ yield ](tokens_helper(_visitor, &(_i . yield_token).0)),
        expr: (_i . expr).map(|it| { Box::new(_visitor.fold_expr(* it)) }),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_field<V: Fold + ?Sized>(_visitor: &mut V, _i: Field) -> Field {
    Field {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        ident: (_i . ident).map(|it| { _visitor.fold_ident(it) }),
        colon_token: (_i . colon_token).map(|it| { Token ! [ : ](tokens_helper(_visitor, &(it).0)) }),
        ty: _visitor.fold_type(_i . ty),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
pub fn fold_field_pat<V: Fold + ?Sized>(_visitor: &mut V, _i: FieldPat) -> FieldPat {
    FieldPat {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        member: _visitor.fold_member(_i . member),
        colon_token: (_i . colon_token).map(|it| { Token ! [ : ](tokens_helper(_visitor, &(it).0)) }),
        pat: Box::new(_visitor.fold_pat(* _i . pat)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
pub fn fold_field_value<V: Fold + ?Sized>(_visitor: &mut V, _i: FieldValue) -> FieldValue {
    FieldValue {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        member: _visitor.fold_member(_i . member),
        colon_token: (_i . colon_token).map(|it| { Token ! [ : ](tokens_helper(_visitor, &(it).0)) }),
        expr: _visitor.fold_expr(_i . expr),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_fields<V: Fold + ?Sized>(_visitor: &mut V, _i: Fields) -> Fields {
    match _i {
        Fields::Named(_binding_0, ) => {
            Fields::Named (
                _visitor.fold_fields_named(_binding_0),
            )
        }
        Fields::Unnamed(_binding_0, ) => {
            Fields::Unnamed (
                _visitor.fold_fields_unnamed(_binding_0),
            )
        }
        Fields::Unit => { Fields::Unit }
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_fields_named<V: Fold + ?Sized>(_visitor: &mut V, _i: FieldsNamed) -> FieldsNamed {
    FieldsNamed {
        brace_token: Brace(tokens_helper(_visitor, &(_i . brace_token).0)),
        named: FoldHelper::lift(_i . named, |it| { _visitor.fold_field(it) }),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_fields_unnamed<V: Fold + ?Sized>(_visitor: &mut V, _i: FieldsUnnamed) -> FieldsUnnamed {
    FieldsUnnamed {
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
        unnamed: FoldHelper::lift(_i . unnamed, |it| { _visitor.fold_field(it) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_file<V: Fold + ?Sized>(_visitor: &mut V, _i: File) -> File {
    File {
        shebang: _i . shebang,
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        items: FoldHelper::lift(_i . items, |it| { _visitor.fold_item(it) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_fn_arg<V: Fold + ?Sized>(_visitor: &mut V, _i: FnArg) -> FnArg {
    match _i {
        FnArg::SelfRef(_binding_0, ) => {
            FnArg::SelfRef (
                _visitor.fold_arg_self_ref(_binding_0),
            )
        }
        FnArg::SelfValue(_binding_0, ) => {
            FnArg::SelfValue (
                _visitor.fold_arg_self(_binding_0),
            )
        }
        FnArg::Captured(_binding_0, ) => {
            FnArg::Captured (
                _visitor.fold_arg_captured(_binding_0),
            )
        }
        FnArg::Inferred(_binding_0, ) => {
            FnArg::Inferred (
                _visitor.fold_pat(_binding_0),
            )
        }
        FnArg::Ignored(_binding_0, ) => {
            FnArg::Ignored (
                _visitor.fold_type(_binding_0),
            )
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_fn_decl<V: Fold + ?Sized>(_visitor: &mut V, _i: FnDecl) -> FnDecl {
    FnDecl {
        fn_token: Token ! [ fn ](tokens_helper(_visitor, &(_i . fn_token).0)),
        generics: _visitor.fold_generics(_i . generics),
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
        inputs: FoldHelper::lift(_i . inputs, |it| { _visitor.fold_fn_arg(it) }),
        variadic: (_i . variadic).map(|it| { Token ! [ ... ](tokens_helper(_visitor, &(it).0)) }),
        output: _visitor.fold_return_type(_i . output),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_foreign_item<V: Fold + ?Sized>(_visitor: &mut V, _i: ForeignItem) -> ForeignItem {
    match _i {
        ForeignItem::Fn(_binding_0, ) => {
            ForeignItem::Fn (
                _visitor.fold_foreign_item_fn(_binding_0),
            )
        }
        ForeignItem::Static(_binding_0, ) => {
            ForeignItem::Static (
                _visitor.fold_foreign_item_static(_binding_0),
            )
        }
        ForeignItem::Type(_binding_0, ) => {
            ForeignItem::Type (
                _visitor.fold_foreign_item_type(_binding_0),
            )
        }
        ForeignItem::Verbatim(_binding_0, ) => {
            ForeignItem::Verbatim (
                _visitor.fold_foreign_item_verbatim(_binding_0),
            )
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_foreign_item_fn<V: Fold + ?Sized>(_visitor: &mut V, _i: ForeignItemFn) -> ForeignItemFn {
    ForeignItemFn {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        ident: _visitor.fold_ident(_i . ident),
        decl: Box::new(_visitor.fold_fn_decl(* _i . decl)),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_foreign_item_static<V: Fold + ?Sized>(_visitor: &mut V, _i: ForeignItemStatic) -> ForeignItemStatic {
    ForeignItemStatic {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        static_token: Token ! [ static ](tokens_helper(_visitor, &(_i . static_token).0)),
        mutability: (_i . mutability).map(|it| { Token ! [ mut ](tokens_helper(_visitor, &(it).0)) }),
        ident: _visitor.fold_ident(_i . ident),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &(_i . colon_token).0)),
        ty: Box::new(_visitor.fold_type(* _i . ty)),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_foreign_item_type<V: Fold + ?Sized>(_visitor: &mut V, _i: ForeignItemType) -> ForeignItemType {
    ForeignItemType {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        type_token: Token ! [ type ](tokens_helper(_visitor, &(_i . type_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_foreign_item_verbatim<V: Fold + ?Sized>(_visitor: &mut V, _i: ForeignItemVerbatim) -> ForeignItemVerbatim {
    ForeignItemVerbatim {
        tts: _i . tts,
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_generic_argument<V: Fold + ?Sized>(_visitor: &mut V, _i: GenericArgument) -> GenericArgument {
    match _i {
        GenericArgument::Lifetime(_binding_0, ) => {
            GenericArgument::Lifetime (
                _visitor.fold_lifetime(_binding_0),
            )
        }
        GenericArgument::Type(_binding_0, ) => {
            GenericArgument::Type (
                _visitor.fold_type(_binding_0),
            )
        }
        GenericArgument::Binding(_binding_0, ) => {
            GenericArgument::Binding (
                _visitor.fold_binding(_binding_0),
            )
        }
        GenericArgument::Const(_binding_0, ) => {
            GenericArgument::Const (
                _visitor.fold_expr(_binding_0),
            )
        }
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
pub fn fold_generic_method_argument<V: Fold + ?Sized>(_visitor: &mut V, _i: GenericMethodArgument) -> GenericMethodArgument {
    match _i {
        GenericMethodArgument::Type(_binding_0, ) => {
            GenericMethodArgument::Type (
                _visitor.fold_type(_binding_0),
            )
        }
        GenericMethodArgument::Const(_binding_0, ) => {
            GenericMethodArgument::Const (
                _visitor.fold_expr(_binding_0),
            )
        }
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_generic_param<V: Fold + ?Sized>(_visitor: &mut V, _i: GenericParam) -> GenericParam {
    match _i {
        GenericParam::Type(_binding_0, ) => {
            GenericParam::Type (
                _visitor.fold_type_param(_binding_0),
            )
        }
        GenericParam::Lifetime(_binding_0, ) => {
            GenericParam::Lifetime (
                _visitor.fold_lifetime_def(_binding_0),
            )
        }
        GenericParam::Const(_binding_0, ) => {
            GenericParam::Const (
                _visitor.fold_const_param(_binding_0),
            )
        }
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_generics<V: Fold + ?Sized>(_visitor: &mut V, _i: Generics) -> Generics {
    Generics {
        lt_token: (_i . lt_token).map(|it| { Token ! [ < ](tokens_helper(_visitor, &(it).0)) }),
        params: FoldHelper::lift(_i . params, |it| { _visitor.fold_generic_param(it) }),
        gt_token: (_i . gt_token).map(|it| { Token ! [ > ](tokens_helper(_visitor, &(it).0)) }),
        where_clause: (_i . where_clause).map(|it| { _visitor.fold_where_clause(it) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_impl_item<V: Fold + ?Sized>(_visitor: &mut V, _i: ImplItem) -> ImplItem {
    match _i {
        ImplItem::Const(_binding_0, ) => {
            ImplItem::Const (
                _visitor.fold_impl_item_const(_binding_0),
            )
        }
        ImplItem::Method(_binding_0, ) => {
            ImplItem::Method (
                _visitor.fold_impl_item_method(_binding_0),
            )
        }
        ImplItem::Type(_binding_0, ) => {
            ImplItem::Type (
                _visitor.fold_impl_item_type(_binding_0),
            )
        }
        ImplItem::Macro(_binding_0, ) => {
            ImplItem::Macro (
                _visitor.fold_impl_item_macro(_binding_0),
            )
        }
        ImplItem::Verbatim(_binding_0, ) => {
            ImplItem::Verbatim (
                _visitor.fold_impl_item_verbatim(_binding_0),
            )
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_impl_item_const<V: Fold + ?Sized>(_visitor: &mut V, _i: ImplItemConst) -> ImplItemConst {
    ImplItemConst {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        defaultness: (_i . defaultness).map(|it| { Token ! [ default ](tokens_helper(_visitor, &(it).0)) }),
        const_token: Token ! [ const ](tokens_helper(_visitor, &(_i . const_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &(_i . colon_token).0)),
        ty: _visitor.fold_type(_i . ty),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &(_i . eq_token).0)),
        expr: _visitor.fold_expr(_i . expr),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_impl_item_macro<V: Fold + ?Sized>(_visitor: &mut V, _i: ImplItemMacro) -> ImplItemMacro {
    ImplItemMacro {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        mac: _visitor.fold_macro(_i . mac),
        semi_token: (_i . semi_token).map(|it| { Token ! [ ; ](tokens_helper(_visitor, &(it).0)) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_impl_item_method<V: Fold + ?Sized>(_visitor: &mut V, _i: ImplItemMethod) -> ImplItemMethod {
    ImplItemMethod {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        defaultness: (_i . defaultness).map(|it| { Token ! [ default ](tokens_helper(_visitor, &(it).0)) }),
        sig: _visitor.fold_method_sig(_i . sig),
        block: _visitor.fold_block(_i . block),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_impl_item_type<V: Fold + ?Sized>(_visitor: &mut V, _i: ImplItemType) -> ImplItemType {
    ImplItemType {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        defaultness: (_i . defaultness).map(|it| { Token ! [ default ](tokens_helper(_visitor, &(it).0)) }),
        type_token: Token ! [ type ](tokens_helper(_visitor, &(_i . type_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        generics: _visitor.fold_generics(_i . generics),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &(_i . eq_token).0)),
        ty: _visitor.fold_type(_i . ty),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_impl_item_verbatim<V: Fold + ?Sized>(_visitor: &mut V, _i: ImplItemVerbatim) -> ImplItemVerbatim {
    ImplItemVerbatim {
        tts: _i . tts,
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_index<V: Fold + ?Sized>(_visitor: &mut V, _i: Index) -> Index {
    Index {
        index: _i . index,
        span: _visitor.fold_span(_i . span),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item<V: Fold + ?Sized>(_visitor: &mut V, _i: Item) -> Item {
    match _i {
        Item::ExternCrate(_binding_0, ) => {
            Item::ExternCrate (
                _visitor.fold_item_extern_crate(_binding_0),
            )
        }
        Item::Use(_binding_0, ) => {
            Item::Use (
                _visitor.fold_item_use(_binding_0),
            )
        }
        Item::Static(_binding_0, ) => {
            Item::Static (
                _visitor.fold_item_static(_binding_0),
            )
        }
        Item::Const(_binding_0, ) => {
            Item::Const (
                _visitor.fold_item_const(_binding_0),
            )
        }
        Item::Fn(_binding_0, ) => {
            Item::Fn (
                _visitor.fold_item_fn(_binding_0),
            )
        }
        Item::Mod(_binding_0, ) => {
            Item::Mod (
                _visitor.fold_item_mod(_binding_0),
            )
        }
        Item::ForeignMod(_binding_0, ) => {
            Item::ForeignMod (
                _visitor.fold_item_foreign_mod(_binding_0),
            )
        }
        Item::Type(_binding_0, ) => {
            Item::Type (
                _visitor.fold_item_type(_binding_0),
            )
        }
        Item::Struct(_binding_0, ) => {
            Item::Struct (
                _visitor.fold_item_struct(_binding_0),
            )
        }
        Item::Enum(_binding_0, ) => {
            Item::Enum (
                _visitor.fold_item_enum(_binding_0),
            )
        }
        Item::Union(_binding_0, ) => {
            Item::Union (
                _visitor.fold_item_union(_binding_0),
            )
        }
        Item::Trait(_binding_0, ) => {
            Item::Trait (
                _visitor.fold_item_trait(_binding_0),
            )
        }
        Item::Impl(_binding_0, ) => {
            Item::Impl (
                _visitor.fold_item_impl(_binding_0),
            )
        }
        Item::Macro(_binding_0, ) => {
            Item::Macro (
                _visitor.fold_item_macro(_binding_0),
            )
        }
        Item::Macro2(_binding_0, ) => {
            Item::Macro2 (
                _visitor.fold_item_macro2(_binding_0),
            )
        }
        Item::Verbatim(_binding_0, ) => {
            Item::Verbatim (
                _visitor.fold_item_verbatim(_binding_0),
            )
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_const<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemConst) -> ItemConst {
    ItemConst {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        const_token: Token ! [ const ](tokens_helper(_visitor, &(_i . const_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &(_i . colon_token).0)),
        ty: Box::new(_visitor.fold_type(* _i . ty)),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &(_i . eq_token).0)),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_enum<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemEnum) -> ItemEnum {
    ItemEnum {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        enum_token: Token ! [ enum ](tokens_helper(_visitor, &(_i . enum_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        generics: _visitor.fold_generics(_i . generics),
        brace_token: Brace(tokens_helper(_visitor, &(_i . brace_token).0)),
        variants: FoldHelper::lift(_i . variants, |it| { _visitor.fold_variant(it) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_extern_crate<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemExternCrate) -> ItemExternCrate {
    ItemExternCrate {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        extern_token: Token ! [ extern ](tokens_helper(_visitor, &(_i . extern_token).0)),
        crate_token: Token ! [ crate ](tokens_helper(_visitor, &(_i . crate_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        rename: (_i . rename).map(|it| { (
            Token ! [ as ](tokens_helper(_visitor, &(( it ) . 0).0)),
            _visitor.fold_ident(( it ) . 1),
        ) }),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_fn<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemFn) -> ItemFn {
    ItemFn {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        constness: (_i . constness).map(|it| { Token ! [ const ](tokens_helper(_visitor, &(it).0)) }),
        unsafety: (_i . unsafety).map(|it| { Token ! [ unsafe ](tokens_helper(_visitor, &(it).0)) }),
        abi: (_i . abi).map(|it| { _visitor.fold_abi(it) }),
        ident: _visitor.fold_ident(_i . ident),
        decl: Box::new(_visitor.fold_fn_decl(* _i . decl)),
        block: Box::new(_visitor.fold_block(* _i . block)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_foreign_mod<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemForeignMod) -> ItemForeignMod {
    ItemForeignMod {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        abi: _visitor.fold_abi(_i . abi),
        brace_token: Brace(tokens_helper(_visitor, &(_i . brace_token).0)),
        items: FoldHelper::lift(_i . items, |it| { _visitor.fold_foreign_item(it) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_impl<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemImpl) -> ItemImpl {
    ItemImpl {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        defaultness: (_i . defaultness).map(|it| { Token ! [ default ](tokens_helper(_visitor, &(it).0)) }),
        unsafety: (_i . unsafety).map(|it| { Token ! [ unsafe ](tokens_helper(_visitor, &(it).0)) }),
        impl_token: Token ! [ impl ](tokens_helper(_visitor, &(_i . impl_token).0)),
        generics: _visitor.fold_generics(_i . generics),
        trait_: (_i . trait_).map(|it| { (
            (( it ) . 0).map(|it| { Token ! [ ! ](tokens_helper(_visitor, &(it).0)) }),
            _visitor.fold_path(( it ) . 1),
            Token ! [ for ](tokens_helper(_visitor, &(( it ) . 2).0)),
        ) }),
        self_ty: Box::new(_visitor.fold_type(* _i . self_ty)),
        brace_token: Brace(tokens_helper(_visitor, &(_i . brace_token).0)),
        items: FoldHelper::lift(_i . items, |it| { _visitor.fold_impl_item(it) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_macro<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemMacro) -> ItemMacro {
    ItemMacro {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        ident: (_i . ident).map(|it| { _visitor.fold_ident(it) }),
        mac: _visitor.fold_macro(_i . mac),
        semi_token: (_i . semi_token).map(|it| { Token ! [ ; ](tokens_helper(_visitor, &(it).0)) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_macro2<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemMacro2) -> ItemMacro2 {
    ItemMacro2 {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        macro_token: Token ! [ macro ](tokens_helper(_visitor, &(_i . macro_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
        args: _i . args,
        brace_token: Brace(tokens_helper(_visitor, &(_i . brace_token).0)),
        body: _i . body,
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_mod<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemMod) -> ItemMod {
    ItemMod {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        mod_token: Token ! [ mod ](tokens_helper(_visitor, &(_i . mod_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        content: (_i . content).map(|it| { (
            Brace(tokens_helper(_visitor, &(( it ) . 0).0)),
            FoldHelper::lift(( it ) . 1, |it| { _visitor.fold_item(it) }),
        ) }),
        semi: (_i . semi).map(|it| { Token ! [ ; ](tokens_helper(_visitor, &(it).0)) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_static<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemStatic) -> ItemStatic {
    ItemStatic {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        static_token: Token ! [ static ](tokens_helper(_visitor, &(_i . static_token).0)),
        mutability: (_i . mutability).map(|it| { Token ! [ mut ](tokens_helper(_visitor, &(it).0)) }),
        ident: _visitor.fold_ident(_i . ident),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &(_i . colon_token).0)),
        ty: Box::new(_visitor.fold_type(* _i . ty)),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &(_i . eq_token).0)),
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_struct<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemStruct) -> ItemStruct {
    ItemStruct {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        struct_token: Token ! [ struct ](tokens_helper(_visitor, &(_i . struct_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        generics: _visitor.fold_generics(_i . generics),
        fields: _visitor.fold_fields(_i . fields),
        semi_token: (_i . semi_token).map(|it| { Token ! [ ; ](tokens_helper(_visitor, &(it).0)) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_trait<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemTrait) -> ItemTrait {
    ItemTrait {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        unsafety: (_i . unsafety).map(|it| { Token ! [ unsafe ](tokens_helper(_visitor, &(it).0)) }),
        auto_token: (_i . auto_token).map(|it| { Token ! [ auto ](tokens_helper(_visitor, &(it).0)) }),
        trait_token: Token ! [ trait ](tokens_helper(_visitor, &(_i . trait_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        generics: _visitor.fold_generics(_i . generics),
        colon_token: (_i . colon_token).map(|it| { Token ! [ : ](tokens_helper(_visitor, &(it).0)) }),
        supertraits: FoldHelper::lift(_i . supertraits, |it| { _visitor.fold_type_param_bound(it) }),
        brace_token: Brace(tokens_helper(_visitor, &(_i . brace_token).0)),
        items: FoldHelper::lift(_i . items, |it| { _visitor.fold_trait_item(it) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_type<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemType) -> ItemType {
    ItemType {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        type_token: Token ! [ type ](tokens_helper(_visitor, &(_i . type_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        generics: _visitor.fold_generics(_i . generics),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &(_i . eq_token).0)),
        ty: Box::new(_visitor.fold_type(* _i . ty)),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_union<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemUnion) -> ItemUnion {
    ItemUnion {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        union_token: Token ! [ union ](tokens_helper(_visitor, &(_i . union_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        generics: _visitor.fold_generics(_i . generics),
        fields: _visitor.fold_fields_named(_i . fields),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_use<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemUse) -> ItemUse {
    ItemUse {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        vis: _visitor.fold_visibility(_i . vis),
        use_token: Token ! [ use ](tokens_helper(_visitor, &(_i . use_token).0)),
        leading_colon: (_i . leading_colon).map(|it| { Token ! [ :: ](tokens_helper(_visitor, &(it).0)) }),
        tree: _visitor.fold_use_tree(_i . tree),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_item_verbatim<V: Fold + ?Sized>(_visitor: &mut V, _i: ItemVerbatim) -> ItemVerbatim {
    ItemVerbatim {
        tts: _i . tts,
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
pub fn fold_label<V: Fold + ?Sized>(_visitor: &mut V, _i: Label) -> Label {
    Label {
        name: _visitor.fold_lifetime(_i . name),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &(_i . colon_token).0)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_lifetime_def<V: Fold + ?Sized>(_visitor: &mut V, _i: LifetimeDef) -> LifetimeDef {
    LifetimeDef {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        lifetime: _visitor.fold_lifetime(_i . lifetime),
        colon_token: (_i . colon_token).map(|it| { Token ! [ : ](tokens_helper(_visitor, &(it).0)) }),
        bounds: FoldHelper::lift(_i . bounds, |it| { _visitor.fold_lifetime(it) }),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_lit<V: Fold + ?Sized>(_visitor: &mut V, _i: Lit) -> Lit {
    match _i {
        Lit::Str(_binding_0, ) => {
            Lit::Str (
                _visitor.fold_lit_str(_binding_0),
            )
        }
        Lit::ByteStr(_binding_0, ) => {
            Lit::ByteStr (
                _visitor.fold_lit_byte_str(_binding_0),
            )
        }
        Lit::Byte(_binding_0, ) => {
            Lit::Byte (
                _visitor.fold_lit_byte(_binding_0),
            )
        }
        Lit::Char(_binding_0, ) => {
            Lit::Char (
                _visitor.fold_lit_char(_binding_0),
            )
        }
        Lit::Int(_binding_0, ) => {
            Lit::Int (
                _visitor.fold_lit_int(_binding_0),
            )
        }
        Lit::Float(_binding_0, ) => {
            Lit::Float (
                _visitor.fold_lit_float(_binding_0),
            )
        }
        Lit::Bool(_binding_0, ) => {
            Lit::Bool (
                _visitor.fold_lit_bool(_binding_0),
            )
        }
        Lit::Verbatim(_binding_0, ) => {
            Lit::Verbatim (
                _visitor.fold_lit_verbatim(_binding_0),
            )
        }
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_lit_bool<V: Fold + ?Sized>(_visitor: &mut V, _i: LitBool) -> LitBool {
    LitBool {
        value: _i . value,
        span: _visitor.fold_span(_i . span),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_lit_verbatim<V: Fold + ?Sized>(_visitor: &mut V, _i: LitVerbatim) -> LitVerbatim {
    LitVerbatim {
        token: _i . token,
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
pub fn fold_local<V: Fold + ?Sized>(_visitor: &mut V, _i: Local) -> Local {
    Local {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        let_token: Token ! [ let ](tokens_helper(_visitor, &(_i . let_token).0)),
        pats: FoldHelper::lift(_i . pats, |it| { _visitor.fold_pat(it) }),
        ty: (_i . ty).map(|it| { (
            Token ! [ : ](tokens_helper(_visitor, &(( it ) . 0).0)),
            Box::new(_visitor.fold_type(* ( it ) . 1)),
        ) }),
        init: (_i . init).map(|it| { (
            Token ! [ = ](tokens_helper(_visitor, &(( it ) . 0).0)),
            Box::new(_visitor.fold_expr(* ( it ) . 1)),
        ) }),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_macro<V: Fold + ?Sized>(_visitor: &mut V, _i: Macro) -> Macro {
    Macro {
        path: _visitor.fold_path(_i . path),
        bang_token: Token ! [ ! ](tokens_helper(_visitor, &(_i . bang_token).0)),
        delimiter: _visitor.fold_macro_delimiter(_i . delimiter),
        tts: _i . tts,
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_macro_delimiter<V: Fold + ?Sized>(_visitor: &mut V, _i: MacroDelimiter) -> MacroDelimiter {
    match _i {
        MacroDelimiter::Paren(_binding_0, ) => {
            MacroDelimiter::Paren (
                Paren(tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        MacroDelimiter::Brace(_binding_0, ) => {
            MacroDelimiter::Brace (
                Brace(tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        MacroDelimiter::Bracket(_binding_0, ) => {
            MacroDelimiter::Bracket (
                Bracket(tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_member<V: Fold + ?Sized>(_visitor: &mut V, _i: Member) -> Member {
    match _i {
        Member::Named(_binding_0, ) => {
            Member::Named (
                _visitor.fold_ident(_binding_0),
            )
        }
        Member::Unnamed(_binding_0, ) => {
            Member::Unnamed (
                _visitor.fold_index(_binding_0),
            )
        }
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_meta<V: Fold + ?Sized>(_visitor: &mut V, _i: Meta) -> Meta {
    match _i {
        Meta::Word(_binding_0, ) => {
            Meta::Word (
                _visitor.fold_ident(_binding_0),
            )
        }
        Meta::List(_binding_0, ) => {
            Meta::List (
                _visitor.fold_meta_list(_binding_0),
            )
        }
        Meta::NameValue(_binding_0, ) => {
            Meta::NameValue (
                _visitor.fold_meta_name_value(_binding_0),
            )
        }
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_meta_list<V: Fold + ?Sized>(_visitor: &mut V, _i: MetaList) -> MetaList {
    MetaList {
        ident: _visitor.fold_ident(_i . ident),
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
        nested: FoldHelper::lift(_i . nested, |it| { _visitor.fold_nested_meta(it) }),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_meta_name_value<V: Fold + ?Sized>(_visitor: &mut V, _i: MetaNameValue) -> MetaNameValue {
    MetaNameValue {
        ident: _visitor.fold_ident(_i . ident),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &(_i . eq_token).0)),
        lit: _visitor.fold_lit(_i . lit),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_method_sig<V: Fold + ?Sized>(_visitor: &mut V, _i: MethodSig) -> MethodSig {
    MethodSig {
        constness: (_i . constness).map(|it| { Token ! [ const ](tokens_helper(_visitor, &(it).0)) }),
        unsafety: (_i . unsafety).map(|it| { Token ! [ unsafe ](tokens_helper(_visitor, &(it).0)) }),
        abi: (_i . abi).map(|it| { _visitor.fold_abi(it) }),
        ident: _visitor.fold_ident(_i . ident),
        decl: _visitor.fold_fn_decl(_i . decl),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
pub fn fold_method_turbofish<V: Fold + ?Sized>(_visitor: &mut V, _i: MethodTurbofish) -> MethodTurbofish {
    MethodTurbofish {
        colon2_token: Token ! [ :: ](tokens_helper(_visitor, &(_i . colon2_token).0)),
        lt_token: Token ! [ < ](tokens_helper(_visitor, &(_i . lt_token).0)),
        args: FoldHelper::lift(_i . args, |it| { _visitor.fold_generic_method_argument(it) }),
        gt_token: Token ! [ > ](tokens_helper(_visitor, &(_i . gt_token).0)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_nested_meta<V: Fold + ?Sized>(_visitor: &mut V, _i: NestedMeta) -> NestedMeta {
    match _i {
        NestedMeta::Meta(_binding_0, ) => {
            NestedMeta::Meta (
                _visitor.fold_meta(_binding_0),
            )
        }
        NestedMeta::Literal(_binding_0, ) => {
            NestedMeta::Literal (
                _visitor.fold_lit(_binding_0),
            )
        }
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_parenthesized_generic_arguments<V: Fold + ?Sized>(_visitor: &mut V, _i: ParenthesizedGenericArguments) -> ParenthesizedGenericArguments {
    ParenthesizedGenericArguments {
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
        inputs: FoldHelper::lift(_i . inputs, |it| { _visitor.fold_type(it) }),
        output: _visitor.fold_return_type(_i . output),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
pub fn fold_pat<V: Fold + ?Sized>(_visitor: &mut V, _i: Pat) -> Pat {
    match _i {
        Pat::Wild(_binding_0, ) => {
            Pat::Wild (
                _visitor.fold_pat_wild(_binding_0),
            )
        }
        Pat::Ident(_binding_0, ) => {
            Pat::Ident (
                _visitor.fold_pat_ident(_binding_0),
            )
        }
        Pat::Struct(_binding_0, ) => {
            Pat::Struct (
                _visitor.fold_pat_struct(_binding_0),
            )
        }
        Pat::TupleStruct(_binding_0, ) => {
            Pat::TupleStruct (
                _visitor.fold_pat_tuple_struct(_binding_0),
            )
        }
        Pat::Path(_binding_0, ) => {
            Pat::Path (
                _visitor.fold_pat_path(_binding_0),
            )
        }
        Pat::Tuple(_binding_0, ) => {
            Pat::Tuple (
                _visitor.fold_pat_tuple(_binding_0),
            )
        }
        Pat::Box(_binding_0, ) => {
            Pat::Box (
                _visitor.fold_pat_box(_binding_0),
            )
        }
        Pat::Ref(_binding_0, ) => {
            Pat::Ref (
                _visitor.fold_pat_ref(_binding_0),
            )
        }
        Pat::Lit(_binding_0, ) => {
            Pat::Lit (
                _visitor.fold_pat_lit(_binding_0),
            )
        }
        Pat::Range(_binding_0, ) => {
            Pat::Range (
                _visitor.fold_pat_range(_binding_0),
            )
        }
        Pat::Slice(_binding_0, ) => {
            Pat::Slice (
                _visitor.fold_pat_slice(_binding_0),
            )
        }
        Pat::Macro(_binding_0, ) => {
            Pat::Macro (
                _visitor.fold_pat_macro(_binding_0),
            )
        }
        Pat::Verbatim(_binding_0, ) => {
            Pat::Verbatim (
                _visitor.fold_pat_verbatim(_binding_0),
            )
        }
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
pub fn fold_pat_box<V: Fold + ?Sized>(_visitor: &mut V, _i: PatBox) -> PatBox {
    PatBox {
        box_token: Token ! [ box ](tokens_helper(_visitor, &(_i . box_token).0)),
        pat: Box::new(_visitor.fold_pat(* _i . pat)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
pub fn fold_pat_ident<V: Fold + ?Sized>(_visitor: &mut V, _i: PatIdent) -> PatIdent {
    PatIdent {
        by_ref: (_i . by_ref).map(|it| { Token ! [ ref ](tokens_helper(_visitor, &(it).0)) }),
        mutability: (_i . mutability).map(|it| { Token ! [ mut ](tokens_helper(_visitor, &(it).0)) }),
        ident: _visitor.fold_ident(_i . ident),
        subpat: (_i . subpat).map(|it| { (
            Token ! [ @ ](tokens_helper(_visitor, &(( it ) . 0).0)),
            Box::new(_visitor.fold_pat(* ( it ) . 1)),
        ) }),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
pub fn fold_pat_lit<V: Fold + ?Sized>(_visitor: &mut V, _i: PatLit) -> PatLit {
    PatLit {
        expr: Box::new(_visitor.fold_expr(* _i . expr)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
pub fn fold_pat_macro<V: Fold + ?Sized>(_visitor: &mut V, _i: PatMacro) -> PatMacro {
    PatMacro {
        mac: _visitor.fold_macro(_i . mac),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
pub fn fold_pat_path<V: Fold + ?Sized>(_visitor: &mut V, _i: PatPath) -> PatPath {
    PatPath {
        qself: (_i . qself).map(|it| { _visitor.fold_qself(it) }),
        path: _visitor.fold_path(_i . path),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
pub fn fold_pat_range<V: Fold + ?Sized>(_visitor: &mut V, _i: PatRange) -> PatRange {
    PatRange {
        lo: Box::new(_visitor.fold_expr(* _i . lo)),
        limits: _visitor.fold_range_limits(_i . limits),
        hi: Box::new(_visitor.fold_expr(* _i . hi)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
pub fn fold_pat_ref<V: Fold + ?Sized>(_visitor: &mut V, _i: PatRef) -> PatRef {
    PatRef {
        and_token: Token ! [ & ](tokens_helper(_visitor, &(_i . and_token).0)),
        mutability: (_i . mutability).map(|it| { Token ! [ mut ](tokens_helper(_visitor, &(it).0)) }),
        pat: Box::new(_visitor.fold_pat(* _i . pat)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
pub fn fold_pat_slice<V: Fold + ?Sized>(_visitor: &mut V, _i: PatSlice) -> PatSlice {
    PatSlice {
        bracket_token: Bracket(tokens_helper(_visitor, &(_i . bracket_token).0)),
        front: FoldHelper::lift(_i . front, |it| { _visitor.fold_pat(it) }),
        middle: (_i . middle).map(|it| { Box::new(_visitor.fold_pat(* it)) }),
        dot2_token: (_i . dot2_token).map(|it| { Token ! [ .. ](tokens_helper(_visitor, &(it).0)) }),
        comma_token: (_i . comma_token).map(|it| { Token ! [ , ](tokens_helper(_visitor, &(it).0)) }),
        back: FoldHelper::lift(_i . back, |it| { _visitor.fold_pat(it) }),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
pub fn fold_pat_struct<V: Fold + ?Sized>(_visitor: &mut V, _i: PatStruct) -> PatStruct {
    PatStruct {
        path: _visitor.fold_path(_i . path),
        brace_token: Brace(tokens_helper(_visitor, &(_i . brace_token).0)),
        fields: FoldHelper::lift(_i . fields, |it| { _visitor.fold_field_pat(it) }),
        dot2_token: (_i . dot2_token).map(|it| { Token ! [ .. ](tokens_helper(_visitor, &(it).0)) }),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
pub fn fold_pat_tuple<V: Fold + ?Sized>(_visitor: &mut V, _i: PatTuple) -> PatTuple {
    PatTuple {
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
        front: FoldHelper::lift(_i . front, |it| { _visitor.fold_pat(it) }),
        dot2_token: (_i . dot2_token).map(|it| { Token ! [ .. ](tokens_helper(_visitor, &(it).0)) }),
        comma_token: (_i . comma_token).map(|it| { Token ! [ , ](tokens_helper(_visitor, &(it).0)) }),
        back: FoldHelper::lift(_i . back, |it| { _visitor.fold_pat(it) }),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
pub fn fold_pat_tuple_struct<V: Fold + ?Sized>(_visitor: &mut V, _i: PatTupleStruct) -> PatTupleStruct {
    PatTupleStruct {
        path: _visitor.fold_path(_i . path),
        pat: _visitor.fold_pat_tuple(_i . pat),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
pub fn fold_pat_verbatim<V: Fold + ?Sized>(_visitor: &mut V, _i: PatVerbatim) -> PatVerbatim {
    PatVerbatim {
        tts: _i . tts,
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
pub fn fold_pat_wild<V: Fold + ?Sized>(_visitor: &mut V, _i: PatWild) -> PatWild {
    PatWild {
        underscore_token: Token ! [ _ ](tokens_helper(_visitor, &(_i . underscore_token).0)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_path<V: Fold + ?Sized>(_visitor: &mut V, _i: Path) -> Path {
    Path {
        leading_colon: (_i . leading_colon).map(|it| { Token ! [ :: ](tokens_helper(_visitor, &(it).0)) }),
        segments: FoldHelper::lift(_i . segments, |it| { _visitor.fold_path_segment(it) }),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_path_arguments<V: Fold + ?Sized>(_visitor: &mut V, _i: PathArguments) -> PathArguments {
    match _i {
        PathArguments::None => { PathArguments::None }
        PathArguments::AngleBracketed(_binding_0, ) => {
            PathArguments::AngleBracketed (
                _visitor.fold_angle_bracketed_generic_arguments(_binding_0),
            )
        }
        PathArguments::Parenthesized(_binding_0, ) => {
            PathArguments::Parenthesized (
                _visitor.fold_parenthesized_generic_arguments(_binding_0),
            )
        }
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_path_segment<V: Fold + ?Sized>(_visitor: &mut V, _i: PathSegment) -> PathSegment {
    PathSegment {
        ident: _visitor.fold_ident(_i . ident),
        arguments: _visitor.fold_path_arguments(_i . arguments),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_predicate_eq<V: Fold + ?Sized>(_visitor: &mut V, _i: PredicateEq) -> PredicateEq {
    PredicateEq {
        lhs_ty: _visitor.fold_type(_i . lhs_ty),
        eq_token: Token ! [ = ](tokens_helper(_visitor, &(_i . eq_token).0)),
        rhs_ty: _visitor.fold_type(_i . rhs_ty),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_predicate_lifetime<V: Fold + ?Sized>(_visitor: &mut V, _i: PredicateLifetime) -> PredicateLifetime {
    PredicateLifetime {
        lifetime: _visitor.fold_lifetime(_i . lifetime),
        colon_token: (_i . colon_token).map(|it| { Token ! [ : ](tokens_helper(_visitor, &(it).0)) }),
        bounds: FoldHelper::lift(_i . bounds, |it| { _visitor.fold_lifetime(it) }),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_predicate_type<V: Fold + ?Sized>(_visitor: &mut V, _i: PredicateType) -> PredicateType {
    PredicateType {
        lifetimes: (_i . lifetimes).map(|it| { _visitor.fold_bound_lifetimes(it) }),
        bounded_ty: _visitor.fold_type(_i . bounded_ty),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &(_i . colon_token).0)),
        bounds: FoldHelper::lift(_i . bounds, |it| { _visitor.fold_type_param_bound(it) }),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_qself<V: Fold + ?Sized>(_visitor: &mut V, _i: QSelf) -> QSelf {
    QSelf {
        lt_token: Token ! [ < ](tokens_helper(_visitor, &(_i . lt_token).0)),
        ty: Box::new(_visitor.fold_type(* _i . ty)),
        position: _i . position,
        as_token: (_i . as_token).map(|it| { Token ! [ as ](tokens_helper(_visitor, &(it).0)) }),
        gt_token: Token ! [ > ](tokens_helper(_visitor, &(_i . gt_token).0)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
pub fn fold_range_limits<V: Fold + ?Sized>(_visitor: &mut V, _i: RangeLimits) -> RangeLimits {
    match _i {
        RangeLimits::HalfOpen(_binding_0, ) => {
            RangeLimits::HalfOpen (
                Token ! [ .. ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        RangeLimits::Closed(_binding_0, ) => {
            RangeLimits::Closed (
                Token ! [ ..= ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_return_type<V: Fold + ?Sized>(_visitor: &mut V, _i: ReturnType) -> ReturnType {
    match _i {
        ReturnType::Default => { ReturnType::Default }
        ReturnType::Type(_binding_0, _binding_1, ) => {
            ReturnType::Type (
                Token ! [ -> ](tokens_helper(_visitor, &(_binding_0).0)),
                Box::new(_visitor.fold_type(* _binding_1)),
            )
        }
    }
}

pub fn fold_span<V: Fold + ?Sized>(_visitor: &mut V, _i: Span) -> Span {
    _i
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ] # [ cfg ( feature = "full" ) ]
pub fn fold_stmt<V: Fold + ?Sized>(_visitor: &mut V, _i: Stmt) -> Stmt {
    match _i {
        Stmt::Local(_binding_0, ) => {
            Stmt::Local (
                _visitor.fold_local(_binding_0),
            )
        }
        Stmt::Item(_binding_0, ) => {
            Stmt::Item (
                _visitor.fold_item(_binding_0),
            )
        }
        Stmt::Expr(_binding_0, ) => {
            Stmt::Expr (
                _visitor.fold_expr(_binding_0),
            )
        }
        Stmt::Semi(_binding_0, _binding_1, ) => {
            Stmt::Semi (
                _visitor.fold_expr(_binding_0),
                Token ! [ ; ](tokens_helper(_visitor, &(_binding_1).0)),
            )
        }
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_trait_bound<V: Fold + ?Sized>(_visitor: &mut V, _i: TraitBound) -> TraitBound {
    TraitBound {
        paren_token: (_i . paren_token).map(|it| { Paren(tokens_helper(_visitor, &(it).0)) }),
        modifier: _visitor.fold_trait_bound_modifier(_i . modifier),
        lifetimes: (_i . lifetimes).map(|it| { _visitor.fold_bound_lifetimes(it) }),
        path: _visitor.fold_path(_i . path),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_trait_bound_modifier<V: Fold + ?Sized>(_visitor: &mut V, _i: TraitBoundModifier) -> TraitBoundModifier {
    match _i {
        TraitBoundModifier::None => { TraitBoundModifier::None }
        TraitBoundModifier::Maybe(_binding_0, ) => {
            TraitBoundModifier::Maybe (
                Token ! [ ? ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_trait_item<V: Fold + ?Sized>(_visitor: &mut V, _i: TraitItem) -> TraitItem {
    match _i {
        TraitItem::Const(_binding_0, ) => {
            TraitItem::Const (
                _visitor.fold_trait_item_const(_binding_0),
            )
        }
        TraitItem::Method(_binding_0, ) => {
            TraitItem::Method (
                _visitor.fold_trait_item_method(_binding_0),
            )
        }
        TraitItem::Type(_binding_0, ) => {
            TraitItem::Type (
                _visitor.fold_trait_item_type(_binding_0),
            )
        }
        TraitItem::Macro(_binding_0, ) => {
            TraitItem::Macro (
                _visitor.fold_trait_item_macro(_binding_0),
            )
        }
        TraitItem::Verbatim(_binding_0, ) => {
            TraitItem::Verbatim (
                _visitor.fold_trait_item_verbatim(_binding_0),
            )
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_trait_item_const<V: Fold + ?Sized>(_visitor: &mut V, _i: TraitItemConst) -> TraitItemConst {
    TraitItemConst {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        const_token: Token ! [ const ](tokens_helper(_visitor, &(_i . const_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        colon_token: Token ! [ : ](tokens_helper(_visitor, &(_i . colon_token).0)),
        ty: _visitor.fold_type(_i . ty),
        default: (_i . default).map(|it| { (
            Token ! [ = ](tokens_helper(_visitor, &(( it ) . 0).0)),
            _visitor.fold_expr(( it ) . 1),
        ) }),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_trait_item_macro<V: Fold + ?Sized>(_visitor: &mut V, _i: TraitItemMacro) -> TraitItemMacro {
    TraitItemMacro {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        mac: _visitor.fold_macro(_i . mac),
        semi_token: (_i . semi_token).map(|it| { Token ! [ ; ](tokens_helper(_visitor, &(it).0)) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_trait_item_method<V: Fold + ?Sized>(_visitor: &mut V, _i: TraitItemMethod) -> TraitItemMethod {
    TraitItemMethod {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        sig: _visitor.fold_method_sig(_i . sig),
        default: (_i . default).map(|it| { _visitor.fold_block(it) }),
        semi_token: (_i . semi_token).map(|it| { Token ! [ ; ](tokens_helper(_visitor, &(it).0)) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_trait_item_type<V: Fold + ?Sized>(_visitor: &mut V, _i: TraitItemType) -> TraitItemType {
    TraitItemType {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        type_token: Token ! [ type ](tokens_helper(_visitor, &(_i . type_token).0)),
        ident: _visitor.fold_ident(_i . ident),
        generics: _visitor.fold_generics(_i . generics),
        colon_token: (_i . colon_token).map(|it| { Token ! [ : ](tokens_helper(_visitor, &(it).0)) }),
        bounds: FoldHelper::lift(_i . bounds, |it| { _visitor.fold_type_param_bound(it) }),
        default: (_i . default).map(|it| { (
            Token ! [ = ](tokens_helper(_visitor, &(( it ) . 0).0)),
            _visitor.fold_type(( it ) . 1),
        ) }),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_trait_item_verbatim<V: Fold + ?Sized>(_visitor: &mut V, _i: TraitItemVerbatim) -> TraitItemVerbatim {
    TraitItemVerbatim {
        tts: _i . tts,
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_type<V: Fold + ?Sized>(_visitor: &mut V, _i: Type) -> Type {
    match _i {
        Type::Slice(_binding_0, ) => {
            Type::Slice (
                _visitor.fold_type_slice(_binding_0),
            )
        }
        Type::Array(_binding_0, ) => {
            Type::Array (
                _visitor.fold_type_array(_binding_0),
            )
        }
        Type::Ptr(_binding_0, ) => {
            Type::Ptr (
                _visitor.fold_type_ptr(_binding_0),
            )
        }
        Type::Reference(_binding_0, ) => {
            Type::Reference (
                _visitor.fold_type_reference(_binding_0),
            )
        }
        Type::BareFn(_binding_0, ) => {
            Type::BareFn (
                _visitor.fold_type_bare_fn(_binding_0),
            )
        }
        Type::Never(_binding_0, ) => {
            Type::Never (
                _visitor.fold_type_never(_binding_0),
            )
        }
        Type::Tuple(_binding_0, ) => {
            Type::Tuple (
                _visitor.fold_type_tuple(_binding_0),
            )
        }
        Type::Path(_binding_0, ) => {
            Type::Path (
                _visitor.fold_type_path(_binding_0),
            )
        }
        Type::TraitObject(_binding_0, ) => {
            Type::TraitObject (
                _visitor.fold_type_trait_object(_binding_0),
            )
        }
        Type::ImplTrait(_binding_0, ) => {
            Type::ImplTrait (
                _visitor.fold_type_impl_trait(_binding_0),
            )
        }
        Type::Paren(_binding_0, ) => {
            Type::Paren (
                _visitor.fold_type_paren(_binding_0),
            )
        }
        Type::Group(_binding_0, ) => {
            Type::Group (
                _visitor.fold_type_group(_binding_0),
            )
        }
        Type::Infer(_binding_0, ) => {
            Type::Infer (
                _visitor.fold_type_infer(_binding_0),
            )
        }
        Type::Macro(_binding_0, ) => {
            Type::Macro (
                _visitor.fold_type_macro(_binding_0),
            )
        }
        Type::Verbatim(_binding_0, ) => {
            Type::Verbatim (
                _visitor.fold_type_verbatim(_binding_0),
            )
        }
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_type_array<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeArray) -> TypeArray {
    TypeArray {
        bracket_token: Bracket(tokens_helper(_visitor, &(_i . bracket_token).0)),
        elem: Box::new(_visitor.fold_type(* _i . elem)),
        semi_token: Token ! [ ; ](tokens_helper(_visitor, &(_i . semi_token).0)),
        len: _visitor.fold_expr(_i . len),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_type_bare_fn<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeBareFn) -> TypeBareFn {
    TypeBareFn {
        unsafety: (_i . unsafety).map(|it| { Token ! [ unsafe ](tokens_helper(_visitor, &(it).0)) }),
        abi: (_i . abi).map(|it| { _visitor.fold_abi(it) }),
        fn_token: Token ! [ fn ](tokens_helper(_visitor, &(_i . fn_token).0)),
        lifetimes: (_i . lifetimes).map(|it| { _visitor.fold_bound_lifetimes(it) }),
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
        inputs: FoldHelper::lift(_i . inputs, |it| { _visitor.fold_bare_fn_arg(it) }),
        variadic: (_i . variadic).map(|it| { Token ! [ ... ](tokens_helper(_visitor, &(it).0)) }),
        output: _visitor.fold_return_type(_i . output),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_type_group<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeGroup) -> TypeGroup {
    TypeGroup {
        group_token: Group(tokens_helper(_visitor, &(_i . group_token).0)),
        elem: Box::new(_visitor.fold_type(* _i . elem)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_type_impl_trait<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeImplTrait) -> TypeImplTrait {
    TypeImplTrait {
        impl_token: Token ! [ impl ](tokens_helper(_visitor, &(_i . impl_token).0)),
        bounds: FoldHelper::lift(_i . bounds, |it| { _visitor.fold_type_param_bound(it) }),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_type_infer<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeInfer) -> TypeInfer {
    TypeInfer {
        underscore_token: Token ! [ _ ](tokens_helper(_visitor, &(_i . underscore_token).0)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_type_macro<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeMacro) -> TypeMacro {
    TypeMacro {
        mac: _visitor.fold_macro(_i . mac),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_type_never<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeNever) -> TypeNever {
    TypeNever {
        bang_token: Token ! [ ! ](tokens_helper(_visitor, &(_i . bang_token).0)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_type_param<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeParam) -> TypeParam {
    TypeParam {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        ident: _visitor.fold_ident(_i . ident),
        colon_token: (_i . colon_token).map(|it| { Token ! [ : ](tokens_helper(_visitor, &(it).0)) }),
        bounds: FoldHelper::lift(_i . bounds, |it| { _visitor.fold_type_param_bound(it) }),
        eq_token: (_i . eq_token).map(|it| { Token ! [ = ](tokens_helper(_visitor, &(it).0)) }),
        default: (_i . default).map(|it| { _visitor.fold_type(it) }),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_type_param_bound<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeParamBound) -> TypeParamBound {
    match _i {
        TypeParamBound::Trait(_binding_0, ) => {
            TypeParamBound::Trait (
                _visitor.fold_trait_bound(_binding_0),
            )
        }
        TypeParamBound::Lifetime(_binding_0, ) => {
            TypeParamBound::Lifetime (
                _visitor.fold_lifetime(_binding_0),
            )
        }
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_type_paren<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeParen) -> TypeParen {
    TypeParen {
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
        elem: Box::new(_visitor.fold_type(* _i . elem)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_type_path<V: Fold + ?Sized>(_visitor: &mut V, _i: TypePath) -> TypePath {
    TypePath {
        qself: (_i . qself).map(|it| { _visitor.fold_qself(it) }),
        path: _visitor.fold_path(_i . path),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_type_ptr<V: Fold + ?Sized>(_visitor: &mut V, _i: TypePtr) -> TypePtr {
    TypePtr {
        star_token: Token ! [ * ](tokens_helper(_visitor, &(_i . star_token).0)),
        const_token: (_i . const_token).map(|it| { Token ! [ const ](tokens_helper(_visitor, &(it).0)) }),
        mutability: (_i . mutability).map(|it| { Token ! [ mut ](tokens_helper(_visitor, &(it).0)) }),
        elem: Box::new(_visitor.fold_type(* _i . elem)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_type_reference<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeReference) -> TypeReference {
    TypeReference {
        and_token: Token ! [ & ](tokens_helper(_visitor, &(_i . and_token).0)),
        lifetime: (_i . lifetime).map(|it| { _visitor.fold_lifetime(it) }),
        mutability: (_i . mutability).map(|it| { Token ! [ mut ](tokens_helper(_visitor, &(it).0)) }),
        elem: Box::new(_visitor.fold_type(* _i . elem)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_type_slice<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeSlice) -> TypeSlice {
    TypeSlice {
        bracket_token: Bracket(tokens_helper(_visitor, &(_i . bracket_token).0)),
        elem: Box::new(_visitor.fold_type(* _i . elem)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_type_trait_object<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeTraitObject) -> TypeTraitObject {
    TypeTraitObject {
        dyn_token: (_i . dyn_token).map(|it| { Token ! [ dyn ](tokens_helper(_visitor, &(it).0)) }),
        bounds: FoldHelper::lift(_i . bounds, |it| { _visitor.fold_type_param_bound(it) }),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_type_tuple<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeTuple) -> TypeTuple {
    TypeTuple {
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
        elems: FoldHelper::lift(_i . elems, |it| { _visitor.fold_type(it) }),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_type_verbatim<V: Fold + ?Sized>(_visitor: &mut V, _i: TypeVerbatim) -> TypeVerbatim {
    TypeVerbatim {
        tts: _i . tts,
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_un_op<V: Fold + ?Sized>(_visitor: &mut V, _i: UnOp) -> UnOp {
    match _i {
        UnOp::Deref(_binding_0, ) => {
            UnOp::Deref (
                Token ! [ * ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        UnOp::Not(_binding_0, ) => {
            UnOp::Not (
                Token ! [ ! ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
        UnOp::Neg(_binding_0, ) => {
            UnOp::Neg (
                Token ! [ - ](tokens_helper(_visitor, &(_binding_0).0)),
            )
        }
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_use_glob<V: Fold + ?Sized>(_visitor: &mut V, _i: UseGlob) -> UseGlob {
    UseGlob {
        star_token: Token ! [ * ](tokens_helper(_visitor, &(_i . star_token).0)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_use_group<V: Fold + ?Sized>(_visitor: &mut V, _i: UseGroup) -> UseGroup {
    UseGroup {
        brace_token: Brace(tokens_helper(_visitor, &(_i . brace_token).0)),
        items: FoldHelper::lift(_i . items, |it| { _visitor.fold_use_tree(it) }),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_use_name<V: Fold + ?Sized>(_visitor: &mut V, _i: UseName) -> UseName {
    UseName {
        ident: _visitor.fold_ident(_i . ident),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_use_path<V: Fold + ?Sized>(_visitor: &mut V, _i: UsePath) -> UsePath {
    UsePath {
        ident: _visitor.fold_ident(_i . ident),
        colon2_token: Token ! [ :: ](tokens_helper(_visitor, &(_i . colon2_token).0)),
        tree: Box::new(_visitor.fold_use_tree(* _i . tree)),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_use_rename<V: Fold + ?Sized>(_visitor: &mut V, _i: UseRename) -> UseRename {
    UseRename {
        ident: _visitor.fold_ident(_i . ident),
        as_token: Token ! [ as ](tokens_helper(_visitor, &(_i . as_token).0)),
        rename: _visitor.fold_ident(_i . rename),
    }
}
# [ cfg ( feature = "full" ) ]
pub fn fold_use_tree<V: Fold + ?Sized>(_visitor: &mut V, _i: UseTree) -> UseTree {
    match _i {
        UseTree::Path(_binding_0, ) => {
            UseTree::Path (
                _visitor.fold_use_path(_binding_0),
            )
        }
        UseTree::Name(_binding_0, ) => {
            UseTree::Name (
                _visitor.fold_use_name(_binding_0),
            )
        }
        UseTree::Rename(_binding_0, ) => {
            UseTree::Rename (
                _visitor.fold_use_rename(_binding_0),
            )
        }
        UseTree::Glob(_binding_0, ) => {
            UseTree::Glob (
                _visitor.fold_use_glob(_binding_0),
            )
        }
        UseTree::Group(_binding_0, ) => {
            UseTree::Group (
                _visitor.fold_use_group(_binding_0),
            )
        }
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_variant<V: Fold + ?Sized>(_visitor: &mut V, _i: Variant) -> Variant {
    Variant {
        attrs: FoldHelper::lift(_i . attrs, |it| { _visitor.fold_attribute(it) }),
        ident: _visitor.fold_ident(_i . ident),
        fields: _visitor.fold_fields(_i . fields),
        discriminant: (_i . discriminant).map(|it| { (
            Token ! [ = ](tokens_helper(_visitor, &(( it ) . 0).0)),
            _visitor.fold_expr(( it ) . 1),
        ) }),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_vis_crate<V: Fold + ?Sized>(_visitor: &mut V, _i: VisCrate) -> VisCrate {
    VisCrate {
        crate_token: Token ! [ crate ](tokens_helper(_visitor, &(_i . crate_token).0)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_vis_public<V: Fold + ?Sized>(_visitor: &mut V, _i: VisPublic) -> VisPublic {
    VisPublic {
        pub_token: Token ! [ pub ](tokens_helper(_visitor, &(_i . pub_token).0)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_vis_restricted<V: Fold + ?Sized>(_visitor: &mut V, _i: VisRestricted) -> VisRestricted {
    VisRestricted {
        pub_token: Token ! [ pub ](tokens_helper(_visitor, &(_i . pub_token).0)),
        paren_token: Paren(tokens_helper(_visitor, &(_i . paren_token).0)),
        in_token: (_i . in_token).map(|it| { Token ! [ in ](tokens_helper(_visitor, &(it).0)) }),
        path: Box::new(_visitor.fold_path(* _i . path)),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_visibility<V: Fold + ?Sized>(_visitor: &mut V, _i: Visibility) -> Visibility {
    match _i {
        Visibility::Public(_binding_0, ) => {
            Visibility::Public (
                _visitor.fold_vis_public(_binding_0),
            )
        }
        Visibility::Crate(_binding_0, ) => {
            Visibility::Crate (
                _visitor.fold_vis_crate(_binding_0),
            )
        }
        Visibility::Restricted(_binding_0, ) => {
            Visibility::Restricted (
                _visitor.fold_vis_restricted(_binding_0),
            )
        }
        Visibility::Inherited => { Visibility::Inherited }
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_where_clause<V: Fold + ?Sized>(_visitor: &mut V, _i: WhereClause) -> WhereClause {
    WhereClause {
        where_token: Token ! [ where ](tokens_helper(_visitor, &(_i . where_token).0)),
        predicates: FoldHelper::lift(_i . predicates, |it| { _visitor.fold_where_predicate(it) }),
    }
}
# [ cfg ( any ( feature = "full" , feature = "derive" ) ) ]
pub fn fold_where_predicate<V: Fold + ?Sized>(_visitor: &mut V, _i: WherePredicate) -> WherePredicate {
    match _i {
        WherePredicate::Type(_binding_0, ) => {
            WherePredicate::Type (
                _visitor.fold_predicate_type(_binding_0),
            )
        }
        WherePredicate::Lifetime(_binding_0, ) => {
            WherePredicate::Lifetime (
                _visitor.fold_predicate_lifetime(_binding_0),
            )
        }
        WherePredicate::Eq(_binding_0, ) => {
            WherePredicate::Eq (
                _visitor.fold_predicate_eq(_binding_0),
            )
        }
    }
}

