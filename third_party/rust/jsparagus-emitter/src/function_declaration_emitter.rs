use crate::ast_emitter::AstEmitter;
use crate::emitter::EmitError;
use crate::function::{FunctionCreationData, FunctionFlags};
use crate::gcthings::GCThingIndex;
use ast::source_atom_set::SourceAtomSetIndex;

/// Create a dummy function with empty script, to implement
/// FunctionDeclarationEmitter without implementing FunctionScriptEmitter.
pub struct DummyFunctionScriptEmitter {
    pub name: SourceAtomSetIndex,
}

impl DummyFunctionScriptEmitter {
    pub fn emit(self, emitter: &mut AstEmitter) -> Result<GCThingIndex, EmitError> {
        let script_index = emitter.with_inner(|_emitter| {
            Err(EmitError::NotImplemented("TODO: FunctionDeclaration"))

            // The following implementing is just a dummy to pass the
            // emitter part.  The generated bytecode is completely wrong.
            //
            // Uncomment the following to check the behavior of
            // FunctionDeclarationEmitter in the enclosing script.
            /*
            let scope_data_map = &emitter.compilation_info.scope_data_map;
            emitter
            .scope_stack
            .enter_global(&mut emitter.emit, scope_data_map);

            emitter.emit.undefined();
            emitter.emit.set_rval();
            emitter.emit.ret_rval();

            emitter.scope_stack.leave_global(&mut emitter.emit);

            Ok(())
             */
        })?;

        let fun_data = FunctionCreationData::non_lazy(
            Some(self.name),
            script_index,
            FunctionFlags::interpreted_normal(),
        );

        Ok(emitter.emit.get_function_gcthing_index(fun_data))
    }
}

pub struct FunctionDeclarationEmitter {
    pub fun: GCThingIndex,
}

impl FunctionDeclarationEmitter {
    pub fn emit(self, emitter: &mut AstEmitter) {
        emitter.emit.lambda(self.fun);
        emitter.emit.def_fun();
    }
}
