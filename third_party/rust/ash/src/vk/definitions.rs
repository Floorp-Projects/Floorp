use crate::vk::aliases::*;
use crate::vk::bitflags::*;
use crate::vk::constants::*;
use crate::vk::enums::*;
use crate::vk::native::*;
use crate::vk::platform_types::*;
use crate::vk::prelude::*;
use crate::vk::{ptr_chain_iter, Handle};
use std::fmt;
use std::os::raw::*;
#[deprecated = "This define is deprecated. VK_MAKE_API_VERSION should be used instead."]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_MAKE_VERSION.html>"]
pub const fn make_version(major: u32, minor: u32, patch: u32) -> u32 {
    ((major) << 22) | ((minor) << 12) | (patch)
}
#[deprecated = "This define is deprecated. VK_API_VERSION_MAJOR should be used instead."]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_VERSION_MAJOR.html>"]
pub const fn version_major(version: u32) -> u32 {
    (version) >> 22
}
#[deprecated = "This define is deprecated. VK_API_VERSION_MINOR should be used instead."]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_VERSION_MINOR.html>"]
pub const fn version_minor(version: u32) -> u32 {
    ((version) >> 12) & 0x3ffu32
}
#[deprecated = "This define is deprecated. VK_API_VERSION_PATCH should be used instead."]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_VERSION_PATCH.html>"]
pub const fn version_patch(version: u32) -> u32 {
    (version) & 0xfffu32
}
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_MAKE_API_VERSION.html>"]
pub const fn make_api_version(variant: u32, major: u32, minor: u32, patch: u32) -> u32 {
    ((variant) << 29) | ((major) << 22) | ((minor) << 12) | (patch)
}
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_API_VERSION_VARIANT.html>"]
pub const fn api_version_variant(version: u32) -> u32 {
    (version) >> 29
}
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_API_VERSION_MAJOR.html>"]
pub const fn api_version_major(version: u32) -> u32 {
    ((version) >> 22) & 0x7fu32
}
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_API_VERSION_MINOR.html>"]
pub const fn api_version_minor(version: u32) -> u32 {
    ((version) >> 12) & 0x3ffu32
}
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_API_VERSION_PATCH.html>"]
pub const fn api_version_patch(version: u32) -> u32 {
    (version) & 0xfffu32
}
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_API_VERSION_1_0.html>"]
pub const API_VERSION_1_0: u32 = make_api_version(0, 1, 0, 0);
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_API_VERSION_1_1.html>"]
pub const API_VERSION_1_1: u32 = make_api_version(0, 1, 1, 0);
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_API_VERSION_1_2.html>"]
pub const API_VERSION_1_2: u32 = make_api_version(0, 1, 2, 0);
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_API_VERSION_1_3.html>"]
pub const API_VERSION_1_3: u32 = make_api_version(0, 1, 3, 0);
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_HEADER_VERSION.html>"]
pub const HEADER_VERSION: u32 = 251;
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_HEADER_VERSION_COMPLETE.html>"]
pub const HEADER_VERSION_COMPLETE: u32 = make_api_version(0, 1, 3, HEADER_VERSION);
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampleMask.html>"]
pub type SampleMask = u32;
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBool32.html>"]
pub type Bool32 = u32;
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFlags.html>"]
pub type Flags = u32;
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFlags64.html>"]
pub type Flags64 = u64;
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceSize.html>"]
pub type DeviceSize = u64;
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceAddress.html>"]
pub type DeviceAddress = u64;
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPoolCreateFlags.html>"]
pub struct QueryPoolCreateFlags(pub(crate) Flags);
vk_bitflags_wrapped!(QueryPoolCreateFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDynamicStateCreateFlags.html>"]
pub struct PipelineDynamicStateCreateFlags(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineDynamicStateCreateFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineMultisampleStateCreateFlags.html>"]
pub struct PipelineMultisampleStateCreateFlags(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineMultisampleStateCreateFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateCreateFlags.html>"]
pub struct PipelineRasterizationStateCreateFlags(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineRasterizationStateCreateFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportStateCreateFlags.html>"]
pub struct PipelineViewportStateCreateFlags(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineViewportStateCreateFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineTessellationStateCreateFlags.html>"]
pub struct PipelineTessellationStateCreateFlags(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineTessellationStateCreateFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineInputAssemblyStateCreateFlags.html>"]
pub struct PipelineInputAssemblyStateCreateFlags(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineInputAssemblyStateCreateFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineVertexInputStateCreateFlags.html>"]
pub struct PipelineVertexInputStateCreateFlags(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineVertexInputStateCreateFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferViewCreateFlags.html>"]
pub struct BufferViewCreateFlags(pub(crate) Flags);
vk_bitflags_wrapped!(BufferViewCreateFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceCreateFlags.html>"]
pub struct DeviceCreateFlags(pub(crate) Flags);
vk_bitflags_wrapped!(DeviceCreateFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryMapFlags.html>"]
pub struct MemoryMapFlags(pub(crate) Flags);
vk_bitflags_wrapped!(MemoryMapFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolResetFlags.html>"]
pub struct DescriptorPoolResetFlags(pub(crate) Flags);
vk_bitflags_wrapped!(DescriptorPoolResetFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorUpdateTemplateCreateFlags.html>"]
pub struct DescriptorUpdateTemplateCreateFlags(pub(crate) Flags);
vk_bitflags_wrapped!(DescriptorUpdateTemplateCreateFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureMotionInfoFlagsNV.html>"]
pub struct AccelerationStructureMotionInfoFlagsNV(pub(crate) Flags);
vk_bitflags_wrapped!(AccelerationStructureMotionInfoFlagsNV, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureMotionInstanceFlagsNV.html>"]
pub struct AccelerationStructureMotionInstanceFlagsNV(pub(crate) Flags);
vk_bitflags_wrapped!(AccelerationStructureMotionInstanceFlagsNV, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDirectDriverLoadingFlagsLUNARG.html>"]
pub struct DirectDriverLoadingFlagsLUNARG(pub(crate) Flags);
vk_bitflags_wrapped!(DirectDriverLoadingFlagsLUNARG, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModeCreateFlagsKHR.html>"]
pub struct DisplayModeCreateFlagsKHR(pub(crate) Flags);
vk_bitflags_wrapped!(DisplayModeCreateFlagsKHR, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplaySurfaceCreateFlagsKHR.html>"]
pub struct DisplaySurfaceCreateFlagsKHR(pub(crate) Flags);
vk_bitflags_wrapped!(DisplaySurfaceCreateFlagsKHR, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAndroidSurfaceCreateFlagsKHR.html>"]
pub struct AndroidSurfaceCreateFlagsKHR(pub(crate) Flags);
vk_bitflags_wrapped!(AndroidSurfaceCreateFlagsKHR, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkViSurfaceCreateFlagsNN.html>"]
pub struct ViSurfaceCreateFlagsNN(pub(crate) Flags);
vk_bitflags_wrapped!(ViSurfaceCreateFlagsNN, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWaylandSurfaceCreateFlagsKHR.html>"]
pub struct WaylandSurfaceCreateFlagsKHR(pub(crate) Flags);
vk_bitflags_wrapped!(WaylandSurfaceCreateFlagsKHR, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWin32SurfaceCreateFlagsKHR.html>"]
pub struct Win32SurfaceCreateFlagsKHR(pub(crate) Flags);
vk_bitflags_wrapped!(Win32SurfaceCreateFlagsKHR, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkXlibSurfaceCreateFlagsKHR.html>"]
pub struct XlibSurfaceCreateFlagsKHR(pub(crate) Flags);
vk_bitflags_wrapped!(XlibSurfaceCreateFlagsKHR, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkXcbSurfaceCreateFlagsKHR.html>"]
pub struct XcbSurfaceCreateFlagsKHR(pub(crate) Flags);
vk_bitflags_wrapped!(XcbSurfaceCreateFlagsKHR, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDirectFBSurfaceCreateFlagsEXT.html>"]
pub struct DirectFBSurfaceCreateFlagsEXT(pub(crate) Flags);
vk_bitflags_wrapped!(DirectFBSurfaceCreateFlagsEXT, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkIOSSurfaceCreateFlagsMVK.html>"]
pub struct IOSSurfaceCreateFlagsMVK(pub(crate) Flags);
vk_bitflags_wrapped!(IOSSurfaceCreateFlagsMVK, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMacOSSurfaceCreateFlagsMVK.html>"]
pub struct MacOSSurfaceCreateFlagsMVK(pub(crate) Flags);
vk_bitflags_wrapped!(MacOSSurfaceCreateFlagsMVK, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMetalSurfaceCreateFlagsEXT.html>"]
pub struct MetalSurfaceCreateFlagsEXT(pub(crate) Flags);
vk_bitflags_wrapped!(MetalSurfaceCreateFlagsEXT, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImagePipeSurfaceCreateFlagsFUCHSIA.html>"]
pub struct ImagePipeSurfaceCreateFlagsFUCHSIA(pub(crate) Flags);
vk_bitflags_wrapped!(ImagePipeSurfaceCreateFlagsFUCHSIA, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStreamDescriptorSurfaceCreateFlagsGGP.html>"]
pub struct StreamDescriptorSurfaceCreateFlagsGGP(pub(crate) Flags);
vk_bitflags_wrapped!(StreamDescriptorSurfaceCreateFlagsGGP, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkHeadlessSurfaceCreateFlagsEXT.html>"]
pub struct HeadlessSurfaceCreateFlagsEXT(pub(crate) Flags);
vk_bitflags_wrapped!(HeadlessSurfaceCreateFlagsEXT, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkScreenSurfaceCreateFlagsQNX.html>"]
pub struct ScreenSurfaceCreateFlagsQNX(pub(crate) Flags);
vk_bitflags_wrapped!(ScreenSurfaceCreateFlagsQNX, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolTrimFlags.html>"]
pub struct CommandPoolTrimFlags(pub(crate) Flags);
vk_bitflags_wrapped!(CommandPoolTrimFlags, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportSwizzleStateCreateFlagsNV.html>"]
pub struct PipelineViewportSwizzleStateCreateFlagsNV(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineViewportSwizzleStateCreateFlagsNV, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDiscardRectangleStateCreateFlagsEXT.html>"]
pub struct PipelineDiscardRectangleStateCreateFlagsEXT(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineDiscardRectangleStateCreateFlagsEXT, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCoverageToColorStateCreateFlagsNV.html>"]
pub struct PipelineCoverageToColorStateCreateFlagsNV(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineCoverageToColorStateCreateFlagsNV, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCoverageModulationStateCreateFlagsNV.html>"]
pub struct PipelineCoverageModulationStateCreateFlagsNV(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineCoverageModulationStateCreateFlagsNV, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCoverageReductionStateCreateFlagsNV.html>"]
pub struct PipelineCoverageReductionStateCreateFlagsNV(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineCoverageReductionStateCreateFlagsNV, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkValidationCacheCreateFlagsEXT.html>"]
pub struct ValidationCacheCreateFlagsEXT(pub(crate) Flags);
vk_bitflags_wrapped!(ValidationCacheCreateFlagsEXT, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateFlagsEXT.html>"]
pub struct DebugUtilsMessengerCreateFlagsEXT(pub(crate) Flags);
vk_bitflags_wrapped!(DebugUtilsMessengerCreateFlagsEXT, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCallbackDataFlagsEXT.html>"]
pub struct DebugUtilsMessengerCallbackDataFlagsEXT(pub(crate) Flags);
vk_bitflags_wrapped!(DebugUtilsMessengerCallbackDataFlagsEXT, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceMemoryReportFlagsEXT.html>"]
pub struct DeviceMemoryReportFlagsEXT(pub(crate) Flags);
vk_bitflags_wrapped!(DeviceMemoryReportFlagsEXT, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationConservativeStateCreateFlagsEXT.html>"]
pub struct PipelineRasterizationConservativeStateCreateFlagsEXT(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineRasterizationConservativeStateCreateFlagsEXT, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateStreamCreateFlagsEXT.html>"]
pub struct PipelineRasterizationStateStreamCreateFlagsEXT(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineRasterizationStateStreamCreateFlagsEXT, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationDepthClipStateCreateFlagsEXT.html>"]
pub struct PipelineRasterizationDepthClipStateCreateFlagsEXT(pub(crate) Flags);
vk_bitflags_wrapped!(PipelineRasterizationDepthClipStateCreateFlagsEXT, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoSessionParametersCreateFlagsKHR.html>"]
pub struct VideoSessionParametersCreateFlagsKHR(pub(crate) Flags);
vk_bitflags_wrapped!(VideoSessionParametersCreateFlagsKHR, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoBeginCodingFlagsKHR.html>"]
pub struct VideoBeginCodingFlagsKHR(pub(crate) Flags);
vk_bitflags_wrapped!(VideoBeginCodingFlagsKHR, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEndCodingFlagsKHR.html>"]
pub struct VideoEndCodingFlagsKHR(pub(crate) Flags);
vk_bitflags_wrapped!(VideoEndCodingFlagsKHR, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeFlagsKHR.html>"]
pub struct VideoDecodeFlagsKHR(pub(crate) Flags);
vk_bitflags_wrapped!(VideoDecodeFlagsKHR, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeFlagsKHR.html>"]
pub struct VideoEncodeFlagsKHR(pub(crate) Flags);
vk_bitflags_wrapped!(VideoEncodeFlagsKHR, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeRateControlFlagsKHR.html>"]
pub struct VideoEncodeRateControlFlagsKHR(pub(crate) Flags);
vk_bitflags_wrapped!(VideoEncodeRateControlFlagsKHR, Flags);
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryUnmapFlagsKHR.html>"]
pub struct MemoryUnmapFlagsKHR(pub(crate) Flags);
vk_bitflags_wrapped!(MemoryUnmapFlagsKHR, Flags);
define_handle!(
    Instance,
    INSTANCE,
    doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInstance.html>"
);
define_handle ! (PhysicalDevice , PHYSICAL_DEVICE , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html>") ;
define_handle!(
    Device,
    DEVICE,
    doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDevice.html>"
);
define_handle!(
    Queue,
    QUEUE,
    doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueue.html>"
);
define_handle ! (CommandBuffer , COMMAND_BUFFER , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBuffer.html>") ;
handle_nondispatchable ! (DeviceMemory , DEVICE_MEMORY , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceMemory.html>") ;
handle_nondispatchable ! (CommandPool , COMMAND_POOL , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPool.html>") ;
handle_nondispatchable!(
    Buffer,
    BUFFER,
    doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBuffer.html>"
);
handle_nondispatchable!(
    BufferView,
    BUFFER_VIEW,
    doc =
        "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferView.html>"
);
handle_nondispatchable!(
    Image,
    IMAGE,
    doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImage.html>"
);
handle_nondispatchable!(
    ImageView,
    IMAGE_VIEW,
    doc =
        "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageView.html>"
);
handle_nondispatchable ! (ShaderModule , SHADER_MODULE , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html>") ;
handle_nondispatchable!(
    Pipeline,
    PIPELINE,
    doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipeline.html>"
);
handle_nondispatchable ! (PipelineLayout , PIPELINE_LAYOUT , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineLayout.html>") ;
handle_nondispatchable!(
    Sampler,
    SAMPLER,
    doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampler.html>"
);
handle_nondispatchable ! (DescriptorSet , DESCRIPTOR_SET , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSet.html>") ;
handle_nondispatchable ! (DescriptorSetLayout , DESCRIPTOR_SET_LAYOUT , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayout.html>") ;
handle_nondispatchable ! (DescriptorPool , DESCRIPTOR_POOL , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPool.html>") ;
handle_nondispatchable!(
    Fence,
    FENCE,
    doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFence.html>"
);
handle_nondispatchable!(
    Semaphore,
    SEMAPHORE,
    doc =
        "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphore.html>"
);
handle_nondispatchable!(
    Event,
    EVENT,
    doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkEvent.html>"
);
handle_nondispatchable!(
    QueryPool,
    QUERY_POOL,
    doc =
        "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPool.html>"
);
handle_nondispatchable ! (Framebuffer , FRAMEBUFFER , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebuffer.html>") ;
handle_nondispatchable!(
    RenderPass,
    RENDER_PASS,
    doc =
        "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPass.html>"
);
handle_nondispatchable ! (PipelineCache , PIPELINE_CACHE , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCache.html>") ;
handle_nondispatchable ! (IndirectCommandsLayoutNV , INDIRECT_COMMANDS_LAYOUT_NV , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkIndirectCommandsLayoutNV.html>") ;
handle_nondispatchable ! (DescriptorUpdateTemplate , DESCRIPTOR_UPDATE_TEMPLATE , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorUpdateTemplate.html>") ;
handle_nondispatchable ! (SamplerYcbcrConversion , SAMPLER_YCBCR_CONVERSION , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerYcbcrConversion.html>") ;
handle_nondispatchable ! (ValidationCacheEXT , VALIDATION_CACHE_EXT , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkValidationCacheEXT.html>") ;
handle_nondispatchable ! (AccelerationStructureKHR , ACCELERATION_STRUCTURE_KHR , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureKHR.html>") ;
handle_nondispatchable ! (AccelerationStructureNV , ACCELERATION_STRUCTURE_NV , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureNV.html>") ;
handle_nondispatchable ! (PerformanceConfigurationINTEL , PERFORMANCE_CONFIGURATION_INTEL , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceConfigurationINTEL.html>") ;
handle_nondispatchable ! (BufferCollectionFUCHSIA , BUFFER_COLLECTION_FUCHSIA , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCollectionFUCHSIA.html>") ;
handle_nondispatchable ! (DeferredOperationKHR , DEFERRED_OPERATION_KHR , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeferredOperationKHR.html>") ;
handle_nondispatchable ! (PrivateDataSlot , PRIVATE_DATA_SLOT , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPrivateDataSlot.html>") ;
handle_nondispatchable ! (CuModuleNVX , CU_MODULE_NVX , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCuModuleNVX.html>") ;
handle_nondispatchable ! (CuFunctionNVX , CU_FUNCTION_NVX , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCuFunctionNVX.html>") ;
handle_nondispatchable ! (OpticalFlowSessionNV , OPTICAL_FLOW_SESSION_NV , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOpticalFlowSessionNV.html>") ;
handle_nondispatchable ! (MicromapEXT , MICROMAP_EXT , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMicromapEXT.html>") ;
handle_nondispatchable!(
    ShaderEXT,
    SHADER_EXT,
    doc =
        "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderEXT.html>"
);
handle_nondispatchable!(
    DisplayKHR,
    DISPLAY_KHR,
    doc =
        "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayKHR.html>"
);
handle_nondispatchable ! (DisplayModeKHR , DISPLAY_MODE_KHR , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModeKHR.html>") ;
handle_nondispatchable!(
    SurfaceKHR,
    SURFACE_KHR,
    doc =
        "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html>"
);
handle_nondispatchable ! (SwapchainKHR , SWAPCHAIN_KHR , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainKHR.html>") ;
handle_nondispatchable ! (DebugReportCallbackEXT , DEBUG_REPORT_CALLBACK_EXT , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugReportCallbackEXT.html>") ;
handle_nondispatchable ! (DebugUtilsMessengerEXT , DEBUG_UTILS_MESSENGER_EXT , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerEXT.html>") ;
handle_nondispatchable ! (VideoSessionKHR , VIDEO_SESSION_KHR , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoSessionKHR.html>") ;
handle_nondispatchable ! (VideoSessionParametersKHR , VIDEO_SESSION_PARAMETERS_KHR , doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoSessionParametersKHR.html>") ;
#[allow(non_camel_case_types)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkInternalAllocationNotification.html>"]
pub type PFN_vkInternalAllocationNotification = Option<
    unsafe extern "system" fn(
        p_user_data: *mut c_void,
        size: usize,
        allocation_type: InternalAllocationType,
        allocation_scope: SystemAllocationScope,
    ),
>;
#[allow(non_camel_case_types)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkInternalFreeNotification.html>"]
pub type PFN_vkInternalFreeNotification = Option<
    unsafe extern "system" fn(
        p_user_data: *mut c_void,
        size: usize,
        allocation_type: InternalAllocationType,
        allocation_scope: SystemAllocationScope,
    ),
>;
#[allow(non_camel_case_types)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkReallocationFunction.html>"]
pub type PFN_vkReallocationFunction = Option<
    unsafe extern "system" fn(
        p_user_data: *mut c_void,
        p_original: *mut c_void,
        size: usize,
        alignment: usize,
        allocation_scope: SystemAllocationScope,
    ) -> *mut c_void,
>;
#[allow(non_camel_case_types)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkAllocationFunction.html>"]
pub type PFN_vkAllocationFunction = Option<
    unsafe extern "system" fn(
        p_user_data: *mut c_void,
        size: usize,
        alignment: usize,
        allocation_scope: SystemAllocationScope,
    ) -> *mut c_void,
>;
#[allow(non_camel_case_types)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkFreeFunction.html>"]
pub type PFN_vkFreeFunction =
    Option<unsafe extern "system" fn(p_user_data: *mut c_void, p_memory: *mut c_void)>;
#[allow(non_camel_case_types)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkVoidFunction.html>"]
pub type PFN_vkVoidFunction = Option<unsafe extern "system" fn()>;
#[allow(non_camel_case_types)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkDebugReportCallbackEXT.html>"]
pub type PFN_vkDebugReportCallbackEXT = Option<
    unsafe extern "system" fn(
        flags: DebugReportFlagsEXT,
        object_type: DebugReportObjectTypeEXT,
        object: u64,
        location: usize,
        message_code: i32,
        p_layer_prefix: *const c_char,
        p_message: *const c_char,
        p_user_data: *mut c_void,
    ) -> Bool32,
>;
#[allow(non_camel_case_types)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkDebugUtilsMessengerCallbackEXT.html>"]
pub type PFN_vkDebugUtilsMessengerCallbackEXT = Option<
    unsafe extern "system" fn(
        message_severity: DebugUtilsMessageSeverityFlagsEXT,
        message_types: DebugUtilsMessageTypeFlagsEXT,
        p_callback_data: *const DebugUtilsMessengerCallbackDataEXT,
        p_user_data: *mut c_void,
    ) -> Bool32,
>;
#[allow(non_camel_case_types)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkDeviceMemoryReportCallbackEXT.html>"]
pub type PFN_vkDeviceMemoryReportCallbackEXT = Option<
    unsafe extern "system" fn(
        p_callback_data: *const DeviceMemoryReportCallbackDataEXT,
        p_user_data: *mut c_void,
    ),
>;
#[allow(non_camel_case_types)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkGetInstanceProcAddrLUNARG.html>"]
pub type PFN_vkGetInstanceProcAddrLUNARG = Option<
    unsafe extern "system" fn(instance: Instance, p_name: *const c_char) -> PFN_vkVoidFunction,
>;
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBaseOutStructure.html>"]
pub struct BaseOutStructure {
    pub s_type: StructureType,
    pub p_next: *mut Self,
}
impl ::std::default::Default for BaseOutStructure {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: unsafe { ::std::mem::zeroed() },
            p_next: ::std::ptr::null_mut(),
        }
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBaseInStructure.html>"]
pub struct BaseInStructure {
    pub s_type: StructureType,
    pub p_next: *const Self,
}
impl ::std::default::Default for BaseInStructure {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: unsafe { ::std::mem::zeroed() },
            p_next: ::std::ptr::null(),
        }
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOffset2D.html>"]
pub struct Offset2D {
    pub x: i32,
    pub y: i32,
}
impl Offset2D {
    pub fn builder<'a>() -> Offset2DBuilder<'a> {
        Offset2DBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct Offset2DBuilder<'a> {
    inner: Offset2D,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for Offset2DBuilder<'a> {
    type Target = Offset2D;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for Offset2DBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> Offset2DBuilder<'a> {
    #[inline]
    pub fn x(mut self, x: i32) -> Self {
        self.inner.x = x;
        self
    }
    #[inline]
    pub fn y(mut self, y: i32) -> Self {
        self.inner.y = y;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> Offset2D {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOffset3D.html>"]
pub struct Offset3D {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
impl Offset3D {
    pub fn builder<'a>() -> Offset3DBuilder<'a> {
        Offset3DBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct Offset3DBuilder<'a> {
    inner: Offset3D,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for Offset3DBuilder<'a> {
    type Target = Offset3D;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for Offset3DBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> Offset3DBuilder<'a> {
    #[inline]
    pub fn x(mut self, x: i32) -> Self {
        self.inner.x = x;
        self
    }
    #[inline]
    pub fn y(mut self, y: i32) -> Self {
        self.inner.y = y;
        self
    }
    #[inline]
    pub fn z(mut self, z: i32) -> Self {
        self.inner.z = z;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> Offset3D {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExtent2D.html>"]
pub struct Extent2D {
    pub width: u32,
    pub height: u32,
}
impl Extent2D {
    pub fn builder<'a>() -> Extent2DBuilder<'a> {
        Extent2DBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct Extent2DBuilder<'a> {
    inner: Extent2D,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for Extent2DBuilder<'a> {
    type Target = Extent2D;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for Extent2DBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> Extent2DBuilder<'a> {
    #[inline]
    pub fn width(mut self, width: u32) -> Self {
        self.inner.width = width;
        self
    }
    #[inline]
    pub fn height(mut self, height: u32) -> Self {
        self.inner.height = height;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> Extent2D {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExtent3D.html>"]
pub struct Extent3D {
    pub width: u32,
    pub height: u32,
    pub depth: u32,
}
impl Extent3D {
    pub fn builder<'a>() -> Extent3DBuilder<'a> {
        Extent3DBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct Extent3DBuilder<'a> {
    inner: Extent3D,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for Extent3DBuilder<'a> {
    type Target = Extent3D;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for Extent3DBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> Extent3DBuilder<'a> {
    #[inline]
    pub fn width(mut self, width: u32) -> Self {
        self.inner.width = width;
        self
    }
    #[inline]
    pub fn height(mut self, height: u32) -> Self {
        self.inner.height = height;
        self
    }
    #[inline]
    pub fn depth(mut self, depth: u32) -> Self {
        self.inner.depth = depth;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> Extent3D {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkViewport.html>"]
pub struct Viewport {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
    pub min_depth: f32,
    pub max_depth: f32,
}
impl Viewport {
    pub fn builder<'a>() -> ViewportBuilder<'a> {
        ViewportBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ViewportBuilder<'a> {
    inner: Viewport,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ViewportBuilder<'a> {
    type Target = Viewport;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ViewportBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ViewportBuilder<'a> {
    #[inline]
    pub fn x(mut self, x: f32) -> Self {
        self.inner.x = x;
        self
    }
    #[inline]
    pub fn y(mut self, y: f32) -> Self {
        self.inner.y = y;
        self
    }
    #[inline]
    pub fn width(mut self, width: f32) -> Self {
        self.inner.width = width;
        self
    }
    #[inline]
    pub fn height(mut self, height: f32) -> Self {
        self.inner.height = height;
        self
    }
    #[inline]
    pub fn min_depth(mut self, min_depth: f32) -> Self {
        self.inner.min_depth = min_depth;
        self
    }
    #[inline]
    pub fn max_depth(mut self, max_depth: f32) -> Self {
        self.inner.max_depth = max_depth;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> Viewport {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRect2D.html>"]
pub struct Rect2D {
    pub offset: Offset2D,
    pub extent: Extent2D,
}
impl Rect2D {
    pub fn builder<'a>() -> Rect2DBuilder<'a> {
        Rect2DBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct Rect2DBuilder<'a> {
    inner: Rect2D,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for Rect2DBuilder<'a> {
    type Target = Rect2D;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for Rect2DBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> Rect2DBuilder<'a> {
    #[inline]
    pub fn offset(mut self, offset: Offset2D) -> Self {
        self.inner.offset = offset;
        self
    }
    #[inline]
    pub fn extent(mut self, extent: Extent2D) -> Self {
        self.inner.extent = extent;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> Rect2D {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearRect.html>"]
pub struct ClearRect {
    pub rect: Rect2D,
    pub base_array_layer: u32,
    pub layer_count: u32,
}
impl ClearRect {
    pub fn builder<'a>() -> ClearRectBuilder<'a> {
        ClearRectBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ClearRectBuilder<'a> {
    inner: ClearRect,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ClearRectBuilder<'a> {
    type Target = ClearRect;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ClearRectBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ClearRectBuilder<'a> {
    #[inline]
    pub fn rect(mut self, rect: Rect2D) -> Self {
        self.inner.rect = rect;
        self
    }
    #[inline]
    pub fn base_array_layer(mut self, base_array_layer: u32) -> Self {
        self.inner.base_array_layer = base_array_layer;
        self
    }
    #[inline]
    pub fn layer_count(mut self, layer_count: u32) -> Self {
        self.inner.layer_count = layer_count;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ClearRect {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkComponentMapping.html>"]
pub struct ComponentMapping {
    pub r: ComponentSwizzle,
    pub g: ComponentSwizzle,
    pub b: ComponentSwizzle,
    pub a: ComponentSwizzle,
}
impl ComponentMapping {
    pub fn builder<'a>() -> ComponentMappingBuilder<'a> {
        ComponentMappingBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ComponentMappingBuilder<'a> {
    inner: ComponentMapping,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ComponentMappingBuilder<'a> {
    type Target = ComponentMapping;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ComponentMappingBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ComponentMappingBuilder<'a> {
    #[inline]
    pub fn r(mut self, r: ComponentSwizzle) -> Self {
        self.inner.r = r;
        self
    }
    #[inline]
    pub fn g(mut self, g: ComponentSwizzle) -> Self {
        self.inner.g = g;
        self
    }
    #[inline]
    pub fn b(mut self, b: ComponentSwizzle) -> Self {
        self.inner.b = b;
        self
    }
    #[inline]
    pub fn a(mut self, a: ComponentSwizzle) -> Self {
        self.inner.a = a;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ComponentMapping {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProperties.html>"]
pub struct PhysicalDeviceProperties {
    pub api_version: u32,
    pub driver_version: u32,
    pub vendor_id: u32,
    pub device_id: u32,
    pub device_type: PhysicalDeviceType,
    pub device_name: [c_char; MAX_PHYSICAL_DEVICE_NAME_SIZE],
    pub pipeline_cache_uuid: [u8; UUID_SIZE],
    pub limits: PhysicalDeviceLimits,
    pub sparse_properties: PhysicalDeviceSparseProperties,
}
#[cfg(feature = "debug")]
impl fmt::Debug for PhysicalDeviceProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceProperties")
            .field("api_version", &self.api_version)
            .field("driver_version", &self.driver_version)
            .field("vendor_id", &self.vendor_id)
            .field("device_id", &self.device_id)
            .field("device_type", &self.device_type)
            .field("device_name", &unsafe {
                ::std::ffi::CStr::from_ptr(self.device_name.as_ptr())
            })
            .field("pipeline_cache_uuid", &self.pipeline_cache_uuid)
            .field("limits", &self.limits)
            .field("sparse_properties", &self.sparse_properties)
            .finish()
    }
}
impl ::std::default::Default for PhysicalDeviceProperties {
    #[inline]
    fn default() -> Self {
        Self {
            api_version: u32::default(),
            driver_version: u32::default(),
            vendor_id: u32::default(),
            device_id: u32::default(),
            device_type: PhysicalDeviceType::default(),
            device_name: unsafe { ::std::mem::zeroed() },
            pipeline_cache_uuid: unsafe { ::std::mem::zeroed() },
            limits: PhysicalDeviceLimits::default(),
            sparse_properties: PhysicalDeviceSparseProperties::default(),
        }
    }
}
impl PhysicalDeviceProperties {
    pub fn builder<'a>() -> PhysicalDevicePropertiesBuilder<'a> {
        PhysicalDevicePropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevicePropertiesBuilder<'a> {
    inner: PhysicalDeviceProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PhysicalDevicePropertiesBuilder<'a> {
    type Target = PhysicalDeviceProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevicePropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevicePropertiesBuilder<'a> {
    #[inline]
    pub fn api_version(mut self, api_version: u32) -> Self {
        self.inner.api_version = api_version;
        self
    }
    #[inline]
    pub fn driver_version(mut self, driver_version: u32) -> Self {
        self.inner.driver_version = driver_version;
        self
    }
    #[inline]
    pub fn vendor_id(mut self, vendor_id: u32) -> Self {
        self.inner.vendor_id = vendor_id;
        self
    }
    #[inline]
    pub fn device_id(mut self, device_id: u32) -> Self {
        self.inner.device_id = device_id;
        self
    }
    #[inline]
    pub fn device_type(mut self, device_type: PhysicalDeviceType) -> Self {
        self.inner.device_type = device_type;
        self
    }
    #[inline]
    pub fn device_name(mut self, device_name: [c_char; MAX_PHYSICAL_DEVICE_NAME_SIZE]) -> Self {
        self.inner.device_name = device_name;
        self
    }
    #[inline]
    pub fn pipeline_cache_uuid(mut self, pipeline_cache_uuid: [u8; UUID_SIZE]) -> Self {
        self.inner.pipeline_cache_uuid = pipeline_cache_uuid;
        self
    }
    #[inline]
    pub fn limits(mut self, limits: PhysicalDeviceLimits) -> Self {
        self.inner.limits = limits;
        self
    }
    #[inline]
    pub fn sparse_properties(mut self, sparse_properties: PhysicalDeviceSparseProperties) -> Self {
        self.inner.sparse_properties = sparse_properties;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceProperties {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExtensionProperties.html>"]
pub struct ExtensionProperties {
    pub extension_name: [c_char; MAX_EXTENSION_NAME_SIZE],
    pub spec_version: u32,
}
#[cfg(feature = "debug")]
impl fmt::Debug for ExtensionProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ExtensionProperties")
            .field("extension_name", &unsafe {
                ::std::ffi::CStr::from_ptr(self.extension_name.as_ptr())
            })
            .field("spec_version", &self.spec_version)
            .finish()
    }
}
impl ::std::default::Default for ExtensionProperties {
    #[inline]
    fn default() -> Self {
        Self {
            extension_name: unsafe { ::std::mem::zeroed() },
            spec_version: u32::default(),
        }
    }
}
impl ExtensionProperties {
    pub fn builder<'a>() -> ExtensionPropertiesBuilder<'a> {
        ExtensionPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExtensionPropertiesBuilder<'a> {
    inner: ExtensionProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ExtensionPropertiesBuilder<'a> {
    type Target = ExtensionProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExtensionPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExtensionPropertiesBuilder<'a> {
    #[inline]
    pub fn extension_name(mut self, extension_name: [c_char; MAX_EXTENSION_NAME_SIZE]) -> Self {
        self.inner.extension_name = extension_name;
        self
    }
    #[inline]
    pub fn spec_version(mut self, spec_version: u32) -> Self {
        self.inner.spec_version = spec_version;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExtensionProperties {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkLayerProperties.html>"]
pub struct LayerProperties {
    pub layer_name: [c_char; MAX_EXTENSION_NAME_SIZE],
    pub spec_version: u32,
    pub implementation_version: u32,
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
}
#[cfg(feature = "debug")]
impl fmt::Debug for LayerProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("LayerProperties")
            .field("layer_name", &unsafe {
                ::std::ffi::CStr::from_ptr(self.layer_name.as_ptr())
            })
            .field("spec_version", &self.spec_version)
            .field("implementation_version", &self.implementation_version)
            .field("description", &unsafe {
                ::std::ffi::CStr::from_ptr(self.description.as_ptr())
            })
            .finish()
    }
}
impl ::std::default::Default for LayerProperties {
    #[inline]
    fn default() -> Self {
        Self {
            layer_name: unsafe { ::std::mem::zeroed() },
            spec_version: u32::default(),
            implementation_version: u32::default(),
            description: unsafe { ::std::mem::zeroed() },
        }
    }
}
impl LayerProperties {
    pub fn builder<'a>() -> LayerPropertiesBuilder<'a> {
        LayerPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct LayerPropertiesBuilder<'a> {
    inner: LayerProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for LayerPropertiesBuilder<'a> {
    type Target = LayerProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for LayerPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> LayerPropertiesBuilder<'a> {
    #[inline]
    pub fn layer_name(mut self, layer_name: [c_char; MAX_EXTENSION_NAME_SIZE]) -> Self {
        self.inner.layer_name = layer_name;
        self
    }
    #[inline]
    pub fn spec_version(mut self, spec_version: u32) -> Self {
        self.inner.spec_version = spec_version;
        self
    }
    #[inline]
    pub fn implementation_version(mut self, implementation_version: u32) -> Self {
        self.inner.implementation_version = implementation_version;
        self
    }
    #[inline]
    pub fn description(mut self, description: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.inner.description = description;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> LayerProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkApplicationInfo.html>"]
pub struct ApplicationInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_application_name: *const c_char,
    pub application_version: u32,
    pub p_engine_name: *const c_char,
    pub engine_version: u32,
    pub api_version: u32,
}
impl ::std::default::Default for ApplicationInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_application_name: ::std::ptr::null(),
            application_version: u32::default(),
            p_engine_name: ::std::ptr::null(),
            engine_version: u32::default(),
            api_version: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for ApplicationInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::APPLICATION_INFO;
}
impl ApplicationInfo {
    pub fn builder<'a>() -> ApplicationInfoBuilder<'a> {
        ApplicationInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ApplicationInfoBuilder<'a> {
    inner: ApplicationInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ApplicationInfoBuilder<'a> {
    type Target = ApplicationInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ApplicationInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ApplicationInfoBuilder<'a> {
    #[inline]
    pub fn application_name(mut self, application_name: &'a ::std::ffi::CStr) -> Self {
        self.inner.p_application_name = application_name.as_ptr();
        self
    }
    #[inline]
    pub fn application_version(mut self, application_version: u32) -> Self {
        self.inner.application_version = application_version;
        self
    }
    #[inline]
    pub fn engine_name(mut self, engine_name: &'a ::std::ffi::CStr) -> Self {
        self.inner.p_engine_name = engine_name.as_ptr();
        self
    }
    #[inline]
    pub fn engine_version(mut self, engine_version: u32) -> Self {
        self.inner.engine_version = engine_version;
        self
    }
    #[inline]
    pub fn api_version(mut self, api_version: u32) -> Self {
        self.inner.api_version = api_version;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ApplicationInfo {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAllocationCallbacks.html>"]
pub struct AllocationCallbacks {
    pub p_user_data: *mut c_void,
    pub pfn_allocation: PFN_vkAllocationFunction,
    pub pfn_reallocation: PFN_vkReallocationFunction,
    pub pfn_free: PFN_vkFreeFunction,
    pub pfn_internal_allocation: PFN_vkInternalAllocationNotification,
    pub pfn_internal_free: PFN_vkInternalFreeNotification,
}
#[cfg(feature = "debug")]
impl fmt::Debug for AllocationCallbacks {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AllocationCallbacks")
            .field("p_user_data", &self.p_user_data)
            .field(
                "pfn_allocation",
                &(self.pfn_allocation.map(|x| x as *const ())),
            )
            .field(
                "pfn_reallocation",
                &(self.pfn_reallocation.map(|x| x as *const ())),
            )
            .field("pfn_free", &(self.pfn_free.map(|x| x as *const ())))
            .field(
                "pfn_internal_allocation",
                &(self.pfn_internal_allocation.map(|x| x as *const ())),
            )
            .field(
                "pfn_internal_free",
                &(self.pfn_internal_free.map(|x| x as *const ())),
            )
            .finish()
    }
}
impl ::std::default::Default for AllocationCallbacks {
    #[inline]
    fn default() -> Self {
        Self {
            p_user_data: ::std::ptr::null_mut(),
            pfn_allocation: PFN_vkAllocationFunction::default(),
            pfn_reallocation: PFN_vkReallocationFunction::default(),
            pfn_free: PFN_vkFreeFunction::default(),
            pfn_internal_allocation: PFN_vkInternalAllocationNotification::default(),
            pfn_internal_free: PFN_vkInternalFreeNotification::default(),
        }
    }
}
impl AllocationCallbacks {
    pub fn builder<'a>() -> AllocationCallbacksBuilder<'a> {
        AllocationCallbacksBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AllocationCallbacksBuilder<'a> {
    inner: AllocationCallbacks,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for AllocationCallbacksBuilder<'a> {
    type Target = AllocationCallbacks;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AllocationCallbacksBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AllocationCallbacksBuilder<'a> {
    #[inline]
    pub fn user_data(mut self, user_data: *mut c_void) -> Self {
        self.inner.p_user_data = user_data;
        self
    }
    #[inline]
    pub fn pfn_allocation(mut self, pfn_allocation: PFN_vkAllocationFunction) -> Self {
        self.inner.pfn_allocation = pfn_allocation;
        self
    }
    #[inline]
    pub fn pfn_reallocation(mut self, pfn_reallocation: PFN_vkReallocationFunction) -> Self {
        self.inner.pfn_reallocation = pfn_reallocation;
        self
    }
    #[inline]
    pub fn pfn_free(mut self, pfn_free: PFN_vkFreeFunction) -> Self {
        self.inner.pfn_free = pfn_free;
        self
    }
    #[inline]
    pub fn pfn_internal_allocation(
        mut self,
        pfn_internal_allocation: PFN_vkInternalAllocationNotification,
    ) -> Self {
        self.inner.pfn_internal_allocation = pfn_internal_allocation;
        self
    }
    #[inline]
    pub fn pfn_internal_free(mut self, pfn_internal_free: PFN_vkInternalFreeNotification) -> Self {
        self.inner.pfn_internal_free = pfn_internal_free;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AllocationCallbacks {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateInfo.html>"]
pub struct DeviceQueueCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DeviceQueueCreateFlags,
    pub queue_family_index: u32,
    pub queue_count: u32,
    pub p_queue_priorities: *const f32,
}
impl ::std::default::Default for DeviceQueueCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DeviceQueueCreateFlags::default(),
            queue_family_index: u32::default(),
            queue_count: u32::default(),
            p_queue_priorities: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for DeviceQueueCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_QUEUE_CREATE_INFO;
}
impl DeviceQueueCreateInfo {
    pub fn builder<'a>() -> DeviceQueueCreateInfoBuilder<'a> {
        DeviceQueueCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceQueueCreateInfoBuilder<'a> {
    inner: DeviceQueueCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsDeviceQueueCreateInfo {}
impl<'a> ::std::ops::Deref for DeviceQueueCreateInfoBuilder<'a> {
    type Target = DeviceQueueCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceQueueCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceQueueCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: DeviceQueueCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn queue_family_index(mut self, queue_family_index: u32) -> Self {
        self.inner.queue_family_index = queue_family_index;
        self
    }
    #[inline]
    pub fn queue_priorities(mut self, queue_priorities: &'a [f32]) -> Self {
        self.inner.queue_count = queue_priorities.len() as _;
        self.inner.p_queue_priorities = queue_priorities.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsDeviceQueueCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceQueueCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceCreateInfo.html>"]
pub struct DeviceCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DeviceCreateFlags,
    pub queue_create_info_count: u32,
    pub p_queue_create_infos: *const DeviceQueueCreateInfo,
    #[deprecated = "functionality described by this member no longer operates"]
    pub enabled_layer_count: u32,
    #[deprecated = "functionality described by this member no longer operates"]
    pub pp_enabled_layer_names: *const *const c_char,
    pub enabled_extension_count: u32,
    pub pp_enabled_extension_names: *const *const c_char,
    pub p_enabled_features: *const PhysicalDeviceFeatures,
}
impl ::std::default::Default for DeviceCreateInfo {
    #[inline]
    fn default() -> Self {
        #[allow(deprecated)]
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DeviceCreateFlags::default(),
            queue_create_info_count: u32::default(),
            p_queue_create_infos: ::std::ptr::null(),
            enabled_layer_count: u32::default(),
            pp_enabled_layer_names: ::std::ptr::null(),
            enabled_extension_count: u32::default(),
            pp_enabled_extension_names: ::std::ptr::null(),
            p_enabled_features: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for DeviceCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_CREATE_INFO;
}
impl DeviceCreateInfo {
    pub fn builder<'a>() -> DeviceCreateInfoBuilder<'a> {
        DeviceCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceCreateInfoBuilder<'a> {
    inner: DeviceCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsDeviceCreateInfo {}
impl<'a> ::std::ops::Deref for DeviceCreateInfoBuilder<'a> {
    type Target = DeviceCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: DeviceCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn queue_create_infos(mut self, queue_create_infos: &'a [DeviceQueueCreateInfo]) -> Self {
        self.inner.queue_create_info_count = queue_create_infos.len() as _;
        self.inner.p_queue_create_infos = queue_create_infos.as_ptr();
        self
    }
    #[inline]
    #[deprecated = "functionality described by this member no longer operates"]
    #[allow(deprecated)]
    pub fn enabled_layer_names(mut self, enabled_layer_names: &'a [*const c_char]) -> Self {
        self.inner.enabled_layer_count = enabled_layer_names.len() as _;
        self.inner.pp_enabled_layer_names = enabled_layer_names.as_ptr();
        self
    }
    #[inline]
    pub fn enabled_extension_names(mut self, enabled_extension_names: &'a [*const c_char]) -> Self {
        self.inner.enabled_extension_count = enabled_extension_names.len() as _;
        self.inner.pp_enabled_extension_names = enabled_extension_names.as_ptr();
        self
    }
    #[inline]
    pub fn enabled_features(mut self, enabled_features: &'a PhysicalDeviceFeatures) -> Self {
        self.inner.p_enabled_features = enabled_features;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsDeviceCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html>"]
pub struct InstanceCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: InstanceCreateFlags,
    pub p_application_info: *const ApplicationInfo,
    pub enabled_layer_count: u32,
    pub pp_enabled_layer_names: *const *const c_char,
    pub enabled_extension_count: u32,
    pub pp_enabled_extension_names: *const *const c_char,
}
impl ::std::default::Default for InstanceCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: InstanceCreateFlags::default(),
            p_application_info: ::std::ptr::null(),
            enabled_layer_count: u32::default(),
            pp_enabled_layer_names: ::std::ptr::null(),
            enabled_extension_count: u32::default(),
            pp_enabled_extension_names: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for InstanceCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::INSTANCE_CREATE_INFO;
}
impl InstanceCreateInfo {
    pub fn builder<'a>() -> InstanceCreateInfoBuilder<'a> {
        InstanceCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct InstanceCreateInfoBuilder<'a> {
    inner: InstanceCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsInstanceCreateInfo {}
impl<'a> ::std::ops::Deref for InstanceCreateInfoBuilder<'a> {
    type Target = InstanceCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for InstanceCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> InstanceCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: InstanceCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn application_info(mut self, application_info: &'a ApplicationInfo) -> Self {
        self.inner.p_application_info = application_info;
        self
    }
    #[inline]
    pub fn enabled_layer_names(mut self, enabled_layer_names: &'a [*const c_char]) -> Self {
        self.inner.enabled_layer_count = enabled_layer_names.len() as _;
        self.inner.pp_enabled_layer_names = enabled_layer_names.as_ptr();
        self
    }
    #[inline]
    pub fn enabled_extension_names(mut self, enabled_extension_names: &'a [*const c_char]) -> Self {
        self.inner.enabled_extension_count = enabled_extension_names.len() as _;
        self.inner.pp_enabled_extension_names = enabled_extension_names.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsInstanceCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> InstanceCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyProperties.html>"]
pub struct QueueFamilyProperties {
    pub queue_flags: QueueFlags,
    pub queue_count: u32,
    pub timestamp_valid_bits: u32,
    pub min_image_transfer_granularity: Extent3D,
}
impl QueueFamilyProperties {
    pub fn builder<'a>() -> QueueFamilyPropertiesBuilder<'a> {
        QueueFamilyPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct QueueFamilyPropertiesBuilder<'a> {
    inner: QueueFamilyProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for QueueFamilyPropertiesBuilder<'a> {
    type Target = QueueFamilyProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for QueueFamilyPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> QueueFamilyPropertiesBuilder<'a> {
    #[inline]
    pub fn queue_flags(mut self, queue_flags: QueueFlags) -> Self {
        self.inner.queue_flags = queue_flags;
        self
    }
    #[inline]
    pub fn queue_count(mut self, queue_count: u32) -> Self {
        self.inner.queue_count = queue_count;
        self
    }
    #[inline]
    pub fn timestamp_valid_bits(mut self, timestamp_valid_bits: u32) -> Self {
        self.inner.timestamp_valid_bits = timestamp_valid_bits;
        self
    }
    #[inline]
    pub fn min_image_transfer_granularity(
        mut self,
        min_image_transfer_granularity: Extent3D,
    ) -> Self {
        self.inner.min_image_transfer_granularity = min_image_transfer_granularity;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> QueueFamilyProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryProperties.html>"]
pub struct PhysicalDeviceMemoryProperties {
    pub memory_type_count: u32,
    pub memory_types: [MemoryType; MAX_MEMORY_TYPES],
    pub memory_heap_count: u32,
    pub memory_heaps: [MemoryHeap; MAX_MEMORY_HEAPS],
}
impl ::std::default::Default for PhysicalDeviceMemoryProperties {
    #[inline]
    fn default() -> Self {
        Self {
            memory_type_count: u32::default(),
            memory_types: unsafe { ::std::mem::zeroed() },
            memory_heap_count: u32::default(),
            memory_heaps: unsafe { ::std::mem::zeroed() },
        }
    }
}
impl PhysicalDeviceMemoryProperties {
    pub fn builder<'a>() -> PhysicalDeviceMemoryPropertiesBuilder<'a> {
        PhysicalDeviceMemoryPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceMemoryPropertiesBuilder<'a> {
    inner: PhysicalDeviceMemoryProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PhysicalDeviceMemoryPropertiesBuilder<'a> {
    type Target = PhysicalDeviceMemoryProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceMemoryPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceMemoryPropertiesBuilder<'a> {
    #[inline]
    pub fn memory_type_count(mut self, memory_type_count: u32) -> Self {
        self.inner.memory_type_count = memory_type_count;
        self
    }
    #[inline]
    pub fn memory_types(mut self, memory_types: [MemoryType; MAX_MEMORY_TYPES]) -> Self {
        self.inner.memory_types = memory_types;
        self
    }
    #[inline]
    pub fn memory_heap_count(mut self, memory_heap_count: u32) -> Self {
        self.inner.memory_heap_count = memory_heap_count;
        self
    }
    #[inline]
    pub fn memory_heaps(mut self, memory_heaps: [MemoryHeap; MAX_MEMORY_HEAPS]) -> Self {
        self.inner.memory_heaps = memory_heaps;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceMemoryProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryAllocateInfo.html>"]
pub struct MemoryAllocateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub allocation_size: DeviceSize,
    pub memory_type_index: u32,
}
impl ::std::default::Default for MemoryAllocateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            allocation_size: DeviceSize::default(),
            memory_type_index: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for MemoryAllocateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_ALLOCATE_INFO;
}
impl MemoryAllocateInfo {
    pub fn builder<'a>() -> MemoryAllocateInfoBuilder<'a> {
        MemoryAllocateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MemoryAllocateInfoBuilder<'a> {
    inner: MemoryAllocateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsMemoryAllocateInfo {}
impl<'a> ::std::ops::Deref for MemoryAllocateInfoBuilder<'a> {
    type Target = MemoryAllocateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MemoryAllocateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MemoryAllocateInfoBuilder<'a> {
    #[inline]
    pub fn allocation_size(mut self, allocation_size: DeviceSize) -> Self {
        self.inner.allocation_size = allocation_size;
        self
    }
    #[inline]
    pub fn memory_type_index(mut self, memory_type_index: u32) -> Self {
        self.inner.memory_type_index = memory_type_index;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsMemoryAllocateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MemoryAllocateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryRequirements.html>"]
pub struct MemoryRequirements {
    pub size: DeviceSize,
    pub alignment: DeviceSize,
    pub memory_type_bits: u32,
}
impl MemoryRequirements {
    pub fn builder<'a>() -> MemoryRequirementsBuilder<'a> {
        MemoryRequirementsBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MemoryRequirementsBuilder<'a> {
    inner: MemoryRequirements,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MemoryRequirementsBuilder<'a> {
    type Target = MemoryRequirements;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MemoryRequirementsBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MemoryRequirementsBuilder<'a> {
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    #[inline]
    pub fn alignment(mut self, alignment: DeviceSize) -> Self {
        self.inner.alignment = alignment;
        self
    }
    #[inline]
    pub fn memory_type_bits(mut self, memory_type_bits: u32) -> Self {
        self.inner.memory_type_bits = memory_type_bits;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MemoryRequirements {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageFormatProperties.html>"]
pub struct SparseImageFormatProperties {
    pub aspect_mask: ImageAspectFlags,
    pub image_granularity: Extent3D,
    pub flags: SparseImageFormatFlags,
}
impl SparseImageFormatProperties {
    pub fn builder<'a>() -> SparseImageFormatPropertiesBuilder<'a> {
        SparseImageFormatPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SparseImageFormatPropertiesBuilder<'a> {
    inner: SparseImageFormatProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SparseImageFormatPropertiesBuilder<'a> {
    type Target = SparseImageFormatProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SparseImageFormatPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SparseImageFormatPropertiesBuilder<'a> {
    #[inline]
    pub fn aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
        self.inner.aspect_mask = aspect_mask;
        self
    }
    #[inline]
    pub fn image_granularity(mut self, image_granularity: Extent3D) -> Self {
        self.inner.image_granularity = image_granularity;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: SparseImageFormatFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SparseImageFormatProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageMemoryRequirements.html>"]
pub struct SparseImageMemoryRequirements {
    pub format_properties: SparseImageFormatProperties,
    pub image_mip_tail_first_lod: u32,
    pub image_mip_tail_size: DeviceSize,
    pub image_mip_tail_offset: DeviceSize,
    pub image_mip_tail_stride: DeviceSize,
}
impl SparseImageMemoryRequirements {
    pub fn builder<'a>() -> SparseImageMemoryRequirementsBuilder<'a> {
        SparseImageMemoryRequirementsBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SparseImageMemoryRequirementsBuilder<'a> {
    inner: SparseImageMemoryRequirements,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SparseImageMemoryRequirementsBuilder<'a> {
    type Target = SparseImageMemoryRequirements;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SparseImageMemoryRequirementsBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SparseImageMemoryRequirementsBuilder<'a> {
    #[inline]
    pub fn format_properties(mut self, format_properties: SparseImageFormatProperties) -> Self {
        self.inner.format_properties = format_properties;
        self
    }
    #[inline]
    pub fn image_mip_tail_first_lod(mut self, image_mip_tail_first_lod: u32) -> Self {
        self.inner.image_mip_tail_first_lod = image_mip_tail_first_lod;
        self
    }
    #[inline]
    pub fn image_mip_tail_size(mut self, image_mip_tail_size: DeviceSize) -> Self {
        self.inner.image_mip_tail_size = image_mip_tail_size;
        self
    }
    #[inline]
    pub fn image_mip_tail_offset(mut self, image_mip_tail_offset: DeviceSize) -> Self {
        self.inner.image_mip_tail_offset = image_mip_tail_offset;
        self
    }
    #[inline]
    pub fn image_mip_tail_stride(mut self, image_mip_tail_stride: DeviceSize) -> Self {
        self.inner.image_mip_tail_stride = image_mip_tail_stride;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SparseImageMemoryRequirements {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryType.html>"]
pub struct MemoryType {
    pub property_flags: MemoryPropertyFlags,
    pub heap_index: u32,
}
impl MemoryType {
    pub fn builder<'a>() -> MemoryTypeBuilder<'a> {
        MemoryTypeBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MemoryTypeBuilder<'a> {
    inner: MemoryType,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MemoryTypeBuilder<'a> {
    type Target = MemoryType;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MemoryTypeBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MemoryTypeBuilder<'a> {
    #[inline]
    pub fn property_flags(mut self, property_flags: MemoryPropertyFlags) -> Self {
        self.inner.property_flags = property_flags;
        self
    }
    #[inline]
    pub fn heap_index(mut self, heap_index: u32) -> Self {
        self.inner.heap_index = heap_index;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MemoryType {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryHeap.html>"]
pub struct MemoryHeap {
    pub size: DeviceSize,
    pub flags: MemoryHeapFlags,
}
impl MemoryHeap {
    pub fn builder<'a>() -> MemoryHeapBuilder<'a> {
        MemoryHeapBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MemoryHeapBuilder<'a> {
    inner: MemoryHeap,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MemoryHeapBuilder<'a> {
    type Target = MemoryHeap;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MemoryHeapBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MemoryHeapBuilder<'a> {
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: MemoryHeapFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MemoryHeap {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMappedMemoryRange.html>"]
pub struct MappedMemoryRange {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: DeviceMemory,
    pub offset: DeviceSize,
    pub size: DeviceSize,
}
impl ::std::default::Default for MappedMemoryRange {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            memory: DeviceMemory::default(),
            offset: DeviceSize::default(),
            size: DeviceSize::default(),
        }
    }
}
unsafe impl TaggedStructure for MappedMemoryRange {
    const STRUCTURE_TYPE: StructureType = StructureType::MAPPED_MEMORY_RANGE;
}
impl MappedMemoryRange {
    pub fn builder<'a>() -> MappedMemoryRangeBuilder<'a> {
        MappedMemoryRangeBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MappedMemoryRangeBuilder<'a> {
    inner: MappedMemoryRange,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MappedMemoryRangeBuilder<'a> {
    type Target = MappedMemoryRange;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MappedMemoryRangeBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MappedMemoryRangeBuilder<'a> {
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: DeviceSize) -> Self {
        self.inner.offset = offset;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MappedMemoryRange {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatProperties.html>"]
pub struct FormatProperties {
    pub linear_tiling_features: FormatFeatureFlags,
    pub optimal_tiling_features: FormatFeatureFlags,
    pub buffer_features: FormatFeatureFlags,
}
impl FormatProperties {
    pub fn builder<'a>() -> FormatPropertiesBuilder<'a> {
        FormatPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct FormatPropertiesBuilder<'a> {
    inner: FormatProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for FormatPropertiesBuilder<'a> {
    type Target = FormatProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for FormatPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> FormatPropertiesBuilder<'a> {
    #[inline]
    pub fn linear_tiling_features(mut self, linear_tiling_features: FormatFeatureFlags) -> Self {
        self.inner.linear_tiling_features = linear_tiling_features;
        self
    }
    #[inline]
    pub fn optimal_tiling_features(mut self, optimal_tiling_features: FormatFeatureFlags) -> Self {
        self.inner.optimal_tiling_features = optimal_tiling_features;
        self
    }
    #[inline]
    pub fn buffer_features(mut self, buffer_features: FormatFeatureFlags) -> Self {
        self.inner.buffer_features = buffer_features;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> FormatProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageFormatProperties.html>"]
pub struct ImageFormatProperties {
    pub max_extent: Extent3D,
    pub max_mip_levels: u32,
    pub max_array_layers: u32,
    pub sample_counts: SampleCountFlags,
    pub max_resource_size: DeviceSize,
}
impl ImageFormatProperties {
    pub fn builder<'a>() -> ImageFormatPropertiesBuilder<'a> {
        ImageFormatPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageFormatPropertiesBuilder<'a> {
    inner: ImageFormatProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ImageFormatPropertiesBuilder<'a> {
    type Target = ImageFormatProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageFormatPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageFormatPropertiesBuilder<'a> {
    #[inline]
    pub fn max_extent(mut self, max_extent: Extent3D) -> Self {
        self.inner.max_extent = max_extent;
        self
    }
    #[inline]
    pub fn max_mip_levels(mut self, max_mip_levels: u32) -> Self {
        self.inner.max_mip_levels = max_mip_levels;
        self
    }
    #[inline]
    pub fn max_array_layers(mut self, max_array_layers: u32) -> Self {
        self.inner.max_array_layers = max_array_layers;
        self
    }
    #[inline]
    pub fn sample_counts(mut self, sample_counts: SampleCountFlags) -> Self {
        self.inner.sample_counts = sample_counts;
        self
    }
    #[inline]
    pub fn max_resource_size(mut self, max_resource_size: DeviceSize) -> Self {
        self.inner.max_resource_size = max_resource_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageFormatProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorBufferInfo.html>"]
pub struct DescriptorBufferInfo {
    pub buffer: Buffer,
    pub offset: DeviceSize,
    pub range: DeviceSize,
}
impl DescriptorBufferInfo {
    pub fn builder<'a>() -> DescriptorBufferInfoBuilder<'a> {
        DescriptorBufferInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DescriptorBufferInfoBuilder<'a> {
    inner: DescriptorBufferInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DescriptorBufferInfoBuilder<'a> {
    type Target = DescriptorBufferInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DescriptorBufferInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DescriptorBufferInfoBuilder<'a> {
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: DeviceSize) -> Self {
        self.inner.offset = offset;
        self
    }
    #[inline]
    pub fn range(mut self, range: DeviceSize) -> Self {
        self.inner.range = range;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DescriptorBufferInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorImageInfo.html>"]
pub struct DescriptorImageInfo {
    pub sampler: Sampler,
    pub image_view: ImageView,
    pub image_layout: ImageLayout,
}
impl DescriptorImageInfo {
    pub fn builder<'a>() -> DescriptorImageInfoBuilder<'a> {
        DescriptorImageInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DescriptorImageInfoBuilder<'a> {
    inner: DescriptorImageInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DescriptorImageInfoBuilder<'a> {
    type Target = DescriptorImageInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DescriptorImageInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DescriptorImageInfoBuilder<'a> {
    #[inline]
    pub fn sampler(mut self, sampler: Sampler) -> Self {
        self.inner.sampler = sampler;
        self
    }
    #[inline]
    pub fn image_view(mut self, image_view: ImageView) -> Self {
        self.inner.image_view = image_view;
        self
    }
    #[inline]
    pub fn image_layout(mut self, image_layout: ImageLayout) -> Self {
        self.inner.image_layout = image_layout;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DescriptorImageInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWriteDescriptorSet.html>"]
pub struct WriteDescriptorSet {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub dst_set: DescriptorSet,
    pub dst_binding: u32,
    pub dst_array_element: u32,
    pub descriptor_count: u32,
    pub descriptor_type: DescriptorType,
    pub p_image_info: *const DescriptorImageInfo,
    pub p_buffer_info: *const DescriptorBufferInfo,
    pub p_texel_buffer_view: *const BufferView,
}
impl ::std::default::Default for WriteDescriptorSet {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            dst_set: DescriptorSet::default(),
            dst_binding: u32::default(),
            dst_array_element: u32::default(),
            descriptor_count: u32::default(),
            descriptor_type: DescriptorType::default(),
            p_image_info: ::std::ptr::null(),
            p_buffer_info: ::std::ptr::null(),
            p_texel_buffer_view: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for WriteDescriptorSet {
    const STRUCTURE_TYPE: StructureType = StructureType::WRITE_DESCRIPTOR_SET;
}
impl WriteDescriptorSet {
    pub fn builder<'a>() -> WriteDescriptorSetBuilder<'a> {
        WriteDescriptorSetBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct WriteDescriptorSetBuilder<'a> {
    inner: WriteDescriptorSet,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsWriteDescriptorSet {}
impl<'a> ::std::ops::Deref for WriteDescriptorSetBuilder<'a> {
    type Target = WriteDescriptorSet;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for WriteDescriptorSetBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> WriteDescriptorSetBuilder<'a> {
    #[inline]
    pub fn dst_set(mut self, dst_set: DescriptorSet) -> Self {
        self.inner.dst_set = dst_set;
        self
    }
    #[inline]
    pub fn dst_binding(mut self, dst_binding: u32) -> Self {
        self.inner.dst_binding = dst_binding;
        self
    }
    #[inline]
    pub fn dst_array_element(mut self, dst_array_element: u32) -> Self {
        self.inner.dst_array_element = dst_array_element;
        self
    }
    #[inline]
    pub fn descriptor_type(mut self, descriptor_type: DescriptorType) -> Self {
        self.inner.descriptor_type = descriptor_type;
        self
    }
    #[inline]
    pub fn image_info(mut self, image_info: &'a [DescriptorImageInfo]) -> Self {
        self.inner.descriptor_count = image_info.len() as _;
        self.inner.p_image_info = image_info.as_ptr();
        self
    }
    #[inline]
    pub fn buffer_info(mut self, buffer_info: &'a [DescriptorBufferInfo]) -> Self {
        self.inner.descriptor_count = buffer_info.len() as _;
        self.inner.p_buffer_info = buffer_info.as_ptr();
        self
    }
    #[inline]
    pub fn texel_buffer_view(mut self, texel_buffer_view: &'a [BufferView]) -> Self {
        self.inner.descriptor_count = texel_buffer_view.len() as _;
        self.inner.p_texel_buffer_view = texel_buffer_view.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsWriteDescriptorSet>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> WriteDescriptorSet {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyDescriptorSet.html>"]
pub struct CopyDescriptorSet {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_set: DescriptorSet,
    pub src_binding: u32,
    pub src_array_element: u32,
    pub dst_set: DescriptorSet,
    pub dst_binding: u32,
    pub dst_array_element: u32,
    pub descriptor_count: u32,
}
impl ::std::default::Default for CopyDescriptorSet {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_set: DescriptorSet::default(),
            src_binding: u32::default(),
            src_array_element: u32::default(),
            dst_set: DescriptorSet::default(),
            dst_binding: u32::default(),
            dst_array_element: u32::default(),
            descriptor_count: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for CopyDescriptorSet {
    const STRUCTURE_TYPE: StructureType = StructureType::COPY_DESCRIPTOR_SET;
}
impl CopyDescriptorSet {
    pub fn builder<'a>() -> CopyDescriptorSetBuilder<'a> {
        CopyDescriptorSetBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CopyDescriptorSetBuilder<'a> {
    inner: CopyDescriptorSet,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CopyDescriptorSetBuilder<'a> {
    type Target = CopyDescriptorSet;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CopyDescriptorSetBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CopyDescriptorSetBuilder<'a> {
    #[inline]
    pub fn src_set(mut self, src_set: DescriptorSet) -> Self {
        self.inner.src_set = src_set;
        self
    }
    #[inline]
    pub fn src_binding(mut self, src_binding: u32) -> Self {
        self.inner.src_binding = src_binding;
        self
    }
    #[inline]
    pub fn src_array_element(mut self, src_array_element: u32) -> Self {
        self.inner.src_array_element = src_array_element;
        self
    }
    #[inline]
    pub fn dst_set(mut self, dst_set: DescriptorSet) -> Self {
        self.inner.dst_set = dst_set;
        self
    }
    #[inline]
    pub fn dst_binding(mut self, dst_binding: u32) -> Self {
        self.inner.dst_binding = dst_binding;
        self
    }
    #[inline]
    pub fn dst_array_element(mut self, dst_array_element: u32) -> Self {
        self.inner.dst_array_element = dst_array_element;
        self
    }
    #[inline]
    pub fn descriptor_count(mut self, descriptor_count: u32) -> Self {
        self.inner.descriptor_count = descriptor_count;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CopyDescriptorSet {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCreateInfo.html>"]
pub struct BufferCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: BufferCreateFlags,
    pub size: DeviceSize,
    pub usage: BufferUsageFlags,
    pub sharing_mode: SharingMode,
    pub queue_family_index_count: u32,
    pub p_queue_family_indices: *const u32,
}
impl ::std::default::Default for BufferCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: BufferCreateFlags::default(),
            size: DeviceSize::default(),
            usage: BufferUsageFlags::default(),
            sharing_mode: SharingMode::default(),
            queue_family_index_count: u32::default(),
            p_queue_family_indices: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for BufferCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_CREATE_INFO;
}
impl BufferCreateInfo {
    pub fn builder<'a>() -> BufferCreateInfoBuilder<'a> {
        BufferCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BufferCreateInfoBuilder<'a> {
    inner: BufferCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsBufferCreateInfo {}
impl<'a> ::std::ops::Deref for BufferCreateInfoBuilder<'a> {
    type Target = BufferCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BufferCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BufferCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: BufferCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    #[inline]
    pub fn usage(mut self, usage: BufferUsageFlags) -> Self {
        self.inner.usage = usage;
        self
    }
    #[inline]
    pub fn sharing_mode(mut self, sharing_mode: SharingMode) -> Self {
        self.inner.sharing_mode = sharing_mode;
        self
    }
    #[inline]
    pub fn queue_family_indices(mut self, queue_family_indices: &'a [u32]) -> Self {
        self.inner.queue_family_index_count = queue_family_indices.len() as _;
        self.inner.p_queue_family_indices = queue_family_indices.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsBufferCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BufferCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferViewCreateInfo.html>"]
pub struct BufferViewCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: BufferViewCreateFlags,
    pub buffer: Buffer,
    pub format: Format,
    pub offset: DeviceSize,
    pub range: DeviceSize,
}
impl ::std::default::Default for BufferViewCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: BufferViewCreateFlags::default(),
            buffer: Buffer::default(),
            format: Format::default(),
            offset: DeviceSize::default(),
            range: DeviceSize::default(),
        }
    }
}
unsafe impl TaggedStructure for BufferViewCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_VIEW_CREATE_INFO;
}
impl BufferViewCreateInfo {
    pub fn builder<'a>() -> BufferViewCreateInfoBuilder<'a> {
        BufferViewCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BufferViewCreateInfoBuilder<'a> {
    inner: BufferViewCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsBufferViewCreateInfo {}
impl<'a> ::std::ops::Deref for BufferViewCreateInfoBuilder<'a> {
    type Target = BufferViewCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BufferViewCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BufferViewCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: BufferViewCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.inner.format = format;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: DeviceSize) -> Self {
        self.inner.offset = offset;
        self
    }
    #[inline]
    pub fn range(mut self, range: DeviceSize) -> Self {
        self.inner.range = range;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsBufferViewCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BufferViewCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSubresource.html>"]
pub struct ImageSubresource {
    pub aspect_mask: ImageAspectFlags,
    pub mip_level: u32,
    pub array_layer: u32,
}
impl ImageSubresource {
    pub fn builder<'a>() -> ImageSubresourceBuilder<'a> {
        ImageSubresourceBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageSubresourceBuilder<'a> {
    inner: ImageSubresource,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ImageSubresourceBuilder<'a> {
    type Target = ImageSubresource;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageSubresourceBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageSubresourceBuilder<'a> {
    #[inline]
    pub fn aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
        self.inner.aspect_mask = aspect_mask;
        self
    }
    #[inline]
    pub fn mip_level(mut self, mip_level: u32) -> Self {
        self.inner.mip_level = mip_level;
        self
    }
    #[inline]
    pub fn array_layer(mut self, array_layer: u32) -> Self {
        self.inner.array_layer = array_layer;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageSubresource {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSubresourceLayers.html>"]
pub struct ImageSubresourceLayers {
    pub aspect_mask: ImageAspectFlags,
    pub mip_level: u32,
    pub base_array_layer: u32,
    pub layer_count: u32,
}
impl ImageSubresourceLayers {
    pub fn builder<'a>() -> ImageSubresourceLayersBuilder<'a> {
        ImageSubresourceLayersBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageSubresourceLayersBuilder<'a> {
    inner: ImageSubresourceLayers,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ImageSubresourceLayersBuilder<'a> {
    type Target = ImageSubresourceLayers;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageSubresourceLayersBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageSubresourceLayersBuilder<'a> {
    #[inline]
    pub fn aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
        self.inner.aspect_mask = aspect_mask;
        self
    }
    #[inline]
    pub fn mip_level(mut self, mip_level: u32) -> Self {
        self.inner.mip_level = mip_level;
        self
    }
    #[inline]
    pub fn base_array_layer(mut self, base_array_layer: u32) -> Self {
        self.inner.base_array_layer = base_array_layer;
        self
    }
    #[inline]
    pub fn layer_count(mut self, layer_count: u32) -> Self {
        self.inner.layer_count = layer_count;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageSubresourceLayers {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSubresourceRange.html>"]
pub struct ImageSubresourceRange {
    pub aspect_mask: ImageAspectFlags,
    pub base_mip_level: u32,
    pub level_count: u32,
    pub base_array_layer: u32,
    pub layer_count: u32,
}
impl ImageSubresourceRange {
    pub fn builder<'a>() -> ImageSubresourceRangeBuilder<'a> {
        ImageSubresourceRangeBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageSubresourceRangeBuilder<'a> {
    inner: ImageSubresourceRange,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ImageSubresourceRangeBuilder<'a> {
    type Target = ImageSubresourceRange;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageSubresourceRangeBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageSubresourceRangeBuilder<'a> {
    #[inline]
    pub fn aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
        self.inner.aspect_mask = aspect_mask;
        self
    }
    #[inline]
    pub fn base_mip_level(mut self, base_mip_level: u32) -> Self {
        self.inner.base_mip_level = base_mip_level;
        self
    }
    #[inline]
    pub fn level_count(mut self, level_count: u32) -> Self {
        self.inner.level_count = level_count;
        self
    }
    #[inline]
    pub fn base_array_layer(mut self, base_array_layer: u32) -> Self {
        self.inner.base_array_layer = base_array_layer;
        self
    }
    #[inline]
    pub fn layer_count(mut self, layer_count: u32) -> Self {
        self.inner.layer_count = layer_count;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageSubresourceRange {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryBarrier.html>"]
pub struct MemoryBarrier {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_access_mask: AccessFlags,
    pub dst_access_mask: AccessFlags,
}
impl ::std::default::Default for MemoryBarrier {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_access_mask: AccessFlags::default(),
            dst_access_mask: AccessFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for MemoryBarrier {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_BARRIER;
}
impl MemoryBarrier {
    pub fn builder<'a>() -> MemoryBarrierBuilder<'a> {
        MemoryBarrierBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MemoryBarrierBuilder<'a> {
    inner: MemoryBarrier,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MemoryBarrierBuilder<'a> {
    type Target = MemoryBarrier;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MemoryBarrierBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MemoryBarrierBuilder<'a> {
    #[inline]
    pub fn src_access_mask(mut self, src_access_mask: AccessFlags) -> Self {
        self.inner.src_access_mask = src_access_mask;
        self
    }
    #[inline]
    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags) -> Self {
        self.inner.dst_access_mask = dst_access_mask;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MemoryBarrier {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferMemoryBarrier.html>"]
pub struct BufferMemoryBarrier {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_access_mask: AccessFlags,
    pub dst_access_mask: AccessFlags,
    pub src_queue_family_index: u32,
    pub dst_queue_family_index: u32,
    pub buffer: Buffer,
    pub offset: DeviceSize,
    pub size: DeviceSize,
}
impl ::std::default::Default for BufferMemoryBarrier {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_access_mask: AccessFlags::default(),
            dst_access_mask: AccessFlags::default(),
            src_queue_family_index: u32::default(),
            dst_queue_family_index: u32::default(),
            buffer: Buffer::default(),
            offset: DeviceSize::default(),
            size: DeviceSize::default(),
        }
    }
}
unsafe impl TaggedStructure for BufferMemoryBarrier {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_MEMORY_BARRIER;
}
impl BufferMemoryBarrier {
    pub fn builder<'a>() -> BufferMemoryBarrierBuilder<'a> {
        BufferMemoryBarrierBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BufferMemoryBarrierBuilder<'a> {
    inner: BufferMemoryBarrier,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for BufferMemoryBarrierBuilder<'a> {
    type Target = BufferMemoryBarrier;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BufferMemoryBarrierBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BufferMemoryBarrierBuilder<'a> {
    #[inline]
    pub fn src_access_mask(mut self, src_access_mask: AccessFlags) -> Self {
        self.inner.src_access_mask = src_access_mask;
        self
    }
    #[inline]
    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags) -> Self {
        self.inner.dst_access_mask = dst_access_mask;
        self
    }
    #[inline]
    pub fn src_queue_family_index(mut self, src_queue_family_index: u32) -> Self {
        self.inner.src_queue_family_index = src_queue_family_index;
        self
    }
    #[inline]
    pub fn dst_queue_family_index(mut self, dst_queue_family_index: u32) -> Self {
        self.inner.dst_queue_family_index = dst_queue_family_index;
        self
    }
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: DeviceSize) -> Self {
        self.inner.offset = offset;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BufferMemoryBarrier {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageMemoryBarrier.html>"]
pub struct ImageMemoryBarrier {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_access_mask: AccessFlags,
    pub dst_access_mask: AccessFlags,
    pub old_layout: ImageLayout,
    pub new_layout: ImageLayout,
    pub src_queue_family_index: u32,
    pub dst_queue_family_index: u32,
    pub image: Image,
    pub subresource_range: ImageSubresourceRange,
}
impl ::std::default::Default for ImageMemoryBarrier {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_access_mask: AccessFlags::default(),
            dst_access_mask: AccessFlags::default(),
            old_layout: ImageLayout::default(),
            new_layout: ImageLayout::default(),
            src_queue_family_index: u32::default(),
            dst_queue_family_index: u32::default(),
            image: Image::default(),
            subresource_range: ImageSubresourceRange::default(),
        }
    }
}
unsafe impl TaggedStructure for ImageMemoryBarrier {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_MEMORY_BARRIER;
}
impl ImageMemoryBarrier {
    pub fn builder<'a>() -> ImageMemoryBarrierBuilder<'a> {
        ImageMemoryBarrierBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageMemoryBarrierBuilder<'a> {
    inner: ImageMemoryBarrier,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsImageMemoryBarrier {}
impl<'a> ::std::ops::Deref for ImageMemoryBarrierBuilder<'a> {
    type Target = ImageMemoryBarrier;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageMemoryBarrierBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageMemoryBarrierBuilder<'a> {
    #[inline]
    pub fn src_access_mask(mut self, src_access_mask: AccessFlags) -> Self {
        self.inner.src_access_mask = src_access_mask;
        self
    }
    #[inline]
    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags) -> Self {
        self.inner.dst_access_mask = dst_access_mask;
        self
    }
    #[inline]
    pub fn old_layout(mut self, old_layout: ImageLayout) -> Self {
        self.inner.old_layout = old_layout;
        self
    }
    #[inline]
    pub fn new_layout(mut self, new_layout: ImageLayout) -> Self {
        self.inner.new_layout = new_layout;
        self
    }
    #[inline]
    pub fn src_queue_family_index(mut self, src_queue_family_index: u32) -> Self {
        self.inner.src_queue_family_index = src_queue_family_index;
        self
    }
    #[inline]
    pub fn dst_queue_family_index(mut self, dst_queue_family_index: u32) -> Self {
        self.inner.dst_queue_family_index = dst_queue_family_index;
        self
    }
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.inner.image = image;
        self
    }
    #[inline]
    pub fn subresource_range(mut self, subresource_range: ImageSubresourceRange) -> Self {
        self.inner.subresource_range = subresource_range;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsImageMemoryBarrier>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageMemoryBarrier {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCreateInfo.html>"]
pub struct ImageCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ImageCreateFlags,
    pub image_type: ImageType,
    pub format: Format,
    pub extent: Extent3D,
    pub mip_levels: u32,
    pub array_layers: u32,
    pub samples: SampleCountFlags,
    pub tiling: ImageTiling,
    pub usage: ImageUsageFlags,
    pub sharing_mode: SharingMode,
    pub queue_family_index_count: u32,
    pub p_queue_family_indices: *const u32,
    pub initial_layout: ImageLayout,
}
impl ::std::default::Default for ImageCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: ImageCreateFlags::default(),
            image_type: ImageType::default(),
            format: Format::default(),
            extent: Extent3D::default(),
            mip_levels: u32::default(),
            array_layers: u32::default(),
            samples: SampleCountFlags::default(),
            tiling: ImageTiling::default(),
            usage: ImageUsageFlags::default(),
            sharing_mode: SharingMode::default(),
            queue_family_index_count: u32::default(),
            p_queue_family_indices: ::std::ptr::null(),
            initial_layout: ImageLayout::default(),
        }
    }
}
unsafe impl TaggedStructure for ImageCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_CREATE_INFO;
}
impl ImageCreateInfo {
    pub fn builder<'a>() -> ImageCreateInfoBuilder<'a> {
        ImageCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageCreateInfoBuilder<'a> {
    inner: ImageCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsImageCreateInfo {}
impl<'a> ::std::ops::Deref for ImageCreateInfoBuilder<'a> {
    type Target = ImageCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: ImageCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn image_type(mut self, image_type: ImageType) -> Self {
        self.inner.image_type = image_type;
        self
    }
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.inner.format = format;
        self
    }
    #[inline]
    pub fn extent(mut self, extent: Extent3D) -> Self {
        self.inner.extent = extent;
        self
    }
    #[inline]
    pub fn mip_levels(mut self, mip_levels: u32) -> Self {
        self.inner.mip_levels = mip_levels;
        self
    }
    #[inline]
    pub fn array_layers(mut self, array_layers: u32) -> Self {
        self.inner.array_layers = array_layers;
        self
    }
    #[inline]
    pub fn samples(mut self, samples: SampleCountFlags) -> Self {
        self.inner.samples = samples;
        self
    }
    #[inline]
    pub fn tiling(mut self, tiling: ImageTiling) -> Self {
        self.inner.tiling = tiling;
        self
    }
    #[inline]
    pub fn usage(mut self, usage: ImageUsageFlags) -> Self {
        self.inner.usage = usage;
        self
    }
    #[inline]
    pub fn sharing_mode(mut self, sharing_mode: SharingMode) -> Self {
        self.inner.sharing_mode = sharing_mode;
        self
    }
    #[inline]
    pub fn queue_family_indices(mut self, queue_family_indices: &'a [u32]) -> Self {
        self.inner.queue_family_index_count = queue_family_indices.len() as _;
        self.inner.p_queue_family_indices = queue_family_indices.as_ptr();
        self
    }
    #[inline]
    pub fn initial_layout(mut self, initial_layout: ImageLayout) -> Self {
        self.inner.initial_layout = initial_layout;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsImageCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubresourceLayout.html>"]
pub struct SubresourceLayout {
    pub offset: DeviceSize,
    pub size: DeviceSize,
    pub row_pitch: DeviceSize,
    pub array_pitch: DeviceSize,
    pub depth_pitch: DeviceSize,
}
impl SubresourceLayout {
    pub fn builder<'a>() -> SubresourceLayoutBuilder<'a> {
        SubresourceLayoutBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SubresourceLayoutBuilder<'a> {
    inner: SubresourceLayout,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SubresourceLayoutBuilder<'a> {
    type Target = SubresourceLayout;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SubresourceLayoutBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SubresourceLayoutBuilder<'a> {
    #[inline]
    pub fn offset(mut self, offset: DeviceSize) -> Self {
        self.inner.offset = offset;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    #[inline]
    pub fn row_pitch(mut self, row_pitch: DeviceSize) -> Self {
        self.inner.row_pitch = row_pitch;
        self
    }
    #[inline]
    pub fn array_pitch(mut self, array_pitch: DeviceSize) -> Self {
        self.inner.array_pitch = array_pitch;
        self
    }
    #[inline]
    pub fn depth_pitch(mut self, depth_pitch: DeviceSize) -> Self {
        self.inner.depth_pitch = depth_pitch;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SubresourceLayout {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateInfo.html>"]
pub struct ImageViewCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ImageViewCreateFlags,
    pub image: Image,
    pub view_type: ImageViewType,
    pub format: Format,
    pub components: ComponentMapping,
    pub subresource_range: ImageSubresourceRange,
}
impl ::std::default::Default for ImageViewCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: ImageViewCreateFlags::default(),
            image: Image::default(),
            view_type: ImageViewType::default(),
            format: Format::default(),
            components: ComponentMapping::default(),
            subresource_range: ImageSubresourceRange::default(),
        }
    }
}
unsafe impl TaggedStructure for ImageViewCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_VIEW_CREATE_INFO;
}
impl ImageViewCreateInfo {
    pub fn builder<'a>() -> ImageViewCreateInfoBuilder<'a> {
        ImageViewCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageViewCreateInfoBuilder<'a> {
    inner: ImageViewCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsImageViewCreateInfo {}
impl<'a> ::std::ops::Deref for ImageViewCreateInfoBuilder<'a> {
    type Target = ImageViewCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageViewCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageViewCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: ImageViewCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.inner.image = image;
        self
    }
    #[inline]
    pub fn view_type(mut self, view_type: ImageViewType) -> Self {
        self.inner.view_type = view_type;
        self
    }
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.inner.format = format;
        self
    }
    #[inline]
    pub fn components(mut self, components: ComponentMapping) -> Self {
        self.inner.components = components;
        self
    }
    #[inline]
    pub fn subresource_range(mut self, subresource_range: ImageSubresourceRange) -> Self {
        self.inner.subresource_range = subresource_range;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsImageViewCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageViewCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCopy.html>"]
pub struct BufferCopy {
    pub src_offset: DeviceSize,
    pub dst_offset: DeviceSize,
    pub size: DeviceSize,
}
impl BufferCopy {
    pub fn builder<'a>() -> BufferCopyBuilder<'a> {
        BufferCopyBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BufferCopyBuilder<'a> {
    inner: BufferCopy,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for BufferCopyBuilder<'a> {
    type Target = BufferCopy;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BufferCopyBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BufferCopyBuilder<'a> {
    #[inline]
    pub fn src_offset(mut self, src_offset: DeviceSize) -> Self {
        self.inner.src_offset = src_offset;
        self
    }
    #[inline]
    pub fn dst_offset(mut self, dst_offset: DeviceSize) -> Self {
        self.inner.dst_offset = dst_offset;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BufferCopy {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseMemoryBind.html>"]
pub struct SparseMemoryBind {
    pub resource_offset: DeviceSize,
    pub size: DeviceSize,
    pub memory: DeviceMemory,
    pub memory_offset: DeviceSize,
    pub flags: SparseMemoryBindFlags,
}
impl SparseMemoryBind {
    pub fn builder<'a>() -> SparseMemoryBindBuilder<'a> {
        SparseMemoryBindBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SparseMemoryBindBuilder<'a> {
    inner: SparseMemoryBind,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SparseMemoryBindBuilder<'a> {
    type Target = SparseMemoryBind;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SparseMemoryBindBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SparseMemoryBindBuilder<'a> {
    #[inline]
    pub fn resource_offset(mut self, resource_offset: DeviceSize) -> Self {
        self.inner.resource_offset = resource_offset;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    #[inline]
    pub fn memory_offset(mut self, memory_offset: DeviceSize) -> Self {
        self.inner.memory_offset = memory_offset;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: SparseMemoryBindFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SparseMemoryBind {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageMemoryBind.html>"]
pub struct SparseImageMemoryBind {
    pub subresource: ImageSubresource,
    pub offset: Offset3D,
    pub extent: Extent3D,
    pub memory: DeviceMemory,
    pub memory_offset: DeviceSize,
    pub flags: SparseMemoryBindFlags,
}
impl SparseImageMemoryBind {
    pub fn builder<'a>() -> SparseImageMemoryBindBuilder<'a> {
        SparseImageMemoryBindBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SparseImageMemoryBindBuilder<'a> {
    inner: SparseImageMemoryBind,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SparseImageMemoryBindBuilder<'a> {
    type Target = SparseImageMemoryBind;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SparseImageMemoryBindBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SparseImageMemoryBindBuilder<'a> {
    #[inline]
    pub fn subresource(mut self, subresource: ImageSubresource) -> Self {
        self.inner.subresource = subresource;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: Offset3D) -> Self {
        self.inner.offset = offset;
        self
    }
    #[inline]
    pub fn extent(mut self, extent: Extent3D) -> Self {
        self.inner.extent = extent;
        self
    }
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    #[inline]
    pub fn memory_offset(mut self, memory_offset: DeviceSize) -> Self {
        self.inner.memory_offset = memory_offset;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: SparseMemoryBindFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SparseImageMemoryBind {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseBufferMemoryBindInfo.html>"]
pub struct SparseBufferMemoryBindInfo {
    pub buffer: Buffer,
    pub bind_count: u32,
    pub p_binds: *const SparseMemoryBind,
}
impl ::std::default::Default for SparseBufferMemoryBindInfo {
    #[inline]
    fn default() -> Self {
        Self {
            buffer: Buffer::default(),
            bind_count: u32::default(),
            p_binds: ::std::ptr::null(),
        }
    }
}
impl SparseBufferMemoryBindInfo {
    pub fn builder<'a>() -> SparseBufferMemoryBindInfoBuilder<'a> {
        SparseBufferMemoryBindInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SparseBufferMemoryBindInfoBuilder<'a> {
    inner: SparseBufferMemoryBindInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SparseBufferMemoryBindInfoBuilder<'a> {
    type Target = SparseBufferMemoryBindInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SparseBufferMemoryBindInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SparseBufferMemoryBindInfoBuilder<'a> {
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    #[inline]
    pub fn binds(mut self, binds: &'a [SparseMemoryBind]) -> Self {
        self.inner.bind_count = binds.len() as _;
        self.inner.p_binds = binds.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SparseBufferMemoryBindInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageOpaqueMemoryBindInfo.html>"]
pub struct SparseImageOpaqueMemoryBindInfo {
    pub image: Image,
    pub bind_count: u32,
    pub p_binds: *const SparseMemoryBind,
}
impl ::std::default::Default for SparseImageOpaqueMemoryBindInfo {
    #[inline]
    fn default() -> Self {
        Self {
            image: Image::default(),
            bind_count: u32::default(),
            p_binds: ::std::ptr::null(),
        }
    }
}
impl SparseImageOpaqueMemoryBindInfo {
    pub fn builder<'a>() -> SparseImageOpaqueMemoryBindInfoBuilder<'a> {
        SparseImageOpaqueMemoryBindInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SparseImageOpaqueMemoryBindInfoBuilder<'a> {
    inner: SparseImageOpaqueMemoryBindInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SparseImageOpaqueMemoryBindInfoBuilder<'a> {
    type Target = SparseImageOpaqueMemoryBindInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SparseImageOpaqueMemoryBindInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SparseImageOpaqueMemoryBindInfoBuilder<'a> {
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.inner.image = image;
        self
    }
    #[inline]
    pub fn binds(mut self, binds: &'a [SparseMemoryBind]) -> Self {
        self.inner.bind_count = binds.len() as _;
        self.inner.p_binds = binds.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SparseImageOpaqueMemoryBindInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageMemoryBindInfo.html>"]
pub struct SparseImageMemoryBindInfo {
    pub image: Image,
    pub bind_count: u32,
    pub p_binds: *const SparseImageMemoryBind,
}
impl ::std::default::Default for SparseImageMemoryBindInfo {
    #[inline]
    fn default() -> Self {
        Self {
            image: Image::default(),
            bind_count: u32::default(),
            p_binds: ::std::ptr::null(),
        }
    }
}
impl SparseImageMemoryBindInfo {
    pub fn builder<'a>() -> SparseImageMemoryBindInfoBuilder<'a> {
        SparseImageMemoryBindInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SparseImageMemoryBindInfoBuilder<'a> {
    inner: SparseImageMemoryBindInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SparseImageMemoryBindInfoBuilder<'a> {
    type Target = SparseImageMemoryBindInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SparseImageMemoryBindInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SparseImageMemoryBindInfoBuilder<'a> {
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.inner.image = image;
        self
    }
    #[inline]
    pub fn binds(mut self, binds: &'a [SparseImageMemoryBind]) -> Self {
        self.inner.bind_count = binds.len() as _;
        self.inner.p_binds = binds.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SparseImageMemoryBindInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindSparseInfo.html>"]
pub struct BindSparseInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub wait_semaphore_count: u32,
    pub p_wait_semaphores: *const Semaphore,
    pub buffer_bind_count: u32,
    pub p_buffer_binds: *const SparseBufferMemoryBindInfo,
    pub image_opaque_bind_count: u32,
    pub p_image_opaque_binds: *const SparseImageOpaqueMemoryBindInfo,
    pub image_bind_count: u32,
    pub p_image_binds: *const SparseImageMemoryBindInfo,
    pub signal_semaphore_count: u32,
    pub p_signal_semaphores: *const Semaphore,
}
impl ::std::default::Default for BindSparseInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            wait_semaphore_count: u32::default(),
            p_wait_semaphores: ::std::ptr::null(),
            buffer_bind_count: u32::default(),
            p_buffer_binds: ::std::ptr::null(),
            image_opaque_bind_count: u32::default(),
            p_image_opaque_binds: ::std::ptr::null(),
            image_bind_count: u32::default(),
            p_image_binds: ::std::ptr::null(),
            signal_semaphore_count: u32::default(),
            p_signal_semaphores: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for BindSparseInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::BIND_SPARSE_INFO;
}
impl BindSparseInfo {
    pub fn builder<'a>() -> BindSparseInfoBuilder<'a> {
        BindSparseInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BindSparseInfoBuilder<'a> {
    inner: BindSparseInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsBindSparseInfo {}
impl<'a> ::std::ops::Deref for BindSparseInfoBuilder<'a> {
    type Target = BindSparseInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BindSparseInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BindSparseInfoBuilder<'a> {
    #[inline]
    pub fn wait_semaphores(mut self, wait_semaphores: &'a [Semaphore]) -> Self {
        self.inner.wait_semaphore_count = wait_semaphores.len() as _;
        self.inner.p_wait_semaphores = wait_semaphores.as_ptr();
        self
    }
    #[inline]
    pub fn buffer_binds(mut self, buffer_binds: &'a [SparseBufferMemoryBindInfo]) -> Self {
        self.inner.buffer_bind_count = buffer_binds.len() as _;
        self.inner.p_buffer_binds = buffer_binds.as_ptr();
        self
    }
    #[inline]
    pub fn image_opaque_binds(
        mut self,
        image_opaque_binds: &'a [SparseImageOpaqueMemoryBindInfo],
    ) -> Self {
        self.inner.image_opaque_bind_count = image_opaque_binds.len() as _;
        self.inner.p_image_opaque_binds = image_opaque_binds.as_ptr();
        self
    }
    #[inline]
    pub fn image_binds(mut self, image_binds: &'a [SparseImageMemoryBindInfo]) -> Self {
        self.inner.image_bind_count = image_binds.len() as _;
        self.inner.p_image_binds = image_binds.as_ptr();
        self
    }
    #[inline]
    pub fn signal_semaphores(mut self, signal_semaphores: &'a [Semaphore]) -> Self {
        self.inner.signal_semaphore_count = signal_semaphores.len() as _;
        self.inner.p_signal_semaphores = signal_semaphores.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsBindSparseInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BindSparseInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCopy.html>"]
pub struct ImageCopy {
    pub src_subresource: ImageSubresourceLayers,
    pub src_offset: Offset3D,
    pub dst_subresource: ImageSubresourceLayers,
    pub dst_offset: Offset3D,
    pub extent: Extent3D,
}
impl ImageCopy {
    pub fn builder<'a>() -> ImageCopyBuilder<'a> {
        ImageCopyBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageCopyBuilder<'a> {
    inner: ImageCopy,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ImageCopyBuilder<'a> {
    type Target = ImageCopy;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageCopyBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageCopyBuilder<'a> {
    #[inline]
    pub fn src_subresource(mut self, src_subresource: ImageSubresourceLayers) -> Self {
        self.inner.src_subresource = src_subresource;
        self
    }
    #[inline]
    pub fn src_offset(mut self, src_offset: Offset3D) -> Self {
        self.inner.src_offset = src_offset;
        self
    }
    #[inline]
    pub fn dst_subresource(mut self, dst_subresource: ImageSubresourceLayers) -> Self {
        self.inner.dst_subresource = dst_subresource;
        self
    }
    #[inline]
    pub fn dst_offset(mut self, dst_offset: Offset3D) -> Self {
        self.inner.dst_offset = dst_offset;
        self
    }
    #[inline]
    pub fn extent(mut self, extent: Extent3D) -> Self {
        self.inner.extent = extent;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageCopy {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageBlit.html>"]
pub struct ImageBlit {
    pub src_subresource: ImageSubresourceLayers,
    pub src_offsets: [Offset3D; 2],
    pub dst_subresource: ImageSubresourceLayers,
    pub dst_offsets: [Offset3D; 2],
}
impl ::std::default::Default for ImageBlit {
    #[inline]
    fn default() -> Self {
        Self {
            src_subresource: ImageSubresourceLayers::default(),
            src_offsets: unsafe { ::std::mem::zeroed() },
            dst_subresource: ImageSubresourceLayers::default(),
            dst_offsets: unsafe { ::std::mem::zeroed() },
        }
    }
}
impl ImageBlit {
    pub fn builder<'a>() -> ImageBlitBuilder<'a> {
        ImageBlitBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageBlitBuilder<'a> {
    inner: ImageBlit,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ImageBlitBuilder<'a> {
    type Target = ImageBlit;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageBlitBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageBlitBuilder<'a> {
    #[inline]
    pub fn src_subresource(mut self, src_subresource: ImageSubresourceLayers) -> Self {
        self.inner.src_subresource = src_subresource;
        self
    }
    #[inline]
    pub fn src_offsets(mut self, src_offsets: [Offset3D; 2]) -> Self {
        self.inner.src_offsets = src_offsets;
        self
    }
    #[inline]
    pub fn dst_subresource(mut self, dst_subresource: ImageSubresourceLayers) -> Self {
        self.inner.dst_subresource = dst_subresource;
        self
    }
    #[inline]
    pub fn dst_offsets(mut self, dst_offsets: [Offset3D; 2]) -> Self {
        self.inner.dst_offsets = dst_offsets;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageBlit {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferImageCopy.html>"]
pub struct BufferImageCopy {
    pub buffer_offset: DeviceSize,
    pub buffer_row_length: u32,
    pub buffer_image_height: u32,
    pub image_subresource: ImageSubresourceLayers,
    pub image_offset: Offset3D,
    pub image_extent: Extent3D,
}
impl BufferImageCopy {
    pub fn builder<'a>() -> BufferImageCopyBuilder<'a> {
        BufferImageCopyBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BufferImageCopyBuilder<'a> {
    inner: BufferImageCopy,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for BufferImageCopyBuilder<'a> {
    type Target = BufferImageCopy;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BufferImageCopyBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BufferImageCopyBuilder<'a> {
    #[inline]
    pub fn buffer_offset(mut self, buffer_offset: DeviceSize) -> Self {
        self.inner.buffer_offset = buffer_offset;
        self
    }
    #[inline]
    pub fn buffer_row_length(mut self, buffer_row_length: u32) -> Self {
        self.inner.buffer_row_length = buffer_row_length;
        self
    }
    #[inline]
    pub fn buffer_image_height(mut self, buffer_image_height: u32) -> Self {
        self.inner.buffer_image_height = buffer_image_height;
        self
    }
    #[inline]
    pub fn image_subresource(mut self, image_subresource: ImageSubresourceLayers) -> Self {
        self.inner.image_subresource = image_subresource;
        self
    }
    #[inline]
    pub fn image_offset(mut self, image_offset: Offset3D) -> Self {
        self.inner.image_offset = image_offset;
        self
    }
    #[inline]
    pub fn image_extent(mut self, image_extent: Extent3D) -> Self {
        self.inner.image_extent = image_extent;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BufferImageCopy {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyMemoryIndirectCommandNV.html>"]
pub struct CopyMemoryIndirectCommandNV {
    pub src_address: DeviceAddress,
    pub dst_address: DeviceAddress,
    pub size: DeviceSize,
}
impl CopyMemoryIndirectCommandNV {
    pub fn builder<'a>() -> CopyMemoryIndirectCommandNVBuilder<'a> {
        CopyMemoryIndirectCommandNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CopyMemoryIndirectCommandNVBuilder<'a> {
    inner: CopyMemoryIndirectCommandNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CopyMemoryIndirectCommandNVBuilder<'a> {
    type Target = CopyMemoryIndirectCommandNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CopyMemoryIndirectCommandNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CopyMemoryIndirectCommandNVBuilder<'a> {
    #[inline]
    pub fn src_address(mut self, src_address: DeviceAddress) -> Self {
        self.inner.src_address = src_address;
        self
    }
    #[inline]
    pub fn dst_address(mut self, dst_address: DeviceAddress) -> Self {
        self.inner.dst_address = dst_address;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CopyMemoryIndirectCommandNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyMemoryToImageIndirectCommandNV.html>"]
pub struct CopyMemoryToImageIndirectCommandNV {
    pub src_address: DeviceAddress,
    pub buffer_row_length: u32,
    pub buffer_image_height: u32,
    pub image_subresource: ImageSubresourceLayers,
    pub image_offset: Offset3D,
    pub image_extent: Extent3D,
}
impl CopyMemoryToImageIndirectCommandNV {
    pub fn builder<'a>() -> CopyMemoryToImageIndirectCommandNVBuilder<'a> {
        CopyMemoryToImageIndirectCommandNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CopyMemoryToImageIndirectCommandNVBuilder<'a> {
    inner: CopyMemoryToImageIndirectCommandNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CopyMemoryToImageIndirectCommandNVBuilder<'a> {
    type Target = CopyMemoryToImageIndirectCommandNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CopyMemoryToImageIndirectCommandNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CopyMemoryToImageIndirectCommandNVBuilder<'a> {
    #[inline]
    pub fn src_address(mut self, src_address: DeviceAddress) -> Self {
        self.inner.src_address = src_address;
        self
    }
    #[inline]
    pub fn buffer_row_length(mut self, buffer_row_length: u32) -> Self {
        self.inner.buffer_row_length = buffer_row_length;
        self
    }
    #[inline]
    pub fn buffer_image_height(mut self, buffer_image_height: u32) -> Self {
        self.inner.buffer_image_height = buffer_image_height;
        self
    }
    #[inline]
    pub fn image_subresource(mut self, image_subresource: ImageSubresourceLayers) -> Self {
        self.inner.image_subresource = image_subresource;
        self
    }
    #[inline]
    pub fn image_offset(mut self, image_offset: Offset3D) -> Self {
        self.inner.image_offset = image_offset;
        self
    }
    #[inline]
    pub fn image_extent(mut self, image_extent: Extent3D) -> Self {
        self.inner.image_extent = image_extent;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CopyMemoryToImageIndirectCommandNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageResolve.html>"]
pub struct ImageResolve {
    pub src_subresource: ImageSubresourceLayers,
    pub src_offset: Offset3D,
    pub dst_subresource: ImageSubresourceLayers,
    pub dst_offset: Offset3D,
    pub extent: Extent3D,
}
impl ImageResolve {
    pub fn builder<'a>() -> ImageResolveBuilder<'a> {
        ImageResolveBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageResolveBuilder<'a> {
    inner: ImageResolve,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ImageResolveBuilder<'a> {
    type Target = ImageResolve;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageResolveBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageResolveBuilder<'a> {
    #[inline]
    pub fn src_subresource(mut self, src_subresource: ImageSubresourceLayers) -> Self {
        self.inner.src_subresource = src_subresource;
        self
    }
    #[inline]
    pub fn src_offset(mut self, src_offset: Offset3D) -> Self {
        self.inner.src_offset = src_offset;
        self
    }
    #[inline]
    pub fn dst_subresource(mut self, dst_subresource: ImageSubresourceLayers) -> Self {
        self.inner.dst_subresource = dst_subresource;
        self
    }
    #[inline]
    pub fn dst_offset(mut self, dst_offset: Offset3D) -> Self {
        self.inner.dst_offset = dst_offset;
        self
    }
    #[inline]
    pub fn extent(mut self, extent: Extent3D) -> Self {
        self.inner.extent = extent;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageResolve {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderModuleCreateInfo.html>"]
pub struct ShaderModuleCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ShaderModuleCreateFlags,
    pub code_size: usize,
    pub p_code: *const u32,
}
impl ::std::default::Default for ShaderModuleCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: ShaderModuleCreateFlags::default(),
            code_size: usize::default(),
            p_code: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for ShaderModuleCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::SHADER_MODULE_CREATE_INFO;
}
impl ShaderModuleCreateInfo {
    pub fn builder<'a>() -> ShaderModuleCreateInfoBuilder<'a> {
        ShaderModuleCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ShaderModuleCreateInfoBuilder<'a> {
    inner: ShaderModuleCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPipelineShaderStageCreateInfo for ShaderModuleCreateInfoBuilder<'_> {}
unsafe impl ExtendsPipelineShaderStageCreateInfo for ShaderModuleCreateInfo {}
pub unsafe trait ExtendsShaderModuleCreateInfo {}
impl<'a> ::std::ops::Deref for ShaderModuleCreateInfoBuilder<'a> {
    type Target = ShaderModuleCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ShaderModuleCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ShaderModuleCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: ShaderModuleCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn code(mut self, code: &'a [u32]) -> Self {
        self.inner.code_size = code.len() * 4;
        self.inner.p_code = code.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsShaderModuleCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ShaderModuleCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutBinding.html>"]
pub struct DescriptorSetLayoutBinding {
    pub binding: u32,
    pub descriptor_type: DescriptorType,
    pub descriptor_count: u32,
    pub stage_flags: ShaderStageFlags,
    pub p_immutable_samplers: *const Sampler,
}
impl ::std::default::Default for DescriptorSetLayoutBinding {
    #[inline]
    fn default() -> Self {
        Self {
            binding: u32::default(),
            descriptor_type: DescriptorType::default(),
            descriptor_count: u32::default(),
            stage_flags: ShaderStageFlags::default(),
            p_immutable_samplers: ::std::ptr::null(),
        }
    }
}
impl DescriptorSetLayoutBinding {
    pub fn builder<'a>() -> DescriptorSetLayoutBindingBuilder<'a> {
        DescriptorSetLayoutBindingBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DescriptorSetLayoutBindingBuilder<'a> {
    inner: DescriptorSetLayoutBinding,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DescriptorSetLayoutBindingBuilder<'a> {
    type Target = DescriptorSetLayoutBinding;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DescriptorSetLayoutBindingBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DescriptorSetLayoutBindingBuilder<'a> {
    #[inline]
    pub fn binding(mut self, binding: u32) -> Self {
        self.inner.binding = binding;
        self
    }
    #[inline]
    pub fn descriptor_type(mut self, descriptor_type: DescriptorType) -> Self {
        self.inner.descriptor_type = descriptor_type;
        self
    }
    #[inline]
    pub fn descriptor_count(mut self, descriptor_count: u32) -> Self {
        self.inner.descriptor_count = descriptor_count;
        self
    }
    #[inline]
    pub fn stage_flags(mut self, stage_flags: ShaderStageFlags) -> Self {
        self.inner.stage_flags = stage_flags;
        self
    }
    #[inline]
    pub fn immutable_samplers(mut self, immutable_samplers: &'a [Sampler]) -> Self {
        self.inner.descriptor_count = immutable_samplers.len() as _;
        self.inner.p_immutable_samplers = immutable_samplers.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DescriptorSetLayoutBinding {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutCreateInfo.html>"]
pub struct DescriptorSetLayoutCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DescriptorSetLayoutCreateFlags,
    pub binding_count: u32,
    pub p_bindings: *const DescriptorSetLayoutBinding,
}
impl ::std::default::Default for DescriptorSetLayoutCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DescriptorSetLayoutCreateFlags::default(),
            binding_count: u32::default(),
            p_bindings: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for DescriptorSetLayoutCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
}
impl DescriptorSetLayoutCreateInfo {
    pub fn builder<'a>() -> DescriptorSetLayoutCreateInfoBuilder<'a> {
        DescriptorSetLayoutCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DescriptorSetLayoutCreateInfoBuilder<'a> {
    inner: DescriptorSetLayoutCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsDescriptorSetLayoutCreateInfo {}
impl<'a> ::std::ops::Deref for DescriptorSetLayoutCreateInfoBuilder<'a> {
    type Target = DescriptorSetLayoutCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DescriptorSetLayoutCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DescriptorSetLayoutCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: DescriptorSetLayoutCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn bindings(mut self, bindings: &'a [DescriptorSetLayoutBinding]) -> Self {
        self.inner.binding_count = bindings.len() as _;
        self.inner.p_bindings = bindings.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsDescriptorSetLayoutCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DescriptorSetLayoutCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolSize.html>"]
pub struct DescriptorPoolSize {
    pub ty: DescriptorType,
    pub descriptor_count: u32,
}
impl DescriptorPoolSize {
    pub fn builder<'a>() -> DescriptorPoolSizeBuilder<'a> {
        DescriptorPoolSizeBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DescriptorPoolSizeBuilder<'a> {
    inner: DescriptorPoolSize,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DescriptorPoolSizeBuilder<'a> {
    type Target = DescriptorPoolSize;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DescriptorPoolSizeBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DescriptorPoolSizeBuilder<'a> {
    #[inline]
    pub fn ty(mut self, ty: DescriptorType) -> Self {
        self.inner.ty = ty;
        self
    }
    #[inline]
    pub fn descriptor_count(mut self, descriptor_count: u32) -> Self {
        self.inner.descriptor_count = descriptor_count;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DescriptorPoolSize {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolCreateInfo.html>"]
pub struct DescriptorPoolCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DescriptorPoolCreateFlags,
    pub max_sets: u32,
    pub pool_size_count: u32,
    pub p_pool_sizes: *const DescriptorPoolSize,
}
impl ::std::default::Default for DescriptorPoolCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DescriptorPoolCreateFlags::default(),
            max_sets: u32::default(),
            pool_size_count: u32::default(),
            p_pool_sizes: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for DescriptorPoolCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::DESCRIPTOR_POOL_CREATE_INFO;
}
impl DescriptorPoolCreateInfo {
    pub fn builder<'a>() -> DescriptorPoolCreateInfoBuilder<'a> {
        DescriptorPoolCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DescriptorPoolCreateInfoBuilder<'a> {
    inner: DescriptorPoolCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsDescriptorPoolCreateInfo {}
impl<'a> ::std::ops::Deref for DescriptorPoolCreateInfoBuilder<'a> {
    type Target = DescriptorPoolCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DescriptorPoolCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DescriptorPoolCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: DescriptorPoolCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn max_sets(mut self, max_sets: u32) -> Self {
        self.inner.max_sets = max_sets;
        self
    }
    #[inline]
    pub fn pool_sizes(mut self, pool_sizes: &'a [DescriptorPoolSize]) -> Self {
        self.inner.pool_size_count = pool_sizes.len() as _;
        self.inner.p_pool_sizes = pool_sizes.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsDescriptorPoolCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DescriptorPoolCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetAllocateInfo.html>"]
pub struct DescriptorSetAllocateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub descriptor_pool: DescriptorPool,
    pub descriptor_set_count: u32,
    pub p_set_layouts: *const DescriptorSetLayout,
}
impl ::std::default::Default for DescriptorSetAllocateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            descriptor_pool: DescriptorPool::default(),
            descriptor_set_count: u32::default(),
            p_set_layouts: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for DescriptorSetAllocateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::DESCRIPTOR_SET_ALLOCATE_INFO;
}
impl DescriptorSetAllocateInfo {
    pub fn builder<'a>() -> DescriptorSetAllocateInfoBuilder<'a> {
        DescriptorSetAllocateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DescriptorSetAllocateInfoBuilder<'a> {
    inner: DescriptorSetAllocateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsDescriptorSetAllocateInfo {}
impl<'a> ::std::ops::Deref for DescriptorSetAllocateInfoBuilder<'a> {
    type Target = DescriptorSetAllocateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DescriptorSetAllocateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DescriptorSetAllocateInfoBuilder<'a> {
    #[inline]
    pub fn descriptor_pool(mut self, descriptor_pool: DescriptorPool) -> Self {
        self.inner.descriptor_pool = descriptor_pool;
        self
    }
    #[inline]
    pub fn set_layouts(mut self, set_layouts: &'a [DescriptorSetLayout]) -> Self {
        self.inner.descriptor_set_count = set_layouts.len() as _;
        self.inner.p_set_layouts = set_layouts.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsDescriptorSetAllocateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DescriptorSetAllocateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSpecializationMapEntry.html>"]
pub struct SpecializationMapEntry {
    pub constant_id: u32,
    pub offset: u32,
    pub size: usize,
}
impl SpecializationMapEntry {
    pub fn builder<'a>() -> SpecializationMapEntryBuilder<'a> {
        SpecializationMapEntryBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SpecializationMapEntryBuilder<'a> {
    inner: SpecializationMapEntry,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SpecializationMapEntryBuilder<'a> {
    type Target = SpecializationMapEntry;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SpecializationMapEntryBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SpecializationMapEntryBuilder<'a> {
    #[inline]
    pub fn constant_id(mut self, constant_id: u32) -> Self {
        self.inner.constant_id = constant_id;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: u32) -> Self {
        self.inner.offset = offset;
        self
    }
    #[inline]
    pub fn size(mut self, size: usize) -> Self {
        self.inner.size = size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SpecializationMapEntry {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSpecializationInfo.html>"]
pub struct SpecializationInfo {
    pub map_entry_count: u32,
    pub p_map_entries: *const SpecializationMapEntry,
    pub data_size: usize,
    pub p_data: *const c_void,
}
impl ::std::default::Default for SpecializationInfo {
    #[inline]
    fn default() -> Self {
        Self {
            map_entry_count: u32::default(),
            p_map_entries: ::std::ptr::null(),
            data_size: usize::default(),
            p_data: ::std::ptr::null(),
        }
    }
}
impl SpecializationInfo {
    pub fn builder<'a>() -> SpecializationInfoBuilder<'a> {
        SpecializationInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SpecializationInfoBuilder<'a> {
    inner: SpecializationInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SpecializationInfoBuilder<'a> {
    type Target = SpecializationInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SpecializationInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SpecializationInfoBuilder<'a> {
    #[inline]
    pub fn map_entries(mut self, map_entries: &'a [SpecializationMapEntry]) -> Self {
        self.inner.map_entry_count = map_entries.len() as _;
        self.inner.p_map_entries = map_entries.as_ptr();
        self
    }
    #[inline]
    pub fn data(mut self, data: &'a [u8]) -> Self {
        self.inner.data_size = data.len();
        self.inner.p_data = data.as_ptr().cast();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SpecializationInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageCreateInfo.html>"]
pub struct PipelineShaderStageCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineShaderStageCreateFlags,
    pub stage: ShaderStageFlags,
    pub module: ShaderModule,
    pub p_name: *const c_char,
    pub p_specialization_info: *const SpecializationInfo,
}
impl ::std::default::Default for PipelineShaderStageCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineShaderStageCreateFlags::default(),
            stage: ShaderStageFlags::default(),
            module: ShaderModule::default(),
            p_name: ::std::ptr::null(),
            p_specialization_info: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for PipelineShaderStageCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_SHADER_STAGE_CREATE_INFO;
}
impl PipelineShaderStageCreateInfo {
    pub fn builder<'a>() -> PipelineShaderStageCreateInfoBuilder<'a> {
        PipelineShaderStageCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineShaderStageCreateInfoBuilder<'a> {
    inner: PipelineShaderStageCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsPipelineShaderStageCreateInfo {}
impl<'a> ::std::ops::Deref for PipelineShaderStageCreateInfoBuilder<'a> {
    type Target = PipelineShaderStageCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineShaderStageCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineShaderStageCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineShaderStageCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn stage(mut self, stage: ShaderStageFlags) -> Self {
        self.inner.stage = stage;
        self
    }
    #[inline]
    pub fn module(mut self, module: ShaderModule) -> Self {
        self.inner.module = module;
        self
    }
    #[inline]
    pub fn name(mut self, name: &'a ::std::ffi::CStr) -> Self {
        self.inner.p_name = name.as_ptr();
        self
    }
    #[inline]
    pub fn specialization_info(mut self, specialization_info: &'a SpecializationInfo) -> Self {
        self.inner.p_specialization_info = specialization_info;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPipelineShaderStageCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineShaderStageCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkComputePipelineCreateInfo.html>"]
pub struct ComputePipelineCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineCreateFlags,
    pub stage: PipelineShaderStageCreateInfo,
    pub layout: PipelineLayout,
    pub base_pipeline_handle: Pipeline,
    pub base_pipeline_index: i32,
}
impl ::std::default::Default for ComputePipelineCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineCreateFlags::default(),
            stage: PipelineShaderStageCreateInfo::default(),
            layout: PipelineLayout::default(),
            base_pipeline_handle: Pipeline::default(),
            base_pipeline_index: i32::default(),
        }
    }
}
unsafe impl TaggedStructure for ComputePipelineCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::COMPUTE_PIPELINE_CREATE_INFO;
}
impl ComputePipelineCreateInfo {
    pub fn builder<'a>() -> ComputePipelineCreateInfoBuilder<'a> {
        ComputePipelineCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ComputePipelineCreateInfoBuilder<'a> {
    inner: ComputePipelineCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsComputePipelineCreateInfo {}
impl<'a> ::std::ops::Deref for ComputePipelineCreateInfoBuilder<'a> {
    type Target = ComputePipelineCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ComputePipelineCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ComputePipelineCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn stage(mut self, stage: PipelineShaderStageCreateInfo) -> Self {
        self.inner.stage = stage;
        self
    }
    #[inline]
    pub fn layout(mut self, layout: PipelineLayout) -> Self {
        self.inner.layout = layout;
        self
    }
    #[inline]
    pub fn base_pipeline_handle(mut self, base_pipeline_handle: Pipeline) -> Self {
        self.inner.base_pipeline_handle = base_pipeline_handle;
        self
    }
    #[inline]
    pub fn base_pipeline_index(mut self, base_pipeline_index: i32) -> Self {
        self.inner.base_pipeline_index = base_pipeline_index;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsComputePipelineCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ComputePipelineCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVertexInputBindingDescription.html>"]
pub struct VertexInputBindingDescription {
    pub binding: u32,
    pub stride: u32,
    pub input_rate: VertexInputRate,
}
impl VertexInputBindingDescription {
    pub fn builder<'a>() -> VertexInputBindingDescriptionBuilder<'a> {
        VertexInputBindingDescriptionBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VertexInputBindingDescriptionBuilder<'a> {
    inner: VertexInputBindingDescription,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for VertexInputBindingDescriptionBuilder<'a> {
    type Target = VertexInputBindingDescription;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VertexInputBindingDescriptionBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VertexInputBindingDescriptionBuilder<'a> {
    #[inline]
    pub fn binding(mut self, binding: u32) -> Self {
        self.inner.binding = binding;
        self
    }
    #[inline]
    pub fn stride(mut self, stride: u32) -> Self {
        self.inner.stride = stride;
        self
    }
    #[inline]
    pub fn input_rate(mut self, input_rate: VertexInputRate) -> Self {
        self.inner.input_rate = input_rate;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VertexInputBindingDescription {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVertexInputAttributeDescription.html>"]
pub struct VertexInputAttributeDescription {
    pub location: u32,
    pub binding: u32,
    pub format: Format,
    pub offset: u32,
}
impl VertexInputAttributeDescription {
    pub fn builder<'a>() -> VertexInputAttributeDescriptionBuilder<'a> {
        VertexInputAttributeDescriptionBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VertexInputAttributeDescriptionBuilder<'a> {
    inner: VertexInputAttributeDescription,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for VertexInputAttributeDescriptionBuilder<'a> {
    type Target = VertexInputAttributeDescription;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VertexInputAttributeDescriptionBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VertexInputAttributeDescriptionBuilder<'a> {
    #[inline]
    pub fn location(mut self, location: u32) -> Self {
        self.inner.location = location;
        self
    }
    #[inline]
    pub fn binding(mut self, binding: u32) -> Self {
        self.inner.binding = binding;
        self
    }
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.inner.format = format;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: u32) -> Self {
        self.inner.offset = offset;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VertexInputAttributeDescription {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineVertexInputStateCreateInfo.html>"]
pub struct PipelineVertexInputStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineVertexInputStateCreateFlags,
    pub vertex_binding_description_count: u32,
    pub p_vertex_binding_descriptions: *const VertexInputBindingDescription,
    pub vertex_attribute_description_count: u32,
    pub p_vertex_attribute_descriptions: *const VertexInputAttributeDescription,
}
impl ::std::default::Default for PipelineVertexInputStateCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineVertexInputStateCreateFlags::default(),
            vertex_binding_description_count: u32::default(),
            p_vertex_binding_descriptions: ::std::ptr::null(),
            vertex_attribute_description_count: u32::default(),
            p_vertex_attribute_descriptions: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for PipelineVertexInputStateCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
}
impl PipelineVertexInputStateCreateInfo {
    pub fn builder<'a>() -> PipelineVertexInputStateCreateInfoBuilder<'a> {
        PipelineVertexInputStateCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineVertexInputStateCreateInfoBuilder<'a> {
    inner: PipelineVertexInputStateCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsPipelineVertexInputStateCreateInfo {}
impl<'a> ::std::ops::Deref for PipelineVertexInputStateCreateInfoBuilder<'a> {
    type Target = PipelineVertexInputStateCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineVertexInputStateCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineVertexInputStateCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineVertexInputStateCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn vertex_binding_descriptions(
        mut self,
        vertex_binding_descriptions: &'a [VertexInputBindingDescription],
    ) -> Self {
        self.inner.vertex_binding_description_count = vertex_binding_descriptions.len() as _;
        self.inner.p_vertex_binding_descriptions = vertex_binding_descriptions.as_ptr();
        self
    }
    #[inline]
    pub fn vertex_attribute_descriptions(
        mut self,
        vertex_attribute_descriptions: &'a [VertexInputAttributeDescription],
    ) -> Self {
        self.inner.vertex_attribute_description_count = vertex_attribute_descriptions.len() as _;
        self.inner.p_vertex_attribute_descriptions = vertex_attribute_descriptions.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPipelineVertexInputStateCreateInfo>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineVertexInputStateCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineInputAssemblyStateCreateInfo.html>"]
pub struct PipelineInputAssemblyStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineInputAssemblyStateCreateFlags,
    pub topology: PrimitiveTopology,
    pub primitive_restart_enable: Bool32,
}
impl ::std::default::Default for PipelineInputAssemblyStateCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineInputAssemblyStateCreateFlags::default(),
            topology: PrimitiveTopology::default(),
            primitive_restart_enable: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineInputAssemblyStateCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
}
impl PipelineInputAssemblyStateCreateInfo {
    pub fn builder<'a>() -> PipelineInputAssemblyStateCreateInfoBuilder<'a> {
        PipelineInputAssemblyStateCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineInputAssemblyStateCreateInfoBuilder<'a> {
    inner: PipelineInputAssemblyStateCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PipelineInputAssemblyStateCreateInfoBuilder<'a> {
    type Target = PipelineInputAssemblyStateCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineInputAssemblyStateCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineInputAssemblyStateCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineInputAssemblyStateCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn topology(mut self, topology: PrimitiveTopology) -> Self {
        self.inner.topology = topology;
        self
    }
    #[inline]
    pub fn primitive_restart_enable(mut self, primitive_restart_enable: bool) -> Self {
        self.inner.primitive_restart_enable = primitive_restart_enable.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineInputAssemblyStateCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineTessellationStateCreateInfo.html>"]
pub struct PipelineTessellationStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineTessellationStateCreateFlags,
    pub patch_control_points: u32,
}
impl ::std::default::Default for PipelineTessellationStateCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineTessellationStateCreateFlags::default(),
            patch_control_points: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineTessellationStateCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_TESSELLATION_STATE_CREATE_INFO;
}
impl PipelineTessellationStateCreateInfo {
    pub fn builder<'a>() -> PipelineTessellationStateCreateInfoBuilder<'a> {
        PipelineTessellationStateCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineTessellationStateCreateInfoBuilder<'a> {
    inner: PipelineTessellationStateCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsPipelineTessellationStateCreateInfo {}
impl<'a> ::std::ops::Deref for PipelineTessellationStateCreateInfoBuilder<'a> {
    type Target = PipelineTessellationStateCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineTessellationStateCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineTessellationStateCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineTessellationStateCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn patch_control_points(mut self, patch_control_points: u32) -> Self {
        self.inner.patch_control_points = patch_control_points;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPipelineTessellationStateCreateInfo>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineTessellationStateCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportStateCreateInfo.html>"]
pub struct PipelineViewportStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineViewportStateCreateFlags,
    pub viewport_count: u32,
    pub p_viewports: *const Viewport,
    pub scissor_count: u32,
    pub p_scissors: *const Rect2D,
}
impl ::std::default::Default for PipelineViewportStateCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineViewportStateCreateFlags::default(),
            viewport_count: u32::default(),
            p_viewports: ::std::ptr::null(),
            scissor_count: u32::default(),
            p_scissors: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for PipelineViewportStateCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_VIEWPORT_STATE_CREATE_INFO;
}
impl PipelineViewportStateCreateInfo {
    pub fn builder<'a>() -> PipelineViewportStateCreateInfoBuilder<'a> {
        PipelineViewportStateCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineViewportStateCreateInfoBuilder<'a> {
    inner: PipelineViewportStateCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsPipelineViewportStateCreateInfo {}
impl<'a> ::std::ops::Deref for PipelineViewportStateCreateInfoBuilder<'a> {
    type Target = PipelineViewportStateCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineViewportStateCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineViewportStateCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineViewportStateCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn viewport_count(mut self, viewport_count: u32) -> Self {
        self.inner.viewport_count = viewport_count;
        self
    }
    #[inline]
    pub fn viewports(mut self, viewports: &'a [Viewport]) -> Self {
        self.inner.viewport_count = viewports.len() as _;
        self.inner.p_viewports = viewports.as_ptr();
        self
    }
    #[inline]
    pub fn scissor_count(mut self, scissor_count: u32) -> Self {
        self.inner.scissor_count = scissor_count;
        self
    }
    #[inline]
    pub fn scissors(mut self, scissors: &'a [Rect2D]) -> Self {
        self.inner.scissor_count = scissors.len() as _;
        self.inner.p_scissors = scissors.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPipelineViewportStateCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineViewportStateCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateCreateInfo.html>"]
pub struct PipelineRasterizationStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineRasterizationStateCreateFlags,
    pub depth_clamp_enable: Bool32,
    pub rasterizer_discard_enable: Bool32,
    pub polygon_mode: PolygonMode,
    pub cull_mode: CullModeFlags,
    pub front_face: FrontFace,
    pub depth_bias_enable: Bool32,
    pub depth_bias_constant_factor: f32,
    pub depth_bias_clamp: f32,
    pub depth_bias_slope_factor: f32,
    pub line_width: f32,
}
impl ::std::default::Default for PipelineRasterizationStateCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineRasterizationStateCreateFlags::default(),
            depth_clamp_enable: Bool32::default(),
            rasterizer_discard_enable: Bool32::default(),
            polygon_mode: PolygonMode::default(),
            cull_mode: CullModeFlags::default(),
            front_face: FrontFace::default(),
            depth_bias_enable: Bool32::default(),
            depth_bias_constant_factor: f32::default(),
            depth_bias_clamp: f32::default(),
            depth_bias_slope_factor: f32::default(),
            line_width: f32::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineRasterizationStateCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
}
impl PipelineRasterizationStateCreateInfo {
    pub fn builder<'a>() -> PipelineRasterizationStateCreateInfoBuilder<'a> {
        PipelineRasterizationStateCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineRasterizationStateCreateInfoBuilder<'a> {
    inner: PipelineRasterizationStateCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsPipelineRasterizationStateCreateInfo {}
impl<'a> ::std::ops::Deref for PipelineRasterizationStateCreateInfoBuilder<'a> {
    type Target = PipelineRasterizationStateCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineRasterizationStateCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineRasterizationStateCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineRasterizationStateCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn depth_clamp_enable(mut self, depth_clamp_enable: bool) -> Self {
        self.inner.depth_clamp_enable = depth_clamp_enable.into();
        self
    }
    #[inline]
    pub fn rasterizer_discard_enable(mut self, rasterizer_discard_enable: bool) -> Self {
        self.inner.rasterizer_discard_enable = rasterizer_discard_enable.into();
        self
    }
    #[inline]
    pub fn polygon_mode(mut self, polygon_mode: PolygonMode) -> Self {
        self.inner.polygon_mode = polygon_mode;
        self
    }
    #[inline]
    pub fn cull_mode(mut self, cull_mode: CullModeFlags) -> Self {
        self.inner.cull_mode = cull_mode;
        self
    }
    #[inline]
    pub fn front_face(mut self, front_face: FrontFace) -> Self {
        self.inner.front_face = front_face;
        self
    }
    #[inline]
    pub fn depth_bias_enable(mut self, depth_bias_enable: bool) -> Self {
        self.inner.depth_bias_enable = depth_bias_enable.into();
        self
    }
    #[inline]
    pub fn depth_bias_constant_factor(mut self, depth_bias_constant_factor: f32) -> Self {
        self.inner.depth_bias_constant_factor = depth_bias_constant_factor;
        self
    }
    #[inline]
    pub fn depth_bias_clamp(mut self, depth_bias_clamp: f32) -> Self {
        self.inner.depth_bias_clamp = depth_bias_clamp;
        self
    }
    #[inline]
    pub fn depth_bias_slope_factor(mut self, depth_bias_slope_factor: f32) -> Self {
        self.inner.depth_bias_slope_factor = depth_bias_slope_factor;
        self
    }
    #[inline]
    pub fn line_width(mut self, line_width: f32) -> Self {
        self.inner.line_width = line_width;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPipelineRasterizationStateCreateInfo>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineRasterizationStateCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineMultisampleStateCreateInfo.html>"]
pub struct PipelineMultisampleStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineMultisampleStateCreateFlags,
    pub rasterization_samples: SampleCountFlags,
    pub sample_shading_enable: Bool32,
    pub min_sample_shading: f32,
    pub p_sample_mask: *const SampleMask,
    pub alpha_to_coverage_enable: Bool32,
    pub alpha_to_one_enable: Bool32,
}
impl ::std::default::Default for PipelineMultisampleStateCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineMultisampleStateCreateFlags::default(),
            rasterization_samples: SampleCountFlags::default(),
            sample_shading_enable: Bool32::default(),
            min_sample_shading: f32::default(),
            p_sample_mask: ::std::ptr::null(),
            alpha_to_coverage_enable: Bool32::default(),
            alpha_to_one_enable: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineMultisampleStateCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
}
impl PipelineMultisampleStateCreateInfo {
    pub fn builder<'a>() -> PipelineMultisampleStateCreateInfoBuilder<'a> {
        PipelineMultisampleStateCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineMultisampleStateCreateInfoBuilder<'a> {
    inner: PipelineMultisampleStateCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsPipelineMultisampleStateCreateInfo {}
impl<'a> ::std::ops::Deref for PipelineMultisampleStateCreateInfoBuilder<'a> {
    type Target = PipelineMultisampleStateCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineMultisampleStateCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineMultisampleStateCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineMultisampleStateCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn rasterization_samples(mut self, rasterization_samples: SampleCountFlags) -> Self {
        self.inner.rasterization_samples = rasterization_samples;
        self
    }
    #[inline]
    pub fn sample_shading_enable(mut self, sample_shading_enable: bool) -> Self {
        self.inner.sample_shading_enable = sample_shading_enable.into();
        self
    }
    #[inline]
    pub fn min_sample_shading(mut self, min_sample_shading: f32) -> Self {
        self.inner.min_sample_shading = min_sample_shading;
        self
    }
    #[doc = r" Sets `p_sample_mask` to `null` if the slice is empty. The mask will"]
    #[doc = r" be treated as if it has all bits set to `1`."]
    #[doc = r""]
    #[doc = r" See <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineMultisampleStateCreateInfo.html#_description>"]
    #[doc = r" for more details."]
    #[inline]
    pub fn sample_mask(mut self, sample_mask: &'a [SampleMask]) -> Self {
        self.inner.p_sample_mask = if sample_mask.is_empty() {
            std::ptr::null()
        } else {
            sample_mask.as_ptr()
        };
        self
    }
    #[inline]
    pub fn alpha_to_coverage_enable(mut self, alpha_to_coverage_enable: bool) -> Self {
        self.inner.alpha_to_coverage_enable = alpha_to_coverage_enable.into();
        self
    }
    #[inline]
    pub fn alpha_to_one_enable(mut self, alpha_to_one_enable: bool) -> Self {
        self.inner.alpha_to_one_enable = alpha_to_one_enable.into();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPipelineMultisampleStateCreateInfo>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineMultisampleStateCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineColorBlendAttachmentState.html>"]
pub struct PipelineColorBlendAttachmentState {
    pub blend_enable: Bool32,
    pub src_color_blend_factor: BlendFactor,
    pub dst_color_blend_factor: BlendFactor,
    pub color_blend_op: BlendOp,
    pub src_alpha_blend_factor: BlendFactor,
    pub dst_alpha_blend_factor: BlendFactor,
    pub alpha_blend_op: BlendOp,
    pub color_write_mask: ColorComponentFlags,
}
impl PipelineColorBlendAttachmentState {
    pub fn builder<'a>() -> PipelineColorBlendAttachmentStateBuilder<'a> {
        PipelineColorBlendAttachmentStateBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineColorBlendAttachmentStateBuilder<'a> {
    inner: PipelineColorBlendAttachmentState,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PipelineColorBlendAttachmentStateBuilder<'a> {
    type Target = PipelineColorBlendAttachmentState;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineColorBlendAttachmentStateBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineColorBlendAttachmentStateBuilder<'a> {
    #[inline]
    pub fn blend_enable(mut self, blend_enable: bool) -> Self {
        self.inner.blend_enable = blend_enable.into();
        self
    }
    #[inline]
    pub fn src_color_blend_factor(mut self, src_color_blend_factor: BlendFactor) -> Self {
        self.inner.src_color_blend_factor = src_color_blend_factor;
        self
    }
    #[inline]
    pub fn dst_color_blend_factor(mut self, dst_color_blend_factor: BlendFactor) -> Self {
        self.inner.dst_color_blend_factor = dst_color_blend_factor;
        self
    }
    #[inline]
    pub fn color_blend_op(mut self, color_blend_op: BlendOp) -> Self {
        self.inner.color_blend_op = color_blend_op;
        self
    }
    #[inline]
    pub fn src_alpha_blend_factor(mut self, src_alpha_blend_factor: BlendFactor) -> Self {
        self.inner.src_alpha_blend_factor = src_alpha_blend_factor;
        self
    }
    #[inline]
    pub fn dst_alpha_blend_factor(mut self, dst_alpha_blend_factor: BlendFactor) -> Self {
        self.inner.dst_alpha_blend_factor = dst_alpha_blend_factor;
        self
    }
    #[inline]
    pub fn alpha_blend_op(mut self, alpha_blend_op: BlendOp) -> Self {
        self.inner.alpha_blend_op = alpha_blend_op;
        self
    }
    #[inline]
    pub fn color_write_mask(mut self, color_write_mask: ColorComponentFlags) -> Self {
        self.inner.color_write_mask = color_write_mask;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineColorBlendAttachmentState {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineColorBlendStateCreateInfo.html>"]
pub struct PipelineColorBlendStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineColorBlendStateCreateFlags,
    pub logic_op_enable: Bool32,
    pub logic_op: LogicOp,
    pub attachment_count: u32,
    pub p_attachments: *const PipelineColorBlendAttachmentState,
    pub blend_constants: [f32; 4],
}
impl ::std::default::Default for PipelineColorBlendStateCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineColorBlendStateCreateFlags::default(),
            logic_op_enable: Bool32::default(),
            logic_op: LogicOp::default(),
            attachment_count: u32::default(),
            p_attachments: ::std::ptr::null(),
            blend_constants: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for PipelineColorBlendStateCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
}
impl PipelineColorBlendStateCreateInfo {
    pub fn builder<'a>() -> PipelineColorBlendStateCreateInfoBuilder<'a> {
        PipelineColorBlendStateCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineColorBlendStateCreateInfoBuilder<'a> {
    inner: PipelineColorBlendStateCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsPipelineColorBlendStateCreateInfo {}
impl<'a> ::std::ops::Deref for PipelineColorBlendStateCreateInfoBuilder<'a> {
    type Target = PipelineColorBlendStateCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineColorBlendStateCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineColorBlendStateCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineColorBlendStateCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn logic_op_enable(mut self, logic_op_enable: bool) -> Self {
        self.inner.logic_op_enable = logic_op_enable.into();
        self
    }
    #[inline]
    pub fn logic_op(mut self, logic_op: LogicOp) -> Self {
        self.inner.logic_op = logic_op;
        self
    }
    #[inline]
    pub fn attachments(mut self, attachments: &'a [PipelineColorBlendAttachmentState]) -> Self {
        self.inner.attachment_count = attachments.len() as _;
        self.inner.p_attachments = attachments.as_ptr();
        self
    }
    #[inline]
    pub fn blend_constants(mut self, blend_constants: [f32; 4]) -> Self {
        self.inner.blend_constants = blend_constants;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPipelineColorBlendStateCreateInfo>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineColorBlendStateCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDynamicStateCreateInfo.html>"]
pub struct PipelineDynamicStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineDynamicStateCreateFlags,
    pub dynamic_state_count: u32,
    pub p_dynamic_states: *const DynamicState,
}
impl ::std::default::Default for PipelineDynamicStateCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineDynamicStateCreateFlags::default(),
            dynamic_state_count: u32::default(),
            p_dynamic_states: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for PipelineDynamicStateCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_DYNAMIC_STATE_CREATE_INFO;
}
impl PipelineDynamicStateCreateInfo {
    pub fn builder<'a>() -> PipelineDynamicStateCreateInfoBuilder<'a> {
        PipelineDynamicStateCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineDynamicStateCreateInfoBuilder<'a> {
    inner: PipelineDynamicStateCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PipelineDynamicStateCreateInfoBuilder<'a> {
    type Target = PipelineDynamicStateCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineDynamicStateCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineDynamicStateCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineDynamicStateCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn dynamic_states(mut self, dynamic_states: &'a [DynamicState]) -> Self {
        self.inner.dynamic_state_count = dynamic_states.len() as _;
        self.inner.p_dynamic_states = dynamic_states.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineDynamicStateCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStencilOpState.html>"]
pub struct StencilOpState {
    pub fail_op: StencilOp,
    pub pass_op: StencilOp,
    pub depth_fail_op: StencilOp,
    pub compare_op: CompareOp,
    pub compare_mask: u32,
    pub write_mask: u32,
    pub reference: u32,
}
impl StencilOpState {
    pub fn builder<'a>() -> StencilOpStateBuilder<'a> {
        StencilOpStateBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct StencilOpStateBuilder<'a> {
    inner: StencilOpState,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for StencilOpStateBuilder<'a> {
    type Target = StencilOpState;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for StencilOpStateBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> StencilOpStateBuilder<'a> {
    #[inline]
    pub fn fail_op(mut self, fail_op: StencilOp) -> Self {
        self.inner.fail_op = fail_op;
        self
    }
    #[inline]
    pub fn pass_op(mut self, pass_op: StencilOp) -> Self {
        self.inner.pass_op = pass_op;
        self
    }
    #[inline]
    pub fn depth_fail_op(mut self, depth_fail_op: StencilOp) -> Self {
        self.inner.depth_fail_op = depth_fail_op;
        self
    }
    #[inline]
    pub fn compare_op(mut self, compare_op: CompareOp) -> Self {
        self.inner.compare_op = compare_op;
        self
    }
    #[inline]
    pub fn compare_mask(mut self, compare_mask: u32) -> Self {
        self.inner.compare_mask = compare_mask;
        self
    }
    #[inline]
    pub fn write_mask(mut self, write_mask: u32) -> Self {
        self.inner.write_mask = write_mask;
        self
    }
    #[inline]
    pub fn reference(mut self, reference: u32) -> Self {
        self.inner.reference = reference;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> StencilOpState {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDepthStencilStateCreateInfo.html>"]
pub struct PipelineDepthStencilStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineDepthStencilStateCreateFlags,
    pub depth_test_enable: Bool32,
    pub depth_write_enable: Bool32,
    pub depth_compare_op: CompareOp,
    pub depth_bounds_test_enable: Bool32,
    pub stencil_test_enable: Bool32,
    pub front: StencilOpState,
    pub back: StencilOpState,
    pub min_depth_bounds: f32,
    pub max_depth_bounds: f32,
}
impl ::std::default::Default for PipelineDepthStencilStateCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineDepthStencilStateCreateFlags::default(),
            depth_test_enable: Bool32::default(),
            depth_write_enable: Bool32::default(),
            depth_compare_op: CompareOp::default(),
            depth_bounds_test_enable: Bool32::default(),
            stencil_test_enable: Bool32::default(),
            front: StencilOpState::default(),
            back: StencilOpState::default(),
            min_depth_bounds: f32::default(),
            max_depth_bounds: f32::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineDepthStencilStateCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
}
impl PipelineDepthStencilStateCreateInfo {
    pub fn builder<'a>() -> PipelineDepthStencilStateCreateInfoBuilder<'a> {
        PipelineDepthStencilStateCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineDepthStencilStateCreateInfoBuilder<'a> {
    inner: PipelineDepthStencilStateCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PipelineDepthStencilStateCreateInfoBuilder<'a> {
    type Target = PipelineDepthStencilStateCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineDepthStencilStateCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineDepthStencilStateCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineDepthStencilStateCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn depth_test_enable(mut self, depth_test_enable: bool) -> Self {
        self.inner.depth_test_enable = depth_test_enable.into();
        self
    }
    #[inline]
    pub fn depth_write_enable(mut self, depth_write_enable: bool) -> Self {
        self.inner.depth_write_enable = depth_write_enable.into();
        self
    }
    #[inline]
    pub fn depth_compare_op(mut self, depth_compare_op: CompareOp) -> Self {
        self.inner.depth_compare_op = depth_compare_op;
        self
    }
    #[inline]
    pub fn depth_bounds_test_enable(mut self, depth_bounds_test_enable: bool) -> Self {
        self.inner.depth_bounds_test_enable = depth_bounds_test_enable.into();
        self
    }
    #[inline]
    pub fn stencil_test_enable(mut self, stencil_test_enable: bool) -> Self {
        self.inner.stencil_test_enable = stencil_test_enable.into();
        self
    }
    #[inline]
    pub fn front(mut self, front: StencilOpState) -> Self {
        self.inner.front = front;
        self
    }
    #[inline]
    pub fn back(mut self, back: StencilOpState) -> Self {
        self.inner.back = back;
        self
    }
    #[inline]
    pub fn min_depth_bounds(mut self, min_depth_bounds: f32) -> Self {
        self.inner.min_depth_bounds = min_depth_bounds;
        self
    }
    #[inline]
    pub fn max_depth_bounds(mut self, max_depth_bounds: f32) -> Self {
        self.inner.max_depth_bounds = max_depth_bounds;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineDepthStencilStateCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGraphicsPipelineCreateInfo.html>"]
pub struct GraphicsPipelineCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineCreateFlags,
    pub stage_count: u32,
    pub p_stages: *const PipelineShaderStageCreateInfo,
    pub p_vertex_input_state: *const PipelineVertexInputStateCreateInfo,
    pub p_input_assembly_state: *const PipelineInputAssemblyStateCreateInfo,
    pub p_tessellation_state: *const PipelineTessellationStateCreateInfo,
    pub p_viewport_state: *const PipelineViewportStateCreateInfo,
    pub p_rasterization_state: *const PipelineRasterizationStateCreateInfo,
    pub p_multisample_state: *const PipelineMultisampleStateCreateInfo,
    pub p_depth_stencil_state: *const PipelineDepthStencilStateCreateInfo,
    pub p_color_blend_state: *const PipelineColorBlendStateCreateInfo,
    pub p_dynamic_state: *const PipelineDynamicStateCreateInfo,
    pub layout: PipelineLayout,
    pub render_pass: RenderPass,
    pub subpass: u32,
    pub base_pipeline_handle: Pipeline,
    pub base_pipeline_index: i32,
}
impl ::std::default::Default for GraphicsPipelineCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineCreateFlags::default(),
            stage_count: u32::default(),
            p_stages: ::std::ptr::null(),
            p_vertex_input_state: ::std::ptr::null(),
            p_input_assembly_state: ::std::ptr::null(),
            p_tessellation_state: ::std::ptr::null(),
            p_viewport_state: ::std::ptr::null(),
            p_rasterization_state: ::std::ptr::null(),
            p_multisample_state: ::std::ptr::null(),
            p_depth_stencil_state: ::std::ptr::null(),
            p_color_blend_state: ::std::ptr::null(),
            p_dynamic_state: ::std::ptr::null(),
            layout: PipelineLayout::default(),
            render_pass: RenderPass::default(),
            subpass: u32::default(),
            base_pipeline_handle: Pipeline::default(),
            base_pipeline_index: i32::default(),
        }
    }
}
unsafe impl TaggedStructure for GraphicsPipelineCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::GRAPHICS_PIPELINE_CREATE_INFO;
}
impl GraphicsPipelineCreateInfo {
    pub fn builder<'a>() -> GraphicsPipelineCreateInfoBuilder<'a> {
        GraphicsPipelineCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct GraphicsPipelineCreateInfoBuilder<'a> {
    inner: GraphicsPipelineCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsGraphicsPipelineCreateInfo {}
impl<'a> ::std::ops::Deref for GraphicsPipelineCreateInfoBuilder<'a> {
    type Target = GraphicsPipelineCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for GraphicsPipelineCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> GraphicsPipelineCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn stages(mut self, stages: &'a [PipelineShaderStageCreateInfo]) -> Self {
        self.inner.stage_count = stages.len() as _;
        self.inner.p_stages = stages.as_ptr();
        self
    }
    #[inline]
    pub fn vertex_input_state(
        mut self,
        vertex_input_state: &'a PipelineVertexInputStateCreateInfo,
    ) -> Self {
        self.inner.p_vertex_input_state = vertex_input_state;
        self
    }
    #[inline]
    pub fn input_assembly_state(
        mut self,
        input_assembly_state: &'a PipelineInputAssemblyStateCreateInfo,
    ) -> Self {
        self.inner.p_input_assembly_state = input_assembly_state;
        self
    }
    #[inline]
    pub fn tessellation_state(
        mut self,
        tessellation_state: &'a PipelineTessellationStateCreateInfo,
    ) -> Self {
        self.inner.p_tessellation_state = tessellation_state;
        self
    }
    #[inline]
    pub fn viewport_state(mut self, viewport_state: &'a PipelineViewportStateCreateInfo) -> Self {
        self.inner.p_viewport_state = viewport_state;
        self
    }
    #[inline]
    pub fn rasterization_state(
        mut self,
        rasterization_state: &'a PipelineRasterizationStateCreateInfo,
    ) -> Self {
        self.inner.p_rasterization_state = rasterization_state;
        self
    }
    #[inline]
    pub fn multisample_state(
        mut self,
        multisample_state: &'a PipelineMultisampleStateCreateInfo,
    ) -> Self {
        self.inner.p_multisample_state = multisample_state;
        self
    }
    #[inline]
    pub fn depth_stencil_state(
        mut self,
        depth_stencil_state: &'a PipelineDepthStencilStateCreateInfo,
    ) -> Self {
        self.inner.p_depth_stencil_state = depth_stencil_state;
        self
    }
    #[inline]
    pub fn color_blend_state(
        mut self,
        color_blend_state: &'a PipelineColorBlendStateCreateInfo,
    ) -> Self {
        self.inner.p_color_blend_state = color_blend_state;
        self
    }
    #[inline]
    pub fn dynamic_state(mut self, dynamic_state: &'a PipelineDynamicStateCreateInfo) -> Self {
        self.inner.p_dynamic_state = dynamic_state;
        self
    }
    #[inline]
    pub fn layout(mut self, layout: PipelineLayout) -> Self {
        self.inner.layout = layout;
        self
    }
    #[inline]
    pub fn render_pass(mut self, render_pass: RenderPass) -> Self {
        self.inner.render_pass = render_pass;
        self
    }
    #[inline]
    pub fn subpass(mut self, subpass: u32) -> Self {
        self.inner.subpass = subpass;
        self
    }
    #[inline]
    pub fn base_pipeline_handle(mut self, base_pipeline_handle: Pipeline) -> Self {
        self.inner.base_pipeline_handle = base_pipeline_handle;
        self
    }
    #[inline]
    pub fn base_pipeline_index(mut self, base_pipeline_index: i32) -> Self {
        self.inner.base_pipeline_index = base_pipeline_index;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsGraphicsPipelineCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> GraphicsPipelineCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCacheCreateInfo.html>"]
pub struct PipelineCacheCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineCacheCreateFlags,
    pub initial_data_size: usize,
    pub p_initial_data: *const c_void,
}
impl ::std::default::Default for PipelineCacheCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineCacheCreateFlags::default(),
            initial_data_size: usize::default(),
            p_initial_data: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for PipelineCacheCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_CACHE_CREATE_INFO;
}
impl PipelineCacheCreateInfo {
    pub fn builder<'a>() -> PipelineCacheCreateInfoBuilder<'a> {
        PipelineCacheCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineCacheCreateInfoBuilder<'a> {
    inner: PipelineCacheCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PipelineCacheCreateInfoBuilder<'a> {
    type Target = PipelineCacheCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineCacheCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineCacheCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineCacheCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn initial_data(mut self, initial_data: &'a [u8]) -> Self {
        self.inner.initial_data_size = initial_data.len();
        self.inner.p_initial_data = initial_data.as_ptr().cast();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineCacheCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCacheHeaderVersionOne.html>"]
pub struct PipelineCacheHeaderVersionOne {
    pub header_size: u32,
    pub header_version: PipelineCacheHeaderVersion,
    pub vendor_id: u32,
    pub device_id: u32,
    pub pipeline_cache_uuid: [u8; UUID_SIZE],
}
impl ::std::default::Default for PipelineCacheHeaderVersionOne {
    #[inline]
    fn default() -> Self {
        Self {
            header_size: u32::default(),
            header_version: PipelineCacheHeaderVersion::default(),
            vendor_id: u32::default(),
            device_id: u32::default(),
            pipeline_cache_uuid: unsafe { ::std::mem::zeroed() },
        }
    }
}
impl PipelineCacheHeaderVersionOne {
    pub fn builder<'a>() -> PipelineCacheHeaderVersionOneBuilder<'a> {
        PipelineCacheHeaderVersionOneBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineCacheHeaderVersionOneBuilder<'a> {
    inner: PipelineCacheHeaderVersionOne,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PipelineCacheHeaderVersionOneBuilder<'a> {
    type Target = PipelineCacheHeaderVersionOne;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineCacheHeaderVersionOneBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineCacheHeaderVersionOneBuilder<'a> {
    #[inline]
    pub fn header_size(mut self, header_size: u32) -> Self {
        self.inner.header_size = header_size;
        self
    }
    #[inline]
    pub fn header_version(mut self, header_version: PipelineCacheHeaderVersion) -> Self {
        self.inner.header_version = header_version;
        self
    }
    #[inline]
    pub fn vendor_id(mut self, vendor_id: u32) -> Self {
        self.inner.vendor_id = vendor_id;
        self
    }
    #[inline]
    pub fn device_id(mut self, device_id: u32) -> Self {
        self.inner.device_id = device_id;
        self
    }
    #[inline]
    pub fn pipeline_cache_uuid(mut self, pipeline_cache_uuid: [u8; UUID_SIZE]) -> Self {
        self.inner.pipeline_cache_uuid = pipeline_cache_uuid;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineCacheHeaderVersionOne {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPushConstantRange.html>"]
pub struct PushConstantRange {
    pub stage_flags: ShaderStageFlags,
    pub offset: u32,
    pub size: u32,
}
impl PushConstantRange {
    pub fn builder<'a>() -> PushConstantRangeBuilder<'a> {
        PushConstantRangeBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PushConstantRangeBuilder<'a> {
    inner: PushConstantRange,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PushConstantRangeBuilder<'a> {
    type Target = PushConstantRange;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PushConstantRangeBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PushConstantRangeBuilder<'a> {
    #[inline]
    pub fn stage_flags(mut self, stage_flags: ShaderStageFlags) -> Self {
        self.inner.stage_flags = stage_flags;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: u32) -> Self {
        self.inner.offset = offset;
        self
    }
    #[inline]
    pub fn size(mut self, size: u32) -> Self {
        self.inner.size = size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PushConstantRange {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineLayoutCreateInfo.html>"]
pub struct PipelineLayoutCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineLayoutCreateFlags,
    pub set_layout_count: u32,
    pub p_set_layouts: *const DescriptorSetLayout,
    pub push_constant_range_count: u32,
    pub p_push_constant_ranges: *const PushConstantRange,
}
impl ::std::default::Default for PipelineLayoutCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineLayoutCreateFlags::default(),
            set_layout_count: u32::default(),
            p_set_layouts: ::std::ptr::null(),
            push_constant_range_count: u32::default(),
            p_push_constant_ranges: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for PipelineLayoutCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_LAYOUT_CREATE_INFO;
}
impl PipelineLayoutCreateInfo {
    pub fn builder<'a>() -> PipelineLayoutCreateInfoBuilder<'a> {
        PipelineLayoutCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineLayoutCreateInfoBuilder<'a> {
    inner: PipelineLayoutCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PipelineLayoutCreateInfoBuilder<'a> {
    type Target = PipelineLayoutCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineLayoutCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineLayoutCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineLayoutCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn set_layouts(mut self, set_layouts: &'a [DescriptorSetLayout]) -> Self {
        self.inner.set_layout_count = set_layouts.len() as _;
        self.inner.p_set_layouts = set_layouts.as_ptr();
        self
    }
    #[inline]
    pub fn push_constant_ranges(mut self, push_constant_ranges: &'a [PushConstantRange]) -> Self {
        self.inner.push_constant_range_count = push_constant_ranges.len() as _;
        self.inner.p_push_constant_ranges = push_constant_ranges.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineLayoutCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerCreateInfo.html>"]
pub struct SamplerCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: SamplerCreateFlags,
    pub mag_filter: Filter,
    pub min_filter: Filter,
    pub mipmap_mode: SamplerMipmapMode,
    pub address_mode_u: SamplerAddressMode,
    pub address_mode_v: SamplerAddressMode,
    pub address_mode_w: SamplerAddressMode,
    pub mip_lod_bias: f32,
    pub anisotropy_enable: Bool32,
    pub max_anisotropy: f32,
    pub compare_enable: Bool32,
    pub compare_op: CompareOp,
    pub min_lod: f32,
    pub max_lod: f32,
    pub border_color: BorderColor,
    pub unnormalized_coordinates: Bool32,
}
impl ::std::default::Default for SamplerCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: SamplerCreateFlags::default(),
            mag_filter: Filter::default(),
            min_filter: Filter::default(),
            mipmap_mode: SamplerMipmapMode::default(),
            address_mode_u: SamplerAddressMode::default(),
            address_mode_v: SamplerAddressMode::default(),
            address_mode_w: SamplerAddressMode::default(),
            mip_lod_bias: f32::default(),
            anisotropy_enable: Bool32::default(),
            max_anisotropy: f32::default(),
            compare_enable: Bool32::default(),
            compare_op: CompareOp::default(),
            min_lod: f32::default(),
            max_lod: f32::default(),
            border_color: BorderColor::default(),
            unnormalized_coordinates: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for SamplerCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::SAMPLER_CREATE_INFO;
}
impl SamplerCreateInfo {
    pub fn builder<'a>() -> SamplerCreateInfoBuilder<'a> {
        SamplerCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SamplerCreateInfoBuilder<'a> {
    inner: SamplerCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsSamplerCreateInfo {}
impl<'a> ::std::ops::Deref for SamplerCreateInfoBuilder<'a> {
    type Target = SamplerCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SamplerCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SamplerCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: SamplerCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn mag_filter(mut self, mag_filter: Filter) -> Self {
        self.inner.mag_filter = mag_filter;
        self
    }
    #[inline]
    pub fn min_filter(mut self, min_filter: Filter) -> Self {
        self.inner.min_filter = min_filter;
        self
    }
    #[inline]
    pub fn mipmap_mode(mut self, mipmap_mode: SamplerMipmapMode) -> Self {
        self.inner.mipmap_mode = mipmap_mode;
        self
    }
    #[inline]
    pub fn address_mode_u(mut self, address_mode_u: SamplerAddressMode) -> Self {
        self.inner.address_mode_u = address_mode_u;
        self
    }
    #[inline]
    pub fn address_mode_v(mut self, address_mode_v: SamplerAddressMode) -> Self {
        self.inner.address_mode_v = address_mode_v;
        self
    }
    #[inline]
    pub fn address_mode_w(mut self, address_mode_w: SamplerAddressMode) -> Self {
        self.inner.address_mode_w = address_mode_w;
        self
    }
    #[inline]
    pub fn mip_lod_bias(mut self, mip_lod_bias: f32) -> Self {
        self.inner.mip_lod_bias = mip_lod_bias;
        self
    }
    #[inline]
    pub fn anisotropy_enable(mut self, anisotropy_enable: bool) -> Self {
        self.inner.anisotropy_enable = anisotropy_enable.into();
        self
    }
    #[inline]
    pub fn max_anisotropy(mut self, max_anisotropy: f32) -> Self {
        self.inner.max_anisotropy = max_anisotropy;
        self
    }
    #[inline]
    pub fn compare_enable(mut self, compare_enable: bool) -> Self {
        self.inner.compare_enable = compare_enable.into();
        self
    }
    #[inline]
    pub fn compare_op(mut self, compare_op: CompareOp) -> Self {
        self.inner.compare_op = compare_op;
        self
    }
    #[inline]
    pub fn min_lod(mut self, min_lod: f32) -> Self {
        self.inner.min_lod = min_lod;
        self
    }
    #[inline]
    pub fn max_lod(mut self, max_lod: f32) -> Self {
        self.inner.max_lod = max_lod;
        self
    }
    #[inline]
    pub fn border_color(mut self, border_color: BorderColor) -> Self {
        self.inner.border_color = border_color;
        self
    }
    #[inline]
    pub fn unnormalized_coordinates(mut self, unnormalized_coordinates: bool) -> Self {
        self.inner.unnormalized_coordinates = unnormalized_coordinates.into();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsSamplerCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SamplerCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolCreateInfo.html>"]
pub struct CommandPoolCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: CommandPoolCreateFlags,
    pub queue_family_index: u32,
}
impl ::std::default::Default for CommandPoolCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: CommandPoolCreateFlags::default(),
            queue_family_index: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for CommandPoolCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::COMMAND_POOL_CREATE_INFO;
}
impl CommandPoolCreateInfo {
    pub fn builder<'a>() -> CommandPoolCreateInfoBuilder<'a> {
        CommandPoolCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CommandPoolCreateInfoBuilder<'a> {
    inner: CommandPoolCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CommandPoolCreateInfoBuilder<'a> {
    type Target = CommandPoolCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CommandPoolCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CommandPoolCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: CommandPoolCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn queue_family_index(mut self, queue_family_index: u32) -> Self {
        self.inner.queue_family_index = queue_family_index;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CommandPoolCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferAllocateInfo.html>"]
pub struct CommandBufferAllocateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub command_pool: CommandPool,
    pub level: CommandBufferLevel,
    pub command_buffer_count: u32,
}
impl ::std::default::Default for CommandBufferAllocateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            command_pool: CommandPool::default(),
            level: CommandBufferLevel::default(),
            command_buffer_count: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for CommandBufferAllocateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::COMMAND_BUFFER_ALLOCATE_INFO;
}
impl CommandBufferAllocateInfo {
    pub fn builder<'a>() -> CommandBufferAllocateInfoBuilder<'a> {
        CommandBufferAllocateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CommandBufferAllocateInfoBuilder<'a> {
    inner: CommandBufferAllocateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CommandBufferAllocateInfoBuilder<'a> {
    type Target = CommandBufferAllocateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CommandBufferAllocateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CommandBufferAllocateInfoBuilder<'a> {
    #[inline]
    pub fn command_pool(mut self, command_pool: CommandPool) -> Self {
        self.inner.command_pool = command_pool;
        self
    }
    #[inline]
    pub fn level(mut self, level: CommandBufferLevel) -> Self {
        self.inner.level = level;
        self
    }
    #[inline]
    pub fn command_buffer_count(mut self, command_buffer_count: u32) -> Self {
        self.inner.command_buffer_count = command_buffer_count;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CommandBufferAllocateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceInfo.html>"]
pub struct CommandBufferInheritanceInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub render_pass: RenderPass,
    pub subpass: u32,
    pub framebuffer: Framebuffer,
    pub occlusion_query_enable: Bool32,
    pub query_flags: QueryControlFlags,
    pub pipeline_statistics: QueryPipelineStatisticFlags,
}
impl ::std::default::Default for CommandBufferInheritanceInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            render_pass: RenderPass::default(),
            subpass: u32::default(),
            framebuffer: Framebuffer::default(),
            occlusion_query_enable: Bool32::default(),
            query_flags: QueryControlFlags::default(),
            pipeline_statistics: QueryPipelineStatisticFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for CommandBufferInheritanceInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::COMMAND_BUFFER_INHERITANCE_INFO;
}
impl CommandBufferInheritanceInfo {
    pub fn builder<'a>() -> CommandBufferInheritanceInfoBuilder<'a> {
        CommandBufferInheritanceInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CommandBufferInheritanceInfoBuilder<'a> {
    inner: CommandBufferInheritanceInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsCommandBufferInheritanceInfo {}
impl<'a> ::std::ops::Deref for CommandBufferInheritanceInfoBuilder<'a> {
    type Target = CommandBufferInheritanceInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CommandBufferInheritanceInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CommandBufferInheritanceInfoBuilder<'a> {
    #[inline]
    pub fn render_pass(mut self, render_pass: RenderPass) -> Self {
        self.inner.render_pass = render_pass;
        self
    }
    #[inline]
    pub fn subpass(mut self, subpass: u32) -> Self {
        self.inner.subpass = subpass;
        self
    }
    #[inline]
    pub fn framebuffer(mut self, framebuffer: Framebuffer) -> Self {
        self.inner.framebuffer = framebuffer;
        self
    }
    #[inline]
    pub fn occlusion_query_enable(mut self, occlusion_query_enable: bool) -> Self {
        self.inner.occlusion_query_enable = occlusion_query_enable.into();
        self
    }
    #[inline]
    pub fn query_flags(mut self, query_flags: QueryControlFlags) -> Self {
        self.inner.query_flags = query_flags;
        self
    }
    #[inline]
    pub fn pipeline_statistics(mut self, pipeline_statistics: QueryPipelineStatisticFlags) -> Self {
        self.inner.pipeline_statistics = pipeline_statistics;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsCommandBufferInheritanceInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CommandBufferInheritanceInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferBeginInfo.html>"]
pub struct CommandBufferBeginInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: CommandBufferUsageFlags,
    pub p_inheritance_info: *const CommandBufferInheritanceInfo,
}
impl ::std::default::Default for CommandBufferBeginInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: CommandBufferUsageFlags::default(),
            p_inheritance_info: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for CommandBufferBeginInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::COMMAND_BUFFER_BEGIN_INFO;
}
impl CommandBufferBeginInfo {
    pub fn builder<'a>() -> CommandBufferBeginInfoBuilder<'a> {
        CommandBufferBeginInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CommandBufferBeginInfoBuilder<'a> {
    inner: CommandBufferBeginInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsCommandBufferBeginInfo {}
impl<'a> ::std::ops::Deref for CommandBufferBeginInfoBuilder<'a> {
    type Target = CommandBufferBeginInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CommandBufferBeginInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CommandBufferBeginInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: CommandBufferUsageFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn inheritance_info(mut self, inheritance_info: &'a CommandBufferInheritanceInfo) -> Self {
        self.inner.p_inheritance_info = inheritance_info;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsCommandBufferBeginInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CommandBufferBeginInfo {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassBeginInfo.html>"]
pub struct RenderPassBeginInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub render_pass: RenderPass,
    pub framebuffer: Framebuffer,
    pub render_area: Rect2D,
    pub clear_value_count: u32,
    pub p_clear_values: *const ClearValue,
}
#[cfg(feature = "debug")]
impl fmt::Debug for RenderPassBeginInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassBeginInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("render_pass", &self.render_pass)
            .field("framebuffer", &self.framebuffer)
            .field("render_area", &self.render_area)
            .field("clear_value_count", &self.clear_value_count)
            .field("p_clear_values", &"union")
            .finish()
    }
}
impl ::std::default::Default for RenderPassBeginInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            render_pass: RenderPass::default(),
            framebuffer: Framebuffer::default(),
            render_area: Rect2D::default(),
            clear_value_count: u32::default(),
            p_clear_values: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for RenderPassBeginInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::RENDER_PASS_BEGIN_INFO;
}
impl RenderPassBeginInfo {
    pub fn builder<'a>() -> RenderPassBeginInfoBuilder<'a> {
        RenderPassBeginInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RenderPassBeginInfoBuilder<'a> {
    inner: RenderPassBeginInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsRenderPassBeginInfo {}
impl<'a> ::std::ops::Deref for RenderPassBeginInfoBuilder<'a> {
    type Target = RenderPassBeginInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RenderPassBeginInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RenderPassBeginInfoBuilder<'a> {
    #[inline]
    pub fn render_pass(mut self, render_pass: RenderPass) -> Self {
        self.inner.render_pass = render_pass;
        self
    }
    #[inline]
    pub fn framebuffer(mut self, framebuffer: Framebuffer) -> Self {
        self.inner.framebuffer = framebuffer;
        self
    }
    #[inline]
    pub fn render_area(mut self, render_area: Rect2D) -> Self {
        self.inner.render_area = render_area;
        self
    }
    #[inline]
    pub fn clear_values(mut self, clear_values: &'a [ClearValue]) -> Self {
        self.inner.clear_value_count = clear_values.len() as _;
        self.inner.p_clear_values = clear_values.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsRenderPassBeginInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RenderPassBeginInfo {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearColorValue.html>"]
pub union ClearColorValue {
    pub float32: [f32; 4],
    pub int32: [i32; 4],
    pub uint32: [u32; 4],
}
impl ::std::default::Default for ClearColorValue {
    #[inline]
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearDepthStencilValue.html>"]
pub struct ClearDepthStencilValue {
    pub depth: f32,
    pub stencil: u32,
}
impl ClearDepthStencilValue {
    pub fn builder<'a>() -> ClearDepthStencilValueBuilder<'a> {
        ClearDepthStencilValueBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ClearDepthStencilValueBuilder<'a> {
    inner: ClearDepthStencilValue,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ClearDepthStencilValueBuilder<'a> {
    type Target = ClearDepthStencilValue;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ClearDepthStencilValueBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ClearDepthStencilValueBuilder<'a> {
    #[inline]
    pub fn depth(mut self, depth: f32) -> Self {
        self.inner.depth = depth;
        self
    }
    #[inline]
    pub fn stencil(mut self, stencil: u32) -> Self {
        self.inner.stencil = stencil;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ClearDepthStencilValue {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearValue.html>"]
pub union ClearValue {
    pub color: ClearColorValue,
    pub depth_stencil: ClearDepthStencilValue,
}
impl ::std::default::Default for ClearValue {
    #[inline]
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearAttachment.html>"]
pub struct ClearAttachment {
    pub aspect_mask: ImageAspectFlags,
    pub color_attachment: u32,
    pub clear_value: ClearValue,
}
#[cfg(feature = "debug")]
impl fmt::Debug for ClearAttachment {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("ClearAttachment")
            .field("aspect_mask", &self.aspect_mask)
            .field("color_attachment", &self.color_attachment)
            .field("clear_value", &"union")
            .finish()
    }
}
impl ClearAttachment {
    pub fn builder<'a>() -> ClearAttachmentBuilder<'a> {
        ClearAttachmentBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ClearAttachmentBuilder<'a> {
    inner: ClearAttachment,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ClearAttachmentBuilder<'a> {
    type Target = ClearAttachment;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ClearAttachmentBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ClearAttachmentBuilder<'a> {
    #[inline]
    pub fn aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
        self.inner.aspect_mask = aspect_mask;
        self
    }
    #[inline]
    pub fn color_attachment(mut self, color_attachment: u32) -> Self {
        self.inner.color_attachment = color_attachment;
        self
    }
    #[inline]
    pub fn clear_value(mut self, clear_value: ClearValue) -> Self {
        self.inner.clear_value = clear_value;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ClearAttachment {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescription.html>"]
pub struct AttachmentDescription {
    pub flags: AttachmentDescriptionFlags,
    pub format: Format,
    pub samples: SampleCountFlags,
    pub load_op: AttachmentLoadOp,
    pub store_op: AttachmentStoreOp,
    pub stencil_load_op: AttachmentLoadOp,
    pub stencil_store_op: AttachmentStoreOp,
    pub initial_layout: ImageLayout,
    pub final_layout: ImageLayout,
}
impl AttachmentDescription {
    pub fn builder<'a>() -> AttachmentDescriptionBuilder<'a> {
        AttachmentDescriptionBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AttachmentDescriptionBuilder<'a> {
    inner: AttachmentDescription,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for AttachmentDescriptionBuilder<'a> {
    type Target = AttachmentDescription;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AttachmentDescriptionBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AttachmentDescriptionBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: AttachmentDescriptionFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.inner.format = format;
        self
    }
    #[inline]
    pub fn samples(mut self, samples: SampleCountFlags) -> Self {
        self.inner.samples = samples;
        self
    }
    #[inline]
    pub fn load_op(mut self, load_op: AttachmentLoadOp) -> Self {
        self.inner.load_op = load_op;
        self
    }
    #[inline]
    pub fn store_op(mut self, store_op: AttachmentStoreOp) -> Self {
        self.inner.store_op = store_op;
        self
    }
    #[inline]
    pub fn stencil_load_op(mut self, stencil_load_op: AttachmentLoadOp) -> Self {
        self.inner.stencil_load_op = stencil_load_op;
        self
    }
    #[inline]
    pub fn stencil_store_op(mut self, stencil_store_op: AttachmentStoreOp) -> Self {
        self.inner.stencil_store_op = stencil_store_op;
        self
    }
    #[inline]
    pub fn initial_layout(mut self, initial_layout: ImageLayout) -> Self {
        self.inner.initial_layout = initial_layout;
        self
    }
    #[inline]
    pub fn final_layout(mut self, final_layout: ImageLayout) -> Self {
        self.inner.final_layout = final_layout;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AttachmentDescription {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentReference.html>"]
pub struct AttachmentReference {
    pub attachment: u32,
    pub layout: ImageLayout,
}
impl AttachmentReference {
    pub fn builder<'a>() -> AttachmentReferenceBuilder<'a> {
        AttachmentReferenceBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AttachmentReferenceBuilder<'a> {
    inner: AttachmentReference,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for AttachmentReferenceBuilder<'a> {
    type Target = AttachmentReference;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AttachmentReferenceBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AttachmentReferenceBuilder<'a> {
    #[inline]
    pub fn attachment(mut self, attachment: u32) -> Self {
        self.inner.attachment = attachment;
        self
    }
    #[inline]
    pub fn layout(mut self, layout: ImageLayout) -> Self {
        self.inner.layout = layout;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AttachmentReference {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDescription.html>"]
pub struct SubpassDescription {
    pub flags: SubpassDescriptionFlags,
    pub pipeline_bind_point: PipelineBindPoint,
    pub input_attachment_count: u32,
    pub p_input_attachments: *const AttachmentReference,
    pub color_attachment_count: u32,
    pub p_color_attachments: *const AttachmentReference,
    pub p_resolve_attachments: *const AttachmentReference,
    pub p_depth_stencil_attachment: *const AttachmentReference,
    pub preserve_attachment_count: u32,
    pub p_preserve_attachments: *const u32,
}
impl ::std::default::Default for SubpassDescription {
    #[inline]
    fn default() -> Self {
        Self {
            flags: SubpassDescriptionFlags::default(),
            pipeline_bind_point: PipelineBindPoint::default(),
            input_attachment_count: u32::default(),
            p_input_attachments: ::std::ptr::null(),
            color_attachment_count: u32::default(),
            p_color_attachments: ::std::ptr::null(),
            p_resolve_attachments: ::std::ptr::null(),
            p_depth_stencil_attachment: ::std::ptr::null(),
            preserve_attachment_count: u32::default(),
            p_preserve_attachments: ::std::ptr::null(),
        }
    }
}
impl SubpassDescription {
    pub fn builder<'a>() -> SubpassDescriptionBuilder<'a> {
        SubpassDescriptionBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SubpassDescriptionBuilder<'a> {
    inner: SubpassDescription,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SubpassDescriptionBuilder<'a> {
    type Target = SubpassDescription;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SubpassDescriptionBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SubpassDescriptionBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: SubpassDescriptionFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn pipeline_bind_point(mut self, pipeline_bind_point: PipelineBindPoint) -> Self {
        self.inner.pipeline_bind_point = pipeline_bind_point;
        self
    }
    #[inline]
    pub fn input_attachments(mut self, input_attachments: &'a [AttachmentReference]) -> Self {
        self.inner.input_attachment_count = input_attachments.len() as _;
        self.inner.p_input_attachments = input_attachments.as_ptr();
        self
    }
    #[inline]
    pub fn color_attachments(mut self, color_attachments: &'a [AttachmentReference]) -> Self {
        self.inner.color_attachment_count = color_attachments.len() as _;
        self.inner.p_color_attachments = color_attachments.as_ptr();
        self
    }
    #[inline]
    pub fn resolve_attachments(mut self, resolve_attachments: &'a [AttachmentReference]) -> Self {
        self.inner.color_attachment_count = resolve_attachments.len() as _;
        self.inner.p_resolve_attachments = resolve_attachments.as_ptr();
        self
    }
    #[inline]
    pub fn depth_stencil_attachment(
        mut self,
        depth_stencil_attachment: &'a AttachmentReference,
    ) -> Self {
        self.inner.p_depth_stencil_attachment = depth_stencil_attachment;
        self
    }
    #[inline]
    pub fn preserve_attachments(mut self, preserve_attachments: &'a [u32]) -> Self {
        self.inner.preserve_attachment_count = preserve_attachments.len() as _;
        self.inner.p_preserve_attachments = preserve_attachments.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SubpassDescription {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDependency.html>"]
pub struct SubpassDependency {
    pub src_subpass: u32,
    pub dst_subpass: u32,
    pub src_stage_mask: PipelineStageFlags,
    pub dst_stage_mask: PipelineStageFlags,
    pub src_access_mask: AccessFlags,
    pub dst_access_mask: AccessFlags,
    pub dependency_flags: DependencyFlags,
}
impl SubpassDependency {
    pub fn builder<'a>() -> SubpassDependencyBuilder<'a> {
        SubpassDependencyBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SubpassDependencyBuilder<'a> {
    inner: SubpassDependency,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SubpassDependencyBuilder<'a> {
    type Target = SubpassDependency;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SubpassDependencyBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SubpassDependencyBuilder<'a> {
    #[inline]
    pub fn src_subpass(mut self, src_subpass: u32) -> Self {
        self.inner.src_subpass = src_subpass;
        self
    }
    #[inline]
    pub fn dst_subpass(mut self, dst_subpass: u32) -> Self {
        self.inner.dst_subpass = dst_subpass;
        self
    }
    #[inline]
    pub fn src_stage_mask(mut self, src_stage_mask: PipelineStageFlags) -> Self {
        self.inner.src_stage_mask = src_stage_mask;
        self
    }
    #[inline]
    pub fn dst_stage_mask(mut self, dst_stage_mask: PipelineStageFlags) -> Self {
        self.inner.dst_stage_mask = dst_stage_mask;
        self
    }
    #[inline]
    pub fn src_access_mask(mut self, src_access_mask: AccessFlags) -> Self {
        self.inner.src_access_mask = src_access_mask;
        self
    }
    #[inline]
    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags) -> Self {
        self.inner.dst_access_mask = dst_access_mask;
        self
    }
    #[inline]
    pub fn dependency_flags(mut self, dependency_flags: DependencyFlags) -> Self {
        self.inner.dependency_flags = dependency_flags;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SubpassDependency {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreateInfo.html>"]
pub struct RenderPassCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: RenderPassCreateFlags,
    pub attachment_count: u32,
    pub p_attachments: *const AttachmentDescription,
    pub subpass_count: u32,
    pub p_subpasses: *const SubpassDescription,
    pub dependency_count: u32,
    pub p_dependencies: *const SubpassDependency,
}
impl ::std::default::Default for RenderPassCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: RenderPassCreateFlags::default(),
            attachment_count: u32::default(),
            p_attachments: ::std::ptr::null(),
            subpass_count: u32::default(),
            p_subpasses: ::std::ptr::null(),
            dependency_count: u32::default(),
            p_dependencies: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for RenderPassCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::RENDER_PASS_CREATE_INFO;
}
impl RenderPassCreateInfo {
    pub fn builder<'a>() -> RenderPassCreateInfoBuilder<'a> {
        RenderPassCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RenderPassCreateInfoBuilder<'a> {
    inner: RenderPassCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsRenderPassCreateInfo {}
impl<'a> ::std::ops::Deref for RenderPassCreateInfoBuilder<'a> {
    type Target = RenderPassCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RenderPassCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RenderPassCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: RenderPassCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn attachments(mut self, attachments: &'a [AttachmentDescription]) -> Self {
        self.inner.attachment_count = attachments.len() as _;
        self.inner.p_attachments = attachments.as_ptr();
        self
    }
    #[inline]
    pub fn subpasses(mut self, subpasses: &'a [SubpassDescription]) -> Self {
        self.inner.subpass_count = subpasses.len() as _;
        self.inner.p_subpasses = subpasses.as_ptr();
        self
    }
    #[inline]
    pub fn dependencies(mut self, dependencies: &'a [SubpassDependency]) -> Self {
        self.inner.dependency_count = dependencies.len() as _;
        self.inner.p_dependencies = dependencies.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsRenderPassCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RenderPassCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkEventCreateInfo.html>"]
pub struct EventCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: EventCreateFlags,
}
impl ::std::default::Default for EventCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: EventCreateFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for EventCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::EVENT_CREATE_INFO;
}
impl EventCreateInfo {
    pub fn builder<'a>() -> EventCreateInfoBuilder<'a> {
        EventCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct EventCreateInfoBuilder<'a> {
    inner: EventCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsEventCreateInfo {}
impl<'a> ::std::ops::Deref for EventCreateInfoBuilder<'a> {
    type Target = EventCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for EventCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> EventCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: EventCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsEventCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> EventCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFenceCreateInfo.html>"]
pub struct FenceCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: FenceCreateFlags,
}
impl ::std::default::Default for FenceCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: FenceCreateFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for FenceCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::FENCE_CREATE_INFO;
}
impl FenceCreateInfo {
    pub fn builder<'a>() -> FenceCreateInfoBuilder<'a> {
        FenceCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct FenceCreateInfoBuilder<'a> {
    inner: FenceCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsFenceCreateInfo {}
impl<'a> ::std::ops::Deref for FenceCreateInfoBuilder<'a> {
    type Target = FenceCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for FenceCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> FenceCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: FenceCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsFenceCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> FenceCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html>"]
pub struct PhysicalDeviceFeatures {
    pub robust_buffer_access: Bool32,
    pub full_draw_index_uint32: Bool32,
    pub image_cube_array: Bool32,
    pub independent_blend: Bool32,
    pub geometry_shader: Bool32,
    pub tessellation_shader: Bool32,
    pub sample_rate_shading: Bool32,
    pub dual_src_blend: Bool32,
    pub logic_op: Bool32,
    pub multi_draw_indirect: Bool32,
    pub draw_indirect_first_instance: Bool32,
    pub depth_clamp: Bool32,
    pub depth_bias_clamp: Bool32,
    pub fill_mode_non_solid: Bool32,
    pub depth_bounds: Bool32,
    pub wide_lines: Bool32,
    pub large_points: Bool32,
    pub alpha_to_one: Bool32,
    pub multi_viewport: Bool32,
    pub sampler_anisotropy: Bool32,
    pub texture_compression_etc2: Bool32,
    pub texture_compression_astc_ldr: Bool32,
    pub texture_compression_bc: Bool32,
    pub occlusion_query_precise: Bool32,
    pub pipeline_statistics_query: Bool32,
    pub vertex_pipeline_stores_and_atomics: Bool32,
    pub fragment_stores_and_atomics: Bool32,
    pub shader_tessellation_and_geometry_point_size: Bool32,
    pub shader_image_gather_extended: Bool32,
    pub shader_storage_image_extended_formats: Bool32,
    pub shader_storage_image_multisample: Bool32,
    pub shader_storage_image_read_without_format: Bool32,
    pub shader_storage_image_write_without_format: Bool32,
    pub shader_uniform_buffer_array_dynamic_indexing: Bool32,
    pub shader_sampled_image_array_dynamic_indexing: Bool32,
    pub shader_storage_buffer_array_dynamic_indexing: Bool32,
    pub shader_storage_image_array_dynamic_indexing: Bool32,
    pub shader_clip_distance: Bool32,
    pub shader_cull_distance: Bool32,
    pub shader_float64: Bool32,
    pub shader_int64: Bool32,
    pub shader_int16: Bool32,
    pub shader_resource_residency: Bool32,
    pub shader_resource_min_lod: Bool32,
    pub sparse_binding: Bool32,
    pub sparse_residency_buffer: Bool32,
    pub sparse_residency_image2_d: Bool32,
    pub sparse_residency_image3_d: Bool32,
    pub sparse_residency2_samples: Bool32,
    pub sparse_residency4_samples: Bool32,
    pub sparse_residency8_samples: Bool32,
    pub sparse_residency16_samples: Bool32,
    pub sparse_residency_aliased: Bool32,
    pub variable_multisample_rate: Bool32,
    pub inherited_queries: Bool32,
}
impl PhysicalDeviceFeatures {
    pub fn builder<'a>() -> PhysicalDeviceFeaturesBuilder<'a> {
        PhysicalDeviceFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceFeaturesBuilder<'a> {
    inner: PhysicalDeviceFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PhysicalDeviceFeaturesBuilder<'a> {
    type Target = PhysicalDeviceFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceFeaturesBuilder<'a> {
    #[inline]
    pub fn robust_buffer_access(mut self, robust_buffer_access: bool) -> Self {
        self.inner.robust_buffer_access = robust_buffer_access.into();
        self
    }
    #[inline]
    pub fn full_draw_index_uint32(mut self, full_draw_index_uint32: bool) -> Self {
        self.inner.full_draw_index_uint32 = full_draw_index_uint32.into();
        self
    }
    #[inline]
    pub fn image_cube_array(mut self, image_cube_array: bool) -> Self {
        self.inner.image_cube_array = image_cube_array.into();
        self
    }
    #[inline]
    pub fn independent_blend(mut self, independent_blend: bool) -> Self {
        self.inner.independent_blend = independent_blend.into();
        self
    }
    #[inline]
    pub fn geometry_shader(mut self, geometry_shader: bool) -> Self {
        self.inner.geometry_shader = geometry_shader.into();
        self
    }
    #[inline]
    pub fn tessellation_shader(mut self, tessellation_shader: bool) -> Self {
        self.inner.tessellation_shader = tessellation_shader.into();
        self
    }
    #[inline]
    pub fn sample_rate_shading(mut self, sample_rate_shading: bool) -> Self {
        self.inner.sample_rate_shading = sample_rate_shading.into();
        self
    }
    #[inline]
    pub fn dual_src_blend(mut self, dual_src_blend: bool) -> Self {
        self.inner.dual_src_blend = dual_src_blend.into();
        self
    }
    #[inline]
    pub fn logic_op(mut self, logic_op: bool) -> Self {
        self.inner.logic_op = logic_op.into();
        self
    }
    #[inline]
    pub fn multi_draw_indirect(mut self, multi_draw_indirect: bool) -> Self {
        self.inner.multi_draw_indirect = multi_draw_indirect.into();
        self
    }
    #[inline]
    pub fn draw_indirect_first_instance(mut self, draw_indirect_first_instance: bool) -> Self {
        self.inner.draw_indirect_first_instance = draw_indirect_first_instance.into();
        self
    }
    #[inline]
    pub fn depth_clamp(mut self, depth_clamp: bool) -> Self {
        self.inner.depth_clamp = depth_clamp.into();
        self
    }
    #[inline]
    pub fn depth_bias_clamp(mut self, depth_bias_clamp: bool) -> Self {
        self.inner.depth_bias_clamp = depth_bias_clamp.into();
        self
    }
    #[inline]
    pub fn fill_mode_non_solid(mut self, fill_mode_non_solid: bool) -> Self {
        self.inner.fill_mode_non_solid = fill_mode_non_solid.into();
        self
    }
    #[inline]
    pub fn depth_bounds(mut self, depth_bounds: bool) -> Self {
        self.inner.depth_bounds = depth_bounds.into();
        self
    }
    #[inline]
    pub fn wide_lines(mut self, wide_lines: bool) -> Self {
        self.inner.wide_lines = wide_lines.into();
        self
    }
    #[inline]
    pub fn large_points(mut self, large_points: bool) -> Self {
        self.inner.large_points = large_points.into();
        self
    }
    #[inline]
    pub fn alpha_to_one(mut self, alpha_to_one: bool) -> Self {
        self.inner.alpha_to_one = alpha_to_one.into();
        self
    }
    #[inline]
    pub fn multi_viewport(mut self, multi_viewport: bool) -> Self {
        self.inner.multi_viewport = multi_viewport.into();
        self
    }
    #[inline]
    pub fn sampler_anisotropy(mut self, sampler_anisotropy: bool) -> Self {
        self.inner.sampler_anisotropy = sampler_anisotropy.into();
        self
    }
    #[inline]
    pub fn texture_compression_etc2(mut self, texture_compression_etc2: bool) -> Self {
        self.inner.texture_compression_etc2 = texture_compression_etc2.into();
        self
    }
    #[inline]
    pub fn texture_compression_astc_ldr(mut self, texture_compression_astc_ldr: bool) -> Self {
        self.inner.texture_compression_astc_ldr = texture_compression_astc_ldr.into();
        self
    }
    #[inline]
    pub fn texture_compression_bc(mut self, texture_compression_bc: bool) -> Self {
        self.inner.texture_compression_bc = texture_compression_bc.into();
        self
    }
    #[inline]
    pub fn occlusion_query_precise(mut self, occlusion_query_precise: bool) -> Self {
        self.inner.occlusion_query_precise = occlusion_query_precise.into();
        self
    }
    #[inline]
    pub fn pipeline_statistics_query(mut self, pipeline_statistics_query: bool) -> Self {
        self.inner.pipeline_statistics_query = pipeline_statistics_query.into();
        self
    }
    #[inline]
    pub fn vertex_pipeline_stores_and_atomics(
        mut self,
        vertex_pipeline_stores_and_atomics: bool,
    ) -> Self {
        self.inner.vertex_pipeline_stores_and_atomics = vertex_pipeline_stores_and_atomics.into();
        self
    }
    #[inline]
    pub fn fragment_stores_and_atomics(mut self, fragment_stores_and_atomics: bool) -> Self {
        self.inner.fragment_stores_and_atomics = fragment_stores_and_atomics.into();
        self
    }
    #[inline]
    pub fn shader_tessellation_and_geometry_point_size(
        mut self,
        shader_tessellation_and_geometry_point_size: bool,
    ) -> Self {
        self.inner.shader_tessellation_and_geometry_point_size =
            shader_tessellation_and_geometry_point_size.into();
        self
    }
    #[inline]
    pub fn shader_image_gather_extended(mut self, shader_image_gather_extended: bool) -> Self {
        self.inner.shader_image_gather_extended = shader_image_gather_extended.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_extended_formats(
        mut self,
        shader_storage_image_extended_formats: bool,
    ) -> Self {
        self.inner.shader_storage_image_extended_formats =
            shader_storage_image_extended_formats.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_multisample(
        mut self,
        shader_storage_image_multisample: bool,
    ) -> Self {
        self.inner.shader_storage_image_multisample = shader_storage_image_multisample.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_read_without_format(
        mut self,
        shader_storage_image_read_without_format: bool,
    ) -> Self {
        self.inner.shader_storage_image_read_without_format =
            shader_storage_image_read_without_format.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_write_without_format(
        mut self,
        shader_storage_image_write_without_format: bool,
    ) -> Self {
        self.inner.shader_storage_image_write_without_format =
            shader_storage_image_write_without_format.into();
        self
    }
    #[inline]
    pub fn shader_uniform_buffer_array_dynamic_indexing(
        mut self,
        shader_uniform_buffer_array_dynamic_indexing: bool,
    ) -> Self {
        self.inner.shader_uniform_buffer_array_dynamic_indexing =
            shader_uniform_buffer_array_dynamic_indexing.into();
        self
    }
    #[inline]
    pub fn shader_sampled_image_array_dynamic_indexing(
        mut self,
        shader_sampled_image_array_dynamic_indexing: bool,
    ) -> Self {
        self.inner.shader_sampled_image_array_dynamic_indexing =
            shader_sampled_image_array_dynamic_indexing.into();
        self
    }
    #[inline]
    pub fn shader_storage_buffer_array_dynamic_indexing(
        mut self,
        shader_storage_buffer_array_dynamic_indexing: bool,
    ) -> Self {
        self.inner.shader_storage_buffer_array_dynamic_indexing =
            shader_storage_buffer_array_dynamic_indexing.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_array_dynamic_indexing(
        mut self,
        shader_storage_image_array_dynamic_indexing: bool,
    ) -> Self {
        self.inner.shader_storage_image_array_dynamic_indexing =
            shader_storage_image_array_dynamic_indexing.into();
        self
    }
    #[inline]
    pub fn shader_clip_distance(mut self, shader_clip_distance: bool) -> Self {
        self.inner.shader_clip_distance = shader_clip_distance.into();
        self
    }
    #[inline]
    pub fn shader_cull_distance(mut self, shader_cull_distance: bool) -> Self {
        self.inner.shader_cull_distance = shader_cull_distance.into();
        self
    }
    #[inline]
    pub fn shader_float64(mut self, shader_float64: bool) -> Self {
        self.inner.shader_float64 = shader_float64.into();
        self
    }
    #[inline]
    pub fn shader_int64(mut self, shader_int64: bool) -> Self {
        self.inner.shader_int64 = shader_int64.into();
        self
    }
    #[inline]
    pub fn shader_int16(mut self, shader_int16: bool) -> Self {
        self.inner.shader_int16 = shader_int16.into();
        self
    }
    #[inline]
    pub fn shader_resource_residency(mut self, shader_resource_residency: bool) -> Self {
        self.inner.shader_resource_residency = shader_resource_residency.into();
        self
    }
    #[inline]
    pub fn shader_resource_min_lod(mut self, shader_resource_min_lod: bool) -> Self {
        self.inner.shader_resource_min_lod = shader_resource_min_lod.into();
        self
    }
    #[inline]
    pub fn sparse_binding(mut self, sparse_binding: bool) -> Self {
        self.inner.sparse_binding = sparse_binding.into();
        self
    }
    #[inline]
    pub fn sparse_residency_buffer(mut self, sparse_residency_buffer: bool) -> Self {
        self.inner.sparse_residency_buffer = sparse_residency_buffer.into();
        self
    }
    #[inline]
    pub fn sparse_residency_image2_d(mut self, sparse_residency_image2_d: bool) -> Self {
        self.inner.sparse_residency_image2_d = sparse_residency_image2_d.into();
        self
    }
    #[inline]
    pub fn sparse_residency_image3_d(mut self, sparse_residency_image3_d: bool) -> Self {
        self.inner.sparse_residency_image3_d = sparse_residency_image3_d.into();
        self
    }
    #[inline]
    pub fn sparse_residency2_samples(mut self, sparse_residency2_samples: bool) -> Self {
        self.inner.sparse_residency2_samples = sparse_residency2_samples.into();
        self
    }
    #[inline]
    pub fn sparse_residency4_samples(mut self, sparse_residency4_samples: bool) -> Self {
        self.inner.sparse_residency4_samples = sparse_residency4_samples.into();
        self
    }
    #[inline]
    pub fn sparse_residency8_samples(mut self, sparse_residency8_samples: bool) -> Self {
        self.inner.sparse_residency8_samples = sparse_residency8_samples.into();
        self
    }
    #[inline]
    pub fn sparse_residency16_samples(mut self, sparse_residency16_samples: bool) -> Self {
        self.inner.sparse_residency16_samples = sparse_residency16_samples.into();
        self
    }
    #[inline]
    pub fn sparse_residency_aliased(mut self, sparse_residency_aliased: bool) -> Self {
        self.inner.sparse_residency_aliased = sparse_residency_aliased.into();
        self
    }
    #[inline]
    pub fn variable_multisample_rate(mut self, variable_multisample_rate: bool) -> Self {
        self.inner.variable_multisample_rate = variable_multisample_rate.into();
        self
    }
    #[inline]
    pub fn inherited_queries(mut self, inherited_queries: bool) -> Self {
        self.inner.inherited_queries = inherited_queries.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSparseProperties.html>"]
pub struct PhysicalDeviceSparseProperties {
    pub residency_standard2_d_block_shape: Bool32,
    pub residency_standard2_d_multisample_block_shape: Bool32,
    pub residency_standard3_d_block_shape: Bool32,
    pub residency_aligned_mip_size: Bool32,
    pub residency_non_resident_strict: Bool32,
}
impl PhysicalDeviceSparseProperties {
    pub fn builder<'a>() -> PhysicalDeviceSparsePropertiesBuilder<'a> {
        PhysicalDeviceSparsePropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceSparsePropertiesBuilder<'a> {
    inner: PhysicalDeviceSparseProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PhysicalDeviceSparsePropertiesBuilder<'a> {
    type Target = PhysicalDeviceSparseProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceSparsePropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceSparsePropertiesBuilder<'a> {
    #[inline]
    pub fn residency_standard2_d_block_shape(
        mut self,
        residency_standard2_d_block_shape: bool,
    ) -> Self {
        self.inner.residency_standard2_d_block_shape = residency_standard2_d_block_shape.into();
        self
    }
    #[inline]
    pub fn residency_standard2_d_multisample_block_shape(
        mut self,
        residency_standard2_d_multisample_block_shape: bool,
    ) -> Self {
        self.inner.residency_standard2_d_multisample_block_shape =
            residency_standard2_d_multisample_block_shape.into();
        self
    }
    #[inline]
    pub fn residency_standard3_d_block_shape(
        mut self,
        residency_standard3_d_block_shape: bool,
    ) -> Self {
        self.inner.residency_standard3_d_block_shape = residency_standard3_d_block_shape.into();
        self
    }
    #[inline]
    pub fn residency_aligned_mip_size(mut self, residency_aligned_mip_size: bool) -> Self {
        self.inner.residency_aligned_mip_size = residency_aligned_mip_size.into();
        self
    }
    #[inline]
    pub fn residency_non_resident_strict(mut self, residency_non_resident_strict: bool) -> Self {
        self.inner.residency_non_resident_strict = residency_non_resident_strict.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceSparseProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLimits.html>"]
pub struct PhysicalDeviceLimits {
    pub max_image_dimension1_d: u32,
    pub max_image_dimension2_d: u32,
    pub max_image_dimension3_d: u32,
    pub max_image_dimension_cube: u32,
    pub max_image_array_layers: u32,
    pub max_texel_buffer_elements: u32,
    pub max_uniform_buffer_range: u32,
    pub max_storage_buffer_range: u32,
    pub max_push_constants_size: u32,
    pub max_memory_allocation_count: u32,
    pub max_sampler_allocation_count: u32,
    pub buffer_image_granularity: DeviceSize,
    pub sparse_address_space_size: DeviceSize,
    pub max_bound_descriptor_sets: u32,
    pub max_per_stage_descriptor_samplers: u32,
    pub max_per_stage_descriptor_uniform_buffers: u32,
    pub max_per_stage_descriptor_storage_buffers: u32,
    pub max_per_stage_descriptor_sampled_images: u32,
    pub max_per_stage_descriptor_storage_images: u32,
    pub max_per_stage_descriptor_input_attachments: u32,
    pub max_per_stage_resources: u32,
    pub max_descriptor_set_samplers: u32,
    pub max_descriptor_set_uniform_buffers: u32,
    pub max_descriptor_set_uniform_buffers_dynamic: u32,
    pub max_descriptor_set_storage_buffers: u32,
    pub max_descriptor_set_storage_buffers_dynamic: u32,
    pub max_descriptor_set_sampled_images: u32,
    pub max_descriptor_set_storage_images: u32,
    pub max_descriptor_set_input_attachments: u32,
    pub max_vertex_input_attributes: u32,
    pub max_vertex_input_bindings: u32,
    pub max_vertex_input_attribute_offset: u32,
    pub max_vertex_input_binding_stride: u32,
    pub max_vertex_output_components: u32,
    pub max_tessellation_generation_level: u32,
    pub max_tessellation_patch_size: u32,
    pub max_tessellation_control_per_vertex_input_components: u32,
    pub max_tessellation_control_per_vertex_output_components: u32,
    pub max_tessellation_control_per_patch_output_components: u32,
    pub max_tessellation_control_total_output_components: u32,
    pub max_tessellation_evaluation_input_components: u32,
    pub max_tessellation_evaluation_output_components: u32,
    pub max_geometry_shader_invocations: u32,
    pub max_geometry_input_components: u32,
    pub max_geometry_output_components: u32,
    pub max_geometry_output_vertices: u32,
    pub max_geometry_total_output_components: u32,
    pub max_fragment_input_components: u32,
    pub max_fragment_output_attachments: u32,
    pub max_fragment_dual_src_attachments: u32,
    pub max_fragment_combined_output_resources: u32,
    pub max_compute_shared_memory_size: u32,
    pub max_compute_work_group_count: [u32; 3],
    pub max_compute_work_group_invocations: u32,
    pub max_compute_work_group_size: [u32; 3],
    pub sub_pixel_precision_bits: u32,
    pub sub_texel_precision_bits: u32,
    pub mipmap_precision_bits: u32,
    pub max_draw_indexed_index_value: u32,
    pub max_draw_indirect_count: u32,
    pub max_sampler_lod_bias: f32,
    pub max_sampler_anisotropy: f32,
    pub max_viewports: u32,
    pub max_viewport_dimensions: [u32; 2],
    pub viewport_bounds_range: [f32; 2],
    pub viewport_sub_pixel_bits: u32,
    pub min_memory_map_alignment: usize,
    pub min_texel_buffer_offset_alignment: DeviceSize,
    pub min_uniform_buffer_offset_alignment: DeviceSize,
    pub min_storage_buffer_offset_alignment: DeviceSize,
    pub min_texel_offset: i32,
    pub max_texel_offset: u32,
    pub min_texel_gather_offset: i32,
    pub max_texel_gather_offset: u32,
    pub min_interpolation_offset: f32,
    pub max_interpolation_offset: f32,
    pub sub_pixel_interpolation_offset_bits: u32,
    pub max_framebuffer_width: u32,
    pub max_framebuffer_height: u32,
    pub max_framebuffer_layers: u32,
    pub framebuffer_color_sample_counts: SampleCountFlags,
    pub framebuffer_depth_sample_counts: SampleCountFlags,
    pub framebuffer_stencil_sample_counts: SampleCountFlags,
    pub framebuffer_no_attachments_sample_counts: SampleCountFlags,
    pub max_color_attachments: u32,
    pub sampled_image_color_sample_counts: SampleCountFlags,
    pub sampled_image_integer_sample_counts: SampleCountFlags,
    pub sampled_image_depth_sample_counts: SampleCountFlags,
    pub sampled_image_stencil_sample_counts: SampleCountFlags,
    pub storage_image_sample_counts: SampleCountFlags,
    pub max_sample_mask_words: u32,
    pub timestamp_compute_and_graphics: Bool32,
    pub timestamp_period: f32,
    pub max_clip_distances: u32,
    pub max_cull_distances: u32,
    pub max_combined_clip_and_cull_distances: u32,
    pub discrete_queue_priorities: u32,
    pub point_size_range: [f32; 2],
    pub line_width_range: [f32; 2],
    pub point_size_granularity: f32,
    pub line_width_granularity: f32,
    pub strict_lines: Bool32,
    pub standard_sample_locations: Bool32,
    pub optimal_buffer_copy_offset_alignment: DeviceSize,
    pub optimal_buffer_copy_row_pitch_alignment: DeviceSize,
    pub non_coherent_atom_size: DeviceSize,
}
impl ::std::default::Default for PhysicalDeviceLimits {
    #[inline]
    fn default() -> Self {
        Self {
            max_image_dimension1_d: u32::default(),
            max_image_dimension2_d: u32::default(),
            max_image_dimension3_d: u32::default(),
            max_image_dimension_cube: u32::default(),
            max_image_array_layers: u32::default(),
            max_texel_buffer_elements: u32::default(),
            max_uniform_buffer_range: u32::default(),
            max_storage_buffer_range: u32::default(),
            max_push_constants_size: u32::default(),
            max_memory_allocation_count: u32::default(),
            max_sampler_allocation_count: u32::default(),
            buffer_image_granularity: DeviceSize::default(),
            sparse_address_space_size: DeviceSize::default(),
            max_bound_descriptor_sets: u32::default(),
            max_per_stage_descriptor_samplers: u32::default(),
            max_per_stage_descriptor_uniform_buffers: u32::default(),
            max_per_stage_descriptor_storage_buffers: u32::default(),
            max_per_stage_descriptor_sampled_images: u32::default(),
            max_per_stage_descriptor_storage_images: u32::default(),
            max_per_stage_descriptor_input_attachments: u32::default(),
            max_per_stage_resources: u32::default(),
            max_descriptor_set_samplers: u32::default(),
            max_descriptor_set_uniform_buffers: u32::default(),
            max_descriptor_set_uniform_buffers_dynamic: u32::default(),
            max_descriptor_set_storage_buffers: u32::default(),
            max_descriptor_set_storage_buffers_dynamic: u32::default(),
            max_descriptor_set_sampled_images: u32::default(),
            max_descriptor_set_storage_images: u32::default(),
            max_descriptor_set_input_attachments: u32::default(),
            max_vertex_input_attributes: u32::default(),
            max_vertex_input_bindings: u32::default(),
            max_vertex_input_attribute_offset: u32::default(),
            max_vertex_input_binding_stride: u32::default(),
            max_vertex_output_components: u32::default(),
            max_tessellation_generation_level: u32::default(),
            max_tessellation_patch_size: u32::default(),
            max_tessellation_control_per_vertex_input_components: u32::default(),
            max_tessellation_control_per_vertex_output_components: u32::default(),
            max_tessellation_control_per_patch_output_components: u32::default(),
            max_tessellation_control_total_output_components: u32::default(),
            max_tessellation_evaluation_input_components: u32::default(),
            max_tessellation_evaluation_output_components: u32::default(),
            max_geometry_shader_invocations: u32::default(),
            max_geometry_input_components: u32::default(),
            max_geometry_output_components: u32::default(),
            max_geometry_output_vertices: u32::default(),
            max_geometry_total_output_components: u32::default(),
            max_fragment_input_components: u32::default(),
            max_fragment_output_attachments: u32::default(),
            max_fragment_dual_src_attachments: u32::default(),
            max_fragment_combined_output_resources: u32::default(),
            max_compute_shared_memory_size: u32::default(),
            max_compute_work_group_count: unsafe { ::std::mem::zeroed() },
            max_compute_work_group_invocations: u32::default(),
            max_compute_work_group_size: unsafe { ::std::mem::zeroed() },
            sub_pixel_precision_bits: u32::default(),
            sub_texel_precision_bits: u32::default(),
            mipmap_precision_bits: u32::default(),
            max_draw_indexed_index_value: u32::default(),
            max_draw_indirect_count: u32::default(),
            max_sampler_lod_bias: f32::default(),
            max_sampler_anisotropy: f32::default(),
            max_viewports: u32::default(),
            max_viewport_dimensions: unsafe { ::std::mem::zeroed() },
            viewport_bounds_range: unsafe { ::std::mem::zeroed() },
            viewport_sub_pixel_bits: u32::default(),
            min_memory_map_alignment: usize::default(),
            min_texel_buffer_offset_alignment: DeviceSize::default(),
            min_uniform_buffer_offset_alignment: DeviceSize::default(),
            min_storage_buffer_offset_alignment: DeviceSize::default(),
            min_texel_offset: i32::default(),
            max_texel_offset: u32::default(),
            min_texel_gather_offset: i32::default(),
            max_texel_gather_offset: u32::default(),
            min_interpolation_offset: f32::default(),
            max_interpolation_offset: f32::default(),
            sub_pixel_interpolation_offset_bits: u32::default(),
            max_framebuffer_width: u32::default(),
            max_framebuffer_height: u32::default(),
            max_framebuffer_layers: u32::default(),
            framebuffer_color_sample_counts: SampleCountFlags::default(),
            framebuffer_depth_sample_counts: SampleCountFlags::default(),
            framebuffer_stencil_sample_counts: SampleCountFlags::default(),
            framebuffer_no_attachments_sample_counts: SampleCountFlags::default(),
            max_color_attachments: u32::default(),
            sampled_image_color_sample_counts: SampleCountFlags::default(),
            sampled_image_integer_sample_counts: SampleCountFlags::default(),
            sampled_image_depth_sample_counts: SampleCountFlags::default(),
            sampled_image_stencil_sample_counts: SampleCountFlags::default(),
            storage_image_sample_counts: SampleCountFlags::default(),
            max_sample_mask_words: u32::default(),
            timestamp_compute_and_graphics: Bool32::default(),
            timestamp_period: f32::default(),
            max_clip_distances: u32::default(),
            max_cull_distances: u32::default(),
            max_combined_clip_and_cull_distances: u32::default(),
            discrete_queue_priorities: u32::default(),
            point_size_range: unsafe { ::std::mem::zeroed() },
            line_width_range: unsafe { ::std::mem::zeroed() },
            point_size_granularity: f32::default(),
            line_width_granularity: f32::default(),
            strict_lines: Bool32::default(),
            standard_sample_locations: Bool32::default(),
            optimal_buffer_copy_offset_alignment: DeviceSize::default(),
            optimal_buffer_copy_row_pitch_alignment: DeviceSize::default(),
            non_coherent_atom_size: DeviceSize::default(),
        }
    }
}
impl PhysicalDeviceLimits {
    pub fn builder<'a>() -> PhysicalDeviceLimitsBuilder<'a> {
        PhysicalDeviceLimitsBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceLimitsBuilder<'a> {
    inner: PhysicalDeviceLimits,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PhysicalDeviceLimitsBuilder<'a> {
    type Target = PhysicalDeviceLimits;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceLimitsBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceLimitsBuilder<'a> {
    #[inline]
    pub fn max_image_dimension1_d(mut self, max_image_dimension1_d: u32) -> Self {
        self.inner.max_image_dimension1_d = max_image_dimension1_d;
        self
    }
    #[inline]
    pub fn max_image_dimension2_d(mut self, max_image_dimension2_d: u32) -> Self {
        self.inner.max_image_dimension2_d = max_image_dimension2_d;
        self
    }
    #[inline]
    pub fn max_image_dimension3_d(mut self, max_image_dimension3_d: u32) -> Self {
        self.inner.max_image_dimension3_d = max_image_dimension3_d;
        self
    }
    #[inline]
    pub fn max_image_dimension_cube(mut self, max_image_dimension_cube: u32) -> Self {
        self.inner.max_image_dimension_cube = max_image_dimension_cube;
        self
    }
    #[inline]
    pub fn max_image_array_layers(mut self, max_image_array_layers: u32) -> Self {
        self.inner.max_image_array_layers = max_image_array_layers;
        self
    }
    #[inline]
    pub fn max_texel_buffer_elements(mut self, max_texel_buffer_elements: u32) -> Self {
        self.inner.max_texel_buffer_elements = max_texel_buffer_elements;
        self
    }
    #[inline]
    pub fn max_uniform_buffer_range(mut self, max_uniform_buffer_range: u32) -> Self {
        self.inner.max_uniform_buffer_range = max_uniform_buffer_range;
        self
    }
    #[inline]
    pub fn max_storage_buffer_range(mut self, max_storage_buffer_range: u32) -> Self {
        self.inner.max_storage_buffer_range = max_storage_buffer_range;
        self
    }
    #[inline]
    pub fn max_push_constants_size(mut self, max_push_constants_size: u32) -> Self {
        self.inner.max_push_constants_size = max_push_constants_size;
        self
    }
    #[inline]
    pub fn max_memory_allocation_count(mut self, max_memory_allocation_count: u32) -> Self {
        self.inner.max_memory_allocation_count = max_memory_allocation_count;
        self
    }
    #[inline]
    pub fn max_sampler_allocation_count(mut self, max_sampler_allocation_count: u32) -> Self {
        self.inner.max_sampler_allocation_count = max_sampler_allocation_count;
        self
    }
    #[inline]
    pub fn buffer_image_granularity(mut self, buffer_image_granularity: DeviceSize) -> Self {
        self.inner.buffer_image_granularity = buffer_image_granularity;
        self
    }
    #[inline]
    pub fn sparse_address_space_size(mut self, sparse_address_space_size: DeviceSize) -> Self {
        self.inner.sparse_address_space_size = sparse_address_space_size;
        self
    }
    #[inline]
    pub fn max_bound_descriptor_sets(mut self, max_bound_descriptor_sets: u32) -> Self {
        self.inner.max_bound_descriptor_sets = max_bound_descriptor_sets;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_samplers(
        mut self,
        max_per_stage_descriptor_samplers: u32,
    ) -> Self {
        self.inner.max_per_stage_descriptor_samplers = max_per_stage_descriptor_samplers;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_uniform_buffers(
        mut self,
        max_per_stage_descriptor_uniform_buffers: u32,
    ) -> Self {
        self.inner.max_per_stage_descriptor_uniform_buffers =
            max_per_stage_descriptor_uniform_buffers;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_storage_buffers(
        mut self,
        max_per_stage_descriptor_storage_buffers: u32,
    ) -> Self {
        self.inner.max_per_stage_descriptor_storage_buffers =
            max_per_stage_descriptor_storage_buffers;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_sampled_images(
        mut self,
        max_per_stage_descriptor_sampled_images: u32,
    ) -> Self {
        self.inner.max_per_stage_descriptor_sampled_images =
            max_per_stage_descriptor_sampled_images;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_storage_images(
        mut self,
        max_per_stage_descriptor_storage_images: u32,
    ) -> Self {
        self.inner.max_per_stage_descriptor_storage_images =
            max_per_stage_descriptor_storage_images;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_input_attachments(
        mut self,
        max_per_stage_descriptor_input_attachments: u32,
    ) -> Self {
        self.inner.max_per_stage_descriptor_input_attachments =
            max_per_stage_descriptor_input_attachments;
        self
    }
    #[inline]
    pub fn max_per_stage_resources(mut self, max_per_stage_resources: u32) -> Self {
        self.inner.max_per_stage_resources = max_per_stage_resources;
        self
    }
    #[inline]
    pub fn max_descriptor_set_samplers(mut self, max_descriptor_set_samplers: u32) -> Self {
        self.inner.max_descriptor_set_samplers = max_descriptor_set_samplers;
        self
    }
    #[inline]
    pub fn max_descriptor_set_uniform_buffers(
        mut self,
        max_descriptor_set_uniform_buffers: u32,
    ) -> Self {
        self.inner.max_descriptor_set_uniform_buffers = max_descriptor_set_uniform_buffers;
        self
    }
    #[inline]
    pub fn max_descriptor_set_uniform_buffers_dynamic(
        mut self,
        max_descriptor_set_uniform_buffers_dynamic: u32,
    ) -> Self {
        self.inner.max_descriptor_set_uniform_buffers_dynamic =
            max_descriptor_set_uniform_buffers_dynamic;
        self
    }
    #[inline]
    pub fn max_descriptor_set_storage_buffers(
        mut self,
        max_descriptor_set_storage_buffers: u32,
    ) -> Self {
        self.inner.max_descriptor_set_storage_buffers = max_descriptor_set_storage_buffers;
        self
    }
    #[inline]
    pub fn max_descriptor_set_storage_buffers_dynamic(
        mut self,
        max_descriptor_set_storage_buffers_dynamic: u32,
    ) -> Self {
        self.inner.max_descriptor_set_storage_buffers_dynamic =
            max_descriptor_set_storage_buffers_dynamic;
        self
    }
    #[inline]
    pub fn max_descriptor_set_sampled_images(
        mut self,
        max_descriptor_set_sampled_images: u32,
    ) -> Self {
        self.inner.max_descriptor_set_sampled_images = max_descriptor_set_sampled_images;
        self
    }
    #[inline]
    pub fn max_descriptor_set_storage_images(
        mut self,
        max_descriptor_set_storage_images: u32,
    ) -> Self {
        self.inner.max_descriptor_set_storage_images = max_descriptor_set_storage_images;
        self
    }
    #[inline]
    pub fn max_descriptor_set_input_attachments(
        mut self,
        max_descriptor_set_input_attachments: u32,
    ) -> Self {
        self.inner.max_descriptor_set_input_attachments = max_descriptor_set_input_attachments;
        self
    }
    #[inline]
    pub fn max_vertex_input_attributes(mut self, max_vertex_input_attributes: u32) -> Self {
        self.inner.max_vertex_input_attributes = max_vertex_input_attributes;
        self
    }
    #[inline]
    pub fn max_vertex_input_bindings(mut self, max_vertex_input_bindings: u32) -> Self {
        self.inner.max_vertex_input_bindings = max_vertex_input_bindings;
        self
    }
    #[inline]
    pub fn max_vertex_input_attribute_offset(
        mut self,
        max_vertex_input_attribute_offset: u32,
    ) -> Self {
        self.inner.max_vertex_input_attribute_offset = max_vertex_input_attribute_offset;
        self
    }
    #[inline]
    pub fn max_vertex_input_binding_stride(mut self, max_vertex_input_binding_stride: u32) -> Self {
        self.inner.max_vertex_input_binding_stride = max_vertex_input_binding_stride;
        self
    }
    #[inline]
    pub fn max_vertex_output_components(mut self, max_vertex_output_components: u32) -> Self {
        self.inner.max_vertex_output_components = max_vertex_output_components;
        self
    }
    #[inline]
    pub fn max_tessellation_generation_level(
        mut self,
        max_tessellation_generation_level: u32,
    ) -> Self {
        self.inner.max_tessellation_generation_level = max_tessellation_generation_level;
        self
    }
    #[inline]
    pub fn max_tessellation_patch_size(mut self, max_tessellation_patch_size: u32) -> Self {
        self.inner.max_tessellation_patch_size = max_tessellation_patch_size;
        self
    }
    #[inline]
    pub fn max_tessellation_control_per_vertex_input_components(
        mut self,
        max_tessellation_control_per_vertex_input_components: u32,
    ) -> Self {
        self.inner
            .max_tessellation_control_per_vertex_input_components =
            max_tessellation_control_per_vertex_input_components;
        self
    }
    #[inline]
    pub fn max_tessellation_control_per_vertex_output_components(
        mut self,
        max_tessellation_control_per_vertex_output_components: u32,
    ) -> Self {
        self.inner
            .max_tessellation_control_per_vertex_output_components =
            max_tessellation_control_per_vertex_output_components;
        self
    }
    #[inline]
    pub fn max_tessellation_control_per_patch_output_components(
        mut self,
        max_tessellation_control_per_patch_output_components: u32,
    ) -> Self {
        self.inner
            .max_tessellation_control_per_patch_output_components =
            max_tessellation_control_per_patch_output_components;
        self
    }
    #[inline]
    pub fn max_tessellation_control_total_output_components(
        mut self,
        max_tessellation_control_total_output_components: u32,
    ) -> Self {
        self.inner.max_tessellation_control_total_output_components =
            max_tessellation_control_total_output_components;
        self
    }
    #[inline]
    pub fn max_tessellation_evaluation_input_components(
        mut self,
        max_tessellation_evaluation_input_components: u32,
    ) -> Self {
        self.inner.max_tessellation_evaluation_input_components =
            max_tessellation_evaluation_input_components;
        self
    }
    #[inline]
    pub fn max_tessellation_evaluation_output_components(
        mut self,
        max_tessellation_evaluation_output_components: u32,
    ) -> Self {
        self.inner.max_tessellation_evaluation_output_components =
            max_tessellation_evaluation_output_components;
        self
    }
    #[inline]
    pub fn max_geometry_shader_invocations(mut self, max_geometry_shader_invocations: u32) -> Self {
        self.inner.max_geometry_shader_invocations = max_geometry_shader_invocations;
        self
    }
    #[inline]
    pub fn max_geometry_input_components(mut self, max_geometry_input_components: u32) -> Self {
        self.inner.max_geometry_input_components = max_geometry_input_components;
        self
    }
    #[inline]
    pub fn max_geometry_output_components(mut self, max_geometry_output_components: u32) -> Self {
        self.inner.max_geometry_output_components = max_geometry_output_components;
        self
    }
    #[inline]
    pub fn max_geometry_output_vertices(mut self, max_geometry_output_vertices: u32) -> Self {
        self.inner.max_geometry_output_vertices = max_geometry_output_vertices;
        self
    }
    #[inline]
    pub fn max_geometry_total_output_components(
        mut self,
        max_geometry_total_output_components: u32,
    ) -> Self {
        self.inner.max_geometry_total_output_components = max_geometry_total_output_components;
        self
    }
    #[inline]
    pub fn max_fragment_input_components(mut self, max_fragment_input_components: u32) -> Self {
        self.inner.max_fragment_input_components = max_fragment_input_components;
        self
    }
    #[inline]
    pub fn max_fragment_output_attachments(mut self, max_fragment_output_attachments: u32) -> Self {
        self.inner.max_fragment_output_attachments = max_fragment_output_attachments;
        self
    }
    #[inline]
    pub fn max_fragment_dual_src_attachments(
        mut self,
        max_fragment_dual_src_attachments: u32,
    ) -> Self {
        self.inner.max_fragment_dual_src_attachments = max_fragment_dual_src_attachments;
        self
    }
    #[inline]
    pub fn max_fragment_combined_output_resources(
        mut self,
        max_fragment_combined_output_resources: u32,
    ) -> Self {
        self.inner.max_fragment_combined_output_resources = max_fragment_combined_output_resources;
        self
    }
    #[inline]
    pub fn max_compute_shared_memory_size(mut self, max_compute_shared_memory_size: u32) -> Self {
        self.inner.max_compute_shared_memory_size = max_compute_shared_memory_size;
        self
    }
    #[inline]
    pub fn max_compute_work_group_count(mut self, max_compute_work_group_count: [u32; 3]) -> Self {
        self.inner.max_compute_work_group_count = max_compute_work_group_count;
        self
    }
    #[inline]
    pub fn max_compute_work_group_invocations(
        mut self,
        max_compute_work_group_invocations: u32,
    ) -> Self {
        self.inner.max_compute_work_group_invocations = max_compute_work_group_invocations;
        self
    }
    #[inline]
    pub fn max_compute_work_group_size(mut self, max_compute_work_group_size: [u32; 3]) -> Self {
        self.inner.max_compute_work_group_size = max_compute_work_group_size;
        self
    }
    #[inline]
    pub fn sub_pixel_precision_bits(mut self, sub_pixel_precision_bits: u32) -> Self {
        self.inner.sub_pixel_precision_bits = sub_pixel_precision_bits;
        self
    }
    #[inline]
    pub fn sub_texel_precision_bits(mut self, sub_texel_precision_bits: u32) -> Self {
        self.inner.sub_texel_precision_bits = sub_texel_precision_bits;
        self
    }
    #[inline]
    pub fn mipmap_precision_bits(mut self, mipmap_precision_bits: u32) -> Self {
        self.inner.mipmap_precision_bits = mipmap_precision_bits;
        self
    }
    #[inline]
    pub fn max_draw_indexed_index_value(mut self, max_draw_indexed_index_value: u32) -> Self {
        self.inner.max_draw_indexed_index_value = max_draw_indexed_index_value;
        self
    }
    #[inline]
    pub fn max_draw_indirect_count(mut self, max_draw_indirect_count: u32) -> Self {
        self.inner.max_draw_indirect_count = max_draw_indirect_count;
        self
    }
    #[inline]
    pub fn max_sampler_lod_bias(mut self, max_sampler_lod_bias: f32) -> Self {
        self.inner.max_sampler_lod_bias = max_sampler_lod_bias;
        self
    }
    #[inline]
    pub fn max_sampler_anisotropy(mut self, max_sampler_anisotropy: f32) -> Self {
        self.inner.max_sampler_anisotropy = max_sampler_anisotropy;
        self
    }
    #[inline]
    pub fn max_viewports(mut self, max_viewports: u32) -> Self {
        self.inner.max_viewports = max_viewports;
        self
    }
    #[inline]
    pub fn max_viewport_dimensions(mut self, max_viewport_dimensions: [u32; 2]) -> Self {
        self.inner.max_viewport_dimensions = max_viewport_dimensions;
        self
    }
    #[inline]
    pub fn viewport_bounds_range(mut self, viewport_bounds_range: [f32; 2]) -> Self {
        self.inner.viewport_bounds_range = viewport_bounds_range;
        self
    }
    #[inline]
    pub fn viewport_sub_pixel_bits(mut self, viewport_sub_pixel_bits: u32) -> Self {
        self.inner.viewport_sub_pixel_bits = viewport_sub_pixel_bits;
        self
    }
    #[inline]
    pub fn min_memory_map_alignment(mut self, min_memory_map_alignment: usize) -> Self {
        self.inner.min_memory_map_alignment = min_memory_map_alignment;
        self
    }
    #[inline]
    pub fn min_texel_buffer_offset_alignment(
        mut self,
        min_texel_buffer_offset_alignment: DeviceSize,
    ) -> Self {
        self.inner.min_texel_buffer_offset_alignment = min_texel_buffer_offset_alignment;
        self
    }
    #[inline]
    pub fn min_uniform_buffer_offset_alignment(
        mut self,
        min_uniform_buffer_offset_alignment: DeviceSize,
    ) -> Self {
        self.inner.min_uniform_buffer_offset_alignment = min_uniform_buffer_offset_alignment;
        self
    }
    #[inline]
    pub fn min_storage_buffer_offset_alignment(
        mut self,
        min_storage_buffer_offset_alignment: DeviceSize,
    ) -> Self {
        self.inner.min_storage_buffer_offset_alignment = min_storage_buffer_offset_alignment;
        self
    }
    #[inline]
    pub fn min_texel_offset(mut self, min_texel_offset: i32) -> Self {
        self.inner.min_texel_offset = min_texel_offset;
        self
    }
    #[inline]
    pub fn max_texel_offset(mut self, max_texel_offset: u32) -> Self {
        self.inner.max_texel_offset = max_texel_offset;
        self
    }
    #[inline]
    pub fn min_texel_gather_offset(mut self, min_texel_gather_offset: i32) -> Self {
        self.inner.min_texel_gather_offset = min_texel_gather_offset;
        self
    }
    #[inline]
    pub fn max_texel_gather_offset(mut self, max_texel_gather_offset: u32) -> Self {
        self.inner.max_texel_gather_offset = max_texel_gather_offset;
        self
    }
    #[inline]
    pub fn min_interpolation_offset(mut self, min_interpolation_offset: f32) -> Self {
        self.inner.min_interpolation_offset = min_interpolation_offset;
        self
    }
    #[inline]
    pub fn max_interpolation_offset(mut self, max_interpolation_offset: f32) -> Self {
        self.inner.max_interpolation_offset = max_interpolation_offset;
        self
    }
    #[inline]
    pub fn sub_pixel_interpolation_offset_bits(
        mut self,
        sub_pixel_interpolation_offset_bits: u32,
    ) -> Self {
        self.inner.sub_pixel_interpolation_offset_bits = sub_pixel_interpolation_offset_bits;
        self
    }
    #[inline]
    pub fn max_framebuffer_width(mut self, max_framebuffer_width: u32) -> Self {
        self.inner.max_framebuffer_width = max_framebuffer_width;
        self
    }
    #[inline]
    pub fn max_framebuffer_height(mut self, max_framebuffer_height: u32) -> Self {
        self.inner.max_framebuffer_height = max_framebuffer_height;
        self
    }
    #[inline]
    pub fn max_framebuffer_layers(mut self, max_framebuffer_layers: u32) -> Self {
        self.inner.max_framebuffer_layers = max_framebuffer_layers;
        self
    }
    #[inline]
    pub fn framebuffer_color_sample_counts(
        mut self,
        framebuffer_color_sample_counts: SampleCountFlags,
    ) -> Self {
        self.inner.framebuffer_color_sample_counts = framebuffer_color_sample_counts;
        self
    }
    #[inline]
    pub fn framebuffer_depth_sample_counts(
        mut self,
        framebuffer_depth_sample_counts: SampleCountFlags,
    ) -> Self {
        self.inner.framebuffer_depth_sample_counts = framebuffer_depth_sample_counts;
        self
    }
    #[inline]
    pub fn framebuffer_stencil_sample_counts(
        mut self,
        framebuffer_stencil_sample_counts: SampleCountFlags,
    ) -> Self {
        self.inner.framebuffer_stencil_sample_counts = framebuffer_stencil_sample_counts;
        self
    }
    #[inline]
    pub fn framebuffer_no_attachments_sample_counts(
        mut self,
        framebuffer_no_attachments_sample_counts: SampleCountFlags,
    ) -> Self {
        self.inner.framebuffer_no_attachments_sample_counts =
            framebuffer_no_attachments_sample_counts;
        self
    }
    #[inline]
    pub fn max_color_attachments(mut self, max_color_attachments: u32) -> Self {
        self.inner.max_color_attachments = max_color_attachments;
        self
    }
    #[inline]
    pub fn sampled_image_color_sample_counts(
        mut self,
        sampled_image_color_sample_counts: SampleCountFlags,
    ) -> Self {
        self.inner.sampled_image_color_sample_counts = sampled_image_color_sample_counts;
        self
    }
    #[inline]
    pub fn sampled_image_integer_sample_counts(
        mut self,
        sampled_image_integer_sample_counts: SampleCountFlags,
    ) -> Self {
        self.inner.sampled_image_integer_sample_counts = sampled_image_integer_sample_counts;
        self
    }
    #[inline]
    pub fn sampled_image_depth_sample_counts(
        mut self,
        sampled_image_depth_sample_counts: SampleCountFlags,
    ) -> Self {
        self.inner.sampled_image_depth_sample_counts = sampled_image_depth_sample_counts;
        self
    }
    #[inline]
    pub fn sampled_image_stencil_sample_counts(
        mut self,
        sampled_image_stencil_sample_counts: SampleCountFlags,
    ) -> Self {
        self.inner.sampled_image_stencil_sample_counts = sampled_image_stencil_sample_counts;
        self
    }
    #[inline]
    pub fn storage_image_sample_counts(
        mut self,
        storage_image_sample_counts: SampleCountFlags,
    ) -> Self {
        self.inner.storage_image_sample_counts = storage_image_sample_counts;
        self
    }
    #[inline]
    pub fn max_sample_mask_words(mut self, max_sample_mask_words: u32) -> Self {
        self.inner.max_sample_mask_words = max_sample_mask_words;
        self
    }
    #[inline]
    pub fn timestamp_compute_and_graphics(mut self, timestamp_compute_and_graphics: bool) -> Self {
        self.inner.timestamp_compute_and_graphics = timestamp_compute_and_graphics.into();
        self
    }
    #[inline]
    pub fn timestamp_period(mut self, timestamp_period: f32) -> Self {
        self.inner.timestamp_period = timestamp_period;
        self
    }
    #[inline]
    pub fn max_clip_distances(mut self, max_clip_distances: u32) -> Self {
        self.inner.max_clip_distances = max_clip_distances;
        self
    }
    #[inline]
    pub fn max_cull_distances(mut self, max_cull_distances: u32) -> Self {
        self.inner.max_cull_distances = max_cull_distances;
        self
    }
    #[inline]
    pub fn max_combined_clip_and_cull_distances(
        mut self,
        max_combined_clip_and_cull_distances: u32,
    ) -> Self {
        self.inner.max_combined_clip_and_cull_distances = max_combined_clip_and_cull_distances;
        self
    }
    #[inline]
    pub fn discrete_queue_priorities(mut self, discrete_queue_priorities: u32) -> Self {
        self.inner.discrete_queue_priorities = discrete_queue_priorities;
        self
    }
    #[inline]
    pub fn point_size_range(mut self, point_size_range: [f32; 2]) -> Self {
        self.inner.point_size_range = point_size_range;
        self
    }
    #[inline]
    pub fn line_width_range(mut self, line_width_range: [f32; 2]) -> Self {
        self.inner.line_width_range = line_width_range;
        self
    }
    #[inline]
    pub fn point_size_granularity(mut self, point_size_granularity: f32) -> Self {
        self.inner.point_size_granularity = point_size_granularity;
        self
    }
    #[inline]
    pub fn line_width_granularity(mut self, line_width_granularity: f32) -> Self {
        self.inner.line_width_granularity = line_width_granularity;
        self
    }
    #[inline]
    pub fn strict_lines(mut self, strict_lines: bool) -> Self {
        self.inner.strict_lines = strict_lines.into();
        self
    }
    #[inline]
    pub fn standard_sample_locations(mut self, standard_sample_locations: bool) -> Self {
        self.inner.standard_sample_locations = standard_sample_locations.into();
        self
    }
    #[inline]
    pub fn optimal_buffer_copy_offset_alignment(
        mut self,
        optimal_buffer_copy_offset_alignment: DeviceSize,
    ) -> Self {
        self.inner.optimal_buffer_copy_offset_alignment = optimal_buffer_copy_offset_alignment;
        self
    }
    #[inline]
    pub fn optimal_buffer_copy_row_pitch_alignment(
        mut self,
        optimal_buffer_copy_row_pitch_alignment: DeviceSize,
    ) -> Self {
        self.inner.optimal_buffer_copy_row_pitch_alignment =
            optimal_buffer_copy_row_pitch_alignment;
        self
    }
    #[inline]
    pub fn non_coherent_atom_size(mut self, non_coherent_atom_size: DeviceSize) -> Self {
        self.inner.non_coherent_atom_size = non_coherent_atom_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceLimits {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreCreateInfo.html>"]
pub struct SemaphoreCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: SemaphoreCreateFlags,
}
impl ::std::default::Default for SemaphoreCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: SemaphoreCreateFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for SemaphoreCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::SEMAPHORE_CREATE_INFO;
}
impl SemaphoreCreateInfo {
    pub fn builder<'a>() -> SemaphoreCreateInfoBuilder<'a> {
        SemaphoreCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SemaphoreCreateInfoBuilder<'a> {
    inner: SemaphoreCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsSemaphoreCreateInfo {}
impl<'a> ::std::ops::Deref for SemaphoreCreateInfoBuilder<'a> {
    type Target = SemaphoreCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SemaphoreCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SemaphoreCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: SemaphoreCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsSemaphoreCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SemaphoreCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPoolCreateInfo.html>"]
pub struct QueryPoolCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: QueryPoolCreateFlags,
    pub query_type: QueryType,
    pub query_count: u32,
    pub pipeline_statistics: QueryPipelineStatisticFlags,
}
impl ::std::default::Default for QueryPoolCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: QueryPoolCreateFlags::default(),
            query_type: QueryType::default(),
            query_count: u32::default(),
            pipeline_statistics: QueryPipelineStatisticFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for QueryPoolCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::QUERY_POOL_CREATE_INFO;
}
impl QueryPoolCreateInfo {
    pub fn builder<'a>() -> QueryPoolCreateInfoBuilder<'a> {
        QueryPoolCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct QueryPoolCreateInfoBuilder<'a> {
    inner: QueryPoolCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsQueryPoolCreateInfo {}
impl<'a> ::std::ops::Deref for QueryPoolCreateInfoBuilder<'a> {
    type Target = QueryPoolCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for QueryPoolCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> QueryPoolCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: QueryPoolCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn query_type(mut self, query_type: QueryType) -> Self {
        self.inner.query_type = query_type;
        self
    }
    #[inline]
    pub fn query_count(mut self, query_count: u32) -> Self {
        self.inner.query_count = query_count;
        self
    }
    #[inline]
    pub fn pipeline_statistics(mut self, pipeline_statistics: QueryPipelineStatisticFlags) -> Self {
        self.inner.pipeline_statistics = pipeline_statistics;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsQueryPoolCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> QueryPoolCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferCreateInfo.html>"]
pub struct FramebufferCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: FramebufferCreateFlags,
    pub render_pass: RenderPass,
    pub attachment_count: u32,
    pub p_attachments: *const ImageView,
    pub width: u32,
    pub height: u32,
    pub layers: u32,
}
impl ::std::default::Default for FramebufferCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: FramebufferCreateFlags::default(),
            render_pass: RenderPass::default(),
            attachment_count: u32::default(),
            p_attachments: ::std::ptr::null(),
            width: u32::default(),
            height: u32::default(),
            layers: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for FramebufferCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::FRAMEBUFFER_CREATE_INFO;
}
impl FramebufferCreateInfo {
    pub fn builder<'a>() -> FramebufferCreateInfoBuilder<'a> {
        FramebufferCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct FramebufferCreateInfoBuilder<'a> {
    inner: FramebufferCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsFramebufferCreateInfo {}
impl<'a> ::std::ops::Deref for FramebufferCreateInfoBuilder<'a> {
    type Target = FramebufferCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for FramebufferCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> FramebufferCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: FramebufferCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn render_pass(mut self, render_pass: RenderPass) -> Self {
        self.inner.render_pass = render_pass;
        self
    }
    #[inline]
    pub fn attachment_count(mut self, attachment_count: u32) -> Self {
        self.inner.attachment_count = attachment_count;
        self
    }
    #[inline]
    pub fn attachments(mut self, attachments: &'a [ImageView]) -> Self {
        self.inner.attachment_count = attachments.len() as _;
        self.inner.p_attachments = attachments.as_ptr();
        self
    }
    #[inline]
    pub fn width(mut self, width: u32) -> Self {
        self.inner.width = width;
        self
    }
    #[inline]
    pub fn height(mut self, height: u32) -> Self {
        self.inner.height = height;
        self
    }
    #[inline]
    pub fn layers(mut self, layers: u32) -> Self {
        self.inner.layers = layers;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsFramebufferCreateInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> FramebufferCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrawIndirectCommand.html>"]
pub struct DrawIndirectCommand {
    pub vertex_count: u32,
    pub instance_count: u32,
    pub first_vertex: u32,
    pub first_instance: u32,
}
impl DrawIndirectCommand {
    pub fn builder<'a>() -> DrawIndirectCommandBuilder<'a> {
        DrawIndirectCommandBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DrawIndirectCommandBuilder<'a> {
    inner: DrawIndirectCommand,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DrawIndirectCommandBuilder<'a> {
    type Target = DrawIndirectCommand;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DrawIndirectCommandBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DrawIndirectCommandBuilder<'a> {
    #[inline]
    pub fn vertex_count(mut self, vertex_count: u32) -> Self {
        self.inner.vertex_count = vertex_count;
        self
    }
    #[inline]
    pub fn instance_count(mut self, instance_count: u32) -> Self {
        self.inner.instance_count = instance_count;
        self
    }
    #[inline]
    pub fn first_vertex(mut self, first_vertex: u32) -> Self {
        self.inner.first_vertex = first_vertex;
        self
    }
    #[inline]
    pub fn first_instance(mut self, first_instance: u32) -> Self {
        self.inner.first_instance = first_instance;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DrawIndirectCommand {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrawIndexedIndirectCommand.html>"]
pub struct DrawIndexedIndirectCommand {
    pub index_count: u32,
    pub instance_count: u32,
    pub first_index: u32,
    pub vertex_offset: i32,
    pub first_instance: u32,
}
impl DrawIndexedIndirectCommand {
    pub fn builder<'a>() -> DrawIndexedIndirectCommandBuilder<'a> {
        DrawIndexedIndirectCommandBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DrawIndexedIndirectCommandBuilder<'a> {
    inner: DrawIndexedIndirectCommand,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DrawIndexedIndirectCommandBuilder<'a> {
    type Target = DrawIndexedIndirectCommand;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DrawIndexedIndirectCommandBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DrawIndexedIndirectCommandBuilder<'a> {
    #[inline]
    pub fn index_count(mut self, index_count: u32) -> Self {
        self.inner.index_count = index_count;
        self
    }
    #[inline]
    pub fn instance_count(mut self, instance_count: u32) -> Self {
        self.inner.instance_count = instance_count;
        self
    }
    #[inline]
    pub fn first_index(mut self, first_index: u32) -> Self {
        self.inner.first_index = first_index;
        self
    }
    #[inline]
    pub fn vertex_offset(mut self, vertex_offset: i32) -> Self {
        self.inner.vertex_offset = vertex_offset;
        self
    }
    #[inline]
    pub fn first_instance(mut self, first_instance: u32) -> Self {
        self.inner.first_instance = first_instance;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DrawIndexedIndirectCommand {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDispatchIndirectCommand.html>"]
pub struct DispatchIndirectCommand {
    pub x: u32,
    pub y: u32,
    pub z: u32,
}
impl DispatchIndirectCommand {
    pub fn builder<'a>() -> DispatchIndirectCommandBuilder<'a> {
        DispatchIndirectCommandBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DispatchIndirectCommandBuilder<'a> {
    inner: DispatchIndirectCommand,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DispatchIndirectCommandBuilder<'a> {
    type Target = DispatchIndirectCommand;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DispatchIndirectCommandBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DispatchIndirectCommandBuilder<'a> {
    #[inline]
    pub fn x(mut self, x: u32) -> Self {
        self.inner.x = x;
        self
    }
    #[inline]
    pub fn y(mut self, y: u32) -> Self {
        self.inner.y = y;
        self
    }
    #[inline]
    pub fn z(mut self, z: u32) -> Self {
        self.inner.z = z;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DispatchIndirectCommand {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMultiDrawInfoEXT.html>"]
pub struct MultiDrawInfoEXT {
    pub first_vertex: u32,
    pub vertex_count: u32,
}
impl MultiDrawInfoEXT {
    pub fn builder<'a>() -> MultiDrawInfoEXTBuilder<'a> {
        MultiDrawInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MultiDrawInfoEXTBuilder<'a> {
    inner: MultiDrawInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MultiDrawInfoEXTBuilder<'a> {
    type Target = MultiDrawInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MultiDrawInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MultiDrawInfoEXTBuilder<'a> {
    #[inline]
    pub fn first_vertex(mut self, first_vertex: u32) -> Self {
        self.inner.first_vertex = first_vertex;
        self
    }
    #[inline]
    pub fn vertex_count(mut self, vertex_count: u32) -> Self {
        self.inner.vertex_count = vertex_count;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MultiDrawInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMultiDrawIndexedInfoEXT.html>"]
pub struct MultiDrawIndexedInfoEXT {
    pub first_index: u32,
    pub index_count: u32,
    pub vertex_offset: i32,
}
impl MultiDrawIndexedInfoEXT {
    pub fn builder<'a>() -> MultiDrawIndexedInfoEXTBuilder<'a> {
        MultiDrawIndexedInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MultiDrawIndexedInfoEXTBuilder<'a> {
    inner: MultiDrawIndexedInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MultiDrawIndexedInfoEXTBuilder<'a> {
    type Target = MultiDrawIndexedInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MultiDrawIndexedInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MultiDrawIndexedInfoEXTBuilder<'a> {
    #[inline]
    pub fn first_index(mut self, first_index: u32) -> Self {
        self.inner.first_index = first_index;
        self
    }
    #[inline]
    pub fn index_count(mut self, index_count: u32) -> Self {
        self.inner.index_count = index_count;
        self
    }
    #[inline]
    pub fn vertex_offset(mut self, vertex_offset: i32) -> Self {
        self.inner.vertex_offset = vertex_offset;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MultiDrawIndexedInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubmitInfo.html>"]
pub struct SubmitInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub wait_semaphore_count: u32,
    pub p_wait_semaphores: *const Semaphore,
    pub p_wait_dst_stage_mask: *const PipelineStageFlags,
    pub command_buffer_count: u32,
    pub p_command_buffers: *const CommandBuffer,
    pub signal_semaphore_count: u32,
    pub p_signal_semaphores: *const Semaphore,
}
impl ::std::default::Default for SubmitInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            wait_semaphore_count: u32::default(),
            p_wait_semaphores: ::std::ptr::null(),
            p_wait_dst_stage_mask: ::std::ptr::null(),
            command_buffer_count: u32::default(),
            p_command_buffers: ::std::ptr::null(),
            signal_semaphore_count: u32::default(),
            p_signal_semaphores: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for SubmitInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::SUBMIT_INFO;
}
impl SubmitInfo {
    pub fn builder<'a>() -> SubmitInfoBuilder<'a> {
        SubmitInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SubmitInfoBuilder<'a> {
    inner: SubmitInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsSubmitInfo {}
impl<'a> ::std::ops::Deref for SubmitInfoBuilder<'a> {
    type Target = SubmitInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SubmitInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SubmitInfoBuilder<'a> {
    #[inline]
    pub fn wait_semaphores(mut self, wait_semaphores: &'a [Semaphore]) -> Self {
        self.inner.wait_semaphore_count = wait_semaphores.len() as _;
        self.inner.p_wait_semaphores = wait_semaphores.as_ptr();
        self
    }
    #[inline]
    pub fn wait_dst_stage_mask(mut self, wait_dst_stage_mask: &'a [PipelineStageFlags]) -> Self {
        self.inner.wait_semaphore_count = wait_dst_stage_mask.len() as _;
        self.inner.p_wait_dst_stage_mask = wait_dst_stage_mask.as_ptr();
        self
    }
    #[inline]
    pub fn command_buffers(mut self, command_buffers: &'a [CommandBuffer]) -> Self {
        self.inner.command_buffer_count = command_buffers.len() as _;
        self.inner.p_command_buffers = command_buffers.as_ptr();
        self
    }
    #[inline]
    pub fn signal_semaphores(mut self, signal_semaphores: &'a [Semaphore]) -> Self {
        self.inner.signal_semaphore_count = signal_semaphores.len() as _;
        self.inner.p_signal_semaphores = signal_semaphores.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsSubmitInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SubmitInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPropertiesKHR.html>"]
pub struct DisplayPropertiesKHR {
    pub display: DisplayKHR,
    pub display_name: *const c_char,
    pub physical_dimensions: Extent2D,
    pub physical_resolution: Extent2D,
    pub supported_transforms: SurfaceTransformFlagsKHR,
    pub plane_reorder_possible: Bool32,
    pub persistent_content: Bool32,
}
impl ::std::default::Default for DisplayPropertiesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            display: DisplayKHR::default(),
            display_name: ::std::ptr::null(),
            physical_dimensions: Extent2D::default(),
            physical_resolution: Extent2D::default(),
            supported_transforms: SurfaceTransformFlagsKHR::default(),
            plane_reorder_possible: Bool32::default(),
            persistent_content: Bool32::default(),
        }
    }
}
impl DisplayPropertiesKHR {
    pub fn builder<'a>() -> DisplayPropertiesKHRBuilder<'a> {
        DisplayPropertiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DisplayPropertiesKHRBuilder<'a> {
    inner: DisplayPropertiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DisplayPropertiesKHRBuilder<'a> {
    type Target = DisplayPropertiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DisplayPropertiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DisplayPropertiesKHRBuilder<'a> {
    #[inline]
    pub fn display(mut self, display: DisplayKHR) -> Self {
        self.inner.display = display;
        self
    }
    #[inline]
    pub fn display_name(mut self, display_name: &'a ::std::ffi::CStr) -> Self {
        self.inner.display_name = display_name.as_ptr();
        self
    }
    #[inline]
    pub fn physical_dimensions(mut self, physical_dimensions: Extent2D) -> Self {
        self.inner.physical_dimensions = physical_dimensions;
        self
    }
    #[inline]
    pub fn physical_resolution(mut self, physical_resolution: Extent2D) -> Self {
        self.inner.physical_resolution = physical_resolution;
        self
    }
    #[inline]
    pub fn supported_transforms(mut self, supported_transforms: SurfaceTransformFlagsKHR) -> Self {
        self.inner.supported_transforms = supported_transforms;
        self
    }
    #[inline]
    pub fn plane_reorder_possible(mut self, plane_reorder_possible: bool) -> Self {
        self.inner.plane_reorder_possible = plane_reorder_possible.into();
        self
    }
    #[inline]
    pub fn persistent_content(mut self, persistent_content: bool) -> Self {
        self.inner.persistent_content = persistent_content.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DisplayPropertiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlanePropertiesKHR.html>"]
pub struct DisplayPlanePropertiesKHR {
    pub current_display: DisplayKHR,
    pub current_stack_index: u32,
}
impl DisplayPlanePropertiesKHR {
    pub fn builder<'a>() -> DisplayPlanePropertiesKHRBuilder<'a> {
        DisplayPlanePropertiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DisplayPlanePropertiesKHRBuilder<'a> {
    inner: DisplayPlanePropertiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DisplayPlanePropertiesKHRBuilder<'a> {
    type Target = DisplayPlanePropertiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DisplayPlanePropertiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DisplayPlanePropertiesKHRBuilder<'a> {
    #[inline]
    pub fn current_display(mut self, current_display: DisplayKHR) -> Self {
        self.inner.current_display = current_display;
        self
    }
    #[inline]
    pub fn current_stack_index(mut self, current_stack_index: u32) -> Self {
        self.inner.current_stack_index = current_stack_index;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DisplayPlanePropertiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModeParametersKHR.html>"]
pub struct DisplayModeParametersKHR {
    pub visible_region: Extent2D,
    pub refresh_rate: u32,
}
impl DisplayModeParametersKHR {
    pub fn builder<'a>() -> DisplayModeParametersKHRBuilder<'a> {
        DisplayModeParametersKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DisplayModeParametersKHRBuilder<'a> {
    inner: DisplayModeParametersKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DisplayModeParametersKHRBuilder<'a> {
    type Target = DisplayModeParametersKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DisplayModeParametersKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DisplayModeParametersKHRBuilder<'a> {
    #[inline]
    pub fn visible_region(mut self, visible_region: Extent2D) -> Self {
        self.inner.visible_region = visible_region;
        self
    }
    #[inline]
    pub fn refresh_rate(mut self, refresh_rate: u32) -> Self {
        self.inner.refresh_rate = refresh_rate;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DisplayModeParametersKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModePropertiesKHR.html>"]
pub struct DisplayModePropertiesKHR {
    pub display_mode: DisplayModeKHR,
    pub parameters: DisplayModeParametersKHR,
}
impl DisplayModePropertiesKHR {
    pub fn builder<'a>() -> DisplayModePropertiesKHRBuilder<'a> {
        DisplayModePropertiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DisplayModePropertiesKHRBuilder<'a> {
    inner: DisplayModePropertiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DisplayModePropertiesKHRBuilder<'a> {
    type Target = DisplayModePropertiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DisplayModePropertiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DisplayModePropertiesKHRBuilder<'a> {
    #[inline]
    pub fn display_mode(mut self, display_mode: DisplayModeKHR) -> Self {
        self.inner.display_mode = display_mode;
        self
    }
    #[inline]
    pub fn parameters(mut self, parameters: DisplayModeParametersKHR) -> Self {
        self.inner.parameters = parameters;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DisplayModePropertiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModeCreateInfoKHR.html>"]
pub struct DisplayModeCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DisplayModeCreateFlagsKHR,
    pub parameters: DisplayModeParametersKHR,
}
impl ::std::default::Default for DisplayModeCreateInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DisplayModeCreateFlagsKHR::default(),
            parameters: DisplayModeParametersKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for DisplayModeCreateInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::DISPLAY_MODE_CREATE_INFO_KHR;
}
impl DisplayModeCreateInfoKHR {
    pub fn builder<'a>() -> DisplayModeCreateInfoKHRBuilder<'a> {
        DisplayModeCreateInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DisplayModeCreateInfoKHRBuilder<'a> {
    inner: DisplayModeCreateInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DisplayModeCreateInfoKHRBuilder<'a> {
    type Target = DisplayModeCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DisplayModeCreateInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DisplayModeCreateInfoKHRBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: DisplayModeCreateFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn parameters(mut self, parameters: DisplayModeParametersKHR) -> Self {
        self.inner.parameters = parameters;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DisplayModeCreateInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlaneCapabilitiesKHR.html>"]
pub struct DisplayPlaneCapabilitiesKHR {
    pub supported_alpha: DisplayPlaneAlphaFlagsKHR,
    pub min_src_position: Offset2D,
    pub max_src_position: Offset2D,
    pub min_src_extent: Extent2D,
    pub max_src_extent: Extent2D,
    pub min_dst_position: Offset2D,
    pub max_dst_position: Offset2D,
    pub min_dst_extent: Extent2D,
    pub max_dst_extent: Extent2D,
}
impl DisplayPlaneCapabilitiesKHR {
    pub fn builder<'a>() -> DisplayPlaneCapabilitiesKHRBuilder<'a> {
        DisplayPlaneCapabilitiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DisplayPlaneCapabilitiesKHRBuilder<'a> {
    inner: DisplayPlaneCapabilitiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DisplayPlaneCapabilitiesKHRBuilder<'a> {
    type Target = DisplayPlaneCapabilitiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DisplayPlaneCapabilitiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DisplayPlaneCapabilitiesKHRBuilder<'a> {
    #[inline]
    pub fn supported_alpha(mut self, supported_alpha: DisplayPlaneAlphaFlagsKHR) -> Self {
        self.inner.supported_alpha = supported_alpha;
        self
    }
    #[inline]
    pub fn min_src_position(mut self, min_src_position: Offset2D) -> Self {
        self.inner.min_src_position = min_src_position;
        self
    }
    #[inline]
    pub fn max_src_position(mut self, max_src_position: Offset2D) -> Self {
        self.inner.max_src_position = max_src_position;
        self
    }
    #[inline]
    pub fn min_src_extent(mut self, min_src_extent: Extent2D) -> Self {
        self.inner.min_src_extent = min_src_extent;
        self
    }
    #[inline]
    pub fn max_src_extent(mut self, max_src_extent: Extent2D) -> Self {
        self.inner.max_src_extent = max_src_extent;
        self
    }
    #[inline]
    pub fn min_dst_position(mut self, min_dst_position: Offset2D) -> Self {
        self.inner.min_dst_position = min_dst_position;
        self
    }
    #[inline]
    pub fn max_dst_position(mut self, max_dst_position: Offset2D) -> Self {
        self.inner.max_dst_position = max_dst_position;
        self
    }
    #[inline]
    pub fn min_dst_extent(mut self, min_dst_extent: Extent2D) -> Self {
        self.inner.min_dst_extent = min_dst_extent;
        self
    }
    #[inline]
    pub fn max_dst_extent(mut self, max_dst_extent: Extent2D) -> Self {
        self.inner.max_dst_extent = max_dst_extent;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DisplayPlaneCapabilitiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplaySurfaceCreateInfoKHR.html>"]
pub struct DisplaySurfaceCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DisplaySurfaceCreateFlagsKHR,
    pub display_mode: DisplayModeKHR,
    pub plane_index: u32,
    pub plane_stack_index: u32,
    pub transform: SurfaceTransformFlagsKHR,
    pub global_alpha: f32,
    pub alpha_mode: DisplayPlaneAlphaFlagsKHR,
    pub image_extent: Extent2D,
}
impl ::std::default::Default for DisplaySurfaceCreateInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DisplaySurfaceCreateFlagsKHR::default(),
            display_mode: DisplayModeKHR::default(),
            plane_index: u32::default(),
            plane_stack_index: u32::default(),
            transform: SurfaceTransformFlagsKHR::default(),
            global_alpha: f32::default(),
            alpha_mode: DisplayPlaneAlphaFlagsKHR::default(),
            image_extent: Extent2D::default(),
        }
    }
}
unsafe impl TaggedStructure for DisplaySurfaceCreateInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::DISPLAY_SURFACE_CREATE_INFO_KHR;
}
impl DisplaySurfaceCreateInfoKHR {
    pub fn builder<'a>() -> DisplaySurfaceCreateInfoKHRBuilder<'a> {
        DisplaySurfaceCreateInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DisplaySurfaceCreateInfoKHRBuilder<'a> {
    inner: DisplaySurfaceCreateInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DisplaySurfaceCreateInfoKHRBuilder<'a> {
    type Target = DisplaySurfaceCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DisplaySurfaceCreateInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DisplaySurfaceCreateInfoKHRBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: DisplaySurfaceCreateFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn display_mode(mut self, display_mode: DisplayModeKHR) -> Self {
        self.inner.display_mode = display_mode;
        self
    }
    #[inline]
    pub fn plane_index(mut self, plane_index: u32) -> Self {
        self.inner.plane_index = plane_index;
        self
    }
    #[inline]
    pub fn plane_stack_index(mut self, plane_stack_index: u32) -> Self {
        self.inner.plane_stack_index = plane_stack_index;
        self
    }
    #[inline]
    pub fn transform(mut self, transform: SurfaceTransformFlagsKHR) -> Self {
        self.inner.transform = transform;
        self
    }
    #[inline]
    pub fn global_alpha(mut self, global_alpha: f32) -> Self {
        self.inner.global_alpha = global_alpha;
        self
    }
    #[inline]
    pub fn alpha_mode(mut self, alpha_mode: DisplayPlaneAlphaFlagsKHR) -> Self {
        self.inner.alpha_mode = alpha_mode;
        self
    }
    #[inline]
    pub fn image_extent(mut self, image_extent: Extent2D) -> Self {
        self.inner.image_extent = image_extent;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DisplaySurfaceCreateInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPresentInfoKHR.html>"]
pub struct DisplayPresentInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_rect: Rect2D,
    pub dst_rect: Rect2D,
    pub persistent: Bool32,
}
impl ::std::default::Default for DisplayPresentInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_rect: Rect2D::default(),
            dst_rect: Rect2D::default(),
            persistent: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for DisplayPresentInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::DISPLAY_PRESENT_INFO_KHR;
}
impl DisplayPresentInfoKHR {
    pub fn builder<'a>() -> DisplayPresentInfoKHRBuilder<'a> {
        DisplayPresentInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DisplayPresentInfoKHRBuilder<'a> {
    inner: DisplayPresentInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPresentInfoKHR for DisplayPresentInfoKHRBuilder<'_> {}
unsafe impl ExtendsPresentInfoKHR for DisplayPresentInfoKHR {}
impl<'a> ::std::ops::Deref for DisplayPresentInfoKHRBuilder<'a> {
    type Target = DisplayPresentInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DisplayPresentInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DisplayPresentInfoKHRBuilder<'a> {
    #[inline]
    pub fn src_rect(mut self, src_rect: Rect2D) -> Self {
        self.inner.src_rect = src_rect;
        self
    }
    #[inline]
    pub fn dst_rect(mut self, dst_rect: Rect2D) -> Self {
        self.inner.dst_rect = dst_rect;
        self
    }
    #[inline]
    pub fn persistent(mut self, persistent: bool) -> Self {
        self.inner.persistent = persistent.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DisplayPresentInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilitiesKHR.html>"]
pub struct SurfaceCapabilitiesKHR {
    pub min_image_count: u32,
    pub max_image_count: u32,
    pub current_extent: Extent2D,
    pub min_image_extent: Extent2D,
    pub max_image_extent: Extent2D,
    pub max_image_array_layers: u32,
    pub supported_transforms: SurfaceTransformFlagsKHR,
    pub current_transform: SurfaceTransformFlagsKHR,
    pub supported_composite_alpha: CompositeAlphaFlagsKHR,
    pub supported_usage_flags: ImageUsageFlags,
}
impl SurfaceCapabilitiesKHR {
    pub fn builder<'a>() -> SurfaceCapabilitiesKHRBuilder<'a> {
        SurfaceCapabilitiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SurfaceCapabilitiesKHRBuilder<'a> {
    inner: SurfaceCapabilitiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SurfaceCapabilitiesKHRBuilder<'a> {
    type Target = SurfaceCapabilitiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SurfaceCapabilitiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SurfaceCapabilitiesKHRBuilder<'a> {
    #[inline]
    pub fn min_image_count(mut self, min_image_count: u32) -> Self {
        self.inner.min_image_count = min_image_count;
        self
    }
    #[inline]
    pub fn max_image_count(mut self, max_image_count: u32) -> Self {
        self.inner.max_image_count = max_image_count;
        self
    }
    #[inline]
    pub fn current_extent(mut self, current_extent: Extent2D) -> Self {
        self.inner.current_extent = current_extent;
        self
    }
    #[inline]
    pub fn min_image_extent(mut self, min_image_extent: Extent2D) -> Self {
        self.inner.min_image_extent = min_image_extent;
        self
    }
    #[inline]
    pub fn max_image_extent(mut self, max_image_extent: Extent2D) -> Self {
        self.inner.max_image_extent = max_image_extent;
        self
    }
    #[inline]
    pub fn max_image_array_layers(mut self, max_image_array_layers: u32) -> Self {
        self.inner.max_image_array_layers = max_image_array_layers;
        self
    }
    #[inline]
    pub fn supported_transforms(mut self, supported_transforms: SurfaceTransformFlagsKHR) -> Self {
        self.inner.supported_transforms = supported_transforms;
        self
    }
    #[inline]
    pub fn current_transform(mut self, current_transform: SurfaceTransformFlagsKHR) -> Self {
        self.inner.current_transform = current_transform;
        self
    }
    #[inline]
    pub fn supported_composite_alpha(
        mut self,
        supported_composite_alpha: CompositeAlphaFlagsKHR,
    ) -> Self {
        self.inner.supported_composite_alpha = supported_composite_alpha;
        self
    }
    #[inline]
    pub fn supported_usage_flags(mut self, supported_usage_flags: ImageUsageFlags) -> Self {
        self.inner.supported_usage_flags = supported_usage_flags;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SurfaceCapabilitiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAndroidSurfaceCreateInfoKHR.html>"]
pub struct AndroidSurfaceCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: AndroidSurfaceCreateFlagsKHR,
    pub window: *mut ANativeWindow,
}
impl ::std::default::Default for AndroidSurfaceCreateInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: AndroidSurfaceCreateFlagsKHR::default(),
            window: ::std::ptr::null_mut(),
        }
    }
}
unsafe impl TaggedStructure for AndroidSurfaceCreateInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::ANDROID_SURFACE_CREATE_INFO_KHR;
}
impl AndroidSurfaceCreateInfoKHR {
    pub fn builder<'a>() -> AndroidSurfaceCreateInfoKHRBuilder<'a> {
        AndroidSurfaceCreateInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AndroidSurfaceCreateInfoKHRBuilder<'a> {
    inner: AndroidSurfaceCreateInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for AndroidSurfaceCreateInfoKHRBuilder<'a> {
    type Target = AndroidSurfaceCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AndroidSurfaceCreateInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AndroidSurfaceCreateInfoKHRBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: AndroidSurfaceCreateFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn window(mut self, window: *mut ANativeWindow) -> Self {
        self.inner.window = window;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AndroidSurfaceCreateInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkViSurfaceCreateInfoNN.html>"]
pub struct ViSurfaceCreateInfoNN {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ViSurfaceCreateFlagsNN,
    pub window: *mut c_void,
}
impl ::std::default::Default for ViSurfaceCreateInfoNN {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: ViSurfaceCreateFlagsNN::default(),
            window: ::std::ptr::null_mut(),
        }
    }
}
unsafe impl TaggedStructure for ViSurfaceCreateInfoNN {
    const STRUCTURE_TYPE: StructureType = StructureType::VI_SURFACE_CREATE_INFO_NN;
}
impl ViSurfaceCreateInfoNN {
    pub fn builder<'a>() -> ViSurfaceCreateInfoNNBuilder<'a> {
        ViSurfaceCreateInfoNNBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ViSurfaceCreateInfoNNBuilder<'a> {
    inner: ViSurfaceCreateInfoNN,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ViSurfaceCreateInfoNNBuilder<'a> {
    type Target = ViSurfaceCreateInfoNN;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ViSurfaceCreateInfoNNBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ViSurfaceCreateInfoNNBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: ViSurfaceCreateFlagsNN) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn window(mut self, window: *mut c_void) -> Self {
        self.inner.window = window;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ViSurfaceCreateInfoNN {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWaylandSurfaceCreateInfoKHR.html>"]
pub struct WaylandSurfaceCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: WaylandSurfaceCreateFlagsKHR,
    pub display: *mut wl_display,
    pub surface: *mut wl_surface,
}
impl ::std::default::Default for WaylandSurfaceCreateInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: WaylandSurfaceCreateFlagsKHR::default(),
            display: ::std::ptr::null_mut(),
            surface: ::std::ptr::null_mut(),
        }
    }
}
unsafe impl TaggedStructure for WaylandSurfaceCreateInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::WAYLAND_SURFACE_CREATE_INFO_KHR;
}
impl WaylandSurfaceCreateInfoKHR {
    pub fn builder<'a>() -> WaylandSurfaceCreateInfoKHRBuilder<'a> {
        WaylandSurfaceCreateInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct WaylandSurfaceCreateInfoKHRBuilder<'a> {
    inner: WaylandSurfaceCreateInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for WaylandSurfaceCreateInfoKHRBuilder<'a> {
    type Target = WaylandSurfaceCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for WaylandSurfaceCreateInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> WaylandSurfaceCreateInfoKHRBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: WaylandSurfaceCreateFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn display(mut self, display: *mut wl_display) -> Self {
        self.inner.display = display;
        self
    }
    #[inline]
    pub fn surface(mut self, surface: *mut wl_surface) -> Self {
        self.inner.surface = surface;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> WaylandSurfaceCreateInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWin32SurfaceCreateInfoKHR.html>"]
pub struct Win32SurfaceCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: Win32SurfaceCreateFlagsKHR,
    pub hinstance: HINSTANCE,
    pub hwnd: HWND,
}
impl ::std::default::Default for Win32SurfaceCreateInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: Win32SurfaceCreateFlagsKHR::default(),
            hinstance: unsafe { ::std::mem::zeroed() },
            hwnd: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for Win32SurfaceCreateInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::WIN32_SURFACE_CREATE_INFO_KHR;
}
impl Win32SurfaceCreateInfoKHR {
    pub fn builder<'a>() -> Win32SurfaceCreateInfoKHRBuilder<'a> {
        Win32SurfaceCreateInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct Win32SurfaceCreateInfoKHRBuilder<'a> {
    inner: Win32SurfaceCreateInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for Win32SurfaceCreateInfoKHRBuilder<'a> {
    type Target = Win32SurfaceCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for Win32SurfaceCreateInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> Win32SurfaceCreateInfoKHRBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: Win32SurfaceCreateFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn hinstance(mut self, hinstance: HINSTANCE) -> Self {
        self.inner.hinstance = hinstance;
        self
    }
    #[inline]
    pub fn hwnd(mut self, hwnd: HWND) -> Self {
        self.inner.hwnd = hwnd;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> Win32SurfaceCreateInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkXlibSurfaceCreateInfoKHR.html>"]
pub struct XlibSurfaceCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: XlibSurfaceCreateFlagsKHR,
    pub dpy: *mut Display,
    pub window: Window,
}
impl ::std::default::Default for XlibSurfaceCreateInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: XlibSurfaceCreateFlagsKHR::default(),
            dpy: ::std::ptr::null_mut(),
            window: Window::default(),
        }
    }
}
unsafe impl TaggedStructure for XlibSurfaceCreateInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::XLIB_SURFACE_CREATE_INFO_KHR;
}
impl XlibSurfaceCreateInfoKHR {
    pub fn builder<'a>() -> XlibSurfaceCreateInfoKHRBuilder<'a> {
        XlibSurfaceCreateInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct XlibSurfaceCreateInfoKHRBuilder<'a> {
    inner: XlibSurfaceCreateInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for XlibSurfaceCreateInfoKHRBuilder<'a> {
    type Target = XlibSurfaceCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for XlibSurfaceCreateInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> XlibSurfaceCreateInfoKHRBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: XlibSurfaceCreateFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn dpy(mut self, dpy: *mut Display) -> Self {
        self.inner.dpy = dpy;
        self
    }
    #[inline]
    pub fn window(mut self, window: Window) -> Self {
        self.inner.window = window;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> XlibSurfaceCreateInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkXcbSurfaceCreateInfoKHR.html>"]
pub struct XcbSurfaceCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: XcbSurfaceCreateFlagsKHR,
    pub connection: *mut xcb_connection_t,
    pub window: xcb_window_t,
}
impl ::std::default::Default for XcbSurfaceCreateInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: XcbSurfaceCreateFlagsKHR::default(),
            connection: ::std::ptr::null_mut(),
            window: xcb_window_t::default(),
        }
    }
}
unsafe impl TaggedStructure for XcbSurfaceCreateInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::XCB_SURFACE_CREATE_INFO_KHR;
}
impl XcbSurfaceCreateInfoKHR {
    pub fn builder<'a>() -> XcbSurfaceCreateInfoKHRBuilder<'a> {
        XcbSurfaceCreateInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct XcbSurfaceCreateInfoKHRBuilder<'a> {
    inner: XcbSurfaceCreateInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for XcbSurfaceCreateInfoKHRBuilder<'a> {
    type Target = XcbSurfaceCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for XcbSurfaceCreateInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> XcbSurfaceCreateInfoKHRBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: XcbSurfaceCreateFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn connection(mut self, connection: *mut xcb_connection_t) -> Self {
        self.inner.connection = connection;
        self
    }
    #[inline]
    pub fn window(mut self, window: xcb_window_t) -> Self {
        self.inner.window = window;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> XcbSurfaceCreateInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDirectFBSurfaceCreateInfoEXT.html>"]
pub struct DirectFBSurfaceCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DirectFBSurfaceCreateFlagsEXT,
    pub dfb: *mut IDirectFB,
    pub surface: *mut IDirectFBSurface,
}
impl ::std::default::Default for DirectFBSurfaceCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DirectFBSurfaceCreateFlagsEXT::default(),
            dfb: ::std::ptr::null_mut(),
            surface: ::std::ptr::null_mut(),
        }
    }
}
unsafe impl TaggedStructure for DirectFBSurfaceCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::DIRECTFB_SURFACE_CREATE_INFO_EXT;
}
impl DirectFBSurfaceCreateInfoEXT {
    pub fn builder<'a>() -> DirectFBSurfaceCreateInfoEXTBuilder<'a> {
        DirectFBSurfaceCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DirectFBSurfaceCreateInfoEXTBuilder<'a> {
    inner: DirectFBSurfaceCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DirectFBSurfaceCreateInfoEXTBuilder<'a> {
    type Target = DirectFBSurfaceCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DirectFBSurfaceCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DirectFBSurfaceCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: DirectFBSurfaceCreateFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn dfb(mut self, dfb: *mut IDirectFB) -> Self {
        self.inner.dfb = dfb;
        self
    }
    #[inline]
    pub fn surface(mut self, surface: *mut IDirectFBSurface) -> Self {
        self.inner.surface = surface;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DirectFBSurfaceCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImagePipeSurfaceCreateInfoFUCHSIA.html>"]
pub struct ImagePipeSurfaceCreateInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ImagePipeSurfaceCreateFlagsFUCHSIA,
    pub image_pipe_handle: zx_handle_t,
}
impl ::std::default::Default for ImagePipeSurfaceCreateInfoFUCHSIA {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: ImagePipeSurfaceCreateFlagsFUCHSIA::default(),
            image_pipe_handle: zx_handle_t::default(),
        }
    }
}
unsafe impl TaggedStructure for ImagePipeSurfaceCreateInfoFUCHSIA {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA;
}
impl ImagePipeSurfaceCreateInfoFUCHSIA {
    pub fn builder<'a>() -> ImagePipeSurfaceCreateInfoFUCHSIABuilder<'a> {
        ImagePipeSurfaceCreateInfoFUCHSIABuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImagePipeSurfaceCreateInfoFUCHSIABuilder<'a> {
    inner: ImagePipeSurfaceCreateInfoFUCHSIA,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ImagePipeSurfaceCreateInfoFUCHSIABuilder<'a> {
    type Target = ImagePipeSurfaceCreateInfoFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImagePipeSurfaceCreateInfoFUCHSIABuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImagePipeSurfaceCreateInfoFUCHSIABuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: ImagePipeSurfaceCreateFlagsFUCHSIA) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn image_pipe_handle(mut self, image_pipe_handle: zx_handle_t) -> Self {
        self.inner.image_pipe_handle = image_pipe_handle;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImagePipeSurfaceCreateInfoFUCHSIA {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStreamDescriptorSurfaceCreateInfoGGP.html>"]
pub struct StreamDescriptorSurfaceCreateInfoGGP {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: StreamDescriptorSurfaceCreateFlagsGGP,
    pub stream_descriptor: GgpStreamDescriptor,
}
impl ::std::default::Default for StreamDescriptorSurfaceCreateInfoGGP {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: StreamDescriptorSurfaceCreateFlagsGGP::default(),
            stream_descriptor: GgpStreamDescriptor::default(),
        }
    }
}
unsafe impl TaggedStructure for StreamDescriptorSurfaceCreateInfoGGP {
    const STRUCTURE_TYPE: StructureType = StructureType::STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP;
}
impl StreamDescriptorSurfaceCreateInfoGGP {
    pub fn builder<'a>() -> StreamDescriptorSurfaceCreateInfoGGPBuilder<'a> {
        StreamDescriptorSurfaceCreateInfoGGPBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct StreamDescriptorSurfaceCreateInfoGGPBuilder<'a> {
    inner: StreamDescriptorSurfaceCreateInfoGGP,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for StreamDescriptorSurfaceCreateInfoGGPBuilder<'a> {
    type Target = StreamDescriptorSurfaceCreateInfoGGP;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for StreamDescriptorSurfaceCreateInfoGGPBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> StreamDescriptorSurfaceCreateInfoGGPBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: StreamDescriptorSurfaceCreateFlagsGGP) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn stream_descriptor(mut self, stream_descriptor: GgpStreamDescriptor) -> Self {
        self.inner.stream_descriptor = stream_descriptor;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> StreamDescriptorSurfaceCreateInfoGGP {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkScreenSurfaceCreateInfoQNX.html>"]
pub struct ScreenSurfaceCreateInfoQNX {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ScreenSurfaceCreateFlagsQNX,
    pub context: *mut _screen_context,
    pub window: *mut _screen_window,
}
impl ::std::default::Default for ScreenSurfaceCreateInfoQNX {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: ScreenSurfaceCreateFlagsQNX::default(),
            context: ::std::ptr::null_mut(),
            window: ::std::ptr::null_mut(),
        }
    }
}
unsafe impl TaggedStructure for ScreenSurfaceCreateInfoQNX {
    const STRUCTURE_TYPE: StructureType = StructureType::SCREEN_SURFACE_CREATE_INFO_QNX;
}
impl ScreenSurfaceCreateInfoQNX {
    pub fn builder<'a>() -> ScreenSurfaceCreateInfoQNXBuilder<'a> {
        ScreenSurfaceCreateInfoQNXBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ScreenSurfaceCreateInfoQNXBuilder<'a> {
    inner: ScreenSurfaceCreateInfoQNX,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ScreenSurfaceCreateInfoQNXBuilder<'a> {
    type Target = ScreenSurfaceCreateInfoQNX;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ScreenSurfaceCreateInfoQNXBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ScreenSurfaceCreateInfoQNXBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: ScreenSurfaceCreateFlagsQNX) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn context(mut self, context: &'a mut _screen_context) -> Self {
        self.inner.context = context;
        self
    }
    #[inline]
    pub fn window(mut self, window: &'a mut _screen_window) -> Self {
        self.inner.window = window;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ScreenSurfaceCreateInfoQNX {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceFormatKHR.html>"]
pub struct SurfaceFormatKHR {
    pub format: Format,
    pub color_space: ColorSpaceKHR,
}
impl SurfaceFormatKHR {
    pub fn builder<'a>() -> SurfaceFormatKHRBuilder<'a> {
        SurfaceFormatKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SurfaceFormatKHRBuilder<'a> {
    inner: SurfaceFormatKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SurfaceFormatKHRBuilder<'a> {
    type Target = SurfaceFormatKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SurfaceFormatKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SurfaceFormatKHRBuilder<'a> {
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.inner.format = format;
        self
    }
    #[inline]
    pub fn color_space(mut self, color_space: ColorSpaceKHR) -> Self {
        self.inner.color_space = color_space;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SurfaceFormatKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html>"]
pub struct SwapchainCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: SwapchainCreateFlagsKHR,
    pub surface: SurfaceKHR,
    pub min_image_count: u32,
    pub image_format: Format,
    pub image_color_space: ColorSpaceKHR,
    pub image_extent: Extent2D,
    pub image_array_layers: u32,
    pub image_usage: ImageUsageFlags,
    pub image_sharing_mode: SharingMode,
    pub queue_family_index_count: u32,
    pub p_queue_family_indices: *const u32,
    pub pre_transform: SurfaceTransformFlagsKHR,
    pub composite_alpha: CompositeAlphaFlagsKHR,
    pub present_mode: PresentModeKHR,
    pub clipped: Bool32,
    pub old_swapchain: SwapchainKHR,
}
impl ::std::default::Default for SwapchainCreateInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: SwapchainCreateFlagsKHR::default(),
            surface: SurfaceKHR::default(),
            min_image_count: u32::default(),
            image_format: Format::default(),
            image_color_space: ColorSpaceKHR::default(),
            image_extent: Extent2D::default(),
            image_array_layers: u32::default(),
            image_usage: ImageUsageFlags::default(),
            image_sharing_mode: SharingMode::default(),
            queue_family_index_count: u32::default(),
            p_queue_family_indices: ::std::ptr::null(),
            pre_transform: SurfaceTransformFlagsKHR::default(),
            composite_alpha: CompositeAlphaFlagsKHR::default(),
            present_mode: PresentModeKHR::default(),
            clipped: Bool32::default(),
            old_swapchain: SwapchainKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for SwapchainCreateInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::SWAPCHAIN_CREATE_INFO_KHR;
}
impl SwapchainCreateInfoKHR {
    pub fn builder<'a>() -> SwapchainCreateInfoKHRBuilder<'a> {
        SwapchainCreateInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SwapchainCreateInfoKHRBuilder<'a> {
    inner: SwapchainCreateInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsSwapchainCreateInfoKHR {}
impl<'a> ::std::ops::Deref for SwapchainCreateInfoKHRBuilder<'a> {
    type Target = SwapchainCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SwapchainCreateInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SwapchainCreateInfoKHRBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: SwapchainCreateFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn surface(mut self, surface: SurfaceKHR) -> Self {
        self.inner.surface = surface;
        self
    }
    #[inline]
    pub fn min_image_count(mut self, min_image_count: u32) -> Self {
        self.inner.min_image_count = min_image_count;
        self
    }
    #[inline]
    pub fn image_format(mut self, image_format: Format) -> Self {
        self.inner.image_format = image_format;
        self
    }
    #[inline]
    pub fn image_color_space(mut self, image_color_space: ColorSpaceKHR) -> Self {
        self.inner.image_color_space = image_color_space;
        self
    }
    #[inline]
    pub fn image_extent(mut self, image_extent: Extent2D) -> Self {
        self.inner.image_extent = image_extent;
        self
    }
    #[inline]
    pub fn image_array_layers(mut self, image_array_layers: u32) -> Self {
        self.inner.image_array_layers = image_array_layers;
        self
    }
    #[inline]
    pub fn image_usage(mut self, image_usage: ImageUsageFlags) -> Self {
        self.inner.image_usage = image_usage;
        self
    }
    #[inline]
    pub fn image_sharing_mode(mut self, image_sharing_mode: SharingMode) -> Self {
        self.inner.image_sharing_mode = image_sharing_mode;
        self
    }
    #[inline]
    pub fn queue_family_indices(mut self, queue_family_indices: &'a [u32]) -> Self {
        self.inner.queue_family_index_count = queue_family_indices.len() as _;
        self.inner.p_queue_family_indices = queue_family_indices.as_ptr();
        self
    }
    #[inline]
    pub fn pre_transform(mut self, pre_transform: SurfaceTransformFlagsKHR) -> Self {
        self.inner.pre_transform = pre_transform;
        self
    }
    #[inline]
    pub fn composite_alpha(mut self, composite_alpha: CompositeAlphaFlagsKHR) -> Self {
        self.inner.composite_alpha = composite_alpha;
        self
    }
    #[inline]
    pub fn present_mode(mut self, present_mode: PresentModeKHR) -> Self {
        self.inner.present_mode = present_mode;
        self
    }
    #[inline]
    pub fn clipped(mut self, clipped: bool) -> Self {
        self.inner.clipped = clipped.into();
        self
    }
    #[inline]
    pub fn old_swapchain(mut self, old_swapchain: SwapchainKHR) -> Self {
        self.inner.old_swapchain = old_swapchain;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsSwapchainCreateInfoKHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SwapchainCreateInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentInfoKHR.html>"]
pub struct PresentInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub wait_semaphore_count: u32,
    pub p_wait_semaphores: *const Semaphore,
    pub swapchain_count: u32,
    pub p_swapchains: *const SwapchainKHR,
    pub p_image_indices: *const u32,
    pub p_results: *mut Result,
}
impl ::std::default::Default for PresentInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            wait_semaphore_count: u32::default(),
            p_wait_semaphores: ::std::ptr::null(),
            swapchain_count: u32::default(),
            p_swapchains: ::std::ptr::null(),
            p_image_indices: ::std::ptr::null(),
            p_results: ::std::ptr::null_mut(),
        }
    }
}
unsafe impl TaggedStructure for PresentInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::PRESENT_INFO_KHR;
}
impl PresentInfoKHR {
    pub fn builder<'a>() -> PresentInfoKHRBuilder<'a> {
        PresentInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PresentInfoKHRBuilder<'a> {
    inner: PresentInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsPresentInfoKHR {}
impl<'a> ::std::ops::Deref for PresentInfoKHRBuilder<'a> {
    type Target = PresentInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PresentInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PresentInfoKHRBuilder<'a> {
    #[inline]
    pub fn wait_semaphores(mut self, wait_semaphores: &'a [Semaphore]) -> Self {
        self.inner.wait_semaphore_count = wait_semaphores.len() as _;
        self.inner.p_wait_semaphores = wait_semaphores.as_ptr();
        self
    }
    #[inline]
    pub fn swapchains(mut self, swapchains: &'a [SwapchainKHR]) -> Self {
        self.inner.swapchain_count = swapchains.len() as _;
        self.inner.p_swapchains = swapchains.as_ptr();
        self
    }
    #[inline]
    pub fn image_indices(mut self, image_indices: &'a [u32]) -> Self {
        self.inner.swapchain_count = image_indices.len() as _;
        self.inner.p_image_indices = image_indices.as_ptr();
        self
    }
    #[inline]
    pub fn results(mut self, results: &'a mut [Result]) -> Self {
        self.inner.swapchain_count = results.len() as _;
        self.inner.p_results = results.as_mut_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPresentInfoKHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PresentInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugReportCallbackCreateInfoEXT.html>"]
pub struct DebugReportCallbackCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DebugReportFlagsEXT,
    pub pfn_callback: PFN_vkDebugReportCallbackEXT,
    pub p_user_data: *mut c_void,
}
#[cfg(feature = "debug")]
impl fmt::Debug for DebugReportCallbackCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DebugReportCallbackCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("pfn_callback", &(self.pfn_callback.map(|x| x as *const ())))
            .field("p_user_data", &self.p_user_data)
            .finish()
    }
}
impl ::std::default::Default for DebugReportCallbackCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DebugReportFlagsEXT::default(),
            pfn_callback: PFN_vkDebugReportCallbackEXT::default(),
            p_user_data: ::std::ptr::null_mut(),
        }
    }
}
unsafe impl TaggedStructure for DebugReportCallbackCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
}
impl DebugReportCallbackCreateInfoEXT {
    pub fn builder<'a>() -> DebugReportCallbackCreateInfoEXTBuilder<'a> {
        DebugReportCallbackCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DebugReportCallbackCreateInfoEXTBuilder<'a> {
    inner: DebugReportCallbackCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsInstanceCreateInfo for DebugReportCallbackCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsInstanceCreateInfo for DebugReportCallbackCreateInfoEXT {}
impl<'a> ::std::ops::Deref for DebugReportCallbackCreateInfoEXTBuilder<'a> {
    type Target = DebugReportCallbackCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DebugReportCallbackCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DebugReportCallbackCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: DebugReportFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn pfn_callback(mut self, pfn_callback: PFN_vkDebugReportCallbackEXT) -> Self {
        self.inner.pfn_callback = pfn_callback;
        self
    }
    #[inline]
    pub fn user_data(mut self, user_data: *mut c_void) -> Self {
        self.inner.p_user_data = user_data;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DebugReportCallbackCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkValidationFlagsEXT.html>"]
pub struct ValidationFlagsEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub disabled_validation_check_count: u32,
    pub p_disabled_validation_checks: *const ValidationCheckEXT,
}
impl ::std::default::Default for ValidationFlagsEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            disabled_validation_check_count: u32::default(),
            p_disabled_validation_checks: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for ValidationFlagsEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::VALIDATION_FLAGS_EXT;
}
impl ValidationFlagsEXT {
    pub fn builder<'a>() -> ValidationFlagsEXTBuilder<'a> {
        ValidationFlagsEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ValidationFlagsEXTBuilder<'a> {
    inner: ValidationFlagsEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsInstanceCreateInfo for ValidationFlagsEXTBuilder<'_> {}
unsafe impl ExtendsInstanceCreateInfo for ValidationFlagsEXT {}
impl<'a> ::std::ops::Deref for ValidationFlagsEXTBuilder<'a> {
    type Target = ValidationFlagsEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ValidationFlagsEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ValidationFlagsEXTBuilder<'a> {
    #[inline]
    pub fn disabled_validation_checks(
        mut self,
        disabled_validation_checks: &'a [ValidationCheckEXT],
    ) -> Self {
        self.inner.disabled_validation_check_count = disabled_validation_checks.len() as _;
        self.inner.p_disabled_validation_checks = disabled_validation_checks.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ValidationFlagsEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkValidationFeaturesEXT.html>"]
pub struct ValidationFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub enabled_validation_feature_count: u32,
    pub p_enabled_validation_features: *const ValidationFeatureEnableEXT,
    pub disabled_validation_feature_count: u32,
    pub p_disabled_validation_features: *const ValidationFeatureDisableEXT,
}
impl ::std::default::Default for ValidationFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            enabled_validation_feature_count: u32::default(),
            p_enabled_validation_features: ::std::ptr::null(),
            disabled_validation_feature_count: u32::default(),
            p_disabled_validation_features: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for ValidationFeaturesEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::VALIDATION_FEATURES_EXT;
}
impl ValidationFeaturesEXT {
    pub fn builder<'a>() -> ValidationFeaturesEXTBuilder<'a> {
        ValidationFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ValidationFeaturesEXTBuilder<'a> {
    inner: ValidationFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsInstanceCreateInfo for ValidationFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsInstanceCreateInfo for ValidationFeaturesEXT {}
impl<'a> ::std::ops::Deref for ValidationFeaturesEXTBuilder<'a> {
    type Target = ValidationFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ValidationFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ValidationFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn enabled_validation_features(
        mut self,
        enabled_validation_features: &'a [ValidationFeatureEnableEXT],
    ) -> Self {
        self.inner.enabled_validation_feature_count = enabled_validation_features.len() as _;
        self.inner.p_enabled_validation_features = enabled_validation_features.as_ptr();
        self
    }
    #[inline]
    pub fn disabled_validation_features(
        mut self,
        disabled_validation_features: &'a [ValidationFeatureDisableEXT],
    ) -> Self {
        self.inner.disabled_validation_feature_count = disabled_validation_features.len() as _;
        self.inner.p_disabled_validation_features = disabled_validation_features.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ValidationFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateRasterizationOrderAMD.html>"]
pub struct PipelineRasterizationStateRasterizationOrderAMD {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub rasterization_order: RasterizationOrderAMD,
}
impl ::std::default::Default for PipelineRasterizationStateRasterizationOrderAMD {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            rasterization_order: RasterizationOrderAMD::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineRasterizationStateRasterizationOrderAMD {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD;
}
impl PipelineRasterizationStateRasterizationOrderAMD {
    pub fn builder<'a>() -> PipelineRasterizationStateRasterizationOrderAMDBuilder<'a> {
        PipelineRasterizationStateRasterizationOrderAMDBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineRasterizationStateRasterizationOrderAMDBuilder<'a> {
    inner: PipelineRasterizationStateRasterizationOrderAMD,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPipelineRasterizationStateCreateInfo
    for PipelineRasterizationStateRasterizationOrderAMDBuilder<'_>
{
}
unsafe impl ExtendsPipelineRasterizationStateCreateInfo
    for PipelineRasterizationStateRasterizationOrderAMD
{
}
impl<'a> ::std::ops::Deref for PipelineRasterizationStateRasterizationOrderAMDBuilder<'a> {
    type Target = PipelineRasterizationStateRasterizationOrderAMD;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineRasterizationStateRasterizationOrderAMDBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineRasterizationStateRasterizationOrderAMDBuilder<'a> {
    #[inline]
    pub fn rasterization_order(mut self, rasterization_order: RasterizationOrderAMD) -> Self {
        self.inner.rasterization_order = rasterization_order;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineRasterizationStateRasterizationOrderAMD {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugMarkerObjectNameInfoEXT.html>"]
pub struct DebugMarkerObjectNameInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub object_type: DebugReportObjectTypeEXT,
    pub object: u64,
    pub p_object_name: *const c_char,
}
impl ::std::default::Default for DebugMarkerObjectNameInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            object_type: DebugReportObjectTypeEXT::default(),
            object: u64::default(),
            p_object_name: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for DebugMarkerObjectNameInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::DEBUG_MARKER_OBJECT_NAME_INFO_EXT;
}
impl DebugMarkerObjectNameInfoEXT {
    pub fn builder<'a>() -> DebugMarkerObjectNameInfoEXTBuilder<'a> {
        DebugMarkerObjectNameInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DebugMarkerObjectNameInfoEXTBuilder<'a> {
    inner: DebugMarkerObjectNameInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DebugMarkerObjectNameInfoEXTBuilder<'a> {
    type Target = DebugMarkerObjectNameInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DebugMarkerObjectNameInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DebugMarkerObjectNameInfoEXTBuilder<'a> {
    #[inline]
    pub fn object_type(mut self, object_type: DebugReportObjectTypeEXT) -> Self {
        self.inner.object_type = object_type;
        self
    }
    #[inline]
    pub fn object(mut self, object: u64) -> Self {
        self.inner.object = object;
        self
    }
    #[inline]
    pub fn object_name(mut self, object_name: &'a ::std::ffi::CStr) -> Self {
        self.inner.p_object_name = object_name.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DebugMarkerObjectNameInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugMarkerObjectTagInfoEXT.html>"]
pub struct DebugMarkerObjectTagInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub object_type: DebugReportObjectTypeEXT,
    pub object: u64,
    pub tag_name: u64,
    pub tag_size: usize,
    pub p_tag: *const c_void,
}
impl ::std::default::Default for DebugMarkerObjectTagInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            object_type: DebugReportObjectTypeEXT::default(),
            object: u64::default(),
            tag_name: u64::default(),
            tag_size: usize::default(),
            p_tag: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for DebugMarkerObjectTagInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::DEBUG_MARKER_OBJECT_TAG_INFO_EXT;
}
impl DebugMarkerObjectTagInfoEXT {
    pub fn builder<'a>() -> DebugMarkerObjectTagInfoEXTBuilder<'a> {
        DebugMarkerObjectTagInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DebugMarkerObjectTagInfoEXTBuilder<'a> {
    inner: DebugMarkerObjectTagInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DebugMarkerObjectTagInfoEXTBuilder<'a> {
    type Target = DebugMarkerObjectTagInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DebugMarkerObjectTagInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DebugMarkerObjectTagInfoEXTBuilder<'a> {
    #[inline]
    pub fn object_type(mut self, object_type: DebugReportObjectTypeEXT) -> Self {
        self.inner.object_type = object_type;
        self
    }
    #[inline]
    pub fn object(mut self, object: u64) -> Self {
        self.inner.object = object;
        self
    }
    #[inline]
    pub fn tag_name(mut self, tag_name: u64) -> Self {
        self.inner.tag_name = tag_name;
        self
    }
    #[inline]
    pub fn tag(mut self, tag: &'a [u8]) -> Self {
        self.inner.tag_size = tag.len();
        self.inner.p_tag = tag.as_ptr().cast();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DebugMarkerObjectTagInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugMarkerMarkerInfoEXT.html>"]
pub struct DebugMarkerMarkerInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_marker_name: *const c_char,
    pub color: [f32; 4],
}
impl ::std::default::Default for DebugMarkerMarkerInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_marker_name: ::std::ptr::null(),
            color: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for DebugMarkerMarkerInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::DEBUG_MARKER_MARKER_INFO_EXT;
}
impl DebugMarkerMarkerInfoEXT {
    pub fn builder<'a>() -> DebugMarkerMarkerInfoEXTBuilder<'a> {
        DebugMarkerMarkerInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DebugMarkerMarkerInfoEXTBuilder<'a> {
    inner: DebugMarkerMarkerInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DebugMarkerMarkerInfoEXTBuilder<'a> {
    type Target = DebugMarkerMarkerInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DebugMarkerMarkerInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DebugMarkerMarkerInfoEXTBuilder<'a> {
    #[inline]
    pub fn marker_name(mut self, marker_name: &'a ::std::ffi::CStr) -> Self {
        self.inner.p_marker_name = marker_name.as_ptr();
        self
    }
    #[inline]
    pub fn color(mut self, color: [f32; 4]) -> Self {
        self.inner.color = color;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DebugMarkerMarkerInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDedicatedAllocationImageCreateInfoNV.html>"]
pub struct DedicatedAllocationImageCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub dedicated_allocation: Bool32,
}
impl ::std::default::Default for DedicatedAllocationImageCreateInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            dedicated_allocation: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for DedicatedAllocationImageCreateInfoNV {
    const STRUCTURE_TYPE: StructureType = StructureType::DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV;
}
impl DedicatedAllocationImageCreateInfoNV {
    pub fn builder<'a>() -> DedicatedAllocationImageCreateInfoNVBuilder<'a> {
        DedicatedAllocationImageCreateInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DedicatedAllocationImageCreateInfoNVBuilder<'a> {
    inner: DedicatedAllocationImageCreateInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageCreateInfo for DedicatedAllocationImageCreateInfoNVBuilder<'_> {}
unsafe impl ExtendsImageCreateInfo for DedicatedAllocationImageCreateInfoNV {}
impl<'a> ::std::ops::Deref for DedicatedAllocationImageCreateInfoNVBuilder<'a> {
    type Target = DedicatedAllocationImageCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DedicatedAllocationImageCreateInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DedicatedAllocationImageCreateInfoNVBuilder<'a> {
    #[inline]
    pub fn dedicated_allocation(mut self, dedicated_allocation: bool) -> Self {
        self.inner.dedicated_allocation = dedicated_allocation.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DedicatedAllocationImageCreateInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDedicatedAllocationBufferCreateInfoNV.html>"]
pub struct DedicatedAllocationBufferCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub dedicated_allocation: Bool32,
}
impl ::std::default::Default for DedicatedAllocationBufferCreateInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            dedicated_allocation: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for DedicatedAllocationBufferCreateInfoNV {
    const STRUCTURE_TYPE: StructureType = StructureType::DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV;
}
impl DedicatedAllocationBufferCreateInfoNV {
    pub fn builder<'a>() -> DedicatedAllocationBufferCreateInfoNVBuilder<'a> {
        DedicatedAllocationBufferCreateInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DedicatedAllocationBufferCreateInfoNVBuilder<'a> {
    inner: DedicatedAllocationBufferCreateInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsBufferCreateInfo for DedicatedAllocationBufferCreateInfoNVBuilder<'_> {}
unsafe impl ExtendsBufferCreateInfo for DedicatedAllocationBufferCreateInfoNV {}
impl<'a> ::std::ops::Deref for DedicatedAllocationBufferCreateInfoNVBuilder<'a> {
    type Target = DedicatedAllocationBufferCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DedicatedAllocationBufferCreateInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DedicatedAllocationBufferCreateInfoNVBuilder<'a> {
    #[inline]
    pub fn dedicated_allocation(mut self, dedicated_allocation: bool) -> Self {
        self.inner.dedicated_allocation = dedicated_allocation.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DedicatedAllocationBufferCreateInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDedicatedAllocationMemoryAllocateInfoNV.html>"]
pub struct DedicatedAllocationMemoryAllocateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image: Image,
    pub buffer: Buffer,
}
impl ::std::default::Default for DedicatedAllocationMemoryAllocateInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image: Image::default(),
            buffer: Buffer::default(),
        }
    }
}
unsafe impl TaggedStructure for DedicatedAllocationMemoryAllocateInfoNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV;
}
impl DedicatedAllocationMemoryAllocateInfoNV {
    pub fn builder<'a>() -> DedicatedAllocationMemoryAllocateInfoNVBuilder<'a> {
        DedicatedAllocationMemoryAllocateInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DedicatedAllocationMemoryAllocateInfoNVBuilder<'a> {
    inner: DedicatedAllocationMemoryAllocateInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsMemoryAllocateInfo for DedicatedAllocationMemoryAllocateInfoNVBuilder<'_> {}
unsafe impl ExtendsMemoryAllocateInfo for DedicatedAllocationMemoryAllocateInfoNV {}
impl<'a> ::std::ops::Deref for DedicatedAllocationMemoryAllocateInfoNVBuilder<'a> {
    type Target = DedicatedAllocationMemoryAllocateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DedicatedAllocationMemoryAllocateInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DedicatedAllocationMemoryAllocateInfoNVBuilder<'a> {
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.inner.image = image;
        self
    }
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DedicatedAllocationMemoryAllocateInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalImageFormatPropertiesNV.html>"]
pub struct ExternalImageFormatPropertiesNV {
    pub image_format_properties: ImageFormatProperties,
    pub external_memory_features: ExternalMemoryFeatureFlagsNV,
    pub export_from_imported_handle_types: ExternalMemoryHandleTypeFlagsNV,
    pub compatible_handle_types: ExternalMemoryHandleTypeFlagsNV,
}
impl ExternalImageFormatPropertiesNV {
    pub fn builder<'a>() -> ExternalImageFormatPropertiesNVBuilder<'a> {
        ExternalImageFormatPropertiesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExternalImageFormatPropertiesNVBuilder<'a> {
    inner: ExternalImageFormatPropertiesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ExternalImageFormatPropertiesNVBuilder<'a> {
    type Target = ExternalImageFormatPropertiesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExternalImageFormatPropertiesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExternalImageFormatPropertiesNVBuilder<'a> {
    #[inline]
    pub fn image_format_properties(
        mut self,
        image_format_properties: ImageFormatProperties,
    ) -> Self {
        self.inner.image_format_properties = image_format_properties;
        self
    }
    #[inline]
    pub fn external_memory_features(
        mut self,
        external_memory_features: ExternalMemoryFeatureFlagsNV,
    ) -> Self {
        self.inner.external_memory_features = external_memory_features;
        self
    }
    #[inline]
    pub fn export_from_imported_handle_types(
        mut self,
        export_from_imported_handle_types: ExternalMemoryHandleTypeFlagsNV,
    ) -> Self {
        self.inner.export_from_imported_handle_types = export_from_imported_handle_types;
        self
    }
    #[inline]
    pub fn compatible_handle_types(
        mut self,
        compatible_handle_types: ExternalMemoryHandleTypeFlagsNV,
    ) -> Self {
        self.inner.compatible_handle_types = compatible_handle_types;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExternalImageFormatPropertiesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryImageCreateInfoNV.html>"]
pub struct ExternalMemoryImageCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalMemoryHandleTypeFlagsNV,
}
impl ::std::default::Default for ExternalMemoryImageCreateInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_types: ExternalMemoryHandleTypeFlagsNV::default(),
        }
    }
}
unsafe impl TaggedStructure for ExternalMemoryImageCreateInfoNV {
    const STRUCTURE_TYPE: StructureType = StructureType::EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV;
}
impl ExternalMemoryImageCreateInfoNV {
    pub fn builder<'a>() -> ExternalMemoryImageCreateInfoNVBuilder<'a> {
        ExternalMemoryImageCreateInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExternalMemoryImageCreateInfoNVBuilder<'a> {
    inner: ExternalMemoryImageCreateInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageCreateInfo for ExternalMemoryImageCreateInfoNVBuilder<'_> {}
unsafe impl ExtendsImageCreateInfo for ExternalMemoryImageCreateInfoNV {}
impl<'a> ::std::ops::Deref for ExternalMemoryImageCreateInfoNVBuilder<'a> {
    type Target = ExternalMemoryImageCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExternalMemoryImageCreateInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExternalMemoryImageCreateInfoNVBuilder<'a> {
    #[inline]
    pub fn handle_types(mut self, handle_types: ExternalMemoryHandleTypeFlagsNV) -> Self {
        self.inner.handle_types = handle_types;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExternalMemoryImageCreateInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMemoryAllocateInfoNV.html>"]
pub struct ExportMemoryAllocateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalMemoryHandleTypeFlagsNV,
}
impl ::std::default::Default for ExportMemoryAllocateInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_types: ExternalMemoryHandleTypeFlagsNV::default(),
        }
    }
}
unsafe impl TaggedStructure for ExportMemoryAllocateInfoNV {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_MEMORY_ALLOCATE_INFO_NV;
}
impl ExportMemoryAllocateInfoNV {
    pub fn builder<'a>() -> ExportMemoryAllocateInfoNVBuilder<'a> {
        ExportMemoryAllocateInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExportMemoryAllocateInfoNVBuilder<'a> {
    inner: ExportMemoryAllocateInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsMemoryAllocateInfo for ExportMemoryAllocateInfoNVBuilder<'_> {}
unsafe impl ExtendsMemoryAllocateInfo for ExportMemoryAllocateInfoNV {}
impl<'a> ::std::ops::Deref for ExportMemoryAllocateInfoNVBuilder<'a> {
    type Target = ExportMemoryAllocateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExportMemoryAllocateInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExportMemoryAllocateInfoNVBuilder<'a> {
    #[inline]
    pub fn handle_types(mut self, handle_types: ExternalMemoryHandleTypeFlagsNV) -> Self {
        self.inner.handle_types = handle_types;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExportMemoryAllocateInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMemoryWin32HandleInfoNV.html>"]
pub struct ImportMemoryWin32HandleInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalMemoryHandleTypeFlagsNV,
    pub handle: HANDLE,
}
impl ::std::default::Default for ImportMemoryWin32HandleInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_type: ExternalMemoryHandleTypeFlagsNV::default(),
            handle: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for ImportMemoryWin32HandleInfoNV {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_MEMORY_WIN32_HANDLE_INFO_NV;
}
impl ImportMemoryWin32HandleInfoNV {
    pub fn builder<'a>() -> ImportMemoryWin32HandleInfoNVBuilder<'a> {
        ImportMemoryWin32HandleInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImportMemoryWin32HandleInfoNVBuilder<'a> {
    inner: ImportMemoryWin32HandleInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsMemoryAllocateInfo for ImportMemoryWin32HandleInfoNVBuilder<'_> {}
unsafe impl ExtendsMemoryAllocateInfo for ImportMemoryWin32HandleInfoNV {}
impl<'a> ::std::ops::Deref for ImportMemoryWin32HandleInfoNVBuilder<'a> {
    type Target = ImportMemoryWin32HandleInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImportMemoryWin32HandleInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImportMemoryWin32HandleInfoNVBuilder<'a> {
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlagsNV) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    #[inline]
    pub fn handle(mut self, handle: HANDLE) -> Self {
        self.inner.handle = handle;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImportMemoryWin32HandleInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMemoryWin32HandleInfoNV.html>"]
pub struct ExportMemoryWin32HandleInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_attributes: *const SECURITY_ATTRIBUTES,
    pub dw_access: DWORD,
}
impl ::std::default::Default for ExportMemoryWin32HandleInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_attributes: ::std::ptr::null(),
            dw_access: DWORD::default(),
        }
    }
}
unsafe impl TaggedStructure for ExportMemoryWin32HandleInfoNV {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_MEMORY_WIN32_HANDLE_INFO_NV;
}
impl ExportMemoryWin32HandleInfoNV {
    pub fn builder<'a>() -> ExportMemoryWin32HandleInfoNVBuilder<'a> {
        ExportMemoryWin32HandleInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExportMemoryWin32HandleInfoNVBuilder<'a> {
    inner: ExportMemoryWin32HandleInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsMemoryAllocateInfo for ExportMemoryWin32HandleInfoNVBuilder<'_> {}
unsafe impl ExtendsMemoryAllocateInfo for ExportMemoryWin32HandleInfoNV {}
impl<'a> ::std::ops::Deref for ExportMemoryWin32HandleInfoNVBuilder<'a> {
    type Target = ExportMemoryWin32HandleInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExportMemoryWin32HandleInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExportMemoryWin32HandleInfoNVBuilder<'a> {
    #[inline]
    pub fn attributes(mut self, attributes: &'a SECURITY_ATTRIBUTES) -> Self {
        self.inner.p_attributes = attributes;
        self
    }
    #[inline]
    pub fn dw_access(mut self, dw_access: DWORD) -> Self {
        self.inner.dw_access = dw_access;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExportMemoryWin32HandleInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWin32KeyedMutexAcquireReleaseInfoNV.html>"]
pub struct Win32KeyedMutexAcquireReleaseInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acquire_count: u32,
    pub p_acquire_syncs: *const DeviceMemory,
    pub p_acquire_keys: *const u64,
    pub p_acquire_timeout_milliseconds: *const u32,
    pub release_count: u32,
    pub p_release_syncs: *const DeviceMemory,
    pub p_release_keys: *const u64,
}
impl ::std::default::Default for Win32KeyedMutexAcquireReleaseInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            acquire_count: u32::default(),
            p_acquire_syncs: ::std::ptr::null(),
            p_acquire_keys: ::std::ptr::null(),
            p_acquire_timeout_milliseconds: ::std::ptr::null(),
            release_count: u32::default(),
            p_release_syncs: ::std::ptr::null(),
            p_release_keys: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for Win32KeyedMutexAcquireReleaseInfoNV {
    const STRUCTURE_TYPE: StructureType = StructureType::WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV;
}
impl Win32KeyedMutexAcquireReleaseInfoNV {
    pub fn builder<'a>() -> Win32KeyedMutexAcquireReleaseInfoNVBuilder<'a> {
        Win32KeyedMutexAcquireReleaseInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct Win32KeyedMutexAcquireReleaseInfoNVBuilder<'a> {
    inner: Win32KeyedMutexAcquireReleaseInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSubmitInfo for Win32KeyedMutexAcquireReleaseInfoNVBuilder<'_> {}
unsafe impl ExtendsSubmitInfo for Win32KeyedMutexAcquireReleaseInfoNV {}
unsafe impl ExtendsSubmitInfo2 for Win32KeyedMutexAcquireReleaseInfoNVBuilder<'_> {}
unsafe impl ExtendsSubmitInfo2 for Win32KeyedMutexAcquireReleaseInfoNV {}
impl<'a> ::std::ops::Deref for Win32KeyedMutexAcquireReleaseInfoNVBuilder<'a> {
    type Target = Win32KeyedMutexAcquireReleaseInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for Win32KeyedMutexAcquireReleaseInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> Win32KeyedMutexAcquireReleaseInfoNVBuilder<'a> {
    #[inline]
    pub fn acquire_syncs(mut self, acquire_syncs: &'a [DeviceMemory]) -> Self {
        self.inner.acquire_count = acquire_syncs.len() as _;
        self.inner.p_acquire_syncs = acquire_syncs.as_ptr();
        self
    }
    #[inline]
    pub fn acquire_keys(mut self, acquire_keys: &'a [u64]) -> Self {
        self.inner.acquire_count = acquire_keys.len() as _;
        self.inner.p_acquire_keys = acquire_keys.as_ptr();
        self
    }
    #[inline]
    pub fn acquire_timeout_milliseconds(mut self, acquire_timeout_milliseconds: &'a [u32]) -> Self {
        self.inner.acquire_count = acquire_timeout_milliseconds.len() as _;
        self.inner.p_acquire_timeout_milliseconds = acquire_timeout_milliseconds.as_ptr();
        self
    }
    #[inline]
    pub fn release_syncs(mut self, release_syncs: &'a [DeviceMemory]) -> Self {
        self.inner.release_count = release_syncs.len() as _;
        self.inner.p_release_syncs = release_syncs.as_ptr();
        self
    }
    #[inline]
    pub fn release_keys(mut self, release_keys: &'a [u64]) -> Self {
        self.inner.release_count = release_keys.len() as _;
        self.inner.p_release_keys = release_keys.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> Win32KeyedMutexAcquireReleaseInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV.html>"]
pub struct PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_generated_commands: Bool32,
}
impl ::std::default::Default for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            device_generated_commands: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV;
}
impl PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
    pub fn builder<'a>() -> PhysicalDeviceDeviceGeneratedCommandsFeaturesNVBuilder<'a> {
        PhysicalDeviceDeviceGeneratedCommandsFeaturesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceDeviceGeneratedCommandsFeaturesNVBuilder<'a> {
    inner: PhysicalDeviceDeviceGeneratedCommandsFeaturesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceDeviceGeneratedCommandsFeaturesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDeviceGeneratedCommandsFeaturesNVBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceDeviceGeneratedCommandsFeaturesNVBuilder<'a> {
    type Target = PhysicalDeviceDeviceGeneratedCommandsFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceDeviceGeneratedCommandsFeaturesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceDeviceGeneratedCommandsFeaturesNVBuilder<'a> {
    #[inline]
    pub fn device_generated_commands(mut self, device_generated_commands: bool) -> Self {
        self.inner.device_generated_commands = device_generated_commands.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDevicePrivateDataCreateInfo.html>"]
pub struct DevicePrivateDataCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub private_data_slot_request_count: u32,
}
impl ::std::default::Default for DevicePrivateDataCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            private_data_slot_request_count: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for DevicePrivateDataCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_PRIVATE_DATA_CREATE_INFO;
}
impl DevicePrivateDataCreateInfo {
    pub fn builder<'a>() -> DevicePrivateDataCreateInfoBuilder<'a> {
        DevicePrivateDataCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DevicePrivateDataCreateInfoBuilder<'a> {
    inner: DevicePrivateDataCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsDeviceCreateInfo for DevicePrivateDataCreateInfoBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for DevicePrivateDataCreateInfo {}
impl<'a> ::std::ops::Deref for DevicePrivateDataCreateInfoBuilder<'a> {
    type Target = DevicePrivateDataCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DevicePrivateDataCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DevicePrivateDataCreateInfoBuilder<'a> {
    #[inline]
    pub fn private_data_slot_request_count(mut self, private_data_slot_request_count: u32) -> Self {
        self.inner.private_data_slot_request_count = private_data_slot_request_count;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DevicePrivateDataCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPrivateDataSlotCreateInfo.html>"]
pub struct PrivateDataSlotCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PrivateDataSlotCreateFlags,
}
impl ::std::default::Default for PrivateDataSlotCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PrivateDataSlotCreateFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for PrivateDataSlotCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::PRIVATE_DATA_SLOT_CREATE_INFO;
}
impl PrivateDataSlotCreateInfo {
    pub fn builder<'a>() -> PrivateDataSlotCreateInfoBuilder<'a> {
        PrivateDataSlotCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PrivateDataSlotCreateInfoBuilder<'a> {
    inner: PrivateDataSlotCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PrivateDataSlotCreateInfoBuilder<'a> {
    type Target = PrivateDataSlotCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PrivateDataSlotCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PrivateDataSlotCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PrivateDataSlotCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PrivateDataSlotCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePrivateDataFeatures.html>"]
pub struct PhysicalDevicePrivateDataFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub private_data: Bool32,
}
impl ::std::default::Default for PhysicalDevicePrivateDataFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            private_data: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevicePrivateDataFeatures {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES;
}
impl PhysicalDevicePrivateDataFeatures {
    pub fn builder<'a>() -> PhysicalDevicePrivateDataFeaturesBuilder<'a> {
        PhysicalDevicePrivateDataFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevicePrivateDataFeaturesBuilder<'a> {
    inner: PhysicalDevicePrivateDataFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePrivateDataFeaturesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePrivateDataFeatures {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePrivateDataFeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePrivateDataFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDevicePrivateDataFeaturesBuilder<'a> {
    type Target = PhysicalDevicePrivateDataFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevicePrivateDataFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevicePrivateDataFeaturesBuilder<'a> {
    #[inline]
    pub fn private_data(mut self, private_data: bool) -> Self {
        self.inner.private_data = private_data.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevicePrivateDataFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV.html>"]
pub struct PhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_graphics_shader_group_count: u32,
    pub max_indirect_sequence_count: u32,
    pub max_indirect_commands_token_count: u32,
    pub max_indirect_commands_stream_count: u32,
    pub max_indirect_commands_token_offset: u32,
    pub max_indirect_commands_stream_stride: u32,
    pub min_sequences_count_buffer_offset_alignment: u32,
    pub min_sequences_index_buffer_offset_alignment: u32,
    pub min_indirect_commands_buffer_offset_alignment: u32,
}
impl ::std::default::Default for PhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_graphics_shader_group_count: u32::default(),
            max_indirect_sequence_count: u32::default(),
            max_indirect_commands_token_count: u32::default(),
            max_indirect_commands_stream_count: u32::default(),
            max_indirect_commands_token_offset: u32::default(),
            max_indirect_commands_stream_stride: u32::default(),
            min_sequences_count_buffer_offset_alignment: u32::default(),
            min_sequences_index_buffer_offset_alignment: u32::default(),
            min_indirect_commands_buffer_offset_alignment: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV;
}
impl PhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
    pub fn builder<'a>() -> PhysicalDeviceDeviceGeneratedCommandsPropertiesNVBuilder<'a> {
        PhysicalDeviceDeviceGeneratedCommandsPropertiesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceDeviceGeneratedCommandsPropertiesNVBuilder<'a> {
    inner: PhysicalDeviceDeviceGeneratedCommandsPropertiesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceDeviceGeneratedCommandsPropertiesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceDeviceGeneratedCommandsPropertiesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceDeviceGeneratedCommandsPropertiesNVBuilder<'a> {
    type Target = PhysicalDeviceDeviceGeneratedCommandsPropertiesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceDeviceGeneratedCommandsPropertiesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceDeviceGeneratedCommandsPropertiesNVBuilder<'a> {
    #[inline]
    pub fn max_graphics_shader_group_count(mut self, max_graphics_shader_group_count: u32) -> Self {
        self.inner.max_graphics_shader_group_count = max_graphics_shader_group_count;
        self
    }
    #[inline]
    pub fn max_indirect_sequence_count(mut self, max_indirect_sequence_count: u32) -> Self {
        self.inner.max_indirect_sequence_count = max_indirect_sequence_count;
        self
    }
    #[inline]
    pub fn max_indirect_commands_token_count(
        mut self,
        max_indirect_commands_token_count: u32,
    ) -> Self {
        self.inner.max_indirect_commands_token_count = max_indirect_commands_token_count;
        self
    }
    #[inline]
    pub fn max_indirect_commands_stream_count(
        mut self,
        max_indirect_commands_stream_count: u32,
    ) -> Self {
        self.inner.max_indirect_commands_stream_count = max_indirect_commands_stream_count;
        self
    }
    #[inline]
    pub fn max_indirect_commands_token_offset(
        mut self,
        max_indirect_commands_token_offset: u32,
    ) -> Self {
        self.inner.max_indirect_commands_token_offset = max_indirect_commands_token_offset;
        self
    }
    #[inline]
    pub fn max_indirect_commands_stream_stride(
        mut self,
        max_indirect_commands_stream_stride: u32,
    ) -> Self {
        self.inner.max_indirect_commands_stream_stride = max_indirect_commands_stream_stride;
        self
    }
    #[inline]
    pub fn min_sequences_count_buffer_offset_alignment(
        mut self,
        min_sequences_count_buffer_offset_alignment: u32,
    ) -> Self {
        self.inner.min_sequences_count_buffer_offset_alignment =
            min_sequences_count_buffer_offset_alignment;
        self
    }
    #[inline]
    pub fn min_sequences_index_buffer_offset_alignment(
        mut self,
        min_sequences_index_buffer_offset_alignment: u32,
    ) -> Self {
        self.inner.min_sequences_index_buffer_offset_alignment =
            min_sequences_index_buffer_offset_alignment;
        self
    }
    #[inline]
    pub fn min_indirect_commands_buffer_offset_alignment(
        mut self,
        min_indirect_commands_buffer_offset_alignment: u32,
    ) -> Self {
        self.inner.min_indirect_commands_buffer_offset_alignment =
            min_indirect_commands_buffer_offset_alignment;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiDrawPropertiesEXT.html>"]
pub struct PhysicalDeviceMultiDrawPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_multi_draw_count: u32,
}
impl ::std::default::Default for PhysicalDeviceMultiDrawPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_multi_draw_count: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceMultiDrawPropertiesEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT;
}
impl PhysicalDeviceMultiDrawPropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceMultiDrawPropertiesEXTBuilder<'a> {
        PhysicalDeviceMultiDrawPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceMultiDrawPropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceMultiDrawPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceMultiDrawPropertiesEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceMultiDrawPropertiesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceMultiDrawPropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceMultiDrawPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceMultiDrawPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceMultiDrawPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn max_multi_draw_count(mut self, max_multi_draw_count: u32) -> Self {
        self.inner.max_multi_draw_count = max_multi_draw_count;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceMultiDrawPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGraphicsShaderGroupCreateInfoNV.html>"]
pub struct GraphicsShaderGroupCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub stage_count: u32,
    pub p_stages: *const PipelineShaderStageCreateInfo,
    pub p_vertex_input_state: *const PipelineVertexInputStateCreateInfo,
    pub p_tessellation_state: *const PipelineTessellationStateCreateInfo,
}
impl ::std::default::Default for GraphicsShaderGroupCreateInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            stage_count: u32::default(),
            p_stages: ::std::ptr::null(),
            p_vertex_input_state: ::std::ptr::null(),
            p_tessellation_state: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for GraphicsShaderGroupCreateInfoNV {
    const STRUCTURE_TYPE: StructureType = StructureType::GRAPHICS_SHADER_GROUP_CREATE_INFO_NV;
}
impl GraphicsShaderGroupCreateInfoNV {
    pub fn builder<'a>() -> GraphicsShaderGroupCreateInfoNVBuilder<'a> {
        GraphicsShaderGroupCreateInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct GraphicsShaderGroupCreateInfoNVBuilder<'a> {
    inner: GraphicsShaderGroupCreateInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for GraphicsShaderGroupCreateInfoNVBuilder<'a> {
    type Target = GraphicsShaderGroupCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for GraphicsShaderGroupCreateInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> GraphicsShaderGroupCreateInfoNVBuilder<'a> {
    #[inline]
    pub fn stages(mut self, stages: &'a [PipelineShaderStageCreateInfo]) -> Self {
        self.inner.stage_count = stages.len() as _;
        self.inner.p_stages = stages.as_ptr();
        self
    }
    #[inline]
    pub fn vertex_input_state(
        mut self,
        vertex_input_state: &'a PipelineVertexInputStateCreateInfo,
    ) -> Self {
        self.inner.p_vertex_input_state = vertex_input_state;
        self
    }
    #[inline]
    pub fn tessellation_state(
        mut self,
        tessellation_state: &'a PipelineTessellationStateCreateInfo,
    ) -> Self {
        self.inner.p_tessellation_state = tessellation_state;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> GraphicsShaderGroupCreateInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGraphicsPipelineShaderGroupsCreateInfoNV.html>"]
pub struct GraphicsPipelineShaderGroupsCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub group_count: u32,
    pub p_groups: *const GraphicsShaderGroupCreateInfoNV,
    pub pipeline_count: u32,
    pub p_pipelines: *const Pipeline,
}
impl ::std::default::Default for GraphicsPipelineShaderGroupsCreateInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            group_count: u32::default(),
            p_groups: ::std::ptr::null(),
            pipeline_count: u32::default(),
            p_pipelines: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for GraphicsPipelineShaderGroupsCreateInfoNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV;
}
impl GraphicsPipelineShaderGroupsCreateInfoNV {
    pub fn builder<'a>() -> GraphicsPipelineShaderGroupsCreateInfoNVBuilder<'a> {
        GraphicsPipelineShaderGroupsCreateInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct GraphicsPipelineShaderGroupsCreateInfoNVBuilder<'a> {
    inner: GraphicsPipelineShaderGroupsCreateInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsGraphicsPipelineCreateInfo
    for GraphicsPipelineShaderGroupsCreateInfoNVBuilder<'_>
{
}
unsafe impl ExtendsGraphicsPipelineCreateInfo for GraphicsPipelineShaderGroupsCreateInfoNV {}
impl<'a> ::std::ops::Deref for GraphicsPipelineShaderGroupsCreateInfoNVBuilder<'a> {
    type Target = GraphicsPipelineShaderGroupsCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for GraphicsPipelineShaderGroupsCreateInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> GraphicsPipelineShaderGroupsCreateInfoNVBuilder<'a> {
    #[inline]
    pub fn groups(mut self, groups: &'a [GraphicsShaderGroupCreateInfoNV]) -> Self {
        self.inner.group_count = groups.len() as _;
        self.inner.p_groups = groups.as_ptr();
        self
    }
    #[inline]
    pub fn pipelines(mut self, pipelines: &'a [Pipeline]) -> Self {
        self.inner.pipeline_count = pipelines.len() as _;
        self.inner.p_pipelines = pipelines.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> GraphicsPipelineShaderGroupsCreateInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindShaderGroupIndirectCommandNV.html>"]
pub struct BindShaderGroupIndirectCommandNV {
    pub group_index: u32,
}
impl BindShaderGroupIndirectCommandNV {
    pub fn builder<'a>() -> BindShaderGroupIndirectCommandNVBuilder<'a> {
        BindShaderGroupIndirectCommandNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BindShaderGroupIndirectCommandNVBuilder<'a> {
    inner: BindShaderGroupIndirectCommandNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for BindShaderGroupIndirectCommandNVBuilder<'a> {
    type Target = BindShaderGroupIndirectCommandNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BindShaderGroupIndirectCommandNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BindShaderGroupIndirectCommandNVBuilder<'a> {
    #[inline]
    pub fn group_index(mut self, group_index: u32) -> Self {
        self.inner.group_index = group_index;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BindShaderGroupIndirectCommandNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindIndexBufferIndirectCommandNV.html>"]
pub struct BindIndexBufferIndirectCommandNV {
    pub buffer_address: DeviceAddress,
    pub size: u32,
    pub index_type: IndexType,
}
impl BindIndexBufferIndirectCommandNV {
    pub fn builder<'a>() -> BindIndexBufferIndirectCommandNVBuilder<'a> {
        BindIndexBufferIndirectCommandNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BindIndexBufferIndirectCommandNVBuilder<'a> {
    inner: BindIndexBufferIndirectCommandNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for BindIndexBufferIndirectCommandNVBuilder<'a> {
    type Target = BindIndexBufferIndirectCommandNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BindIndexBufferIndirectCommandNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BindIndexBufferIndirectCommandNVBuilder<'a> {
    #[inline]
    pub fn buffer_address(mut self, buffer_address: DeviceAddress) -> Self {
        self.inner.buffer_address = buffer_address;
        self
    }
    #[inline]
    pub fn size(mut self, size: u32) -> Self {
        self.inner.size = size;
        self
    }
    #[inline]
    pub fn index_type(mut self, index_type: IndexType) -> Self {
        self.inner.index_type = index_type;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BindIndexBufferIndirectCommandNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindVertexBufferIndirectCommandNV.html>"]
pub struct BindVertexBufferIndirectCommandNV {
    pub buffer_address: DeviceAddress,
    pub size: u32,
    pub stride: u32,
}
impl BindVertexBufferIndirectCommandNV {
    pub fn builder<'a>() -> BindVertexBufferIndirectCommandNVBuilder<'a> {
        BindVertexBufferIndirectCommandNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BindVertexBufferIndirectCommandNVBuilder<'a> {
    inner: BindVertexBufferIndirectCommandNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for BindVertexBufferIndirectCommandNVBuilder<'a> {
    type Target = BindVertexBufferIndirectCommandNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BindVertexBufferIndirectCommandNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BindVertexBufferIndirectCommandNVBuilder<'a> {
    #[inline]
    pub fn buffer_address(mut self, buffer_address: DeviceAddress) -> Self {
        self.inner.buffer_address = buffer_address;
        self
    }
    #[inline]
    pub fn size(mut self, size: u32) -> Self {
        self.inner.size = size;
        self
    }
    #[inline]
    pub fn stride(mut self, stride: u32) -> Self {
        self.inner.stride = stride;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BindVertexBufferIndirectCommandNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSetStateFlagsIndirectCommandNV.html>"]
pub struct SetStateFlagsIndirectCommandNV {
    pub data: u32,
}
impl SetStateFlagsIndirectCommandNV {
    pub fn builder<'a>() -> SetStateFlagsIndirectCommandNVBuilder<'a> {
        SetStateFlagsIndirectCommandNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SetStateFlagsIndirectCommandNVBuilder<'a> {
    inner: SetStateFlagsIndirectCommandNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SetStateFlagsIndirectCommandNVBuilder<'a> {
    type Target = SetStateFlagsIndirectCommandNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SetStateFlagsIndirectCommandNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SetStateFlagsIndirectCommandNVBuilder<'a> {
    #[inline]
    pub fn data(mut self, data: u32) -> Self {
        self.inner.data = data;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SetStateFlagsIndirectCommandNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkIndirectCommandsStreamNV.html>"]
pub struct IndirectCommandsStreamNV {
    pub buffer: Buffer,
    pub offset: DeviceSize,
}
impl IndirectCommandsStreamNV {
    pub fn builder<'a>() -> IndirectCommandsStreamNVBuilder<'a> {
        IndirectCommandsStreamNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct IndirectCommandsStreamNVBuilder<'a> {
    inner: IndirectCommandsStreamNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for IndirectCommandsStreamNVBuilder<'a> {
    type Target = IndirectCommandsStreamNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for IndirectCommandsStreamNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> IndirectCommandsStreamNVBuilder<'a> {
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: DeviceSize) -> Self {
        self.inner.offset = offset;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> IndirectCommandsStreamNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkIndirectCommandsLayoutTokenNV.html>"]
pub struct IndirectCommandsLayoutTokenNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub token_type: IndirectCommandsTokenTypeNV,
    pub stream: u32,
    pub offset: u32,
    pub vertex_binding_unit: u32,
    pub vertex_dynamic_stride: Bool32,
    pub pushconstant_pipeline_layout: PipelineLayout,
    pub pushconstant_shader_stage_flags: ShaderStageFlags,
    pub pushconstant_offset: u32,
    pub pushconstant_size: u32,
    pub indirect_state_flags: IndirectStateFlagsNV,
    pub index_type_count: u32,
    pub p_index_types: *const IndexType,
    pub p_index_type_values: *const u32,
}
impl ::std::default::Default for IndirectCommandsLayoutTokenNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            token_type: IndirectCommandsTokenTypeNV::default(),
            stream: u32::default(),
            offset: u32::default(),
            vertex_binding_unit: u32::default(),
            vertex_dynamic_stride: Bool32::default(),
            pushconstant_pipeline_layout: PipelineLayout::default(),
            pushconstant_shader_stage_flags: ShaderStageFlags::default(),
            pushconstant_offset: u32::default(),
            pushconstant_size: u32::default(),
            indirect_state_flags: IndirectStateFlagsNV::default(),
            index_type_count: u32::default(),
            p_index_types: ::std::ptr::null(),
            p_index_type_values: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for IndirectCommandsLayoutTokenNV {
    const STRUCTURE_TYPE: StructureType = StructureType::INDIRECT_COMMANDS_LAYOUT_TOKEN_NV;
}
impl IndirectCommandsLayoutTokenNV {
    pub fn builder<'a>() -> IndirectCommandsLayoutTokenNVBuilder<'a> {
        IndirectCommandsLayoutTokenNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct IndirectCommandsLayoutTokenNVBuilder<'a> {
    inner: IndirectCommandsLayoutTokenNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for IndirectCommandsLayoutTokenNVBuilder<'a> {
    type Target = IndirectCommandsLayoutTokenNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for IndirectCommandsLayoutTokenNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> IndirectCommandsLayoutTokenNVBuilder<'a> {
    #[inline]
    pub fn token_type(mut self, token_type: IndirectCommandsTokenTypeNV) -> Self {
        self.inner.token_type = token_type;
        self
    }
    #[inline]
    pub fn stream(mut self, stream: u32) -> Self {
        self.inner.stream = stream;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: u32) -> Self {
        self.inner.offset = offset;
        self
    }
    #[inline]
    pub fn vertex_binding_unit(mut self, vertex_binding_unit: u32) -> Self {
        self.inner.vertex_binding_unit = vertex_binding_unit;
        self
    }
    #[inline]
    pub fn vertex_dynamic_stride(mut self, vertex_dynamic_stride: bool) -> Self {
        self.inner.vertex_dynamic_stride = vertex_dynamic_stride.into();
        self
    }
    #[inline]
    pub fn pushconstant_pipeline_layout(
        mut self,
        pushconstant_pipeline_layout: PipelineLayout,
    ) -> Self {
        self.inner.pushconstant_pipeline_layout = pushconstant_pipeline_layout;
        self
    }
    #[inline]
    pub fn pushconstant_shader_stage_flags(
        mut self,
        pushconstant_shader_stage_flags: ShaderStageFlags,
    ) -> Self {
        self.inner.pushconstant_shader_stage_flags = pushconstant_shader_stage_flags;
        self
    }
    #[inline]
    pub fn pushconstant_offset(mut self, pushconstant_offset: u32) -> Self {
        self.inner.pushconstant_offset = pushconstant_offset;
        self
    }
    #[inline]
    pub fn pushconstant_size(mut self, pushconstant_size: u32) -> Self {
        self.inner.pushconstant_size = pushconstant_size;
        self
    }
    #[inline]
    pub fn indirect_state_flags(mut self, indirect_state_flags: IndirectStateFlagsNV) -> Self {
        self.inner.indirect_state_flags = indirect_state_flags;
        self
    }
    #[inline]
    pub fn index_types(mut self, index_types: &'a [IndexType]) -> Self {
        self.inner.index_type_count = index_types.len() as _;
        self.inner.p_index_types = index_types.as_ptr();
        self
    }
    #[inline]
    pub fn index_type_values(mut self, index_type_values: &'a [u32]) -> Self {
        self.inner.index_type_count = index_type_values.len() as _;
        self.inner.p_index_type_values = index_type_values.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> IndirectCommandsLayoutTokenNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkIndirectCommandsLayoutCreateInfoNV.html>"]
pub struct IndirectCommandsLayoutCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: IndirectCommandsLayoutUsageFlagsNV,
    pub pipeline_bind_point: PipelineBindPoint,
    pub token_count: u32,
    pub p_tokens: *const IndirectCommandsLayoutTokenNV,
    pub stream_count: u32,
    pub p_stream_strides: *const u32,
}
impl ::std::default::Default for IndirectCommandsLayoutCreateInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: IndirectCommandsLayoutUsageFlagsNV::default(),
            pipeline_bind_point: PipelineBindPoint::default(),
            token_count: u32::default(),
            p_tokens: ::std::ptr::null(),
            stream_count: u32::default(),
            p_stream_strides: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for IndirectCommandsLayoutCreateInfoNV {
    const STRUCTURE_TYPE: StructureType = StructureType::INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV;
}
impl IndirectCommandsLayoutCreateInfoNV {
    pub fn builder<'a>() -> IndirectCommandsLayoutCreateInfoNVBuilder<'a> {
        IndirectCommandsLayoutCreateInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct IndirectCommandsLayoutCreateInfoNVBuilder<'a> {
    inner: IndirectCommandsLayoutCreateInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for IndirectCommandsLayoutCreateInfoNVBuilder<'a> {
    type Target = IndirectCommandsLayoutCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for IndirectCommandsLayoutCreateInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> IndirectCommandsLayoutCreateInfoNVBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: IndirectCommandsLayoutUsageFlagsNV) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn pipeline_bind_point(mut self, pipeline_bind_point: PipelineBindPoint) -> Self {
        self.inner.pipeline_bind_point = pipeline_bind_point;
        self
    }
    #[inline]
    pub fn tokens(mut self, tokens: &'a [IndirectCommandsLayoutTokenNV]) -> Self {
        self.inner.token_count = tokens.len() as _;
        self.inner.p_tokens = tokens.as_ptr();
        self
    }
    #[inline]
    pub fn stream_strides(mut self, stream_strides: &'a [u32]) -> Self {
        self.inner.stream_count = stream_strides.len() as _;
        self.inner.p_stream_strides = stream_strides.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> IndirectCommandsLayoutCreateInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGeneratedCommandsInfoNV.html>"]
pub struct GeneratedCommandsInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub pipeline_bind_point: PipelineBindPoint,
    pub pipeline: Pipeline,
    pub indirect_commands_layout: IndirectCommandsLayoutNV,
    pub stream_count: u32,
    pub p_streams: *const IndirectCommandsStreamNV,
    pub sequences_count: u32,
    pub preprocess_buffer: Buffer,
    pub preprocess_offset: DeviceSize,
    pub preprocess_size: DeviceSize,
    pub sequences_count_buffer: Buffer,
    pub sequences_count_offset: DeviceSize,
    pub sequences_index_buffer: Buffer,
    pub sequences_index_offset: DeviceSize,
}
impl ::std::default::Default for GeneratedCommandsInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            pipeline_bind_point: PipelineBindPoint::default(),
            pipeline: Pipeline::default(),
            indirect_commands_layout: IndirectCommandsLayoutNV::default(),
            stream_count: u32::default(),
            p_streams: ::std::ptr::null(),
            sequences_count: u32::default(),
            preprocess_buffer: Buffer::default(),
            preprocess_offset: DeviceSize::default(),
            preprocess_size: DeviceSize::default(),
            sequences_count_buffer: Buffer::default(),
            sequences_count_offset: DeviceSize::default(),
            sequences_index_buffer: Buffer::default(),
            sequences_index_offset: DeviceSize::default(),
        }
    }
}
unsafe impl TaggedStructure for GeneratedCommandsInfoNV {
    const STRUCTURE_TYPE: StructureType = StructureType::GENERATED_COMMANDS_INFO_NV;
}
impl GeneratedCommandsInfoNV {
    pub fn builder<'a>() -> GeneratedCommandsInfoNVBuilder<'a> {
        GeneratedCommandsInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct GeneratedCommandsInfoNVBuilder<'a> {
    inner: GeneratedCommandsInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for GeneratedCommandsInfoNVBuilder<'a> {
    type Target = GeneratedCommandsInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for GeneratedCommandsInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> GeneratedCommandsInfoNVBuilder<'a> {
    #[inline]
    pub fn pipeline_bind_point(mut self, pipeline_bind_point: PipelineBindPoint) -> Self {
        self.inner.pipeline_bind_point = pipeline_bind_point;
        self
    }
    #[inline]
    pub fn pipeline(mut self, pipeline: Pipeline) -> Self {
        self.inner.pipeline = pipeline;
        self
    }
    #[inline]
    pub fn indirect_commands_layout(
        mut self,
        indirect_commands_layout: IndirectCommandsLayoutNV,
    ) -> Self {
        self.inner.indirect_commands_layout = indirect_commands_layout;
        self
    }
    #[inline]
    pub fn streams(mut self, streams: &'a [IndirectCommandsStreamNV]) -> Self {
        self.inner.stream_count = streams.len() as _;
        self.inner.p_streams = streams.as_ptr();
        self
    }
    #[inline]
    pub fn sequences_count(mut self, sequences_count: u32) -> Self {
        self.inner.sequences_count = sequences_count;
        self
    }
    #[inline]
    pub fn preprocess_buffer(mut self, preprocess_buffer: Buffer) -> Self {
        self.inner.preprocess_buffer = preprocess_buffer;
        self
    }
    #[inline]
    pub fn preprocess_offset(mut self, preprocess_offset: DeviceSize) -> Self {
        self.inner.preprocess_offset = preprocess_offset;
        self
    }
    #[inline]
    pub fn preprocess_size(mut self, preprocess_size: DeviceSize) -> Self {
        self.inner.preprocess_size = preprocess_size;
        self
    }
    #[inline]
    pub fn sequences_count_buffer(mut self, sequences_count_buffer: Buffer) -> Self {
        self.inner.sequences_count_buffer = sequences_count_buffer;
        self
    }
    #[inline]
    pub fn sequences_count_offset(mut self, sequences_count_offset: DeviceSize) -> Self {
        self.inner.sequences_count_offset = sequences_count_offset;
        self
    }
    #[inline]
    pub fn sequences_index_buffer(mut self, sequences_index_buffer: Buffer) -> Self {
        self.inner.sequences_index_buffer = sequences_index_buffer;
        self
    }
    #[inline]
    pub fn sequences_index_offset(mut self, sequences_index_offset: DeviceSize) -> Self {
        self.inner.sequences_index_offset = sequences_index_offset;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> GeneratedCommandsInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGeneratedCommandsMemoryRequirementsInfoNV.html>"]
pub struct GeneratedCommandsMemoryRequirementsInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub pipeline_bind_point: PipelineBindPoint,
    pub pipeline: Pipeline,
    pub indirect_commands_layout: IndirectCommandsLayoutNV,
    pub max_sequences_count: u32,
}
impl ::std::default::Default for GeneratedCommandsMemoryRequirementsInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            pipeline_bind_point: PipelineBindPoint::default(),
            pipeline: Pipeline::default(),
            indirect_commands_layout: IndirectCommandsLayoutNV::default(),
            max_sequences_count: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for GeneratedCommandsMemoryRequirementsInfoNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV;
}
impl GeneratedCommandsMemoryRequirementsInfoNV {
    pub fn builder<'a>() -> GeneratedCommandsMemoryRequirementsInfoNVBuilder<'a> {
        GeneratedCommandsMemoryRequirementsInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct GeneratedCommandsMemoryRequirementsInfoNVBuilder<'a> {
    inner: GeneratedCommandsMemoryRequirementsInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for GeneratedCommandsMemoryRequirementsInfoNVBuilder<'a> {
    type Target = GeneratedCommandsMemoryRequirementsInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for GeneratedCommandsMemoryRequirementsInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> GeneratedCommandsMemoryRequirementsInfoNVBuilder<'a> {
    #[inline]
    pub fn pipeline_bind_point(mut self, pipeline_bind_point: PipelineBindPoint) -> Self {
        self.inner.pipeline_bind_point = pipeline_bind_point;
        self
    }
    #[inline]
    pub fn pipeline(mut self, pipeline: Pipeline) -> Self {
        self.inner.pipeline = pipeline;
        self
    }
    #[inline]
    pub fn indirect_commands_layout(
        mut self,
        indirect_commands_layout: IndirectCommandsLayoutNV,
    ) -> Self {
        self.inner.indirect_commands_layout = indirect_commands_layout;
        self
    }
    #[inline]
    pub fn max_sequences_count(mut self, max_sequences_count: u32) -> Self {
        self.inner.max_sequences_count = max_sequences_count;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> GeneratedCommandsMemoryRequirementsInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures2.html>"]
pub struct PhysicalDeviceFeatures2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub features: PhysicalDeviceFeatures,
}
impl ::std::default::Default for PhysicalDeviceFeatures2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            features: PhysicalDeviceFeatures::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceFeatures2 {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_FEATURES_2;
}
impl PhysicalDeviceFeatures2 {
    pub fn builder<'a>() -> PhysicalDeviceFeatures2Builder<'a> {
        PhysicalDeviceFeatures2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceFeatures2Builder<'a> {
    inner: PhysicalDeviceFeatures2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFeatures2Builder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFeatures2 {}
pub unsafe trait ExtendsPhysicalDeviceFeatures2 {}
impl<'a> ::std::ops::Deref for PhysicalDeviceFeatures2Builder<'a> {
    type Target = PhysicalDeviceFeatures2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceFeatures2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceFeatures2Builder<'a> {
    #[inline]
    pub fn features(mut self, features: PhysicalDeviceFeatures) -> Self {
        self.inner.features = features;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPhysicalDeviceFeatures2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceFeatures2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProperties2.html>"]
pub struct PhysicalDeviceProperties2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub properties: PhysicalDeviceProperties,
}
impl ::std::default::Default for PhysicalDeviceProperties2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            properties: PhysicalDeviceProperties::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceProperties2 {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_PROPERTIES_2;
}
impl PhysicalDeviceProperties2 {
    pub fn builder<'a>() -> PhysicalDeviceProperties2Builder<'a> {
        PhysicalDeviceProperties2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceProperties2Builder<'a> {
    inner: PhysicalDeviceProperties2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsPhysicalDeviceProperties2 {}
impl<'a> ::std::ops::Deref for PhysicalDeviceProperties2Builder<'a> {
    type Target = PhysicalDeviceProperties2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceProperties2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceProperties2Builder<'a> {
    #[inline]
    pub fn properties(mut self, properties: PhysicalDeviceProperties) -> Self {
        self.inner.properties = properties;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPhysicalDeviceProperties2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceProperties2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatProperties2.html>"]
pub struct FormatProperties2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub format_properties: FormatProperties,
}
impl ::std::default::Default for FormatProperties2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            format_properties: FormatProperties::default(),
        }
    }
}
unsafe impl TaggedStructure for FormatProperties2 {
    const STRUCTURE_TYPE: StructureType = StructureType::FORMAT_PROPERTIES_2;
}
impl FormatProperties2 {
    pub fn builder<'a>() -> FormatProperties2Builder<'a> {
        FormatProperties2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct FormatProperties2Builder<'a> {
    inner: FormatProperties2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsFormatProperties2 {}
impl<'a> ::std::ops::Deref for FormatProperties2Builder<'a> {
    type Target = FormatProperties2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for FormatProperties2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> FormatProperties2Builder<'a> {
    #[inline]
    pub fn format_properties(mut self, format_properties: FormatProperties) -> Self {
        self.inner.format_properties = format_properties;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsFormatProperties2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> FormatProperties2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageFormatProperties2.html>"]
pub struct ImageFormatProperties2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_format_properties: ImageFormatProperties,
}
impl ::std::default::Default for ImageFormatProperties2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            image_format_properties: ImageFormatProperties::default(),
        }
    }
}
unsafe impl TaggedStructure for ImageFormatProperties2 {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_FORMAT_PROPERTIES_2;
}
impl ImageFormatProperties2 {
    pub fn builder<'a>() -> ImageFormatProperties2Builder<'a> {
        ImageFormatProperties2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageFormatProperties2Builder<'a> {
    inner: ImageFormatProperties2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsImageFormatProperties2 {}
impl<'a> ::std::ops::Deref for ImageFormatProperties2Builder<'a> {
    type Target = ImageFormatProperties2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageFormatProperties2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageFormatProperties2Builder<'a> {
    #[inline]
    pub fn image_format_properties(
        mut self,
        image_format_properties: ImageFormatProperties,
    ) -> Self {
        self.inner.image_format_properties = image_format_properties;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsImageFormatProperties2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageFormatProperties2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageFormatInfo2.html>"]
pub struct PhysicalDeviceImageFormatInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub format: Format,
    pub ty: ImageType,
    pub tiling: ImageTiling,
    pub usage: ImageUsageFlags,
    pub flags: ImageCreateFlags,
}
impl ::std::default::Default for PhysicalDeviceImageFormatInfo2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            format: Format::default(),
            ty: ImageType::default(),
            tiling: ImageTiling::default(),
            usage: ImageUsageFlags::default(),
            flags: ImageCreateFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceImageFormatInfo2 {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2;
}
impl PhysicalDeviceImageFormatInfo2 {
    pub fn builder<'a>() -> PhysicalDeviceImageFormatInfo2Builder<'a> {
        PhysicalDeviceImageFormatInfo2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceImageFormatInfo2Builder<'a> {
    inner: PhysicalDeviceImageFormatInfo2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsPhysicalDeviceImageFormatInfo2 {}
impl<'a> ::std::ops::Deref for PhysicalDeviceImageFormatInfo2Builder<'a> {
    type Target = PhysicalDeviceImageFormatInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceImageFormatInfo2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceImageFormatInfo2Builder<'a> {
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.inner.format = format;
        self
    }
    #[inline]
    pub fn ty(mut self, ty: ImageType) -> Self {
        self.inner.ty = ty;
        self
    }
    #[inline]
    pub fn tiling(mut self, tiling: ImageTiling) -> Self {
        self.inner.tiling = tiling;
        self
    }
    #[inline]
    pub fn usage(mut self, usage: ImageUsageFlags) -> Self {
        self.inner.usage = usage;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: ImageCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPhysicalDeviceImageFormatInfo2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceImageFormatInfo2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyProperties2.html>"]
pub struct QueueFamilyProperties2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub queue_family_properties: QueueFamilyProperties,
}
impl ::std::default::Default for QueueFamilyProperties2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            queue_family_properties: QueueFamilyProperties::default(),
        }
    }
}
unsafe impl TaggedStructure for QueueFamilyProperties2 {
    const STRUCTURE_TYPE: StructureType = StructureType::QUEUE_FAMILY_PROPERTIES_2;
}
impl QueueFamilyProperties2 {
    pub fn builder<'a>() -> QueueFamilyProperties2Builder<'a> {
        QueueFamilyProperties2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct QueueFamilyProperties2Builder<'a> {
    inner: QueueFamilyProperties2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsQueueFamilyProperties2 {}
impl<'a> ::std::ops::Deref for QueueFamilyProperties2Builder<'a> {
    type Target = QueueFamilyProperties2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for QueueFamilyProperties2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> QueueFamilyProperties2Builder<'a> {
    #[inline]
    pub fn queue_family_properties(
        mut self,
        queue_family_properties: QueueFamilyProperties,
    ) -> Self {
        self.inner.queue_family_properties = queue_family_properties;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsQueueFamilyProperties2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> QueueFamilyProperties2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryProperties2.html>"]
pub struct PhysicalDeviceMemoryProperties2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_properties: PhysicalDeviceMemoryProperties,
}
impl ::std::default::Default for PhysicalDeviceMemoryProperties2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            memory_properties: PhysicalDeviceMemoryProperties::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceMemoryProperties2 {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_MEMORY_PROPERTIES_2;
}
impl PhysicalDeviceMemoryProperties2 {
    pub fn builder<'a>() -> PhysicalDeviceMemoryProperties2Builder<'a> {
        PhysicalDeviceMemoryProperties2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceMemoryProperties2Builder<'a> {
    inner: PhysicalDeviceMemoryProperties2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsPhysicalDeviceMemoryProperties2 {}
impl<'a> ::std::ops::Deref for PhysicalDeviceMemoryProperties2Builder<'a> {
    type Target = PhysicalDeviceMemoryProperties2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceMemoryProperties2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceMemoryProperties2Builder<'a> {
    #[inline]
    pub fn memory_properties(mut self, memory_properties: PhysicalDeviceMemoryProperties) -> Self {
        self.inner.memory_properties = memory_properties;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPhysicalDeviceMemoryProperties2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceMemoryProperties2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageFormatProperties2.html>"]
pub struct SparseImageFormatProperties2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub properties: SparseImageFormatProperties,
}
impl ::std::default::Default for SparseImageFormatProperties2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            properties: SparseImageFormatProperties::default(),
        }
    }
}
unsafe impl TaggedStructure for SparseImageFormatProperties2 {
    const STRUCTURE_TYPE: StructureType = StructureType::SPARSE_IMAGE_FORMAT_PROPERTIES_2;
}
impl SparseImageFormatProperties2 {
    pub fn builder<'a>() -> SparseImageFormatProperties2Builder<'a> {
        SparseImageFormatProperties2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SparseImageFormatProperties2Builder<'a> {
    inner: SparseImageFormatProperties2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SparseImageFormatProperties2Builder<'a> {
    type Target = SparseImageFormatProperties2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SparseImageFormatProperties2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SparseImageFormatProperties2Builder<'a> {
    #[inline]
    pub fn properties(mut self, properties: SparseImageFormatProperties) -> Self {
        self.inner.properties = properties;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SparseImageFormatProperties2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSparseImageFormatInfo2.html>"]
pub struct PhysicalDeviceSparseImageFormatInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub format: Format,
    pub ty: ImageType,
    pub samples: SampleCountFlags,
    pub usage: ImageUsageFlags,
    pub tiling: ImageTiling,
}
impl ::std::default::Default for PhysicalDeviceSparseImageFormatInfo2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            format: Format::default(),
            ty: ImageType::default(),
            samples: SampleCountFlags::default(),
            usage: ImageUsageFlags::default(),
            tiling: ImageTiling::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceSparseImageFormatInfo2 {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2;
}
impl PhysicalDeviceSparseImageFormatInfo2 {
    pub fn builder<'a>() -> PhysicalDeviceSparseImageFormatInfo2Builder<'a> {
        PhysicalDeviceSparseImageFormatInfo2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceSparseImageFormatInfo2Builder<'a> {
    inner: PhysicalDeviceSparseImageFormatInfo2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PhysicalDeviceSparseImageFormatInfo2Builder<'a> {
    type Target = PhysicalDeviceSparseImageFormatInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceSparseImageFormatInfo2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceSparseImageFormatInfo2Builder<'a> {
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.inner.format = format;
        self
    }
    #[inline]
    pub fn ty(mut self, ty: ImageType) -> Self {
        self.inner.ty = ty;
        self
    }
    #[inline]
    pub fn samples(mut self, samples: SampleCountFlags) -> Self {
        self.inner.samples = samples;
        self
    }
    #[inline]
    pub fn usage(mut self, usage: ImageUsageFlags) -> Self {
        self.inner.usage = usage;
        self
    }
    #[inline]
    pub fn tiling(mut self, tiling: ImageTiling) -> Self {
        self.inner.tiling = tiling;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceSparseImageFormatInfo2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePushDescriptorPropertiesKHR.html>"]
pub struct PhysicalDevicePushDescriptorPropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_push_descriptors: u32,
}
impl ::std::default::Default for PhysicalDevicePushDescriptorPropertiesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_push_descriptors: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevicePushDescriptorPropertiesKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR;
}
impl PhysicalDevicePushDescriptorPropertiesKHR {
    pub fn builder<'a>() -> PhysicalDevicePushDescriptorPropertiesKHRBuilder<'a> {
        PhysicalDevicePushDescriptorPropertiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevicePushDescriptorPropertiesKHRBuilder<'a> {
    inner: PhysicalDevicePushDescriptorPropertiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDevicePushDescriptorPropertiesKHRBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDevicePushDescriptorPropertiesKHR {}
impl<'a> ::std::ops::Deref for PhysicalDevicePushDescriptorPropertiesKHRBuilder<'a> {
    type Target = PhysicalDevicePushDescriptorPropertiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevicePushDescriptorPropertiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevicePushDescriptorPropertiesKHRBuilder<'a> {
    #[inline]
    pub fn max_push_descriptors(mut self, max_push_descriptors: u32) -> Self {
        self.inner.max_push_descriptors = max_push_descriptors;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevicePushDescriptorPropertiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkConformanceVersion.html>"]
pub struct ConformanceVersion {
    pub major: u8,
    pub minor: u8,
    pub subminor: u8,
    pub patch: u8,
}
impl ConformanceVersion {
    pub fn builder<'a>() -> ConformanceVersionBuilder<'a> {
        ConformanceVersionBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ConformanceVersionBuilder<'a> {
    inner: ConformanceVersion,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ConformanceVersionBuilder<'a> {
    type Target = ConformanceVersion;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ConformanceVersionBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ConformanceVersionBuilder<'a> {
    #[inline]
    pub fn major(mut self, major: u8) -> Self {
        self.inner.major = major;
        self
    }
    #[inline]
    pub fn minor(mut self, minor: u8) -> Self {
        self.inner.minor = minor;
        self
    }
    #[inline]
    pub fn subminor(mut self, subminor: u8) -> Self {
        self.inner.subminor = subminor;
        self
    }
    #[inline]
    pub fn patch(mut self, patch: u8) -> Self {
        self.inner.patch = patch;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ConformanceVersion {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDriverProperties.html>"]
pub struct PhysicalDeviceDriverProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub driver_id: DriverId,
    pub driver_name: [c_char; MAX_DRIVER_NAME_SIZE],
    pub driver_info: [c_char; MAX_DRIVER_INFO_SIZE],
    pub conformance_version: ConformanceVersion,
}
#[cfg(feature = "debug")]
impl fmt::Debug for PhysicalDeviceDriverProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceDriverProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("driver_id", &self.driver_id)
            .field("driver_name", &unsafe {
                ::std::ffi::CStr::from_ptr(self.driver_name.as_ptr())
            })
            .field("driver_info", &unsafe {
                ::std::ffi::CStr::from_ptr(self.driver_info.as_ptr())
            })
            .field("conformance_version", &self.conformance_version)
            .finish()
    }
}
impl ::std::default::Default for PhysicalDeviceDriverProperties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            driver_id: DriverId::default(),
            driver_name: unsafe { ::std::mem::zeroed() },
            driver_info: unsafe { ::std::mem::zeroed() },
            conformance_version: ConformanceVersion::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceDriverProperties {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_DRIVER_PROPERTIES;
}
impl PhysicalDeviceDriverProperties {
    pub fn builder<'a>() -> PhysicalDeviceDriverPropertiesBuilder<'a> {
        PhysicalDeviceDriverPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceDriverPropertiesBuilder<'a> {
    inner: PhysicalDeviceDriverProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceDriverPropertiesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceDriverProperties {}
impl<'a> ::std::ops::Deref for PhysicalDeviceDriverPropertiesBuilder<'a> {
    type Target = PhysicalDeviceDriverProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceDriverPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceDriverPropertiesBuilder<'a> {
    #[inline]
    pub fn driver_id(mut self, driver_id: DriverId) -> Self {
        self.inner.driver_id = driver_id;
        self
    }
    #[inline]
    pub fn driver_name(mut self, driver_name: [c_char; MAX_DRIVER_NAME_SIZE]) -> Self {
        self.inner.driver_name = driver_name;
        self
    }
    #[inline]
    pub fn driver_info(mut self, driver_info: [c_char; MAX_DRIVER_INFO_SIZE]) -> Self {
        self.inner.driver_info = driver_info;
        self
    }
    #[inline]
    pub fn conformance_version(mut self, conformance_version: ConformanceVersion) -> Self {
        self.inner.conformance_version = conformance_version;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceDriverProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentRegionsKHR.html>"]
pub struct PresentRegionsKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain_count: u32,
    pub p_regions: *const PresentRegionKHR,
}
impl ::std::default::Default for PresentRegionsKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            swapchain_count: u32::default(),
            p_regions: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for PresentRegionsKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::PRESENT_REGIONS_KHR;
}
impl PresentRegionsKHR {
    pub fn builder<'a>() -> PresentRegionsKHRBuilder<'a> {
        PresentRegionsKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PresentRegionsKHRBuilder<'a> {
    inner: PresentRegionsKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPresentInfoKHR for PresentRegionsKHRBuilder<'_> {}
unsafe impl ExtendsPresentInfoKHR for PresentRegionsKHR {}
impl<'a> ::std::ops::Deref for PresentRegionsKHRBuilder<'a> {
    type Target = PresentRegionsKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PresentRegionsKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PresentRegionsKHRBuilder<'a> {
    #[inline]
    pub fn regions(mut self, regions: &'a [PresentRegionKHR]) -> Self {
        self.inner.swapchain_count = regions.len() as _;
        self.inner.p_regions = regions.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PresentRegionsKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentRegionKHR.html>"]
pub struct PresentRegionKHR {
    pub rectangle_count: u32,
    pub p_rectangles: *const RectLayerKHR,
}
impl ::std::default::Default for PresentRegionKHR {
    #[inline]
    fn default() -> Self {
        Self {
            rectangle_count: u32::default(),
            p_rectangles: ::std::ptr::null(),
        }
    }
}
impl PresentRegionKHR {
    pub fn builder<'a>() -> PresentRegionKHRBuilder<'a> {
        PresentRegionKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PresentRegionKHRBuilder<'a> {
    inner: PresentRegionKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PresentRegionKHRBuilder<'a> {
    type Target = PresentRegionKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PresentRegionKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PresentRegionKHRBuilder<'a> {
    #[inline]
    pub fn rectangles(mut self, rectangles: &'a [RectLayerKHR]) -> Self {
        self.inner.rectangle_count = rectangles.len() as _;
        self.inner.p_rectangles = rectangles.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PresentRegionKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRectLayerKHR.html>"]
pub struct RectLayerKHR {
    pub offset: Offset2D,
    pub extent: Extent2D,
    pub layer: u32,
}
impl RectLayerKHR {
    pub fn builder<'a>() -> RectLayerKHRBuilder<'a> {
        RectLayerKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RectLayerKHRBuilder<'a> {
    inner: RectLayerKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for RectLayerKHRBuilder<'a> {
    type Target = RectLayerKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RectLayerKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RectLayerKHRBuilder<'a> {
    #[inline]
    pub fn offset(mut self, offset: Offset2D) -> Self {
        self.inner.offset = offset;
        self
    }
    #[inline]
    pub fn extent(mut self, extent: Extent2D) -> Self {
        self.inner.extent = extent;
        self
    }
    #[inline]
    pub fn layer(mut self, layer: u32) -> Self {
        self.inner.layer = layer;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RectLayerKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVariablePointersFeatures.html>"]
pub struct PhysicalDeviceVariablePointersFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub variable_pointers_storage_buffer: Bool32,
    pub variable_pointers: Bool32,
}
impl ::std::default::Default for PhysicalDeviceVariablePointersFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            variable_pointers_storage_buffer: Bool32::default(),
            variable_pointers: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceVariablePointersFeatures {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
}
impl PhysicalDeviceVariablePointersFeatures {
    pub fn builder<'a>() -> PhysicalDeviceVariablePointersFeaturesBuilder<'a> {
        PhysicalDeviceVariablePointersFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceVariablePointersFeaturesBuilder<'a> {
    inner: PhysicalDeviceVariablePointersFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVariablePointersFeaturesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVariablePointersFeatures {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVariablePointersFeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVariablePointersFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDeviceVariablePointersFeaturesBuilder<'a> {
    type Target = PhysicalDeviceVariablePointersFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceVariablePointersFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceVariablePointersFeaturesBuilder<'a> {
    #[inline]
    pub fn variable_pointers_storage_buffer(
        mut self,
        variable_pointers_storage_buffer: bool,
    ) -> Self {
        self.inner.variable_pointers_storage_buffer = variable_pointers_storage_buffer.into();
        self
    }
    #[inline]
    pub fn variable_pointers(mut self, variable_pointers: bool) -> Self {
        self.inner.variable_pointers = variable_pointers.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceVariablePointersFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryProperties.html>"]
pub struct ExternalMemoryProperties {
    pub external_memory_features: ExternalMemoryFeatureFlags,
    pub export_from_imported_handle_types: ExternalMemoryHandleTypeFlags,
    pub compatible_handle_types: ExternalMemoryHandleTypeFlags,
}
impl ExternalMemoryProperties {
    pub fn builder<'a>() -> ExternalMemoryPropertiesBuilder<'a> {
        ExternalMemoryPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExternalMemoryPropertiesBuilder<'a> {
    inner: ExternalMemoryProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ExternalMemoryPropertiesBuilder<'a> {
    type Target = ExternalMemoryProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExternalMemoryPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExternalMemoryPropertiesBuilder<'a> {
    #[inline]
    pub fn external_memory_features(
        mut self,
        external_memory_features: ExternalMemoryFeatureFlags,
    ) -> Self {
        self.inner.external_memory_features = external_memory_features;
        self
    }
    #[inline]
    pub fn export_from_imported_handle_types(
        mut self,
        export_from_imported_handle_types: ExternalMemoryHandleTypeFlags,
    ) -> Self {
        self.inner.export_from_imported_handle_types = export_from_imported_handle_types;
        self
    }
    #[inline]
    pub fn compatible_handle_types(
        mut self,
        compatible_handle_types: ExternalMemoryHandleTypeFlags,
    ) -> Self {
        self.inner.compatible_handle_types = compatible_handle_types;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExternalMemoryProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalImageFormatInfo.html>"]
pub struct PhysicalDeviceExternalImageFormatInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalMemoryHandleTypeFlags,
}
impl ::std::default::Default for PhysicalDeviceExternalImageFormatInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceExternalImageFormatInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;
}
impl PhysicalDeviceExternalImageFormatInfo {
    pub fn builder<'a>() -> PhysicalDeviceExternalImageFormatInfoBuilder<'a> {
        PhysicalDeviceExternalImageFormatInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceExternalImageFormatInfoBuilder<'a> {
    inner: PhysicalDeviceExternalImageFormatInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceImageFormatInfo2
    for PhysicalDeviceExternalImageFormatInfoBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceImageFormatInfo2 for PhysicalDeviceExternalImageFormatInfo {}
impl<'a> ::std::ops::Deref for PhysicalDeviceExternalImageFormatInfoBuilder<'a> {
    type Target = PhysicalDeviceExternalImageFormatInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceExternalImageFormatInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceExternalImageFormatInfoBuilder<'a> {
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceExternalImageFormatInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalImageFormatProperties.html>"]
pub struct ExternalImageFormatProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub external_memory_properties: ExternalMemoryProperties,
}
impl ::std::default::Default for ExternalImageFormatProperties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            external_memory_properties: ExternalMemoryProperties::default(),
        }
    }
}
unsafe impl TaggedStructure for ExternalImageFormatProperties {
    const STRUCTURE_TYPE: StructureType = StructureType::EXTERNAL_IMAGE_FORMAT_PROPERTIES;
}
impl ExternalImageFormatProperties {
    pub fn builder<'a>() -> ExternalImageFormatPropertiesBuilder<'a> {
        ExternalImageFormatPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExternalImageFormatPropertiesBuilder<'a> {
    inner: ExternalImageFormatProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageFormatProperties2 for ExternalImageFormatPropertiesBuilder<'_> {}
unsafe impl ExtendsImageFormatProperties2 for ExternalImageFormatProperties {}
impl<'a> ::std::ops::Deref for ExternalImageFormatPropertiesBuilder<'a> {
    type Target = ExternalImageFormatProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExternalImageFormatPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExternalImageFormatPropertiesBuilder<'a> {
    #[inline]
    pub fn external_memory_properties(
        mut self,
        external_memory_properties: ExternalMemoryProperties,
    ) -> Self {
        self.inner.external_memory_properties = external_memory_properties;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExternalImageFormatProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalBufferInfo.html>"]
pub struct PhysicalDeviceExternalBufferInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: BufferCreateFlags,
    pub usage: BufferUsageFlags,
    pub handle_type: ExternalMemoryHandleTypeFlags,
}
impl ::std::default::Default for PhysicalDeviceExternalBufferInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: BufferCreateFlags::default(),
            usage: BufferUsageFlags::default(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceExternalBufferInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO;
}
impl PhysicalDeviceExternalBufferInfo {
    pub fn builder<'a>() -> PhysicalDeviceExternalBufferInfoBuilder<'a> {
        PhysicalDeviceExternalBufferInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceExternalBufferInfoBuilder<'a> {
    inner: PhysicalDeviceExternalBufferInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PhysicalDeviceExternalBufferInfoBuilder<'a> {
    type Target = PhysicalDeviceExternalBufferInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceExternalBufferInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceExternalBufferInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: BufferCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn usage(mut self, usage: BufferUsageFlags) -> Self {
        self.inner.usage = usage;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceExternalBufferInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalBufferProperties.html>"]
pub struct ExternalBufferProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub external_memory_properties: ExternalMemoryProperties,
}
impl ::std::default::Default for ExternalBufferProperties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            external_memory_properties: ExternalMemoryProperties::default(),
        }
    }
}
unsafe impl TaggedStructure for ExternalBufferProperties {
    const STRUCTURE_TYPE: StructureType = StructureType::EXTERNAL_BUFFER_PROPERTIES;
}
impl ExternalBufferProperties {
    pub fn builder<'a>() -> ExternalBufferPropertiesBuilder<'a> {
        ExternalBufferPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExternalBufferPropertiesBuilder<'a> {
    inner: ExternalBufferProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ExternalBufferPropertiesBuilder<'a> {
    type Target = ExternalBufferProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExternalBufferPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExternalBufferPropertiesBuilder<'a> {
    #[inline]
    pub fn external_memory_properties(
        mut self,
        external_memory_properties: ExternalMemoryProperties,
    ) -> Self {
        self.inner.external_memory_properties = external_memory_properties;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExternalBufferProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceIDProperties.html>"]
pub struct PhysicalDeviceIDProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_uuid: [u8; UUID_SIZE],
    pub driver_uuid: [u8; UUID_SIZE],
    pub device_luid: [u8; LUID_SIZE],
    pub device_node_mask: u32,
    pub device_luid_valid: Bool32,
}
impl ::std::default::Default for PhysicalDeviceIDProperties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            device_uuid: unsafe { ::std::mem::zeroed() },
            driver_uuid: unsafe { ::std::mem::zeroed() },
            device_luid: unsafe { ::std::mem::zeroed() },
            device_node_mask: u32::default(),
            device_luid_valid: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceIDProperties {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_ID_PROPERTIES;
}
impl PhysicalDeviceIDProperties {
    pub fn builder<'a>() -> PhysicalDeviceIDPropertiesBuilder<'a> {
        PhysicalDeviceIDPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceIDPropertiesBuilder<'a> {
    inner: PhysicalDeviceIDProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceIDPropertiesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceIDProperties {}
impl<'a> ::std::ops::Deref for PhysicalDeviceIDPropertiesBuilder<'a> {
    type Target = PhysicalDeviceIDProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceIDPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceIDPropertiesBuilder<'a> {
    #[inline]
    pub fn device_uuid(mut self, device_uuid: [u8; UUID_SIZE]) -> Self {
        self.inner.device_uuid = device_uuid;
        self
    }
    #[inline]
    pub fn driver_uuid(mut self, driver_uuid: [u8; UUID_SIZE]) -> Self {
        self.inner.driver_uuid = driver_uuid;
        self
    }
    #[inline]
    pub fn device_luid(mut self, device_luid: [u8; LUID_SIZE]) -> Self {
        self.inner.device_luid = device_luid;
        self
    }
    #[inline]
    pub fn device_node_mask(mut self, device_node_mask: u32) -> Self {
        self.inner.device_node_mask = device_node_mask;
        self
    }
    #[inline]
    pub fn device_luid_valid(mut self, device_luid_valid: bool) -> Self {
        self.inner.device_luid_valid = device_luid_valid.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceIDProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryImageCreateInfo.html>"]
pub struct ExternalMemoryImageCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalMemoryHandleTypeFlags,
}
impl ::std::default::Default for ExternalMemoryImageCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_types: ExternalMemoryHandleTypeFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for ExternalMemoryImageCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
}
impl ExternalMemoryImageCreateInfo {
    pub fn builder<'a>() -> ExternalMemoryImageCreateInfoBuilder<'a> {
        ExternalMemoryImageCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExternalMemoryImageCreateInfoBuilder<'a> {
    inner: ExternalMemoryImageCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageCreateInfo for ExternalMemoryImageCreateInfoBuilder<'_> {}
unsafe impl ExtendsImageCreateInfo for ExternalMemoryImageCreateInfo {}
impl<'a> ::std::ops::Deref for ExternalMemoryImageCreateInfoBuilder<'a> {
    type Target = ExternalMemoryImageCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExternalMemoryImageCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExternalMemoryImageCreateInfoBuilder<'a> {
    #[inline]
    pub fn handle_types(mut self, handle_types: ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_types = handle_types;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExternalMemoryImageCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryBufferCreateInfo.html>"]
pub struct ExternalMemoryBufferCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalMemoryHandleTypeFlags,
}
impl ::std::default::Default for ExternalMemoryBufferCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_types: ExternalMemoryHandleTypeFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for ExternalMemoryBufferCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
}
impl ExternalMemoryBufferCreateInfo {
    pub fn builder<'a>() -> ExternalMemoryBufferCreateInfoBuilder<'a> {
        ExternalMemoryBufferCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExternalMemoryBufferCreateInfoBuilder<'a> {
    inner: ExternalMemoryBufferCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsBufferCreateInfo for ExternalMemoryBufferCreateInfoBuilder<'_> {}
unsafe impl ExtendsBufferCreateInfo for ExternalMemoryBufferCreateInfo {}
impl<'a> ::std::ops::Deref for ExternalMemoryBufferCreateInfoBuilder<'a> {
    type Target = ExternalMemoryBufferCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExternalMemoryBufferCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExternalMemoryBufferCreateInfoBuilder<'a> {
    #[inline]
    pub fn handle_types(mut self, handle_types: ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_types = handle_types;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExternalMemoryBufferCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMemoryAllocateInfo.html>"]
pub struct ExportMemoryAllocateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalMemoryHandleTypeFlags,
}
impl ::std::default::Default for ExportMemoryAllocateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_types: ExternalMemoryHandleTypeFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for ExportMemoryAllocateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_MEMORY_ALLOCATE_INFO;
}
impl ExportMemoryAllocateInfo {
    pub fn builder<'a>() -> ExportMemoryAllocateInfoBuilder<'a> {
        ExportMemoryAllocateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExportMemoryAllocateInfoBuilder<'a> {
    inner: ExportMemoryAllocateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsMemoryAllocateInfo for ExportMemoryAllocateInfoBuilder<'_> {}
unsafe impl ExtendsMemoryAllocateInfo for ExportMemoryAllocateInfo {}
impl<'a> ::std::ops::Deref for ExportMemoryAllocateInfoBuilder<'a> {
    type Target = ExportMemoryAllocateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExportMemoryAllocateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExportMemoryAllocateInfoBuilder<'a> {
    #[inline]
    pub fn handle_types(mut self, handle_types: ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_types = handle_types;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExportMemoryAllocateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMemoryWin32HandleInfoKHR.html>"]
pub struct ImportMemoryWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub handle: HANDLE,
    pub name: LPCWSTR,
}
impl ::std::default::Default for ImportMemoryWin32HandleInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
            handle: unsafe { ::std::mem::zeroed() },
            name: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for ImportMemoryWin32HandleInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
}
impl ImportMemoryWin32HandleInfoKHR {
    pub fn builder<'a>() -> ImportMemoryWin32HandleInfoKHRBuilder<'a> {
        ImportMemoryWin32HandleInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImportMemoryWin32HandleInfoKHRBuilder<'a> {
    inner: ImportMemoryWin32HandleInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsMemoryAllocateInfo for ImportMemoryWin32HandleInfoKHRBuilder<'_> {}
unsafe impl ExtendsMemoryAllocateInfo for ImportMemoryWin32HandleInfoKHR {}
impl<'a> ::std::ops::Deref for ImportMemoryWin32HandleInfoKHRBuilder<'a> {
    type Target = ImportMemoryWin32HandleInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImportMemoryWin32HandleInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImportMemoryWin32HandleInfoKHRBuilder<'a> {
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    #[inline]
    pub fn handle(mut self, handle: HANDLE) -> Self {
        self.inner.handle = handle;
        self
    }
    #[inline]
    pub fn name(mut self, name: LPCWSTR) -> Self {
        self.inner.name = name;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImportMemoryWin32HandleInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMemoryWin32HandleInfoKHR.html>"]
pub struct ExportMemoryWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_attributes: *const SECURITY_ATTRIBUTES,
    pub dw_access: DWORD,
    pub name: LPCWSTR,
}
impl ::std::default::Default for ExportMemoryWin32HandleInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_attributes: ::std::ptr::null(),
            dw_access: DWORD::default(),
            name: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for ExportMemoryWin32HandleInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
}
impl ExportMemoryWin32HandleInfoKHR {
    pub fn builder<'a>() -> ExportMemoryWin32HandleInfoKHRBuilder<'a> {
        ExportMemoryWin32HandleInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExportMemoryWin32HandleInfoKHRBuilder<'a> {
    inner: ExportMemoryWin32HandleInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsMemoryAllocateInfo for ExportMemoryWin32HandleInfoKHRBuilder<'_> {}
unsafe impl ExtendsMemoryAllocateInfo for ExportMemoryWin32HandleInfoKHR {}
impl<'a> ::std::ops::Deref for ExportMemoryWin32HandleInfoKHRBuilder<'a> {
    type Target = ExportMemoryWin32HandleInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExportMemoryWin32HandleInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExportMemoryWin32HandleInfoKHRBuilder<'a> {
    #[inline]
    pub fn attributes(mut self, attributes: &'a SECURITY_ATTRIBUTES) -> Self {
        self.inner.p_attributes = attributes;
        self
    }
    #[inline]
    pub fn dw_access(mut self, dw_access: DWORD) -> Self {
        self.inner.dw_access = dw_access;
        self
    }
    #[inline]
    pub fn name(mut self, name: LPCWSTR) -> Self {
        self.inner.name = name;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExportMemoryWin32HandleInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMemoryZirconHandleInfoFUCHSIA.html>"]
pub struct ImportMemoryZirconHandleInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub handle: zx_handle_t,
}
impl ::std::default::Default for ImportMemoryZirconHandleInfoFUCHSIA {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
            handle: zx_handle_t::default(),
        }
    }
}
unsafe impl TaggedStructure for ImportMemoryZirconHandleInfoFUCHSIA {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA;
}
impl ImportMemoryZirconHandleInfoFUCHSIA {
    pub fn builder<'a>() -> ImportMemoryZirconHandleInfoFUCHSIABuilder<'a> {
        ImportMemoryZirconHandleInfoFUCHSIABuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImportMemoryZirconHandleInfoFUCHSIABuilder<'a> {
    inner: ImportMemoryZirconHandleInfoFUCHSIA,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsMemoryAllocateInfo for ImportMemoryZirconHandleInfoFUCHSIABuilder<'_> {}
unsafe impl ExtendsMemoryAllocateInfo for ImportMemoryZirconHandleInfoFUCHSIA {}
impl<'a> ::std::ops::Deref for ImportMemoryZirconHandleInfoFUCHSIABuilder<'a> {
    type Target = ImportMemoryZirconHandleInfoFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImportMemoryZirconHandleInfoFUCHSIABuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImportMemoryZirconHandleInfoFUCHSIABuilder<'a> {
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    #[inline]
    pub fn handle(mut self, handle: zx_handle_t) -> Self {
        self.inner.handle = handle;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImportMemoryZirconHandleInfoFUCHSIA {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryZirconHandlePropertiesFUCHSIA.html>"]
pub struct MemoryZirconHandlePropertiesFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_type_bits: u32,
}
impl ::std::default::Default for MemoryZirconHandlePropertiesFUCHSIA {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            memory_type_bits: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for MemoryZirconHandlePropertiesFUCHSIA {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA;
}
impl MemoryZirconHandlePropertiesFUCHSIA {
    pub fn builder<'a>() -> MemoryZirconHandlePropertiesFUCHSIABuilder<'a> {
        MemoryZirconHandlePropertiesFUCHSIABuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MemoryZirconHandlePropertiesFUCHSIABuilder<'a> {
    inner: MemoryZirconHandlePropertiesFUCHSIA,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MemoryZirconHandlePropertiesFUCHSIABuilder<'a> {
    type Target = MemoryZirconHandlePropertiesFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MemoryZirconHandlePropertiesFUCHSIABuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MemoryZirconHandlePropertiesFUCHSIABuilder<'a> {
    #[inline]
    pub fn memory_type_bits(mut self, memory_type_bits: u32) -> Self {
        self.inner.memory_type_bits = memory_type_bits;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MemoryZirconHandlePropertiesFUCHSIA {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryGetZirconHandleInfoFUCHSIA.html>"]
pub struct MemoryGetZirconHandleInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: DeviceMemory,
    pub handle_type: ExternalMemoryHandleTypeFlags,
}
impl ::std::default::Default for MemoryGetZirconHandleInfoFUCHSIA {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            memory: DeviceMemory::default(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for MemoryGetZirconHandleInfoFUCHSIA {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA;
}
impl MemoryGetZirconHandleInfoFUCHSIA {
    pub fn builder<'a>() -> MemoryGetZirconHandleInfoFUCHSIABuilder<'a> {
        MemoryGetZirconHandleInfoFUCHSIABuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MemoryGetZirconHandleInfoFUCHSIABuilder<'a> {
    inner: MemoryGetZirconHandleInfoFUCHSIA,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MemoryGetZirconHandleInfoFUCHSIABuilder<'a> {
    type Target = MemoryGetZirconHandleInfoFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MemoryGetZirconHandleInfoFUCHSIABuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MemoryGetZirconHandleInfoFUCHSIABuilder<'a> {
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MemoryGetZirconHandleInfoFUCHSIA {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryWin32HandlePropertiesKHR.html>"]
pub struct MemoryWin32HandlePropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_type_bits: u32,
}
impl ::std::default::Default for MemoryWin32HandlePropertiesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            memory_type_bits: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for MemoryWin32HandlePropertiesKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_WIN32_HANDLE_PROPERTIES_KHR;
}
impl MemoryWin32HandlePropertiesKHR {
    pub fn builder<'a>() -> MemoryWin32HandlePropertiesKHRBuilder<'a> {
        MemoryWin32HandlePropertiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MemoryWin32HandlePropertiesKHRBuilder<'a> {
    inner: MemoryWin32HandlePropertiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MemoryWin32HandlePropertiesKHRBuilder<'a> {
    type Target = MemoryWin32HandlePropertiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MemoryWin32HandlePropertiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MemoryWin32HandlePropertiesKHRBuilder<'a> {
    #[inline]
    pub fn memory_type_bits(mut self, memory_type_bits: u32) -> Self {
        self.inner.memory_type_bits = memory_type_bits;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MemoryWin32HandlePropertiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryGetWin32HandleInfoKHR.html>"]
pub struct MemoryGetWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: DeviceMemory,
    pub handle_type: ExternalMemoryHandleTypeFlags,
}
impl ::std::default::Default for MemoryGetWin32HandleInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            memory: DeviceMemory::default(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for MemoryGetWin32HandleInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_GET_WIN32_HANDLE_INFO_KHR;
}
impl MemoryGetWin32HandleInfoKHR {
    pub fn builder<'a>() -> MemoryGetWin32HandleInfoKHRBuilder<'a> {
        MemoryGetWin32HandleInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MemoryGetWin32HandleInfoKHRBuilder<'a> {
    inner: MemoryGetWin32HandleInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MemoryGetWin32HandleInfoKHRBuilder<'a> {
    type Target = MemoryGetWin32HandleInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MemoryGetWin32HandleInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MemoryGetWin32HandleInfoKHRBuilder<'a> {
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MemoryGetWin32HandleInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMemoryFdInfoKHR.html>"]
pub struct ImportMemoryFdInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub fd: c_int,
}
impl ::std::default::Default for ImportMemoryFdInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
            fd: c_int::default(),
        }
    }
}
unsafe impl TaggedStructure for ImportMemoryFdInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_MEMORY_FD_INFO_KHR;
}
impl ImportMemoryFdInfoKHR {
    pub fn builder<'a>() -> ImportMemoryFdInfoKHRBuilder<'a> {
        ImportMemoryFdInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImportMemoryFdInfoKHRBuilder<'a> {
    inner: ImportMemoryFdInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsMemoryAllocateInfo for ImportMemoryFdInfoKHRBuilder<'_> {}
unsafe impl ExtendsMemoryAllocateInfo for ImportMemoryFdInfoKHR {}
impl<'a> ::std::ops::Deref for ImportMemoryFdInfoKHRBuilder<'a> {
    type Target = ImportMemoryFdInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImportMemoryFdInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImportMemoryFdInfoKHRBuilder<'a> {
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    #[inline]
    pub fn fd(mut self, fd: c_int) -> Self {
        self.inner.fd = fd;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImportMemoryFdInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryFdPropertiesKHR.html>"]
pub struct MemoryFdPropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_type_bits: u32,
}
impl ::std::default::Default for MemoryFdPropertiesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            memory_type_bits: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for MemoryFdPropertiesKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_FD_PROPERTIES_KHR;
}
impl MemoryFdPropertiesKHR {
    pub fn builder<'a>() -> MemoryFdPropertiesKHRBuilder<'a> {
        MemoryFdPropertiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MemoryFdPropertiesKHRBuilder<'a> {
    inner: MemoryFdPropertiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MemoryFdPropertiesKHRBuilder<'a> {
    type Target = MemoryFdPropertiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MemoryFdPropertiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MemoryFdPropertiesKHRBuilder<'a> {
    #[inline]
    pub fn memory_type_bits(mut self, memory_type_bits: u32) -> Self {
        self.inner.memory_type_bits = memory_type_bits;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MemoryFdPropertiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryGetFdInfoKHR.html>"]
pub struct MemoryGetFdInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: DeviceMemory,
    pub handle_type: ExternalMemoryHandleTypeFlags,
}
impl ::std::default::Default for MemoryGetFdInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            memory: DeviceMemory::default(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for MemoryGetFdInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_GET_FD_INFO_KHR;
}
impl MemoryGetFdInfoKHR {
    pub fn builder<'a>() -> MemoryGetFdInfoKHRBuilder<'a> {
        MemoryGetFdInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MemoryGetFdInfoKHRBuilder<'a> {
    inner: MemoryGetFdInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MemoryGetFdInfoKHRBuilder<'a> {
    type Target = MemoryGetFdInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MemoryGetFdInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MemoryGetFdInfoKHRBuilder<'a> {
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MemoryGetFdInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWin32KeyedMutexAcquireReleaseInfoKHR.html>"]
pub struct Win32KeyedMutexAcquireReleaseInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acquire_count: u32,
    pub p_acquire_syncs: *const DeviceMemory,
    pub p_acquire_keys: *const u64,
    pub p_acquire_timeouts: *const u32,
    pub release_count: u32,
    pub p_release_syncs: *const DeviceMemory,
    pub p_release_keys: *const u64,
}
impl ::std::default::Default for Win32KeyedMutexAcquireReleaseInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            acquire_count: u32::default(),
            p_acquire_syncs: ::std::ptr::null(),
            p_acquire_keys: ::std::ptr::null(),
            p_acquire_timeouts: ::std::ptr::null(),
            release_count: u32::default(),
            p_release_syncs: ::std::ptr::null(),
            p_release_keys: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for Win32KeyedMutexAcquireReleaseInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR;
}
impl Win32KeyedMutexAcquireReleaseInfoKHR {
    pub fn builder<'a>() -> Win32KeyedMutexAcquireReleaseInfoKHRBuilder<'a> {
        Win32KeyedMutexAcquireReleaseInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct Win32KeyedMutexAcquireReleaseInfoKHRBuilder<'a> {
    inner: Win32KeyedMutexAcquireReleaseInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSubmitInfo for Win32KeyedMutexAcquireReleaseInfoKHRBuilder<'_> {}
unsafe impl ExtendsSubmitInfo for Win32KeyedMutexAcquireReleaseInfoKHR {}
unsafe impl ExtendsSubmitInfo2 for Win32KeyedMutexAcquireReleaseInfoKHRBuilder<'_> {}
unsafe impl ExtendsSubmitInfo2 for Win32KeyedMutexAcquireReleaseInfoKHR {}
impl<'a> ::std::ops::Deref for Win32KeyedMutexAcquireReleaseInfoKHRBuilder<'a> {
    type Target = Win32KeyedMutexAcquireReleaseInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for Win32KeyedMutexAcquireReleaseInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> Win32KeyedMutexAcquireReleaseInfoKHRBuilder<'a> {
    #[inline]
    pub fn acquire_syncs(mut self, acquire_syncs: &'a [DeviceMemory]) -> Self {
        self.inner.acquire_count = acquire_syncs.len() as _;
        self.inner.p_acquire_syncs = acquire_syncs.as_ptr();
        self
    }
    #[inline]
    pub fn acquire_keys(mut self, acquire_keys: &'a [u64]) -> Self {
        self.inner.acquire_count = acquire_keys.len() as _;
        self.inner.p_acquire_keys = acquire_keys.as_ptr();
        self
    }
    #[inline]
    pub fn acquire_timeouts(mut self, acquire_timeouts: &'a [u32]) -> Self {
        self.inner.acquire_count = acquire_timeouts.len() as _;
        self.inner.p_acquire_timeouts = acquire_timeouts.as_ptr();
        self
    }
    #[inline]
    pub fn release_syncs(mut self, release_syncs: &'a [DeviceMemory]) -> Self {
        self.inner.release_count = release_syncs.len() as _;
        self.inner.p_release_syncs = release_syncs.as_ptr();
        self
    }
    #[inline]
    pub fn release_keys(mut self, release_keys: &'a [u64]) -> Self {
        self.inner.release_count = release_keys.len() as _;
        self.inner.p_release_keys = release_keys.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> Win32KeyedMutexAcquireReleaseInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalSemaphoreInfo.html>"]
pub struct PhysicalDeviceExternalSemaphoreInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
}
impl ::std::default::Default for PhysicalDeviceExternalSemaphoreInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_type: ExternalSemaphoreHandleTypeFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceExternalSemaphoreInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO;
}
impl PhysicalDeviceExternalSemaphoreInfo {
    pub fn builder<'a>() -> PhysicalDeviceExternalSemaphoreInfoBuilder<'a> {
        PhysicalDeviceExternalSemaphoreInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceExternalSemaphoreInfoBuilder<'a> {
    inner: PhysicalDeviceExternalSemaphoreInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsPhysicalDeviceExternalSemaphoreInfo {}
impl<'a> ::std::ops::Deref for PhysicalDeviceExternalSemaphoreInfoBuilder<'a> {
    type Target = PhysicalDeviceExternalSemaphoreInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceExternalSemaphoreInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceExternalSemaphoreInfoBuilder<'a> {
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPhysicalDeviceExternalSemaphoreInfo>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceExternalSemaphoreInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalSemaphoreProperties.html>"]
pub struct ExternalSemaphoreProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub export_from_imported_handle_types: ExternalSemaphoreHandleTypeFlags,
    pub compatible_handle_types: ExternalSemaphoreHandleTypeFlags,
    pub external_semaphore_features: ExternalSemaphoreFeatureFlags,
}
impl ::std::default::Default for ExternalSemaphoreProperties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            export_from_imported_handle_types: ExternalSemaphoreHandleTypeFlags::default(),
            compatible_handle_types: ExternalSemaphoreHandleTypeFlags::default(),
            external_semaphore_features: ExternalSemaphoreFeatureFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for ExternalSemaphoreProperties {
    const STRUCTURE_TYPE: StructureType = StructureType::EXTERNAL_SEMAPHORE_PROPERTIES;
}
impl ExternalSemaphoreProperties {
    pub fn builder<'a>() -> ExternalSemaphorePropertiesBuilder<'a> {
        ExternalSemaphorePropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExternalSemaphorePropertiesBuilder<'a> {
    inner: ExternalSemaphoreProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ExternalSemaphorePropertiesBuilder<'a> {
    type Target = ExternalSemaphoreProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExternalSemaphorePropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExternalSemaphorePropertiesBuilder<'a> {
    #[inline]
    pub fn export_from_imported_handle_types(
        mut self,
        export_from_imported_handle_types: ExternalSemaphoreHandleTypeFlags,
    ) -> Self {
        self.inner.export_from_imported_handle_types = export_from_imported_handle_types;
        self
    }
    #[inline]
    pub fn compatible_handle_types(
        mut self,
        compatible_handle_types: ExternalSemaphoreHandleTypeFlags,
    ) -> Self {
        self.inner.compatible_handle_types = compatible_handle_types;
        self
    }
    #[inline]
    pub fn external_semaphore_features(
        mut self,
        external_semaphore_features: ExternalSemaphoreFeatureFlags,
    ) -> Self {
        self.inner.external_semaphore_features = external_semaphore_features;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExternalSemaphoreProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportSemaphoreCreateInfo.html>"]
pub struct ExportSemaphoreCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalSemaphoreHandleTypeFlags,
}
impl ::std::default::Default for ExportSemaphoreCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_types: ExternalSemaphoreHandleTypeFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for ExportSemaphoreCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_SEMAPHORE_CREATE_INFO;
}
impl ExportSemaphoreCreateInfo {
    pub fn builder<'a>() -> ExportSemaphoreCreateInfoBuilder<'a> {
        ExportSemaphoreCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExportSemaphoreCreateInfoBuilder<'a> {
    inner: ExportSemaphoreCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSemaphoreCreateInfo for ExportSemaphoreCreateInfoBuilder<'_> {}
unsafe impl ExtendsSemaphoreCreateInfo for ExportSemaphoreCreateInfo {}
impl<'a> ::std::ops::Deref for ExportSemaphoreCreateInfoBuilder<'a> {
    type Target = ExportSemaphoreCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExportSemaphoreCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExportSemaphoreCreateInfoBuilder<'a> {
    #[inline]
    pub fn handle_types(mut self, handle_types: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.inner.handle_types = handle_types;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExportSemaphoreCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportSemaphoreWin32HandleInfoKHR.html>"]
pub struct ImportSemaphoreWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Semaphore,
    pub flags: SemaphoreImportFlags,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
    pub handle: HANDLE,
    pub name: LPCWSTR,
}
impl ::std::default::Default for ImportSemaphoreWin32HandleInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            semaphore: Semaphore::default(),
            flags: SemaphoreImportFlags::default(),
            handle_type: ExternalSemaphoreHandleTypeFlags::default(),
            handle: unsafe { ::std::mem::zeroed() },
            name: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for ImportSemaphoreWin32HandleInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
}
impl ImportSemaphoreWin32HandleInfoKHR {
    pub fn builder<'a>() -> ImportSemaphoreWin32HandleInfoKHRBuilder<'a> {
        ImportSemaphoreWin32HandleInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImportSemaphoreWin32HandleInfoKHRBuilder<'a> {
    inner: ImportSemaphoreWin32HandleInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ImportSemaphoreWin32HandleInfoKHRBuilder<'a> {
    type Target = ImportSemaphoreWin32HandleInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImportSemaphoreWin32HandleInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImportSemaphoreWin32HandleInfoKHRBuilder<'a> {
    #[inline]
    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
        self.inner.semaphore = semaphore;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: SemaphoreImportFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    #[inline]
    pub fn handle(mut self, handle: HANDLE) -> Self {
        self.inner.handle = handle;
        self
    }
    #[inline]
    pub fn name(mut self, name: LPCWSTR) -> Self {
        self.inner.name = name;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImportSemaphoreWin32HandleInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportSemaphoreWin32HandleInfoKHR.html>"]
pub struct ExportSemaphoreWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_attributes: *const SECURITY_ATTRIBUTES,
    pub dw_access: DWORD,
    pub name: LPCWSTR,
}
impl ::std::default::Default for ExportSemaphoreWin32HandleInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_attributes: ::std::ptr::null(),
            dw_access: DWORD::default(),
            name: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for ExportSemaphoreWin32HandleInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
}
impl ExportSemaphoreWin32HandleInfoKHR {
    pub fn builder<'a>() -> ExportSemaphoreWin32HandleInfoKHRBuilder<'a> {
        ExportSemaphoreWin32HandleInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExportSemaphoreWin32HandleInfoKHRBuilder<'a> {
    inner: ExportSemaphoreWin32HandleInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSemaphoreCreateInfo for ExportSemaphoreWin32HandleInfoKHRBuilder<'_> {}
unsafe impl ExtendsSemaphoreCreateInfo for ExportSemaphoreWin32HandleInfoKHR {}
impl<'a> ::std::ops::Deref for ExportSemaphoreWin32HandleInfoKHRBuilder<'a> {
    type Target = ExportSemaphoreWin32HandleInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExportSemaphoreWin32HandleInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExportSemaphoreWin32HandleInfoKHRBuilder<'a> {
    #[inline]
    pub fn attributes(mut self, attributes: &'a SECURITY_ATTRIBUTES) -> Self {
        self.inner.p_attributes = attributes;
        self
    }
    #[inline]
    pub fn dw_access(mut self, dw_access: DWORD) -> Self {
        self.inner.dw_access = dw_access;
        self
    }
    #[inline]
    pub fn name(mut self, name: LPCWSTR) -> Self {
        self.inner.name = name;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExportSemaphoreWin32HandleInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkD3D12FenceSubmitInfoKHR.html>"]
pub struct D3D12FenceSubmitInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub wait_semaphore_values_count: u32,
    pub p_wait_semaphore_values: *const u64,
    pub signal_semaphore_values_count: u32,
    pub p_signal_semaphore_values: *const u64,
}
impl ::std::default::Default for D3D12FenceSubmitInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            wait_semaphore_values_count: u32::default(),
            p_wait_semaphore_values: ::std::ptr::null(),
            signal_semaphore_values_count: u32::default(),
            p_signal_semaphore_values: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for D3D12FenceSubmitInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::D3D12_FENCE_SUBMIT_INFO_KHR;
}
impl D3D12FenceSubmitInfoKHR {
    pub fn builder<'a>() -> D3D12FenceSubmitInfoKHRBuilder<'a> {
        D3D12FenceSubmitInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct D3D12FenceSubmitInfoKHRBuilder<'a> {
    inner: D3D12FenceSubmitInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSubmitInfo for D3D12FenceSubmitInfoKHRBuilder<'_> {}
unsafe impl ExtendsSubmitInfo for D3D12FenceSubmitInfoKHR {}
impl<'a> ::std::ops::Deref for D3D12FenceSubmitInfoKHRBuilder<'a> {
    type Target = D3D12FenceSubmitInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for D3D12FenceSubmitInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> D3D12FenceSubmitInfoKHRBuilder<'a> {
    #[inline]
    pub fn wait_semaphore_values(mut self, wait_semaphore_values: &'a [u64]) -> Self {
        self.inner.wait_semaphore_values_count = wait_semaphore_values.len() as _;
        self.inner.p_wait_semaphore_values = wait_semaphore_values.as_ptr();
        self
    }
    #[inline]
    pub fn signal_semaphore_values(mut self, signal_semaphore_values: &'a [u64]) -> Self {
        self.inner.signal_semaphore_values_count = signal_semaphore_values.len() as _;
        self.inner.p_signal_semaphore_values = signal_semaphore_values.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> D3D12FenceSubmitInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreGetWin32HandleInfoKHR.html>"]
pub struct SemaphoreGetWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Semaphore,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
}
impl ::std::default::Default for SemaphoreGetWin32HandleInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            semaphore: Semaphore::default(),
            handle_type: ExternalSemaphoreHandleTypeFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for SemaphoreGetWin32HandleInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR;
}
impl SemaphoreGetWin32HandleInfoKHR {
    pub fn builder<'a>() -> SemaphoreGetWin32HandleInfoKHRBuilder<'a> {
        SemaphoreGetWin32HandleInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SemaphoreGetWin32HandleInfoKHRBuilder<'a> {
    inner: SemaphoreGetWin32HandleInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SemaphoreGetWin32HandleInfoKHRBuilder<'a> {
    type Target = SemaphoreGetWin32HandleInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SemaphoreGetWin32HandleInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SemaphoreGetWin32HandleInfoKHRBuilder<'a> {
    #[inline]
    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
        self.inner.semaphore = semaphore;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SemaphoreGetWin32HandleInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportSemaphoreFdInfoKHR.html>"]
pub struct ImportSemaphoreFdInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Semaphore,
    pub flags: SemaphoreImportFlags,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
    pub fd: c_int,
}
impl ::std::default::Default for ImportSemaphoreFdInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            semaphore: Semaphore::default(),
            flags: SemaphoreImportFlags::default(),
            handle_type: ExternalSemaphoreHandleTypeFlags::default(),
            fd: c_int::default(),
        }
    }
}
unsafe impl TaggedStructure for ImportSemaphoreFdInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_SEMAPHORE_FD_INFO_KHR;
}
impl ImportSemaphoreFdInfoKHR {
    pub fn builder<'a>() -> ImportSemaphoreFdInfoKHRBuilder<'a> {
        ImportSemaphoreFdInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImportSemaphoreFdInfoKHRBuilder<'a> {
    inner: ImportSemaphoreFdInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ImportSemaphoreFdInfoKHRBuilder<'a> {
    type Target = ImportSemaphoreFdInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImportSemaphoreFdInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImportSemaphoreFdInfoKHRBuilder<'a> {
    #[inline]
    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
        self.inner.semaphore = semaphore;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: SemaphoreImportFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    #[inline]
    pub fn fd(mut self, fd: c_int) -> Self {
        self.inner.fd = fd;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImportSemaphoreFdInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreGetFdInfoKHR.html>"]
pub struct SemaphoreGetFdInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Semaphore,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
}
impl ::std::default::Default for SemaphoreGetFdInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            semaphore: Semaphore::default(),
            handle_type: ExternalSemaphoreHandleTypeFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for SemaphoreGetFdInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::SEMAPHORE_GET_FD_INFO_KHR;
}
impl SemaphoreGetFdInfoKHR {
    pub fn builder<'a>() -> SemaphoreGetFdInfoKHRBuilder<'a> {
        SemaphoreGetFdInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SemaphoreGetFdInfoKHRBuilder<'a> {
    inner: SemaphoreGetFdInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SemaphoreGetFdInfoKHRBuilder<'a> {
    type Target = SemaphoreGetFdInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SemaphoreGetFdInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SemaphoreGetFdInfoKHRBuilder<'a> {
    #[inline]
    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
        self.inner.semaphore = semaphore;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SemaphoreGetFdInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportSemaphoreZirconHandleInfoFUCHSIA.html>"]
pub struct ImportSemaphoreZirconHandleInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Semaphore,
    pub flags: SemaphoreImportFlags,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
    pub zircon_handle: zx_handle_t,
}
impl ::std::default::Default for ImportSemaphoreZirconHandleInfoFUCHSIA {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            semaphore: Semaphore::default(),
            flags: SemaphoreImportFlags::default(),
            handle_type: ExternalSemaphoreHandleTypeFlags::default(),
            zircon_handle: zx_handle_t::default(),
        }
    }
}
unsafe impl TaggedStructure for ImportSemaphoreZirconHandleInfoFUCHSIA {
    const STRUCTURE_TYPE: StructureType =
        StructureType::IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA;
}
impl ImportSemaphoreZirconHandleInfoFUCHSIA {
    pub fn builder<'a>() -> ImportSemaphoreZirconHandleInfoFUCHSIABuilder<'a> {
        ImportSemaphoreZirconHandleInfoFUCHSIABuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImportSemaphoreZirconHandleInfoFUCHSIABuilder<'a> {
    inner: ImportSemaphoreZirconHandleInfoFUCHSIA,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ImportSemaphoreZirconHandleInfoFUCHSIABuilder<'a> {
    type Target = ImportSemaphoreZirconHandleInfoFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImportSemaphoreZirconHandleInfoFUCHSIABuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImportSemaphoreZirconHandleInfoFUCHSIABuilder<'a> {
    #[inline]
    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
        self.inner.semaphore = semaphore;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: SemaphoreImportFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    #[inline]
    pub fn zircon_handle(mut self, zircon_handle: zx_handle_t) -> Self {
        self.inner.zircon_handle = zircon_handle;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImportSemaphoreZirconHandleInfoFUCHSIA {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreGetZirconHandleInfoFUCHSIA.html>"]
pub struct SemaphoreGetZirconHandleInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Semaphore,
    pub handle_type: ExternalSemaphoreHandleTypeFlags,
}
impl ::std::default::Default for SemaphoreGetZirconHandleInfoFUCHSIA {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            semaphore: Semaphore::default(),
            handle_type: ExternalSemaphoreHandleTypeFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for SemaphoreGetZirconHandleInfoFUCHSIA {
    const STRUCTURE_TYPE: StructureType = StructureType::SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA;
}
impl SemaphoreGetZirconHandleInfoFUCHSIA {
    pub fn builder<'a>() -> SemaphoreGetZirconHandleInfoFUCHSIABuilder<'a> {
        SemaphoreGetZirconHandleInfoFUCHSIABuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SemaphoreGetZirconHandleInfoFUCHSIABuilder<'a> {
    inner: SemaphoreGetZirconHandleInfoFUCHSIA,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SemaphoreGetZirconHandleInfoFUCHSIABuilder<'a> {
    type Target = SemaphoreGetZirconHandleInfoFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SemaphoreGetZirconHandleInfoFUCHSIABuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SemaphoreGetZirconHandleInfoFUCHSIABuilder<'a> {
    #[inline]
    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
        self.inner.semaphore = semaphore;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalSemaphoreHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SemaphoreGetZirconHandleInfoFUCHSIA {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalFenceInfo.html>"]
pub struct PhysicalDeviceExternalFenceInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalFenceHandleTypeFlags,
}
impl ::std::default::Default for PhysicalDeviceExternalFenceInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_type: ExternalFenceHandleTypeFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceExternalFenceInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;
}
impl PhysicalDeviceExternalFenceInfo {
    pub fn builder<'a>() -> PhysicalDeviceExternalFenceInfoBuilder<'a> {
        PhysicalDeviceExternalFenceInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceExternalFenceInfoBuilder<'a> {
    inner: PhysicalDeviceExternalFenceInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PhysicalDeviceExternalFenceInfoBuilder<'a> {
    type Target = PhysicalDeviceExternalFenceInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceExternalFenceInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceExternalFenceInfoBuilder<'a> {
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalFenceHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceExternalFenceInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalFenceProperties.html>"]
pub struct ExternalFenceProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub export_from_imported_handle_types: ExternalFenceHandleTypeFlags,
    pub compatible_handle_types: ExternalFenceHandleTypeFlags,
    pub external_fence_features: ExternalFenceFeatureFlags,
}
impl ::std::default::Default for ExternalFenceProperties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            export_from_imported_handle_types: ExternalFenceHandleTypeFlags::default(),
            compatible_handle_types: ExternalFenceHandleTypeFlags::default(),
            external_fence_features: ExternalFenceFeatureFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for ExternalFenceProperties {
    const STRUCTURE_TYPE: StructureType = StructureType::EXTERNAL_FENCE_PROPERTIES;
}
impl ExternalFenceProperties {
    pub fn builder<'a>() -> ExternalFencePropertiesBuilder<'a> {
        ExternalFencePropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExternalFencePropertiesBuilder<'a> {
    inner: ExternalFenceProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ExternalFencePropertiesBuilder<'a> {
    type Target = ExternalFenceProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExternalFencePropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExternalFencePropertiesBuilder<'a> {
    #[inline]
    pub fn export_from_imported_handle_types(
        mut self,
        export_from_imported_handle_types: ExternalFenceHandleTypeFlags,
    ) -> Self {
        self.inner.export_from_imported_handle_types = export_from_imported_handle_types;
        self
    }
    #[inline]
    pub fn compatible_handle_types(
        mut self,
        compatible_handle_types: ExternalFenceHandleTypeFlags,
    ) -> Self {
        self.inner.compatible_handle_types = compatible_handle_types;
        self
    }
    #[inline]
    pub fn external_fence_features(
        mut self,
        external_fence_features: ExternalFenceFeatureFlags,
    ) -> Self {
        self.inner.external_fence_features = external_fence_features;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExternalFenceProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportFenceCreateInfo.html>"]
pub struct ExportFenceCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_types: ExternalFenceHandleTypeFlags,
}
impl ::std::default::Default for ExportFenceCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_types: ExternalFenceHandleTypeFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for ExportFenceCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_FENCE_CREATE_INFO;
}
impl ExportFenceCreateInfo {
    pub fn builder<'a>() -> ExportFenceCreateInfoBuilder<'a> {
        ExportFenceCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExportFenceCreateInfoBuilder<'a> {
    inner: ExportFenceCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsFenceCreateInfo for ExportFenceCreateInfoBuilder<'_> {}
unsafe impl ExtendsFenceCreateInfo for ExportFenceCreateInfo {}
impl<'a> ::std::ops::Deref for ExportFenceCreateInfoBuilder<'a> {
    type Target = ExportFenceCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExportFenceCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExportFenceCreateInfoBuilder<'a> {
    #[inline]
    pub fn handle_types(mut self, handle_types: ExternalFenceHandleTypeFlags) -> Self {
        self.inner.handle_types = handle_types;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExportFenceCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportFenceWin32HandleInfoKHR.html>"]
pub struct ImportFenceWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fence: Fence,
    pub flags: FenceImportFlags,
    pub handle_type: ExternalFenceHandleTypeFlags,
    pub handle: HANDLE,
    pub name: LPCWSTR,
}
impl ::std::default::Default for ImportFenceWin32HandleInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            fence: Fence::default(),
            flags: FenceImportFlags::default(),
            handle_type: ExternalFenceHandleTypeFlags::default(),
            handle: unsafe { ::std::mem::zeroed() },
            name: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for ImportFenceWin32HandleInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_FENCE_WIN32_HANDLE_INFO_KHR;
}
impl ImportFenceWin32HandleInfoKHR {
    pub fn builder<'a>() -> ImportFenceWin32HandleInfoKHRBuilder<'a> {
        ImportFenceWin32HandleInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImportFenceWin32HandleInfoKHRBuilder<'a> {
    inner: ImportFenceWin32HandleInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ImportFenceWin32HandleInfoKHRBuilder<'a> {
    type Target = ImportFenceWin32HandleInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImportFenceWin32HandleInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImportFenceWin32HandleInfoKHRBuilder<'a> {
    #[inline]
    pub fn fence(mut self, fence: Fence) -> Self {
        self.inner.fence = fence;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: FenceImportFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalFenceHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    #[inline]
    pub fn handle(mut self, handle: HANDLE) -> Self {
        self.inner.handle = handle;
        self
    }
    #[inline]
    pub fn name(mut self, name: LPCWSTR) -> Self {
        self.inner.name = name;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImportFenceWin32HandleInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportFenceWin32HandleInfoKHR.html>"]
pub struct ExportFenceWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_attributes: *const SECURITY_ATTRIBUTES,
    pub dw_access: DWORD,
    pub name: LPCWSTR,
}
impl ::std::default::Default for ExportFenceWin32HandleInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_attributes: ::std::ptr::null(),
            dw_access: DWORD::default(),
            name: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for ExportFenceWin32HandleInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_FENCE_WIN32_HANDLE_INFO_KHR;
}
impl ExportFenceWin32HandleInfoKHR {
    pub fn builder<'a>() -> ExportFenceWin32HandleInfoKHRBuilder<'a> {
        ExportFenceWin32HandleInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExportFenceWin32HandleInfoKHRBuilder<'a> {
    inner: ExportFenceWin32HandleInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsFenceCreateInfo for ExportFenceWin32HandleInfoKHRBuilder<'_> {}
unsafe impl ExtendsFenceCreateInfo for ExportFenceWin32HandleInfoKHR {}
impl<'a> ::std::ops::Deref for ExportFenceWin32HandleInfoKHRBuilder<'a> {
    type Target = ExportFenceWin32HandleInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExportFenceWin32HandleInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExportFenceWin32HandleInfoKHRBuilder<'a> {
    #[inline]
    pub fn attributes(mut self, attributes: &'a SECURITY_ATTRIBUTES) -> Self {
        self.inner.p_attributes = attributes;
        self
    }
    #[inline]
    pub fn dw_access(mut self, dw_access: DWORD) -> Self {
        self.inner.dw_access = dw_access;
        self
    }
    #[inline]
    pub fn name(mut self, name: LPCWSTR) -> Self {
        self.inner.name = name;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExportFenceWin32HandleInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFenceGetWin32HandleInfoKHR.html>"]
pub struct FenceGetWin32HandleInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fence: Fence,
    pub handle_type: ExternalFenceHandleTypeFlags,
}
impl ::std::default::Default for FenceGetWin32HandleInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            fence: Fence::default(),
            handle_type: ExternalFenceHandleTypeFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for FenceGetWin32HandleInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::FENCE_GET_WIN32_HANDLE_INFO_KHR;
}
impl FenceGetWin32HandleInfoKHR {
    pub fn builder<'a>() -> FenceGetWin32HandleInfoKHRBuilder<'a> {
        FenceGetWin32HandleInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct FenceGetWin32HandleInfoKHRBuilder<'a> {
    inner: FenceGetWin32HandleInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for FenceGetWin32HandleInfoKHRBuilder<'a> {
    type Target = FenceGetWin32HandleInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for FenceGetWin32HandleInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> FenceGetWin32HandleInfoKHRBuilder<'a> {
    #[inline]
    pub fn fence(mut self, fence: Fence) -> Self {
        self.inner.fence = fence;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalFenceHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> FenceGetWin32HandleInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportFenceFdInfoKHR.html>"]
pub struct ImportFenceFdInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fence: Fence,
    pub flags: FenceImportFlags,
    pub handle_type: ExternalFenceHandleTypeFlags,
    pub fd: c_int,
}
impl ::std::default::Default for ImportFenceFdInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            fence: Fence::default(),
            flags: FenceImportFlags::default(),
            handle_type: ExternalFenceHandleTypeFlags::default(),
            fd: c_int::default(),
        }
    }
}
unsafe impl TaggedStructure for ImportFenceFdInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_FENCE_FD_INFO_KHR;
}
impl ImportFenceFdInfoKHR {
    pub fn builder<'a>() -> ImportFenceFdInfoKHRBuilder<'a> {
        ImportFenceFdInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImportFenceFdInfoKHRBuilder<'a> {
    inner: ImportFenceFdInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ImportFenceFdInfoKHRBuilder<'a> {
    type Target = ImportFenceFdInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImportFenceFdInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImportFenceFdInfoKHRBuilder<'a> {
    #[inline]
    pub fn fence(mut self, fence: Fence) -> Self {
        self.inner.fence = fence;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: FenceImportFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalFenceHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    #[inline]
    pub fn fd(mut self, fd: c_int) -> Self {
        self.inner.fd = fd;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImportFenceFdInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFenceGetFdInfoKHR.html>"]
pub struct FenceGetFdInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fence: Fence,
    pub handle_type: ExternalFenceHandleTypeFlags,
}
impl ::std::default::Default for FenceGetFdInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            fence: Fence::default(),
            handle_type: ExternalFenceHandleTypeFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for FenceGetFdInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::FENCE_GET_FD_INFO_KHR;
}
impl FenceGetFdInfoKHR {
    pub fn builder<'a>() -> FenceGetFdInfoKHRBuilder<'a> {
        FenceGetFdInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct FenceGetFdInfoKHRBuilder<'a> {
    inner: FenceGetFdInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for FenceGetFdInfoKHRBuilder<'a> {
    type Target = FenceGetFdInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for FenceGetFdInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> FenceGetFdInfoKHRBuilder<'a> {
    #[inline]
    pub fn fence(mut self, fence: Fence) -> Self {
        self.inner.fence = fence;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalFenceHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> FenceGetFdInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiviewFeatures.html>"]
pub struct PhysicalDeviceMultiviewFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub multiview: Bool32,
    pub multiview_geometry_shader: Bool32,
    pub multiview_tessellation_shader: Bool32,
}
impl ::std::default::Default for PhysicalDeviceMultiviewFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            multiview: Bool32::default(),
            multiview_geometry_shader: Bool32::default(),
            multiview_tessellation_shader: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceMultiviewFeatures {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
}
impl PhysicalDeviceMultiviewFeatures {
    pub fn builder<'a>() -> PhysicalDeviceMultiviewFeaturesBuilder<'a> {
        PhysicalDeviceMultiviewFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceMultiviewFeaturesBuilder<'a> {
    inner: PhysicalDeviceMultiviewFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMultiviewFeaturesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMultiviewFeatures {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMultiviewFeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMultiviewFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDeviceMultiviewFeaturesBuilder<'a> {
    type Target = PhysicalDeviceMultiviewFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceMultiviewFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceMultiviewFeaturesBuilder<'a> {
    #[inline]
    pub fn multiview(mut self, multiview: bool) -> Self {
        self.inner.multiview = multiview.into();
        self
    }
    #[inline]
    pub fn multiview_geometry_shader(mut self, multiview_geometry_shader: bool) -> Self {
        self.inner.multiview_geometry_shader = multiview_geometry_shader.into();
        self
    }
    #[inline]
    pub fn multiview_tessellation_shader(mut self, multiview_tessellation_shader: bool) -> Self {
        self.inner.multiview_tessellation_shader = multiview_tessellation_shader.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceMultiviewFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiviewProperties.html>"]
pub struct PhysicalDeviceMultiviewProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_multiview_view_count: u32,
    pub max_multiview_instance_index: u32,
}
impl ::std::default::Default for PhysicalDeviceMultiviewProperties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_multiview_view_count: u32::default(),
            max_multiview_instance_index: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceMultiviewProperties {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;
}
impl PhysicalDeviceMultiviewProperties {
    pub fn builder<'a>() -> PhysicalDeviceMultiviewPropertiesBuilder<'a> {
        PhysicalDeviceMultiviewPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceMultiviewPropertiesBuilder<'a> {
    inner: PhysicalDeviceMultiviewProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceMultiviewPropertiesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceMultiviewProperties {}
impl<'a> ::std::ops::Deref for PhysicalDeviceMultiviewPropertiesBuilder<'a> {
    type Target = PhysicalDeviceMultiviewProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceMultiviewPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceMultiviewPropertiesBuilder<'a> {
    #[inline]
    pub fn max_multiview_view_count(mut self, max_multiview_view_count: u32) -> Self {
        self.inner.max_multiview_view_count = max_multiview_view_count;
        self
    }
    #[inline]
    pub fn max_multiview_instance_index(mut self, max_multiview_instance_index: u32) -> Self {
        self.inner.max_multiview_instance_index = max_multiview_instance_index;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceMultiviewProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassMultiviewCreateInfo.html>"]
pub struct RenderPassMultiviewCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub subpass_count: u32,
    pub p_view_masks: *const u32,
    pub dependency_count: u32,
    pub p_view_offsets: *const i32,
    pub correlation_mask_count: u32,
    pub p_correlation_masks: *const u32,
}
impl ::std::default::Default for RenderPassMultiviewCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            subpass_count: u32::default(),
            p_view_masks: ::std::ptr::null(),
            dependency_count: u32::default(),
            p_view_offsets: ::std::ptr::null(),
            correlation_mask_count: u32::default(),
            p_correlation_masks: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for RenderPassMultiviewCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::RENDER_PASS_MULTIVIEW_CREATE_INFO;
}
impl RenderPassMultiviewCreateInfo {
    pub fn builder<'a>() -> RenderPassMultiviewCreateInfoBuilder<'a> {
        RenderPassMultiviewCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RenderPassMultiviewCreateInfoBuilder<'a> {
    inner: RenderPassMultiviewCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsRenderPassCreateInfo for RenderPassMultiviewCreateInfoBuilder<'_> {}
unsafe impl ExtendsRenderPassCreateInfo for RenderPassMultiviewCreateInfo {}
impl<'a> ::std::ops::Deref for RenderPassMultiviewCreateInfoBuilder<'a> {
    type Target = RenderPassMultiviewCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RenderPassMultiviewCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RenderPassMultiviewCreateInfoBuilder<'a> {
    #[inline]
    pub fn view_masks(mut self, view_masks: &'a [u32]) -> Self {
        self.inner.subpass_count = view_masks.len() as _;
        self.inner.p_view_masks = view_masks.as_ptr();
        self
    }
    #[inline]
    pub fn view_offsets(mut self, view_offsets: &'a [i32]) -> Self {
        self.inner.dependency_count = view_offsets.len() as _;
        self.inner.p_view_offsets = view_offsets.as_ptr();
        self
    }
    #[inline]
    pub fn correlation_masks(mut self, correlation_masks: &'a [u32]) -> Self {
        self.inner.correlation_mask_count = correlation_masks.len() as _;
        self.inner.p_correlation_masks = correlation_masks.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RenderPassMultiviewCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilities2EXT.html>"]
pub struct SurfaceCapabilities2EXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_image_count: u32,
    pub max_image_count: u32,
    pub current_extent: Extent2D,
    pub min_image_extent: Extent2D,
    pub max_image_extent: Extent2D,
    pub max_image_array_layers: u32,
    pub supported_transforms: SurfaceTransformFlagsKHR,
    pub current_transform: SurfaceTransformFlagsKHR,
    pub supported_composite_alpha: CompositeAlphaFlagsKHR,
    pub supported_usage_flags: ImageUsageFlags,
    pub supported_surface_counters: SurfaceCounterFlagsEXT,
}
impl ::std::default::Default for SurfaceCapabilities2EXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            min_image_count: u32::default(),
            max_image_count: u32::default(),
            current_extent: Extent2D::default(),
            min_image_extent: Extent2D::default(),
            max_image_extent: Extent2D::default(),
            max_image_array_layers: u32::default(),
            supported_transforms: SurfaceTransformFlagsKHR::default(),
            current_transform: SurfaceTransformFlagsKHR::default(),
            supported_composite_alpha: CompositeAlphaFlagsKHR::default(),
            supported_usage_flags: ImageUsageFlags::default(),
            supported_surface_counters: SurfaceCounterFlagsEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for SurfaceCapabilities2EXT {
    const STRUCTURE_TYPE: StructureType = StructureType::SURFACE_CAPABILITIES_2_EXT;
}
impl SurfaceCapabilities2EXT {
    pub fn builder<'a>() -> SurfaceCapabilities2EXTBuilder<'a> {
        SurfaceCapabilities2EXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SurfaceCapabilities2EXTBuilder<'a> {
    inner: SurfaceCapabilities2EXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SurfaceCapabilities2EXTBuilder<'a> {
    type Target = SurfaceCapabilities2EXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SurfaceCapabilities2EXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SurfaceCapabilities2EXTBuilder<'a> {
    #[inline]
    pub fn min_image_count(mut self, min_image_count: u32) -> Self {
        self.inner.min_image_count = min_image_count;
        self
    }
    #[inline]
    pub fn max_image_count(mut self, max_image_count: u32) -> Self {
        self.inner.max_image_count = max_image_count;
        self
    }
    #[inline]
    pub fn current_extent(mut self, current_extent: Extent2D) -> Self {
        self.inner.current_extent = current_extent;
        self
    }
    #[inline]
    pub fn min_image_extent(mut self, min_image_extent: Extent2D) -> Self {
        self.inner.min_image_extent = min_image_extent;
        self
    }
    #[inline]
    pub fn max_image_extent(mut self, max_image_extent: Extent2D) -> Self {
        self.inner.max_image_extent = max_image_extent;
        self
    }
    #[inline]
    pub fn max_image_array_layers(mut self, max_image_array_layers: u32) -> Self {
        self.inner.max_image_array_layers = max_image_array_layers;
        self
    }
    #[inline]
    pub fn supported_transforms(mut self, supported_transforms: SurfaceTransformFlagsKHR) -> Self {
        self.inner.supported_transforms = supported_transforms;
        self
    }
    #[inline]
    pub fn current_transform(mut self, current_transform: SurfaceTransformFlagsKHR) -> Self {
        self.inner.current_transform = current_transform;
        self
    }
    #[inline]
    pub fn supported_composite_alpha(
        mut self,
        supported_composite_alpha: CompositeAlphaFlagsKHR,
    ) -> Self {
        self.inner.supported_composite_alpha = supported_composite_alpha;
        self
    }
    #[inline]
    pub fn supported_usage_flags(mut self, supported_usage_flags: ImageUsageFlags) -> Self {
        self.inner.supported_usage_flags = supported_usage_flags;
        self
    }
    #[inline]
    pub fn supported_surface_counters(
        mut self,
        supported_surface_counters: SurfaceCounterFlagsEXT,
    ) -> Self {
        self.inner.supported_surface_counters = supported_surface_counters;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SurfaceCapabilities2EXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPowerInfoEXT.html>"]
pub struct DisplayPowerInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub power_state: DisplayPowerStateEXT,
}
impl ::std::default::Default for DisplayPowerInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            power_state: DisplayPowerStateEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for DisplayPowerInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::DISPLAY_POWER_INFO_EXT;
}
impl DisplayPowerInfoEXT {
    pub fn builder<'a>() -> DisplayPowerInfoEXTBuilder<'a> {
        DisplayPowerInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DisplayPowerInfoEXTBuilder<'a> {
    inner: DisplayPowerInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DisplayPowerInfoEXTBuilder<'a> {
    type Target = DisplayPowerInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DisplayPowerInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DisplayPowerInfoEXTBuilder<'a> {
    #[inline]
    pub fn power_state(mut self, power_state: DisplayPowerStateEXT) -> Self {
        self.inner.power_state = power_state;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DisplayPowerInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceEventInfoEXT.html>"]
pub struct DeviceEventInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub device_event: DeviceEventTypeEXT,
}
impl ::std::default::Default for DeviceEventInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            device_event: DeviceEventTypeEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for DeviceEventInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_EVENT_INFO_EXT;
}
impl DeviceEventInfoEXT {
    pub fn builder<'a>() -> DeviceEventInfoEXTBuilder<'a> {
        DeviceEventInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceEventInfoEXTBuilder<'a> {
    inner: DeviceEventInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DeviceEventInfoEXTBuilder<'a> {
    type Target = DeviceEventInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceEventInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceEventInfoEXTBuilder<'a> {
    #[inline]
    pub fn device_event(mut self, device_event: DeviceEventTypeEXT) -> Self {
        self.inner.device_event = device_event;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceEventInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayEventInfoEXT.html>"]
pub struct DisplayEventInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub display_event: DisplayEventTypeEXT,
}
impl ::std::default::Default for DisplayEventInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            display_event: DisplayEventTypeEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for DisplayEventInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::DISPLAY_EVENT_INFO_EXT;
}
impl DisplayEventInfoEXT {
    pub fn builder<'a>() -> DisplayEventInfoEXTBuilder<'a> {
        DisplayEventInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DisplayEventInfoEXTBuilder<'a> {
    inner: DisplayEventInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DisplayEventInfoEXTBuilder<'a> {
    type Target = DisplayEventInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DisplayEventInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DisplayEventInfoEXTBuilder<'a> {
    #[inline]
    pub fn display_event(mut self, display_event: DisplayEventTypeEXT) -> Self {
        self.inner.display_event = display_event;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DisplayEventInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainCounterCreateInfoEXT.html>"]
pub struct SwapchainCounterCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub surface_counters: SurfaceCounterFlagsEXT,
}
impl ::std::default::Default for SwapchainCounterCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            surface_counters: SurfaceCounterFlagsEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for SwapchainCounterCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::SWAPCHAIN_COUNTER_CREATE_INFO_EXT;
}
impl SwapchainCounterCreateInfoEXT {
    pub fn builder<'a>() -> SwapchainCounterCreateInfoEXTBuilder<'a> {
        SwapchainCounterCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SwapchainCounterCreateInfoEXTBuilder<'a> {
    inner: SwapchainCounterCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSwapchainCreateInfoKHR for SwapchainCounterCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsSwapchainCreateInfoKHR for SwapchainCounterCreateInfoEXT {}
impl<'a> ::std::ops::Deref for SwapchainCounterCreateInfoEXTBuilder<'a> {
    type Target = SwapchainCounterCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SwapchainCounterCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SwapchainCounterCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn surface_counters(mut self, surface_counters: SurfaceCounterFlagsEXT) -> Self {
        self.inner.surface_counters = surface_counters;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SwapchainCounterCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceGroupProperties.html>"]
pub struct PhysicalDeviceGroupProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub physical_device_count: u32,
    pub physical_devices: [PhysicalDevice; MAX_DEVICE_GROUP_SIZE],
    pub subset_allocation: Bool32,
}
impl ::std::default::Default for PhysicalDeviceGroupProperties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            physical_device_count: u32::default(),
            physical_devices: unsafe { ::std::mem::zeroed() },
            subset_allocation: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceGroupProperties {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_GROUP_PROPERTIES;
}
impl PhysicalDeviceGroupProperties {
    pub fn builder<'a>() -> PhysicalDeviceGroupPropertiesBuilder<'a> {
        PhysicalDeviceGroupPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceGroupPropertiesBuilder<'a> {
    inner: PhysicalDeviceGroupProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PhysicalDeviceGroupPropertiesBuilder<'a> {
    type Target = PhysicalDeviceGroupProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceGroupPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceGroupPropertiesBuilder<'a> {
    #[inline]
    pub fn physical_device_count(mut self, physical_device_count: u32) -> Self {
        self.inner.physical_device_count = physical_device_count;
        self
    }
    #[inline]
    pub fn physical_devices(
        mut self,
        physical_devices: [PhysicalDevice; MAX_DEVICE_GROUP_SIZE],
    ) -> Self {
        self.inner.physical_devices = physical_devices;
        self
    }
    #[inline]
    pub fn subset_allocation(mut self, subset_allocation: bool) -> Self {
        self.inner.subset_allocation = subset_allocation.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceGroupProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryAllocateFlagsInfo.html>"]
pub struct MemoryAllocateFlagsInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: MemoryAllocateFlags,
    pub device_mask: u32,
}
impl ::std::default::Default for MemoryAllocateFlagsInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: MemoryAllocateFlags::default(),
            device_mask: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for MemoryAllocateFlagsInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_ALLOCATE_FLAGS_INFO;
}
impl MemoryAllocateFlagsInfo {
    pub fn builder<'a>() -> MemoryAllocateFlagsInfoBuilder<'a> {
        MemoryAllocateFlagsInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MemoryAllocateFlagsInfoBuilder<'a> {
    inner: MemoryAllocateFlagsInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsMemoryAllocateInfo for MemoryAllocateFlagsInfoBuilder<'_> {}
unsafe impl ExtendsMemoryAllocateInfo for MemoryAllocateFlagsInfo {}
impl<'a> ::std::ops::Deref for MemoryAllocateFlagsInfoBuilder<'a> {
    type Target = MemoryAllocateFlagsInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MemoryAllocateFlagsInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MemoryAllocateFlagsInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: MemoryAllocateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn device_mask(mut self, device_mask: u32) -> Self {
        self.inner.device_mask = device_mask;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MemoryAllocateFlagsInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindBufferMemoryInfo.html>"]
pub struct BindBufferMemoryInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub buffer: Buffer,
    pub memory: DeviceMemory,
    pub memory_offset: DeviceSize,
}
impl ::std::default::Default for BindBufferMemoryInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            buffer: Buffer::default(),
            memory: DeviceMemory::default(),
            memory_offset: DeviceSize::default(),
        }
    }
}
unsafe impl TaggedStructure for BindBufferMemoryInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::BIND_BUFFER_MEMORY_INFO;
}
impl BindBufferMemoryInfo {
    pub fn builder<'a>() -> BindBufferMemoryInfoBuilder<'a> {
        BindBufferMemoryInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BindBufferMemoryInfoBuilder<'a> {
    inner: BindBufferMemoryInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsBindBufferMemoryInfo {}
impl<'a> ::std::ops::Deref for BindBufferMemoryInfoBuilder<'a> {
    type Target = BindBufferMemoryInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BindBufferMemoryInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BindBufferMemoryInfoBuilder<'a> {
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    #[inline]
    pub fn memory_offset(mut self, memory_offset: DeviceSize) -> Self {
        self.inner.memory_offset = memory_offset;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsBindBufferMemoryInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BindBufferMemoryInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindBufferMemoryDeviceGroupInfo.html>"]
pub struct BindBufferMemoryDeviceGroupInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub device_index_count: u32,
    pub p_device_indices: *const u32,
}
impl ::std::default::Default for BindBufferMemoryDeviceGroupInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            device_index_count: u32::default(),
            p_device_indices: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for BindBufferMemoryDeviceGroupInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO;
}
impl BindBufferMemoryDeviceGroupInfo {
    pub fn builder<'a>() -> BindBufferMemoryDeviceGroupInfoBuilder<'a> {
        BindBufferMemoryDeviceGroupInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BindBufferMemoryDeviceGroupInfoBuilder<'a> {
    inner: BindBufferMemoryDeviceGroupInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsBindBufferMemoryInfo for BindBufferMemoryDeviceGroupInfoBuilder<'_> {}
unsafe impl ExtendsBindBufferMemoryInfo for BindBufferMemoryDeviceGroupInfo {}
impl<'a> ::std::ops::Deref for BindBufferMemoryDeviceGroupInfoBuilder<'a> {
    type Target = BindBufferMemoryDeviceGroupInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BindBufferMemoryDeviceGroupInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BindBufferMemoryDeviceGroupInfoBuilder<'a> {
    #[inline]
    pub fn device_indices(mut self, device_indices: &'a [u32]) -> Self {
        self.inner.device_index_count = device_indices.len() as _;
        self.inner.p_device_indices = device_indices.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BindBufferMemoryDeviceGroupInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindImageMemoryInfo.html>"]
pub struct BindImageMemoryInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image: Image,
    pub memory: DeviceMemory,
    pub memory_offset: DeviceSize,
}
impl ::std::default::Default for BindImageMemoryInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image: Image::default(),
            memory: DeviceMemory::default(),
            memory_offset: DeviceSize::default(),
        }
    }
}
unsafe impl TaggedStructure for BindImageMemoryInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::BIND_IMAGE_MEMORY_INFO;
}
impl BindImageMemoryInfo {
    pub fn builder<'a>() -> BindImageMemoryInfoBuilder<'a> {
        BindImageMemoryInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BindImageMemoryInfoBuilder<'a> {
    inner: BindImageMemoryInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsBindImageMemoryInfo {}
impl<'a> ::std::ops::Deref for BindImageMemoryInfoBuilder<'a> {
    type Target = BindImageMemoryInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BindImageMemoryInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BindImageMemoryInfoBuilder<'a> {
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.inner.image = image;
        self
    }
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    #[inline]
    pub fn memory_offset(mut self, memory_offset: DeviceSize) -> Self {
        self.inner.memory_offset = memory_offset;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsBindImageMemoryInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BindImageMemoryInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindImageMemoryDeviceGroupInfo.html>"]
pub struct BindImageMemoryDeviceGroupInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub device_index_count: u32,
    pub p_device_indices: *const u32,
    pub split_instance_bind_region_count: u32,
    pub p_split_instance_bind_regions: *const Rect2D,
}
impl ::std::default::Default for BindImageMemoryDeviceGroupInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            device_index_count: u32::default(),
            p_device_indices: ::std::ptr::null(),
            split_instance_bind_region_count: u32::default(),
            p_split_instance_bind_regions: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for BindImageMemoryDeviceGroupInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO;
}
impl BindImageMemoryDeviceGroupInfo {
    pub fn builder<'a>() -> BindImageMemoryDeviceGroupInfoBuilder<'a> {
        BindImageMemoryDeviceGroupInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BindImageMemoryDeviceGroupInfoBuilder<'a> {
    inner: BindImageMemoryDeviceGroupInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsBindImageMemoryInfo for BindImageMemoryDeviceGroupInfoBuilder<'_> {}
unsafe impl ExtendsBindImageMemoryInfo for BindImageMemoryDeviceGroupInfo {}
impl<'a> ::std::ops::Deref for BindImageMemoryDeviceGroupInfoBuilder<'a> {
    type Target = BindImageMemoryDeviceGroupInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BindImageMemoryDeviceGroupInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BindImageMemoryDeviceGroupInfoBuilder<'a> {
    #[inline]
    pub fn device_indices(mut self, device_indices: &'a [u32]) -> Self {
        self.inner.device_index_count = device_indices.len() as _;
        self.inner.p_device_indices = device_indices.as_ptr();
        self
    }
    #[inline]
    pub fn split_instance_bind_regions(
        mut self,
        split_instance_bind_regions: &'a [Rect2D],
    ) -> Self {
        self.inner.split_instance_bind_region_count = split_instance_bind_regions.len() as _;
        self.inner.p_split_instance_bind_regions = split_instance_bind_regions.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BindImageMemoryDeviceGroupInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupRenderPassBeginInfo.html>"]
pub struct DeviceGroupRenderPassBeginInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub device_mask: u32,
    pub device_render_area_count: u32,
    pub p_device_render_areas: *const Rect2D,
}
impl ::std::default::Default for DeviceGroupRenderPassBeginInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            device_mask: u32::default(),
            device_render_area_count: u32::default(),
            p_device_render_areas: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for DeviceGroupRenderPassBeginInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_GROUP_RENDER_PASS_BEGIN_INFO;
}
impl DeviceGroupRenderPassBeginInfo {
    pub fn builder<'a>() -> DeviceGroupRenderPassBeginInfoBuilder<'a> {
        DeviceGroupRenderPassBeginInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceGroupRenderPassBeginInfoBuilder<'a> {
    inner: DeviceGroupRenderPassBeginInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsRenderPassBeginInfo for DeviceGroupRenderPassBeginInfoBuilder<'_> {}
unsafe impl ExtendsRenderPassBeginInfo for DeviceGroupRenderPassBeginInfo {}
unsafe impl ExtendsRenderingInfo for DeviceGroupRenderPassBeginInfoBuilder<'_> {}
unsafe impl ExtendsRenderingInfo for DeviceGroupRenderPassBeginInfo {}
impl<'a> ::std::ops::Deref for DeviceGroupRenderPassBeginInfoBuilder<'a> {
    type Target = DeviceGroupRenderPassBeginInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceGroupRenderPassBeginInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceGroupRenderPassBeginInfoBuilder<'a> {
    #[inline]
    pub fn device_mask(mut self, device_mask: u32) -> Self {
        self.inner.device_mask = device_mask;
        self
    }
    #[inline]
    pub fn device_render_areas(mut self, device_render_areas: &'a [Rect2D]) -> Self {
        self.inner.device_render_area_count = device_render_areas.len() as _;
        self.inner.p_device_render_areas = device_render_areas.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceGroupRenderPassBeginInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupCommandBufferBeginInfo.html>"]
pub struct DeviceGroupCommandBufferBeginInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub device_mask: u32,
}
impl ::std::default::Default for DeviceGroupCommandBufferBeginInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            device_mask: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for DeviceGroupCommandBufferBeginInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO;
}
impl DeviceGroupCommandBufferBeginInfo {
    pub fn builder<'a>() -> DeviceGroupCommandBufferBeginInfoBuilder<'a> {
        DeviceGroupCommandBufferBeginInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceGroupCommandBufferBeginInfoBuilder<'a> {
    inner: DeviceGroupCommandBufferBeginInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsCommandBufferBeginInfo for DeviceGroupCommandBufferBeginInfoBuilder<'_> {}
unsafe impl ExtendsCommandBufferBeginInfo for DeviceGroupCommandBufferBeginInfo {}
impl<'a> ::std::ops::Deref for DeviceGroupCommandBufferBeginInfoBuilder<'a> {
    type Target = DeviceGroupCommandBufferBeginInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceGroupCommandBufferBeginInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceGroupCommandBufferBeginInfoBuilder<'a> {
    #[inline]
    pub fn device_mask(mut self, device_mask: u32) -> Self {
        self.inner.device_mask = device_mask;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceGroupCommandBufferBeginInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupSubmitInfo.html>"]
pub struct DeviceGroupSubmitInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub wait_semaphore_count: u32,
    pub p_wait_semaphore_device_indices: *const u32,
    pub command_buffer_count: u32,
    pub p_command_buffer_device_masks: *const u32,
    pub signal_semaphore_count: u32,
    pub p_signal_semaphore_device_indices: *const u32,
}
impl ::std::default::Default for DeviceGroupSubmitInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            wait_semaphore_count: u32::default(),
            p_wait_semaphore_device_indices: ::std::ptr::null(),
            command_buffer_count: u32::default(),
            p_command_buffer_device_masks: ::std::ptr::null(),
            signal_semaphore_count: u32::default(),
            p_signal_semaphore_device_indices: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for DeviceGroupSubmitInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_GROUP_SUBMIT_INFO;
}
impl DeviceGroupSubmitInfo {
    pub fn builder<'a>() -> DeviceGroupSubmitInfoBuilder<'a> {
        DeviceGroupSubmitInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceGroupSubmitInfoBuilder<'a> {
    inner: DeviceGroupSubmitInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSubmitInfo for DeviceGroupSubmitInfoBuilder<'_> {}
unsafe impl ExtendsSubmitInfo for DeviceGroupSubmitInfo {}
impl<'a> ::std::ops::Deref for DeviceGroupSubmitInfoBuilder<'a> {
    type Target = DeviceGroupSubmitInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceGroupSubmitInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceGroupSubmitInfoBuilder<'a> {
    #[inline]
    pub fn wait_semaphore_device_indices(
        mut self,
        wait_semaphore_device_indices: &'a [u32],
    ) -> Self {
        self.inner.wait_semaphore_count = wait_semaphore_device_indices.len() as _;
        self.inner.p_wait_semaphore_device_indices = wait_semaphore_device_indices.as_ptr();
        self
    }
    #[inline]
    pub fn command_buffer_device_masks(mut self, command_buffer_device_masks: &'a [u32]) -> Self {
        self.inner.command_buffer_count = command_buffer_device_masks.len() as _;
        self.inner.p_command_buffer_device_masks = command_buffer_device_masks.as_ptr();
        self
    }
    #[inline]
    pub fn signal_semaphore_device_indices(
        mut self,
        signal_semaphore_device_indices: &'a [u32],
    ) -> Self {
        self.inner.signal_semaphore_count = signal_semaphore_device_indices.len() as _;
        self.inner.p_signal_semaphore_device_indices = signal_semaphore_device_indices.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceGroupSubmitInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupBindSparseInfo.html>"]
pub struct DeviceGroupBindSparseInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub resource_device_index: u32,
    pub memory_device_index: u32,
}
impl ::std::default::Default for DeviceGroupBindSparseInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            resource_device_index: u32::default(),
            memory_device_index: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for DeviceGroupBindSparseInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_GROUP_BIND_SPARSE_INFO;
}
impl DeviceGroupBindSparseInfo {
    pub fn builder<'a>() -> DeviceGroupBindSparseInfoBuilder<'a> {
        DeviceGroupBindSparseInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceGroupBindSparseInfoBuilder<'a> {
    inner: DeviceGroupBindSparseInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsBindSparseInfo for DeviceGroupBindSparseInfoBuilder<'_> {}
unsafe impl ExtendsBindSparseInfo for DeviceGroupBindSparseInfo {}
impl<'a> ::std::ops::Deref for DeviceGroupBindSparseInfoBuilder<'a> {
    type Target = DeviceGroupBindSparseInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceGroupBindSparseInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceGroupBindSparseInfoBuilder<'a> {
    #[inline]
    pub fn resource_device_index(mut self, resource_device_index: u32) -> Self {
        self.inner.resource_device_index = resource_device_index;
        self
    }
    #[inline]
    pub fn memory_device_index(mut self, memory_device_index: u32) -> Self {
        self.inner.memory_device_index = memory_device_index;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceGroupBindSparseInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupPresentCapabilitiesKHR.html>"]
pub struct DeviceGroupPresentCapabilitiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub present_mask: [u32; MAX_DEVICE_GROUP_SIZE],
    pub modes: DeviceGroupPresentModeFlagsKHR,
}
impl ::std::default::Default for DeviceGroupPresentCapabilitiesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            present_mask: unsafe { ::std::mem::zeroed() },
            modes: DeviceGroupPresentModeFlagsKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for DeviceGroupPresentCapabilitiesKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_GROUP_PRESENT_CAPABILITIES_KHR;
}
impl DeviceGroupPresentCapabilitiesKHR {
    pub fn builder<'a>() -> DeviceGroupPresentCapabilitiesKHRBuilder<'a> {
        DeviceGroupPresentCapabilitiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceGroupPresentCapabilitiesKHRBuilder<'a> {
    inner: DeviceGroupPresentCapabilitiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DeviceGroupPresentCapabilitiesKHRBuilder<'a> {
    type Target = DeviceGroupPresentCapabilitiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceGroupPresentCapabilitiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceGroupPresentCapabilitiesKHRBuilder<'a> {
    #[inline]
    pub fn present_mask(mut self, present_mask: [u32; MAX_DEVICE_GROUP_SIZE]) -> Self {
        self.inner.present_mask = present_mask;
        self
    }
    #[inline]
    pub fn modes(mut self, modes: DeviceGroupPresentModeFlagsKHR) -> Self {
        self.inner.modes = modes;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceGroupPresentCapabilitiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSwapchainCreateInfoKHR.html>"]
pub struct ImageSwapchainCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain: SwapchainKHR,
}
impl ::std::default::Default for ImageSwapchainCreateInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            swapchain: SwapchainKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for ImageSwapchainCreateInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_SWAPCHAIN_CREATE_INFO_KHR;
}
impl ImageSwapchainCreateInfoKHR {
    pub fn builder<'a>() -> ImageSwapchainCreateInfoKHRBuilder<'a> {
        ImageSwapchainCreateInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageSwapchainCreateInfoKHRBuilder<'a> {
    inner: ImageSwapchainCreateInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageCreateInfo for ImageSwapchainCreateInfoKHRBuilder<'_> {}
unsafe impl ExtendsImageCreateInfo for ImageSwapchainCreateInfoKHR {}
impl<'a> ::std::ops::Deref for ImageSwapchainCreateInfoKHRBuilder<'a> {
    type Target = ImageSwapchainCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageSwapchainCreateInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageSwapchainCreateInfoKHRBuilder<'a> {
    #[inline]
    pub fn swapchain(mut self, swapchain: SwapchainKHR) -> Self {
        self.inner.swapchain = swapchain;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageSwapchainCreateInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindImageMemorySwapchainInfoKHR.html>"]
pub struct BindImageMemorySwapchainInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain: SwapchainKHR,
    pub image_index: u32,
}
impl ::std::default::Default for BindImageMemorySwapchainInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            swapchain: SwapchainKHR::default(),
            image_index: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for BindImageMemorySwapchainInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR;
}
impl BindImageMemorySwapchainInfoKHR {
    pub fn builder<'a>() -> BindImageMemorySwapchainInfoKHRBuilder<'a> {
        BindImageMemorySwapchainInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BindImageMemorySwapchainInfoKHRBuilder<'a> {
    inner: BindImageMemorySwapchainInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsBindImageMemoryInfo for BindImageMemorySwapchainInfoKHRBuilder<'_> {}
unsafe impl ExtendsBindImageMemoryInfo for BindImageMemorySwapchainInfoKHR {}
impl<'a> ::std::ops::Deref for BindImageMemorySwapchainInfoKHRBuilder<'a> {
    type Target = BindImageMemorySwapchainInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BindImageMemorySwapchainInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BindImageMemorySwapchainInfoKHRBuilder<'a> {
    #[inline]
    pub fn swapchain(mut self, swapchain: SwapchainKHR) -> Self {
        self.inner.swapchain = swapchain;
        self
    }
    #[inline]
    pub fn image_index(mut self, image_index: u32) -> Self {
        self.inner.image_index = image_index;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BindImageMemorySwapchainInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAcquireNextImageInfoKHR.html>"]
pub struct AcquireNextImageInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain: SwapchainKHR,
    pub timeout: u64,
    pub semaphore: Semaphore,
    pub fence: Fence,
    pub device_mask: u32,
}
impl ::std::default::Default for AcquireNextImageInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            swapchain: SwapchainKHR::default(),
            timeout: u64::default(),
            semaphore: Semaphore::default(),
            fence: Fence::default(),
            device_mask: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for AcquireNextImageInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::ACQUIRE_NEXT_IMAGE_INFO_KHR;
}
impl AcquireNextImageInfoKHR {
    pub fn builder<'a>() -> AcquireNextImageInfoKHRBuilder<'a> {
        AcquireNextImageInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AcquireNextImageInfoKHRBuilder<'a> {
    inner: AcquireNextImageInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for AcquireNextImageInfoKHRBuilder<'a> {
    type Target = AcquireNextImageInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AcquireNextImageInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AcquireNextImageInfoKHRBuilder<'a> {
    #[inline]
    pub fn swapchain(mut self, swapchain: SwapchainKHR) -> Self {
        self.inner.swapchain = swapchain;
        self
    }
    #[inline]
    pub fn timeout(mut self, timeout: u64) -> Self {
        self.inner.timeout = timeout;
        self
    }
    #[inline]
    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
        self.inner.semaphore = semaphore;
        self
    }
    #[inline]
    pub fn fence(mut self, fence: Fence) -> Self {
        self.inner.fence = fence;
        self
    }
    #[inline]
    pub fn device_mask(mut self, device_mask: u32) -> Self {
        self.inner.device_mask = device_mask;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AcquireNextImageInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupPresentInfoKHR.html>"]
pub struct DeviceGroupPresentInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain_count: u32,
    pub p_device_masks: *const u32,
    pub mode: DeviceGroupPresentModeFlagsKHR,
}
impl ::std::default::Default for DeviceGroupPresentInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            swapchain_count: u32::default(),
            p_device_masks: ::std::ptr::null(),
            mode: DeviceGroupPresentModeFlagsKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for DeviceGroupPresentInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_GROUP_PRESENT_INFO_KHR;
}
impl DeviceGroupPresentInfoKHR {
    pub fn builder<'a>() -> DeviceGroupPresentInfoKHRBuilder<'a> {
        DeviceGroupPresentInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceGroupPresentInfoKHRBuilder<'a> {
    inner: DeviceGroupPresentInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPresentInfoKHR for DeviceGroupPresentInfoKHRBuilder<'_> {}
unsafe impl ExtendsPresentInfoKHR for DeviceGroupPresentInfoKHR {}
impl<'a> ::std::ops::Deref for DeviceGroupPresentInfoKHRBuilder<'a> {
    type Target = DeviceGroupPresentInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceGroupPresentInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceGroupPresentInfoKHRBuilder<'a> {
    #[inline]
    pub fn device_masks(mut self, device_masks: &'a [u32]) -> Self {
        self.inner.swapchain_count = device_masks.len() as _;
        self.inner.p_device_masks = device_masks.as_ptr();
        self
    }
    #[inline]
    pub fn mode(mut self, mode: DeviceGroupPresentModeFlagsKHR) -> Self {
        self.inner.mode = mode;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceGroupPresentInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupDeviceCreateInfo.html>"]
pub struct DeviceGroupDeviceCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub physical_device_count: u32,
    pub p_physical_devices: *const PhysicalDevice,
}
impl ::std::default::Default for DeviceGroupDeviceCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            physical_device_count: u32::default(),
            p_physical_devices: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for DeviceGroupDeviceCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_GROUP_DEVICE_CREATE_INFO;
}
impl DeviceGroupDeviceCreateInfo {
    pub fn builder<'a>() -> DeviceGroupDeviceCreateInfoBuilder<'a> {
        DeviceGroupDeviceCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceGroupDeviceCreateInfoBuilder<'a> {
    inner: DeviceGroupDeviceCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsDeviceCreateInfo for DeviceGroupDeviceCreateInfoBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for DeviceGroupDeviceCreateInfo {}
impl<'a> ::std::ops::Deref for DeviceGroupDeviceCreateInfoBuilder<'a> {
    type Target = DeviceGroupDeviceCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceGroupDeviceCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceGroupDeviceCreateInfoBuilder<'a> {
    #[inline]
    pub fn physical_devices(mut self, physical_devices: &'a [PhysicalDevice]) -> Self {
        self.inner.physical_device_count = physical_devices.len() as _;
        self.inner.p_physical_devices = physical_devices.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceGroupDeviceCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupSwapchainCreateInfoKHR.html>"]
pub struct DeviceGroupSwapchainCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub modes: DeviceGroupPresentModeFlagsKHR,
}
impl ::std::default::Default for DeviceGroupSwapchainCreateInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            modes: DeviceGroupPresentModeFlagsKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for DeviceGroupSwapchainCreateInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR;
}
impl DeviceGroupSwapchainCreateInfoKHR {
    pub fn builder<'a>() -> DeviceGroupSwapchainCreateInfoKHRBuilder<'a> {
        DeviceGroupSwapchainCreateInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceGroupSwapchainCreateInfoKHRBuilder<'a> {
    inner: DeviceGroupSwapchainCreateInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSwapchainCreateInfoKHR for DeviceGroupSwapchainCreateInfoKHRBuilder<'_> {}
unsafe impl ExtendsSwapchainCreateInfoKHR for DeviceGroupSwapchainCreateInfoKHR {}
impl<'a> ::std::ops::Deref for DeviceGroupSwapchainCreateInfoKHRBuilder<'a> {
    type Target = DeviceGroupSwapchainCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceGroupSwapchainCreateInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceGroupSwapchainCreateInfoKHRBuilder<'a> {
    #[inline]
    pub fn modes(mut self, modes: DeviceGroupPresentModeFlagsKHR) -> Self {
        self.inner.modes = modes;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceGroupSwapchainCreateInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorUpdateTemplateEntry.html>"]
pub struct DescriptorUpdateTemplateEntry {
    pub dst_binding: u32,
    pub dst_array_element: u32,
    pub descriptor_count: u32,
    pub descriptor_type: DescriptorType,
    pub offset: usize,
    pub stride: usize,
}
impl DescriptorUpdateTemplateEntry {
    pub fn builder<'a>() -> DescriptorUpdateTemplateEntryBuilder<'a> {
        DescriptorUpdateTemplateEntryBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DescriptorUpdateTemplateEntryBuilder<'a> {
    inner: DescriptorUpdateTemplateEntry,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DescriptorUpdateTemplateEntryBuilder<'a> {
    type Target = DescriptorUpdateTemplateEntry;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DescriptorUpdateTemplateEntryBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DescriptorUpdateTemplateEntryBuilder<'a> {
    #[inline]
    pub fn dst_binding(mut self, dst_binding: u32) -> Self {
        self.inner.dst_binding = dst_binding;
        self
    }
    #[inline]
    pub fn dst_array_element(mut self, dst_array_element: u32) -> Self {
        self.inner.dst_array_element = dst_array_element;
        self
    }
    #[inline]
    pub fn descriptor_count(mut self, descriptor_count: u32) -> Self {
        self.inner.descriptor_count = descriptor_count;
        self
    }
    #[inline]
    pub fn descriptor_type(mut self, descriptor_type: DescriptorType) -> Self {
        self.inner.descriptor_type = descriptor_type;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: usize) -> Self {
        self.inner.offset = offset;
        self
    }
    #[inline]
    pub fn stride(mut self, stride: usize) -> Self {
        self.inner.stride = stride;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DescriptorUpdateTemplateEntry {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorUpdateTemplateCreateInfo.html>"]
pub struct DescriptorUpdateTemplateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DescriptorUpdateTemplateCreateFlags,
    pub descriptor_update_entry_count: u32,
    pub p_descriptor_update_entries: *const DescriptorUpdateTemplateEntry,
    pub template_type: DescriptorUpdateTemplateType,
    pub descriptor_set_layout: DescriptorSetLayout,
    pub pipeline_bind_point: PipelineBindPoint,
    pub pipeline_layout: PipelineLayout,
    pub set: u32,
}
impl ::std::default::Default for DescriptorUpdateTemplateCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DescriptorUpdateTemplateCreateFlags::default(),
            descriptor_update_entry_count: u32::default(),
            p_descriptor_update_entries: ::std::ptr::null(),
            template_type: DescriptorUpdateTemplateType::default(),
            descriptor_set_layout: DescriptorSetLayout::default(),
            pipeline_bind_point: PipelineBindPoint::default(),
            pipeline_layout: PipelineLayout::default(),
            set: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for DescriptorUpdateTemplateCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO;
}
impl DescriptorUpdateTemplateCreateInfo {
    pub fn builder<'a>() -> DescriptorUpdateTemplateCreateInfoBuilder<'a> {
        DescriptorUpdateTemplateCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DescriptorUpdateTemplateCreateInfoBuilder<'a> {
    inner: DescriptorUpdateTemplateCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DescriptorUpdateTemplateCreateInfoBuilder<'a> {
    type Target = DescriptorUpdateTemplateCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DescriptorUpdateTemplateCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DescriptorUpdateTemplateCreateInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: DescriptorUpdateTemplateCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn descriptor_update_entries(
        mut self,
        descriptor_update_entries: &'a [DescriptorUpdateTemplateEntry],
    ) -> Self {
        self.inner.descriptor_update_entry_count = descriptor_update_entries.len() as _;
        self.inner.p_descriptor_update_entries = descriptor_update_entries.as_ptr();
        self
    }
    #[inline]
    pub fn template_type(mut self, template_type: DescriptorUpdateTemplateType) -> Self {
        self.inner.template_type = template_type;
        self
    }
    #[inline]
    pub fn descriptor_set_layout(mut self, descriptor_set_layout: DescriptorSetLayout) -> Self {
        self.inner.descriptor_set_layout = descriptor_set_layout;
        self
    }
    #[inline]
    pub fn pipeline_bind_point(mut self, pipeline_bind_point: PipelineBindPoint) -> Self {
        self.inner.pipeline_bind_point = pipeline_bind_point;
        self
    }
    #[inline]
    pub fn pipeline_layout(mut self, pipeline_layout: PipelineLayout) -> Self {
        self.inner.pipeline_layout = pipeline_layout;
        self
    }
    #[inline]
    pub fn set(mut self, set: u32) -> Self {
        self.inner.set = set;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DescriptorUpdateTemplateCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkXYColorEXT.html>"]
pub struct XYColorEXT {
    pub x: f32,
    pub y: f32,
}
impl XYColorEXT {
    pub fn builder<'a>() -> XYColorEXTBuilder<'a> {
        XYColorEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct XYColorEXTBuilder<'a> {
    inner: XYColorEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for XYColorEXTBuilder<'a> {
    type Target = XYColorEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for XYColorEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> XYColorEXTBuilder<'a> {
    #[inline]
    pub fn x(mut self, x: f32) -> Self {
        self.inner.x = x;
        self
    }
    #[inline]
    pub fn y(mut self, y: f32) -> Self {
        self.inner.y = y;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> XYColorEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePresentIdFeaturesKHR.html>"]
pub struct PhysicalDevicePresentIdFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub present_id: Bool32,
}
impl ::std::default::Default for PhysicalDevicePresentIdFeaturesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            present_id: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevicePresentIdFeaturesKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR;
}
impl PhysicalDevicePresentIdFeaturesKHR {
    pub fn builder<'a>() -> PhysicalDevicePresentIdFeaturesKHRBuilder<'a> {
        PhysicalDevicePresentIdFeaturesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevicePresentIdFeaturesKHRBuilder<'a> {
    inner: PhysicalDevicePresentIdFeaturesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePresentIdFeaturesKHRBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePresentIdFeaturesKHR {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePresentIdFeaturesKHRBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePresentIdFeaturesKHR {}
impl<'a> ::std::ops::Deref for PhysicalDevicePresentIdFeaturesKHRBuilder<'a> {
    type Target = PhysicalDevicePresentIdFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevicePresentIdFeaturesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevicePresentIdFeaturesKHRBuilder<'a> {
    #[inline]
    pub fn present_id(mut self, present_id: bool) -> Self {
        self.inner.present_id = present_id.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevicePresentIdFeaturesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentIdKHR.html>"]
pub struct PresentIdKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain_count: u32,
    pub p_present_ids: *const u64,
}
impl ::std::default::Default for PresentIdKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            swapchain_count: u32::default(),
            p_present_ids: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for PresentIdKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::PRESENT_ID_KHR;
}
impl PresentIdKHR {
    pub fn builder<'a>() -> PresentIdKHRBuilder<'a> {
        PresentIdKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PresentIdKHRBuilder<'a> {
    inner: PresentIdKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPresentInfoKHR for PresentIdKHRBuilder<'_> {}
unsafe impl ExtendsPresentInfoKHR for PresentIdKHR {}
impl<'a> ::std::ops::Deref for PresentIdKHRBuilder<'a> {
    type Target = PresentIdKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PresentIdKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PresentIdKHRBuilder<'a> {
    #[inline]
    pub fn present_ids(mut self, present_ids: &'a [u64]) -> Self {
        self.inner.swapchain_count = present_ids.len() as _;
        self.inner.p_present_ids = present_ids.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PresentIdKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePresentWaitFeaturesKHR.html>"]
pub struct PhysicalDevicePresentWaitFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub present_wait: Bool32,
}
impl ::std::default::Default for PhysicalDevicePresentWaitFeaturesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            present_wait: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevicePresentWaitFeaturesKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR;
}
impl PhysicalDevicePresentWaitFeaturesKHR {
    pub fn builder<'a>() -> PhysicalDevicePresentWaitFeaturesKHRBuilder<'a> {
        PhysicalDevicePresentWaitFeaturesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevicePresentWaitFeaturesKHRBuilder<'a> {
    inner: PhysicalDevicePresentWaitFeaturesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePresentWaitFeaturesKHRBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePresentWaitFeaturesKHR {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePresentWaitFeaturesKHRBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePresentWaitFeaturesKHR {}
impl<'a> ::std::ops::Deref for PhysicalDevicePresentWaitFeaturesKHRBuilder<'a> {
    type Target = PhysicalDevicePresentWaitFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevicePresentWaitFeaturesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevicePresentWaitFeaturesKHRBuilder<'a> {
    #[inline]
    pub fn present_wait(mut self, present_wait: bool) -> Self {
        self.inner.present_wait = present_wait.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevicePresentWaitFeaturesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkHdrMetadataEXT.html>"]
pub struct HdrMetadataEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub display_primary_red: XYColorEXT,
    pub display_primary_green: XYColorEXT,
    pub display_primary_blue: XYColorEXT,
    pub white_point: XYColorEXT,
    pub max_luminance: f32,
    pub min_luminance: f32,
    pub max_content_light_level: f32,
    pub max_frame_average_light_level: f32,
}
impl ::std::default::Default for HdrMetadataEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            display_primary_red: XYColorEXT::default(),
            display_primary_green: XYColorEXT::default(),
            display_primary_blue: XYColorEXT::default(),
            white_point: XYColorEXT::default(),
            max_luminance: f32::default(),
            min_luminance: f32::default(),
            max_content_light_level: f32::default(),
            max_frame_average_light_level: f32::default(),
        }
    }
}
unsafe impl TaggedStructure for HdrMetadataEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::HDR_METADATA_EXT;
}
impl HdrMetadataEXT {
    pub fn builder<'a>() -> HdrMetadataEXTBuilder<'a> {
        HdrMetadataEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct HdrMetadataEXTBuilder<'a> {
    inner: HdrMetadataEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for HdrMetadataEXTBuilder<'a> {
    type Target = HdrMetadataEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for HdrMetadataEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> HdrMetadataEXTBuilder<'a> {
    #[inline]
    pub fn display_primary_red(mut self, display_primary_red: XYColorEXT) -> Self {
        self.inner.display_primary_red = display_primary_red;
        self
    }
    #[inline]
    pub fn display_primary_green(mut self, display_primary_green: XYColorEXT) -> Self {
        self.inner.display_primary_green = display_primary_green;
        self
    }
    #[inline]
    pub fn display_primary_blue(mut self, display_primary_blue: XYColorEXT) -> Self {
        self.inner.display_primary_blue = display_primary_blue;
        self
    }
    #[inline]
    pub fn white_point(mut self, white_point: XYColorEXT) -> Self {
        self.inner.white_point = white_point;
        self
    }
    #[inline]
    pub fn max_luminance(mut self, max_luminance: f32) -> Self {
        self.inner.max_luminance = max_luminance;
        self
    }
    #[inline]
    pub fn min_luminance(mut self, min_luminance: f32) -> Self {
        self.inner.min_luminance = min_luminance;
        self
    }
    #[inline]
    pub fn max_content_light_level(mut self, max_content_light_level: f32) -> Self {
        self.inner.max_content_light_level = max_content_light_level;
        self
    }
    #[inline]
    pub fn max_frame_average_light_level(mut self, max_frame_average_light_level: f32) -> Self {
        self.inner.max_frame_average_light_level = max_frame_average_light_level;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> HdrMetadataEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayNativeHdrSurfaceCapabilitiesAMD.html>"]
pub struct DisplayNativeHdrSurfaceCapabilitiesAMD {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub local_dimming_support: Bool32,
}
impl ::std::default::Default for DisplayNativeHdrSurfaceCapabilitiesAMD {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            local_dimming_support: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for DisplayNativeHdrSurfaceCapabilitiesAMD {
    const STRUCTURE_TYPE: StructureType =
        StructureType::DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD;
}
impl DisplayNativeHdrSurfaceCapabilitiesAMD {
    pub fn builder<'a>() -> DisplayNativeHdrSurfaceCapabilitiesAMDBuilder<'a> {
        DisplayNativeHdrSurfaceCapabilitiesAMDBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DisplayNativeHdrSurfaceCapabilitiesAMDBuilder<'a> {
    inner: DisplayNativeHdrSurfaceCapabilitiesAMD,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSurfaceCapabilities2KHR for DisplayNativeHdrSurfaceCapabilitiesAMDBuilder<'_> {}
unsafe impl ExtendsSurfaceCapabilities2KHR for DisplayNativeHdrSurfaceCapabilitiesAMD {}
impl<'a> ::std::ops::Deref for DisplayNativeHdrSurfaceCapabilitiesAMDBuilder<'a> {
    type Target = DisplayNativeHdrSurfaceCapabilitiesAMD;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DisplayNativeHdrSurfaceCapabilitiesAMDBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DisplayNativeHdrSurfaceCapabilitiesAMDBuilder<'a> {
    #[inline]
    pub fn local_dimming_support(mut self, local_dimming_support: bool) -> Self {
        self.inner.local_dimming_support = local_dimming_support.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DisplayNativeHdrSurfaceCapabilitiesAMD {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainDisplayNativeHdrCreateInfoAMD.html>"]
pub struct SwapchainDisplayNativeHdrCreateInfoAMD {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub local_dimming_enable: Bool32,
}
impl ::std::default::Default for SwapchainDisplayNativeHdrCreateInfoAMD {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            local_dimming_enable: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for SwapchainDisplayNativeHdrCreateInfoAMD {
    const STRUCTURE_TYPE: StructureType =
        StructureType::SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD;
}
impl SwapchainDisplayNativeHdrCreateInfoAMD {
    pub fn builder<'a>() -> SwapchainDisplayNativeHdrCreateInfoAMDBuilder<'a> {
        SwapchainDisplayNativeHdrCreateInfoAMDBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SwapchainDisplayNativeHdrCreateInfoAMDBuilder<'a> {
    inner: SwapchainDisplayNativeHdrCreateInfoAMD,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSwapchainCreateInfoKHR for SwapchainDisplayNativeHdrCreateInfoAMDBuilder<'_> {}
unsafe impl ExtendsSwapchainCreateInfoKHR for SwapchainDisplayNativeHdrCreateInfoAMD {}
impl<'a> ::std::ops::Deref for SwapchainDisplayNativeHdrCreateInfoAMDBuilder<'a> {
    type Target = SwapchainDisplayNativeHdrCreateInfoAMD;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SwapchainDisplayNativeHdrCreateInfoAMDBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SwapchainDisplayNativeHdrCreateInfoAMDBuilder<'a> {
    #[inline]
    pub fn local_dimming_enable(mut self, local_dimming_enable: bool) -> Self {
        self.inner.local_dimming_enable = local_dimming_enable.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SwapchainDisplayNativeHdrCreateInfoAMD {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRefreshCycleDurationGOOGLE.html>"]
pub struct RefreshCycleDurationGOOGLE {
    pub refresh_duration: u64,
}
impl RefreshCycleDurationGOOGLE {
    pub fn builder<'a>() -> RefreshCycleDurationGOOGLEBuilder<'a> {
        RefreshCycleDurationGOOGLEBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RefreshCycleDurationGOOGLEBuilder<'a> {
    inner: RefreshCycleDurationGOOGLE,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for RefreshCycleDurationGOOGLEBuilder<'a> {
    type Target = RefreshCycleDurationGOOGLE;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RefreshCycleDurationGOOGLEBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RefreshCycleDurationGOOGLEBuilder<'a> {
    #[inline]
    pub fn refresh_duration(mut self, refresh_duration: u64) -> Self {
        self.inner.refresh_duration = refresh_duration;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RefreshCycleDurationGOOGLE {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPastPresentationTimingGOOGLE.html>"]
pub struct PastPresentationTimingGOOGLE {
    pub present_id: u32,
    pub desired_present_time: u64,
    pub actual_present_time: u64,
    pub earliest_present_time: u64,
    pub present_margin: u64,
}
impl PastPresentationTimingGOOGLE {
    pub fn builder<'a>() -> PastPresentationTimingGOOGLEBuilder<'a> {
        PastPresentationTimingGOOGLEBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PastPresentationTimingGOOGLEBuilder<'a> {
    inner: PastPresentationTimingGOOGLE,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PastPresentationTimingGOOGLEBuilder<'a> {
    type Target = PastPresentationTimingGOOGLE;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PastPresentationTimingGOOGLEBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PastPresentationTimingGOOGLEBuilder<'a> {
    #[inline]
    pub fn present_id(mut self, present_id: u32) -> Self {
        self.inner.present_id = present_id;
        self
    }
    #[inline]
    pub fn desired_present_time(mut self, desired_present_time: u64) -> Self {
        self.inner.desired_present_time = desired_present_time;
        self
    }
    #[inline]
    pub fn actual_present_time(mut self, actual_present_time: u64) -> Self {
        self.inner.actual_present_time = actual_present_time;
        self
    }
    #[inline]
    pub fn earliest_present_time(mut self, earliest_present_time: u64) -> Self {
        self.inner.earliest_present_time = earliest_present_time;
        self
    }
    #[inline]
    pub fn present_margin(mut self, present_margin: u64) -> Self {
        self.inner.present_margin = present_margin;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PastPresentationTimingGOOGLE {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentTimesInfoGOOGLE.html>"]
pub struct PresentTimesInfoGOOGLE {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain_count: u32,
    pub p_times: *const PresentTimeGOOGLE,
}
impl ::std::default::Default for PresentTimesInfoGOOGLE {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            swapchain_count: u32::default(),
            p_times: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for PresentTimesInfoGOOGLE {
    const STRUCTURE_TYPE: StructureType = StructureType::PRESENT_TIMES_INFO_GOOGLE;
}
impl PresentTimesInfoGOOGLE {
    pub fn builder<'a>() -> PresentTimesInfoGOOGLEBuilder<'a> {
        PresentTimesInfoGOOGLEBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PresentTimesInfoGOOGLEBuilder<'a> {
    inner: PresentTimesInfoGOOGLE,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPresentInfoKHR for PresentTimesInfoGOOGLEBuilder<'_> {}
unsafe impl ExtendsPresentInfoKHR for PresentTimesInfoGOOGLE {}
impl<'a> ::std::ops::Deref for PresentTimesInfoGOOGLEBuilder<'a> {
    type Target = PresentTimesInfoGOOGLE;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PresentTimesInfoGOOGLEBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PresentTimesInfoGOOGLEBuilder<'a> {
    #[inline]
    pub fn times(mut self, times: &'a [PresentTimeGOOGLE]) -> Self {
        self.inner.swapchain_count = times.len() as _;
        self.inner.p_times = times.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PresentTimesInfoGOOGLE {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentTimeGOOGLE.html>"]
pub struct PresentTimeGOOGLE {
    pub present_id: u32,
    pub desired_present_time: u64,
}
impl PresentTimeGOOGLE {
    pub fn builder<'a>() -> PresentTimeGOOGLEBuilder<'a> {
        PresentTimeGOOGLEBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PresentTimeGOOGLEBuilder<'a> {
    inner: PresentTimeGOOGLE,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PresentTimeGOOGLEBuilder<'a> {
    type Target = PresentTimeGOOGLE;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PresentTimeGOOGLEBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PresentTimeGOOGLEBuilder<'a> {
    #[inline]
    pub fn present_id(mut self, present_id: u32) -> Self {
        self.inner.present_id = present_id;
        self
    }
    #[inline]
    pub fn desired_present_time(mut self, desired_present_time: u64) -> Self {
        self.inner.desired_present_time = desired_present_time;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PresentTimeGOOGLE {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkIOSSurfaceCreateInfoMVK.html>"]
pub struct IOSSurfaceCreateInfoMVK {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: IOSSurfaceCreateFlagsMVK,
    pub p_view: *const c_void,
}
impl ::std::default::Default for IOSSurfaceCreateInfoMVK {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: IOSSurfaceCreateFlagsMVK::default(),
            p_view: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for IOSSurfaceCreateInfoMVK {
    const STRUCTURE_TYPE: StructureType = StructureType::IOS_SURFACE_CREATE_INFO_MVK;
}
impl IOSSurfaceCreateInfoMVK {
    pub fn builder<'a>() -> IOSSurfaceCreateInfoMVKBuilder<'a> {
        IOSSurfaceCreateInfoMVKBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct IOSSurfaceCreateInfoMVKBuilder<'a> {
    inner: IOSSurfaceCreateInfoMVK,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for IOSSurfaceCreateInfoMVKBuilder<'a> {
    type Target = IOSSurfaceCreateInfoMVK;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for IOSSurfaceCreateInfoMVKBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> IOSSurfaceCreateInfoMVKBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: IOSSurfaceCreateFlagsMVK) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn view(mut self, view: *const c_void) -> Self {
        self.inner.p_view = view;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> IOSSurfaceCreateInfoMVK {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMacOSSurfaceCreateInfoMVK.html>"]
pub struct MacOSSurfaceCreateInfoMVK {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: MacOSSurfaceCreateFlagsMVK,
    pub p_view: *const c_void,
}
impl ::std::default::Default for MacOSSurfaceCreateInfoMVK {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: MacOSSurfaceCreateFlagsMVK::default(),
            p_view: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for MacOSSurfaceCreateInfoMVK {
    const STRUCTURE_TYPE: StructureType = StructureType::MACOS_SURFACE_CREATE_INFO_MVK;
}
impl MacOSSurfaceCreateInfoMVK {
    pub fn builder<'a>() -> MacOSSurfaceCreateInfoMVKBuilder<'a> {
        MacOSSurfaceCreateInfoMVKBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MacOSSurfaceCreateInfoMVKBuilder<'a> {
    inner: MacOSSurfaceCreateInfoMVK,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MacOSSurfaceCreateInfoMVKBuilder<'a> {
    type Target = MacOSSurfaceCreateInfoMVK;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MacOSSurfaceCreateInfoMVKBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MacOSSurfaceCreateInfoMVKBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: MacOSSurfaceCreateFlagsMVK) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn view(mut self, view: *const c_void) -> Self {
        self.inner.p_view = view;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MacOSSurfaceCreateInfoMVK {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMetalSurfaceCreateInfoEXT.html>"]
pub struct MetalSurfaceCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: MetalSurfaceCreateFlagsEXT,
    pub p_layer: *const CAMetalLayer,
}
impl ::std::default::Default for MetalSurfaceCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: MetalSurfaceCreateFlagsEXT::default(),
            p_layer: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for MetalSurfaceCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::METAL_SURFACE_CREATE_INFO_EXT;
}
impl MetalSurfaceCreateInfoEXT {
    pub fn builder<'a>() -> MetalSurfaceCreateInfoEXTBuilder<'a> {
        MetalSurfaceCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MetalSurfaceCreateInfoEXTBuilder<'a> {
    inner: MetalSurfaceCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MetalSurfaceCreateInfoEXTBuilder<'a> {
    type Target = MetalSurfaceCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MetalSurfaceCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MetalSurfaceCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: MetalSurfaceCreateFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn layer(mut self, layer: *const CAMetalLayer) -> Self {
        self.inner.p_layer = layer;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MetalSurfaceCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkViewportWScalingNV.html>"]
pub struct ViewportWScalingNV {
    pub xcoeff: f32,
    pub ycoeff: f32,
}
impl ViewportWScalingNV {
    pub fn builder<'a>() -> ViewportWScalingNVBuilder<'a> {
        ViewportWScalingNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ViewportWScalingNVBuilder<'a> {
    inner: ViewportWScalingNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ViewportWScalingNVBuilder<'a> {
    type Target = ViewportWScalingNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ViewportWScalingNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ViewportWScalingNVBuilder<'a> {
    #[inline]
    pub fn xcoeff(mut self, xcoeff: f32) -> Self {
        self.inner.xcoeff = xcoeff;
        self
    }
    #[inline]
    pub fn ycoeff(mut self, ycoeff: f32) -> Self {
        self.inner.ycoeff = ycoeff;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ViewportWScalingNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportWScalingStateCreateInfoNV.html>"]
pub struct PipelineViewportWScalingStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub viewport_w_scaling_enable: Bool32,
    pub viewport_count: u32,
    pub p_viewport_w_scalings: *const ViewportWScalingNV,
}
impl ::std::default::Default for PipelineViewportWScalingStateCreateInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            viewport_w_scaling_enable: Bool32::default(),
            viewport_count: u32::default(),
            p_viewport_w_scalings: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for PipelineViewportWScalingStateCreateInfoNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV;
}
impl PipelineViewportWScalingStateCreateInfoNV {
    pub fn builder<'a>() -> PipelineViewportWScalingStateCreateInfoNVBuilder<'a> {
        PipelineViewportWScalingStateCreateInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineViewportWScalingStateCreateInfoNVBuilder<'a> {
    inner: PipelineViewportWScalingStateCreateInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPipelineViewportStateCreateInfo
    for PipelineViewportWScalingStateCreateInfoNVBuilder<'_>
{
}
unsafe impl ExtendsPipelineViewportStateCreateInfo for PipelineViewportWScalingStateCreateInfoNV {}
impl<'a> ::std::ops::Deref for PipelineViewportWScalingStateCreateInfoNVBuilder<'a> {
    type Target = PipelineViewportWScalingStateCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineViewportWScalingStateCreateInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineViewportWScalingStateCreateInfoNVBuilder<'a> {
    #[inline]
    pub fn viewport_w_scaling_enable(mut self, viewport_w_scaling_enable: bool) -> Self {
        self.inner.viewport_w_scaling_enable = viewport_w_scaling_enable.into();
        self
    }
    #[inline]
    pub fn viewport_w_scalings(mut self, viewport_w_scalings: &'a [ViewportWScalingNV]) -> Self {
        self.inner.viewport_count = viewport_w_scalings.len() as _;
        self.inner.p_viewport_w_scalings = viewport_w_scalings.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineViewportWScalingStateCreateInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkViewportSwizzleNV.html>"]
pub struct ViewportSwizzleNV {
    pub x: ViewportCoordinateSwizzleNV,
    pub y: ViewportCoordinateSwizzleNV,
    pub z: ViewportCoordinateSwizzleNV,
    pub w: ViewportCoordinateSwizzleNV,
}
impl ViewportSwizzleNV {
    pub fn builder<'a>() -> ViewportSwizzleNVBuilder<'a> {
        ViewportSwizzleNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ViewportSwizzleNVBuilder<'a> {
    inner: ViewportSwizzleNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ViewportSwizzleNVBuilder<'a> {
    type Target = ViewportSwizzleNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ViewportSwizzleNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ViewportSwizzleNVBuilder<'a> {
    #[inline]
    pub fn x(mut self, x: ViewportCoordinateSwizzleNV) -> Self {
        self.inner.x = x;
        self
    }
    #[inline]
    pub fn y(mut self, y: ViewportCoordinateSwizzleNV) -> Self {
        self.inner.y = y;
        self
    }
    #[inline]
    pub fn z(mut self, z: ViewportCoordinateSwizzleNV) -> Self {
        self.inner.z = z;
        self
    }
    #[inline]
    pub fn w(mut self, w: ViewportCoordinateSwizzleNV) -> Self {
        self.inner.w = w;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ViewportSwizzleNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportSwizzleStateCreateInfoNV.html>"]
pub struct PipelineViewportSwizzleStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineViewportSwizzleStateCreateFlagsNV,
    pub viewport_count: u32,
    pub p_viewport_swizzles: *const ViewportSwizzleNV,
}
impl ::std::default::Default for PipelineViewportSwizzleStateCreateInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineViewportSwizzleStateCreateFlagsNV::default(),
            viewport_count: u32::default(),
            p_viewport_swizzles: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for PipelineViewportSwizzleStateCreateInfoNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV;
}
impl PipelineViewportSwizzleStateCreateInfoNV {
    pub fn builder<'a>() -> PipelineViewportSwizzleStateCreateInfoNVBuilder<'a> {
        PipelineViewportSwizzleStateCreateInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineViewportSwizzleStateCreateInfoNVBuilder<'a> {
    inner: PipelineViewportSwizzleStateCreateInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPipelineViewportStateCreateInfo
    for PipelineViewportSwizzleStateCreateInfoNVBuilder<'_>
{
}
unsafe impl ExtendsPipelineViewportStateCreateInfo for PipelineViewportSwizzleStateCreateInfoNV {}
impl<'a> ::std::ops::Deref for PipelineViewportSwizzleStateCreateInfoNVBuilder<'a> {
    type Target = PipelineViewportSwizzleStateCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineViewportSwizzleStateCreateInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineViewportSwizzleStateCreateInfoNVBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineViewportSwizzleStateCreateFlagsNV) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn viewport_swizzles(mut self, viewport_swizzles: &'a [ViewportSwizzleNV]) -> Self {
        self.inner.viewport_count = viewport_swizzles.len() as _;
        self.inner.p_viewport_swizzles = viewport_swizzles.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineViewportSwizzleStateCreateInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDiscardRectanglePropertiesEXT.html>"]
pub struct PhysicalDeviceDiscardRectanglePropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_discard_rectangles: u32,
}
impl ::std::default::Default for PhysicalDeviceDiscardRectanglePropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_discard_rectangles: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceDiscardRectanglePropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT;
}
impl PhysicalDeviceDiscardRectanglePropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceDiscardRectanglePropertiesEXTBuilder<'a> {
        PhysicalDeviceDiscardRectanglePropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceDiscardRectanglePropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceDiscardRectanglePropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceDiscardRectanglePropertiesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceDiscardRectanglePropertiesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceDiscardRectanglePropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceDiscardRectanglePropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceDiscardRectanglePropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceDiscardRectanglePropertiesEXTBuilder<'a> {
    #[inline]
    pub fn max_discard_rectangles(mut self, max_discard_rectangles: u32) -> Self {
        self.inner.max_discard_rectangles = max_discard_rectangles;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceDiscardRectanglePropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDiscardRectangleStateCreateInfoEXT.html>"]
pub struct PipelineDiscardRectangleStateCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineDiscardRectangleStateCreateFlagsEXT,
    pub discard_rectangle_mode: DiscardRectangleModeEXT,
    pub discard_rectangle_count: u32,
    pub p_discard_rectangles: *const Rect2D,
}
impl ::std::default::Default for PipelineDiscardRectangleStateCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineDiscardRectangleStateCreateFlagsEXT::default(),
            discard_rectangle_mode: DiscardRectangleModeEXT::default(),
            discard_rectangle_count: u32::default(),
            p_discard_rectangles: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for PipelineDiscardRectangleStateCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT;
}
impl PipelineDiscardRectangleStateCreateInfoEXT {
    pub fn builder<'a>() -> PipelineDiscardRectangleStateCreateInfoEXTBuilder<'a> {
        PipelineDiscardRectangleStateCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineDiscardRectangleStateCreateInfoEXTBuilder<'a> {
    inner: PipelineDiscardRectangleStateCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsGraphicsPipelineCreateInfo
    for PipelineDiscardRectangleStateCreateInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsGraphicsPipelineCreateInfo for PipelineDiscardRectangleStateCreateInfoEXT {}
impl<'a> ::std::ops::Deref for PipelineDiscardRectangleStateCreateInfoEXTBuilder<'a> {
    type Target = PipelineDiscardRectangleStateCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineDiscardRectangleStateCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineDiscardRectangleStateCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineDiscardRectangleStateCreateFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn discard_rectangle_mode(
        mut self,
        discard_rectangle_mode: DiscardRectangleModeEXT,
    ) -> Self {
        self.inner.discard_rectangle_mode = discard_rectangle_mode;
        self
    }
    #[inline]
    pub fn discard_rectangles(mut self, discard_rectangles: &'a [Rect2D]) -> Self {
        self.inner.discard_rectangle_count = discard_rectangles.len() as _;
        self.inner.p_discard_rectangles = discard_rectangles.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineDiscardRectangleStateCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.html>"]
pub struct PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub per_view_position_all_components: Bool32,
}
impl ::std::default::Default for PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            per_view_position_all_components: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX;
}
impl PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
    pub fn builder<'a>() -> PhysicalDeviceMultiviewPerViewAttributesPropertiesNVXBuilder<'a> {
        PhysicalDeviceMultiviewPerViewAttributesPropertiesNVXBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceMultiviewPerViewAttributesPropertiesNVXBuilder<'a> {
    inner: PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceMultiviewPerViewAttributesPropertiesNVXBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX
{
}
impl<'a> ::std::ops::Deref for PhysicalDeviceMultiviewPerViewAttributesPropertiesNVXBuilder<'a> {
    type Target = PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceMultiviewPerViewAttributesPropertiesNVXBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceMultiviewPerViewAttributesPropertiesNVXBuilder<'a> {
    #[inline]
    pub fn per_view_position_all_components(
        mut self,
        per_view_position_all_components: bool,
    ) -> Self {
        self.inner.per_view_position_all_components = per_view_position_all_components.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInputAttachmentAspectReference.html>"]
pub struct InputAttachmentAspectReference {
    pub subpass: u32,
    pub input_attachment_index: u32,
    pub aspect_mask: ImageAspectFlags,
}
impl InputAttachmentAspectReference {
    pub fn builder<'a>() -> InputAttachmentAspectReferenceBuilder<'a> {
        InputAttachmentAspectReferenceBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct InputAttachmentAspectReferenceBuilder<'a> {
    inner: InputAttachmentAspectReference,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for InputAttachmentAspectReferenceBuilder<'a> {
    type Target = InputAttachmentAspectReference;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for InputAttachmentAspectReferenceBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> InputAttachmentAspectReferenceBuilder<'a> {
    #[inline]
    pub fn subpass(mut self, subpass: u32) -> Self {
        self.inner.subpass = subpass;
        self
    }
    #[inline]
    pub fn input_attachment_index(mut self, input_attachment_index: u32) -> Self {
        self.inner.input_attachment_index = input_attachment_index;
        self
    }
    #[inline]
    pub fn aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
        self.inner.aspect_mask = aspect_mask;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> InputAttachmentAspectReference {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassInputAttachmentAspectCreateInfo.html>"]
pub struct RenderPassInputAttachmentAspectCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub aspect_reference_count: u32,
    pub p_aspect_references: *const InputAttachmentAspectReference,
}
impl ::std::default::Default for RenderPassInputAttachmentAspectCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            aspect_reference_count: u32::default(),
            p_aspect_references: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for RenderPassInputAttachmentAspectCreateInfo {
    const STRUCTURE_TYPE: StructureType =
        StructureType::RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO;
}
impl RenderPassInputAttachmentAspectCreateInfo {
    pub fn builder<'a>() -> RenderPassInputAttachmentAspectCreateInfoBuilder<'a> {
        RenderPassInputAttachmentAspectCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RenderPassInputAttachmentAspectCreateInfoBuilder<'a> {
    inner: RenderPassInputAttachmentAspectCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsRenderPassCreateInfo for RenderPassInputAttachmentAspectCreateInfoBuilder<'_> {}
unsafe impl ExtendsRenderPassCreateInfo for RenderPassInputAttachmentAspectCreateInfo {}
impl<'a> ::std::ops::Deref for RenderPassInputAttachmentAspectCreateInfoBuilder<'a> {
    type Target = RenderPassInputAttachmentAspectCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RenderPassInputAttachmentAspectCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RenderPassInputAttachmentAspectCreateInfoBuilder<'a> {
    #[inline]
    pub fn aspect_references(
        mut self,
        aspect_references: &'a [InputAttachmentAspectReference],
    ) -> Self {
        self.inner.aspect_reference_count = aspect_references.len() as _;
        self.inner.p_aspect_references = aspect_references.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RenderPassInputAttachmentAspectCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSurfaceInfo2KHR.html>"]
pub struct PhysicalDeviceSurfaceInfo2KHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub surface: SurfaceKHR,
}
impl ::std::default::Default for PhysicalDeviceSurfaceInfo2KHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            surface: SurfaceKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceSurfaceInfo2KHR {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_SURFACE_INFO_2_KHR;
}
impl PhysicalDeviceSurfaceInfo2KHR {
    pub fn builder<'a>() -> PhysicalDeviceSurfaceInfo2KHRBuilder<'a> {
        PhysicalDeviceSurfaceInfo2KHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceSurfaceInfo2KHRBuilder<'a> {
    inner: PhysicalDeviceSurfaceInfo2KHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsPhysicalDeviceSurfaceInfo2KHR {}
impl<'a> ::std::ops::Deref for PhysicalDeviceSurfaceInfo2KHRBuilder<'a> {
    type Target = PhysicalDeviceSurfaceInfo2KHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceSurfaceInfo2KHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceSurfaceInfo2KHRBuilder<'a> {
    #[inline]
    pub fn surface(mut self, surface: SurfaceKHR) -> Self {
        self.inner.surface = surface;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPhysicalDeviceSurfaceInfo2KHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceSurfaceInfo2KHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilities2KHR.html>"]
pub struct SurfaceCapabilities2KHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub surface_capabilities: SurfaceCapabilitiesKHR,
}
impl ::std::default::Default for SurfaceCapabilities2KHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            surface_capabilities: SurfaceCapabilitiesKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for SurfaceCapabilities2KHR {
    const STRUCTURE_TYPE: StructureType = StructureType::SURFACE_CAPABILITIES_2_KHR;
}
impl SurfaceCapabilities2KHR {
    pub fn builder<'a>() -> SurfaceCapabilities2KHRBuilder<'a> {
        SurfaceCapabilities2KHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SurfaceCapabilities2KHRBuilder<'a> {
    inner: SurfaceCapabilities2KHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsSurfaceCapabilities2KHR {}
impl<'a> ::std::ops::Deref for SurfaceCapabilities2KHRBuilder<'a> {
    type Target = SurfaceCapabilities2KHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SurfaceCapabilities2KHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SurfaceCapabilities2KHRBuilder<'a> {
    #[inline]
    pub fn surface_capabilities(mut self, surface_capabilities: SurfaceCapabilitiesKHR) -> Self {
        self.inner.surface_capabilities = surface_capabilities;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsSurfaceCapabilities2KHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SurfaceCapabilities2KHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceFormat2KHR.html>"]
pub struct SurfaceFormat2KHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub surface_format: SurfaceFormatKHR,
}
impl ::std::default::Default for SurfaceFormat2KHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            surface_format: SurfaceFormatKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for SurfaceFormat2KHR {
    const STRUCTURE_TYPE: StructureType = StructureType::SURFACE_FORMAT_2_KHR;
}
impl SurfaceFormat2KHR {
    pub fn builder<'a>() -> SurfaceFormat2KHRBuilder<'a> {
        SurfaceFormat2KHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SurfaceFormat2KHRBuilder<'a> {
    inner: SurfaceFormat2KHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsSurfaceFormat2KHR {}
impl<'a> ::std::ops::Deref for SurfaceFormat2KHRBuilder<'a> {
    type Target = SurfaceFormat2KHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SurfaceFormat2KHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SurfaceFormat2KHRBuilder<'a> {
    #[inline]
    pub fn surface_format(mut self, surface_format: SurfaceFormatKHR) -> Self {
        self.inner.surface_format = surface_format;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsSurfaceFormat2KHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SurfaceFormat2KHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayProperties2KHR.html>"]
pub struct DisplayProperties2KHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub display_properties: DisplayPropertiesKHR,
}
impl ::std::default::Default for DisplayProperties2KHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            display_properties: DisplayPropertiesKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for DisplayProperties2KHR {
    const STRUCTURE_TYPE: StructureType = StructureType::DISPLAY_PROPERTIES_2_KHR;
}
impl DisplayProperties2KHR {
    pub fn builder<'a>() -> DisplayProperties2KHRBuilder<'a> {
        DisplayProperties2KHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DisplayProperties2KHRBuilder<'a> {
    inner: DisplayProperties2KHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DisplayProperties2KHRBuilder<'a> {
    type Target = DisplayProperties2KHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DisplayProperties2KHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DisplayProperties2KHRBuilder<'a> {
    #[inline]
    pub fn display_properties(mut self, display_properties: DisplayPropertiesKHR) -> Self {
        self.inner.display_properties = display_properties;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DisplayProperties2KHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlaneProperties2KHR.html>"]
pub struct DisplayPlaneProperties2KHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub display_plane_properties: DisplayPlanePropertiesKHR,
}
impl ::std::default::Default for DisplayPlaneProperties2KHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            display_plane_properties: DisplayPlanePropertiesKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for DisplayPlaneProperties2KHR {
    const STRUCTURE_TYPE: StructureType = StructureType::DISPLAY_PLANE_PROPERTIES_2_KHR;
}
impl DisplayPlaneProperties2KHR {
    pub fn builder<'a>() -> DisplayPlaneProperties2KHRBuilder<'a> {
        DisplayPlaneProperties2KHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DisplayPlaneProperties2KHRBuilder<'a> {
    inner: DisplayPlaneProperties2KHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DisplayPlaneProperties2KHRBuilder<'a> {
    type Target = DisplayPlaneProperties2KHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DisplayPlaneProperties2KHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DisplayPlaneProperties2KHRBuilder<'a> {
    #[inline]
    pub fn display_plane_properties(
        mut self,
        display_plane_properties: DisplayPlanePropertiesKHR,
    ) -> Self {
        self.inner.display_plane_properties = display_plane_properties;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DisplayPlaneProperties2KHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModeProperties2KHR.html>"]
pub struct DisplayModeProperties2KHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub display_mode_properties: DisplayModePropertiesKHR,
}
impl ::std::default::Default for DisplayModeProperties2KHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            display_mode_properties: DisplayModePropertiesKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for DisplayModeProperties2KHR {
    const STRUCTURE_TYPE: StructureType = StructureType::DISPLAY_MODE_PROPERTIES_2_KHR;
}
impl DisplayModeProperties2KHR {
    pub fn builder<'a>() -> DisplayModeProperties2KHRBuilder<'a> {
        DisplayModeProperties2KHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DisplayModeProperties2KHRBuilder<'a> {
    inner: DisplayModeProperties2KHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DisplayModeProperties2KHRBuilder<'a> {
    type Target = DisplayModeProperties2KHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DisplayModeProperties2KHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DisplayModeProperties2KHRBuilder<'a> {
    #[inline]
    pub fn display_mode_properties(
        mut self,
        display_mode_properties: DisplayModePropertiesKHR,
    ) -> Self {
        self.inner.display_mode_properties = display_mode_properties;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DisplayModeProperties2KHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlaneInfo2KHR.html>"]
pub struct DisplayPlaneInfo2KHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub mode: DisplayModeKHR,
    pub plane_index: u32,
}
impl ::std::default::Default for DisplayPlaneInfo2KHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            mode: DisplayModeKHR::default(),
            plane_index: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for DisplayPlaneInfo2KHR {
    const STRUCTURE_TYPE: StructureType = StructureType::DISPLAY_PLANE_INFO_2_KHR;
}
impl DisplayPlaneInfo2KHR {
    pub fn builder<'a>() -> DisplayPlaneInfo2KHRBuilder<'a> {
        DisplayPlaneInfo2KHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DisplayPlaneInfo2KHRBuilder<'a> {
    inner: DisplayPlaneInfo2KHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DisplayPlaneInfo2KHRBuilder<'a> {
    type Target = DisplayPlaneInfo2KHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DisplayPlaneInfo2KHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DisplayPlaneInfo2KHRBuilder<'a> {
    #[inline]
    pub fn mode(mut self, mode: DisplayModeKHR) -> Self {
        self.inner.mode = mode;
        self
    }
    #[inline]
    pub fn plane_index(mut self, plane_index: u32) -> Self {
        self.inner.plane_index = plane_index;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DisplayPlaneInfo2KHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlaneCapabilities2KHR.html>"]
pub struct DisplayPlaneCapabilities2KHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub capabilities: DisplayPlaneCapabilitiesKHR,
}
impl ::std::default::Default for DisplayPlaneCapabilities2KHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            capabilities: DisplayPlaneCapabilitiesKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for DisplayPlaneCapabilities2KHR {
    const STRUCTURE_TYPE: StructureType = StructureType::DISPLAY_PLANE_CAPABILITIES_2_KHR;
}
impl DisplayPlaneCapabilities2KHR {
    pub fn builder<'a>() -> DisplayPlaneCapabilities2KHRBuilder<'a> {
        DisplayPlaneCapabilities2KHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DisplayPlaneCapabilities2KHRBuilder<'a> {
    inner: DisplayPlaneCapabilities2KHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DisplayPlaneCapabilities2KHRBuilder<'a> {
    type Target = DisplayPlaneCapabilities2KHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DisplayPlaneCapabilities2KHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DisplayPlaneCapabilities2KHRBuilder<'a> {
    #[inline]
    pub fn capabilities(mut self, capabilities: DisplayPlaneCapabilitiesKHR) -> Self {
        self.inner.capabilities = capabilities;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DisplayPlaneCapabilities2KHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSharedPresentSurfaceCapabilitiesKHR.html>"]
pub struct SharedPresentSurfaceCapabilitiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shared_present_supported_usage_flags: ImageUsageFlags,
}
impl ::std::default::Default for SharedPresentSurfaceCapabilitiesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shared_present_supported_usage_flags: ImageUsageFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for SharedPresentSurfaceCapabilitiesKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::SHARED_PRESENT_SURFACE_CAPABILITIES_KHR;
}
impl SharedPresentSurfaceCapabilitiesKHR {
    pub fn builder<'a>() -> SharedPresentSurfaceCapabilitiesKHRBuilder<'a> {
        SharedPresentSurfaceCapabilitiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SharedPresentSurfaceCapabilitiesKHRBuilder<'a> {
    inner: SharedPresentSurfaceCapabilitiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSurfaceCapabilities2KHR for SharedPresentSurfaceCapabilitiesKHRBuilder<'_> {}
unsafe impl ExtendsSurfaceCapabilities2KHR for SharedPresentSurfaceCapabilitiesKHR {}
impl<'a> ::std::ops::Deref for SharedPresentSurfaceCapabilitiesKHRBuilder<'a> {
    type Target = SharedPresentSurfaceCapabilitiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SharedPresentSurfaceCapabilitiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SharedPresentSurfaceCapabilitiesKHRBuilder<'a> {
    #[inline]
    pub fn shared_present_supported_usage_flags(
        mut self,
        shared_present_supported_usage_flags: ImageUsageFlags,
    ) -> Self {
        self.inner.shared_present_supported_usage_flags = shared_present_supported_usage_flags;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SharedPresentSurfaceCapabilitiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice16BitStorageFeatures.html>"]
pub struct PhysicalDevice16BitStorageFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub storage_buffer16_bit_access: Bool32,
    pub uniform_and_storage_buffer16_bit_access: Bool32,
    pub storage_push_constant16: Bool32,
    pub storage_input_output16: Bool32,
}
impl ::std::default::Default for PhysicalDevice16BitStorageFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            storage_buffer16_bit_access: Bool32::default(),
            uniform_and_storage_buffer16_bit_access: Bool32::default(),
            storage_push_constant16: Bool32::default(),
            storage_input_output16: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevice16BitStorageFeatures {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
}
impl PhysicalDevice16BitStorageFeatures {
    pub fn builder<'a>() -> PhysicalDevice16BitStorageFeaturesBuilder<'a> {
        PhysicalDevice16BitStorageFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevice16BitStorageFeaturesBuilder<'a> {
    inner: PhysicalDevice16BitStorageFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevice16BitStorageFeaturesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevice16BitStorageFeatures {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevice16BitStorageFeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevice16BitStorageFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDevice16BitStorageFeaturesBuilder<'a> {
    type Target = PhysicalDevice16BitStorageFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevice16BitStorageFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevice16BitStorageFeaturesBuilder<'a> {
    #[inline]
    pub fn storage_buffer16_bit_access(mut self, storage_buffer16_bit_access: bool) -> Self {
        self.inner.storage_buffer16_bit_access = storage_buffer16_bit_access.into();
        self
    }
    #[inline]
    pub fn uniform_and_storage_buffer16_bit_access(
        mut self,
        uniform_and_storage_buffer16_bit_access: bool,
    ) -> Self {
        self.inner.uniform_and_storage_buffer16_bit_access =
            uniform_and_storage_buffer16_bit_access.into();
        self
    }
    #[inline]
    pub fn storage_push_constant16(mut self, storage_push_constant16: bool) -> Self {
        self.inner.storage_push_constant16 = storage_push_constant16.into();
        self
    }
    #[inline]
    pub fn storage_input_output16(mut self, storage_input_output16: bool) -> Self {
        self.inner.storage_input_output16 = storage_input_output16.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevice16BitStorageFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubgroupProperties.html>"]
pub struct PhysicalDeviceSubgroupProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub subgroup_size: u32,
    pub supported_stages: ShaderStageFlags,
    pub supported_operations: SubgroupFeatureFlags,
    pub quad_operations_in_all_stages: Bool32,
}
impl ::std::default::Default for PhysicalDeviceSubgroupProperties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            subgroup_size: u32::default(),
            supported_stages: ShaderStageFlags::default(),
            supported_operations: SubgroupFeatureFlags::default(),
            quad_operations_in_all_stages: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceSubgroupProperties {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_SUBGROUP_PROPERTIES;
}
impl PhysicalDeviceSubgroupProperties {
    pub fn builder<'a>() -> PhysicalDeviceSubgroupPropertiesBuilder<'a> {
        PhysicalDeviceSubgroupPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceSubgroupPropertiesBuilder<'a> {
    inner: PhysicalDeviceSubgroupProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceSubgroupPropertiesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceSubgroupProperties {}
impl<'a> ::std::ops::Deref for PhysicalDeviceSubgroupPropertiesBuilder<'a> {
    type Target = PhysicalDeviceSubgroupProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceSubgroupPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceSubgroupPropertiesBuilder<'a> {
    #[inline]
    pub fn subgroup_size(mut self, subgroup_size: u32) -> Self {
        self.inner.subgroup_size = subgroup_size;
        self
    }
    #[inline]
    pub fn supported_stages(mut self, supported_stages: ShaderStageFlags) -> Self {
        self.inner.supported_stages = supported_stages;
        self
    }
    #[inline]
    pub fn supported_operations(mut self, supported_operations: SubgroupFeatureFlags) -> Self {
        self.inner.supported_operations = supported_operations;
        self
    }
    #[inline]
    pub fn quad_operations_in_all_stages(mut self, quad_operations_in_all_stages: bool) -> Self {
        self.inner.quad_operations_in_all_stages = quad_operations_in_all_stages.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceSubgroupProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.html>"]
pub struct PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_subgroup_extended_types: Bool32,
}
impl ::std::default::Default for PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_subgroup_extended_types: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
}
impl PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
    pub fn builder<'a>() -> PhysicalDeviceShaderSubgroupExtendedTypesFeaturesBuilder<'a> {
        PhysicalDeviceShaderSubgroupExtendedTypesFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderSubgroupExtendedTypesFeaturesBuilder<'a> {
    inner: PhysicalDeviceShaderSubgroupExtendedTypesFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceShaderSubgroupExtendedTypesFeaturesBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderSubgroupExtendedTypesFeatures {}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceShaderSubgroupExtendedTypesFeaturesBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderSubgroupExtendedTypesFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderSubgroupExtendedTypesFeaturesBuilder<'a> {
    type Target = PhysicalDeviceShaderSubgroupExtendedTypesFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderSubgroupExtendedTypesFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderSubgroupExtendedTypesFeaturesBuilder<'a> {
    #[inline]
    pub fn shader_subgroup_extended_types(mut self, shader_subgroup_extended_types: bool) -> Self {
        self.inner.shader_subgroup_extended_types = shader_subgroup_extended_types.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferMemoryRequirementsInfo2.html>"]
pub struct BufferMemoryRequirementsInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub buffer: Buffer,
}
impl ::std::default::Default for BufferMemoryRequirementsInfo2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            buffer: Buffer::default(),
        }
    }
}
unsafe impl TaggedStructure for BufferMemoryRequirementsInfo2 {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_MEMORY_REQUIREMENTS_INFO_2;
}
impl BufferMemoryRequirementsInfo2 {
    pub fn builder<'a>() -> BufferMemoryRequirementsInfo2Builder<'a> {
        BufferMemoryRequirementsInfo2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BufferMemoryRequirementsInfo2Builder<'a> {
    inner: BufferMemoryRequirementsInfo2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for BufferMemoryRequirementsInfo2Builder<'a> {
    type Target = BufferMemoryRequirementsInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BufferMemoryRequirementsInfo2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BufferMemoryRequirementsInfo2Builder<'a> {
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BufferMemoryRequirementsInfo2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceBufferMemoryRequirements.html>"]
pub struct DeviceBufferMemoryRequirements {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_create_info: *const BufferCreateInfo,
}
impl ::std::default::Default for DeviceBufferMemoryRequirements {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_create_info: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for DeviceBufferMemoryRequirements {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_BUFFER_MEMORY_REQUIREMENTS;
}
impl DeviceBufferMemoryRequirements {
    pub fn builder<'a>() -> DeviceBufferMemoryRequirementsBuilder<'a> {
        DeviceBufferMemoryRequirementsBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceBufferMemoryRequirementsBuilder<'a> {
    inner: DeviceBufferMemoryRequirements,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DeviceBufferMemoryRequirementsBuilder<'a> {
    type Target = DeviceBufferMemoryRequirements;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceBufferMemoryRequirementsBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceBufferMemoryRequirementsBuilder<'a> {
    #[inline]
    pub fn create_info(mut self, create_info: &'a BufferCreateInfo) -> Self {
        self.inner.p_create_info = create_info;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceBufferMemoryRequirements {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageMemoryRequirementsInfo2.html>"]
pub struct ImageMemoryRequirementsInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image: Image,
}
impl ::std::default::Default for ImageMemoryRequirementsInfo2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image: Image::default(),
        }
    }
}
unsafe impl TaggedStructure for ImageMemoryRequirementsInfo2 {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_MEMORY_REQUIREMENTS_INFO_2;
}
impl ImageMemoryRequirementsInfo2 {
    pub fn builder<'a>() -> ImageMemoryRequirementsInfo2Builder<'a> {
        ImageMemoryRequirementsInfo2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageMemoryRequirementsInfo2Builder<'a> {
    inner: ImageMemoryRequirementsInfo2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsImageMemoryRequirementsInfo2 {}
impl<'a> ::std::ops::Deref for ImageMemoryRequirementsInfo2Builder<'a> {
    type Target = ImageMemoryRequirementsInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageMemoryRequirementsInfo2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageMemoryRequirementsInfo2Builder<'a> {
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.inner.image = image;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsImageMemoryRequirementsInfo2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageMemoryRequirementsInfo2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSparseMemoryRequirementsInfo2.html>"]
pub struct ImageSparseMemoryRequirementsInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image: Image,
}
impl ::std::default::Default for ImageSparseMemoryRequirementsInfo2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image: Image::default(),
        }
    }
}
unsafe impl TaggedStructure for ImageSparseMemoryRequirementsInfo2 {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2;
}
impl ImageSparseMemoryRequirementsInfo2 {
    pub fn builder<'a>() -> ImageSparseMemoryRequirementsInfo2Builder<'a> {
        ImageSparseMemoryRequirementsInfo2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageSparseMemoryRequirementsInfo2Builder<'a> {
    inner: ImageSparseMemoryRequirementsInfo2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ImageSparseMemoryRequirementsInfo2Builder<'a> {
    type Target = ImageSparseMemoryRequirementsInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageSparseMemoryRequirementsInfo2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageSparseMemoryRequirementsInfo2Builder<'a> {
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.inner.image = image;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageSparseMemoryRequirementsInfo2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceImageMemoryRequirements.html>"]
pub struct DeviceImageMemoryRequirements {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_create_info: *const ImageCreateInfo,
    pub plane_aspect: ImageAspectFlags,
}
impl ::std::default::Default for DeviceImageMemoryRequirements {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_create_info: ::std::ptr::null(),
            plane_aspect: ImageAspectFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for DeviceImageMemoryRequirements {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_IMAGE_MEMORY_REQUIREMENTS;
}
impl DeviceImageMemoryRequirements {
    pub fn builder<'a>() -> DeviceImageMemoryRequirementsBuilder<'a> {
        DeviceImageMemoryRequirementsBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceImageMemoryRequirementsBuilder<'a> {
    inner: DeviceImageMemoryRequirements,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DeviceImageMemoryRequirementsBuilder<'a> {
    type Target = DeviceImageMemoryRequirements;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceImageMemoryRequirementsBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceImageMemoryRequirementsBuilder<'a> {
    #[inline]
    pub fn create_info(mut self, create_info: &'a ImageCreateInfo) -> Self {
        self.inner.p_create_info = create_info;
        self
    }
    #[inline]
    pub fn plane_aspect(mut self, plane_aspect: ImageAspectFlags) -> Self {
        self.inner.plane_aspect = plane_aspect;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceImageMemoryRequirements {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryRequirements2.html>"]
pub struct MemoryRequirements2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_requirements: MemoryRequirements,
}
impl ::std::default::Default for MemoryRequirements2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            memory_requirements: MemoryRequirements::default(),
        }
    }
}
unsafe impl TaggedStructure for MemoryRequirements2 {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_REQUIREMENTS_2;
}
impl MemoryRequirements2 {
    pub fn builder<'a>() -> MemoryRequirements2Builder<'a> {
        MemoryRequirements2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MemoryRequirements2Builder<'a> {
    inner: MemoryRequirements2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsMemoryRequirements2 {}
impl<'a> ::std::ops::Deref for MemoryRequirements2Builder<'a> {
    type Target = MemoryRequirements2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MemoryRequirements2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MemoryRequirements2Builder<'a> {
    #[inline]
    pub fn memory_requirements(mut self, memory_requirements: MemoryRequirements) -> Self {
        self.inner.memory_requirements = memory_requirements;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsMemoryRequirements2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MemoryRequirements2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageMemoryRequirements2.html>"]
pub struct SparseImageMemoryRequirements2 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_requirements: SparseImageMemoryRequirements,
}
impl ::std::default::Default for SparseImageMemoryRequirements2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            memory_requirements: SparseImageMemoryRequirements::default(),
        }
    }
}
unsafe impl TaggedStructure for SparseImageMemoryRequirements2 {
    const STRUCTURE_TYPE: StructureType = StructureType::SPARSE_IMAGE_MEMORY_REQUIREMENTS_2;
}
impl SparseImageMemoryRequirements2 {
    pub fn builder<'a>() -> SparseImageMemoryRequirements2Builder<'a> {
        SparseImageMemoryRequirements2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SparseImageMemoryRequirements2Builder<'a> {
    inner: SparseImageMemoryRequirements2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SparseImageMemoryRequirements2Builder<'a> {
    type Target = SparseImageMemoryRequirements2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SparseImageMemoryRequirements2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SparseImageMemoryRequirements2Builder<'a> {
    #[inline]
    pub fn memory_requirements(
        mut self,
        memory_requirements: SparseImageMemoryRequirements,
    ) -> Self {
        self.inner.memory_requirements = memory_requirements;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SparseImageMemoryRequirements2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePointClippingProperties.html>"]
pub struct PhysicalDevicePointClippingProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub point_clipping_behavior: PointClippingBehavior,
}
impl ::std::default::Default for PhysicalDevicePointClippingProperties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            point_clipping_behavior: PointClippingBehavior::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevicePointClippingProperties {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;
}
impl PhysicalDevicePointClippingProperties {
    pub fn builder<'a>() -> PhysicalDevicePointClippingPropertiesBuilder<'a> {
        PhysicalDevicePointClippingPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevicePointClippingPropertiesBuilder<'a> {
    inner: PhysicalDevicePointClippingProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDevicePointClippingPropertiesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDevicePointClippingProperties {}
impl<'a> ::std::ops::Deref for PhysicalDevicePointClippingPropertiesBuilder<'a> {
    type Target = PhysicalDevicePointClippingProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevicePointClippingPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevicePointClippingPropertiesBuilder<'a> {
    #[inline]
    pub fn point_clipping_behavior(
        mut self,
        point_clipping_behavior: PointClippingBehavior,
    ) -> Self {
        self.inner.point_clipping_behavior = point_clipping_behavior;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevicePointClippingProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryDedicatedRequirements.html>"]
pub struct MemoryDedicatedRequirements {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub prefers_dedicated_allocation: Bool32,
    pub requires_dedicated_allocation: Bool32,
}
impl ::std::default::Default for MemoryDedicatedRequirements {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            prefers_dedicated_allocation: Bool32::default(),
            requires_dedicated_allocation: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for MemoryDedicatedRequirements {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_DEDICATED_REQUIREMENTS;
}
impl MemoryDedicatedRequirements {
    pub fn builder<'a>() -> MemoryDedicatedRequirementsBuilder<'a> {
        MemoryDedicatedRequirementsBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MemoryDedicatedRequirementsBuilder<'a> {
    inner: MemoryDedicatedRequirements,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsMemoryRequirements2 for MemoryDedicatedRequirementsBuilder<'_> {}
unsafe impl ExtendsMemoryRequirements2 for MemoryDedicatedRequirements {}
impl<'a> ::std::ops::Deref for MemoryDedicatedRequirementsBuilder<'a> {
    type Target = MemoryDedicatedRequirements;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MemoryDedicatedRequirementsBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MemoryDedicatedRequirementsBuilder<'a> {
    #[inline]
    pub fn prefers_dedicated_allocation(mut self, prefers_dedicated_allocation: bool) -> Self {
        self.inner.prefers_dedicated_allocation = prefers_dedicated_allocation.into();
        self
    }
    #[inline]
    pub fn requires_dedicated_allocation(mut self, requires_dedicated_allocation: bool) -> Self {
        self.inner.requires_dedicated_allocation = requires_dedicated_allocation.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MemoryDedicatedRequirements {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryDedicatedAllocateInfo.html>"]
pub struct MemoryDedicatedAllocateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image: Image,
    pub buffer: Buffer,
}
impl ::std::default::Default for MemoryDedicatedAllocateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image: Image::default(),
            buffer: Buffer::default(),
        }
    }
}
unsafe impl TaggedStructure for MemoryDedicatedAllocateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_DEDICATED_ALLOCATE_INFO;
}
impl MemoryDedicatedAllocateInfo {
    pub fn builder<'a>() -> MemoryDedicatedAllocateInfoBuilder<'a> {
        MemoryDedicatedAllocateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MemoryDedicatedAllocateInfoBuilder<'a> {
    inner: MemoryDedicatedAllocateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsMemoryAllocateInfo for MemoryDedicatedAllocateInfoBuilder<'_> {}
unsafe impl ExtendsMemoryAllocateInfo for MemoryDedicatedAllocateInfo {}
impl<'a> ::std::ops::Deref for MemoryDedicatedAllocateInfoBuilder<'a> {
    type Target = MemoryDedicatedAllocateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MemoryDedicatedAllocateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MemoryDedicatedAllocateInfoBuilder<'a> {
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.inner.image = image;
        self
    }
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MemoryDedicatedAllocateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewUsageCreateInfo.html>"]
pub struct ImageViewUsageCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub usage: ImageUsageFlags,
}
impl ::std::default::Default for ImageViewUsageCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            usage: ImageUsageFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for ImageViewUsageCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_VIEW_USAGE_CREATE_INFO;
}
impl ImageViewUsageCreateInfo {
    pub fn builder<'a>() -> ImageViewUsageCreateInfoBuilder<'a> {
        ImageViewUsageCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageViewUsageCreateInfoBuilder<'a> {
    inner: ImageViewUsageCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageViewCreateInfo for ImageViewUsageCreateInfoBuilder<'_> {}
unsafe impl ExtendsImageViewCreateInfo for ImageViewUsageCreateInfo {}
impl<'a> ::std::ops::Deref for ImageViewUsageCreateInfoBuilder<'a> {
    type Target = ImageViewUsageCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageViewUsageCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageViewUsageCreateInfoBuilder<'a> {
    #[inline]
    pub fn usage(mut self, usage: ImageUsageFlags) -> Self {
        self.inner.usage = usage;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageViewUsageCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewSlicedCreateInfoEXT.html>"]
pub struct ImageViewSlicedCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub slice_offset: u32,
    pub slice_count: u32,
}
impl ::std::default::Default for ImageViewSlicedCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            slice_offset: u32::default(),
            slice_count: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for ImageViewSlicedCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_VIEW_SLICED_CREATE_INFO_EXT;
}
impl ImageViewSlicedCreateInfoEXT {
    pub fn builder<'a>() -> ImageViewSlicedCreateInfoEXTBuilder<'a> {
        ImageViewSlicedCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageViewSlicedCreateInfoEXTBuilder<'a> {
    inner: ImageViewSlicedCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageViewCreateInfo for ImageViewSlicedCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsImageViewCreateInfo for ImageViewSlicedCreateInfoEXT {}
impl<'a> ::std::ops::Deref for ImageViewSlicedCreateInfoEXTBuilder<'a> {
    type Target = ImageViewSlicedCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageViewSlicedCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageViewSlicedCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn slice_offset(mut self, slice_offset: u32) -> Self {
        self.inner.slice_offset = slice_offset;
        self
    }
    #[inline]
    pub fn slice_count(mut self, slice_count: u32) -> Self {
        self.inner.slice_count = slice_count;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageViewSlicedCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineTessellationDomainOriginStateCreateInfo.html>"]
pub struct PipelineTessellationDomainOriginStateCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub domain_origin: TessellationDomainOrigin,
}
impl ::std::default::Default for PipelineTessellationDomainOriginStateCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            domain_origin: TessellationDomainOrigin::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineTessellationDomainOriginStateCreateInfo {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO;
}
impl PipelineTessellationDomainOriginStateCreateInfo {
    pub fn builder<'a>() -> PipelineTessellationDomainOriginStateCreateInfoBuilder<'a> {
        PipelineTessellationDomainOriginStateCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineTessellationDomainOriginStateCreateInfoBuilder<'a> {
    inner: PipelineTessellationDomainOriginStateCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPipelineTessellationStateCreateInfo
    for PipelineTessellationDomainOriginStateCreateInfoBuilder<'_>
{
}
unsafe impl ExtendsPipelineTessellationStateCreateInfo
    for PipelineTessellationDomainOriginStateCreateInfo
{
}
impl<'a> ::std::ops::Deref for PipelineTessellationDomainOriginStateCreateInfoBuilder<'a> {
    type Target = PipelineTessellationDomainOriginStateCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineTessellationDomainOriginStateCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineTessellationDomainOriginStateCreateInfoBuilder<'a> {
    #[inline]
    pub fn domain_origin(mut self, domain_origin: TessellationDomainOrigin) -> Self {
        self.inner.domain_origin = domain_origin;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineTessellationDomainOriginStateCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerYcbcrConversionInfo.html>"]
pub struct SamplerYcbcrConversionInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub conversion: SamplerYcbcrConversion,
}
impl ::std::default::Default for SamplerYcbcrConversionInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            conversion: SamplerYcbcrConversion::default(),
        }
    }
}
unsafe impl TaggedStructure for SamplerYcbcrConversionInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::SAMPLER_YCBCR_CONVERSION_INFO;
}
impl SamplerYcbcrConversionInfo {
    pub fn builder<'a>() -> SamplerYcbcrConversionInfoBuilder<'a> {
        SamplerYcbcrConversionInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SamplerYcbcrConversionInfoBuilder<'a> {
    inner: SamplerYcbcrConversionInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSamplerCreateInfo for SamplerYcbcrConversionInfoBuilder<'_> {}
unsafe impl ExtendsSamplerCreateInfo for SamplerYcbcrConversionInfo {}
unsafe impl ExtendsImageViewCreateInfo for SamplerYcbcrConversionInfoBuilder<'_> {}
unsafe impl ExtendsImageViewCreateInfo for SamplerYcbcrConversionInfo {}
impl<'a> ::std::ops::Deref for SamplerYcbcrConversionInfoBuilder<'a> {
    type Target = SamplerYcbcrConversionInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SamplerYcbcrConversionInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SamplerYcbcrConversionInfoBuilder<'a> {
    #[inline]
    pub fn conversion(mut self, conversion: SamplerYcbcrConversion) -> Self {
        self.inner.conversion = conversion;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SamplerYcbcrConversionInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerYcbcrConversionCreateInfo.html>"]
pub struct SamplerYcbcrConversionCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub format: Format,
    pub ycbcr_model: SamplerYcbcrModelConversion,
    pub ycbcr_range: SamplerYcbcrRange,
    pub components: ComponentMapping,
    pub x_chroma_offset: ChromaLocation,
    pub y_chroma_offset: ChromaLocation,
    pub chroma_filter: Filter,
    pub force_explicit_reconstruction: Bool32,
}
impl ::std::default::Default for SamplerYcbcrConversionCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            format: Format::default(),
            ycbcr_model: SamplerYcbcrModelConversion::default(),
            ycbcr_range: SamplerYcbcrRange::default(),
            components: ComponentMapping::default(),
            x_chroma_offset: ChromaLocation::default(),
            y_chroma_offset: ChromaLocation::default(),
            chroma_filter: Filter::default(),
            force_explicit_reconstruction: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for SamplerYcbcrConversionCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::SAMPLER_YCBCR_CONVERSION_CREATE_INFO;
}
impl SamplerYcbcrConversionCreateInfo {
    pub fn builder<'a>() -> SamplerYcbcrConversionCreateInfoBuilder<'a> {
        SamplerYcbcrConversionCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SamplerYcbcrConversionCreateInfoBuilder<'a> {
    inner: SamplerYcbcrConversionCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsSamplerYcbcrConversionCreateInfo {}
impl<'a> ::std::ops::Deref for SamplerYcbcrConversionCreateInfoBuilder<'a> {
    type Target = SamplerYcbcrConversionCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SamplerYcbcrConversionCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SamplerYcbcrConversionCreateInfoBuilder<'a> {
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.inner.format = format;
        self
    }
    #[inline]
    pub fn ycbcr_model(mut self, ycbcr_model: SamplerYcbcrModelConversion) -> Self {
        self.inner.ycbcr_model = ycbcr_model;
        self
    }
    #[inline]
    pub fn ycbcr_range(mut self, ycbcr_range: SamplerYcbcrRange) -> Self {
        self.inner.ycbcr_range = ycbcr_range;
        self
    }
    #[inline]
    pub fn components(mut self, components: ComponentMapping) -> Self {
        self.inner.components = components;
        self
    }
    #[inline]
    pub fn x_chroma_offset(mut self, x_chroma_offset: ChromaLocation) -> Self {
        self.inner.x_chroma_offset = x_chroma_offset;
        self
    }
    #[inline]
    pub fn y_chroma_offset(mut self, y_chroma_offset: ChromaLocation) -> Self {
        self.inner.y_chroma_offset = y_chroma_offset;
        self
    }
    #[inline]
    pub fn chroma_filter(mut self, chroma_filter: Filter) -> Self {
        self.inner.chroma_filter = chroma_filter;
        self
    }
    #[inline]
    pub fn force_explicit_reconstruction(mut self, force_explicit_reconstruction: bool) -> Self {
        self.inner.force_explicit_reconstruction = force_explicit_reconstruction.into();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsSamplerYcbcrConversionCreateInfo>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SamplerYcbcrConversionCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindImagePlaneMemoryInfo.html>"]
pub struct BindImagePlaneMemoryInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub plane_aspect: ImageAspectFlags,
}
impl ::std::default::Default for BindImagePlaneMemoryInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            plane_aspect: ImageAspectFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for BindImagePlaneMemoryInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::BIND_IMAGE_PLANE_MEMORY_INFO;
}
impl BindImagePlaneMemoryInfo {
    pub fn builder<'a>() -> BindImagePlaneMemoryInfoBuilder<'a> {
        BindImagePlaneMemoryInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BindImagePlaneMemoryInfoBuilder<'a> {
    inner: BindImagePlaneMemoryInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsBindImageMemoryInfo for BindImagePlaneMemoryInfoBuilder<'_> {}
unsafe impl ExtendsBindImageMemoryInfo for BindImagePlaneMemoryInfo {}
impl<'a> ::std::ops::Deref for BindImagePlaneMemoryInfoBuilder<'a> {
    type Target = BindImagePlaneMemoryInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BindImagePlaneMemoryInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BindImagePlaneMemoryInfoBuilder<'a> {
    #[inline]
    pub fn plane_aspect(mut self, plane_aspect: ImageAspectFlags) -> Self {
        self.inner.plane_aspect = plane_aspect;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BindImagePlaneMemoryInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImagePlaneMemoryRequirementsInfo.html>"]
pub struct ImagePlaneMemoryRequirementsInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub plane_aspect: ImageAspectFlags,
}
impl ::std::default::Default for ImagePlaneMemoryRequirementsInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            plane_aspect: ImageAspectFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for ImagePlaneMemoryRequirementsInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO;
}
impl ImagePlaneMemoryRequirementsInfo {
    pub fn builder<'a>() -> ImagePlaneMemoryRequirementsInfoBuilder<'a> {
        ImagePlaneMemoryRequirementsInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImagePlaneMemoryRequirementsInfoBuilder<'a> {
    inner: ImagePlaneMemoryRequirementsInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageMemoryRequirementsInfo2 for ImagePlaneMemoryRequirementsInfoBuilder<'_> {}
unsafe impl ExtendsImageMemoryRequirementsInfo2 for ImagePlaneMemoryRequirementsInfo {}
impl<'a> ::std::ops::Deref for ImagePlaneMemoryRequirementsInfoBuilder<'a> {
    type Target = ImagePlaneMemoryRequirementsInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImagePlaneMemoryRequirementsInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImagePlaneMemoryRequirementsInfoBuilder<'a> {
    #[inline]
    pub fn plane_aspect(mut self, plane_aspect: ImageAspectFlags) -> Self {
        self.inner.plane_aspect = plane_aspect;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImagePlaneMemoryRequirementsInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSamplerYcbcrConversionFeatures.html>"]
pub struct PhysicalDeviceSamplerYcbcrConversionFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub sampler_ycbcr_conversion: Bool32,
}
impl ::std::default::Default for PhysicalDeviceSamplerYcbcrConversionFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            sampler_ycbcr_conversion: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceSamplerYcbcrConversionFeatures {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
}
impl PhysicalDeviceSamplerYcbcrConversionFeatures {
    pub fn builder<'a>() -> PhysicalDeviceSamplerYcbcrConversionFeaturesBuilder<'a> {
        PhysicalDeviceSamplerYcbcrConversionFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceSamplerYcbcrConversionFeaturesBuilder<'a> {
    inner: PhysicalDeviceSamplerYcbcrConversionFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceSamplerYcbcrConversionFeaturesBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceSamplerYcbcrConversionFeatures {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSamplerYcbcrConversionFeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSamplerYcbcrConversionFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDeviceSamplerYcbcrConversionFeaturesBuilder<'a> {
    type Target = PhysicalDeviceSamplerYcbcrConversionFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceSamplerYcbcrConversionFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceSamplerYcbcrConversionFeaturesBuilder<'a> {
    #[inline]
    pub fn sampler_ycbcr_conversion(mut self, sampler_ycbcr_conversion: bool) -> Self {
        self.inner.sampler_ycbcr_conversion = sampler_ycbcr_conversion.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceSamplerYcbcrConversionFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerYcbcrConversionImageFormatProperties.html>"]
pub struct SamplerYcbcrConversionImageFormatProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub combined_image_sampler_descriptor_count: u32,
}
impl ::std::default::Default for SamplerYcbcrConversionImageFormatProperties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            combined_image_sampler_descriptor_count: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for SamplerYcbcrConversionImageFormatProperties {
    const STRUCTURE_TYPE: StructureType =
        StructureType::SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES;
}
impl SamplerYcbcrConversionImageFormatProperties {
    pub fn builder<'a>() -> SamplerYcbcrConversionImageFormatPropertiesBuilder<'a> {
        SamplerYcbcrConversionImageFormatPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SamplerYcbcrConversionImageFormatPropertiesBuilder<'a> {
    inner: SamplerYcbcrConversionImageFormatProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageFormatProperties2
    for SamplerYcbcrConversionImageFormatPropertiesBuilder<'_>
{
}
unsafe impl ExtendsImageFormatProperties2 for SamplerYcbcrConversionImageFormatProperties {}
impl<'a> ::std::ops::Deref for SamplerYcbcrConversionImageFormatPropertiesBuilder<'a> {
    type Target = SamplerYcbcrConversionImageFormatProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SamplerYcbcrConversionImageFormatPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SamplerYcbcrConversionImageFormatPropertiesBuilder<'a> {
    #[inline]
    pub fn combined_image_sampler_descriptor_count(
        mut self,
        combined_image_sampler_descriptor_count: u32,
    ) -> Self {
        self.inner.combined_image_sampler_descriptor_count =
            combined_image_sampler_descriptor_count;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SamplerYcbcrConversionImageFormatProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkTextureLODGatherFormatPropertiesAMD.html>"]
pub struct TextureLODGatherFormatPropertiesAMD {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub supports_texture_gather_lod_bias_amd: Bool32,
}
impl ::std::default::Default for TextureLODGatherFormatPropertiesAMD {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            supports_texture_gather_lod_bias_amd: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for TextureLODGatherFormatPropertiesAMD {
    const STRUCTURE_TYPE: StructureType = StructureType::TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD;
}
impl TextureLODGatherFormatPropertiesAMD {
    pub fn builder<'a>() -> TextureLODGatherFormatPropertiesAMDBuilder<'a> {
        TextureLODGatherFormatPropertiesAMDBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct TextureLODGatherFormatPropertiesAMDBuilder<'a> {
    inner: TextureLODGatherFormatPropertiesAMD,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageFormatProperties2 for TextureLODGatherFormatPropertiesAMDBuilder<'_> {}
unsafe impl ExtendsImageFormatProperties2 for TextureLODGatherFormatPropertiesAMD {}
impl<'a> ::std::ops::Deref for TextureLODGatherFormatPropertiesAMDBuilder<'a> {
    type Target = TextureLODGatherFormatPropertiesAMD;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for TextureLODGatherFormatPropertiesAMDBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> TextureLODGatherFormatPropertiesAMDBuilder<'a> {
    #[inline]
    pub fn supports_texture_gather_lod_bias_amd(
        mut self,
        supports_texture_gather_lod_bias_amd: bool,
    ) -> Self {
        self.inner.supports_texture_gather_lod_bias_amd =
            supports_texture_gather_lod_bias_amd.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> TextureLODGatherFormatPropertiesAMD {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkConditionalRenderingBeginInfoEXT.html>"]
pub struct ConditionalRenderingBeginInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub buffer: Buffer,
    pub offset: DeviceSize,
    pub flags: ConditionalRenderingFlagsEXT,
}
impl ::std::default::Default for ConditionalRenderingBeginInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            buffer: Buffer::default(),
            offset: DeviceSize::default(),
            flags: ConditionalRenderingFlagsEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for ConditionalRenderingBeginInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::CONDITIONAL_RENDERING_BEGIN_INFO_EXT;
}
impl ConditionalRenderingBeginInfoEXT {
    pub fn builder<'a>() -> ConditionalRenderingBeginInfoEXTBuilder<'a> {
        ConditionalRenderingBeginInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ConditionalRenderingBeginInfoEXTBuilder<'a> {
    inner: ConditionalRenderingBeginInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ConditionalRenderingBeginInfoEXTBuilder<'a> {
    type Target = ConditionalRenderingBeginInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ConditionalRenderingBeginInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ConditionalRenderingBeginInfoEXTBuilder<'a> {
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: DeviceSize) -> Self {
        self.inner.offset = offset;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: ConditionalRenderingFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ConditionalRenderingBeginInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkProtectedSubmitInfo.html>"]
pub struct ProtectedSubmitInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub protected_submit: Bool32,
}
impl ::std::default::Default for ProtectedSubmitInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            protected_submit: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for ProtectedSubmitInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::PROTECTED_SUBMIT_INFO;
}
impl ProtectedSubmitInfo {
    pub fn builder<'a>() -> ProtectedSubmitInfoBuilder<'a> {
        ProtectedSubmitInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ProtectedSubmitInfoBuilder<'a> {
    inner: ProtectedSubmitInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSubmitInfo for ProtectedSubmitInfoBuilder<'_> {}
unsafe impl ExtendsSubmitInfo for ProtectedSubmitInfo {}
impl<'a> ::std::ops::Deref for ProtectedSubmitInfoBuilder<'a> {
    type Target = ProtectedSubmitInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ProtectedSubmitInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ProtectedSubmitInfoBuilder<'a> {
    #[inline]
    pub fn protected_submit(mut self, protected_submit: bool) -> Self {
        self.inner.protected_submit = protected_submit.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ProtectedSubmitInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProtectedMemoryFeatures.html>"]
pub struct PhysicalDeviceProtectedMemoryFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub protected_memory: Bool32,
}
impl ::std::default::Default for PhysicalDeviceProtectedMemoryFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            protected_memory: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceProtectedMemoryFeatures {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES;
}
impl PhysicalDeviceProtectedMemoryFeatures {
    pub fn builder<'a>() -> PhysicalDeviceProtectedMemoryFeaturesBuilder<'a> {
        PhysicalDeviceProtectedMemoryFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceProtectedMemoryFeaturesBuilder<'a> {
    inner: PhysicalDeviceProtectedMemoryFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceProtectedMemoryFeaturesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceProtectedMemoryFeatures {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceProtectedMemoryFeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceProtectedMemoryFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDeviceProtectedMemoryFeaturesBuilder<'a> {
    type Target = PhysicalDeviceProtectedMemoryFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceProtectedMemoryFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceProtectedMemoryFeaturesBuilder<'a> {
    #[inline]
    pub fn protected_memory(mut self, protected_memory: bool) -> Self {
        self.inner.protected_memory = protected_memory.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceProtectedMemoryFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProtectedMemoryProperties.html>"]
pub struct PhysicalDeviceProtectedMemoryProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub protected_no_fault: Bool32,
}
impl ::std::default::Default for PhysicalDeviceProtectedMemoryProperties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            protected_no_fault: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceProtectedMemoryProperties {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES;
}
impl PhysicalDeviceProtectedMemoryProperties {
    pub fn builder<'a>() -> PhysicalDeviceProtectedMemoryPropertiesBuilder<'a> {
        PhysicalDeviceProtectedMemoryPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceProtectedMemoryPropertiesBuilder<'a> {
    inner: PhysicalDeviceProtectedMemoryProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceProtectedMemoryPropertiesBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceProtectedMemoryProperties {}
impl<'a> ::std::ops::Deref for PhysicalDeviceProtectedMemoryPropertiesBuilder<'a> {
    type Target = PhysicalDeviceProtectedMemoryProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceProtectedMemoryPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceProtectedMemoryPropertiesBuilder<'a> {
    #[inline]
    pub fn protected_no_fault(mut self, protected_no_fault: bool) -> Self {
        self.inner.protected_no_fault = protected_no_fault.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceProtectedMemoryProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueInfo2.html>"]
pub struct DeviceQueueInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DeviceQueueCreateFlags,
    pub queue_family_index: u32,
    pub queue_index: u32,
}
impl ::std::default::Default for DeviceQueueInfo2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DeviceQueueCreateFlags::default(),
            queue_family_index: u32::default(),
            queue_index: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for DeviceQueueInfo2 {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_QUEUE_INFO_2;
}
impl DeviceQueueInfo2 {
    pub fn builder<'a>() -> DeviceQueueInfo2Builder<'a> {
        DeviceQueueInfo2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceQueueInfo2Builder<'a> {
    inner: DeviceQueueInfo2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DeviceQueueInfo2Builder<'a> {
    type Target = DeviceQueueInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceQueueInfo2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceQueueInfo2Builder<'a> {
    #[inline]
    pub fn flags(mut self, flags: DeviceQueueCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn queue_family_index(mut self, queue_family_index: u32) -> Self {
        self.inner.queue_family_index = queue_family_index;
        self
    }
    #[inline]
    pub fn queue_index(mut self, queue_index: u32) -> Self {
        self.inner.queue_index = queue_index;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceQueueInfo2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCoverageToColorStateCreateInfoNV.html>"]
pub struct PipelineCoverageToColorStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineCoverageToColorStateCreateFlagsNV,
    pub coverage_to_color_enable: Bool32,
    pub coverage_to_color_location: u32,
}
impl ::std::default::Default for PipelineCoverageToColorStateCreateInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineCoverageToColorStateCreateFlagsNV::default(),
            coverage_to_color_enable: Bool32::default(),
            coverage_to_color_location: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineCoverageToColorStateCreateInfoNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV;
}
impl PipelineCoverageToColorStateCreateInfoNV {
    pub fn builder<'a>() -> PipelineCoverageToColorStateCreateInfoNVBuilder<'a> {
        PipelineCoverageToColorStateCreateInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineCoverageToColorStateCreateInfoNVBuilder<'a> {
    inner: PipelineCoverageToColorStateCreateInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPipelineMultisampleStateCreateInfo
    for PipelineCoverageToColorStateCreateInfoNVBuilder<'_>
{
}
unsafe impl ExtendsPipelineMultisampleStateCreateInfo for PipelineCoverageToColorStateCreateInfoNV {}
impl<'a> ::std::ops::Deref for PipelineCoverageToColorStateCreateInfoNVBuilder<'a> {
    type Target = PipelineCoverageToColorStateCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineCoverageToColorStateCreateInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineCoverageToColorStateCreateInfoNVBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineCoverageToColorStateCreateFlagsNV) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn coverage_to_color_enable(mut self, coverage_to_color_enable: bool) -> Self {
        self.inner.coverage_to_color_enable = coverage_to_color_enable.into();
        self
    }
    #[inline]
    pub fn coverage_to_color_location(mut self, coverage_to_color_location: u32) -> Self {
        self.inner.coverage_to_color_location = coverage_to_color_location;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineCoverageToColorStateCreateInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSamplerFilterMinmaxProperties.html>"]
pub struct PhysicalDeviceSamplerFilterMinmaxProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub filter_minmax_single_component_formats: Bool32,
    pub filter_minmax_image_component_mapping: Bool32,
}
impl ::std::default::Default for PhysicalDeviceSamplerFilterMinmaxProperties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            filter_minmax_single_component_formats: Bool32::default(),
            filter_minmax_image_component_mapping: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceSamplerFilterMinmaxProperties {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES;
}
impl PhysicalDeviceSamplerFilterMinmaxProperties {
    pub fn builder<'a>() -> PhysicalDeviceSamplerFilterMinmaxPropertiesBuilder<'a> {
        PhysicalDeviceSamplerFilterMinmaxPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceSamplerFilterMinmaxPropertiesBuilder<'a> {
    inner: PhysicalDeviceSamplerFilterMinmaxProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceSamplerFilterMinmaxPropertiesBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceSamplerFilterMinmaxProperties {}
impl<'a> ::std::ops::Deref for PhysicalDeviceSamplerFilterMinmaxPropertiesBuilder<'a> {
    type Target = PhysicalDeviceSamplerFilterMinmaxProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceSamplerFilterMinmaxPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceSamplerFilterMinmaxPropertiesBuilder<'a> {
    #[inline]
    pub fn filter_minmax_single_component_formats(
        mut self,
        filter_minmax_single_component_formats: bool,
    ) -> Self {
        self.inner.filter_minmax_single_component_formats =
            filter_minmax_single_component_formats.into();
        self
    }
    #[inline]
    pub fn filter_minmax_image_component_mapping(
        mut self,
        filter_minmax_image_component_mapping: bool,
    ) -> Self {
        self.inner.filter_minmax_image_component_mapping =
            filter_minmax_image_component_mapping.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceSamplerFilterMinmaxProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampleLocationEXT.html>"]
pub struct SampleLocationEXT {
    pub x: f32,
    pub y: f32,
}
impl SampleLocationEXT {
    pub fn builder<'a>() -> SampleLocationEXTBuilder<'a> {
        SampleLocationEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SampleLocationEXTBuilder<'a> {
    inner: SampleLocationEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SampleLocationEXTBuilder<'a> {
    type Target = SampleLocationEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SampleLocationEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SampleLocationEXTBuilder<'a> {
    #[inline]
    pub fn x(mut self, x: f32) -> Self {
        self.inner.x = x;
        self
    }
    #[inline]
    pub fn y(mut self, y: f32) -> Self {
        self.inner.y = y;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SampleLocationEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampleLocationsInfoEXT.html>"]
pub struct SampleLocationsInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub sample_locations_per_pixel: SampleCountFlags,
    pub sample_location_grid_size: Extent2D,
    pub sample_locations_count: u32,
    pub p_sample_locations: *const SampleLocationEXT,
}
impl ::std::default::Default for SampleLocationsInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            sample_locations_per_pixel: SampleCountFlags::default(),
            sample_location_grid_size: Extent2D::default(),
            sample_locations_count: u32::default(),
            p_sample_locations: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for SampleLocationsInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::SAMPLE_LOCATIONS_INFO_EXT;
}
impl SampleLocationsInfoEXT {
    pub fn builder<'a>() -> SampleLocationsInfoEXTBuilder<'a> {
        SampleLocationsInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SampleLocationsInfoEXTBuilder<'a> {
    inner: SampleLocationsInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageMemoryBarrier for SampleLocationsInfoEXTBuilder<'_> {}
unsafe impl ExtendsImageMemoryBarrier for SampleLocationsInfoEXT {}
unsafe impl ExtendsImageMemoryBarrier2 for SampleLocationsInfoEXTBuilder<'_> {}
unsafe impl ExtendsImageMemoryBarrier2 for SampleLocationsInfoEXT {}
impl<'a> ::std::ops::Deref for SampleLocationsInfoEXTBuilder<'a> {
    type Target = SampleLocationsInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SampleLocationsInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SampleLocationsInfoEXTBuilder<'a> {
    #[inline]
    pub fn sample_locations_per_pixel(
        mut self,
        sample_locations_per_pixel: SampleCountFlags,
    ) -> Self {
        self.inner.sample_locations_per_pixel = sample_locations_per_pixel;
        self
    }
    #[inline]
    pub fn sample_location_grid_size(mut self, sample_location_grid_size: Extent2D) -> Self {
        self.inner.sample_location_grid_size = sample_location_grid_size;
        self
    }
    #[inline]
    pub fn sample_locations(mut self, sample_locations: &'a [SampleLocationEXT]) -> Self {
        self.inner.sample_locations_count = sample_locations.len() as _;
        self.inner.p_sample_locations = sample_locations.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SampleLocationsInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentSampleLocationsEXT.html>"]
pub struct AttachmentSampleLocationsEXT {
    pub attachment_index: u32,
    pub sample_locations_info: SampleLocationsInfoEXT,
}
impl AttachmentSampleLocationsEXT {
    pub fn builder<'a>() -> AttachmentSampleLocationsEXTBuilder<'a> {
        AttachmentSampleLocationsEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AttachmentSampleLocationsEXTBuilder<'a> {
    inner: AttachmentSampleLocationsEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for AttachmentSampleLocationsEXTBuilder<'a> {
    type Target = AttachmentSampleLocationsEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AttachmentSampleLocationsEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AttachmentSampleLocationsEXTBuilder<'a> {
    #[inline]
    pub fn attachment_index(mut self, attachment_index: u32) -> Self {
        self.inner.attachment_index = attachment_index;
        self
    }
    #[inline]
    pub fn sample_locations_info(mut self, sample_locations_info: SampleLocationsInfoEXT) -> Self {
        self.inner.sample_locations_info = sample_locations_info;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AttachmentSampleLocationsEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassSampleLocationsEXT.html>"]
pub struct SubpassSampleLocationsEXT {
    pub subpass_index: u32,
    pub sample_locations_info: SampleLocationsInfoEXT,
}
impl SubpassSampleLocationsEXT {
    pub fn builder<'a>() -> SubpassSampleLocationsEXTBuilder<'a> {
        SubpassSampleLocationsEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SubpassSampleLocationsEXTBuilder<'a> {
    inner: SubpassSampleLocationsEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SubpassSampleLocationsEXTBuilder<'a> {
    type Target = SubpassSampleLocationsEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SubpassSampleLocationsEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SubpassSampleLocationsEXTBuilder<'a> {
    #[inline]
    pub fn subpass_index(mut self, subpass_index: u32) -> Self {
        self.inner.subpass_index = subpass_index;
        self
    }
    #[inline]
    pub fn sample_locations_info(mut self, sample_locations_info: SampleLocationsInfoEXT) -> Self {
        self.inner.sample_locations_info = sample_locations_info;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SubpassSampleLocationsEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassSampleLocationsBeginInfoEXT.html>"]
pub struct RenderPassSampleLocationsBeginInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub attachment_initial_sample_locations_count: u32,
    pub p_attachment_initial_sample_locations: *const AttachmentSampleLocationsEXT,
    pub post_subpass_sample_locations_count: u32,
    pub p_post_subpass_sample_locations: *const SubpassSampleLocationsEXT,
}
impl ::std::default::Default for RenderPassSampleLocationsBeginInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            attachment_initial_sample_locations_count: u32::default(),
            p_attachment_initial_sample_locations: ::std::ptr::null(),
            post_subpass_sample_locations_count: u32::default(),
            p_post_subpass_sample_locations: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for RenderPassSampleLocationsBeginInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT;
}
impl RenderPassSampleLocationsBeginInfoEXT {
    pub fn builder<'a>() -> RenderPassSampleLocationsBeginInfoEXTBuilder<'a> {
        RenderPassSampleLocationsBeginInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RenderPassSampleLocationsBeginInfoEXTBuilder<'a> {
    inner: RenderPassSampleLocationsBeginInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsRenderPassBeginInfo for RenderPassSampleLocationsBeginInfoEXTBuilder<'_> {}
unsafe impl ExtendsRenderPassBeginInfo for RenderPassSampleLocationsBeginInfoEXT {}
impl<'a> ::std::ops::Deref for RenderPassSampleLocationsBeginInfoEXTBuilder<'a> {
    type Target = RenderPassSampleLocationsBeginInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RenderPassSampleLocationsBeginInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RenderPassSampleLocationsBeginInfoEXTBuilder<'a> {
    #[inline]
    pub fn attachment_initial_sample_locations(
        mut self,
        attachment_initial_sample_locations: &'a [AttachmentSampleLocationsEXT],
    ) -> Self {
        self.inner.attachment_initial_sample_locations_count =
            attachment_initial_sample_locations.len() as _;
        self.inner.p_attachment_initial_sample_locations =
            attachment_initial_sample_locations.as_ptr();
        self
    }
    #[inline]
    pub fn post_subpass_sample_locations(
        mut self,
        post_subpass_sample_locations: &'a [SubpassSampleLocationsEXT],
    ) -> Self {
        self.inner.post_subpass_sample_locations_count = post_subpass_sample_locations.len() as _;
        self.inner.p_post_subpass_sample_locations = post_subpass_sample_locations.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RenderPassSampleLocationsBeginInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineSampleLocationsStateCreateInfoEXT.html>"]
pub struct PipelineSampleLocationsStateCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub sample_locations_enable: Bool32,
    pub sample_locations_info: SampleLocationsInfoEXT,
}
impl ::std::default::Default for PipelineSampleLocationsStateCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            sample_locations_enable: Bool32::default(),
            sample_locations_info: SampleLocationsInfoEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineSampleLocationsStateCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT;
}
impl PipelineSampleLocationsStateCreateInfoEXT {
    pub fn builder<'a>() -> PipelineSampleLocationsStateCreateInfoEXTBuilder<'a> {
        PipelineSampleLocationsStateCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineSampleLocationsStateCreateInfoEXTBuilder<'a> {
    inner: PipelineSampleLocationsStateCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPipelineMultisampleStateCreateInfo
    for PipelineSampleLocationsStateCreateInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsPipelineMultisampleStateCreateInfo
    for PipelineSampleLocationsStateCreateInfoEXT
{
}
impl<'a> ::std::ops::Deref for PipelineSampleLocationsStateCreateInfoEXTBuilder<'a> {
    type Target = PipelineSampleLocationsStateCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineSampleLocationsStateCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineSampleLocationsStateCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn sample_locations_enable(mut self, sample_locations_enable: bool) -> Self {
        self.inner.sample_locations_enable = sample_locations_enable.into();
        self
    }
    #[inline]
    pub fn sample_locations_info(mut self, sample_locations_info: SampleLocationsInfoEXT) -> Self {
        self.inner.sample_locations_info = sample_locations_info;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineSampleLocationsStateCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSampleLocationsPropertiesEXT.html>"]
pub struct PhysicalDeviceSampleLocationsPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub sample_location_sample_counts: SampleCountFlags,
    pub max_sample_location_grid_size: Extent2D,
    pub sample_location_coordinate_range: [f32; 2],
    pub sample_location_sub_pixel_bits: u32,
    pub variable_sample_locations: Bool32,
}
impl ::std::default::Default for PhysicalDeviceSampleLocationsPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            sample_location_sample_counts: SampleCountFlags::default(),
            max_sample_location_grid_size: Extent2D::default(),
            sample_location_coordinate_range: unsafe { ::std::mem::zeroed() },
            sample_location_sub_pixel_bits: u32::default(),
            variable_sample_locations: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceSampleLocationsPropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT;
}
impl PhysicalDeviceSampleLocationsPropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceSampleLocationsPropertiesEXTBuilder<'a> {
        PhysicalDeviceSampleLocationsPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceSampleLocationsPropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceSampleLocationsPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceSampleLocationsPropertiesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceSampleLocationsPropertiesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceSampleLocationsPropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceSampleLocationsPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceSampleLocationsPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceSampleLocationsPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn sample_location_sample_counts(
        mut self,
        sample_location_sample_counts: SampleCountFlags,
    ) -> Self {
        self.inner.sample_location_sample_counts = sample_location_sample_counts;
        self
    }
    #[inline]
    pub fn max_sample_location_grid_size(
        mut self,
        max_sample_location_grid_size: Extent2D,
    ) -> Self {
        self.inner.max_sample_location_grid_size = max_sample_location_grid_size;
        self
    }
    #[inline]
    pub fn sample_location_coordinate_range(
        mut self,
        sample_location_coordinate_range: [f32; 2],
    ) -> Self {
        self.inner.sample_location_coordinate_range = sample_location_coordinate_range;
        self
    }
    #[inline]
    pub fn sample_location_sub_pixel_bits(mut self, sample_location_sub_pixel_bits: u32) -> Self {
        self.inner.sample_location_sub_pixel_bits = sample_location_sub_pixel_bits;
        self
    }
    #[inline]
    pub fn variable_sample_locations(mut self, variable_sample_locations: bool) -> Self {
        self.inner.variable_sample_locations = variable_sample_locations.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceSampleLocationsPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMultisamplePropertiesEXT.html>"]
pub struct MultisamplePropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_sample_location_grid_size: Extent2D,
}
impl ::std::default::Default for MultisamplePropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_sample_location_grid_size: Extent2D::default(),
        }
    }
}
unsafe impl TaggedStructure for MultisamplePropertiesEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::MULTISAMPLE_PROPERTIES_EXT;
}
impl MultisamplePropertiesEXT {
    pub fn builder<'a>() -> MultisamplePropertiesEXTBuilder<'a> {
        MultisamplePropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MultisamplePropertiesEXTBuilder<'a> {
    inner: MultisamplePropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MultisamplePropertiesEXTBuilder<'a> {
    type Target = MultisamplePropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MultisamplePropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MultisamplePropertiesEXTBuilder<'a> {
    #[inline]
    pub fn max_sample_location_grid_size(
        mut self,
        max_sample_location_grid_size: Extent2D,
    ) -> Self {
        self.inner.max_sample_location_grid_size = max_sample_location_grid_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MultisamplePropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerReductionModeCreateInfo.html>"]
pub struct SamplerReductionModeCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub reduction_mode: SamplerReductionMode,
}
impl ::std::default::Default for SamplerReductionModeCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            reduction_mode: SamplerReductionMode::default(),
        }
    }
}
unsafe impl TaggedStructure for SamplerReductionModeCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::SAMPLER_REDUCTION_MODE_CREATE_INFO;
}
impl SamplerReductionModeCreateInfo {
    pub fn builder<'a>() -> SamplerReductionModeCreateInfoBuilder<'a> {
        SamplerReductionModeCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SamplerReductionModeCreateInfoBuilder<'a> {
    inner: SamplerReductionModeCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSamplerCreateInfo for SamplerReductionModeCreateInfoBuilder<'_> {}
unsafe impl ExtendsSamplerCreateInfo for SamplerReductionModeCreateInfo {}
impl<'a> ::std::ops::Deref for SamplerReductionModeCreateInfoBuilder<'a> {
    type Target = SamplerReductionModeCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SamplerReductionModeCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SamplerReductionModeCreateInfoBuilder<'a> {
    #[inline]
    pub fn reduction_mode(mut self, reduction_mode: SamplerReductionMode) -> Self {
        self.inner.reduction_mode = reduction_mode;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SamplerReductionModeCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.html>"]
pub struct PhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub advanced_blend_coherent_operations: Bool32,
}
impl ::std::default::Default for PhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            advanced_blend_coherent_operations: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT;
}
impl PhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceBlendOperationAdvancedFeaturesEXTBuilder<'a> {
        PhysicalDeviceBlendOperationAdvancedFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceBlendOperationAdvancedFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceBlendOperationAdvancedFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceBlendOperationAdvancedFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceBlendOperationAdvancedFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceBlendOperationAdvancedFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceBlendOperationAdvancedFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceBlendOperationAdvancedFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceBlendOperationAdvancedFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceBlendOperationAdvancedFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceBlendOperationAdvancedFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn advanced_blend_coherent_operations(
        mut self,
        advanced_blend_coherent_operations: bool,
    ) -> Self {
        self.inner.advanced_blend_coherent_operations = advanced_blend_coherent_operations.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceBlendOperationAdvancedFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiDrawFeaturesEXT.html>"]
pub struct PhysicalDeviceMultiDrawFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub multi_draw: Bool32,
}
impl ::std::default::Default for PhysicalDeviceMultiDrawFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            multi_draw: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceMultiDrawFeaturesEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT;
}
impl PhysicalDeviceMultiDrawFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceMultiDrawFeaturesEXTBuilder<'a> {
        PhysicalDeviceMultiDrawFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceMultiDrawFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceMultiDrawFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMultiDrawFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMultiDrawFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMultiDrawFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMultiDrawFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceMultiDrawFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceMultiDrawFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceMultiDrawFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceMultiDrawFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn multi_draw(mut self, multi_draw: bool) -> Self {
        self.inner.multi_draw = multi_draw.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceMultiDrawFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.html>"]
pub struct PhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub advanced_blend_max_color_attachments: u32,
    pub advanced_blend_independent_blend: Bool32,
    pub advanced_blend_non_premultiplied_src_color: Bool32,
    pub advanced_blend_non_premultiplied_dst_color: Bool32,
    pub advanced_blend_correlated_overlap: Bool32,
    pub advanced_blend_all_operations: Bool32,
}
impl ::std::default::Default for PhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            advanced_blend_max_color_attachments: u32::default(),
            advanced_blend_independent_blend: Bool32::default(),
            advanced_blend_non_premultiplied_src_color: Bool32::default(),
            advanced_blend_non_premultiplied_dst_color: Bool32::default(),
            advanced_blend_correlated_overlap: Bool32::default(),
            advanced_blend_all_operations: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT;
}
impl PhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceBlendOperationAdvancedPropertiesEXTBuilder<'a> {
        PhysicalDeviceBlendOperationAdvancedPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceBlendOperationAdvancedPropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceBlendOperationAdvancedPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceBlendOperationAdvancedPropertiesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceBlendOperationAdvancedPropertiesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceBlendOperationAdvancedPropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceBlendOperationAdvancedPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceBlendOperationAdvancedPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceBlendOperationAdvancedPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn advanced_blend_max_color_attachments(
        mut self,
        advanced_blend_max_color_attachments: u32,
    ) -> Self {
        self.inner.advanced_blend_max_color_attachments = advanced_blend_max_color_attachments;
        self
    }
    #[inline]
    pub fn advanced_blend_independent_blend(
        mut self,
        advanced_blend_independent_blend: bool,
    ) -> Self {
        self.inner.advanced_blend_independent_blend = advanced_blend_independent_blend.into();
        self
    }
    #[inline]
    pub fn advanced_blend_non_premultiplied_src_color(
        mut self,
        advanced_blend_non_premultiplied_src_color: bool,
    ) -> Self {
        self.inner.advanced_blend_non_premultiplied_src_color =
            advanced_blend_non_premultiplied_src_color.into();
        self
    }
    #[inline]
    pub fn advanced_blend_non_premultiplied_dst_color(
        mut self,
        advanced_blend_non_premultiplied_dst_color: bool,
    ) -> Self {
        self.inner.advanced_blend_non_premultiplied_dst_color =
            advanced_blend_non_premultiplied_dst_color.into();
        self
    }
    #[inline]
    pub fn advanced_blend_correlated_overlap(
        mut self,
        advanced_blend_correlated_overlap: bool,
    ) -> Self {
        self.inner.advanced_blend_correlated_overlap = advanced_blend_correlated_overlap.into();
        self
    }
    #[inline]
    pub fn advanced_blend_all_operations(mut self, advanced_blend_all_operations: bool) -> Self {
        self.inner.advanced_blend_all_operations = advanced_blend_all_operations.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceBlendOperationAdvancedPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineColorBlendAdvancedStateCreateInfoEXT.html>"]
pub struct PipelineColorBlendAdvancedStateCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_premultiplied: Bool32,
    pub dst_premultiplied: Bool32,
    pub blend_overlap: BlendOverlapEXT,
}
impl ::std::default::Default for PipelineColorBlendAdvancedStateCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_premultiplied: Bool32::default(),
            dst_premultiplied: Bool32::default(),
            blend_overlap: BlendOverlapEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineColorBlendAdvancedStateCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT;
}
impl PipelineColorBlendAdvancedStateCreateInfoEXT {
    pub fn builder<'a>() -> PipelineColorBlendAdvancedStateCreateInfoEXTBuilder<'a> {
        PipelineColorBlendAdvancedStateCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineColorBlendAdvancedStateCreateInfoEXTBuilder<'a> {
    inner: PipelineColorBlendAdvancedStateCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPipelineColorBlendStateCreateInfo
    for PipelineColorBlendAdvancedStateCreateInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsPipelineColorBlendStateCreateInfo
    for PipelineColorBlendAdvancedStateCreateInfoEXT
{
}
impl<'a> ::std::ops::Deref for PipelineColorBlendAdvancedStateCreateInfoEXTBuilder<'a> {
    type Target = PipelineColorBlendAdvancedStateCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineColorBlendAdvancedStateCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineColorBlendAdvancedStateCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn src_premultiplied(mut self, src_premultiplied: bool) -> Self {
        self.inner.src_premultiplied = src_premultiplied.into();
        self
    }
    #[inline]
    pub fn dst_premultiplied(mut self, dst_premultiplied: bool) -> Self {
        self.inner.dst_premultiplied = dst_premultiplied.into();
        self
    }
    #[inline]
    pub fn blend_overlap(mut self, blend_overlap: BlendOverlapEXT) -> Self {
        self.inner.blend_overlap = blend_overlap;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineColorBlendAdvancedStateCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceInlineUniformBlockFeatures.html>"]
pub struct PhysicalDeviceInlineUniformBlockFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub inline_uniform_block: Bool32,
    pub descriptor_binding_inline_uniform_block_update_after_bind: Bool32,
}
impl ::std::default::Default for PhysicalDeviceInlineUniformBlockFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            inline_uniform_block: Bool32::default(),
            descriptor_binding_inline_uniform_block_update_after_bind: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceInlineUniformBlockFeatures {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES;
}
impl PhysicalDeviceInlineUniformBlockFeatures {
    pub fn builder<'a>() -> PhysicalDeviceInlineUniformBlockFeaturesBuilder<'a> {
        PhysicalDeviceInlineUniformBlockFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceInlineUniformBlockFeaturesBuilder<'a> {
    inner: PhysicalDeviceInlineUniformBlockFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceInlineUniformBlockFeaturesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceInlineUniformBlockFeatures {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceInlineUniformBlockFeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceInlineUniformBlockFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDeviceInlineUniformBlockFeaturesBuilder<'a> {
    type Target = PhysicalDeviceInlineUniformBlockFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceInlineUniformBlockFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceInlineUniformBlockFeaturesBuilder<'a> {
    #[inline]
    pub fn inline_uniform_block(mut self, inline_uniform_block: bool) -> Self {
        self.inner.inline_uniform_block = inline_uniform_block.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_inline_uniform_block_update_after_bind(
        mut self,
        descriptor_binding_inline_uniform_block_update_after_bind: bool,
    ) -> Self {
        self.inner
            .descriptor_binding_inline_uniform_block_update_after_bind =
            descriptor_binding_inline_uniform_block_update_after_bind.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceInlineUniformBlockFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceInlineUniformBlockProperties.html>"]
pub struct PhysicalDeviceInlineUniformBlockProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_inline_uniform_block_size: u32,
    pub max_per_stage_descriptor_inline_uniform_blocks: u32,
    pub max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
    pub max_descriptor_set_inline_uniform_blocks: u32,
    pub max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
}
impl ::std::default::Default for PhysicalDeviceInlineUniformBlockProperties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_inline_uniform_block_size: u32::default(),
            max_per_stage_descriptor_inline_uniform_blocks: u32::default(),
            max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32::default(),
            max_descriptor_set_inline_uniform_blocks: u32::default(),
            max_descriptor_set_update_after_bind_inline_uniform_blocks: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceInlineUniformBlockProperties {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES;
}
impl PhysicalDeviceInlineUniformBlockProperties {
    pub fn builder<'a>() -> PhysicalDeviceInlineUniformBlockPropertiesBuilder<'a> {
        PhysicalDeviceInlineUniformBlockPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceInlineUniformBlockPropertiesBuilder<'a> {
    inner: PhysicalDeviceInlineUniformBlockProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceInlineUniformBlockPropertiesBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceInlineUniformBlockProperties {}
impl<'a> ::std::ops::Deref for PhysicalDeviceInlineUniformBlockPropertiesBuilder<'a> {
    type Target = PhysicalDeviceInlineUniformBlockProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceInlineUniformBlockPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceInlineUniformBlockPropertiesBuilder<'a> {
    #[inline]
    pub fn max_inline_uniform_block_size(mut self, max_inline_uniform_block_size: u32) -> Self {
        self.inner.max_inline_uniform_block_size = max_inline_uniform_block_size;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_inline_uniform_blocks(
        mut self,
        max_per_stage_descriptor_inline_uniform_blocks: u32,
    ) -> Self {
        self.inner.max_per_stage_descriptor_inline_uniform_blocks =
            max_per_stage_descriptor_inline_uniform_blocks;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_inline_uniform_blocks(
        mut self,
        max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
    ) -> Self {
        self.inner
            .max_per_stage_descriptor_update_after_bind_inline_uniform_blocks =
            max_per_stage_descriptor_update_after_bind_inline_uniform_blocks;
        self
    }
    #[inline]
    pub fn max_descriptor_set_inline_uniform_blocks(
        mut self,
        max_descriptor_set_inline_uniform_blocks: u32,
    ) -> Self {
        self.inner.max_descriptor_set_inline_uniform_blocks =
            max_descriptor_set_inline_uniform_blocks;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_inline_uniform_blocks(
        mut self,
        max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
    ) -> Self {
        self.inner
            .max_descriptor_set_update_after_bind_inline_uniform_blocks =
            max_descriptor_set_update_after_bind_inline_uniform_blocks;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceInlineUniformBlockProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWriteDescriptorSetInlineUniformBlock.html>"]
pub struct WriteDescriptorSetInlineUniformBlock {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub data_size: u32,
    pub p_data: *const c_void,
}
impl ::std::default::Default for WriteDescriptorSetInlineUniformBlock {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            data_size: u32::default(),
            p_data: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for WriteDescriptorSetInlineUniformBlock {
    const STRUCTURE_TYPE: StructureType = StructureType::WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK;
}
impl WriteDescriptorSetInlineUniformBlock {
    pub fn builder<'a>() -> WriteDescriptorSetInlineUniformBlockBuilder<'a> {
        WriteDescriptorSetInlineUniformBlockBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct WriteDescriptorSetInlineUniformBlockBuilder<'a> {
    inner: WriteDescriptorSetInlineUniformBlock,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsWriteDescriptorSet for WriteDescriptorSetInlineUniformBlockBuilder<'_> {}
unsafe impl ExtendsWriteDescriptorSet for WriteDescriptorSetInlineUniformBlock {}
impl<'a> ::std::ops::Deref for WriteDescriptorSetInlineUniformBlockBuilder<'a> {
    type Target = WriteDescriptorSetInlineUniformBlock;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for WriteDescriptorSetInlineUniformBlockBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> WriteDescriptorSetInlineUniformBlockBuilder<'a> {
    #[inline]
    pub fn data(mut self, data: &'a [u8]) -> Self {
        self.inner.data_size = data.len() as _;
        self.inner.p_data = data.as_ptr().cast();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> WriteDescriptorSetInlineUniformBlock {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolInlineUniformBlockCreateInfo.html>"]
pub struct DescriptorPoolInlineUniformBlockCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub max_inline_uniform_block_bindings: u32,
}
impl ::std::default::Default for DescriptorPoolInlineUniformBlockCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            max_inline_uniform_block_bindings: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for DescriptorPoolInlineUniformBlockCreateInfo {
    const STRUCTURE_TYPE: StructureType =
        StructureType::DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO;
}
impl DescriptorPoolInlineUniformBlockCreateInfo {
    pub fn builder<'a>() -> DescriptorPoolInlineUniformBlockCreateInfoBuilder<'a> {
        DescriptorPoolInlineUniformBlockCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DescriptorPoolInlineUniformBlockCreateInfoBuilder<'a> {
    inner: DescriptorPoolInlineUniformBlockCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsDescriptorPoolCreateInfo
    for DescriptorPoolInlineUniformBlockCreateInfoBuilder<'_>
{
}
unsafe impl ExtendsDescriptorPoolCreateInfo for DescriptorPoolInlineUniformBlockCreateInfo {}
impl<'a> ::std::ops::Deref for DescriptorPoolInlineUniformBlockCreateInfoBuilder<'a> {
    type Target = DescriptorPoolInlineUniformBlockCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DescriptorPoolInlineUniformBlockCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DescriptorPoolInlineUniformBlockCreateInfoBuilder<'a> {
    #[inline]
    pub fn max_inline_uniform_block_bindings(
        mut self,
        max_inline_uniform_block_bindings: u32,
    ) -> Self {
        self.inner.max_inline_uniform_block_bindings = max_inline_uniform_block_bindings;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DescriptorPoolInlineUniformBlockCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCoverageModulationStateCreateInfoNV.html>"]
pub struct PipelineCoverageModulationStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineCoverageModulationStateCreateFlagsNV,
    pub coverage_modulation_mode: CoverageModulationModeNV,
    pub coverage_modulation_table_enable: Bool32,
    pub coverage_modulation_table_count: u32,
    pub p_coverage_modulation_table: *const f32,
}
impl ::std::default::Default for PipelineCoverageModulationStateCreateInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineCoverageModulationStateCreateFlagsNV::default(),
            coverage_modulation_mode: CoverageModulationModeNV::default(),
            coverage_modulation_table_enable: Bool32::default(),
            coverage_modulation_table_count: u32::default(),
            p_coverage_modulation_table: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for PipelineCoverageModulationStateCreateInfoNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV;
}
impl PipelineCoverageModulationStateCreateInfoNV {
    pub fn builder<'a>() -> PipelineCoverageModulationStateCreateInfoNVBuilder<'a> {
        PipelineCoverageModulationStateCreateInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineCoverageModulationStateCreateInfoNVBuilder<'a> {
    inner: PipelineCoverageModulationStateCreateInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPipelineMultisampleStateCreateInfo
    for PipelineCoverageModulationStateCreateInfoNVBuilder<'_>
{
}
unsafe impl ExtendsPipelineMultisampleStateCreateInfo
    for PipelineCoverageModulationStateCreateInfoNV
{
}
impl<'a> ::std::ops::Deref for PipelineCoverageModulationStateCreateInfoNVBuilder<'a> {
    type Target = PipelineCoverageModulationStateCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineCoverageModulationStateCreateInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineCoverageModulationStateCreateInfoNVBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineCoverageModulationStateCreateFlagsNV) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn coverage_modulation_mode(
        mut self,
        coverage_modulation_mode: CoverageModulationModeNV,
    ) -> Self {
        self.inner.coverage_modulation_mode = coverage_modulation_mode;
        self
    }
    #[inline]
    pub fn coverage_modulation_table_enable(
        mut self,
        coverage_modulation_table_enable: bool,
    ) -> Self {
        self.inner.coverage_modulation_table_enable = coverage_modulation_table_enable.into();
        self
    }
    #[inline]
    pub fn coverage_modulation_table(mut self, coverage_modulation_table: &'a [f32]) -> Self {
        self.inner.coverage_modulation_table_count = coverage_modulation_table.len() as _;
        self.inner.p_coverage_modulation_table = coverage_modulation_table.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineCoverageModulationStateCreateInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageFormatListCreateInfo.html>"]
pub struct ImageFormatListCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub view_format_count: u32,
    pub p_view_formats: *const Format,
}
impl ::std::default::Default for ImageFormatListCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            view_format_count: u32::default(),
            p_view_formats: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for ImageFormatListCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_FORMAT_LIST_CREATE_INFO;
}
impl ImageFormatListCreateInfo {
    pub fn builder<'a>() -> ImageFormatListCreateInfoBuilder<'a> {
        ImageFormatListCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageFormatListCreateInfoBuilder<'a> {
    inner: ImageFormatListCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageCreateInfo for ImageFormatListCreateInfoBuilder<'_> {}
unsafe impl ExtendsImageCreateInfo for ImageFormatListCreateInfo {}
unsafe impl ExtendsSwapchainCreateInfoKHR for ImageFormatListCreateInfoBuilder<'_> {}
unsafe impl ExtendsSwapchainCreateInfoKHR for ImageFormatListCreateInfo {}
unsafe impl ExtendsPhysicalDeviceImageFormatInfo2 for ImageFormatListCreateInfoBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceImageFormatInfo2 for ImageFormatListCreateInfo {}
impl<'a> ::std::ops::Deref for ImageFormatListCreateInfoBuilder<'a> {
    type Target = ImageFormatListCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageFormatListCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageFormatListCreateInfoBuilder<'a> {
    #[inline]
    pub fn view_formats(mut self, view_formats: &'a [Format]) -> Self {
        self.inner.view_format_count = view_formats.len() as _;
        self.inner.p_view_formats = view_formats.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageFormatListCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkValidationCacheCreateInfoEXT.html>"]
pub struct ValidationCacheCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ValidationCacheCreateFlagsEXT,
    pub initial_data_size: usize,
    pub p_initial_data: *const c_void,
}
impl ::std::default::Default for ValidationCacheCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: ValidationCacheCreateFlagsEXT::default(),
            initial_data_size: usize::default(),
            p_initial_data: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for ValidationCacheCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::VALIDATION_CACHE_CREATE_INFO_EXT;
}
impl ValidationCacheCreateInfoEXT {
    pub fn builder<'a>() -> ValidationCacheCreateInfoEXTBuilder<'a> {
        ValidationCacheCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ValidationCacheCreateInfoEXTBuilder<'a> {
    inner: ValidationCacheCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ValidationCacheCreateInfoEXTBuilder<'a> {
    type Target = ValidationCacheCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ValidationCacheCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ValidationCacheCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: ValidationCacheCreateFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn initial_data(mut self, initial_data: &'a [u8]) -> Self {
        self.inner.initial_data_size = initial_data.len();
        self.inner.p_initial_data = initial_data.as_ptr().cast();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ValidationCacheCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderModuleValidationCacheCreateInfoEXT.html>"]
pub struct ShaderModuleValidationCacheCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub validation_cache: ValidationCacheEXT,
}
impl ::std::default::Default for ShaderModuleValidationCacheCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            validation_cache: ValidationCacheEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for ShaderModuleValidationCacheCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT;
}
impl ShaderModuleValidationCacheCreateInfoEXT {
    pub fn builder<'a>() -> ShaderModuleValidationCacheCreateInfoEXTBuilder<'a> {
        ShaderModuleValidationCacheCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ShaderModuleValidationCacheCreateInfoEXTBuilder<'a> {
    inner: ShaderModuleValidationCacheCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsShaderModuleCreateInfo for ShaderModuleValidationCacheCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsShaderModuleCreateInfo for ShaderModuleValidationCacheCreateInfoEXT {}
unsafe impl ExtendsPipelineShaderStageCreateInfo
    for ShaderModuleValidationCacheCreateInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsPipelineShaderStageCreateInfo for ShaderModuleValidationCacheCreateInfoEXT {}
impl<'a> ::std::ops::Deref for ShaderModuleValidationCacheCreateInfoEXTBuilder<'a> {
    type Target = ShaderModuleValidationCacheCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ShaderModuleValidationCacheCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ShaderModuleValidationCacheCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn validation_cache(mut self, validation_cache: ValidationCacheEXT) -> Self {
        self.inner.validation_cache = validation_cache;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ShaderModuleValidationCacheCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance3Properties.html>"]
pub struct PhysicalDeviceMaintenance3Properties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_per_set_descriptors: u32,
    pub max_memory_allocation_size: DeviceSize,
}
impl ::std::default::Default for PhysicalDeviceMaintenance3Properties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_per_set_descriptors: u32::default(),
            max_memory_allocation_size: DeviceSize::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceMaintenance3Properties {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES;
}
impl PhysicalDeviceMaintenance3Properties {
    pub fn builder<'a>() -> PhysicalDeviceMaintenance3PropertiesBuilder<'a> {
        PhysicalDeviceMaintenance3PropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceMaintenance3PropertiesBuilder<'a> {
    inner: PhysicalDeviceMaintenance3Properties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceMaintenance3PropertiesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceMaintenance3Properties {}
impl<'a> ::std::ops::Deref for PhysicalDeviceMaintenance3PropertiesBuilder<'a> {
    type Target = PhysicalDeviceMaintenance3Properties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceMaintenance3PropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceMaintenance3PropertiesBuilder<'a> {
    #[inline]
    pub fn max_per_set_descriptors(mut self, max_per_set_descriptors: u32) -> Self {
        self.inner.max_per_set_descriptors = max_per_set_descriptors;
        self
    }
    #[inline]
    pub fn max_memory_allocation_size(mut self, max_memory_allocation_size: DeviceSize) -> Self {
        self.inner.max_memory_allocation_size = max_memory_allocation_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceMaintenance3Properties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance4Features.html>"]
pub struct PhysicalDeviceMaintenance4Features {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub maintenance4: Bool32,
}
impl ::std::default::Default for PhysicalDeviceMaintenance4Features {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            maintenance4: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceMaintenance4Features {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES;
}
impl PhysicalDeviceMaintenance4Features {
    pub fn builder<'a>() -> PhysicalDeviceMaintenance4FeaturesBuilder<'a> {
        PhysicalDeviceMaintenance4FeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceMaintenance4FeaturesBuilder<'a> {
    inner: PhysicalDeviceMaintenance4Features,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMaintenance4FeaturesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMaintenance4Features {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMaintenance4FeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMaintenance4Features {}
impl<'a> ::std::ops::Deref for PhysicalDeviceMaintenance4FeaturesBuilder<'a> {
    type Target = PhysicalDeviceMaintenance4Features;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceMaintenance4FeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceMaintenance4FeaturesBuilder<'a> {
    #[inline]
    pub fn maintenance4(mut self, maintenance4: bool) -> Self {
        self.inner.maintenance4 = maintenance4.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceMaintenance4Features {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance4Properties.html>"]
pub struct PhysicalDeviceMaintenance4Properties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_buffer_size: DeviceSize,
}
impl ::std::default::Default for PhysicalDeviceMaintenance4Properties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_buffer_size: DeviceSize::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceMaintenance4Properties {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES;
}
impl PhysicalDeviceMaintenance4Properties {
    pub fn builder<'a>() -> PhysicalDeviceMaintenance4PropertiesBuilder<'a> {
        PhysicalDeviceMaintenance4PropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceMaintenance4PropertiesBuilder<'a> {
    inner: PhysicalDeviceMaintenance4Properties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceMaintenance4PropertiesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceMaintenance4Properties {}
impl<'a> ::std::ops::Deref for PhysicalDeviceMaintenance4PropertiesBuilder<'a> {
    type Target = PhysicalDeviceMaintenance4Properties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceMaintenance4PropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceMaintenance4PropertiesBuilder<'a> {
    #[inline]
    pub fn max_buffer_size(mut self, max_buffer_size: DeviceSize) -> Self {
        self.inner.max_buffer_size = max_buffer_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceMaintenance4Properties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutSupport.html>"]
pub struct DescriptorSetLayoutSupport {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub supported: Bool32,
}
impl ::std::default::Default for DescriptorSetLayoutSupport {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            supported: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for DescriptorSetLayoutSupport {
    const STRUCTURE_TYPE: StructureType = StructureType::DESCRIPTOR_SET_LAYOUT_SUPPORT;
}
impl DescriptorSetLayoutSupport {
    pub fn builder<'a>() -> DescriptorSetLayoutSupportBuilder<'a> {
        DescriptorSetLayoutSupportBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DescriptorSetLayoutSupportBuilder<'a> {
    inner: DescriptorSetLayoutSupport,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsDescriptorSetLayoutSupport {}
impl<'a> ::std::ops::Deref for DescriptorSetLayoutSupportBuilder<'a> {
    type Target = DescriptorSetLayoutSupport;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DescriptorSetLayoutSupportBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DescriptorSetLayoutSupportBuilder<'a> {
    #[inline]
    pub fn supported(mut self, supported: bool) -> Self {
        self.inner.supported = supported.into();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsDescriptorSetLayoutSupport>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DescriptorSetLayoutSupport {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderDrawParametersFeatures.html>"]
pub struct PhysicalDeviceShaderDrawParametersFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_draw_parameters: Bool32,
}
impl ::std::default::Default for PhysicalDeviceShaderDrawParametersFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_draw_parameters: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderDrawParametersFeatures {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
}
impl PhysicalDeviceShaderDrawParametersFeatures {
    pub fn builder<'a>() -> PhysicalDeviceShaderDrawParametersFeaturesBuilder<'a> {
        PhysicalDeviceShaderDrawParametersFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderDrawParametersFeaturesBuilder<'a> {
    inner: PhysicalDeviceShaderDrawParametersFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceShaderDrawParametersFeaturesBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderDrawParametersFeatures {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderDrawParametersFeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderDrawParametersFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderDrawParametersFeaturesBuilder<'a> {
    type Target = PhysicalDeviceShaderDrawParametersFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderDrawParametersFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderDrawParametersFeaturesBuilder<'a> {
    #[inline]
    pub fn shader_draw_parameters(mut self, shader_draw_parameters: bool) -> Self {
        self.inner.shader_draw_parameters = shader_draw_parameters.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderDrawParametersFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderFloat16Int8Features.html>"]
pub struct PhysicalDeviceShaderFloat16Int8Features {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_float16: Bool32,
    pub shader_int8: Bool32,
}
impl ::std::default::Default for PhysicalDeviceShaderFloat16Int8Features {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_float16: Bool32::default(),
            shader_int8: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderFloat16Int8Features {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
}
impl PhysicalDeviceShaderFloat16Int8Features {
    pub fn builder<'a>() -> PhysicalDeviceShaderFloat16Int8FeaturesBuilder<'a> {
        PhysicalDeviceShaderFloat16Int8FeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderFloat16Int8FeaturesBuilder<'a> {
    inner: PhysicalDeviceShaderFloat16Int8Features,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderFloat16Int8FeaturesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderFloat16Int8Features {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderFloat16Int8FeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderFloat16Int8Features {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderFloat16Int8FeaturesBuilder<'a> {
    type Target = PhysicalDeviceShaderFloat16Int8Features;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderFloat16Int8FeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderFloat16Int8FeaturesBuilder<'a> {
    #[inline]
    pub fn shader_float16(mut self, shader_float16: bool) -> Self {
        self.inner.shader_float16 = shader_float16.into();
        self
    }
    #[inline]
    pub fn shader_int8(mut self, shader_int8: bool) -> Self {
        self.inner.shader_int8 = shader_int8.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderFloat16Int8Features {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFloatControlsProperties.html>"]
pub struct PhysicalDeviceFloatControlsProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub denorm_behavior_independence: ShaderFloatControlsIndependence,
    pub rounding_mode_independence: ShaderFloatControlsIndependence,
    pub shader_signed_zero_inf_nan_preserve_float16: Bool32,
    pub shader_signed_zero_inf_nan_preserve_float32: Bool32,
    pub shader_signed_zero_inf_nan_preserve_float64: Bool32,
    pub shader_denorm_preserve_float16: Bool32,
    pub shader_denorm_preserve_float32: Bool32,
    pub shader_denorm_preserve_float64: Bool32,
    pub shader_denorm_flush_to_zero_float16: Bool32,
    pub shader_denorm_flush_to_zero_float32: Bool32,
    pub shader_denorm_flush_to_zero_float64: Bool32,
    pub shader_rounding_mode_rte_float16: Bool32,
    pub shader_rounding_mode_rte_float32: Bool32,
    pub shader_rounding_mode_rte_float64: Bool32,
    pub shader_rounding_mode_rtz_float16: Bool32,
    pub shader_rounding_mode_rtz_float32: Bool32,
    pub shader_rounding_mode_rtz_float64: Bool32,
}
impl ::std::default::Default for PhysicalDeviceFloatControlsProperties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            denorm_behavior_independence: ShaderFloatControlsIndependence::default(),
            rounding_mode_independence: ShaderFloatControlsIndependence::default(),
            shader_signed_zero_inf_nan_preserve_float16: Bool32::default(),
            shader_signed_zero_inf_nan_preserve_float32: Bool32::default(),
            shader_signed_zero_inf_nan_preserve_float64: Bool32::default(),
            shader_denorm_preserve_float16: Bool32::default(),
            shader_denorm_preserve_float32: Bool32::default(),
            shader_denorm_preserve_float64: Bool32::default(),
            shader_denorm_flush_to_zero_float16: Bool32::default(),
            shader_denorm_flush_to_zero_float32: Bool32::default(),
            shader_denorm_flush_to_zero_float64: Bool32::default(),
            shader_rounding_mode_rte_float16: Bool32::default(),
            shader_rounding_mode_rte_float32: Bool32::default(),
            shader_rounding_mode_rte_float64: Bool32::default(),
            shader_rounding_mode_rtz_float16: Bool32::default(),
            shader_rounding_mode_rtz_float32: Bool32::default(),
            shader_rounding_mode_rtz_float64: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceFloatControlsProperties {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES;
}
impl PhysicalDeviceFloatControlsProperties {
    pub fn builder<'a>() -> PhysicalDeviceFloatControlsPropertiesBuilder<'a> {
        PhysicalDeviceFloatControlsPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceFloatControlsPropertiesBuilder<'a> {
    inner: PhysicalDeviceFloatControlsProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceFloatControlsPropertiesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceFloatControlsProperties {}
impl<'a> ::std::ops::Deref for PhysicalDeviceFloatControlsPropertiesBuilder<'a> {
    type Target = PhysicalDeviceFloatControlsProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceFloatControlsPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceFloatControlsPropertiesBuilder<'a> {
    #[inline]
    pub fn denorm_behavior_independence(
        mut self,
        denorm_behavior_independence: ShaderFloatControlsIndependence,
    ) -> Self {
        self.inner.denorm_behavior_independence = denorm_behavior_independence;
        self
    }
    #[inline]
    pub fn rounding_mode_independence(
        mut self,
        rounding_mode_independence: ShaderFloatControlsIndependence,
    ) -> Self {
        self.inner.rounding_mode_independence = rounding_mode_independence;
        self
    }
    #[inline]
    pub fn shader_signed_zero_inf_nan_preserve_float16(
        mut self,
        shader_signed_zero_inf_nan_preserve_float16: bool,
    ) -> Self {
        self.inner.shader_signed_zero_inf_nan_preserve_float16 =
            shader_signed_zero_inf_nan_preserve_float16.into();
        self
    }
    #[inline]
    pub fn shader_signed_zero_inf_nan_preserve_float32(
        mut self,
        shader_signed_zero_inf_nan_preserve_float32: bool,
    ) -> Self {
        self.inner.shader_signed_zero_inf_nan_preserve_float32 =
            shader_signed_zero_inf_nan_preserve_float32.into();
        self
    }
    #[inline]
    pub fn shader_signed_zero_inf_nan_preserve_float64(
        mut self,
        shader_signed_zero_inf_nan_preserve_float64: bool,
    ) -> Self {
        self.inner.shader_signed_zero_inf_nan_preserve_float64 =
            shader_signed_zero_inf_nan_preserve_float64.into();
        self
    }
    #[inline]
    pub fn shader_denorm_preserve_float16(mut self, shader_denorm_preserve_float16: bool) -> Self {
        self.inner.shader_denorm_preserve_float16 = shader_denorm_preserve_float16.into();
        self
    }
    #[inline]
    pub fn shader_denorm_preserve_float32(mut self, shader_denorm_preserve_float32: bool) -> Self {
        self.inner.shader_denorm_preserve_float32 = shader_denorm_preserve_float32.into();
        self
    }
    #[inline]
    pub fn shader_denorm_preserve_float64(mut self, shader_denorm_preserve_float64: bool) -> Self {
        self.inner.shader_denorm_preserve_float64 = shader_denorm_preserve_float64.into();
        self
    }
    #[inline]
    pub fn shader_denorm_flush_to_zero_float16(
        mut self,
        shader_denorm_flush_to_zero_float16: bool,
    ) -> Self {
        self.inner.shader_denorm_flush_to_zero_float16 = shader_denorm_flush_to_zero_float16.into();
        self
    }
    #[inline]
    pub fn shader_denorm_flush_to_zero_float32(
        mut self,
        shader_denorm_flush_to_zero_float32: bool,
    ) -> Self {
        self.inner.shader_denorm_flush_to_zero_float32 = shader_denorm_flush_to_zero_float32.into();
        self
    }
    #[inline]
    pub fn shader_denorm_flush_to_zero_float64(
        mut self,
        shader_denorm_flush_to_zero_float64: bool,
    ) -> Self {
        self.inner.shader_denorm_flush_to_zero_float64 = shader_denorm_flush_to_zero_float64.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rte_float16(
        mut self,
        shader_rounding_mode_rte_float16: bool,
    ) -> Self {
        self.inner.shader_rounding_mode_rte_float16 = shader_rounding_mode_rte_float16.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rte_float32(
        mut self,
        shader_rounding_mode_rte_float32: bool,
    ) -> Self {
        self.inner.shader_rounding_mode_rte_float32 = shader_rounding_mode_rte_float32.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rte_float64(
        mut self,
        shader_rounding_mode_rte_float64: bool,
    ) -> Self {
        self.inner.shader_rounding_mode_rte_float64 = shader_rounding_mode_rte_float64.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rtz_float16(
        mut self,
        shader_rounding_mode_rtz_float16: bool,
    ) -> Self {
        self.inner.shader_rounding_mode_rtz_float16 = shader_rounding_mode_rtz_float16.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rtz_float32(
        mut self,
        shader_rounding_mode_rtz_float32: bool,
    ) -> Self {
        self.inner.shader_rounding_mode_rtz_float32 = shader_rounding_mode_rtz_float32.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rtz_float64(
        mut self,
        shader_rounding_mode_rtz_float64: bool,
    ) -> Self {
        self.inner.shader_rounding_mode_rtz_float64 = shader_rounding_mode_rtz_float64.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceFloatControlsProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceHostQueryResetFeatures.html>"]
pub struct PhysicalDeviceHostQueryResetFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub host_query_reset: Bool32,
}
impl ::std::default::Default for PhysicalDeviceHostQueryResetFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            host_query_reset: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceHostQueryResetFeatures {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
}
impl PhysicalDeviceHostQueryResetFeatures {
    pub fn builder<'a>() -> PhysicalDeviceHostQueryResetFeaturesBuilder<'a> {
        PhysicalDeviceHostQueryResetFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceHostQueryResetFeaturesBuilder<'a> {
    inner: PhysicalDeviceHostQueryResetFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceHostQueryResetFeaturesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceHostQueryResetFeatures {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceHostQueryResetFeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceHostQueryResetFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDeviceHostQueryResetFeaturesBuilder<'a> {
    type Target = PhysicalDeviceHostQueryResetFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceHostQueryResetFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceHostQueryResetFeaturesBuilder<'a> {
    #[inline]
    pub fn host_query_reset(mut self, host_query_reset: bool) -> Self {
        self.inner.host_query_reset = host_query_reset.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceHostQueryResetFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkNativeBufferUsage2ANDROID.html>"]
pub struct NativeBufferUsage2ANDROID {
    pub consumer: u64,
    pub producer: u64,
}
impl NativeBufferUsage2ANDROID {
    pub fn builder<'a>() -> NativeBufferUsage2ANDROIDBuilder<'a> {
        NativeBufferUsage2ANDROIDBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct NativeBufferUsage2ANDROIDBuilder<'a> {
    inner: NativeBufferUsage2ANDROID,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for NativeBufferUsage2ANDROIDBuilder<'a> {
    type Target = NativeBufferUsage2ANDROID;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for NativeBufferUsage2ANDROIDBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> NativeBufferUsage2ANDROIDBuilder<'a> {
    #[inline]
    pub fn consumer(mut self, consumer: u64) -> Self {
        self.inner.consumer = consumer;
        self
    }
    #[inline]
    pub fn producer(mut self, producer: u64) -> Self {
        self.inner.producer = producer;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> NativeBufferUsage2ANDROID {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkNativeBufferANDROID.html>"]
pub struct NativeBufferANDROID {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle: *const c_void,
    pub stride: c_int,
    pub format: c_int,
    pub usage: c_int,
    pub usage2: NativeBufferUsage2ANDROID,
}
impl ::std::default::Default for NativeBufferANDROID {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle: ::std::ptr::null(),
            stride: c_int::default(),
            format: c_int::default(),
            usage: c_int::default(),
            usage2: NativeBufferUsage2ANDROID::default(),
        }
    }
}
unsafe impl TaggedStructure for NativeBufferANDROID {
    const STRUCTURE_TYPE: StructureType = StructureType::NATIVE_BUFFER_ANDROID;
}
impl NativeBufferANDROID {
    pub fn builder<'a>() -> NativeBufferANDROIDBuilder<'a> {
        NativeBufferANDROIDBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct NativeBufferANDROIDBuilder<'a> {
    inner: NativeBufferANDROID,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for NativeBufferANDROIDBuilder<'a> {
    type Target = NativeBufferANDROID;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for NativeBufferANDROIDBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> NativeBufferANDROIDBuilder<'a> {
    #[inline]
    pub fn handle(mut self, handle: *const c_void) -> Self {
        self.inner.handle = handle;
        self
    }
    #[inline]
    pub fn stride(mut self, stride: c_int) -> Self {
        self.inner.stride = stride;
        self
    }
    #[inline]
    pub fn format(mut self, format: c_int) -> Self {
        self.inner.format = format;
        self
    }
    #[inline]
    pub fn usage(mut self, usage: c_int) -> Self {
        self.inner.usage = usage;
        self
    }
    #[inline]
    pub fn usage2(mut self, usage2: NativeBufferUsage2ANDROID) -> Self {
        self.inner.usage2 = usage2;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> NativeBufferANDROID {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainImageCreateInfoANDROID.html>"]
pub struct SwapchainImageCreateInfoANDROID {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub usage: SwapchainImageUsageFlagsANDROID,
}
impl ::std::default::Default for SwapchainImageCreateInfoANDROID {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            usage: SwapchainImageUsageFlagsANDROID::default(),
        }
    }
}
unsafe impl TaggedStructure for SwapchainImageCreateInfoANDROID {
    const STRUCTURE_TYPE: StructureType = StructureType::SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID;
}
impl SwapchainImageCreateInfoANDROID {
    pub fn builder<'a>() -> SwapchainImageCreateInfoANDROIDBuilder<'a> {
        SwapchainImageCreateInfoANDROIDBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SwapchainImageCreateInfoANDROIDBuilder<'a> {
    inner: SwapchainImageCreateInfoANDROID,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SwapchainImageCreateInfoANDROIDBuilder<'a> {
    type Target = SwapchainImageCreateInfoANDROID;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SwapchainImageCreateInfoANDROIDBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SwapchainImageCreateInfoANDROIDBuilder<'a> {
    #[inline]
    pub fn usage(mut self, usage: SwapchainImageUsageFlagsANDROID) -> Self {
        self.inner.usage = usage;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SwapchainImageCreateInfoANDROID {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePresentationPropertiesANDROID.html>"]
pub struct PhysicalDevicePresentationPropertiesANDROID {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub shared_image: Bool32,
}
impl ::std::default::Default for PhysicalDevicePresentationPropertiesANDROID {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            shared_image: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevicePresentationPropertiesANDROID {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID;
}
impl PhysicalDevicePresentationPropertiesANDROID {
    pub fn builder<'a>() -> PhysicalDevicePresentationPropertiesANDROIDBuilder<'a> {
        PhysicalDevicePresentationPropertiesANDROIDBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevicePresentationPropertiesANDROIDBuilder<'a> {
    inner: PhysicalDevicePresentationPropertiesANDROID,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PhysicalDevicePresentationPropertiesANDROIDBuilder<'a> {
    type Target = PhysicalDevicePresentationPropertiesANDROID;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevicePresentationPropertiesANDROIDBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevicePresentationPropertiesANDROIDBuilder<'a> {
    #[inline]
    pub fn shared_image(mut self, shared_image: bool) -> Self {
        self.inner.shared_image = shared_image.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevicePresentationPropertiesANDROID {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderResourceUsageAMD.html>"]
pub struct ShaderResourceUsageAMD {
    pub num_used_vgprs: u32,
    pub num_used_sgprs: u32,
    pub lds_size_per_local_work_group: u32,
    pub lds_usage_size_in_bytes: usize,
    pub scratch_mem_usage_in_bytes: usize,
}
impl ShaderResourceUsageAMD {
    pub fn builder<'a>() -> ShaderResourceUsageAMDBuilder<'a> {
        ShaderResourceUsageAMDBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ShaderResourceUsageAMDBuilder<'a> {
    inner: ShaderResourceUsageAMD,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ShaderResourceUsageAMDBuilder<'a> {
    type Target = ShaderResourceUsageAMD;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ShaderResourceUsageAMDBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ShaderResourceUsageAMDBuilder<'a> {
    #[inline]
    pub fn num_used_vgprs(mut self, num_used_vgprs: u32) -> Self {
        self.inner.num_used_vgprs = num_used_vgprs;
        self
    }
    #[inline]
    pub fn num_used_sgprs(mut self, num_used_sgprs: u32) -> Self {
        self.inner.num_used_sgprs = num_used_sgprs;
        self
    }
    #[inline]
    pub fn lds_size_per_local_work_group(mut self, lds_size_per_local_work_group: u32) -> Self {
        self.inner.lds_size_per_local_work_group = lds_size_per_local_work_group;
        self
    }
    #[inline]
    pub fn lds_usage_size_in_bytes(mut self, lds_usage_size_in_bytes: usize) -> Self {
        self.inner.lds_usage_size_in_bytes = lds_usage_size_in_bytes;
        self
    }
    #[inline]
    pub fn scratch_mem_usage_in_bytes(mut self, scratch_mem_usage_in_bytes: usize) -> Self {
        self.inner.scratch_mem_usage_in_bytes = scratch_mem_usage_in_bytes;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ShaderResourceUsageAMD {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderStatisticsInfoAMD.html>"]
pub struct ShaderStatisticsInfoAMD {
    pub shader_stage_mask: ShaderStageFlags,
    pub resource_usage: ShaderResourceUsageAMD,
    pub num_physical_vgprs: u32,
    pub num_physical_sgprs: u32,
    pub num_available_vgprs: u32,
    pub num_available_sgprs: u32,
    pub compute_work_group_size: [u32; 3],
}
impl ::std::default::Default for ShaderStatisticsInfoAMD {
    #[inline]
    fn default() -> Self {
        Self {
            shader_stage_mask: ShaderStageFlags::default(),
            resource_usage: ShaderResourceUsageAMD::default(),
            num_physical_vgprs: u32::default(),
            num_physical_sgprs: u32::default(),
            num_available_vgprs: u32::default(),
            num_available_sgprs: u32::default(),
            compute_work_group_size: unsafe { ::std::mem::zeroed() },
        }
    }
}
impl ShaderStatisticsInfoAMD {
    pub fn builder<'a>() -> ShaderStatisticsInfoAMDBuilder<'a> {
        ShaderStatisticsInfoAMDBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ShaderStatisticsInfoAMDBuilder<'a> {
    inner: ShaderStatisticsInfoAMD,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ShaderStatisticsInfoAMDBuilder<'a> {
    type Target = ShaderStatisticsInfoAMD;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ShaderStatisticsInfoAMDBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ShaderStatisticsInfoAMDBuilder<'a> {
    #[inline]
    pub fn shader_stage_mask(mut self, shader_stage_mask: ShaderStageFlags) -> Self {
        self.inner.shader_stage_mask = shader_stage_mask;
        self
    }
    #[inline]
    pub fn resource_usage(mut self, resource_usage: ShaderResourceUsageAMD) -> Self {
        self.inner.resource_usage = resource_usage;
        self
    }
    #[inline]
    pub fn num_physical_vgprs(mut self, num_physical_vgprs: u32) -> Self {
        self.inner.num_physical_vgprs = num_physical_vgprs;
        self
    }
    #[inline]
    pub fn num_physical_sgprs(mut self, num_physical_sgprs: u32) -> Self {
        self.inner.num_physical_sgprs = num_physical_sgprs;
        self
    }
    #[inline]
    pub fn num_available_vgprs(mut self, num_available_vgprs: u32) -> Self {
        self.inner.num_available_vgprs = num_available_vgprs;
        self
    }
    #[inline]
    pub fn num_available_sgprs(mut self, num_available_sgprs: u32) -> Self {
        self.inner.num_available_sgprs = num_available_sgprs;
        self
    }
    #[inline]
    pub fn compute_work_group_size(mut self, compute_work_group_size: [u32; 3]) -> Self {
        self.inner.compute_work_group_size = compute_work_group_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ShaderStatisticsInfoAMD {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueGlobalPriorityCreateInfoKHR.html>"]
pub struct DeviceQueueGlobalPriorityCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub global_priority: QueueGlobalPriorityKHR,
}
impl ::std::default::Default for DeviceQueueGlobalPriorityCreateInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            global_priority: QueueGlobalPriorityKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for DeviceQueueGlobalPriorityCreateInfoKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR;
}
impl DeviceQueueGlobalPriorityCreateInfoKHR {
    pub fn builder<'a>() -> DeviceQueueGlobalPriorityCreateInfoKHRBuilder<'a> {
        DeviceQueueGlobalPriorityCreateInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceQueueGlobalPriorityCreateInfoKHRBuilder<'a> {
    inner: DeviceQueueGlobalPriorityCreateInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsDeviceQueueCreateInfo for DeviceQueueGlobalPriorityCreateInfoKHRBuilder<'_> {}
unsafe impl ExtendsDeviceQueueCreateInfo for DeviceQueueGlobalPriorityCreateInfoKHR {}
impl<'a> ::std::ops::Deref for DeviceQueueGlobalPriorityCreateInfoKHRBuilder<'a> {
    type Target = DeviceQueueGlobalPriorityCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceQueueGlobalPriorityCreateInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceQueueGlobalPriorityCreateInfoKHRBuilder<'a> {
    #[inline]
    pub fn global_priority(mut self, global_priority: QueueGlobalPriorityKHR) -> Self {
        self.inner.global_priority = global_priority;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceQueueGlobalPriorityCreateInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR.html>"]
pub struct PhysicalDeviceGlobalPriorityQueryFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub global_priority_query: Bool32,
}
impl ::std::default::Default for PhysicalDeviceGlobalPriorityQueryFeaturesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            global_priority_query: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceGlobalPriorityQueryFeaturesKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR;
}
impl PhysicalDeviceGlobalPriorityQueryFeaturesKHR {
    pub fn builder<'a>() -> PhysicalDeviceGlobalPriorityQueryFeaturesKHRBuilder<'a> {
        PhysicalDeviceGlobalPriorityQueryFeaturesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceGlobalPriorityQueryFeaturesKHRBuilder<'a> {
    inner: PhysicalDeviceGlobalPriorityQueryFeaturesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceGlobalPriorityQueryFeaturesKHRBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceGlobalPriorityQueryFeaturesKHR {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceGlobalPriorityQueryFeaturesKHRBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceGlobalPriorityQueryFeaturesKHR {}
impl<'a> ::std::ops::Deref for PhysicalDeviceGlobalPriorityQueryFeaturesKHRBuilder<'a> {
    type Target = PhysicalDeviceGlobalPriorityQueryFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceGlobalPriorityQueryFeaturesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceGlobalPriorityQueryFeaturesKHRBuilder<'a> {
    #[inline]
    pub fn global_priority_query(mut self, global_priority_query: bool) -> Self {
        self.inner.global_priority_query = global_priority_query.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceGlobalPriorityQueryFeaturesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyGlobalPriorityPropertiesKHR.html>"]
pub struct QueueFamilyGlobalPriorityPropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub priority_count: u32,
    pub priorities: [QueueGlobalPriorityKHR; MAX_GLOBAL_PRIORITY_SIZE_KHR],
}
impl ::std::default::Default for QueueFamilyGlobalPriorityPropertiesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            priority_count: u32::default(),
            priorities: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for QueueFamilyGlobalPriorityPropertiesKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR;
}
impl QueueFamilyGlobalPriorityPropertiesKHR {
    pub fn builder<'a>() -> QueueFamilyGlobalPriorityPropertiesKHRBuilder<'a> {
        QueueFamilyGlobalPriorityPropertiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct QueueFamilyGlobalPriorityPropertiesKHRBuilder<'a> {
    inner: QueueFamilyGlobalPriorityPropertiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsQueueFamilyProperties2 for QueueFamilyGlobalPriorityPropertiesKHRBuilder<'_> {}
unsafe impl ExtendsQueueFamilyProperties2 for QueueFamilyGlobalPriorityPropertiesKHR {}
impl<'a> ::std::ops::Deref for QueueFamilyGlobalPriorityPropertiesKHRBuilder<'a> {
    type Target = QueueFamilyGlobalPriorityPropertiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for QueueFamilyGlobalPriorityPropertiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> QueueFamilyGlobalPriorityPropertiesKHRBuilder<'a> {
    #[inline]
    pub fn priority_count(mut self, priority_count: u32) -> Self {
        self.inner.priority_count = priority_count;
        self
    }
    #[inline]
    pub fn priorities(
        mut self,
        priorities: [QueueGlobalPriorityKHR; MAX_GLOBAL_PRIORITY_SIZE_KHR],
    ) -> Self {
        self.inner.priorities = priorities;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> QueueFamilyGlobalPriorityPropertiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsObjectNameInfoEXT.html>"]
pub struct DebugUtilsObjectNameInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub object_type: ObjectType,
    pub object_handle: u64,
    pub p_object_name: *const c_char,
}
impl ::std::default::Default for DebugUtilsObjectNameInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            object_type: ObjectType::default(),
            object_handle: u64::default(),
            p_object_name: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for DebugUtilsObjectNameInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::DEBUG_UTILS_OBJECT_NAME_INFO_EXT;
}
impl DebugUtilsObjectNameInfoEXT {
    pub fn builder<'a>() -> DebugUtilsObjectNameInfoEXTBuilder<'a> {
        DebugUtilsObjectNameInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DebugUtilsObjectNameInfoEXTBuilder<'a> {
    inner: DebugUtilsObjectNameInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPipelineShaderStageCreateInfo for DebugUtilsObjectNameInfoEXTBuilder<'_> {}
unsafe impl ExtendsPipelineShaderStageCreateInfo for DebugUtilsObjectNameInfoEXT {}
impl<'a> ::std::ops::Deref for DebugUtilsObjectNameInfoEXTBuilder<'a> {
    type Target = DebugUtilsObjectNameInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DebugUtilsObjectNameInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DebugUtilsObjectNameInfoEXTBuilder<'a> {
    #[inline]
    pub fn object_type(mut self, object_type: ObjectType) -> Self {
        self.inner.object_type = object_type;
        self
    }
    #[inline]
    pub fn object_handle(mut self, object_handle: u64) -> Self {
        self.inner.object_handle = object_handle;
        self
    }
    #[inline]
    pub fn object_name(mut self, object_name: &'a ::std::ffi::CStr) -> Self {
        self.inner.p_object_name = object_name.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DebugUtilsObjectNameInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsObjectTagInfoEXT.html>"]
pub struct DebugUtilsObjectTagInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub object_type: ObjectType,
    pub object_handle: u64,
    pub tag_name: u64,
    pub tag_size: usize,
    pub p_tag: *const c_void,
}
impl ::std::default::Default for DebugUtilsObjectTagInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            object_type: ObjectType::default(),
            object_handle: u64::default(),
            tag_name: u64::default(),
            tag_size: usize::default(),
            p_tag: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for DebugUtilsObjectTagInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::DEBUG_UTILS_OBJECT_TAG_INFO_EXT;
}
impl DebugUtilsObjectTagInfoEXT {
    pub fn builder<'a>() -> DebugUtilsObjectTagInfoEXTBuilder<'a> {
        DebugUtilsObjectTagInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DebugUtilsObjectTagInfoEXTBuilder<'a> {
    inner: DebugUtilsObjectTagInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DebugUtilsObjectTagInfoEXTBuilder<'a> {
    type Target = DebugUtilsObjectTagInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DebugUtilsObjectTagInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DebugUtilsObjectTagInfoEXTBuilder<'a> {
    #[inline]
    pub fn object_type(mut self, object_type: ObjectType) -> Self {
        self.inner.object_type = object_type;
        self
    }
    #[inline]
    pub fn object_handle(mut self, object_handle: u64) -> Self {
        self.inner.object_handle = object_handle;
        self
    }
    #[inline]
    pub fn tag_name(mut self, tag_name: u64) -> Self {
        self.inner.tag_name = tag_name;
        self
    }
    #[inline]
    pub fn tag(mut self, tag: &'a [u8]) -> Self {
        self.inner.tag_size = tag.len();
        self.inner.p_tag = tag.as_ptr().cast();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DebugUtilsObjectTagInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsLabelEXT.html>"]
pub struct DebugUtilsLabelEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_label_name: *const c_char,
    pub color: [f32; 4],
}
impl ::std::default::Default for DebugUtilsLabelEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_label_name: ::std::ptr::null(),
            color: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for DebugUtilsLabelEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::DEBUG_UTILS_LABEL_EXT;
}
impl DebugUtilsLabelEXT {
    pub fn builder<'a>() -> DebugUtilsLabelEXTBuilder<'a> {
        DebugUtilsLabelEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DebugUtilsLabelEXTBuilder<'a> {
    inner: DebugUtilsLabelEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DebugUtilsLabelEXTBuilder<'a> {
    type Target = DebugUtilsLabelEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DebugUtilsLabelEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DebugUtilsLabelEXTBuilder<'a> {
    #[inline]
    pub fn label_name(mut self, label_name: &'a ::std::ffi::CStr) -> Self {
        self.inner.p_label_name = label_name.as_ptr();
        self
    }
    #[inline]
    pub fn color(mut self, color: [f32; 4]) -> Self {
        self.inner.color = color;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DebugUtilsLabelEXT {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCreateInfoEXT.html>"]
pub struct DebugUtilsMessengerCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DebugUtilsMessengerCreateFlagsEXT,
    pub message_severity: DebugUtilsMessageSeverityFlagsEXT,
    pub message_type: DebugUtilsMessageTypeFlagsEXT,
    pub pfn_user_callback: PFN_vkDebugUtilsMessengerCallbackEXT,
    pub p_user_data: *mut c_void,
}
#[cfg(feature = "debug")]
impl fmt::Debug for DebugUtilsMessengerCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DebugUtilsMessengerCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("message_severity", &self.message_severity)
            .field("message_type", &self.message_type)
            .field(
                "pfn_user_callback",
                &(self.pfn_user_callback.map(|x| x as *const ())),
            )
            .field("p_user_data", &self.p_user_data)
            .finish()
    }
}
impl ::std::default::Default for DebugUtilsMessengerCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DebugUtilsMessengerCreateFlagsEXT::default(),
            message_severity: DebugUtilsMessageSeverityFlagsEXT::default(),
            message_type: DebugUtilsMessageTypeFlagsEXT::default(),
            pfn_user_callback: PFN_vkDebugUtilsMessengerCallbackEXT::default(),
            p_user_data: ::std::ptr::null_mut(),
        }
    }
}
unsafe impl TaggedStructure for DebugUtilsMessengerCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
}
impl DebugUtilsMessengerCreateInfoEXT {
    pub fn builder<'a>() -> DebugUtilsMessengerCreateInfoEXTBuilder<'a> {
        DebugUtilsMessengerCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DebugUtilsMessengerCreateInfoEXTBuilder<'a> {
    inner: DebugUtilsMessengerCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsInstanceCreateInfo for DebugUtilsMessengerCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsInstanceCreateInfo for DebugUtilsMessengerCreateInfoEXT {}
impl<'a> ::std::ops::Deref for DebugUtilsMessengerCreateInfoEXTBuilder<'a> {
    type Target = DebugUtilsMessengerCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DebugUtilsMessengerCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DebugUtilsMessengerCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: DebugUtilsMessengerCreateFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn message_severity(mut self, message_severity: DebugUtilsMessageSeverityFlagsEXT) -> Self {
        self.inner.message_severity = message_severity;
        self
    }
    #[inline]
    pub fn message_type(mut self, message_type: DebugUtilsMessageTypeFlagsEXT) -> Self {
        self.inner.message_type = message_type;
        self
    }
    #[inline]
    pub fn pfn_user_callback(
        mut self,
        pfn_user_callback: PFN_vkDebugUtilsMessengerCallbackEXT,
    ) -> Self {
        self.inner.pfn_user_callback = pfn_user_callback;
        self
    }
    #[inline]
    pub fn user_data(mut self, user_data: *mut c_void) -> Self {
        self.inner.p_user_data = user_data;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DebugUtilsMessengerCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCallbackDataEXT.html>"]
pub struct DebugUtilsMessengerCallbackDataEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DebugUtilsMessengerCallbackDataFlagsEXT,
    pub p_message_id_name: *const c_char,
    pub message_id_number: i32,
    pub p_message: *const c_char,
    pub queue_label_count: u32,
    pub p_queue_labels: *const DebugUtilsLabelEXT,
    pub cmd_buf_label_count: u32,
    pub p_cmd_buf_labels: *const DebugUtilsLabelEXT,
    pub object_count: u32,
    pub p_objects: *const DebugUtilsObjectNameInfoEXT,
}
impl ::std::default::Default for DebugUtilsMessengerCallbackDataEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DebugUtilsMessengerCallbackDataFlagsEXT::default(),
            p_message_id_name: ::std::ptr::null(),
            message_id_number: i32::default(),
            p_message: ::std::ptr::null(),
            queue_label_count: u32::default(),
            p_queue_labels: ::std::ptr::null(),
            cmd_buf_label_count: u32::default(),
            p_cmd_buf_labels: ::std::ptr::null(),
            object_count: u32::default(),
            p_objects: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for DebugUtilsMessengerCallbackDataEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT;
}
impl DebugUtilsMessengerCallbackDataEXT {
    pub fn builder<'a>() -> DebugUtilsMessengerCallbackDataEXTBuilder<'a> {
        DebugUtilsMessengerCallbackDataEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DebugUtilsMessengerCallbackDataEXTBuilder<'a> {
    inner: DebugUtilsMessengerCallbackDataEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsDebugUtilsMessengerCallbackDataEXT {}
impl<'a> ::std::ops::Deref for DebugUtilsMessengerCallbackDataEXTBuilder<'a> {
    type Target = DebugUtilsMessengerCallbackDataEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DebugUtilsMessengerCallbackDataEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DebugUtilsMessengerCallbackDataEXTBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: DebugUtilsMessengerCallbackDataFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn message_id_name(mut self, message_id_name: &'a ::std::ffi::CStr) -> Self {
        self.inner.p_message_id_name = message_id_name.as_ptr();
        self
    }
    #[inline]
    pub fn message_id_number(mut self, message_id_number: i32) -> Self {
        self.inner.message_id_number = message_id_number;
        self
    }
    #[inline]
    pub fn message(mut self, message: &'a ::std::ffi::CStr) -> Self {
        self.inner.p_message = message.as_ptr();
        self
    }
    #[inline]
    pub fn queue_labels(mut self, queue_labels: &'a [DebugUtilsLabelEXT]) -> Self {
        self.inner.queue_label_count = queue_labels.len() as _;
        self.inner.p_queue_labels = queue_labels.as_ptr();
        self
    }
    #[inline]
    pub fn cmd_buf_labels(mut self, cmd_buf_labels: &'a [DebugUtilsLabelEXT]) -> Self {
        self.inner.cmd_buf_label_count = cmd_buf_labels.len() as _;
        self.inner.p_cmd_buf_labels = cmd_buf_labels.as_ptr();
        self
    }
    #[inline]
    pub fn objects(mut self, objects: &'a [DebugUtilsObjectNameInfoEXT]) -> Self {
        self.inner.object_count = objects.len() as _;
        self.inner.p_objects = objects.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsDebugUtilsMessengerCallbackDataEXT>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DebugUtilsMessengerCallbackDataEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDeviceMemoryReportFeaturesEXT.html>"]
pub struct PhysicalDeviceDeviceMemoryReportFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_memory_report: Bool32,
}
impl ::std::default::Default for PhysicalDeviceDeviceMemoryReportFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            device_memory_report: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceDeviceMemoryReportFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT;
}
impl PhysicalDeviceDeviceMemoryReportFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceDeviceMemoryReportFeaturesEXTBuilder<'a> {
        PhysicalDeviceDeviceMemoryReportFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceDeviceMemoryReportFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceDeviceMemoryReportFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceDeviceMemoryReportFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDeviceMemoryReportFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDeviceMemoryReportFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDeviceMemoryReportFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceDeviceMemoryReportFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceDeviceMemoryReportFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceDeviceMemoryReportFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceDeviceMemoryReportFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn device_memory_report(mut self, device_memory_report: bool) -> Self {
        self.inner.device_memory_report = device_memory_report.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceDeviceMemoryReportFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceDeviceMemoryReportCreateInfoEXT.html>"]
pub struct DeviceDeviceMemoryReportCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DeviceMemoryReportFlagsEXT,
    pub pfn_user_callback: PFN_vkDeviceMemoryReportCallbackEXT,
    pub p_user_data: *mut c_void,
}
#[cfg(feature = "debug")]
impl fmt::Debug for DeviceDeviceMemoryReportCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceDeviceMemoryReportCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field(
                "pfn_user_callback",
                &(self.pfn_user_callback.map(|x| x as *const ())),
            )
            .field("p_user_data", &self.p_user_data)
            .finish()
    }
}
impl ::std::default::Default for DeviceDeviceMemoryReportCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DeviceMemoryReportFlagsEXT::default(),
            pfn_user_callback: PFN_vkDeviceMemoryReportCallbackEXT::default(),
            p_user_data: ::std::ptr::null_mut(),
        }
    }
}
unsafe impl TaggedStructure for DeviceDeviceMemoryReportCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT;
}
impl DeviceDeviceMemoryReportCreateInfoEXT {
    pub fn builder<'a>() -> DeviceDeviceMemoryReportCreateInfoEXTBuilder<'a> {
        DeviceDeviceMemoryReportCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceDeviceMemoryReportCreateInfoEXTBuilder<'a> {
    inner: DeviceDeviceMemoryReportCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsDeviceCreateInfo for DeviceDeviceMemoryReportCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for DeviceDeviceMemoryReportCreateInfoEXT {}
impl<'a> ::std::ops::Deref for DeviceDeviceMemoryReportCreateInfoEXTBuilder<'a> {
    type Target = DeviceDeviceMemoryReportCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceDeviceMemoryReportCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceDeviceMemoryReportCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: DeviceMemoryReportFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn pfn_user_callback(
        mut self,
        pfn_user_callback: PFN_vkDeviceMemoryReportCallbackEXT,
    ) -> Self {
        self.inner.pfn_user_callback = pfn_user_callback;
        self
    }
    #[inline]
    pub fn user_data(mut self, user_data: *mut c_void) -> Self {
        self.inner.p_user_data = user_data;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceDeviceMemoryReportCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceMemoryReportCallbackDataEXT.html>"]
pub struct DeviceMemoryReportCallbackDataEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub flags: DeviceMemoryReportFlagsEXT,
    pub ty: DeviceMemoryReportEventTypeEXT,
    pub memory_object_id: u64,
    pub size: DeviceSize,
    pub object_type: ObjectType,
    pub object_handle: u64,
    pub heap_index: u32,
}
impl ::std::default::Default for DeviceMemoryReportCallbackDataEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            flags: DeviceMemoryReportFlagsEXT::default(),
            ty: DeviceMemoryReportEventTypeEXT::default(),
            memory_object_id: u64::default(),
            size: DeviceSize::default(),
            object_type: ObjectType::default(),
            object_handle: u64::default(),
            heap_index: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for DeviceMemoryReportCallbackDataEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT;
}
impl DeviceMemoryReportCallbackDataEXT {
    pub fn builder<'a>() -> DeviceMemoryReportCallbackDataEXTBuilder<'a> {
        DeviceMemoryReportCallbackDataEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceMemoryReportCallbackDataEXTBuilder<'a> {
    inner: DeviceMemoryReportCallbackDataEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DeviceMemoryReportCallbackDataEXTBuilder<'a> {
    type Target = DeviceMemoryReportCallbackDataEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceMemoryReportCallbackDataEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceMemoryReportCallbackDataEXTBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: DeviceMemoryReportFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn ty(mut self, ty: DeviceMemoryReportEventTypeEXT) -> Self {
        self.inner.ty = ty;
        self
    }
    #[inline]
    pub fn memory_object_id(mut self, memory_object_id: u64) -> Self {
        self.inner.memory_object_id = memory_object_id;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    #[inline]
    pub fn object_type(mut self, object_type: ObjectType) -> Self {
        self.inner.object_type = object_type;
        self
    }
    #[inline]
    pub fn object_handle(mut self, object_handle: u64) -> Self {
        self.inner.object_handle = object_handle;
        self
    }
    #[inline]
    pub fn heap_index(mut self, heap_index: u32) -> Self {
        self.inner.heap_index = heap_index;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceMemoryReportCallbackDataEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMemoryHostPointerInfoEXT.html>"]
pub struct ImportMemoryHostPointerInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub handle_type: ExternalMemoryHandleTypeFlags,
    pub p_host_pointer: *mut c_void,
}
impl ::std::default::Default for ImportMemoryHostPointerInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
            p_host_pointer: ::std::ptr::null_mut(),
        }
    }
}
unsafe impl TaggedStructure for ImportMemoryHostPointerInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_MEMORY_HOST_POINTER_INFO_EXT;
}
impl ImportMemoryHostPointerInfoEXT {
    pub fn builder<'a>() -> ImportMemoryHostPointerInfoEXTBuilder<'a> {
        ImportMemoryHostPointerInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImportMemoryHostPointerInfoEXTBuilder<'a> {
    inner: ImportMemoryHostPointerInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsMemoryAllocateInfo for ImportMemoryHostPointerInfoEXTBuilder<'_> {}
unsafe impl ExtendsMemoryAllocateInfo for ImportMemoryHostPointerInfoEXT {}
impl<'a> ::std::ops::Deref for ImportMemoryHostPointerInfoEXTBuilder<'a> {
    type Target = ImportMemoryHostPointerInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImportMemoryHostPointerInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImportMemoryHostPointerInfoEXTBuilder<'a> {
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    #[inline]
    pub fn host_pointer(mut self, host_pointer: *mut c_void) -> Self {
        self.inner.p_host_pointer = host_pointer;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImportMemoryHostPointerInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryHostPointerPropertiesEXT.html>"]
pub struct MemoryHostPointerPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_type_bits: u32,
}
impl ::std::default::Default for MemoryHostPointerPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            memory_type_bits: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for MemoryHostPointerPropertiesEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_HOST_POINTER_PROPERTIES_EXT;
}
impl MemoryHostPointerPropertiesEXT {
    pub fn builder<'a>() -> MemoryHostPointerPropertiesEXTBuilder<'a> {
        MemoryHostPointerPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MemoryHostPointerPropertiesEXTBuilder<'a> {
    inner: MemoryHostPointerPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MemoryHostPointerPropertiesEXTBuilder<'a> {
    type Target = MemoryHostPointerPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MemoryHostPointerPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MemoryHostPointerPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn memory_type_bits(mut self, memory_type_bits: u32) -> Self {
        self.inner.memory_type_bits = memory_type_bits;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MemoryHostPointerPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalMemoryHostPropertiesEXT.html>"]
pub struct PhysicalDeviceExternalMemoryHostPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_imported_host_pointer_alignment: DeviceSize,
}
impl ::std::default::Default for PhysicalDeviceExternalMemoryHostPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            min_imported_host_pointer_alignment: DeviceSize::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceExternalMemoryHostPropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT;
}
impl PhysicalDeviceExternalMemoryHostPropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceExternalMemoryHostPropertiesEXTBuilder<'a> {
        PhysicalDeviceExternalMemoryHostPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceExternalMemoryHostPropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceExternalMemoryHostPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceExternalMemoryHostPropertiesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceExternalMemoryHostPropertiesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceExternalMemoryHostPropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceExternalMemoryHostPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceExternalMemoryHostPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceExternalMemoryHostPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn min_imported_host_pointer_alignment(
        mut self,
        min_imported_host_pointer_alignment: DeviceSize,
    ) -> Self {
        self.inner.min_imported_host_pointer_alignment = min_imported_host_pointer_alignment;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceExternalMemoryHostPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceConservativeRasterizationPropertiesEXT.html>"]
pub struct PhysicalDeviceConservativeRasterizationPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub primitive_overestimation_size: f32,
    pub max_extra_primitive_overestimation_size: f32,
    pub extra_primitive_overestimation_size_granularity: f32,
    pub primitive_underestimation: Bool32,
    pub conservative_point_and_line_rasterization: Bool32,
    pub degenerate_triangles_rasterized: Bool32,
    pub degenerate_lines_rasterized: Bool32,
    pub fully_covered_fragment_shader_input_variable: Bool32,
    pub conservative_rasterization_post_depth_coverage: Bool32,
}
impl ::std::default::Default for PhysicalDeviceConservativeRasterizationPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            primitive_overestimation_size: f32::default(),
            max_extra_primitive_overestimation_size: f32::default(),
            extra_primitive_overestimation_size_granularity: f32::default(),
            primitive_underestimation: Bool32::default(),
            conservative_point_and_line_rasterization: Bool32::default(),
            degenerate_triangles_rasterized: Bool32::default(),
            degenerate_lines_rasterized: Bool32::default(),
            fully_covered_fragment_shader_input_variable: Bool32::default(),
            conservative_rasterization_post_depth_coverage: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceConservativeRasterizationPropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT;
}
impl PhysicalDeviceConservativeRasterizationPropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceConservativeRasterizationPropertiesEXTBuilder<'a> {
        PhysicalDeviceConservativeRasterizationPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceConservativeRasterizationPropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceConservativeRasterizationPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceConservativeRasterizationPropertiesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceConservativeRasterizationPropertiesEXT
{
}
impl<'a> ::std::ops::Deref for PhysicalDeviceConservativeRasterizationPropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceConservativeRasterizationPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceConservativeRasterizationPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceConservativeRasterizationPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn primitive_overestimation_size(mut self, primitive_overestimation_size: f32) -> Self {
        self.inner.primitive_overestimation_size = primitive_overestimation_size;
        self
    }
    #[inline]
    pub fn max_extra_primitive_overestimation_size(
        mut self,
        max_extra_primitive_overestimation_size: f32,
    ) -> Self {
        self.inner.max_extra_primitive_overestimation_size =
            max_extra_primitive_overestimation_size;
        self
    }
    #[inline]
    pub fn extra_primitive_overestimation_size_granularity(
        mut self,
        extra_primitive_overestimation_size_granularity: f32,
    ) -> Self {
        self.inner.extra_primitive_overestimation_size_granularity =
            extra_primitive_overestimation_size_granularity;
        self
    }
    #[inline]
    pub fn primitive_underestimation(mut self, primitive_underestimation: bool) -> Self {
        self.inner.primitive_underestimation = primitive_underestimation.into();
        self
    }
    #[inline]
    pub fn conservative_point_and_line_rasterization(
        mut self,
        conservative_point_and_line_rasterization: bool,
    ) -> Self {
        self.inner.conservative_point_and_line_rasterization =
            conservative_point_and_line_rasterization.into();
        self
    }
    #[inline]
    pub fn degenerate_triangles_rasterized(
        mut self,
        degenerate_triangles_rasterized: bool,
    ) -> Self {
        self.inner.degenerate_triangles_rasterized = degenerate_triangles_rasterized.into();
        self
    }
    #[inline]
    pub fn degenerate_lines_rasterized(mut self, degenerate_lines_rasterized: bool) -> Self {
        self.inner.degenerate_lines_rasterized = degenerate_lines_rasterized.into();
        self
    }
    #[inline]
    pub fn fully_covered_fragment_shader_input_variable(
        mut self,
        fully_covered_fragment_shader_input_variable: bool,
    ) -> Self {
        self.inner.fully_covered_fragment_shader_input_variable =
            fully_covered_fragment_shader_input_variable.into();
        self
    }
    #[inline]
    pub fn conservative_rasterization_post_depth_coverage(
        mut self,
        conservative_rasterization_post_depth_coverage: bool,
    ) -> Self {
        self.inner.conservative_rasterization_post_depth_coverage =
            conservative_rasterization_post_depth_coverage.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceConservativeRasterizationPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCalibratedTimestampInfoEXT.html>"]
pub struct CalibratedTimestampInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub time_domain: TimeDomainEXT,
}
impl ::std::default::Default for CalibratedTimestampInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            time_domain: TimeDomainEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for CalibratedTimestampInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::CALIBRATED_TIMESTAMP_INFO_EXT;
}
impl CalibratedTimestampInfoEXT {
    pub fn builder<'a>() -> CalibratedTimestampInfoEXTBuilder<'a> {
        CalibratedTimestampInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CalibratedTimestampInfoEXTBuilder<'a> {
    inner: CalibratedTimestampInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CalibratedTimestampInfoEXTBuilder<'a> {
    type Target = CalibratedTimestampInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CalibratedTimestampInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CalibratedTimestampInfoEXTBuilder<'a> {
    #[inline]
    pub fn time_domain(mut self, time_domain: TimeDomainEXT) -> Self {
        self.inner.time_domain = time_domain;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CalibratedTimestampInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderCorePropertiesAMD.html>"]
pub struct PhysicalDeviceShaderCorePropertiesAMD {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_engine_count: u32,
    pub shader_arrays_per_engine_count: u32,
    pub compute_units_per_shader_array: u32,
    pub simd_per_compute_unit: u32,
    pub wavefronts_per_simd: u32,
    pub wavefront_size: u32,
    pub sgprs_per_simd: u32,
    pub min_sgpr_allocation: u32,
    pub max_sgpr_allocation: u32,
    pub sgpr_allocation_granularity: u32,
    pub vgprs_per_simd: u32,
    pub min_vgpr_allocation: u32,
    pub max_vgpr_allocation: u32,
    pub vgpr_allocation_granularity: u32,
}
impl ::std::default::Default for PhysicalDeviceShaderCorePropertiesAMD {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_engine_count: u32::default(),
            shader_arrays_per_engine_count: u32::default(),
            compute_units_per_shader_array: u32::default(),
            simd_per_compute_unit: u32::default(),
            wavefronts_per_simd: u32::default(),
            wavefront_size: u32::default(),
            sgprs_per_simd: u32::default(),
            min_sgpr_allocation: u32::default(),
            max_sgpr_allocation: u32::default(),
            sgpr_allocation_granularity: u32::default(),
            vgprs_per_simd: u32::default(),
            min_vgpr_allocation: u32::default(),
            max_vgpr_allocation: u32::default(),
            vgpr_allocation_granularity: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderCorePropertiesAMD {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD;
}
impl PhysicalDeviceShaderCorePropertiesAMD {
    pub fn builder<'a>() -> PhysicalDeviceShaderCorePropertiesAMDBuilder<'a> {
        PhysicalDeviceShaderCorePropertiesAMDBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderCorePropertiesAMDBuilder<'a> {
    inner: PhysicalDeviceShaderCorePropertiesAMD,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceShaderCorePropertiesAMDBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceShaderCorePropertiesAMD {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderCorePropertiesAMDBuilder<'a> {
    type Target = PhysicalDeviceShaderCorePropertiesAMD;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderCorePropertiesAMDBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderCorePropertiesAMDBuilder<'a> {
    #[inline]
    pub fn shader_engine_count(mut self, shader_engine_count: u32) -> Self {
        self.inner.shader_engine_count = shader_engine_count;
        self
    }
    #[inline]
    pub fn shader_arrays_per_engine_count(mut self, shader_arrays_per_engine_count: u32) -> Self {
        self.inner.shader_arrays_per_engine_count = shader_arrays_per_engine_count;
        self
    }
    #[inline]
    pub fn compute_units_per_shader_array(mut self, compute_units_per_shader_array: u32) -> Self {
        self.inner.compute_units_per_shader_array = compute_units_per_shader_array;
        self
    }
    #[inline]
    pub fn simd_per_compute_unit(mut self, simd_per_compute_unit: u32) -> Self {
        self.inner.simd_per_compute_unit = simd_per_compute_unit;
        self
    }
    #[inline]
    pub fn wavefronts_per_simd(mut self, wavefronts_per_simd: u32) -> Self {
        self.inner.wavefronts_per_simd = wavefronts_per_simd;
        self
    }
    #[inline]
    pub fn wavefront_size(mut self, wavefront_size: u32) -> Self {
        self.inner.wavefront_size = wavefront_size;
        self
    }
    #[inline]
    pub fn sgprs_per_simd(mut self, sgprs_per_simd: u32) -> Self {
        self.inner.sgprs_per_simd = sgprs_per_simd;
        self
    }
    #[inline]
    pub fn min_sgpr_allocation(mut self, min_sgpr_allocation: u32) -> Self {
        self.inner.min_sgpr_allocation = min_sgpr_allocation;
        self
    }
    #[inline]
    pub fn max_sgpr_allocation(mut self, max_sgpr_allocation: u32) -> Self {
        self.inner.max_sgpr_allocation = max_sgpr_allocation;
        self
    }
    #[inline]
    pub fn sgpr_allocation_granularity(mut self, sgpr_allocation_granularity: u32) -> Self {
        self.inner.sgpr_allocation_granularity = sgpr_allocation_granularity;
        self
    }
    #[inline]
    pub fn vgprs_per_simd(mut self, vgprs_per_simd: u32) -> Self {
        self.inner.vgprs_per_simd = vgprs_per_simd;
        self
    }
    #[inline]
    pub fn min_vgpr_allocation(mut self, min_vgpr_allocation: u32) -> Self {
        self.inner.min_vgpr_allocation = min_vgpr_allocation;
        self
    }
    #[inline]
    pub fn max_vgpr_allocation(mut self, max_vgpr_allocation: u32) -> Self {
        self.inner.max_vgpr_allocation = max_vgpr_allocation;
        self
    }
    #[inline]
    pub fn vgpr_allocation_granularity(mut self, vgpr_allocation_granularity: u32) -> Self {
        self.inner.vgpr_allocation_granularity = vgpr_allocation_granularity;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderCorePropertiesAMD {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderCoreProperties2AMD.html>"]
pub struct PhysicalDeviceShaderCoreProperties2AMD {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_core_features: ShaderCorePropertiesFlagsAMD,
    pub active_compute_unit_count: u32,
}
impl ::std::default::Default for PhysicalDeviceShaderCoreProperties2AMD {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_core_features: ShaderCorePropertiesFlagsAMD::default(),
            active_compute_unit_count: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderCoreProperties2AMD {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD;
}
impl PhysicalDeviceShaderCoreProperties2AMD {
    pub fn builder<'a>() -> PhysicalDeviceShaderCoreProperties2AMDBuilder<'a> {
        PhysicalDeviceShaderCoreProperties2AMDBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderCoreProperties2AMDBuilder<'a> {
    inner: PhysicalDeviceShaderCoreProperties2AMD,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceShaderCoreProperties2AMDBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceShaderCoreProperties2AMD {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderCoreProperties2AMDBuilder<'a> {
    type Target = PhysicalDeviceShaderCoreProperties2AMD;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderCoreProperties2AMDBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderCoreProperties2AMDBuilder<'a> {
    #[inline]
    pub fn shader_core_features(
        mut self,
        shader_core_features: ShaderCorePropertiesFlagsAMD,
    ) -> Self {
        self.inner.shader_core_features = shader_core_features;
        self
    }
    #[inline]
    pub fn active_compute_unit_count(mut self, active_compute_unit_count: u32) -> Self {
        self.inner.active_compute_unit_count = active_compute_unit_count;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderCoreProperties2AMD {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationConservativeStateCreateInfoEXT.html>"]
pub struct PipelineRasterizationConservativeStateCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineRasterizationConservativeStateCreateFlagsEXT,
    pub conservative_rasterization_mode: ConservativeRasterizationModeEXT,
    pub extra_primitive_overestimation_size: f32,
}
impl ::std::default::Default for PipelineRasterizationConservativeStateCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineRasterizationConservativeStateCreateFlagsEXT::default(),
            conservative_rasterization_mode: ConservativeRasterizationModeEXT::default(),
            extra_primitive_overestimation_size: f32::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineRasterizationConservativeStateCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT;
}
impl PipelineRasterizationConservativeStateCreateInfoEXT {
    pub fn builder<'a>() -> PipelineRasterizationConservativeStateCreateInfoEXTBuilder<'a> {
        PipelineRasterizationConservativeStateCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineRasterizationConservativeStateCreateInfoEXTBuilder<'a> {
    inner: PipelineRasterizationConservativeStateCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPipelineRasterizationStateCreateInfo
    for PipelineRasterizationConservativeStateCreateInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsPipelineRasterizationStateCreateInfo
    for PipelineRasterizationConservativeStateCreateInfoEXT
{
}
impl<'a> ::std::ops::Deref for PipelineRasterizationConservativeStateCreateInfoEXTBuilder<'a> {
    type Target = PipelineRasterizationConservativeStateCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineRasterizationConservativeStateCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineRasterizationConservativeStateCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineRasterizationConservativeStateCreateFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn conservative_rasterization_mode(
        mut self,
        conservative_rasterization_mode: ConservativeRasterizationModeEXT,
    ) -> Self {
        self.inner.conservative_rasterization_mode = conservative_rasterization_mode;
        self
    }
    #[inline]
    pub fn extra_primitive_overestimation_size(
        mut self,
        extra_primitive_overestimation_size: f32,
    ) -> Self {
        self.inner.extra_primitive_overestimation_size = extra_primitive_overestimation_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineRasterizationConservativeStateCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorIndexingFeatures.html>"]
pub struct PhysicalDeviceDescriptorIndexingFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_input_attachment_array_dynamic_indexing: Bool32,
    pub shader_uniform_texel_buffer_array_dynamic_indexing: Bool32,
    pub shader_storage_texel_buffer_array_dynamic_indexing: Bool32,
    pub shader_uniform_buffer_array_non_uniform_indexing: Bool32,
    pub shader_sampled_image_array_non_uniform_indexing: Bool32,
    pub shader_storage_buffer_array_non_uniform_indexing: Bool32,
    pub shader_storage_image_array_non_uniform_indexing: Bool32,
    pub shader_input_attachment_array_non_uniform_indexing: Bool32,
    pub shader_uniform_texel_buffer_array_non_uniform_indexing: Bool32,
    pub shader_storage_texel_buffer_array_non_uniform_indexing: Bool32,
    pub descriptor_binding_uniform_buffer_update_after_bind: Bool32,
    pub descriptor_binding_sampled_image_update_after_bind: Bool32,
    pub descriptor_binding_storage_image_update_after_bind: Bool32,
    pub descriptor_binding_storage_buffer_update_after_bind: Bool32,
    pub descriptor_binding_uniform_texel_buffer_update_after_bind: Bool32,
    pub descriptor_binding_storage_texel_buffer_update_after_bind: Bool32,
    pub descriptor_binding_update_unused_while_pending: Bool32,
    pub descriptor_binding_partially_bound: Bool32,
    pub descriptor_binding_variable_descriptor_count: Bool32,
    pub runtime_descriptor_array: Bool32,
}
impl ::std::default::Default for PhysicalDeviceDescriptorIndexingFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_input_attachment_array_dynamic_indexing: Bool32::default(),
            shader_uniform_texel_buffer_array_dynamic_indexing: Bool32::default(),
            shader_storage_texel_buffer_array_dynamic_indexing: Bool32::default(),
            shader_uniform_buffer_array_non_uniform_indexing: Bool32::default(),
            shader_sampled_image_array_non_uniform_indexing: Bool32::default(),
            shader_storage_buffer_array_non_uniform_indexing: Bool32::default(),
            shader_storage_image_array_non_uniform_indexing: Bool32::default(),
            shader_input_attachment_array_non_uniform_indexing: Bool32::default(),
            shader_uniform_texel_buffer_array_non_uniform_indexing: Bool32::default(),
            shader_storage_texel_buffer_array_non_uniform_indexing: Bool32::default(),
            descriptor_binding_uniform_buffer_update_after_bind: Bool32::default(),
            descriptor_binding_sampled_image_update_after_bind: Bool32::default(),
            descriptor_binding_storage_image_update_after_bind: Bool32::default(),
            descriptor_binding_storage_buffer_update_after_bind: Bool32::default(),
            descriptor_binding_uniform_texel_buffer_update_after_bind: Bool32::default(),
            descriptor_binding_storage_texel_buffer_update_after_bind: Bool32::default(),
            descriptor_binding_update_unused_while_pending: Bool32::default(),
            descriptor_binding_partially_bound: Bool32::default(),
            descriptor_binding_variable_descriptor_count: Bool32::default(),
            runtime_descriptor_array: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceDescriptorIndexingFeatures {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
}
impl PhysicalDeviceDescriptorIndexingFeatures {
    pub fn builder<'a>() -> PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
        PhysicalDeviceDescriptorIndexingFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
    inner: PhysicalDeviceDescriptorIndexingFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDescriptorIndexingFeaturesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDescriptorIndexingFeatures {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDescriptorIndexingFeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDescriptorIndexingFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
    type Target = PhysicalDeviceDescriptorIndexingFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
    #[inline]
    pub fn shader_input_attachment_array_dynamic_indexing(
        mut self,
        shader_input_attachment_array_dynamic_indexing: bool,
    ) -> Self {
        self.inner.shader_input_attachment_array_dynamic_indexing =
            shader_input_attachment_array_dynamic_indexing.into();
        self
    }
    #[inline]
    pub fn shader_uniform_texel_buffer_array_dynamic_indexing(
        mut self,
        shader_uniform_texel_buffer_array_dynamic_indexing: bool,
    ) -> Self {
        self.inner
            .shader_uniform_texel_buffer_array_dynamic_indexing =
            shader_uniform_texel_buffer_array_dynamic_indexing.into();
        self
    }
    #[inline]
    pub fn shader_storage_texel_buffer_array_dynamic_indexing(
        mut self,
        shader_storage_texel_buffer_array_dynamic_indexing: bool,
    ) -> Self {
        self.inner
            .shader_storage_texel_buffer_array_dynamic_indexing =
            shader_storage_texel_buffer_array_dynamic_indexing.into();
        self
    }
    #[inline]
    pub fn shader_uniform_buffer_array_non_uniform_indexing(
        mut self,
        shader_uniform_buffer_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner.shader_uniform_buffer_array_non_uniform_indexing =
            shader_uniform_buffer_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn shader_sampled_image_array_non_uniform_indexing(
        mut self,
        shader_sampled_image_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner.shader_sampled_image_array_non_uniform_indexing =
            shader_sampled_image_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn shader_storage_buffer_array_non_uniform_indexing(
        mut self,
        shader_storage_buffer_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner.shader_storage_buffer_array_non_uniform_indexing =
            shader_storage_buffer_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_array_non_uniform_indexing(
        mut self,
        shader_storage_image_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner.shader_storage_image_array_non_uniform_indexing =
            shader_storage_image_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn shader_input_attachment_array_non_uniform_indexing(
        mut self,
        shader_input_attachment_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner
            .shader_input_attachment_array_non_uniform_indexing =
            shader_input_attachment_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn shader_uniform_texel_buffer_array_non_uniform_indexing(
        mut self,
        shader_uniform_texel_buffer_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner
            .shader_uniform_texel_buffer_array_non_uniform_indexing =
            shader_uniform_texel_buffer_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn shader_storage_texel_buffer_array_non_uniform_indexing(
        mut self,
        shader_storage_texel_buffer_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner
            .shader_storage_texel_buffer_array_non_uniform_indexing =
            shader_storage_texel_buffer_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_uniform_buffer_update_after_bind(
        mut self,
        descriptor_binding_uniform_buffer_update_after_bind: bool,
    ) -> Self {
        self.inner
            .descriptor_binding_uniform_buffer_update_after_bind =
            descriptor_binding_uniform_buffer_update_after_bind.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_sampled_image_update_after_bind(
        mut self,
        descriptor_binding_sampled_image_update_after_bind: bool,
    ) -> Self {
        self.inner
            .descriptor_binding_sampled_image_update_after_bind =
            descriptor_binding_sampled_image_update_after_bind.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_storage_image_update_after_bind(
        mut self,
        descriptor_binding_storage_image_update_after_bind: bool,
    ) -> Self {
        self.inner
            .descriptor_binding_storage_image_update_after_bind =
            descriptor_binding_storage_image_update_after_bind.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_storage_buffer_update_after_bind(
        mut self,
        descriptor_binding_storage_buffer_update_after_bind: bool,
    ) -> Self {
        self.inner
            .descriptor_binding_storage_buffer_update_after_bind =
            descriptor_binding_storage_buffer_update_after_bind.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_uniform_texel_buffer_update_after_bind(
        mut self,
        descriptor_binding_uniform_texel_buffer_update_after_bind: bool,
    ) -> Self {
        self.inner
            .descriptor_binding_uniform_texel_buffer_update_after_bind =
            descriptor_binding_uniform_texel_buffer_update_after_bind.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_storage_texel_buffer_update_after_bind(
        mut self,
        descriptor_binding_storage_texel_buffer_update_after_bind: bool,
    ) -> Self {
        self.inner
            .descriptor_binding_storage_texel_buffer_update_after_bind =
            descriptor_binding_storage_texel_buffer_update_after_bind.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_update_unused_while_pending(
        mut self,
        descriptor_binding_update_unused_while_pending: bool,
    ) -> Self {
        self.inner.descriptor_binding_update_unused_while_pending =
            descriptor_binding_update_unused_while_pending.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_partially_bound(
        mut self,
        descriptor_binding_partially_bound: bool,
    ) -> Self {
        self.inner.descriptor_binding_partially_bound = descriptor_binding_partially_bound.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_variable_descriptor_count(
        mut self,
        descriptor_binding_variable_descriptor_count: bool,
    ) -> Self {
        self.inner.descriptor_binding_variable_descriptor_count =
            descriptor_binding_variable_descriptor_count.into();
        self
    }
    #[inline]
    pub fn runtime_descriptor_array(mut self, runtime_descriptor_array: bool) -> Self {
        self.inner.runtime_descriptor_array = runtime_descriptor_array.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceDescriptorIndexingFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorIndexingProperties.html>"]
pub struct PhysicalDeviceDescriptorIndexingProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_update_after_bind_descriptors_in_all_pools: u32,
    pub shader_uniform_buffer_array_non_uniform_indexing_native: Bool32,
    pub shader_sampled_image_array_non_uniform_indexing_native: Bool32,
    pub shader_storage_buffer_array_non_uniform_indexing_native: Bool32,
    pub shader_storage_image_array_non_uniform_indexing_native: Bool32,
    pub shader_input_attachment_array_non_uniform_indexing_native: Bool32,
    pub robust_buffer_access_update_after_bind: Bool32,
    pub quad_divergent_implicit_lod: Bool32,
    pub max_per_stage_descriptor_update_after_bind_samplers: u32,
    pub max_per_stage_descriptor_update_after_bind_uniform_buffers: u32,
    pub max_per_stage_descriptor_update_after_bind_storage_buffers: u32,
    pub max_per_stage_descriptor_update_after_bind_sampled_images: u32,
    pub max_per_stage_descriptor_update_after_bind_storage_images: u32,
    pub max_per_stage_descriptor_update_after_bind_input_attachments: u32,
    pub max_per_stage_update_after_bind_resources: u32,
    pub max_descriptor_set_update_after_bind_samplers: u32,
    pub max_descriptor_set_update_after_bind_uniform_buffers: u32,
    pub max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32,
    pub max_descriptor_set_update_after_bind_storage_buffers: u32,
    pub max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32,
    pub max_descriptor_set_update_after_bind_sampled_images: u32,
    pub max_descriptor_set_update_after_bind_storage_images: u32,
    pub max_descriptor_set_update_after_bind_input_attachments: u32,
}
impl ::std::default::Default for PhysicalDeviceDescriptorIndexingProperties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_update_after_bind_descriptors_in_all_pools: u32::default(),
            shader_uniform_buffer_array_non_uniform_indexing_native: Bool32::default(),
            shader_sampled_image_array_non_uniform_indexing_native: Bool32::default(),
            shader_storage_buffer_array_non_uniform_indexing_native: Bool32::default(),
            shader_storage_image_array_non_uniform_indexing_native: Bool32::default(),
            shader_input_attachment_array_non_uniform_indexing_native: Bool32::default(),
            robust_buffer_access_update_after_bind: Bool32::default(),
            quad_divergent_implicit_lod: Bool32::default(),
            max_per_stage_descriptor_update_after_bind_samplers: u32::default(),
            max_per_stage_descriptor_update_after_bind_uniform_buffers: u32::default(),
            max_per_stage_descriptor_update_after_bind_storage_buffers: u32::default(),
            max_per_stage_descriptor_update_after_bind_sampled_images: u32::default(),
            max_per_stage_descriptor_update_after_bind_storage_images: u32::default(),
            max_per_stage_descriptor_update_after_bind_input_attachments: u32::default(),
            max_per_stage_update_after_bind_resources: u32::default(),
            max_descriptor_set_update_after_bind_samplers: u32::default(),
            max_descriptor_set_update_after_bind_uniform_buffers: u32::default(),
            max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32::default(),
            max_descriptor_set_update_after_bind_storage_buffers: u32::default(),
            max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32::default(),
            max_descriptor_set_update_after_bind_sampled_images: u32::default(),
            max_descriptor_set_update_after_bind_storage_images: u32::default(),
            max_descriptor_set_update_after_bind_input_attachments: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceDescriptorIndexingProperties {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES;
}
impl PhysicalDeviceDescriptorIndexingProperties {
    pub fn builder<'a>() -> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
        PhysicalDeviceDescriptorIndexingPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
    inner: PhysicalDeviceDescriptorIndexingProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceDescriptorIndexingPropertiesBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceDescriptorIndexingProperties {}
impl<'a> ::std::ops::Deref for PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
    type Target = PhysicalDeviceDescriptorIndexingProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
    #[inline]
    pub fn max_update_after_bind_descriptors_in_all_pools(
        mut self,
        max_update_after_bind_descriptors_in_all_pools: u32,
    ) -> Self {
        self.inner.max_update_after_bind_descriptors_in_all_pools =
            max_update_after_bind_descriptors_in_all_pools;
        self
    }
    #[inline]
    pub fn shader_uniform_buffer_array_non_uniform_indexing_native(
        mut self,
        shader_uniform_buffer_array_non_uniform_indexing_native: bool,
    ) -> Self {
        self.inner
            .shader_uniform_buffer_array_non_uniform_indexing_native =
            shader_uniform_buffer_array_non_uniform_indexing_native.into();
        self
    }
    #[inline]
    pub fn shader_sampled_image_array_non_uniform_indexing_native(
        mut self,
        shader_sampled_image_array_non_uniform_indexing_native: bool,
    ) -> Self {
        self.inner
            .shader_sampled_image_array_non_uniform_indexing_native =
            shader_sampled_image_array_non_uniform_indexing_native.into();
        self
    }
    #[inline]
    pub fn shader_storage_buffer_array_non_uniform_indexing_native(
        mut self,
        shader_storage_buffer_array_non_uniform_indexing_native: bool,
    ) -> Self {
        self.inner
            .shader_storage_buffer_array_non_uniform_indexing_native =
            shader_storage_buffer_array_non_uniform_indexing_native.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_array_non_uniform_indexing_native(
        mut self,
        shader_storage_image_array_non_uniform_indexing_native: bool,
    ) -> Self {
        self.inner
            .shader_storage_image_array_non_uniform_indexing_native =
            shader_storage_image_array_non_uniform_indexing_native.into();
        self
    }
    #[inline]
    pub fn shader_input_attachment_array_non_uniform_indexing_native(
        mut self,
        shader_input_attachment_array_non_uniform_indexing_native: bool,
    ) -> Self {
        self.inner
            .shader_input_attachment_array_non_uniform_indexing_native =
            shader_input_attachment_array_non_uniform_indexing_native.into();
        self
    }
    #[inline]
    pub fn robust_buffer_access_update_after_bind(
        mut self,
        robust_buffer_access_update_after_bind: bool,
    ) -> Self {
        self.inner.robust_buffer_access_update_after_bind =
            robust_buffer_access_update_after_bind.into();
        self
    }
    #[inline]
    pub fn quad_divergent_implicit_lod(mut self, quad_divergent_implicit_lod: bool) -> Self {
        self.inner.quad_divergent_implicit_lod = quad_divergent_implicit_lod.into();
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_samplers(
        mut self,
        max_per_stage_descriptor_update_after_bind_samplers: u32,
    ) -> Self {
        self.inner
            .max_per_stage_descriptor_update_after_bind_samplers =
            max_per_stage_descriptor_update_after_bind_samplers;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_uniform_buffers(
        mut self,
        max_per_stage_descriptor_update_after_bind_uniform_buffers: u32,
    ) -> Self {
        self.inner
            .max_per_stage_descriptor_update_after_bind_uniform_buffers =
            max_per_stage_descriptor_update_after_bind_uniform_buffers;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_storage_buffers(
        mut self,
        max_per_stage_descriptor_update_after_bind_storage_buffers: u32,
    ) -> Self {
        self.inner
            .max_per_stage_descriptor_update_after_bind_storage_buffers =
            max_per_stage_descriptor_update_after_bind_storage_buffers;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_sampled_images(
        mut self,
        max_per_stage_descriptor_update_after_bind_sampled_images: u32,
    ) -> Self {
        self.inner
            .max_per_stage_descriptor_update_after_bind_sampled_images =
            max_per_stage_descriptor_update_after_bind_sampled_images;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_storage_images(
        mut self,
        max_per_stage_descriptor_update_after_bind_storage_images: u32,
    ) -> Self {
        self.inner
            .max_per_stage_descriptor_update_after_bind_storage_images =
            max_per_stage_descriptor_update_after_bind_storage_images;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_input_attachments(
        mut self,
        max_per_stage_descriptor_update_after_bind_input_attachments: u32,
    ) -> Self {
        self.inner
            .max_per_stage_descriptor_update_after_bind_input_attachments =
            max_per_stage_descriptor_update_after_bind_input_attachments;
        self
    }
    #[inline]
    pub fn max_per_stage_update_after_bind_resources(
        mut self,
        max_per_stage_update_after_bind_resources: u32,
    ) -> Self {
        self.inner.max_per_stage_update_after_bind_resources =
            max_per_stage_update_after_bind_resources;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_samplers(
        mut self,
        max_descriptor_set_update_after_bind_samplers: u32,
    ) -> Self {
        self.inner.max_descriptor_set_update_after_bind_samplers =
            max_descriptor_set_update_after_bind_samplers;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_uniform_buffers(
        mut self,
        max_descriptor_set_update_after_bind_uniform_buffers: u32,
    ) -> Self {
        self.inner
            .max_descriptor_set_update_after_bind_uniform_buffers =
            max_descriptor_set_update_after_bind_uniform_buffers;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_uniform_buffers_dynamic(
        mut self,
        max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32,
    ) -> Self {
        self.inner
            .max_descriptor_set_update_after_bind_uniform_buffers_dynamic =
            max_descriptor_set_update_after_bind_uniform_buffers_dynamic;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_storage_buffers(
        mut self,
        max_descriptor_set_update_after_bind_storage_buffers: u32,
    ) -> Self {
        self.inner
            .max_descriptor_set_update_after_bind_storage_buffers =
            max_descriptor_set_update_after_bind_storage_buffers;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_storage_buffers_dynamic(
        mut self,
        max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32,
    ) -> Self {
        self.inner
            .max_descriptor_set_update_after_bind_storage_buffers_dynamic =
            max_descriptor_set_update_after_bind_storage_buffers_dynamic;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_sampled_images(
        mut self,
        max_descriptor_set_update_after_bind_sampled_images: u32,
    ) -> Self {
        self.inner
            .max_descriptor_set_update_after_bind_sampled_images =
            max_descriptor_set_update_after_bind_sampled_images;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_storage_images(
        mut self,
        max_descriptor_set_update_after_bind_storage_images: u32,
    ) -> Self {
        self.inner
            .max_descriptor_set_update_after_bind_storage_images =
            max_descriptor_set_update_after_bind_storage_images;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_input_attachments(
        mut self,
        max_descriptor_set_update_after_bind_input_attachments: u32,
    ) -> Self {
        self.inner
            .max_descriptor_set_update_after_bind_input_attachments =
            max_descriptor_set_update_after_bind_input_attachments;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceDescriptorIndexingProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutBindingFlagsCreateInfo.html>"]
pub struct DescriptorSetLayoutBindingFlagsCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub binding_count: u32,
    pub p_binding_flags: *const DescriptorBindingFlags,
}
impl ::std::default::Default for DescriptorSetLayoutBindingFlagsCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            binding_count: u32::default(),
            p_binding_flags: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for DescriptorSetLayoutBindingFlagsCreateInfo {
    const STRUCTURE_TYPE: StructureType =
        StructureType::DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO;
}
impl DescriptorSetLayoutBindingFlagsCreateInfo {
    pub fn builder<'a>() -> DescriptorSetLayoutBindingFlagsCreateInfoBuilder<'a> {
        DescriptorSetLayoutBindingFlagsCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DescriptorSetLayoutBindingFlagsCreateInfoBuilder<'a> {
    inner: DescriptorSetLayoutBindingFlagsCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsDescriptorSetLayoutCreateInfo
    for DescriptorSetLayoutBindingFlagsCreateInfoBuilder<'_>
{
}
unsafe impl ExtendsDescriptorSetLayoutCreateInfo for DescriptorSetLayoutBindingFlagsCreateInfo {}
impl<'a> ::std::ops::Deref for DescriptorSetLayoutBindingFlagsCreateInfoBuilder<'a> {
    type Target = DescriptorSetLayoutBindingFlagsCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DescriptorSetLayoutBindingFlagsCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DescriptorSetLayoutBindingFlagsCreateInfoBuilder<'a> {
    #[inline]
    pub fn binding_flags(mut self, binding_flags: &'a [DescriptorBindingFlags]) -> Self {
        self.inner.binding_count = binding_flags.len() as _;
        self.inner.p_binding_flags = binding_flags.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DescriptorSetLayoutBindingFlagsCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetVariableDescriptorCountAllocateInfo.html>"]
pub struct DescriptorSetVariableDescriptorCountAllocateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub descriptor_set_count: u32,
    pub p_descriptor_counts: *const u32,
}
impl ::std::default::Default for DescriptorSetVariableDescriptorCountAllocateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            descriptor_set_count: u32::default(),
            p_descriptor_counts: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for DescriptorSetVariableDescriptorCountAllocateInfo {
    const STRUCTURE_TYPE: StructureType =
        StructureType::DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO;
}
impl DescriptorSetVariableDescriptorCountAllocateInfo {
    pub fn builder<'a>() -> DescriptorSetVariableDescriptorCountAllocateInfoBuilder<'a> {
        DescriptorSetVariableDescriptorCountAllocateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DescriptorSetVariableDescriptorCountAllocateInfoBuilder<'a> {
    inner: DescriptorSetVariableDescriptorCountAllocateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsDescriptorSetAllocateInfo
    for DescriptorSetVariableDescriptorCountAllocateInfoBuilder<'_>
{
}
unsafe impl ExtendsDescriptorSetAllocateInfo for DescriptorSetVariableDescriptorCountAllocateInfo {}
impl<'a> ::std::ops::Deref for DescriptorSetVariableDescriptorCountAllocateInfoBuilder<'a> {
    type Target = DescriptorSetVariableDescriptorCountAllocateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DescriptorSetVariableDescriptorCountAllocateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DescriptorSetVariableDescriptorCountAllocateInfoBuilder<'a> {
    #[inline]
    pub fn descriptor_counts(mut self, descriptor_counts: &'a [u32]) -> Self {
        self.inner.descriptor_set_count = descriptor_counts.len() as _;
        self.inner.p_descriptor_counts = descriptor_counts.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DescriptorSetVariableDescriptorCountAllocateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetVariableDescriptorCountLayoutSupport.html>"]
pub struct DescriptorSetVariableDescriptorCountLayoutSupport {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_variable_descriptor_count: u32,
}
impl ::std::default::Default for DescriptorSetVariableDescriptorCountLayoutSupport {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_variable_descriptor_count: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for DescriptorSetVariableDescriptorCountLayoutSupport {
    const STRUCTURE_TYPE: StructureType =
        StructureType::DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT;
}
impl DescriptorSetVariableDescriptorCountLayoutSupport {
    pub fn builder<'a>() -> DescriptorSetVariableDescriptorCountLayoutSupportBuilder<'a> {
        DescriptorSetVariableDescriptorCountLayoutSupportBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DescriptorSetVariableDescriptorCountLayoutSupportBuilder<'a> {
    inner: DescriptorSetVariableDescriptorCountLayoutSupport,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsDescriptorSetLayoutSupport
    for DescriptorSetVariableDescriptorCountLayoutSupportBuilder<'_>
{
}
unsafe impl ExtendsDescriptorSetLayoutSupport
    for DescriptorSetVariableDescriptorCountLayoutSupport
{
}
impl<'a> ::std::ops::Deref for DescriptorSetVariableDescriptorCountLayoutSupportBuilder<'a> {
    type Target = DescriptorSetVariableDescriptorCountLayoutSupport;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DescriptorSetVariableDescriptorCountLayoutSupportBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DescriptorSetVariableDescriptorCountLayoutSupportBuilder<'a> {
    #[inline]
    pub fn max_variable_descriptor_count(mut self, max_variable_descriptor_count: u32) -> Self {
        self.inner.max_variable_descriptor_count = max_variable_descriptor_count;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DescriptorSetVariableDescriptorCountLayoutSupport {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescription2.html>"]
pub struct AttachmentDescription2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: AttachmentDescriptionFlags,
    pub format: Format,
    pub samples: SampleCountFlags,
    pub load_op: AttachmentLoadOp,
    pub store_op: AttachmentStoreOp,
    pub stencil_load_op: AttachmentLoadOp,
    pub stencil_store_op: AttachmentStoreOp,
    pub initial_layout: ImageLayout,
    pub final_layout: ImageLayout,
}
impl ::std::default::Default for AttachmentDescription2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: AttachmentDescriptionFlags::default(),
            format: Format::default(),
            samples: SampleCountFlags::default(),
            load_op: AttachmentLoadOp::default(),
            store_op: AttachmentStoreOp::default(),
            stencil_load_op: AttachmentLoadOp::default(),
            stencil_store_op: AttachmentStoreOp::default(),
            initial_layout: ImageLayout::default(),
            final_layout: ImageLayout::default(),
        }
    }
}
unsafe impl TaggedStructure for AttachmentDescription2 {
    const STRUCTURE_TYPE: StructureType = StructureType::ATTACHMENT_DESCRIPTION_2;
}
impl AttachmentDescription2 {
    pub fn builder<'a>() -> AttachmentDescription2Builder<'a> {
        AttachmentDescription2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AttachmentDescription2Builder<'a> {
    inner: AttachmentDescription2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsAttachmentDescription2 {}
impl<'a> ::std::ops::Deref for AttachmentDescription2Builder<'a> {
    type Target = AttachmentDescription2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AttachmentDescription2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AttachmentDescription2Builder<'a> {
    #[inline]
    pub fn flags(mut self, flags: AttachmentDescriptionFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.inner.format = format;
        self
    }
    #[inline]
    pub fn samples(mut self, samples: SampleCountFlags) -> Self {
        self.inner.samples = samples;
        self
    }
    #[inline]
    pub fn load_op(mut self, load_op: AttachmentLoadOp) -> Self {
        self.inner.load_op = load_op;
        self
    }
    #[inline]
    pub fn store_op(mut self, store_op: AttachmentStoreOp) -> Self {
        self.inner.store_op = store_op;
        self
    }
    #[inline]
    pub fn stencil_load_op(mut self, stencil_load_op: AttachmentLoadOp) -> Self {
        self.inner.stencil_load_op = stencil_load_op;
        self
    }
    #[inline]
    pub fn stencil_store_op(mut self, stencil_store_op: AttachmentStoreOp) -> Self {
        self.inner.stencil_store_op = stencil_store_op;
        self
    }
    #[inline]
    pub fn initial_layout(mut self, initial_layout: ImageLayout) -> Self {
        self.inner.initial_layout = initial_layout;
        self
    }
    #[inline]
    pub fn final_layout(mut self, final_layout: ImageLayout) -> Self {
        self.inner.final_layout = final_layout;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsAttachmentDescription2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AttachmentDescription2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentReference2.html>"]
pub struct AttachmentReference2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub attachment: u32,
    pub layout: ImageLayout,
    pub aspect_mask: ImageAspectFlags,
}
impl ::std::default::Default for AttachmentReference2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            attachment: u32::default(),
            layout: ImageLayout::default(),
            aspect_mask: ImageAspectFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for AttachmentReference2 {
    const STRUCTURE_TYPE: StructureType = StructureType::ATTACHMENT_REFERENCE_2;
}
impl AttachmentReference2 {
    pub fn builder<'a>() -> AttachmentReference2Builder<'a> {
        AttachmentReference2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AttachmentReference2Builder<'a> {
    inner: AttachmentReference2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsAttachmentReference2 {}
impl<'a> ::std::ops::Deref for AttachmentReference2Builder<'a> {
    type Target = AttachmentReference2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AttachmentReference2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AttachmentReference2Builder<'a> {
    #[inline]
    pub fn attachment(mut self, attachment: u32) -> Self {
        self.inner.attachment = attachment;
        self
    }
    #[inline]
    pub fn layout(mut self, layout: ImageLayout) -> Self {
        self.inner.layout = layout;
        self
    }
    #[inline]
    pub fn aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
        self.inner.aspect_mask = aspect_mask;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsAttachmentReference2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AttachmentReference2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDescription2.html>"]
pub struct SubpassDescription2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: SubpassDescriptionFlags,
    pub pipeline_bind_point: PipelineBindPoint,
    pub view_mask: u32,
    pub input_attachment_count: u32,
    pub p_input_attachments: *const AttachmentReference2,
    pub color_attachment_count: u32,
    pub p_color_attachments: *const AttachmentReference2,
    pub p_resolve_attachments: *const AttachmentReference2,
    pub p_depth_stencil_attachment: *const AttachmentReference2,
    pub preserve_attachment_count: u32,
    pub p_preserve_attachments: *const u32,
}
impl ::std::default::Default for SubpassDescription2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: SubpassDescriptionFlags::default(),
            pipeline_bind_point: PipelineBindPoint::default(),
            view_mask: u32::default(),
            input_attachment_count: u32::default(),
            p_input_attachments: ::std::ptr::null(),
            color_attachment_count: u32::default(),
            p_color_attachments: ::std::ptr::null(),
            p_resolve_attachments: ::std::ptr::null(),
            p_depth_stencil_attachment: ::std::ptr::null(),
            preserve_attachment_count: u32::default(),
            p_preserve_attachments: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for SubpassDescription2 {
    const STRUCTURE_TYPE: StructureType = StructureType::SUBPASS_DESCRIPTION_2;
}
impl SubpassDescription2 {
    pub fn builder<'a>() -> SubpassDescription2Builder<'a> {
        SubpassDescription2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SubpassDescription2Builder<'a> {
    inner: SubpassDescription2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsSubpassDescription2 {}
impl<'a> ::std::ops::Deref for SubpassDescription2Builder<'a> {
    type Target = SubpassDescription2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SubpassDescription2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SubpassDescription2Builder<'a> {
    #[inline]
    pub fn flags(mut self, flags: SubpassDescriptionFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn pipeline_bind_point(mut self, pipeline_bind_point: PipelineBindPoint) -> Self {
        self.inner.pipeline_bind_point = pipeline_bind_point;
        self
    }
    #[inline]
    pub fn view_mask(mut self, view_mask: u32) -> Self {
        self.inner.view_mask = view_mask;
        self
    }
    #[inline]
    pub fn input_attachments(mut self, input_attachments: &'a [AttachmentReference2]) -> Self {
        self.inner.input_attachment_count = input_attachments.len() as _;
        self.inner.p_input_attachments = input_attachments.as_ptr();
        self
    }
    #[inline]
    pub fn color_attachments(mut self, color_attachments: &'a [AttachmentReference2]) -> Self {
        self.inner.color_attachment_count = color_attachments.len() as _;
        self.inner.p_color_attachments = color_attachments.as_ptr();
        self
    }
    #[inline]
    pub fn resolve_attachments(mut self, resolve_attachments: &'a [AttachmentReference2]) -> Self {
        self.inner.color_attachment_count = resolve_attachments.len() as _;
        self.inner.p_resolve_attachments = resolve_attachments.as_ptr();
        self
    }
    #[inline]
    pub fn depth_stencil_attachment(
        mut self,
        depth_stencil_attachment: &'a AttachmentReference2,
    ) -> Self {
        self.inner.p_depth_stencil_attachment = depth_stencil_attachment;
        self
    }
    #[inline]
    pub fn preserve_attachments(mut self, preserve_attachments: &'a [u32]) -> Self {
        self.inner.preserve_attachment_count = preserve_attachments.len() as _;
        self.inner.p_preserve_attachments = preserve_attachments.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsSubpassDescription2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SubpassDescription2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDependency2.html>"]
pub struct SubpassDependency2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_subpass: u32,
    pub dst_subpass: u32,
    pub src_stage_mask: PipelineStageFlags,
    pub dst_stage_mask: PipelineStageFlags,
    pub src_access_mask: AccessFlags,
    pub dst_access_mask: AccessFlags,
    pub dependency_flags: DependencyFlags,
    pub view_offset: i32,
}
impl ::std::default::Default for SubpassDependency2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_subpass: u32::default(),
            dst_subpass: u32::default(),
            src_stage_mask: PipelineStageFlags::default(),
            dst_stage_mask: PipelineStageFlags::default(),
            src_access_mask: AccessFlags::default(),
            dst_access_mask: AccessFlags::default(),
            dependency_flags: DependencyFlags::default(),
            view_offset: i32::default(),
        }
    }
}
unsafe impl TaggedStructure for SubpassDependency2 {
    const STRUCTURE_TYPE: StructureType = StructureType::SUBPASS_DEPENDENCY_2;
}
impl SubpassDependency2 {
    pub fn builder<'a>() -> SubpassDependency2Builder<'a> {
        SubpassDependency2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SubpassDependency2Builder<'a> {
    inner: SubpassDependency2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsSubpassDependency2 {}
impl<'a> ::std::ops::Deref for SubpassDependency2Builder<'a> {
    type Target = SubpassDependency2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SubpassDependency2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SubpassDependency2Builder<'a> {
    #[inline]
    pub fn src_subpass(mut self, src_subpass: u32) -> Self {
        self.inner.src_subpass = src_subpass;
        self
    }
    #[inline]
    pub fn dst_subpass(mut self, dst_subpass: u32) -> Self {
        self.inner.dst_subpass = dst_subpass;
        self
    }
    #[inline]
    pub fn src_stage_mask(mut self, src_stage_mask: PipelineStageFlags) -> Self {
        self.inner.src_stage_mask = src_stage_mask;
        self
    }
    #[inline]
    pub fn dst_stage_mask(mut self, dst_stage_mask: PipelineStageFlags) -> Self {
        self.inner.dst_stage_mask = dst_stage_mask;
        self
    }
    #[inline]
    pub fn src_access_mask(mut self, src_access_mask: AccessFlags) -> Self {
        self.inner.src_access_mask = src_access_mask;
        self
    }
    #[inline]
    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags) -> Self {
        self.inner.dst_access_mask = dst_access_mask;
        self
    }
    #[inline]
    pub fn dependency_flags(mut self, dependency_flags: DependencyFlags) -> Self {
        self.inner.dependency_flags = dependency_flags;
        self
    }
    #[inline]
    pub fn view_offset(mut self, view_offset: i32) -> Self {
        self.inner.view_offset = view_offset;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsSubpassDependency2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SubpassDependency2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreateInfo2.html>"]
pub struct RenderPassCreateInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: RenderPassCreateFlags,
    pub attachment_count: u32,
    pub p_attachments: *const AttachmentDescription2,
    pub subpass_count: u32,
    pub p_subpasses: *const SubpassDescription2,
    pub dependency_count: u32,
    pub p_dependencies: *const SubpassDependency2,
    pub correlated_view_mask_count: u32,
    pub p_correlated_view_masks: *const u32,
}
impl ::std::default::Default for RenderPassCreateInfo2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: RenderPassCreateFlags::default(),
            attachment_count: u32::default(),
            p_attachments: ::std::ptr::null(),
            subpass_count: u32::default(),
            p_subpasses: ::std::ptr::null(),
            dependency_count: u32::default(),
            p_dependencies: ::std::ptr::null(),
            correlated_view_mask_count: u32::default(),
            p_correlated_view_masks: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for RenderPassCreateInfo2 {
    const STRUCTURE_TYPE: StructureType = StructureType::RENDER_PASS_CREATE_INFO_2;
}
impl RenderPassCreateInfo2 {
    pub fn builder<'a>() -> RenderPassCreateInfo2Builder<'a> {
        RenderPassCreateInfo2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RenderPassCreateInfo2Builder<'a> {
    inner: RenderPassCreateInfo2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsRenderPassCreateInfo2 {}
impl<'a> ::std::ops::Deref for RenderPassCreateInfo2Builder<'a> {
    type Target = RenderPassCreateInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RenderPassCreateInfo2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RenderPassCreateInfo2Builder<'a> {
    #[inline]
    pub fn flags(mut self, flags: RenderPassCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn attachments(mut self, attachments: &'a [AttachmentDescription2]) -> Self {
        self.inner.attachment_count = attachments.len() as _;
        self.inner.p_attachments = attachments.as_ptr();
        self
    }
    #[inline]
    pub fn subpasses(mut self, subpasses: &'a [SubpassDescription2]) -> Self {
        self.inner.subpass_count = subpasses.len() as _;
        self.inner.p_subpasses = subpasses.as_ptr();
        self
    }
    #[inline]
    pub fn dependencies(mut self, dependencies: &'a [SubpassDependency2]) -> Self {
        self.inner.dependency_count = dependencies.len() as _;
        self.inner.p_dependencies = dependencies.as_ptr();
        self
    }
    #[inline]
    pub fn correlated_view_masks(mut self, correlated_view_masks: &'a [u32]) -> Self {
        self.inner.correlated_view_mask_count = correlated_view_masks.len() as _;
        self.inner.p_correlated_view_masks = correlated_view_masks.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsRenderPassCreateInfo2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RenderPassCreateInfo2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassBeginInfo.html>"]
pub struct SubpassBeginInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub contents: SubpassContents,
}
impl ::std::default::Default for SubpassBeginInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            contents: SubpassContents::default(),
        }
    }
}
unsafe impl TaggedStructure for SubpassBeginInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::SUBPASS_BEGIN_INFO;
}
impl SubpassBeginInfo {
    pub fn builder<'a>() -> SubpassBeginInfoBuilder<'a> {
        SubpassBeginInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SubpassBeginInfoBuilder<'a> {
    inner: SubpassBeginInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SubpassBeginInfoBuilder<'a> {
    type Target = SubpassBeginInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SubpassBeginInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SubpassBeginInfoBuilder<'a> {
    #[inline]
    pub fn contents(mut self, contents: SubpassContents) -> Self {
        self.inner.contents = contents;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SubpassBeginInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassEndInfo.html>"]
pub struct SubpassEndInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
}
impl ::std::default::Default for SubpassEndInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for SubpassEndInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::SUBPASS_END_INFO;
}
impl SubpassEndInfo {
    pub fn builder<'a>() -> SubpassEndInfoBuilder<'a> {
        SubpassEndInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SubpassEndInfoBuilder<'a> {
    inner: SubpassEndInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsSubpassEndInfo {}
impl<'a> ::std::ops::Deref for SubpassEndInfoBuilder<'a> {
    type Target = SubpassEndInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SubpassEndInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SubpassEndInfoBuilder<'a> {
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsSubpassEndInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SubpassEndInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTimelineSemaphoreFeatures.html>"]
pub struct PhysicalDeviceTimelineSemaphoreFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub timeline_semaphore: Bool32,
}
impl ::std::default::Default for PhysicalDeviceTimelineSemaphoreFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            timeline_semaphore: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceTimelineSemaphoreFeatures {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
}
impl PhysicalDeviceTimelineSemaphoreFeatures {
    pub fn builder<'a>() -> PhysicalDeviceTimelineSemaphoreFeaturesBuilder<'a> {
        PhysicalDeviceTimelineSemaphoreFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceTimelineSemaphoreFeaturesBuilder<'a> {
    inner: PhysicalDeviceTimelineSemaphoreFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceTimelineSemaphoreFeaturesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceTimelineSemaphoreFeatures {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceTimelineSemaphoreFeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceTimelineSemaphoreFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDeviceTimelineSemaphoreFeaturesBuilder<'a> {
    type Target = PhysicalDeviceTimelineSemaphoreFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceTimelineSemaphoreFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceTimelineSemaphoreFeaturesBuilder<'a> {
    #[inline]
    pub fn timeline_semaphore(mut self, timeline_semaphore: bool) -> Self {
        self.inner.timeline_semaphore = timeline_semaphore.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceTimelineSemaphoreFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTimelineSemaphoreProperties.html>"]
pub struct PhysicalDeviceTimelineSemaphoreProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_timeline_semaphore_value_difference: u64,
}
impl ::std::default::Default for PhysicalDeviceTimelineSemaphoreProperties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_timeline_semaphore_value_difference: u64::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceTimelineSemaphoreProperties {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES;
}
impl PhysicalDeviceTimelineSemaphoreProperties {
    pub fn builder<'a>() -> PhysicalDeviceTimelineSemaphorePropertiesBuilder<'a> {
        PhysicalDeviceTimelineSemaphorePropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceTimelineSemaphorePropertiesBuilder<'a> {
    inner: PhysicalDeviceTimelineSemaphoreProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceTimelineSemaphorePropertiesBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceTimelineSemaphoreProperties {}
impl<'a> ::std::ops::Deref for PhysicalDeviceTimelineSemaphorePropertiesBuilder<'a> {
    type Target = PhysicalDeviceTimelineSemaphoreProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceTimelineSemaphorePropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceTimelineSemaphorePropertiesBuilder<'a> {
    #[inline]
    pub fn max_timeline_semaphore_value_difference(
        mut self,
        max_timeline_semaphore_value_difference: u64,
    ) -> Self {
        self.inner.max_timeline_semaphore_value_difference =
            max_timeline_semaphore_value_difference;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceTimelineSemaphoreProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreTypeCreateInfo.html>"]
pub struct SemaphoreTypeCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore_type: SemaphoreType,
    pub initial_value: u64,
}
impl ::std::default::Default for SemaphoreTypeCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            semaphore_type: SemaphoreType::default(),
            initial_value: u64::default(),
        }
    }
}
unsafe impl TaggedStructure for SemaphoreTypeCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::SEMAPHORE_TYPE_CREATE_INFO;
}
impl SemaphoreTypeCreateInfo {
    pub fn builder<'a>() -> SemaphoreTypeCreateInfoBuilder<'a> {
        SemaphoreTypeCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SemaphoreTypeCreateInfoBuilder<'a> {
    inner: SemaphoreTypeCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSemaphoreCreateInfo for SemaphoreTypeCreateInfoBuilder<'_> {}
unsafe impl ExtendsSemaphoreCreateInfo for SemaphoreTypeCreateInfo {}
unsafe impl ExtendsPhysicalDeviceExternalSemaphoreInfo for SemaphoreTypeCreateInfoBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceExternalSemaphoreInfo for SemaphoreTypeCreateInfo {}
impl<'a> ::std::ops::Deref for SemaphoreTypeCreateInfoBuilder<'a> {
    type Target = SemaphoreTypeCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SemaphoreTypeCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SemaphoreTypeCreateInfoBuilder<'a> {
    #[inline]
    pub fn semaphore_type(mut self, semaphore_type: SemaphoreType) -> Self {
        self.inner.semaphore_type = semaphore_type;
        self
    }
    #[inline]
    pub fn initial_value(mut self, initial_value: u64) -> Self {
        self.inner.initial_value = initial_value;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SemaphoreTypeCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkTimelineSemaphoreSubmitInfo.html>"]
pub struct TimelineSemaphoreSubmitInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub wait_semaphore_value_count: u32,
    pub p_wait_semaphore_values: *const u64,
    pub signal_semaphore_value_count: u32,
    pub p_signal_semaphore_values: *const u64,
}
impl ::std::default::Default for TimelineSemaphoreSubmitInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            wait_semaphore_value_count: u32::default(),
            p_wait_semaphore_values: ::std::ptr::null(),
            signal_semaphore_value_count: u32::default(),
            p_signal_semaphore_values: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for TimelineSemaphoreSubmitInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::TIMELINE_SEMAPHORE_SUBMIT_INFO;
}
impl TimelineSemaphoreSubmitInfo {
    pub fn builder<'a>() -> TimelineSemaphoreSubmitInfoBuilder<'a> {
        TimelineSemaphoreSubmitInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct TimelineSemaphoreSubmitInfoBuilder<'a> {
    inner: TimelineSemaphoreSubmitInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSubmitInfo for TimelineSemaphoreSubmitInfoBuilder<'_> {}
unsafe impl ExtendsSubmitInfo for TimelineSemaphoreSubmitInfo {}
unsafe impl ExtendsBindSparseInfo for TimelineSemaphoreSubmitInfoBuilder<'_> {}
unsafe impl ExtendsBindSparseInfo for TimelineSemaphoreSubmitInfo {}
impl<'a> ::std::ops::Deref for TimelineSemaphoreSubmitInfoBuilder<'a> {
    type Target = TimelineSemaphoreSubmitInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for TimelineSemaphoreSubmitInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> TimelineSemaphoreSubmitInfoBuilder<'a> {
    #[inline]
    pub fn wait_semaphore_values(mut self, wait_semaphore_values: &'a [u64]) -> Self {
        self.inner.wait_semaphore_value_count = wait_semaphore_values.len() as _;
        self.inner.p_wait_semaphore_values = wait_semaphore_values.as_ptr();
        self
    }
    #[inline]
    pub fn signal_semaphore_values(mut self, signal_semaphore_values: &'a [u64]) -> Self {
        self.inner.signal_semaphore_value_count = signal_semaphore_values.len() as _;
        self.inner.p_signal_semaphore_values = signal_semaphore_values.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> TimelineSemaphoreSubmitInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreWaitInfo.html>"]
pub struct SemaphoreWaitInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: SemaphoreWaitFlags,
    pub semaphore_count: u32,
    pub p_semaphores: *const Semaphore,
    pub p_values: *const u64,
}
impl ::std::default::Default for SemaphoreWaitInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: SemaphoreWaitFlags::default(),
            semaphore_count: u32::default(),
            p_semaphores: ::std::ptr::null(),
            p_values: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for SemaphoreWaitInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::SEMAPHORE_WAIT_INFO;
}
impl SemaphoreWaitInfo {
    pub fn builder<'a>() -> SemaphoreWaitInfoBuilder<'a> {
        SemaphoreWaitInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SemaphoreWaitInfoBuilder<'a> {
    inner: SemaphoreWaitInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SemaphoreWaitInfoBuilder<'a> {
    type Target = SemaphoreWaitInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SemaphoreWaitInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SemaphoreWaitInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: SemaphoreWaitFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn semaphores(mut self, semaphores: &'a [Semaphore]) -> Self {
        self.inner.semaphore_count = semaphores.len() as _;
        self.inner.p_semaphores = semaphores.as_ptr();
        self
    }
    #[inline]
    pub fn values(mut self, values: &'a [u64]) -> Self {
        self.inner.semaphore_count = values.len() as _;
        self.inner.p_values = values.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SemaphoreWaitInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreSignalInfo.html>"]
pub struct SemaphoreSignalInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Semaphore,
    pub value: u64,
}
impl ::std::default::Default for SemaphoreSignalInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            semaphore: Semaphore::default(),
            value: u64::default(),
        }
    }
}
unsafe impl TaggedStructure for SemaphoreSignalInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::SEMAPHORE_SIGNAL_INFO;
}
impl SemaphoreSignalInfo {
    pub fn builder<'a>() -> SemaphoreSignalInfoBuilder<'a> {
        SemaphoreSignalInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SemaphoreSignalInfoBuilder<'a> {
    inner: SemaphoreSignalInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SemaphoreSignalInfoBuilder<'a> {
    type Target = SemaphoreSignalInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SemaphoreSignalInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SemaphoreSignalInfoBuilder<'a> {
    #[inline]
    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
        self.inner.semaphore = semaphore;
        self
    }
    #[inline]
    pub fn value(mut self, value: u64) -> Self {
        self.inner.value = value;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SemaphoreSignalInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVertexInputBindingDivisorDescriptionEXT.html>"]
pub struct VertexInputBindingDivisorDescriptionEXT {
    pub binding: u32,
    pub divisor: u32,
}
impl VertexInputBindingDivisorDescriptionEXT {
    pub fn builder<'a>() -> VertexInputBindingDivisorDescriptionEXTBuilder<'a> {
        VertexInputBindingDivisorDescriptionEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VertexInputBindingDivisorDescriptionEXTBuilder<'a> {
    inner: VertexInputBindingDivisorDescriptionEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for VertexInputBindingDivisorDescriptionEXTBuilder<'a> {
    type Target = VertexInputBindingDivisorDescriptionEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VertexInputBindingDivisorDescriptionEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VertexInputBindingDivisorDescriptionEXTBuilder<'a> {
    #[inline]
    pub fn binding(mut self, binding: u32) -> Self {
        self.inner.binding = binding;
        self
    }
    #[inline]
    pub fn divisor(mut self, divisor: u32) -> Self {
        self.inner.divisor = divisor;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VertexInputBindingDivisorDescriptionEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineVertexInputDivisorStateCreateInfoEXT.html>"]
pub struct PipelineVertexInputDivisorStateCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub vertex_binding_divisor_count: u32,
    pub p_vertex_binding_divisors: *const VertexInputBindingDivisorDescriptionEXT,
}
impl ::std::default::Default for PipelineVertexInputDivisorStateCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            vertex_binding_divisor_count: u32::default(),
            p_vertex_binding_divisors: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for PipelineVertexInputDivisorStateCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT;
}
impl PipelineVertexInputDivisorStateCreateInfoEXT {
    pub fn builder<'a>() -> PipelineVertexInputDivisorStateCreateInfoEXTBuilder<'a> {
        PipelineVertexInputDivisorStateCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineVertexInputDivisorStateCreateInfoEXTBuilder<'a> {
    inner: PipelineVertexInputDivisorStateCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPipelineVertexInputStateCreateInfo
    for PipelineVertexInputDivisorStateCreateInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsPipelineVertexInputStateCreateInfo
    for PipelineVertexInputDivisorStateCreateInfoEXT
{
}
impl<'a> ::std::ops::Deref for PipelineVertexInputDivisorStateCreateInfoEXTBuilder<'a> {
    type Target = PipelineVertexInputDivisorStateCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineVertexInputDivisorStateCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineVertexInputDivisorStateCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn vertex_binding_divisors(
        mut self,
        vertex_binding_divisors: &'a [VertexInputBindingDivisorDescriptionEXT],
    ) -> Self {
        self.inner.vertex_binding_divisor_count = vertex_binding_divisors.len() as _;
        self.inner.p_vertex_binding_divisors = vertex_binding_divisors.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineVertexInputDivisorStateCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.html>"]
pub struct PhysicalDeviceVertexAttributeDivisorPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_vertex_attrib_divisor: u32,
}
impl ::std::default::Default for PhysicalDeviceVertexAttributeDivisorPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_vertex_attrib_divisor: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceVertexAttributeDivisorPropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT;
}
impl PhysicalDeviceVertexAttributeDivisorPropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceVertexAttributeDivisorPropertiesEXTBuilder<'a> {
        PhysicalDeviceVertexAttributeDivisorPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceVertexAttributeDivisorPropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceVertexAttributeDivisorPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceVertexAttributeDivisorPropertiesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceVertexAttributeDivisorPropertiesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceVertexAttributeDivisorPropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceVertexAttributeDivisorPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceVertexAttributeDivisorPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceVertexAttributeDivisorPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn max_vertex_attrib_divisor(mut self, max_vertex_attrib_divisor: u32) -> Self {
        self.inner.max_vertex_attrib_divisor = max_vertex_attrib_divisor;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceVertexAttributeDivisorPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePCIBusInfoPropertiesEXT.html>"]
pub struct PhysicalDevicePCIBusInfoPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pci_domain: u32,
    pub pci_bus: u32,
    pub pci_device: u32,
    pub pci_function: u32,
}
impl ::std::default::Default for PhysicalDevicePCIBusInfoPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            pci_domain: u32::default(),
            pci_bus: u32::default(),
            pci_device: u32::default(),
            pci_function: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevicePCIBusInfoPropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT;
}
impl PhysicalDevicePCIBusInfoPropertiesEXT {
    pub fn builder<'a>() -> PhysicalDevicePCIBusInfoPropertiesEXTBuilder<'a> {
        PhysicalDevicePCIBusInfoPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevicePCIBusInfoPropertiesEXTBuilder<'a> {
    inner: PhysicalDevicePCIBusInfoPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDevicePCIBusInfoPropertiesEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDevicePCIBusInfoPropertiesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDevicePCIBusInfoPropertiesEXTBuilder<'a> {
    type Target = PhysicalDevicePCIBusInfoPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevicePCIBusInfoPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevicePCIBusInfoPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn pci_domain(mut self, pci_domain: u32) -> Self {
        self.inner.pci_domain = pci_domain;
        self
    }
    #[inline]
    pub fn pci_bus(mut self, pci_bus: u32) -> Self {
        self.inner.pci_bus = pci_bus;
        self
    }
    #[inline]
    pub fn pci_device(mut self, pci_device: u32) -> Self {
        self.inner.pci_device = pci_device;
        self
    }
    #[inline]
    pub fn pci_function(mut self, pci_function: u32) -> Self {
        self.inner.pci_function = pci_function;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevicePCIBusInfoPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportAndroidHardwareBufferInfoANDROID.html>"]
pub struct ImportAndroidHardwareBufferInfoANDROID {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub buffer: *mut AHardwareBuffer,
}
impl ::std::default::Default for ImportAndroidHardwareBufferInfoANDROID {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            buffer: ::std::ptr::null_mut(),
        }
    }
}
unsafe impl TaggedStructure for ImportAndroidHardwareBufferInfoANDROID {
    const STRUCTURE_TYPE: StructureType =
        StructureType::IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID;
}
impl ImportAndroidHardwareBufferInfoANDROID {
    pub fn builder<'a>() -> ImportAndroidHardwareBufferInfoANDROIDBuilder<'a> {
        ImportAndroidHardwareBufferInfoANDROIDBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImportAndroidHardwareBufferInfoANDROIDBuilder<'a> {
    inner: ImportAndroidHardwareBufferInfoANDROID,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsMemoryAllocateInfo for ImportAndroidHardwareBufferInfoANDROIDBuilder<'_> {}
unsafe impl ExtendsMemoryAllocateInfo for ImportAndroidHardwareBufferInfoANDROID {}
impl<'a> ::std::ops::Deref for ImportAndroidHardwareBufferInfoANDROIDBuilder<'a> {
    type Target = ImportAndroidHardwareBufferInfoANDROID;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImportAndroidHardwareBufferInfoANDROIDBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImportAndroidHardwareBufferInfoANDROIDBuilder<'a> {
    #[inline]
    pub fn buffer(mut self, buffer: *mut AHardwareBuffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImportAndroidHardwareBufferInfoANDROID {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAndroidHardwareBufferUsageANDROID.html>"]
pub struct AndroidHardwareBufferUsageANDROID {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub android_hardware_buffer_usage: u64,
}
impl ::std::default::Default for AndroidHardwareBufferUsageANDROID {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            android_hardware_buffer_usage: u64::default(),
        }
    }
}
unsafe impl TaggedStructure for AndroidHardwareBufferUsageANDROID {
    const STRUCTURE_TYPE: StructureType = StructureType::ANDROID_HARDWARE_BUFFER_USAGE_ANDROID;
}
impl AndroidHardwareBufferUsageANDROID {
    pub fn builder<'a>() -> AndroidHardwareBufferUsageANDROIDBuilder<'a> {
        AndroidHardwareBufferUsageANDROIDBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AndroidHardwareBufferUsageANDROIDBuilder<'a> {
    inner: AndroidHardwareBufferUsageANDROID,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageFormatProperties2 for AndroidHardwareBufferUsageANDROIDBuilder<'_> {}
unsafe impl ExtendsImageFormatProperties2 for AndroidHardwareBufferUsageANDROID {}
impl<'a> ::std::ops::Deref for AndroidHardwareBufferUsageANDROIDBuilder<'a> {
    type Target = AndroidHardwareBufferUsageANDROID;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AndroidHardwareBufferUsageANDROIDBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AndroidHardwareBufferUsageANDROIDBuilder<'a> {
    #[inline]
    pub fn android_hardware_buffer_usage(mut self, android_hardware_buffer_usage: u64) -> Self {
        self.inner.android_hardware_buffer_usage = android_hardware_buffer_usage;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AndroidHardwareBufferUsageANDROID {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAndroidHardwareBufferPropertiesANDROID.html>"]
pub struct AndroidHardwareBufferPropertiesANDROID {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub allocation_size: DeviceSize,
    pub memory_type_bits: u32,
}
impl ::std::default::Default for AndroidHardwareBufferPropertiesANDROID {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            allocation_size: DeviceSize::default(),
            memory_type_bits: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for AndroidHardwareBufferPropertiesANDROID {
    const STRUCTURE_TYPE: StructureType = StructureType::ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID;
}
impl AndroidHardwareBufferPropertiesANDROID {
    pub fn builder<'a>() -> AndroidHardwareBufferPropertiesANDROIDBuilder<'a> {
        AndroidHardwareBufferPropertiesANDROIDBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AndroidHardwareBufferPropertiesANDROIDBuilder<'a> {
    inner: AndroidHardwareBufferPropertiesANDROID,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsAndroidHardwareBufferPropertiesANDROID {}
impl<'a> ::std::ops::Deref for AndroidHardwareBufferPropertiesANDROIDBuilder<'a> {
    type Target = AndroidHardwareBufferPropertiesANDROID;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AndroidHardwareBufferPropertiesANDROIDBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AndroidHardwareBufferPropertiesANDROIDBuilder<'a> {
    #[inline]
    pub fn allocation_size(mut self, allocation_size: DeviceSize) -> Self {
        self.inner.allocation_size = allocation_size;
        self
    }
    #[inline]
    pub fn memory_type_bits(mut self, memory_type_bits: u32) -> Self {
        self.inner.memory_type_bits = memory_type_bits;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsAndroidHardwareBufferPropertiesANDROID>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AndroidHardwareBufferPropertiesANDROID {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryGetAndroidHardwareBufferInfoANDROID.html>"]
pub struct MemoryGetAndroidHardwareBufferInfoANDROID {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: DeviceMemory,
}
impl ::std::default::Default for MemoryGetAndroidHardwareBufferInfoANDROID {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            memory: DeviceMemory::default(),
        }
    }
}
unsafe impl TaggedStructure for MemoryGetAndroidHardwareBufferInfoANDROID {
    const STRUCTURE_TYPE: StructureType =
        StructureType::MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID;
}
impl MemoryGetAndroidHardwareBufferInfoANDROID {
    pub fn builder<'a>() -> MemoryGetAndroidHardwareBufferInfoANDROIDBuilder<'a> {
        MemoryGetAndroidHardwareBufferInfoANDROIDBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MemoryGetAndroidHardwareBufferInfoANDROIDBuilder<'a> {
    inner: MemoryGetAndroidHardwareBufferInfoANDROID,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MemoryGetAndroidHardwareBufferInfoANDROIDBuilder<'a> {
    type Target = MemoryGetAndroidHardwareBufferInfoANDROID;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MemoryGetAndroidHardwareBufferInfoANDROIDBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MemoryGetAndroidHardwareBufferInfoANDROIDBuilder<'a> {
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MemoryGetAndroidHardwareBufferInfoANDROID {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAndroidHardwareBufferFormatPropertiesANDROID.html>"]
pub struct AndroidHardwareBufferFormatPropertiesANDROID {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub format: Format,
    pub external_format: u64,
    pub format_features: FormatFeatureFlags,
    pub sampler_ycbcr_conversion_components: ComponentMapping,
    pub suggested_ycbcr_model: SamplerYcbcrModelConversion,
    pub suggested_ycbcr_range: SamplerYcbcrRange,
    pub suggested_x_chroma_offset: ChromaLocation,
    pub suggested_y_chroma_offset: ChromaLocation,
}
impl ::std::default::Default for AndroidHardwareBufferFormatPropertiesANDROID {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            format: Format::default(),
            external_format: u64::default(),
            format_features: FormatFeatureFlags::default(),
            sampler_ycbcr_conversion_components: ComponentMapping::default(),
            suggested_ycbcr_model: SamplerYcbcrModelConversion::default(),
            suggested_ycbcr_range: SamplerYcbcrRange::default(),
            suggested_x_chroma_offset: ChromaLocation::default(),
            suggested_y_chroma_offset: ChromaLocation::default(),
        }
    }
}
unsafe impl TaggedStructure for AndroidHardwareBufferFormatPropertiesANDROID {
    const STRUCTURE_TYPE: StructureType =
        StructureType::ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID;
}
impl AndroidHardwareBufferFormatPropertiesANDROID {
    pub fn builder<'a>() -> AndroidHardwareBufferFormatPropertiesANDROIDBuilder<'a> {
        AndroidHardwareBufferFormatPropertiesANDROIDBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AndroidHardwareBufferFormatPropertiesANDROIDBuilder<'a> {
    inner: AndroidHardwareBufferFormatPropertiesANDROID,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsAndroidHardwareBufferPropertiesANDROID
    for AndroidHardwareBufferFormatPropertiesANDROIDBuilder<'_>
{
}
unsafe impl ExtendsAndroidHardwareBufferPropertiesANDROID
    for AndroidHardwareBufferFormatPropertiesANDROID
{
}
impl<'a> ::std::ops::Deref for AndroidHardwareBufferFormatPropertiesANDROIDBuilder<'a> {
    type Target = AndroidHardwareBufferFormatPropertiesANDROID;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AndroidHardwareBufferFormatPropertiesANDROIDBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AndroidHardwareBufferFormatPropertiesANDROIDBuilder<'a> {
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.inner.format = format;
        self
    }
    #[inline]
    pub fn external_format(mut self, external_format: u64) -> Self {
        self.inner.external_format = external_format;
        self
    }
    #[inline]
    pub fn format_features(mut self, format_features: FormatFeatureFlags) -> Self {
        self.inner.format_features = format_features;
        self
    }
    #[inline]
    pub fn sampler_ycbcr_conversion_components(
        mut self,
        sampler_ycbcr_conversion_components: ComponentMapping,
    ) -> Self {
        self.inner.sampler_ycbcr_conversion_components = sampler_ycbcr_conversion_components;
        self
    }
    #[inline]
    pub fn suggested_ycbcr_model(
        mut self,
        suggested_ycbcr_model: SamplerYcbcrModelConversion,
    ) -> Self {
        self.inner.suggested_ycbcr_model = suggested_ycbcr_model;
        self
    }
    #[inline]
    pub fn suggested_ycbcr_range(mut self, suggested_ycbcr_range: SamplerYcbcrRange) -> Self {
        self.inner.suggested_ycbcr_range = suggested_ycbcr_range;
        self
    }
    #[inline]
    pub fn suggested_x_chroma_offset(mut self, suggested_x_chroma_offset: ChromaLocation) -> Self {
        self.inner.suggested_x_chroma_offset = suggested_x_chroma_offset;
        self
    }
    #[inline]
    pub fn suggested_y_chroma_offset(mut self, suggested_y_chroma_offset: ChromaLocation) -> Self {
        self.inner.suggested_y_chroma_offset = suggested_y_chroma_offset;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AndroidHardwareBufferFormatPropertiesANDROID {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceConditionalRenderingInfoEXT.html>"]
pub struct CommandBufferInheritanceConditionalRenderingInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub conditional_rendering_enable: Bool32,
}
impl ::std::default::Default for CommandBufferInheritanceConditionalRenderingInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            conditional_rendering_enable: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for CommandBufferInheritanceConditionalRenderingInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT;
}
impl CommandBufferInheritanceConditionalRenderingInfoEXT {
    pub fn builder<'a>() -> CommandBufferInheritanceConditionalRenderingInfoEXTBuilder<'a> {
        CommandBufferInheritanceConditionalRenderingInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CommandBufferInheritanceConditionalRenderingInfoEXTBuilder<'a> {
    inner: CommandBufferInheritanceConditionalRenderingInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsCommandBufferInheritanceInfo
    for CommandBufferInheritanceConditionalRenderingInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsCommandBufferInheritanceInfo
    for CommandBufferInheritanceConditionalRenderingInfoEXT
{
}
impl<'a> ::std::ops::Deref for CommandBufferInheritanceConditionalRenderingInfoEXTBuilder<'a> {
    type Target = CommandBufferInheritanceConditionalRenderingInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CommandBufferInheritanceConditionalRenderingInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CommandBufferInheritanceConditionalRenderingInfoEXTBuilder<'a> {
    #[inline]
    pub fn conditional_rendering_enable(mut self, conditional_rendering_enable: bool) -> Self {
        self.inner.conditional_rendering_enable = conditional_rendering_enable.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CommandBufferInheritanceConditionalRenderingInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalFormatANDROID.html>"]
pub struct ExternalFormatANDROID {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub external_format: u64,
}
impl ::std::default::Default for ExternalFormatANDROID {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            external_format: u64::default(),
        }
    }
}
unsafe impl TaggedStructure for ExternalFormatANDROID {
    const STRUCTURE_TYPE: StructureType = StructureType::EXTERNAL_FORMAT_ANDROID;
}
impl ExternalFormatANDROID {
    pub fn builder<'a>() -> ExternalFormatANDROIDBuilder<'a> {
        ExternalFormatANDROIDBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExternalFormatANDROIDBuilder<'a> {
    inner: ExternalFormatANDROID,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageCreateInfo for ExternalFormatANDROIDBuilder<'_> {}
unsafe impl ExtendsImageCreateInfo for ExternalFormatANDROID {}
unsafe impl ExtendsSamplerYcbcrConversionCreateInfo for ExternalFormatANDROIDBuilder<'_> {}
unsafe impl ExtendsSamplerYcbcrConversionCreateInfo for ExternalFormatANDROID {}
impl<'a> ::std::ops::Deref for ExternalFormatANDROIDBuilder<'a> {
    type Target = ExternalFormatANDROID;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExternalFormatANDROIDBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExternalFormatANDROIDBuilder<'a> {
    #[inline]
    pub fn external_format(mut self, external_format: u64) -> Self {
        self.inner.external_format = external_format;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExternalFormatANDROID {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice8BitStorageFeatures.html>"]
pub struct PhysicalDevice8BitStorageFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub storage_buffer8_bit_access: Bool32,
    pub uniform_and_storage_buffer8_bit_access: Bool32,
    pub storage_push_constant8: Bool32,
}
impl ::std::default::Default for PhysicalDevice8BitStorageFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            storage_buffer8_bit_access: Bool32::default(),
            uniform_and_storage_buffer8_bit_access: Bool32::default(),
            storage_push_constant8: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevice8BitStorageFeatures {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
}
impl PhysicalDevice8BitStorageFeatures {
    pub fn builder<'a>() -> PhysicalDevice8BitStorageFeaturesBuilder<'a> {
        PhysicalDevice8BitStorageFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevice8BitStorageFeaturesBuilder<'a> {
    inner: PhysicalDevice8BitStorageFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevice8BitStorageFeaturesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevice8BitStorageFeatures {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevice8BitStorageFeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevice8BitStorageFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDevice8BitStorageFeaturesBuilder<'a> {
    type Target = PhysicalDevice8BitStorageFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevice8BitStorageFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevice8BitStorageFeaturesBuilder<'a> {
    #[inline]
    pub fn storage_buffer8_bit_access(mut self, storage_buffer8_bit_access: bool) -> Self {
        self.inner.storage_buffer8_bit_access = storage_buffer8_bit_access.into();
        self
    }
    #[inline]
    pub fn uniform_and_storage_buffer8_bit_access(
        mut self,
        uniform_and_storage_buffer8_bit_access: bool,
    ) -> Self {
        self.inner.uniform_and_storage_buffer8_bit_access =
            uniform_and_storage_buffer8_bit_access.into();
        self
    }
    #[inline]
    pub fn storage_push_constant8(mut self, storage_push_constant8: bool) -> Self {
        self.inner.storage_push_constant8 = storage_push_constant8.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevice8BitStorageFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceConditionalRenderingFeaturesEXT.html>"]
pub struct PhysicalDeviceConditionalRenderingFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub conditional_rendering: Bool32,
    pub inherited_conditional_rendering: Bool32,
}
impl ::std::default::Default for PhysicalDeviceConditionalRenderingFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            conditional_rendering: Bool32::default(),
            inherited_conditional_rendering: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceConditionalRenderingFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT;
}
impl PhysicalDeviceConditionalRenderingFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceConditionalRenderingFeaturesEXTBuilder<'a> {
        PhysicalDeviceConditionalRenderingFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceConditionalRenderingFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceConditionalRenderingFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceConditionalRenderingFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceConditionalRenderingFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceConditionalRenderingFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceConditionalRenderingFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceConditionalRenderingFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceConditionalRenderingFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceConditionalRenderingFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceConditionalRenderingFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn conditional_rendering(mut self, conditional_rendering: bool) -> Self {
        self.inner.conditional_rendering = conditional_rendering.into();
        self
    }
    #[inline]
    pub fn inherited_conditional_rendering(
        mut self,
        inherited_conditional_rendering: bool,
    ) -> Self {
        self.inner.inherited_conditional_rendering = inherited_conditional_rendering.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceConditionalRenderingFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkanMemoryModelFeatures.html>"]
pub struct PhysicalDeviceVulkanMemoryModelFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub vulkan_memory_model: Bool32,
    pub vulkan_memory_model_device_scope: Bool32,
    pub vulkan_memory_model_availability_visibility_chains: Bool32,
}
impl ::std::default::Default for PhysicalDeviceVulkanMemoryModelFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            vulkan_memory_model: Bool32::default(),
            vulkan_memory_model_device_scope: Bool32::default(),
            vulkan_memory_model_availability_visibility_chains: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceVulkanMemoryModelFeatures {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
}
impl PhysicalDeviceVulkanMemoryModelFeatures {
    pub fn builder<'a>() -> PhysicalDeviceVulkanMemoryModelFeaturesBuilder<'a> {
        PhysicalDeviceVulkanMemoryModelFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceVulkanMemoryModelFeaturesBuilder<'a> {
    inner: PhysicalDeviceVulkanMemoryModelFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVulkanMemoryModelFeaturesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVulkanMemoryModelFeatures {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVulkanMemoryModelFeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVulkanMemoryModelFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDeviceVulkanMemoryModelFeaturesBuilder<'a> {
    type Target = PhysicalDeviceVulkanMemoryModelFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceVulkanMemoryModelFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceVulkanMemoryModelFeaturesBuilder<'a> {
    #[inline]
    pub fn vulkan_memory_model(mut self, vulkan_memory_model: bool) -> Self {
        self.inner.vulkan_memory_model = vulkan_memory_model.into();
        self
    }
    #[inline]
    pub fn vulkan_memory_model_device_scope(
        mut self,
        vulkan_memory_model_device_scope: bool,
    ) -> Self {
        self.inner.vulkan_memory_model_device_scope = vulkan_memory_model_device_scope.into();
        self
    }
    #[inline]
    pub fn vulkan_memory_model_availability_visibility_chains(
        mut self,
        vulkan_memory_model_availability_visibility_chains: bool,
    ) -> Self {
        self.inner
            .vulkan_memory_model_availability_visibility_chains =
            vulkan_memory_model_availability_visibility_chains.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceVulkanMemoryModelFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicInt64Features.html>"]
pub struct PhysicalDeviceShaderAtomicInt64Features {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_buffer_int64_atomics: Bool32,
    pub shader_shared_int64_atomics: Bool32,
}
impl ::std::default::Default for PhysicalDeviceShaderAtomicInt64Features {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_buffer_int64_atomics: Bool32::default(),
            shader_shared_int64_atomics: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderAtomicInt64Features {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
}
impl PhysicalDeviceShaderAtomicInt64Features {
    pub fn builder<'a>() -> PhysicalDeviceShaderAtomicInt64FeaturesBuilder<'a> {
        PhysicalDeviceShaderAtomicInt64FeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderAtomicInt64FeaturesBuilder<'a> {
    inner: PhysicalDeviceShaderAtomicInt64Features,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderAtomicInt64FeaturesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderAtomicInt64Features {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderAtomicInt64FeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderAtomicInt64Features {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderAtomicInt64FeaturesBuilder<'a> {
    type Target = PhysicalDeviceShaderAtomicInt64Features;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderAtomicInt64FeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderAtomicInt64FeaturesBuilder<'a> {
    #[inline]
    pub fn shader_buffer_int64_atomics(mut self, shader_buffer_int64_atomics: bool) -> Self {
        self.inner.shader_buffer_int64_atomics = shader_buffer_int64_atomics.into();
        self
    }
    #[inline]
    pub fn shader_shared_int64_atomics(mut self, shader_shared_int64_atomics: bool) -> Self {
        self.inner.shader_shared_int64_atomics = shader_shared_int64_atomics.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderAtomicInt64Features {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html>"]
pub struct PhysicalDeviceShaderAtomicFloatFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_buffer_float32_atomics: Bool32,
    pub shader_buffer_float32_atomic_add: Bool32,
    pub shader_buffer_float64_atomics: Bool32,
    pub shader_buffer_float64_atomic_add: Bool32,
    pub shader_shared_float32_atomics: Bool32,
    pub shader_shared_float32_atomic_add: Bool32,
    pub shader_shared_float64_atomics: Bool32,
    pub shader_shared_float64_atomic_add: Bool32,
    pub shader_image_float32_atomics: Bool32,
    pub shader_image_float32_atomic_add: Bool32,
    pub sparse_image_float32_atomics: Bool32,
    pub sparse_image_float32_atomic_add: Bool32,
}
impl ::std::default::Default for PhysicalDeviceShaderAtomicFloatFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_buffer_float32_atomics: Bool32::default(),
            shader_buffer_float32_atomic_add: Bool32::default(),
            shader_buffer_float64_atomics: Bool32::default(),
            shader_buffer_float64_atomic_add: Bool32::default(),
            shader_shared_float32_atomics: Bool32::default(),
            shader_shared_float32_atomic_add: Bool32::default(),
            shader_shared_float64_atomics: Bool32::default(),
            shader_shared_float64_atomic_add: Bool32::default(),
            shader_image_float32_atomics: Bool32::default(),
            shader_image_float32_atomic_add: Bool32::default(),
            sparse_image_float32_atomics: Bool32::default(),
            sparse_image_float32_atomic_add: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderAtomicFloatFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT;
}
impl PhysicalDeviceShaderAtomicFloatFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'a> {
        PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceShaderAtomicFloatFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderAtomicFloatFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderAtomicFloatFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceShaderAtomicFloatFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn shader_buffer_float32_atomics(mut self, shader_buffer_float32_atomics: bool) -> Self {
        self.inner.shader_buffer_float32_atomics = shader_buffer_float32_atomics.into();
        self
    }
    #[inline]
    pub fn shader_buffer_float32_atomic_add(
        mut self,
        shader_buffer_float32_atomic_add: bool,
    ) -> Self {
        self.inner.shader_buffer_float32_atomic_add = shader_buffer_float32_atomic_add.into();
        self
    }
    #[inline]
    pub fn shader_buffer_float64_atomics(mut self, shader_buffer_float64_atomics: bool) -> Self {
        self.inner.shader_buffer_float64_atomics = shader_buffer_float64_atomics.into();
        self
    }
    #[inline]
    pub fn shader_buffer_float64_atomic_add(
        mut self,
        shader_buffer_float64_atomic_add: bool,
    ) -> Self {
        self.inner.shader_buffer_float64_atomic_add = shader_buffer_float64_atomic_add.into();
        self
    }
    #[inline]
    pub fn shader_shared_float32_atomics(mut self, shader_shared_float32_atomics: bool) -> Self {
        self.inner.shader_shared_float32_atomics = shader_shared_float32_atomics.into();
        self
    }
    #[inline]
    pub fn shader_shared_float32_atomic_add(
        mut self,
        shader_shared_float32_atomic_add: bool,
    ) -> Self {
        self.inner.shader_shared_float32_atomic_add = shader_shared_float32_atomic_add.into();
        self
    }
    #[inline]
    pub fn shader_shared_float64_atomics(mut self, shader_shared_float64_atomics: bool) -> Self {
        self.inner.shader_shared_float64_atomics = shader_shared_float64_atomics.into();
        self
    }
    #[inline]
    pub fn shader_shared_float64_atomic_add(
        mut self,
        shader_shared_float64_atomic_add: bool,
    ) -> Self {
        self.inner.shader_shared_float64_atomic_add = shader_shared_float64_atomic_add.into();
        self
    }
    #[inline]
    pub fn shader_image_float32_atomics(mut self, shader_image_float32_atomics: bool) -> Self {
        self.inner.shader_image_float32_atomics = shader_image_float32_atomics.into();
        self
    }
    #[inline]
    pub fn shader_image_float32_atomic_add(
        mut self,
        shader_image_float32_atomic_add: bool,
    ) -> Self {
        self.inner.shader_image_float32_atomic_add = shader_image_float32_atomic_add.into();
        self
    }
    #[inline]
    pub fn sparse_image_float32_atomics(mut self, sparse_image_float32_atomics: bool) -> Self {
        self.inner.sparse_image_float32_atomics = sparse_image_float32_atomics.into();
        self
    }
    #[inline]
    pub fn sparse_image_float32_atomic_add(
        mut self,
        sparse_image_float32_atomic_add: bool,
    ) -> Self {
        self.inner.sparse_image_float32_atomic_add = sparse_image_float32_atomic_add.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderAtomicFloatFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html>"]
pub struct PhysicalDeviceShaderAtomicFloat2FeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_buffer_float16_atomics: Bool32,
    pub shader_buffer_float16_atomic_add: Bool32,
    pub shader_buffer_float16_atomic_min_max: Bool32,
    pub shader_buffer_float32_atomic_min_max: Bool32,
    pub shader_buffer_float64_atomic_min_max: Bool32,
    pub shader_shared_float16_atomics: Bool32,
    pub shader_shared_float16_atomic_add: Bool32,
    pub shader_shared_float16_atomic_min_max: Bool32,
    pub shader_shared_float32_atomic_min_max: Bool32,
    pub shader_shared_float64_atomic_min_max: Bool32,
    pub shader_image_float32_atomic_min_max: Bool32,
    pub sparse_image_float32_atomic_min_max: Bool32,
}
impl ::std::default::Default for PhysicalDeviceShaderAtomicFloat2FeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_buffer_float16_atomics: Bool32::default(),
            shader_buffer_float16_atomic_add: Bool32::default(),
            shader_buffer_float16_atomic_min_max: Bool32::default(),
            shader_buffer_float32_atomic_min_max: Bool32::default(),
            shader_buffer_float64_atomic_min_max: Bool32::default(),
            shader_shared_float16_atomics: Bool32::default(),
            shader_shared_float16_atomic_add: Bool32::default(),
            shader_shared_float16_atomic_min_max: Bool32::default(),
            shader_shared_float32_atomic_min_max: Bool32::default(),
            shader_shared_float64_atomic_min_max: Bool32::default(),
            shader_image_float32_atomic_min_max: Bool32::default(),
            sparse_image_float32_atomic_min_max: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderAtomicFloat2FeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT;
}
impl PhysicalDeviceShaderAtomicFloat2FeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceShaderAtomicFloat2FeaturesEXTBuilder<'a> {
        PhysicalDeviceShaderAtomicFloat2FeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderAtomicFloat2FeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceShaderAtomicFloat2FeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceShaderAtomicFloat2FeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderAtomicFloat2FeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderAtomicFloat2FeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderAtomicFloat2FeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderAtomicFloat2FeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceShaderAtomicFloat2FeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderAtomicFloat2FeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderAtomicFloat2FeaturesEXTBuilder<'a> {
    #[inline]
    pub fn shader_buffer_float16_atomics(mut self, shader_buffer_float16_atomics: bool) -> Self {
        self.inner.shader_buffer_float16_atomics = shader_buffer_float16_atomics.into();
        self
    }
    #[inline]
    pub fn shader_buffer_float16_atomic_add(
        mut self,
        shader_buffer_float16_atomic_add: bool,
    ) -> Self {
        self.inner.shader_buffer_float16_atomic_add = shader_buffer_float16_atomic_add.into();
        self
    }
    #[inline]
    pub fn shader_buffer_float16_atomic_min_max(
        mut self,
        shader_buffer_float16_atomic_min_max: bool,
    ) -> Self {
        self.inner.shader_buffer_float16_atomic_min_max =
            shader_buffer_float16_atomic_min_max.into();
        self
    }
    #[inline]
    pub fn shader_buffer_float32_atomic_min_max(
        mut self,
        shader_buffer_float32_atomic_min_max: bool,
    ) -> Self {
        self.inner.shader_buffer_float32_atomic_min_max =
            shader_buffer_float32_atomic_min_max.into();
        self
    }
    #[inline]
    pub fn shader_buffer_float64_atomic_min_max(
        mut self,
        shader_buffer_float64_atomic_min_max: bool,
    ) -> Self {
        self.inner.shader_buffer_float64_atomic_min_max =
            shader_buffer_float64_atomic_min_max.into();
        self
    }
    #[inline]
    pub fn shader_shared_float16_atomics(mut self, shader_shared_float16_atomics: bool) -> Self {
        self.inner.shader_shared_float16_atomics = shader_shared_float16_atomics.into();
        self
    }
    #[inline]
    pub fn shader_shared_float16_atomic_add(
        mut self,
        shader_shared_float16_atomic_add: bool,
    ) -> Self {
        self.inner.shader_shared_float16_atomic_add = shader_shared_float16_atomic_add.into();
        self
    }
    #[inline]
    pub fn shader_shared_float16_atomic_min_max(
        mut self,
        shader_shared_float16_atomic_min_max: bool,
    ) -> Self {
        self.inner.shader_shared_float16_atomic_min_max =
            shader_shared_float16_atomic_min_max.into();
        self
    }
    #[inline]
    pub fn shader_shared_float32_atomic_min_max(
        mut self,
        shader_shared_float32_atomic_min_max: bool,
    ) -> Self {
        self.inner.shader_shared_float32_atomic_min_max =
            shader_shared_float32_atomic_min_max.into();
        self
    }
    #[inline]
    pub fn shader_shared_float64_atomic_min_max(
        mut self,
        shader_shared_float64_atomic_min_max: bool,
    ) -> Self {
        self.inner.shader_shared_float64_atomic_min_max =
            shader_shared_float64_atomic_min_max.into();
        self
    }
    #[inline]
    pub fn shader_image_float32_atomic_min_max(
        mut self,
        shader_image_float32_atomic_min_max: bool,
    ) -> Self {
        self.inner.shader_image_float32_atomic_min_max = shader_image_float32_atomic_min_max.into();
        self
    }
    #[inline]
    pub fn sparse_image_float32_atomic_min_max(
        mut self,
        sparse_image_float32_atomic_min_max: bool,
    ) -> Self {
        self.inner.sparse_image_float32_atomic_min_max = sparse_image_float32_atomic_min_max.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderAtomicFloat2FeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.html>"]
pub struct PhysicalDeviceVertexAttributeDivisorFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub vertex_attribute_instance_rate_divisor: Bool32,
    pub vertex_attribute_instance_rate_zero_divisor: Bool32,
}
impl ::std::default::Default for PhysicalDeviceVertexAttributeDivisorFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            vertex_attribute_instance_rate_divisor: Bool32::default(),
            vertex_attribute_instance_rate_zero_divisor: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceVertexAttributeDivisorFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT;
}
impl PhysicalDeviceVertexAttributeDivisorFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceVertexAttributeDivisorFeaturesEXTBuilder<'a> {
        PhysicalDeviceVertexAttributeDivisorFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceVertexAttributeDivisorFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceVertexAttributeDivisorFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceVertexAttributeDivisorFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVertexAttributeDivisorFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVertexAttributeDivisorFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVertexAttributeDivisorFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceVertexAttributeDivisorFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceVertexAttributeDivisorFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceVertexAttributeDivisorFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceVertexAttributeDivisorFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn vertex_attribute_instance_rate_divisor(
        mut self,
        vertex_attribute_instance_rate_divisor: bool,
    ) -> Self {
        self.inner.vertex_attribute_instance_rate_divisor =
            vertex_attribute_instance_rate_divisor.into();
        self
    }
    #[inline]
    pub fn vertex_attribute_instance_rate_zero_divisor(
        mut self,
        vertex_attribute_instance_rate_zero_divisor: bool,
    ) -> Self {
        self.inner.vertex_attribute_instance_rate_zero_divisor =
            vertex_attribute_instance_rate_zero_divisor.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceVertexAttributeDivisorFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyCheckpointPropertiesNV.html>"]
pub struct QueueFamilyCheckpointPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub checkpoint_execution_stage_mask: PipelineStageFlags,
}
impl ::std::default::Default for QueueFamilyCheckpointPropertiesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            checkpoint_execution_stage_mask: PipelineStageFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for QueueFamilyCheckpointPropertiesNV {
    const STRUCTURE_TYPE: StructureType = StructureType::QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV;
}
impl QueueFamilyCheckpointPropertiesNV {
    pub fn builder<'a>() -> QueueFamilyCheckpointPropertiesNVBuilder<'a> {
        QueueFamilyCheckpointPropertiesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct QueueFamilyCheckpointPropertiesNVBuilder<'a> {
    inner: QueueFamilyCheckpointPropertiesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsQueueFamilyProperties2 for QueueFamilyCheckpointPropertiesNVBuilder<'_> {}
unsafe impl ExtendsQueueFamilyProperties2 for QueueFamilyCheckpointPropertiesNV {}
impl<'a> ::std::ops::Deref for QueueFamilyCheckpointPropertiesNVBuilder<'a> {
    type Target = QueueFamilyCheckpointPropertiesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for QueueFamilyCheckpointPropertiesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> QueueFamilyCheckpointPropertiesNVBuilder<'a> {
    #[inline]
    pub fn checkpoint_execution_stage_mask(
        mut self,
        checkpoint_execution_stage_mask: PipelineStageFlags,
    ) -> Self {
        self.inner.checkpoint_execution_stage_mask = checkpoint_execution_stage_mask;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> QueueFamilyCheckpointPropertiesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCheckpointDataNV.html>"]
pub struct CheckpointDataNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub stage: PipelineStageFlags,
    pub p_checkpoint_marker: *mut c_void,
}
impl ::std::default::Default for CheckpointDataNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            stage: PipelineStageFlags::default(),
            p_checkpoint_marker: ::std::ptr::null_mut(),
        }
    }
}
unsafe impl TaggedStructure for CheckpointDataNV {
    const STRUCTURE_TYPE: StructureType = StructureType::CHECKPOINT_DATA_NV;
}
impl CheckpointDataNV {
    pub fn builder<'a>() -> CheckpointDataNVBuilder<'a> {
        CheckpointDataNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CheckpointDataNVBuilder<'a> {
    inner: CheckpointDataNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CheckpointDataNVBuilder<'a> {
    type Target = CheckpointDataNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CheckpointDataNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CheckpointDataNVBuilder<'a> {
    #[inline]
    pub fn stage(mut self, stage: PipelineStageFlags) -> Self {
        self.inner.stage = stage;
        self
    }
    #[inline]
    pub fn checkpoint_marker(mut self, checkpoint_marker: *mut c_void) -> Self {
        self.inner.p_checkpoint_marker = checkpoint_marker;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CheckpointDataNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDepthStencilResolveProperties.html>"]
pub struct PhysicalDeviceDepthStencilResolveProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub supported_depth_resolve_modes: ResolveModeFlags,
    pub supported_stencil_resolve_modes: ResolveModeFlags,
    pub independent_resolve_none: Bool32,
    pub independent_resolve: Bool32,
}
impl ::std::default::Default for PhysicalDeviceDepthStencilResolveProperties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            supported_depth_resolve_modes: ResolveModeFlags::default(),
            supported_stencil_resolve_modes: ResolveModeFlags::default(),
            independent_resolve_none: Bool32::default(),
            independent_resolve: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceDepthStencilResolveProperties {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES;
}
impl PhysicalDeviceDepthStencilResolveProperties {
    pub fn builder<'a>() -> PhysicalDeviceDepthStencilResolvePropertiesBuilder<'a> {
        PhysicalDeviceDepthStencilResolvePropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceDepthStencilResolvePropertiesBuilder<'a> {
    inner: PhysicalDeviceDepthStencilResolveProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceDepthStencilResolvePropertiesBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceDepthStencilResolveProperties {}
impl<'a> ::std::ops::Deref for PhysicalDeviceDepthStencilResolvePropertiesBuilder<'a> {
    type Target = PhysicalDeviceDepthStencilResolveProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceDepthStencilResolvePropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceDepthStencilResolvePropertiesBuilder<'a> {
    #[inline]
    pub fn supported_depth_resolve_modes(
        mut self,
        supported_depth_resolve_modes: ResolveModeFlags,
    ) -> Self {
        self.inner.supported_depth_resolve_modes = supported_depth_resolve_modes;
        self
    }
    #[inline]
    pub fn supported_stencil_resolve_modes(
        mut self,
        supported_stencil_resolve_modes: ResolveModeFlags,
    ) -> Self {
        self.inner.supported_stencil_resolve_modes = supported_stencil_resolve_modes;
        self
    }
    #[inline]
    pub fn independent_resolve_none(mut self, independent_resolve_none: bool) -> Self {
        self.inner.independent_resolve_none = independent_resolve_none.into();
        self
    }
    #[inline]
    pub fn independent_resolve(mut self, independent_resolve: bool) -> Self {
        self.inner.independent_resolve = independent_resolve.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceDepthStencilResolveProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDescriptionDepthStencilResolve.html>"]
pub struct SubpassDescriptionDepthStencilResolve {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub depth_resolve_mode: ResolveModeFlags,
    pub stencil_resolve_mode: ResolveModeFlags,
    pub p_depth_stencil_resolve_attachment: *const AttachmentReference2,
}
impl ::std::default::Default for SubpassDescriptionDepthStencilResolve {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            depth_resolve_mode: ResolveModeFlags::default(),
            stencil_resolve_mode: ResolveModeFlags::default(),
            p_depth_stencil_resolve_attachment: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for SubpassDescriptionDepthStencilResolve {
    const STRUCTURE_TYPE: StructureType = StructureType::SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE;
}
impl SubpassDescriptionDepthStencilResolve {
    pub fn builder<'a>() -> SubpassDescriptionDepthStencilResolveBuilder<'a> {
        SubpassDescriptionDepthStencilResolveBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SubpassDescriptionDepthStencilResolveBuilder<'a> {
    inner: SubpassDescriptionDepthStencilResolve,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSubpassDescription2 for SubpassDescriptionDepthStencilResolveBuilder<'_> {}
unsafe impl ExtendsSubpassDescription2 for SubpassDescriptionDepthStencilResolve {}
impl<'a> ::std::ops::Deref for SubpassDescriptionDepthStencilResolveBuilder<'a> {
    type Target = SubpassDescriptionDepthStencilResolve;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SubpassDescriptionDepthStencilResolveBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SubpassDescriptionDepthStencilResolveBuilder<'a> {
    #[inline]
    pub fn depth_resolve_mode(mut self, depth_resolve_mode: ResolveModeFlags) -> Self {
        self.inner.depth_resolve_mode = depth_resolve_mode;
        self
    }
    #[inline]
    pub fn stencil_resolve_mode(mut self, stencil_resolve_mode: ResolveModeFlags) -> Self {
        self.inner.stencil_resolve_mode = stencil_resolve_mode;
        self
    }
    #[inline]
    pub fn depth_stencil_resolve_attachment(
        mut self,
        depth_stencil_resolve_attachment: &'a AttachmentReference2,
    ) -> Self {
        self.inner.p_depth_stencil_resolve_attachment = depth_stencil_resolve_attachment;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SubpassDescriptionDepthStencilResolve {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewASTCDecodeModeEXT.html>"]
pub struct ImageViewASTCDecodeModeEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub decode_mode: Format,
}
impl ::std::default::Default for ImageViewASTCDecodeModeEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            decode_mode: Format::default(),
        }
    }
}
unsafe impl TaggedStructure for ImageViewASTCDecodeModeEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_VIEW_ASTC_DECODE_MODE_EXT;
}
impl ImageViewASTCDecodeModeEXT {
    pub fn builder<'a>() -> ImageViewASTCDecodeModeEXTBuilder<'a> {
        ImageViewASTCDecodeModeEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageViewASTCDecodeModeEXTBuilder<'a> {
    inner: ImageViewASTCDecodeModeEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageViewCreateInfo for ImageViewASTCDecodeModeEXTBuilder<'_> {}
unsafe impl ExtendsImageViewCreateInfo for ImageViewASTCDecodeModeEXT {}
impl<'a> ::std::ops::Deref for ImageViewASTCDecodeModeEXTBuilder<'a> {
    type Target = ImageViewASTCDecodeModeEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageViewASTCDecodeModeEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageViewASTCDecodeModeEXTBuilder<'a> {
    #[inline]
    pub fn decode_mode(mut self, decode_mode: Format) -> Self {
        self.inner.decode_mode = decode_mode;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageViewASTCDecodeModeEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceASTCDecodeFeaturesEXT.html>"]
pub struct PhysicalDeviceASTCDecodeFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub decode_mode_shared_exponent: Bool32,
}
impl ::std::default::Default for PhysicalDeviceASTCDecodeFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            decode_mode_shared_exponent: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceASTCDecodeFeaturesEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT;
}
impl PhysicalDeviceASTCDecodeFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceASTCDecodeFeaturesEXTBuilder<'a> {
        PhysicalDeviceASTCDecodeFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceASTCDecodeFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceASTCDecodeFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceASTCDecodeFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceASTCDecodeFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceASTCDecodeFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceASTCDecodeFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceASTCDecodeFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceASTCDecodeFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceASTCDecodeFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceASTCDecodeFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn decode_mode_shared_exponent(mut self, decode_mode_shared_exponent: bool) -> Self {
        self.inner.decode_mode_shared_exponent = decode_mode_shared_exponent.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceASTCDecodeFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTransformFeedbackFeaturesEXT.html>"]
pub struct PhysicalDeviceTransformFeedbackFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub transform_feedback: Bool32,
    pub geometry_streams: Bool32,
}
impl ::std::default::Default for PhysicalDeviceTransformFeedbackFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            transform_feedback: Bool32::default(),
            geometry_streams: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceTransformFeedbackFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT;
}
impl PhysicalDeviceTransformFeedbackFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceTransformFeedbackFeaturesEXTBuilder<'a> {
        PhysicalDeviceTransformFeedbackFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceTransformFeedbackFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceTransformFeedbackFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceTransformFeedbackFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceTransformFeedbackFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceTransformFeedbackFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceTransformFeedbackFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceTransformFeedbackFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceTransformFeedbackFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceTransformFeedbackFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceTransformFeedbackFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn transform_feedback(mut self, transform_feedback: bool) -> Self {
        self.inner.transform_feedback = transform_feedback.into();
        self
    }
    #[inline]
    pub fn geometry_streams(mut self, geometry_streams: bool) -> Self {
        self.inner.geometry_streams = geometry_streams.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceTransformFeedbackFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTransformFeedbackPropertiesEXT.html>"]
pub struct PhysicalDeviceTransformFeedbackPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_transform_feedback_streams: u32,
    pub max_transform_feedback_buffers: u32,
    pub max_transform_feedback_buffer_size: DeviceSize,
    pub max_transform_feedback_stream_data_size: u32,
    pub max_transform_feedback_buffer_data_size: u32,
    pub max_transform_feedback_buffer_data_stride: u32,
    pub transform_feedback_queries: Bool32,
    pub transform_feedback_streams_lines_triangles: Bool32,
    pub transform_feedback_rasterization_stream_select: Bool32,
    pub transform_feedback_draw: Bool32,
}
impl ::std::default::Default for PhysicalDeviceTransformFeedbackPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_transform_feedback_streams: u32::default(),
            max_transform_feedback_buffers: u32::default(),
            max_transform_feedback_buffer_size: DeviceSize::default(),
            max_transform_feedback_stream_data_size: u32::default(),
            max_transform_feedback_buffer_data_size: u32::default(),
            max_transform_feedback_buffer_data_stride: u32::default(),
            transform_feedback_queries: Bool32::default(),
            transform_feedback_streams_lines_triangles: Bool32::default(),
            transform_feedback_rasterization_stream_select: Bool32::default(),
            transform_feedback_draw: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceTransformFeedbackPropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT;
}
impl PhysicalDeviceTransformFeedbackPropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceTransformFeedbackPropertiesEXTBuilder<'a> {
        PhysicalDeviceTransformFeedbackPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceTransformFeedbackPropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceTransformFeedbackPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceTransformFeedbackPropertiesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceTransformFeedbackPropertiesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceTransformFeedbackPropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceTransformFeedbackPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceTransformFeedbackPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceTransformFeedbackPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn max_transform_feedback_streams(mut self, max_transform_feedback_streams: u32) -> Self {
        self.inner.max_transform_feedback_streams = max_transform_feedback_streams;
        self
    }
    #[inline]
    pub fn max_transform_feedback_buffers(mut self, max_transform_feedback_buffers: u32) -> Self {
        self.inner.max_transform_feedback_buffers = max_transform_feedback_buffers;
        self
    }
    #[inline]
    pub fn max_transform_feedback_buffer_size(
        mut self,
        max_transform_feedback_buffer_size: DeviceSize,
    ) -> Self {
        self.inner.max_transform_feedback_buffer_size = max_transform_feedback_buffer_size;
        self
    }
    #[inline]
    pub fn max_transform_feedback_stream_data_size(
        mut self,
        max_transform_feedback_stream_data_size: u32,
    ) -> Self {
        self.inner.max_transform_feedback_stream_data_size =
            max_transform_feedback_stream_data_size;
        self
    }
    #[inline]
    pub fn max_transform_feedback_buffer_data_size(
        mut self,
        max_transform_feedback_buffer_data_size: u32,
    ) -> Self {
        self.inner.max_transform_feedback_buffer_data_size =
            max_transform_feedback_buffer_data_size;
        self
    }
    #[inline]
    pub fn max_transform_feedback_buffer_data_stride(
        mut self,
        max_transform_feedback_buffer_data_stride: u32,
    ) -> Self {
        self.inner.max_transform_feedback_buffer_data_stride =
            max_transform_feedback_buffer_data_stride;
        self
    }
    #[inline]
    pub fn transform_feedback_queries(mut self, transform_feedback_queries: bool) -> Self {
        self.inner.transform_feedback_queries = transform_feedback_queries.into();
        self
    }
    #[inline]
    pub fn transform_feedback_streams_lines_triangles(
        mut self,
        transform_feedback_streams_lines_triangles: bool,
    ) -> Self {
        self.inner.transform_feedback_streams_lines_triangles =
            transform_feedback_streams_lines_triangles.into();
        self
    }
    #[inline]
    pub fn transform_feedback_rasterization_stream_select(
        mut self,
        transform_feedback_rasterization_stream_select: bool,
    ) -> Self {
        self.inner.transform_feedback_rasterization_stream_select =
            transform_feedback_rasterization_stream_select.into();
        self
    }
    #[inline]
    pub fn transform_feedback_draw(mut self, transform_feedback_draw: bool) -> Self {
        self.inner.transform_feedback_draw = transform_feedback_draw.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceTransformFeedbackPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateStreamCreateInfoEXT.html>"]
pub struct PipelineRasterizationStateStreamCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineRasterizationStateStreamCreateFlagsEXT,
    pub rasterization_stream: u32,
}
impl ::std::default::Default for PipelineRasterizationStateStreamCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineRasterizationStateStreamCreateFlagsEXT::default(),
            rasterization_stream: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineRasterizationStateStreamCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT;
}
impl PipelineRasterizationStateStreamCreateInfoEXT {
    pub fn builder<'a>() -> PipelineRasterizationStateStreamCreateInfoEXTBuilder<'a> {
        PipelineRasterizationStateStreamCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineRasterizationStateStreamCreateInfoEXTBuilder<'a> {
    inner: PipelineRasterizationStateStreamCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPipelineRasterizationStateCreateInfo
    for PipelineRasterizationStateStreamCreateInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsPipelineRasterizationStateCreateInfo
    for PipelineRasterizationStateStreamCreateInfoEXT
{
}
impl<'a> ::std::ops::Deref for PipelineRasterizationStateStreamCreateInfoEXTBuilder<'a> {
    type Target = PipelineRasterizationStateStreamCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineRasterizationStateStreamCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineRasterizationStateStreamCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineRasterizationStateStreamCreateFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn rasterization_stream(mut self, rasterization_stream: u32) -> Self {
        self.inner.rasterization_stream = rasterization_stream;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineRasterizationStateStreamCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.html>"]
pub struct PhysicalDeviceRepresentativeFragmentTestFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub representative_fragment_test: Bool32,
}
impl ::std::default::Default for PhysicalDeviceRepresentativeFragmentTestFeaturesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            representative_fragment_test: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceRepresentativeFragmentTestFeaturesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV;
}
impl PhysicalDeviceRepresentativeFragmentTestFeaturesNV {
    pub fn builder<'a>() -> PhysicalDeviceRepresentativeFragmentTestFeaturesNVBuilder<'a> {
        PhysicalDeviceRepresentativeFragmentTestFeaturesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceRepresentativeFragmentTestFeaturesNVBuilder<'a> {
    inner: PhysicalDeviceRepresentativeFragmentTestFeaturesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceRepresentativeFragmentTestFeaturesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRepresentativeFragmentTestFeaturesNV {}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceRepresentativeFragmentTestFeaturesNVBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRepresentativeFragmentTestFeaturesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceRepresentativeFragmentTestFeaturesNVBuilder<'a> {
    type Target = PhysicalDeviceRepresentativeFragmentTestFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceRepresentativeFragmentTestFeaturesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceRepresentativeFragmentTestFeaturesNVBuilder<'a> {
    #[inline]
    pub fn representative_fragment_test(mut self, representative_fragment_test: bool) -> Self {
        self.inner.representative_fragment_test = representative_fragment_test.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceRepresentativeFragmentTestFeaturesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRepresentativeFragmentTestStateCreateInfoNV.html>"]
pub struct PipelineRepresentativeFragmentTestStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub representative_fragment_test_enable: Bool32,
}
impl ::std::default::Default for PipelineRepresentativeFragmentTestStateCreateInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            representative_fragment_test_enable: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineRepresentativeFragmentTestStateCreateInfoNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV;
}
impl PipelineRepresentativeFragmentTestStateCreateInfoNV {
    pub fn builder<'a>() -> PipelineRepresentativeFragmentTestStateCreateInfoNVBuilder<'a> {
        PipelineRepresentativeFragmentTestStateCreateInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineRepresentativeFragmentTestStateCreateInfoNVBuilder<'a> {
    inner: PipelineRepresentativeFragmentTestStateCreateInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsGraphicsPipelineCreateInfo
    for PipelineRepresentativeFragmentTestStateCreateInfoNVBuilder<'_>
{
}
unsafe impl ExtendsGraphicsPipelineCreateInfo
    for PipelineRepresentativeFragmentTestStateCreateInfoNV
{
}
impl<'a> ::std::ops::Deref for PipelineRepresentativeFragmentTestStateCreateInfoNVBuilder<'a> {
    type Target = PipelineRepresentativeFragmentTestStateCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineRepresentativeFragmentTestStateCreateInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineRepresentativeFragmentTestStateCreateInfoNVBuilder<'a> {
    #[inline]
    pub fn representative_fragment_test_enable(
        mut self,
        representative_fragment_test_enable: bool,
    ) -> Self {
        self.inner.representative_fragment_test_enable = representative_fragment_test_enable.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineRepresentativeFragmentTestStateCreateInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExclusiveScissorFeaturesNV.html>"]
pub struct PhysicalDeviceExclusiveScissorFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub exclusive_scissor: Bool32,
}
impl ::std::default::Default for PhysicalDeviceExclusiveScissorFeaturesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            exclusive_scissor: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceExclusiveScissorFeaturesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV;
}
impl PhysicalDeviceExclusiveScissorFeaturesNV {
    pub fn builder<'a>() -> PhysicalDeviceExclusiveScissorFeaturesNVBuilder<'a> {
        PhysicalDeviceExclusiveScissorFeaturesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceExclusiveScissorFeaturesNVBuilder<'a> {
    inner: PhysicalDeviceExclusiveScissorFeaturesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceExclusiveScissorFeaturesNVBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceExclusiveScissorFeaturesNV {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceExclusiveScissorFeaturesNVBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceExclusiveScissorFeaturesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceExclusiveScissorFeaturesNVBuilder<'a> {
    type Target = PhysicalDeviceExclusiveScissorFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceExclusiveScissorFeaturesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceExclusiveScissorFeaturesNVBuilder<'a> {
    #[inline]
    pub fn exclusive_scissor(mut self, exclusive_scissor: bool) -> Self {
        self.inner.exclusive_scissor = exclusive_scissor.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceExclusiveScissorFeaturesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportExclusiveScissorStateCreateInfoNV.html>"]
pub struct PipelineViewportExclusiveScissorStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub exclusive_scissor_count: u32,
    pub p_exclusive_scissors: *const Rect2D,
}
impl ::std::default::Default for PipelineViewportExclusiveScissorStateCreateInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            exclusive_scissor_count: u32::default(),
            p_exclusive_scissors: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for PipelineViewportExclusiveScissorStateCreateInfoNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV;
}
impl PipelineViewportExclusiveScissorStateCreateInfoNV {
    pub fn builder<'a>() -> PipelineViewportExclusiveScissorStateCreateInfoNVBuilder<'a> {
        PipelineViewportExclusiveScissorStateCreateInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineViewportExclusiveScissorStateCreateInfoNVBuilder<'a> {
    inner: PipelineViewportExclusiveScissorStateCreateInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPipelineViewportStateCreateInfo
    for PipelineViewportExclusiveScissorStateCreateInfoNVBuilder<'_>
{
}
unsafe impl ExtendsPipelineViewportStateCreateInfo
    for PipelineViewportExclusiveScissorStateCreateInfoNV
{
}
impl<'a> ::std::ops::Deref for PipelineViewportExclusiveScissorStateCreateInfoNVBuilder<'a> {
    type Target = PipelineViewportExclusiveScissorStateCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineViewportExclusiveScissorStateCreateInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineViewportExclusiveScissorStateCreateInfoNVBuilder<'a> {
    #[inline]
    pub fn exclusive_scissors(mut self, exclusive_scissors: &'a [Rect2D]) -> Self {
        self.inner.exclusive_scissor_count = exclusive_scissors.len() as _;
        self.inner.p_exclusive_scissors = exclusive_scissors.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineViewportExclusiveScissorStateCreateInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCornerSampledImageFeaturesNV.html>"]
pub struct PhysicalDeviceCornerSampledImageFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub corner_sampled_image: Bool32,
}
impl ::std::default::Default for PhysicalDeviceCornerSampledImageFeaturesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            corner_sampled_image: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceCornerSampledImageFeaturesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV;
}
impl PhysicalDeviceCornerSampledImageFeaturesNV {
    pub fn builder<'a>() -> PhysicalDeviceCornerSampledImageFeaturesNVBuilder<'a> {
        PhysicalDeviceCornerSampledImageFeaturesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceCornerSampledImageFeaturesNVBuilder<'a> {
    inner: PhysicalDeviceCornerSampledImageFeaturesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceCornerSampledImageFeaturesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceCornerSampledImageFeaturesNV {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCornerSampledImageFeaturesNVBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCornerSampledImageFeaturesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceCornerSampledImageFeaturesNVBuilder<'a> {
    type Target = PhysicalDeviceCornerSampledImageFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceCornerSampledImageFeaturesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceCornerSampledImageFeaturesNVBuilder<'a> {
    #[inline]
    pub fn corner_sampled_image(mut self, corner_sampled_image: bool) -> Self {
        self.inner.corner_sampled_image = corner_sampled_image.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceCornerSampledImageFeaturesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.html>"]
pub struct PhysicalDeviceComputeShaderDerivativesFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub compute_derivative_group_quads: Bool32,
    pub compute_derivative_group_linear: Bool32,
}
impl ::std::default::Default for PhysicalDeviceComputeShaderDerivativesFeaturesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            compute_derivative_group_quads: Bool32::default(),
            compute_derivative_group_linear: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceComputeShaderDerivativesFeaturesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV;
}
impl PhysicalDeviceComputeShaderDerivativesFeaturesNV {
    pub fn builder<'a>() -> PhysicalDeviceComputeShaderDerivativesFeaturesNVBuilder<'a> {
        PhysicalDeviceComputeShaderDerivativesFeaturesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceComputeShaderDerivativesFeaturesNVBuilder<'a> {
    inner: PhysicalDeviceComputeShaderDerivativesFeaturesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceComputeShaderDerivativesFeaturesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceComputeShaderDerivativesFeaturesNV {}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceComputeShaderDerivativesFeaturesNVBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceComputeShaderDerivativesFeaturesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceComputeShaderDerivativesFeaturesNVBuilder<'a> {
    type Target = PhysicalDeviceComputeShaderDerivativesFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceComputeShaderDerivativesFeaturesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceComputeShaderDerivativesFeaturesNVBuilder<'a> {
    #[inline]
    pub fn compute_derivative_group_quads(mut self, compute_derivative_group_quads: bool) -> Self {
        self.inner.compute_derivative_group_quads = compute_derivative_group_quads.into();
        self
    }
    #[inline]
    pub fn compute_derivative_group_linear(
        mut self,
        compute_derivative_group_linear: bool,
    ) -> Self {
        self.inner.compute_derivative_group_linear = compute_derivative_group_linear.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceComputeShaderDerivativesFeaturesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderImageFootprintFeaturesNV.html>"]
pub struct PhysicalDeviceShaderImageFootprintFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_footprint: Bool32,
}
impl ::std::default::Default for PhysicalDeviceShaderImageFootprintFeaturesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            image_footprint: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderImageFootprintFeaturesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV;
}
impl PhysicalDeviceShaderImageFootprintFeaturesNV {
    pub fn builder<'a>() -> PhysicalDeviceShaderImageFootprintFeaturesNVBuilder<'a> {
        PhysicalDeviceShaderImageFootprintFeaturesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderImageFootprintFeaturesNVBuilder<'a> {
    inner: PhysicalDeviceShaderImageFootprintFeaturesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceShaderImageFootprintFeaturesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderImageFootprintFeaturesNV {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderImageFootprintFeaturesNVBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderImageFootprintFeaturesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderImageFootprintFeaturesNVBuilder<'a> {
    type Target = PhysicalDeviceShaderImageFootprintFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderImageFootprintFeaturesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderImageFootprintFeaturesNVBuilder<'a> {
    #[inline]
    pub fn image_footprint(mut self, image_footprint: bool) -> Self {
        self.inner.image_footprint = image_footprint.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderImageFootprintFeaturesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.html>"]
pub struct PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub dedicated_allocation_image_aliasing: Bool32,
}
impl ::std::default::Default for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            dedicated_allocation_image_aliasing: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV;
}
impl PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
    pub fn builder<'a>() -> PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVBuilder<'a> {
        PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVBuilder<'a> {
    inner: PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV
{
}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVBuilder<'a> {
    type Target = PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut
    for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVBuilder<'a>
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVBuilder<'a> {
    #[inline]
    pub fn dedicated_allocation_image_aliasing(
        mut self,
        dedicated_allocation_image_aliasing: bool,
    ) -> Self {
        self.inner.dedicated_allocation_image_aliasing = dedicated_allocation_image_aliasing.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCopyMemoryIndirectFeaturesNV.html>"]
pub struct PhysicalDeviceCopyMemoryIndirectFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub indirect_copy: Bool32,
}
impl ::std::default::Default for PhysicalDeviceCopyMemoryIndirectFeaturesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            indirect_copy: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceCopyMemoryIndirectFeaturesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV;
}
impl PhysicalDeviceCopyMemoryIndirectFeaturesNV {
    pub fn builder<'a>() -> PhysicalDeviceCopyMemoryIndirectFeaturesNVBuilder<'a> {
        PhysicalDeviceCopyMemoryIndirectFeaturesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceCopyMemoryIndirectFeaturesNVBuilder<'a> {
    inner: PhysicalDeviceCopyMemoryIndirectFeaturesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceCopyMemoryIndirectFeaturesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceCopyMemoryIndirectFeaturesNV {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCopyMemoryIndirectFeaturesNVBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCopyMemoryIndirectFeaturesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceCopyMemoryIndirectFeaturesNVBuilder<'a> {
    type Target = PhysicalDeviceCopyMemoryIndirectFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceCopyMemoryIndirectFeaturesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceCopyMemoryIndirectFeaturesNVBuilder<'a> {
    #[inline]
    pub fn indirect_copy(mut self, indirect_copy: bool) -> Self {
        self.inner.indirect_copy = indirect_copy.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceCopyMemoryIndirectFeaturesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCopyMemoryIndirectPropertiesNV.html>"]
pub struct PhysicalDeviceCopyMemoryIndirectPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub supported_queues: QueueFlags,
}
impl ::std::default::Default for PhysicalDeviceCopyMemoryIndirectPropertiesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            supported_queues: QueueFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceCopyMemoryIndirectPropertiesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV;
}
impl PhysicalDeviceCopyMemoryIndirectPropertiesNV {
    pub fn builder<'a>() -> PhysicalDeviceCopyMemoryIndirectPropertiesNVBuilder<'a> {
        PhysicalDeviceCopyMemoryIndirectPropertiesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceCopyMemoryIndirectPropertiesNVBuilder<'a> {
    inner: PhysicalDeviceCopyMemoryIndirectPropertiesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceCopyMemoryIndirectPropertiesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceCopyMemoryIndirectPropertiesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceCopyMemoryIndirectPropertiesNVBuilder<'a> {
    type Target = PhysicalDeviceCopyMemoryIndirectPropertiesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceCopyMemoryIndirectPropertiesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceCopyMemoryIndirectPropertiesNVBuilder<'a> {
    #[inline]
    pub fn supported_queues(mut self, supported_queues: QueueFlags) -> Self {
        self.inner.supported_queues = supported_queues;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceCopyMemoryIndirectPropertiesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryDecompressionFeaturesNV.html>"]
pub struct PhysicalDeviceMemoryDecompressionFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_decompression: Bool32,
}
impl ::std::default::Default for PhysicalDeviceMemoryDecompressionFeaturesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            memory_decompression: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceMemoryDecompressionFeaturesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV;
}
impl PhysicalDeviceMemoryDecompressionFeaturesNV {
    pub fn builder<'a>() -> PhysicalDeviceMemoryDecompressionFeaturesNVBuilder<'a> {
        PhysicalDeviceMemoryDecompressionFeaturesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceMemoryDecompressionFeaturesNVBuilder<'a> {
    inner: PhysicalDeviceMemoryDecompressionFeaturesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceMemoryDecompressionFeaturesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMemoryDecompressionFeaturesNV {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMemoryDecompressionFeaturesNVBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMemoryDecompressionFeaturesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceMemoryDecompressionFeaturesNVBuilder<'a> {
    type Target = PhysicalDeviceMemoryDecompressionFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceMemoryDecompressionFeaturesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceMemoryDecompressionFeaturesNVBuilder<'a> {
    #[inline]
    pub fn memory_decompression(mut self, memory_decompression: bool) -> Self {
        self.inner.memory_decompression = memory_decompression.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceMemoryDecompressionFeaturesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryDecompressionPropertiesNV.html>"]
pub struct PhysicalDeviceMemoryDecompressionPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub decompression_methods: MemoryDecompressionMethodFlagsNV,
    pub max_decompression_indirect_count: u64,
}
impl ::std::default::Default for PhysicalDeviceMemoryDecompressionPropertiesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            decompression_methods: MemoryDecompressionMethodFlagsNV::default(),
            max_decompression_indirect_count: u64::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceMemoryDecompressionPropertiesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV;
}
impl PhysicalDeviceMemoryDecompressionPropertiesNV {
    pub fn builder<'a>() -> PhysicalDeviceMemoryDecompressionPropertiesNVBuilder<'a> {
        PhysicalDeviceMemoryDecompressionPropertiesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceMemoryDecompressionPropertiesNVBuilder<'a> {
    inner: PhysicalDeviceMemoryDecompressionPropertiesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceMemoryDecompressionPropertiesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceMemoryDecompressionPropertiesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceMemoryDecompressionPropertiesNVBuilder<'a> {
    type Target = PhysicalDeviceMemoryDecompressionPropertiesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceMemoryDecompressionPropertiesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceMemoryDecompressionPropertiesNVBuilder<'a> {
    #[inline]
    pub fn decompression_methods(
        mut self,
        decompression_methods: MemoryDecompressionMethodFlagsNV,
    ) -> Self {
        self.inner.decompression_methods = decompression_methods;
        self
    }
    #[inline]
    pub fn max_decompression_indirect_count(
        mut self,
        max_decompression_indirect_count: u64,
    ) -> Self {
        self.inner.max_decompression_indirect_count = max_decompression_indirect_count;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceMemoryDecompressionPropertiesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShadingRatePaletteNV.html>"]
pub struct ShadingRatePaletteNV {
    pub shading_rate_palette_entry_count: u32,
    pub p_shading_rate_palette_entries: *const ShadingRatePaletteEntryNV,
}
impl ::std::default::Default for ShadingRatePaletteNV {
    #[inline]
    fn default() -> Self {
        Self {
            shading_rate_palette_entry_count: u32::default(),
            p_shading_rate_palette_entries: ::std::ptr::null(),
        }
    }
}
impl ShadingRatePaletteNV {
    pub fn builder<'a>() -> ShadingRatePaletteNVBuilder<'a> {
        ShadingRatePaletteNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ShadingRatePaletteNVBuilder<'a> {
    inner: ShadingRatePaletteNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ShadingRatePaletteNVBuilder<'a> {
    type Target = ShadingRatePaletteNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ShadingRatePaletteNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ShadingRatePaletteNVBuilder<'a> {
    #[inline]
    pub fn shading_rate_palette_entries(
        mut self,
        shading_rate_palette_entries: &'a [ShadingRatePaletteEntryNV],
    ) -> Self {
        self.inner.shading_rate_palette_entry_count = shading_rate_palette_entries.len() as _;
        self.inner.p_shading_rate_palette_entries = shading_rate_palette_entries.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ShadingRatePaletteNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportShadingRateImageStateCreateInfoNV.html>"]
pub struct PipelineViewportShadingRateImageStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub shading_rate_image_enable: Bool32,
    pub viewport_count: u32,
    pub p_shading_rate_palettes: *const ShadingRatePaletteNV,
}
impl ::std::default::Default for PipelineViewportShadingRateImageStateCreateInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            shading_rate_image_enable: Bool32::default(),
            viewport_count: u32::default(),
            p_shading_rate_palettes: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for PipelineViewportShadingRateImageStateCreateInfoNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV;
}
impl PipelineViewportShadingRateImageStateCreateInfoNV {
    pub fn builder<'a>() -> PipelineViewportShadingRateImageStateCreateInfoNVBuilder<'a> {
        PipelineViewportShadingRateImageStateCreateInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineViewportShadingRateImageStateCreateInfoNVBuilder<'a> {
    inner: PipelineViewportShadingRateImageStateCreateInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPipelineViewportStateCreateInfo
    for PipelineViewportShadingRateImageStateCreateInfoNVBuilder<'_>
{
}
unsafe impl ExtendsPipelineViewportStateCreateInfo
    for PipelineViewportShadingRateImageStateCreateInfoNV
{
}
impl<'a> ::std::ops::Deref for PipelineViewportShadingRateImageStateCreateInfoNVBuilder<'a> {
    type Target = PipelineViewportShadingRateImageStateCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineViewportShadingRateImageStateCreateInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineViewportShadingRateImageStateCreateInfoNVBuilder<'a> {
    #[inline]
    pub fn shading_rate_image_enable(mut self, shading_rate_image_enable: bool) -> Self {
        self.inner.shading_rate_image_enable = shading_rate_image_enable.into();
        self
    }
    #[inline]
    pub fn shading_rate_palettes(
        mut self,
        shading_rate_palettes: &'a [ShadingRatePaletteNV],
    ) -> Self {
        self.inner.viewport_count = shading_rate_palettes.len() as _;
        self.inner.p_shading_rate_palettes = shading_rate_palettes.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineViewportShadingRateImageStateCreateInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShadingRateImageFeaturesNV.html>"]
pub struct PhysicalDeviceShadingRateImageFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shading_rate_image: Bool32,
    pub shading_rate_coarse_sample_order: Bool32,
}
impl ::std::default::Default for PhysicalDeviceShadingRateImageFeaturesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shading_rate_image: Bool32::default(),
            shading_rate_coarse_sample_order: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShadingRateImageFeaturesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV;
}
impl PhysicalDeviceShadingRateImageFeaturesNV {
    pub fn builder<'a>() -> PhysicalDeviceShadingRateImageFeaturesNVBuilder<'a> {
        PhysicalDeviceShadingRateImageFeaturesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShadingRateImageFeaturesNVBuilder<'a> {
    inner: PhysicalDeviceShadingRateImageFeaturesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShadingRateImageFeaturesNVBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShadingRateImageFeaturesNV {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShadingRateImageFeaturesNVBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShadingRateImageFeaturesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShadingRateImageFeaturesNVBuilder<'a> {
    type Target = PhysicalDeviceShadingRateImageFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShadingRateImageFeaturesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShadingRateImageFeaturesNVBuilder<'a> {
    #[inline]
    pub fn shading_rate_image(mut self, shading_rate_image: bool) -> Self {
        self.inner.shading_rate_image = shading_rate_image.into();
        self
    }
    #[inline]
    pub fn shading_rate_coarse_sample_order(
        mut self,
        shading_rate_coarse_sample_order: bool,
    ) -> Self {
        self.inner.shading_rate_coarse_sample_order = shading_rate_coarse_sample_order.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShadingRateImageFeaturesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShadingRateImagePropertiesNV.html>"]
pub struct PhysicalDeviceShadingRateImagePropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shading_rate_texel_size: Extent2D,
    pub shading_rate_palette_size: u32,
    pub shading_rate_max_coarse_samples: u32,
}
impl ::std::default::Default for PhysicalDeviceShadingRateImagePropertiesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shading_rate_texel_size: Extent2D::default(),
            shading_rate_palette_size: u32::default(),
            shading_rate_max_coarse_samples: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShadingRateImagePropertiesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV;
}
impl PhysicalDeviceShadingRateImagePropertiesNV {
    pub fn builder<'a>() -> PhysicalDeviceShadingRateImagePropertiesNVBuilder<'a> {
        PhysicalDeviceShadingRateImagePropertiesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShadingRateImagePropertiesNVBuilder<'a> {
    inner: PhysicalDeviceShadingRateImagePropertiesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceShadingRateImagePropertiesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceShadingRateImagePropertiesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShadingRateImagePropertiesNVBuilder<'a> {
    type Target = PhysicalDeviceShadingRateImagePropertiesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShadingRateImagePropertiesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShadingRateImagePropertiesNVBuilder<'a> {
    #[inline]
    pub fn shading_rate_texel_size(mut self, shading_rate_texel_size: Extent2D) -> Self {
        self.inner.shading_rate_texel_size = shading_rate_texel_size;
        self
    }
    #[inline]
    pub fn shading_rate_palette_size(mut self, shading_rate_palette_size: u32) -> Self {
        self.inner.shading_rate_palette_size = shading_rate_palette_size;
        self
    }
    #[inline]
    pub fn shading_rate_max_coarse_samples(mut self, shading_rate_max_coarse_samples: u32) -> Self {
        self.inner.shading_rate_max_coarse_samples = shading_rate_max_coarse_samples;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShadingRateImagePropertiesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceInvocationMaskFeaturesHUAWEI.html>"]
pub struct PhysicalDeviceInvocationMaskFeaturesHUAWEI {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub invocation_mask: Bool32,
}
impl ::std::default::Default for PhysicalDeviceInvocationMaskFeaturesHUAWEI {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            invocation_mask: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceInvocationMaskFeaturesHUAWEI {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI;
}
impl PhysicalDeviceInvocationMaskFeaturesHUAWEI {
    pub fn builder<'a>() -> PhysicalDeviceInvocationMaskFeaturesHUAWEIBuilder<'a> {
        PhysicalDeviceInvocationMaskFeaturesHUAWEIBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceInvocationMaskFeaturesHUAWEIBuilder<'a> {
    inner: PhysicalDeviceInvocationMaskFeaturesHUAWEI,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceInvocationMaskFeaturesHUAWEIBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceInvocationMaskFeaturesHUAWEI {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceInvocationMaskFeaturesHUAWEIBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceInvocationMaskFeaturesHUAWEI {}
impl<'a> ::std::ops::Deref for PhysicalDeviceInvocationMaskFeaturesHUAWEIBuilder<'a> {
    type Target = PhysicalDeviceInvocationMaskFeaturesHUAWEI;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceInvocationMaskFeaturesHUAWEIBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceInvocationMaskFeaturesHUAWEIBuilder<'a> {
    #[inline]
    pub fn invocation_mask(mut self, invocation_mask: bool) -> Self {
        self.inner.invocation_mask = invocation_mask.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceInvocationMaskFeaturesHUAWEI {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCoarseSampleLocationNV.html>"]
pub struct CoarseSampleLocationNV {
    pub pixel_x: u32,
    pub pixel_y: u32,
    pub sample: u32,
}
impl CoarseSampleLocationNV {
    pub fn builder<'a>() -> CoarseSampleLocationNVBuilder<'a> {
        CoarseSampleLocationNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CoarseSampleLocationNVBuilder<'a> {
    inner: CoarseSampleLocationNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CoarseSampleLocationNVBuilder<'a> {
    type Target = CoarseSampleLocationNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CoarseSampleLocationNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CoarseSampleLocationNVBuilder<'a> {
    #[inline]
    pub fn pixel_x(mut self, pixel_x: u32) -> Self {
        self.inner.pixel_x = pixel_x;
        self
    }
    #[inline]
    pub fn pixel_y(mut self, pixel_y: u32) -> Self {
        self.inner.pixel_y = pixel_y;
        self
    }
    #[inline]
    pub fn sample(mut self, sample: u32) -> Self {
        self.inner.sample = sample;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CoarseSampleLocationNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCoarseSampleOrderCustomNV.html>"]
pub struct CoarseSampleOrderCustomNV {
    pub shading_rate: ShadingRatePaletteEntryNV,
    pub sample_count: u32,
    pub sample_location_count: u32,
    pub p_sample_locations: *const CoarseSampleLocationNV,
}
impl ::std::default::Default for CoarseSampleOrderCustomNV {
    #[inline]
    fn default() -> Self {
        Self {
            shading_rate: ShadingRatePaletteEntryNV::default(),
            sample_count: u32::default(),
            sample_location_count: u32::default(),
            p_sample_locations: ::std::ptr::null(),
        }
    }
}
impl CoarseSampleOrderCustomNV {
    pub fn builder<'a>() -> CoarseSampleOrderCustomNVBuilder<'a> {
        CoarseSampleOrderCustomNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CoarseSampleOrderCustomNVBuilder<'a> {
    inner: CoarseSampleOrderCustomNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CoarseSampleOrderCustomNVBuilder<'a> {
    type Target = CoarseSampleOrderCustomNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CoarseSampleOrderCustomNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CoarseSampleOrderCustomNVBuilder<'a> {
    #[inline]
    pub fn shading_rate(mut self, shading_rate: ShadingRatePaletteEntryNV) -> Self {
        self.inner.shading_rate = shading_rate;
        self
    }
    #[inline]
    pub fn sample_count(mut self, sample_count: u32) -> Self {
        self.inner.sample_count = sample_count;
        self
    }
    #[inline]
    pub fn sample_locations(mut self, sample_locations: &'a [CoarseSampleLocationNV]) -> Self {
        self.inner.sample_location_count = sample_locations.len() as _;
        self.inner.p_sample_locations = sample_locations.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CoarseSampleOrderCustomNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.html>"]
pub struct PipelineViewportCoarseSampleOrderStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub sample_order_type: CoarseSampleOrderTypeNV,
    pub custom_sample_order_count: u32,
    pub p_custom_sample_orders: *const CoarseSampleOrderCustomNV,
}
impl ::std::default::Default for PipelineViewportCoarseSampleOrderStateCreateInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            sample_order_type: CoarseSampleOrderTypeNV::default(),
            custom_sample_order_count: u32::default(),
            p_custom_sample_orders: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for PipelineViewportCoarseSampleOrderStateCreateInfoNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV;
}
impl PipelineViewportCoarseSampleOrderStateCreateInfoNV {
    pub fn builder<'a>() -> PipelineViewportCoarseSampleOrderStateCreateInfoNVBuilder<'a> {
        PipelineViewportCoarseSampleOrderStateCreateInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineViewportCoarseSampleOrderStateCreateInfoNVBuilder<'a> {
    inner: PipelineViewportCoarseSampleOrderStateCreateInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPipelineViewportStateCreateInfo
    for PipelineViewportCoarseSampleOrderStateCreateInfoNVBuilder<'_>
{
}
unsafe impl ExtendsPipelineViewportStateCreateInfo
    for PipelineViewportCoarseSampleOrderStateCreateInfoNV
{
}
impl<'a> ::std::ops::Deref for PipelineViewportCoarseSampleOrderStateCreateInfoNVBuilder<'a> {
    type Target = PipelineViewportCoarseSampleOrderStateCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineViewportCoarseSampleOrderStateCreateInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineViewportCoarseSampleOrderStateCreateInfoNVBuilder<'a> {
    #[inline]
    pub fn sample_order_type(mut self, sample_order_type: CoarseSampleOrderTypeNV) -> Self {
        self.inner.sample_order_type = sample_order_type;
        self
    }
    #[inline]
    pub fn custom_sample_orders(
        mut self,
        custom_sample_orders: &'a [CoarseSampleOrderCustomNV],
    ) -> Self {
        self.inner.custom_sample_order_count = custom_sample_orders.len() as _;
        self.inner.p_custom_sample_orders = custom_sample_orders.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineViewportCoarseSampleOrderStateCreateInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMeshShaderFeaturesNV.html>"]
pub struct PhysicalDeviceMeshShaderFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub task_shader: Bool32,
    pub mesh_shader: Bool32,
}
impl ::std::default::Default for PhysicalDeviceMeshShaderFeaturesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            task_shader: Bool32::default(),
            mesh_shader: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceMeshShaderFeaturesNV {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV;
}
impl PhysicalDeviceMeshShaderFeaturesNV {
    pub fn builder<'a>() -> PhysicalDeviceMeshShaderFeaturesNVBuilder<'a> {
        PhysicalDeviceMeshShaderFeaturesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceMeshShaderFeaturesNVBuilder<'a> {
    inner: PhysicalDeviceMeshShaderFeaturesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMeshShaderFeaturesNVBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMeshShaderFeaturesNV {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMeshShaderFeaturesNVBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMeshShaderFeaturesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceMeshShaderFeaturesNVBuilder<'a> {
    type Target = PhysicalDeviceMeshShaderFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceMeshShaderFeaturesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceMeshShaderFeaturesNVBuilder<'a> {
    #[inline]
    pub fn task_shader(mut self, task_shader: bool) -> Self {
        self.inner.task_shader = task_shader.into();
        self
    }
    #[inline]
    pub fn mesh_shader(mut self, mesh_shader: bool) -> Self {
        self.inner.mesh_shader = mesh_shader.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceMeshShaderFeaturesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMeshShaderPropertiesNV.html>"]
pub struct PhysicalDeviceMeshShaderPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_draw_mesh_tasks_count: u32,
    pub max_task_work_group_invocations: u32,
    pub max_task_work_group_size: [u32; 3],
    pub max_task_total_memory_size: u32,
    pub max_task_output_count: u32,
    pub max_mesh_work_group_invocations: u32,
    pub max_mesh_work_group_size: [u32; 3],
    pub max_mesh_total_memory_size: u32,
    pub max_mesh_output_vertices: u32,
    pub max_mesh_output_primitives: u32,
    pub max_mesh_multiview_view_count: u32,
    pub mesh_output_per_vertex_granularity: u32,
    pub mesh_output_per_primitive_granularity: u32,
}
impl ::std::default::Default for PhysicalDeviceMeshShaderPropertiesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_draw_mesh_tasks_count: u32::default(),
            max_task_work_group_invocations: u32::default(),
            max_task_work_group_size: unsafe { ::std::mem::zeroed() },
            max_task_total_memory_size: u32::default(),
            max_task_output_count: u32::default(),
            max_mesh_work_group_invocations: u32::default(),
            max_mesh_work_group_size: unsafe { ::std::mem::zeroed() },
            max_mesh_total_memory_size: u32::default(),
            max_mesh_output_vertices: u32::default(),
            max_mesh_output_primitives: u32::default(),
            max_mesh_multiview_view_count: u32::default(),
            mesh_output_per_vertex_granularity: u32::default(),
            mesh_output_per_primitive_granularity: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceMeshShaderPropertiesNV {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV;
}
impl PhysicalDeviceMeshShaderPropertiesNV {
    pub fn builder<'a>() -> PhysicalDeviceMeshShaderPropertiesNVBuilder<'a> {
        PhysicalDeviceMeshShaderPropertiesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceMeshShaderPropertiesNVBuilder<'a> {
    inner: PhysicalDeviceMeshShaderPropertiesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceMeshShaderPropertiesNVBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceMeshShaderPropertiesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceMeshShaderPropertiesNVBuilder<'a> {
    type Target = PhysicalDeviceMeshShaderPropertiesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceMeshShaderPropertiesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceMeshShaderPropertiesNVBuilder<'a> {
    #[inline]
    pub fn max_draw_mesh_tasks_count(mut self, max_draw_mesh_tasks_count: u32) -> Self {
        self.inner.max_draw_mesh_tasks_count = max_draw_mesh_tasks_count;
        self
    }
    #[inline]
    pub fn max_task_work_group_invocations(mut self, max_task_work_group_invocations: u32) -> Self {
        self.inner.max_task_work_group_invocations = max_task_work_group_invocations;
        self
    }
    #[inline]
    pub fn max_task_work_group_size(mut self, max_task_work_group_size: [u32; 3]) -> Self {
        self.inner.max_task_work_group_size = max_task_work_group_size;
        self
    }
    #[inline]
    pub fn max_task_total_memory_size(mut self, max_task_total_memory_size: u32) -> Self {
        self.inner.max_task_total_memory_size = max_task_total_memory_size;
        self
    }
    #[inline]
    pub fn max_task_output_count(mut self, max_task_output_count: u32) -> Self {
        self.inner.max_task_output_count = max_task_output_count;
        self
    }
    #[inline]
    pub fn max_mesh_work_group_invocations(mut self, max_mesh_work_group_invocations: u32) -> Self {
        self.inner.max_mesh_work_group_invocations = max_mesh_work_group_invocations;
        self
    }
    #[inline]
    pub fn max_mesh_work_group_size(mut self, max_mesh_work_group_size: [u32; 3]) -> Self {
        self.inner.max_mesh_work_group_size = max_mesh_work_group_size;
        self
    }
    #[inline]
    pub fn max_mesh_total_memory_size(mut self, max_mesh_total_memory_size: u32) -> Self {
        self.inner.max_mesh_total_memory_size = max_mesh_total_memory_size;
        self
    }
    #[inline]
    pub fn max_mesh_output_vertices(mut self, max_mesh_output_vertices: u32) -> Self {
        self.inner.max_mesh_output_vertices = max_mesh_output_vertices;
        self
    }
    #[inline]
    pub fn max_mesh_output_primitives(mut self, max_mesh_output_primitives: u32) -> Self {
        self.inner.max_mesh_output_primitives = max_mesh_output_primitives;
        self
    }
    #[inline]
    pub fn max_mesh_multiview_view_count(mut self, max_mesh_multiview_view_count: u32) -> Self {
        self.inner.max_mesh_multiview_view_count = max_mesh_multiview_view_count;
        self
    }
    #[inline]
    pub fn mesh_output_per_vertex_granularity(
        mut self,
        mesh_output_per_vertex_granularity: u32,
    ) -> Self {
        self.inner.mesh_output_per_vertex_granularity = mesh_output_per_vertex_granularity;
        self
    }
    #[inline]
    pub fn mesh_output_per_primitive_granularity(
        mut self,
        mesh_output_per_primitive_granularity: u32,
    ) -> Self {
        self.inner.mesh_output_per_primitive_granularity = mesh_output_per_primitive_granularity;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceMeshShaderPropertiesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrawMeshTasksIndirectCommandNV.html>"]
pub struct DrawMeshTasksIndirectCommandNV {
    pub task_count: u32,
    pub first_task: u32,
}
impl DrawMeshTasksIndirectCommandNV {
    pub fn builder<'a>() -> DrawMeshTasksIndirectCommandNVBuilder<'a> {
        DrawMeshTasksIndirectCommandNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DrawMeshTasksIndirectCommandNVBuilder<'a> {
    inner: DrawMeshTasksIndirectCommandNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DrawMeshTasksIndirectCommandNVBuilder<'a> {
    type Target = DrawMeshTasksIndirectCommandNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DrawMeshTasksIndirectCommandNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DrawMeshTasksIndirectCommandNVBuilder<'a> {
    #[inline]
    pub fn task_count(mut self, task_count: u32) -> Self {
        self.inner.task_count = task_count;
        self
    }
    #[inline]
    pub fn first_task(mut self, first_task: u32) -> Self {
        self.inner.first_task = first_task;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DrawMeshTasksIndirectCommandNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMeshShaderFeaturesEXT.html>"]
pub struct PhysicalDeviceMeshShaderFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub task_shader: Bool32,
    pub mesh_shader: Bool32,
    pub multiview_mesh_shader: Bool32,
    pub primitive_fragment_shading_rate_mesh_shader: Bool32,
    pub mesh_shader_queries: Bool32,
}
impl ::std::default::Default for PhysicalDeviceMeshShaderFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            task_shader: Bool32::default(),
            mesh_shader: Bool32::default(),
            multiview_mesh_shader: Bool32::default(),
            primitive_fragment_shading_rate_mesh_shader: Bool32::default(),
            mesh_shader_queries: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceMeshShaderFeaturesEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT;
}
impl PhysicalDeviceMeshShaderFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceMeshShaderFeaturesEXTBuilder<'a> {
        PhysicalDeviceMeshShaderFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceMeshShaderFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceMeshShaderFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMeshShaderFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMeshShaderFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMeshShaderFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMeshShaderFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceMeshShaderFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceMeshShaderFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceMeshShaderFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceMeshShaderFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn task_shader(mut self, task_shader: bool) -> Self {
        self.inner.task_shader = task_shader.into();
        self
    }
    #[inline]
    pub fn mesh_shader(mut self, mesh_shader: bool) -> Self {
        self.inner.mesh_shader = mesh_shader.into();
        self
    }
    #[inline]
    pub fn multiview_mesh_shader(mut self, multiview_mesh_shader: bool) -> Self {
        self.inner.multiview_mesh_shader = multiview_mesh_shader.into();
        self
    }
    #[inline]
    pub fn primitive_fragment_shading_rate_mesh_shader(
        mut self,
        primitive_fragment_shading_rate_mesh_shader: bool,
    ) -> Self {
        self.inner.primitive_fragment_shading_rate_mesh_shader =
            primitive_fragment_shading_rate_mesh_shader.into();
        self
    }
    #[inline]
    pub fn mesh_shader_queries(mut self, mesh_shader_queries: bool) -> Self {
        self.inner.mesh_shader_queries = mesh_shader_queries.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceMeshShaderFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMeshShaderPropertiesEXT.html>"]
pub struct PhysicalDeviceMeshShaderPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_task_work_group_total_count: u32,
    pub max_task_work_group_count: [u32; 3],
    pub max_task_work_group_invocations: u32,
    pub max_task_work_group_size: [u32; 3],
    pub max_task_payload_size: u32,
    pub max_task_shared_memory_size: u32,
    pub max_task_payload_and_shared_memory_size: u32,
    pub max_mesh_work_group_total_count: u32,
    pub max_mesh_work_group_count: [u32; 3],
    pub max_mesh_work_group_invocations: u32,
    pub max_mesh_work_group_size: [u32; 3],
    pub max_mesh_shared_memory_size: u32,
    pub max_mesh_payload_and_shared_memory_size: u32,
    pub max_mesh_output_memory_size: u32,
    pub max_mesh_payload_and_output_memory_size: u32,
    pub max_mesh_output_components: u32,
    pub max_mesh_output_vertices: u32,
    pub max_mesh_output_primitives: u32,
    pub max_mesh_output_layers: u32,
    pub max_mesh_multiview_view_count: u32,
    pub mesh_output_per_vertex_granularity: u32,
    pub mesh_output_per_primitive_granularity: u32,
    pub max_preferred_task_work_group_invocations: u32,
    pub max_preferred_mesh_work_group_invocations: u32,
    pub prefers_local_invocation_vertex_output: Bool32,
    pub prefers_local_invocation_primitive_output: Bool32,
    pub prefers_compact_vertex_output: Bool32,
    pub prefers_compact_primitive_output: Bool32,
}
impl ::std::default::Default for PhysicalDeviceMeshShaderPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_task_work_group_total_count: u32::default(),
            max_task_work_group_count: unsafe { ::std::mem::zeroed() },
            max_task_work_group_invocations: u32::default(),
            max_task_work_group_size: unsafe { ::std::mem::zeroed() },
            max_task_payload_size: u32::default(),
            max_task_shared_memory_size: u32::default(),
            max_task_payload_and_shared_memory_size: u32::default(),
            max_mesh_work_group_total_count: u32::default(),
            max_mesh_work_group_count: unsafe { ::std::mem::zeroed() },
            max_mesh_work_group_invocations: u32::default(),
            max_mesh_work_group_size: unsafe { ::std::mem::zeroed() },
            max_mesh_shared_memory_size: u32::default(),
            max_mesh_payload_and_shared_memory_size: u32::default(),
            max_mesh_output_memory_size: u32::default(),
            max_mesh_payload_and_output_memory_size: u32::default(),
            max_mesh_output_components: u32::default(),
            max_mesh_output_vertices: u32::default(),
            max_mesh_output_primitives: u32::default(),
            max_mesh_output_layers: u32::default(),
            max_mesh_multiview_view_count: u32::default(),
            mesh_output_per_vertex_granularity: u32::default(),
            mesh_output_per_primitive_granularity: u32::default(),
            max_preferred_task_work_group_invocations: u32::default(),
            max_preferred_mesh_work_group_invocations: u32::default(),
            prefers_local_invocation_vertex_output: Bool32::default(),
            prefers_local_invocation_primitive_output: Bool32::default(),
            prefers_compact_vertex_output: Bool32::default(),
            prefers_compact_primitive_output: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceMeshShaderPropertiesEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT;
}
impl PhysicalDeviceMeshShaderPropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceMeshShaderPropertiesEXTBuilder<'a> {
        PhysicalDeviceMeshShaderPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceMeshShaderPropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceMeshShaderPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceMeshShaderPropertiesEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceMeshShaderPropertiesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceMeshShaderPropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceMeshShaderPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceMeshShaderPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceMeshShaderPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn max_task_work_group_total_count(mut self, max_task_work_group_total_count: u32) -> Self {
        self.inner.max_task_work_group_total_count = max_task_work_group_total_count;
        self
    }
    #[inline]
    pub fn max_task_work_group_count(mut self, max_task_work_group_count: [u32; 3]) -> Self {
        self.inner.max_task_work_group_count = max_task_work_group_count;
        self
    }
    #[inline]
    pub fn max_task_work_group_invocations(mut self, max_task_work_group_invocations: u32) -> Self {
        self.inner.max_task_work_group_invocations = max_task_work_group_invocations;
        self
    }
    #[inline]
    pub fn max_task_work_group_size(mut self, max_task_work_group_size: [u32; 3]) -> Self {
        self.inner.max_task_work_group_size = max_task_work_group_size;
        self
    }
    #[inline]
    pub fn max_task_payload_size(mut self, max_task_payload_size: u32) -> Self {
        self.inner.max_task_payload_size = max_task_payload_size;
        self
    }
    #[inline]
    pub fn max_task_shared_memory_size(mut self, max_task_shared_memory_size: u32) -> Self {
        self.inner.max_task_shared_memory_size = max_task_shared_memory_size;
        self
    }
    #[inline]
    pub fn max_task_payload_and_shared_memory_size(
        mut self,
        max_task_payload_and_shared_memory_size: u32,
    ) -> Self {
        self.inner.max_task_payload_and_shared_memory_size =
            max_task_payload_and_shared_memory_size;
        self
    }
    #[inline]
    pub fn max_mesh_work_group_total_count(mut self, max_mesh_work_group_total_count: u32) -> Self {
        self.inner.max_mesh_work_group_total_count = max_mesh_work_group_total_count;
        self
    }
    #[inline]
    pub fn max_mesh_work_group_count(mut self, max_mesh_work_group_count: [u32; 3]) -> Self {
        self.inner.max_mesh_work_group_count = max_mesh_work_group_count;
        self
    }
    #[inline]
    pub fn max_mesh_work_group_invocations(mut self, max_mesh_work_group_invocations: u32) -> Self {
        self.inner.max_mesh_work_group_invocations = max_mesh_work_group_invocations;
        self
    }
    #[inline]
    pub fn max_mesh_work_group_size(mut self, max_mesh_work_group_size: [u32; 3]) -> Self {
        self.inner.max_mesh_work_group_size = max_mesh_work_group_size;
        self
    }
    #[inline]
    pub fn max_mesh_shared_memory_size(mut self, max_mesh_shared_memory_size: u32) -> Self {
        self.inner.max_mesh_shared_memory_size = max_mesh_shared_memory_size;
        self
    }
    #[inline]
    pub fn max_mesh_payload_and_shared_memory_size(
        mut self,
        max_mesh_payload_and_shared_memory_size: u32,
    ) -> Self {
        self.inner.max_mesh_payload_and_shared_memory_size =
            max_mesh_payload_and_shared_memory_size;
        self
    }
    #[inline]
    pub fn max_mesh_output_memory_size(mut self, max_mesh_output_memory_size: u32) -> Self {
        self.inner.max_mesh_output_memory_size = max_mesh_output_memory_size;
        self
    }
    #[inline]
    pub fn max_mesh_payload_and_output_memory_size(
        mut self,
        max_mesh_payload_and_output_memory_size: u32,
    ) -> Self {
        self.inner.max_mesh_payload_and_output_memory_size =
            max_mesh_payload_and_output_memory_size;
        self
    }
    #[inline]
    pub fn max_mesh_output_components(mut self, max_mesh_output_components: u32) -> Self {
        self.inner.max_mesh_output_components = max_mesh_output_components;
        self
    }
    #[inline]
    pub fn max_mesh_output_vertices(mut self, max_mesh_output_vertices: u32) -> Self {
        self.inner.max_mesh_output_vertices = max_mesh_output_vertices;
        self
    }
    #[inline]
    pub fn max_mesh_output_primitives(mut self, max_mesh_output_primitives: u32) -> Self {
        self.inner.max_mesh_output_primitives = max_mesh_output_primitives;
        self
    }
    #[inline]
    pub fn max_mesh_output_layers(mut self, max_mesh_output_layers: u32) -> Self {
        self.inner.max_mesh_output_layers = max_mesh_output_layers;
        self
    }
    #[inline]
    pub fn max_mesh_multiview_view_count(mut self, max_mesh_multiview_view_count: u32) -> Self {
        self.inner.max_mesh_multiview_view_count = max_mesh_multiview_view_count;
        self
    }
    #[inline]
    pub fn mesh_output_per_vertex_granularity(
        mut self,
        mesh_output_per_vertex_granularity: u32,
    ) -> Self {
        self.inner.mesh_output_per_vertex_granularity = mesh_output_per_vertex_granularity;
        self
    }
    #[inline]
    pub fn mesh_output_per_primitive_granularity(
        mut self,
        mesh_output_per_primitive_granularity: u32,
    ) -> Self {
        self.inner.mesh_output_per_primitive_granularity = mesh_output_per_primitive_granularity;
        self
    }
    #[inline]
    pub fn max_preferred_task_work_group_invocations(
        mut self,
        max_preferred_task_work_group_invocations: u32,
    ) -> Self {
        self.inner.max_preferred_task_work_group_invocations =
            max_preferred_task_work_group_invocations;
        self
    }
    #[inline]
    pub fn max_preferred_mesh_work_group_invocations(
        mut self,
        max_preferred_mesh_work_group_invocations: u32,
    ) -> Self {
        self.inner.max_preferred_mesh_work_group_invocations =
            max_preferred_mesh_work_group_invocations;
        self
    }
    #[inline]
    pub fn prefers_local_invocation_vertex_output(
        mut self,
        prefers_local_invocation_vertex_output: bool,
    ) -> Self {
        self.inner.prefers_local_invocation_vertex_output =
            prefers_local_invocation_vertex_output.into();
        self
    }
    #[inline]
    pub fn prefers_local_invocation_primitive_output(
        mut self,
        prefers_local_invocation_primitive_output: bool,
    ) -> Self {
        self.inner.prefers_local_invocation_primitive_output =
            prefers_local_invocation_primitive_output.into();
        self
    }
    #[inline]
    pub fn prefers_compact_vertex_output(mut self, prefers_compact_vertex_output: bool) -> Self {
        self.inner.prefers_compact_vertex_output = prefers_compact_vertex_output.into();
        self
    }
    #[inline]
    pub fn prefers_compact_primitive_output(
        mut self,
        prefers_compact_primitive_output: bool,
    ) -> Self {
        self.inner.prefers_compact_primitive_output = prefers_compact_primitive_output.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceMeshShaderPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrawMeshTasksIndirectCommandEXT.html>"]
pub struct DrawMeshTasksIndirectCommandEXT {
    pub group_count_x: u32,
    pub group_count_y: u32,
    pub group_count_z: u32,
}
impl DrawMeshTasksIndirectCommandEXT {
    pub fn builder<'a>() -> DrawMeshTasksIndirectCommandEXTBuilder<'a> {
        DrawMeshTasksIndirectCommandEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DrawMeshTasksIndirectCommandEXTBuilder<'a> {
    inner: DrawMeshTasksIndirectCommandEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DrawMeshTasksIndirectCommandEXTBuilder<'a> {
    type Target = DrawMeshTasksIndirectCommandEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DrawMeshTasksIndirectCommandEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DrawMeshTasksIndirectCommandEXTBuilder<'a> {
    #[inline]
    pub fn group_count_x(mut self, group_count_x: u32) -> Self {
        self.inner.group_count_x = group_count_x;
        self
    }
    #[inline]
    pub fn group_count_y(mut self, group_count_y: u32) -> Self {
        self.inner.group_count_y = group_count_y;
        self
    }
    #[inline]
    pub fn group_count_z(mut self, group_count_z: u32) -> Self {
        self.inner.group_count_z = group_count_z;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DrawMeshTasksIndirectCommandEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRayTracingShaderGroupCreateInfoNV.html>"]
pub struct RayTracingShaderGroupCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: RayTracingShaderGroupTypeKHR,
    pub general_shader: u32,
    pub closest_hit_shader: u32,
    pub any_hit_shader: u32,
    pub intersection_shader: u32,
}
impl ::std::default::Default for RayTracingShaderGroupCreateInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            ty: RayTracingShaderGroupTypeKHR::default(),
            general_shader: u32::default(),
            closest_hit_shader: u32::default(),
            any_hit_shader: u32::default(),
            intersection_shader: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for RayTracingShaderGroupCreateInfoNV {
    const STRUCTURE_TYPE: StructureType = StructureType::RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV;
}
impl RayTracingShaderGroupCreateInfoNV {
    pub fn builder<'a>() -> RayTracingShaderGroupCreateInfoNVBuilder<'a> {
        RayTracingShaderGroupCreateInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RayTracingShaderGroupCreateInfoNVBuilder<'a> {
    inner: RayTracingShaderGroupCreateInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for RayTracingShaderGroupCreateInfoNVBuilder<'a> {
    type Target = RayTracingShaderGroupCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RayTracingShaderGroupCreateInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RayTracingShaderGroupCreateInfoNVBuilder<'a> {
    #[inline]
    pub fn ty(mut self, ty: RayTracingShaderGroupTypeKHR) -> Self {
        self.inner.ty = ty;
        self
    }
    #[inline]
    pub fn general_shader(mut self, general_shader: u32) -> Self {
        self.inner.general_shader = general_shader;
        self
    }
    #[inline]
    pub fn closest_hit_shader(mut self, closest_hit_shader: u32) -> Self {
        self.inner.closest_hit_shader = closest_hit_shader;
        self
    }
    #[inline]
    pub fn any_hit_shader(mut self, any_hit_shader: u32) -> Self {
        self.inner.any_hit_shader = any_hit_shader;
        self
    }
    #[inline]
    pub fn intersection_shader(mut self, intersection_shader: u32) -> Self {
        self.inner.intersection_shader = intersection_shader;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RayTracingShaderGroupCreateInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRayTracingShaderGroupCreateInfoKHR.html>"]
pub struct RayTracingShaderGroupCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: RayTracingShaderGroupTypeKHR,
    pub general_shader: u32,
    pub closest_hit_shader: u32,
    pub any_hit_shader: u32,
    pub intersection_shader: u32,
    pub p_shader_group_capture_replay_handle: *const c_void,
}
impl ::std::default::Default for RayTracingShaderGroupCreateInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            ty: RayTracingShaderGroupTypeKHR::default(),
            general_shader: u32::default(),
            closest_hit_shader: u32::default(),
            any_hit_shader: u32::default(),
            intersection_shader: u32::default(),
            p_shader_group_capture_replay_handle: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for RayTracingShaderGroupCreateInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR;
}
impl RayTracingShaderGroupCreateInfoKHR {
    pub fn builder<'a>() -> RayTracingShaderGroupCreateInfoKHRBuilder<'a> {
        RayTracingShaderGroupCreateInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RayTracingShaderGroupCreateInfoKHRBuilder<'a> {
    inner: RayTracingShaderGroupCreateInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for RayTracingShaderGroupCreateInfoKHRBuilder<'a> {
    type Target = RayTracingShaderGroupCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RayTracingShaderGroupCreateInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RayTracingShaderGroupCreateInfoKHRBuilder<'a> {
    #[inline]
    pub fn ty(mut self, ty: RayTracingShaderGroupTypeKHR) -> Self {
        self.inner.ty = ty;
        self
    }
    #[inline]
    pub fn general_shader(mut self, general_shader: u32) -> Self {
        self.inner.general_shader = general_shader;
        self
    }
    #[inline]
    pub fn closest_hit_shader(mut self, closest_hit_shader: u32) -> Self {
        self.inner.closest_hit_shader = closest_hit_shader;
        self
    }
    #[inline]
    pub fn any_hit_shader(mut self, any_hit_shader: u32) -> Self {
        self.inner.any_hit_shader = any_hit_shader;
        self
    }
    #[inline]
    pub fn intersection_shader(mut self, intersection_shader: u32) -> Self {
        self.inner.intersection_shader = intersection_shader;
        self
    }
    #[inline]
    pub fn shader_group_capture_replay_handle(
        mut self,
        shader_group_capture_replay_handle: *const c_void,
    ) -> Self {
        self.inner.p_shader_group_capture_replay_handle = shader_group_capture_replay_handle;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RayTracingShaderGroupCreateInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRayTracingPipelineCreateInfoNV.html>"]
pub struct RayTracingPipelineCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineCreateFlags,
    pub stage_count: u32,
    pub p_stages: *const PipelineShaderStageCreateInfo,
    pub group_count: u32,
    pub p_groups: *const RayTracingShaderGroupCreateInfoNV,
    pub max_recursion_depth: u32,
    pub layout: PipelineLayout,
    pub base_pipeline_handle: Pipeline,
    pub base_pipeline_index: i32,
}
impl ::std::default::Default for RayTracingPipelineCreateInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineCreateFlags::default(),
            stage_count: u32::default(),
            p_stages: ::std::ptr::null(),
            group_count: u32::default(),
            p_groups: ::std::ptr::null(),
            max_recursion_depth: u32::default(),
            layout: PipelineLayout::default(),
            base_pipeline_handle: Pipeline::default(),
            base_pipeline_index: i32::default(),
        }
    }
}
unsafe impl TaggedStructure for RayTracingPipelineCreateInfoNV {
    const STRUCTURE_TYPE: StructureType = StructureType::RAY_TRACING_PIPELINE_CREATE_INFO_NV;
}
impl RayTracingPipelineCreateInfoNV {
    pub fn builder<'a>() -> RayTracingPipelineCreateInfoNVBuilder<'a> {
        RayTracingPipelineCreateInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RayTracingPipelineCreateInfoNVBuilder<'a> {
    inner: RayTracingPipelineCreateInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsRayTracingPipelineCreateInfoNV {}
impl<'a> ::std::ops::Deref for RayTracingPipelineCreateInfoNVBuilder<'a> {
    type Target = RayTracingPipelineCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RayTracingPipelineCreateInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RayTracingPipelineCreateInfoNVBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn stages(mut self, stages: &'a [PipelineShaderStageCreateInfo]) -> Self {
        self.inner.stage_count = stages.len() as _;
        self.inner.p_stages = stages.as_ptr();
        self
    }
    #[inline]
    pub fn groups(mut self, groups: &'a [RayTracingShaderGroupCreateInfoNV]) -> Self {
        self.inner.group_count = groups.len() as _;
        self.inner.p_groups = groups.as_ptr();
        self
    }
    #[inline]
    pub fn max_recursion_depth(mut self, max_recursion_depth: u32) -> Self {
        self.inner.max_recursion_depth = max_recursion_depth;
        self
    }
    #[inline]
    pub fn layout(mut self, layout: PipelineLayout) -> Self {
        self.inner.layout = layout;
        self
    }
    #[inline]
    pub fn base_pipeline_handle(mut self, base_pipeline_handle: Pipeline) -> Self {
        self.inner.base_pipeline_handle = base_pipeline_handle;
        self
    }
    #[inline]
    pub fn base_pipeline_index(mut self, base_pipeline_index: i32) -> Self {
        self.inner.base_pipeline_index = base_pipeline_index;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsRayTracingPipelineCreateInfoNV>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RayTracingPipelineCreateInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRayTracingPipelineCreateInfoKHR.html>"]
pub struct RayTracingPipelineCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineCreateFlags,
    pub stage_count: u32,
    pub p_stages: *const PipelineShaderStageCreateInfo,
    pub group_count: u32,
    pub p_groups: *const RayTracingShaderGroupCreateInfoKHR,
    pub max_pipeline_ray_recursion_depth: u32,
    pub p_library_info: *const PipelineLibraryCreateInfoKHR,
    pub p_library_interface: *const RayTracingPipelineInterfaceCreateInfoKHR,
    pub p_dynamic_state: *const PipelineDynamicStateCreateInfo,
    pub layout: PipelineLayout,
    pub base_pipeline_handle: Pipeline,
    pub base_pipeline_index: i32,
}
impl ::std::default::Default for RayTracingPipelineCreateInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineCreateFlags::default(),
            stage_count: u32::default(),
            p_stages: ::std::ptr::null(),
            group_count: u32::default(),
            p_groups: ::std::ptr::null(),
            max_pipeline_ray_recursion_depth: u32::default(),
            p_library_info: ::std::ptr::null(),
            p_library_interface: ::std::ptr::null(),
            p_dynamic_state: ::std::ptr::null(),
            layout: PipelineLayout::default(),
            base_pipeline_handle: Pipeline::default(),
            base_pipeline_index: i32::default(),
        }
    }
}
unsafe impl TaggedStructure for RayTracingPipelineCreateInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::RAY_TRACING_PIPELINE_CREATE_INFO_KHR;
}
impl RayTracingPipelineCreateInfoKHR {
    pub fn builder<'a>() -> RayTracingPipelineCreateInfoKHRBuilder<'a> {
        RayTracingPipelineCreateInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RayTracingPipelineCreateInfoKHRBuilder<'a> {
    inner: RayTracingPipelineCreateInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsRayTracingPipelineCreateInfoKHR {}
impl<'a> ::std::ops::Deref for RayTracingPipelineCreateInfoKHRBuilder<'a> {
    type Target = RayTracingPipelineCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RayTracingPipelineCreateInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RayTracingPipelineCreateInfoKHRBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn stages(mut self, stages: &'a [PipelineShaderStageCreateInfo]) -> Self {
        self.inner.stage_count = stages.len() as _;
        self.inner.p_stages = stages.as_ptr();
        self
    }
    #[inline]
    pub fn groups(mut self, groups: &'a [RayTracingShaderGroupCreateInfoKHR]) -> Self {
        self.inner.group_count = groups.len() as _;
        self.inner.p_groups = groups.as_ptr();
        self
    }
    #[inline]
    pub fn max_pipeline_ray_recursion_depth(
        mut self,
        max_pipeline_ray_recursion_depth: u32,
    ) -> Self {
        self.inner.max_pipeline_ray_recursion_depth = max_pipeline_ray_recursion_depth;
        self
    }
    #[inline]
    pub fn library_info(mut self, library_info: &'a PipelineLibraryCreateInfoKHR) -> Self {
        self.inner.p_library_info = library_info;
        self
    }
    #[inline]
    pub fn library_interface(
        mut self,
        library_interface: &'a RayTracingPipelineInterfaceCreateInfoKHR,
    ) -> Self {
        self.inner.p_library_interface = library_interface;
        self
    }
    #[inline]
    pub fn dynamic_state(mut self, dynamic_state: &'a PipelineDynamicStateCreateInfo) -> Self {
        self.inner.p_dynamic_state = dynamic_state;
        self
    }
    #[inline]
    pub fn layout(mut self, layout: PipelineLayout) -> Self {
        self.inner.layout = layout;
        self
    }
    #[inline]
    pub fn base_pipeline_handle(mut self, base_pipeline_handle: Pipeline) -> Self {
        self.inner.base_pipeline_handle = base_pipeline_handle;
        self
    }
    #[inline]
    pub fn base_pipeline_index(mut self, base_pipeline_index: i32) -> Self {
        self.inner.base_pipeline_index = base_pipeline_index;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsRayTracingPipelineCreateInfoKHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RayTracingPipelineCreateInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGeometryTrianglesNV.html>"]
pub struct GeometryTrianglesNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub vertex_data: Buffer,
    pub vertex_offset: DeviceSize,
    pub vertex_count: u32,
    pub vertex_stride: DeviceSize,
    pub vertex_format: Format,
    pub index_data: Buffer,
    pub index_offset: DeviceSize,
    pub index_count: u32,
    pub index_type: IndexType,
    pub transform_data: Buffer,
    pub transform_offset: DeviceSize,
}
impl ::std::default::Default for GeometryTrianglesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            vertex_data: Buffer::default(),
            vertex_offset: DeviceSize::default(),
            vertex_count: u32::default(),
            vertex_stride: DeviceSize::default(),
            vertex_format: Format::default(),
            index_data: Buffer::default(),
            index_offset: DeviceSize::default(),
            index_count: u32::default(),
            index_type: IndexType::default(),
            transform_data: Buffer::default(),
            transform_offset: DeviceSize::default(),
        }
    }
}
unsafe impl TaggedStructure for GeometryTrianglesNV {
    const STRUCTURE_TYPE: StructureType = StructureType::GEOMETRY_TRIANGLES_NV;
}
impl GeometryTrianglesNV {
    pub fn builder<'a>() -> GeometryTrianglesNVBuilder<'a> {
        GeometryTrianglesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct GeometryTrianglesNVBuilder<'a> {
    inner: GeometryTrianglesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for GeometryTrianglesNVBuilder<'a> {
    type Target = GeometryTrianglesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for GeometryTrianglesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> GeometryTrianglesNVBuilder<'a> {
    #[inline]
    pub fn vertex_data(mut self, vertex_data: Buffer) -> Self {
        self.inner.vertex_data = vertex_data;
        self
    }
    #[inline]
    pub fn vertex_offset(mut self, vertex_offset: DeviceSize) -> Self {
        self.inner.vertex_offset = vertex_offset;
        self
    }
    #[inline]
    pub fn vertex_count(mut self, vertex_count: u32) -> Self {
        self.inner.vertex_count = vertex_count;
        self
    }
    #[inline]
    pub fn vertex_stride(mut self, vertex_stride: DeviceSize) -> Self {
        self.inner.vertex_stride = vertex_stride;
        self
    }
    #[inline]
    pub fn vertex_format(mut self, vertex_format: Format) -> Self {
        self.inner.vertex_format = vertex_format;
        self
    }
    #[inline]
    pub fn index_data(mut self, index_data: Buffer) -> Self {
        self.inner.index_data = index_data;
        self
    }
    #[inline]
    pub fn index_offset(mut self, index_offset: DeviceSize) -> Self {
        self.inner.index_offset = index_offset;
        self
    }
    #[inline]
    pub fn index_count(mut self, index_count: u32) -> Self {
        self.inner.index_count = index_count;
        self
    }
    #[inline]
    pub fn index_type(mut self, index_type: IndexType) -> Self {
        self.inner.index_type = index_type;
        self
    }
    #[inline]
    pub fn transform_data(mut self, transform_data: Buffer) -> Self {
        self.inner.transform_data = transform_data;
        self
    }
    #[inline]
    pub fn transform_offset(mut self, transform_offset: DeviceSize) -> Self {
        self.inner.transform_offset = transform_offset;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> GeometryTrianglesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGeometryAABBNV.html>"]
pub struct GeometryAABBNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub aabb_data: Buffer,
    pub num_aab_bs: u32,
    pub stride: u32,
    pub offset: DeviceSize,
}
impl ::std::default::Default for GeometryAABBNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            aabb_data: Buffer::default(),
            num_aab_bs: u32::default(),
            stride: u32::default(),
            offset: DeviceSize::default(),
        }
    }
}
unsafe impl TaggedStructure for GeometryAABBNV {
    const STRUCTURE_TYPE: StructureType = StructureType::GEOMETRY_AABB_NV;
}
impl GeometryAABBNV {
    pub fn builder<'a>() -> GeometryAABBNVBuilder<'a> {
        GeometryAABBNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct GeometryAABBNVBuilder<'a> {
    inner: GeometryAABBNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for GeometryAABBNVBuilder<'a> {
    type Target = GeometryAABBNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for GeometryAABBNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> GeometryAABBNVBuilder<'a> {
    #[inline]
    pub fn aabb_data(mut self, aabb_data: Buffer) -> Self {
        self.inner.aabb_data = aabb_data;
        self
    }
    #[inline]
    pub fn num_aab_bs(mut self, num_aab_bs: u32) -> Self {
        self.inner.num_aab_bs = num_aab_bs;
        self
    }
    #[inline]
    pub fn stride(mut self, stride: u32) -> Self {
        self.inner.stride = stride;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: DeviceSize) -> Self {
        self.inner.offset = offset;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> GeometryAABBNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGeometryDataNV.html>"]
pub struct GeometryDataNV {
    pub triangles: GeometryTrianglesNV,
    pub aabbs: GeometryAABBNV,
}
impl GeometryDataNV {
    pub fn builder<'a>() -> GeometryDataNVBuilder<'a> {
        GeometryDataNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct GeometryDataNVBuilder<'a> {
    inner: GeometryDataNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for GeometryDataNVBuilder<'a> {
    type Target = GeometryDataNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for GeometryDataNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> GeometryDataNVBuilder<'a> {
    #[inline]
    pub fn triangles(mut self, triangles: GeometryTrianglesNV) -> Self {
        self.inner.triangles = triangles;
        self
    }
    #[inline]
    pub fn aabbs(mut self, aabbs: GeometryAABBNV) -> Self {
        self.inner.aabbs = aabbs;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> GeometryDataNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGeometryNV.html>"]
pub struct GeometryNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub geometry_type: GeometryTypeKHR,
    pub geometry: GeometryDataNV,
    pub flags: GeometryFlagsKHR,
}
impl ::std::default::Default for GeometryNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            geometry_type: GeometryTypeKHR::default(),
            geometry: GeometryDataNV::default(),
            flags: GeometryFlagsKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for GeometryNV {
    const STRUCTURE_TYPE: StructureType = StructureType::GEOMETRY_NV;
}
impl GeometryNV {
    pub fn builder<'a>() -> GeometryNVBuilder<'a> {
        GeometryNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct GeometryNVBuilder<'a> {
    inner: GeometryNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for GeometryNVBuilder<'a> {
    type Target = GeometryNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for GeometryNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> GeometryNVBuilder<'a> {
    #[inline]
    pub fn geometry_type(mut self, geometry_type: GeometryTypeKHR) -> Self {
        self.inner.geometry_type = geometry_type;
        self
    }
    #[inline]
    pub fn geometry(mut self, geometry: GeometryDataNV) -> Self {
        self.inner.geometry = geometry;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: GeometryFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> GeometryNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureInfoNV.html>"]
pub struct AccelerationStructureInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: AccelerationStructureTypeNV,
    pub flags: BuildAccelerationStructureFlagsNV,
    pub instance_count: u32,
    pub geometry_count: u32,
    pub p_geometries: *const GeometryNV,
}
impl ::std::default::Default for AccelerationStructureInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            ty: AccelerationStructureTypeNV::default(),
            flags: BuildAccelerationStructureFlagsNV::default(),
            instance_count: u32::default(),
            geometry_count: u32::default(),
            p_geometries: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for AccelerationStructureInfoNV {
    const STRUCTURE_TYPE: StructureType = StructureType::ACCELERATION_STRUCTURE_INFO_NV;
}
impl AccelerationStructureInfoNV {
    pub fn builder<'a>() -> AccelerationStructureInfoNVBuilder<'a> {
        AccelerationStructureInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AccelerationStructureInfoNVBuilder<'a> {
    inner: AccelerationStructureInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for AccelerationStructureInfoNVBuilder<'a> {
    type Target = AccelerationStructureInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AccelerationStructureInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AccelerationStructureInfoNVBuilder<'a> {
    #[inline]
    pub fn ty(mut self, ty: AccelerationStructureTypeNV) -> Self {
        self.inner.ty = ty;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: BuildAccelerationStructureFlagsNV) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn instance_count(mut self, instance_count: u32) -> Self {
        self.inner.instance_count = instance_count;
        self
    }
    #[inline]
    pub fn geometries(mut self, geometries: &'a [GeometryNV]) -> Self {
        self.inner.geometry_count = geometries.len() as _;
        self.inner.p_geometries = geometries.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AccelerationStructureInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureCreateInfoNV.html>"]
pub struct AccelerationStructureCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub compacted_size: DeviceSize,
    pub info: AccelerationStructureInfoNV,
}
impl ::std::default::Default for AccelerationStructureCreateInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            compacted_size: DeviceSize::default(),
            info: AccelerationStructureInfoNV::default(),
        }
    }
}
unsafe impl TaggedStructure for AccelerationStructureCreateInfoNV {
    const STRUCTURE_TYPE: StructureType = StructureType::ACCELERATION_STRUCTURE_CREATE_INFO_NV;
}
impl AccelerationStructureCreateInfoNV {
    pub fn builder<'a>() -> AccelerationStructureCreateInfoNVBuilder<'a> {
        AccelerationStructureCreateInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AccelerationStructureCreateInfoNVBuilder<'a> {
    inner: AccelerationStructureCreateInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsAccelerationStructureCreateInfoNV {}
impl<'a> ::std::ops::Deref for AccelerationStructureCreateInfoNVBuilder<'a> {
    type Target = AccelerationStructureCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AccelerationStructureCreateInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AccelerationStructureCreateInfoNVBuilder<'a> {
    #[inline]
    pub fn compacted_size(mut self, compacted_size: DeviceSize) -> Self {
        self.inner.compacted_size = compacted_size;
        self
    }
    #[inline]
    pub fn info(mut self, info: AccelerationStructureInfoNV) -> Self {
        self.inner.info = info;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsAccelerationStructureCreateInfoNV>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AccelerationStructureCreateInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindAccelerationStructureMemoryInfoNV.html>"]
pub struct BindAccelerationStructureMemoryInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acceleration_structure: AccelerationStructureNV,
    pub memory: DeviceMemory,
    pub memory_offset: DeviceSize,
    pub device_index_count: u32,
    pub p_device_indices: *const u32,
}
impl ::std::default::Default for BindAccelerationStructureMemoryInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            acceleration_structure: AccelerationStructureNV::default(),
            memory: DeviceMemory::default(),
            memory_offset: DeviceSize::default(),
            device_index_count: u32::default(),
            p_device_indices: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for BindAccelerationStructureMemoryInfoNV {
    const STRUCTURE_TYPE: StructureType = StructureType::BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV;
}
impl BindAccelerationStructureMemoryInfoNV {
    pub fn builder<'a>() -> BindAccelerationStructureMemoryInfoNVBuilder<'a> {
        BindAccelerationStructureMemoryInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BindAccelerationStructureMemoryInfoNVBuilder<'a> {
    inner: BindAccelerationStructureMemoryInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for BindAccelerationStructureMemoryInfoNVBuilder<'a> {
    type Target = BindAccelerationStructureMemoryInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BindAccelerationStructureMemoryInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BindAccelerationStructureMemoryInfoNVBuilder<'a> {
    #[inline]
    pub fn acceleration_structure(
        mut self,
        acceleration_structure: AccelerationStructureNV,
    ) -> Self {
        self.inner.acceleration_structure = acceleration_structure;
        self
    }
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    #[inline]
    pub fn memory_offset(mut self, memory_offset: DeviceSize) -> Self {
        self.inner.memory_offset = memory_offset;
        self
    }
    #[inline]
    pub fn device_indices(mut self, device_indices: &'a [u32]) -> Self {
        self.inner.device_index_count = device_indices.len() as _;
        self.inner.p_device_indices = device_indices.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BindAccelerationStructureMemoryInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWriteDescriptorSetAccelerationStructureKHR.html>"]
pub struct WriteDescriptorSetAccelerationStructureKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acceleration_structure_count: u32,
    pub p_acceleration_structures: *const AccelerationStructureKHR,
}
impl ::std::default::Default for WriteDescriptorSetAccelerationStructureKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            acceleration_structure_count: u32::default(),
            p_acceleration_structures: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for WriteDescriptorSetAccelerationStructureKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR;
}
impl WriteDescriptorSetAccelerationStructureKHR {
    pub fn builder<'a>() -> WriteDescriptorSetAccelerationStructureKHRBuilder<'a> {
        WriteDescriptorSetAccelerationStructureKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct WriteDescriptorSetAccelerationStructureKHRBuilder<'a> {
    inner: WriteDescriptorSetAccelerationStructureKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsWriteDescriptorSet for WriteDescriptorSetAccelerationStructureKHRBuilder<'_> {}
unsafe impl ExtendsWriteDescriptorSet for WriteDescriptorSetAccelerationStructureKHR {}
impl<'a> ::std::ops::Deref for WriteDescriptorSetAccelerationStructureKHRBuilder<'a> {
    type Target = WriteDescriptorSetAccelerationStructureKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for WriteDescriptorSetAccelerationStructureKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> WriteDescriptorSetAccelerationStructureKHRBuilder<'a> {
    #[inline]
    pub fn acceleration_structures(
        mut self,
        acceleration_structures: &'a [AccelerationStructureKHR],
    ) -> Self {
        self.inner.acceleration_structure_count = acceleration_structures.len() as _;
        self.inner.p_acceleration_structures = acceleration_structures.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> WriteDescriptorSetAccelerationStructureKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWriteDescriptorSetAccelerationStructureNV.html>"]
pub struct WriteDescriptorSetAccelerationStructureNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acceleration_structure_count: u32,
    pub p_acceleration_structures: *const AccelerationStructureNV,
}
impl ::std::default::Default for WriteDescriptorSetAccelerationStructureNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            acceleration_structure_count: u32::default(),
            p_acceleration_structures: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for WriteDescriptorSetAccelerationStructureNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV;
}
impl WriteDescriptorSetAccelerationStructureNV {
    pub fn builder<'a>() -> WriteDescriptorSetAccelerationStructureNVBuilder<'a> {
        WriteDescriptorSetAccelerationStructureNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct WriteDescriptorSetAccelerationStructureNVBuilder<'a> {
    inner: WriteDescriptorSetAccelerationStructureNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsWriteDescriptorSet for WriteDescriptorSetAccelerationStructureNVBuilder<'_> {}
unsafe impl ExtendsWriteDescriptorSet for WriteDescriptorSetAccelerationStructureNV {}
impl<'a> ::std::ops::Deref for WriteDescriptorSetAccelerationStructureNVBuilder<'a> {
    type Target = WriteDescriptorSetAccelerationStructureNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for WriteDescriptorSetAccelerationStructureNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> WriteDescriptorSetAccelerationStructureNVBuilder<'a> {
    #[inline]
    pub fn acceleration_structures(
        mut self,
        acceleration_structures: &'a [AccelerationStructureNV],
    ) -> Self {
        self.inner.acceleration_structure_count = acceleration_structures.len() as _;
        self.inner.p_acceleration_structures = acceleration_structures.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> WriteDescriptorSetAccelerationStructureNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureMemoryRequirementsInfoNV.html>"]
pub struct AccelerationStructureMemoryRequirementsInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: AccelerationStructureMemoryRequirementsTypeNV,
    pub acceleration_structure: AccelerationStructureNV,
}
impl ::std::default::Default for AccelerationStructureMemoryRequirementsInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            ty: AccelerationStructureMemoryRequirementsTypeNV::default(),
            acceleration_structure: AccelerationStructureNV::default(),
        }
    }
}
unsafe impl TaggedStructure for AccelerationStructureMemoryRequirementsInfoNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV;
}
impl AccelerationStructureMemoryRequirementsInfoNV {
    pub fn builder<'a>() -> AccelerationStructureMemoryRequirementsInfoNVBuilder<'a> {
        AccelerationStructureMemoryRequirementsInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AccelerationStructureMemoryRequirementsInfoNVBuilder<'a> {
    inner: AccelerationStructureMemoryRequirementsInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for AccelerationStructureMemoryRequirementsInfoNVBuilder<'a> {
    type Target = AccelerationStructureMemoryRequirementsInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AccelerationStructureMemoryRequirementsInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AccelerationStructureMemoryRequirementsInfoNVBuilder<'a> {
    #[inline]
    pub fn ty(mut self, ty: AccelerationStructureMemoryRequirementsTypeNV) -> Self {
        self.inner.ty = ty;
        self
    }
    #[inline]
    pub fn acceleration_structure(
        mut self,
        acceleration_structure: AccelerationStructureNV,
    ) -> Self {
        self.inner.acceleration_structure = acceleration_structure;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AccelerationStructureMemoryRequirementsInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceAccelerationStructureFeaturesKHR.html>"]
pub struct PhysicalDeviceAccelerationStructureFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub acceleration_structure: Bool32,
    pub acceleration_structure_capture_replay: Bool32,
    pub acceleration_structure_indirect_build: Bool32,
    pub acceleration_structure_host_commands: Bool32,
    pub descriptor_binding_acceleration_structure_update_after_bind: Bool32,
}
impl ::std::default::Default for PhysicalDeviceAccelerationStructureFeaturesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            acceleration_structure: Bool32::default(),
            acceleration_structure_capture_replay: Bool32::default(),
            acceleration_structure_indirect_build: Bool32::default(),
            acceleration_structure_host_commands: Bool32::default(),
            descriptor_binding_acceleration_structure_update_after_bind: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceAccelerationStructureFeaturesKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR;
}
impl PhysicalDeviceAccelerationStructureFeaturesKHR {
    pub fn builder<'a>() -> PhysicalDeviceAccelerationStructureFeaturesKHRBuilder<'a> {
        PhysicalDeviceAccelerationStructureFeaturesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceAccelerationStructureFeaturesKHRBuilder<'a> {
    inner: PhysicalDeviceAccelerationStructureFeaturesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceAccelerationStructureFeaturesKHRBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceAccelerationStructureFeaturesKHR {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceAccelerationStructureFeaturesKHRBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceAccelerationStructureFeaturesKHR {}
impl<'a> ::std::ops::Deref for PhysicalDeviceAccelerationStructureFeaturesKHRBuilder<'a> {
    type Target = PhysicalDeviceAccelerationStructureFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceAccelerationStructureFeaturesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceAccelerationStructureFeaturesKHRBuilder<'a> {
    #[inline]
    pub fn acceleration_structure(mut self, acceleration_structure: bool) -> Self {
        self.inner.acceleration_structure = acceleration_structure.into();
        self
    }
    #[inline]
    pub fn acceleration_structure_capture_replay(
        mut self,
        acceleration_structure_capture_replay: bool,
    ) -> Self {
        self.inner.acceleration_structure_capture_replay =
            acceleration_structure_capture_replay.into();
        self
    }
    #[inline]
    pub fn acceleration_structure_indirect_build(
        mut self,
        acceleration_structure_indirect_build: bool,
    ) -> Self {
        self.inner.acceleration_structure_indirect_build =
            acceleration_structure_indirect_build.into();
        self
    }
    #[inline]
    pub fn acceleration_structure_host_commands(
        mut self,
        acceleration_structure_host_commands: bool,
    ) -> Self {
        self.inner.acceleration_structure_host_commands =
            acceleration_structure_host_commands.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_acceleration_structure_update_after_bind(
        mut self,
        descriptor_binding_acceleration_structure_update_after_bind: bool,
    ) -> Self {
        self.inner
            .descriptor_binding_acceleration_structure_update_after_bind =
            descriptor_binding_acceleration_structure_update_after_bind.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceAccelerationStructureFeaturesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingPipelineFeaturesKHR.html>"]
pub struct PhysicalDeviceRayTracingPipelineFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ray_tracing_pipeline: Bool32,
    pub ray_tracing_pipeline_shader_group_handle_capture_replay: Bool32,
    pub ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: Bool32,
    pub ray_tracing_pipeline_trace_rays_indirect: Bool32,
    pub ray_traversal_primitive_culling: Bool32,
}
impl ::std::default::Default for PhysicalDeviceRayTracingPipelineFeaturesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            ray_tracing_pipeline: Bool32::default(),
            ray_tracing_pipeline_shader_group_handle_capture_replay: Bool32::default(),
            ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: Bool32::default(),
            ray_tracing_pipeline_trace_rays_indirect: Bool32::default(),
            ray_traversal_primitive_culling: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceRayTracingPipelineFeaturesKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR;
}
impl PhysicalDeviceRayTracingPipelineFeaturesKHR {
    pub fn builder<'a>() -> PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder<'a> {
        PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder<'a> {
    inner: PhysicalDeviceRayTracingPipelineFeaturesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRayTracingPipelineFeaturesKHR {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRayTracingPipelineFeaturesKHR {}
impl<'a> ::std::ops::Deref for PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder<'a> {
    type Target = PhysicalDeviceRayTracingPipelineFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder<'a> {
    #[inline]
    pub fn ray_tracing_pipeline(mut self, ray_tracing_pipeline: bool) -> Self {
        self.inner.ray_tracing_pipeline = ray_tracing_pipeline.into();
        self
    }
    #[inline]
    pub fn ray_tracing_pipeline_shader_group_handle_capture_replay(
        mut self,
        ray_tracing_pipeline_shader_group_handle_capture_replay: bool,
    ) -> Self {
        self.inner
            .ray_tracing_pipeline_shader_group_handle_capture_replay =
            ray_tracing_pipeline_shader_group_handle_capture_replay.into();
        self
    }
    #[inline]
    pub fn ray_tracing_pipeline_shader_group_handle_capture_replay_mixed(
        mut self,
        ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: bool,
    ) -> Self {
        self.inner
            .ray_tracing_pipeline_shader_group_handle_capture_replay_mixed =
            ray_tracing_pipeline_shader_group_handle_capture_replay_mixed.into();
        self
    }
    #[inline]
    pub fn ray_tracing_pipeline_trace_rays_indirect(
        mut self,
        ray_tracing_pipeline_trace_rays_indirect: bool,
    ) -> Self {
        self.inner.ray_tracing_pipeline_trace_rays_indirect =
            ray_tracing_pipeline_trace_rays_indirect.into();
        self
    }
    #[inline]
    pub fn ray_traversal_primitive_culling(
        mut self,
        ray_traversal_primitive_culling: bool,
    ) -> Self {
        self.inner.ray_traversal_primitive_culling = ray_traversal_primitive_culling.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceRayTracingPipelineFeaturesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayQueryFeaturesKHR.html>"]
pub struct PhysicalDeviceRayQueryFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ray_query: Bool32,
}
impl ::std::default::Default for PhysicalDeviceRayQueryFeaturesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            ray_query: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceRayQueryFeaturesKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR;
}
impl PhysicalDeviceRayQueryFeaturesKHR {
    pub fn builder<'a>() -> PhysicalDeviceRayQueryFeaturesKHRBuilder<'a> {
        PhysicalDeviceRayQueryFeaturesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceRayQueryFeaturesKHRBuilder<'a> {
    inner: PhysicalDeviceRayQueryFeaturesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRayQueryFeaturesKHRBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRayQueryFeaturesKHR {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRayQueryFeaturesKHRBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRayQueryFeaturesKHR {}
impl<'a> ::std::ops::Deref for PhysicalDeviceRayQueryFeaturesKHRBuilder<'a> {
    type Target = PhysicalDeviceRayQueryFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceRayQueryFeaturesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceRayQueryFeaturesKHRBuilder<'a> {
    #[inline]
    pub fn ray_query(mut self, ray_query: bool) -> Self {
        self.inner.ray_query = ray_query.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceRayQueryFeaturesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceAccelerationStructurePropertiesKHR.html>"]
pub struct PhysicalDeviceAccelerationStructurePropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_geometry_count: u64,
    pub max_instance_count: u64,
    pub max_primitive_count: u64,
    pub max_per_stage_descriptor_acceleration_structures: u32,
    pub max_per_stage_descriptor_update_after_bind_acceleration_structures: u32,
    pub max_descriptor_set_acceleration_structures: u32,
    pub max_descriptor_set_update_after_bind_acceleration_structures: u32,
    pub min_acceleration_structure_scratch_offset_alignment: u32,
}
impl ::std::default::Default for PhysicalDeviceAccelerationStructurePropertiesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_geometry_count: u64::default(),
            max_instance_count: u64::default(),
            max_primitive_count: u64::default(),
            max_per_stage_descriptor_acceleration_structures: u32::default(),
            max_per_stage_descriptor_update_after_bind_acceleration_structures: u32::default(),
            max_descriptor_set_acceleration_structures: u32::default(),
            max_descriptor_set_update_after_bind_acceleration_structures: u32::default(),
            min_acceleration_structure_scratch_offset_alignment: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceAccelerationStructurePropertiesKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR;
}
impl PhysicalDeviceAccelerationStructurePropertiesKHR {
    pub fn builder<'a>() -> PhysicalDeviceAccelerationStructurePropertiesKHRBuilder<'a> {
        PhysicalDeviceAccelerationStructurePropertiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceAccelerationStructurePropertiesKHRBuilder<'a> {
    inner: PhysicalDeviceAccelerationStructurePropertiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceAccelerationStructurePropertiesKHRBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceAccelerationStructurePropertiesKHR {}
impl<'a> ::std::ops::Deref for PhysicalDeviceAccelerationStructurePropertiesKHRBuilder<'a> {
    type Target = PhysicalDeviceAccelerationStructurePropertiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceAccelerationStructurePropertiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceAccelerationStructurePropertiesKHRBuilder<'a> {
    #[inline]
    pub fn max_geometry_count(mut self, max_geometry_count: u64) -> Self {
        self.inner.max_geometry_count = max_geometry_count;
        self
    }
    #[inline]
    pub fn max_instance_count(mut self, max_instance_count: u64) -> Self {
        self.inner.max_instance_count = max_instance_count;
        self
    }
    #[inline]
    pub fn max_primitive_count(mut self, max_primitive_count: u64) -> Self {
        self.inner.max_primitive_count = max_primitive_count;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_acceleration_structures(
        mut self,
        max_per_stage_descriptor_acceleration_structures: u32,
    ) -> Self {
        self.inner.max_per_stage_descriptor_acceleration_structures =
            max_per_stage_descriptor_acceleration_structures;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_acceleration_structures(
        mut self,
        max_per_stage_descriptor_update_after_bind_acceleration_structures: u32,
    ) -> Self {
        self.inner
            .max_per_stage_descriptor_update_after_bind_acceleration_structures =
            max_per_stage_descriptor_update_after_bind_acceleration_structures;
        self
    }
    #[inline]
    pub fn max_descriptor_set_acceleration_structures(
        mut self,
        max_descriptor_set_acceleration_structures: u32,
    ) -> Self {
        self.inner.max_descriptor_set_acceleration_structures =
            max_descriptor_set_acceleration_structures;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_acceleration_structures(
        mut self,
        max_descriptor_set_update_after_bind_acceleration_structures: u32,
    ) -> Self {
        self.inner
            .max_descriptor_set_update_after_bind_acceleration_structures =
            max_descriptor_set_update_after_bind_acceleration_structures;
        self
    }
    #[inline]
    pub fn min_acceleration_structure_scratch_offset_alignment(
        mut self,
        min_acceleration_structure_scratch_offset_alignment: u32,
    ) -> Self {
        self.inner
            .min_acceleration_structure_scratch_offset_alignment =
            min_acceleration_structure_scratch_offset_alignment;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceAccelerationStructurePropertiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingPipelinePropertiesKHR.html>"]
pub struct PhysicalDeviceRayTracingPipelinePropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_group_handle_size: u32,
    pub max_ray_recursion_depth: u32,
    pub max_shader_group_stride: u32,
    pub shader_group_base_alignment: u32,
    pub shader_group_handle_capture_replay_size: u32,
    pub max_ray_dispatch_invocation_count: u32,
    pub shader_group_handle_alignment: u32,
    pub max_ray_hit_attribute_size: u32,
}
impl ::std::default::Default for PhysicalDeviceRayTracingPipelinePropertiesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_group_handle_size: u32::default(),
            max_ray_recursion_depth: u32::default(),
            max_shader_group_stride: u32::default(),
            shader_group_base_alignment: u32::default(),
            shader_group_handle_capture_replay_size: u32::default(),
            max_ray_dispatch_invocation_count: u32::default(),
            shader_group_handle_alignment: u32::default(),
            max_ray_hit_attribute_size: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceRayTracingPipelinePropertiesKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR;
}
impl PhysicalDeviceRayTracingPipelinePropertiesKHR {
    pub fn builder<'a>() -> PhysicalDeviceRayTracingPipelinePropertiesKHRBuilder<'a> {
        PhysicalDeviceRayTracingPipelinePropertiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceRayTracingPipelinePropertiesKHRBuilder<'a> {
    inner: PhysicalDeviceRayTracingPipelinePropertiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceRayTracingPipelinePropertiesKHRBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceRayTracingPipelinePropertiesKHR {}
impl<'a> ::std::ops::Deref for PhysicalDeviceRayTracingPipelinePropertiesKHRBuilder<'a> {
    type Target = PhysicalDeviceRayTracingPipelinePropertiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceRayTracingPipelinePropertiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceRayTracingPipelinePropertiesKHRBuilder<'a> {
    #[inline]
    pub fn shader_group_handle_size(mut self, shader_group_handle_size: u32) -> Self {
        self.inner.shader_group_handle_size = shader_group_handle_size;
        self
    }
    #[inline]
    pub fn max_ray_recursion_depth(mut self, max_ray_recursion_depth: u32) -> Self {
        self.inner.max_ray_recursion_depth = max_ray_recursion_depth;
        self
    }
    #[inline]
    pub fn max_shader_group_stride(mut self, max_shader_group_stride: u32) -> Self {
        self.inner.max_shader_group_stride = max_shader_group_stride;
        self
    }
    #[inline]
    pub fn shader_group_base_alignment(mut self, shader_group_base_alignment: u32) -> Self {
        self.inner.shader_group_base_alignment = shader_group_base_alignment;
        self
    }
    #[inline]
    pub fn shader_group_handle_capture_replay_size(
        mut self,
        shader_group_handle_capture_replay_size: u32,
    ) -> Self {
        self.inner.shader_group_handle_capture_replay_size =
            shader_group_handle_capture_replay_size;
        self
    }
    #[inline]
    pub fn max_ray_dispatch_invocation_count(
        mut self,
        max_ray_dispatch_invocation_count: u32,
    ) -> Self {
        self.inner.max_ray_dispatch_invocation_count = max_ray_dispatch_invocation_count;
        self
    }
    #[inline]
    pub fn shader_group_handle_alignment(mut self, shader_group_handle_alignment: u32) -> Self {
        self.inner.shader_group_handle_alignment = shader_group_handle_alignment;
        self
    }
    #[inline]
    pub fn max_ray_hit_attribute_size(mut self, max_ray_hit_attribute_size: u32) -> Self {
        self.inner.max_ray_hit_attribute_size = max_ray_hit_attribute_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceRayTracingPipelinePropertiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingPropertiesNV.html>"]
pub struct PhysicalDeviceRayTracingPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_group_handle_size: u32,
    pub max_recursion_depth: u32,
    pub max_shader_group_stride: u32,
    pub shader_group_base_alignment: u32,
    pub max_geometry_count: u64,
    pub max_instance_count: u64,
    pub max_triangle_count: u64,
    pub max_descriptor_set_acceleration_structures: u32,
}
impl ::std::default::Default for PhysicalDeviceRayTracingPropertiesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_group_handle_size: u32::default(),
            max_recursion_depth: u32::default(),
            max_shader_group_stride: u32::default(),
            shader_group_base_alignment: u32::default(),
            max_geometry_count: u64::default(),
            max_instance_count: u64::default(),
            max_triangle_count: u64::default(),
            max_descriptor_set_acceleration_structures: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceRayTracingPropertiesNV {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV;
}
impl PhysicalDeviceRayTracingPropertiesNV {
    pub fn builder<'a>() -> PhysicalDeviceRayTracingPropertiesNVBuilder<'a> {
        PhysicalDeviceRayTracingPropertiesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceRayTracingPropertiesNVBuilder<'a> {
    inner: PhysicalDeviceRayTracingPropertiesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceRayTracingPropertiesNVBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceRayTracingPropertiesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceRayTracingPropertiesNVBuilder<'a> {
    type Target = PhysicalDeviceRayTracingPropertiesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceRayTracingPropertiesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceRayTracingPropertiesNVBuilder<'a> {
    #[inline]
    pub fn shader_group_handle_size(mut self, shader_group_handle_size: u32) -> Self {
        self.inner.shader_group_handle_size = shader_group_handle_size;
        self
    }
    #[inline]
    pub fn max_recursion_depth(mut self, max_recursion_depth: u32) -> Self {
        self.inner.max_recursion_depth = max_recursion_depth;
        self
    }
    #[inline]
    pub fn max_shader_group_stride(mut self, max_shader_group_stride: u32) -> Self {
        self.inner.max_shader_group_stride = max_shader_group_stride;
        self
    }
    #[inline]
    pub fn shader_group_base_alignment(mut self, shader_group_base_alignment: u32) -> Self {
        self.inner.shader_group_base_alignment = shader_group_base_alignment;
        self
    }
    #[inline]
    pub fn max_geometry_count(mut self, max_geometry_count: u64) -> Self {
        self.inner.max_geometry_count = max_geometry_count;
        self
    }
    #[inline]
    pub fn max_instance_count(mut self, max_instance_count: u64) -> Self {
        self.inner.max_instance_count = max_instance_count;
        self
    }
    #[inline]
    pub fn max_triangle_count(mut self, max_triangle_count: u64) -> Self {
        self.inner.max_triangle_count = max_triangle_count;
        self
    }
    #[inline]
    pub fn max_descriptor_set_acceleration_structures(
        mut self,
        max_descriptor_set_acceleration_structures: u32,
    ) -> Self {
        self.inner.max_descriptor_set_acceleration_structures =
            max_descriptor_set_acceleration_structures;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceRayTracingPropertiesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStridedDeviceAddressRegionKHR.html>"]
pub struct StridedDeviceAddressRegionKHR {
    pub device_address: DeviceAddress,
    pub stride: DeviceSize,
    pub size: DeviceSize,
}
impl StridedDeviceAddressRegionKHR {
    pub fn builder<'a>() -> StridedDeviceAddressRegionKHRBuilder<'a> {
        StridedDeviceAddressRegionKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct StridedDeviceAddressRegionKHRBuilder<'a> {
    inner: StridedDeviceAddressRegionKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for StridedDeviceAddressRegionKHRBuilder<'a> {
    type Target = StridedDeviceAddressRegionKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for StridedDeviceAddressRegionKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> StridedDeviceAddressRegionKHRBuilder<'a> {
    #[inline]
    pub fn device_address(mut self, device_address: DeviceAddress) -> Self {
        self.inner.device_address = device_address;
        self
    }
    #[inline]
    pub fn stride(mut self, stride: DeviceSize) -> Self {
        self.inner.stride = stride;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> StridedDeviceAddressRegionKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkTraceRaysIndirectCommandKHR.html>"]
pub struct TraceRaysIndirectCommandKHR {
    pub width: u32,
    pub height: u32,
    pub depth: u32,
}
impl TraceRaysIndirectCommandKHR {
    pub fn builder<'a>() -> TraceRaysIndirectCommandKHRBuilder<'a> {
        TraceRaysIndirectCommandKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct TraceRaysIndirectCommandKHRBuilder<'a> {
    inner: TraceRaysIndirectCommandKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for TraceRaysIndirectCommandKHRBuilder<'a> {
    type Target = TraceRaysIndirectCommandKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for TraceRaysIndirectCommandKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> TraceRaysIndirectCommandKHRBuilder<'a> {
    #[inline]
    pub fn width(mut self, width: u32) -> Self {
        self.inner.width = width;
        self
    }
    #[inline]
    pub fn height(mut self, height: u32) -> Self {
        self.inner.height = height;
        self
    }
    #[inline]
    pub fn depth(mut self, depth: u32) -> Self {
        self.inner.depth = depth;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> TraceRaysIndirectCommandKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkTraceRaysIndirectCommand2KHR.html>"]
pub struct TraceRaysIndirectCommand2KHR {
    pub raygen_shader_record_address: DeviceAddress,
    pub raygen_shader_record_size: DeviceSize,
    pub miss_shader_binding_table_address: DeviceAddress,
    pub miss_shader_binding_table_size: DeviceSize,
    pub miss_shader_binding_table_stride: DeviceSize,
    pub hit_shader_binding_table_address: DeviceAddress,
    pub hit_shader_binding_table_size: DeviceSize,
    pub hit_shader_binding_table_stride: DeviceSize,
    pub callable_shader_binding_table_address: DeviceAddress,
    pub callable_shader_binding_table_size: DeviceSize,
    pub callable_shader_binding_table_stride: DeviceSize,
    pub width: u32,
    pub height: u32,
    pub depth: u32,
}
impl TraceRaysIndirectCommand2KHR {
    pub fn builder<'a>() -> TraceRaysIndirectCommand2KHRBuilder<'a> {
        TraceRaysIndirectCommand2KHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct TraceRaysIndirectCommand2KHRBuilder<'a> {
    inner: TraceRaysIndirectCommand2KHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for TraceRaysIndirectCommand2KHRBuilder<'a> {
    type Target = TraceRaysIndirectCommand2KHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for TraceRaysIndirectCommand2KHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> TraceRaysIndirectCommand2KHRBuilder<'a> {
    #[inline]
    pub fn raygen_shader_record_address(
        mut self,
        raygen_shader_record_address: DeviceAddress,
    ) -> Self {
        self.inner.raygen_shader_record_address = raygen_shader_record_address;
        self
    }
    #[inline]
    pub fn raygen_shader_record_size(mut self, raygen_shader_record_size: DeviceSize) -> Self {
        self.inner.raygen_shader_record_size = raygen_shader_record_size;
        self
    }
    #[inline]
    pub fn miss_shader_binding_table_address(
        mut self,
        miss_shader_binding_table_address: DeviceAddress,
    ) -> Self {
        self.inner.miss_shader_binding_table_address = miss_shader_binding_table_address;
        self
    }
    #[inline]
    pub fn miss_shader_binding_table_size(
        mut self,
        miss_shader_binding_table_size: DeviceSize,
    ) -> Self {
        self.inner.miss_shader_binding_table_size = miss_shader_binding_table_size;
        self
    }
    #[inline]
    pub fn miss_shader_binding_table_stride(
        mut self,
        miss_shader_binding_table_stride: DeviceSize,
    ) -> Self {
        self.inner.miss_shader_binding_table_stride = miss_shader_binding_table_stride;
        self
    }
    #[inline]
    pub fn hit_shader_binding_table_address(
        mut self,
        hit_shader_binding_table_address: DeviceAddress,
    ) -> Self {
        self.inner.hit_shader_binding_table_address = hit_shader_binding_table_address;
        self
    }
    #[inline]
    pub fn hit_shader_binding_table_size(
        mut self,
        hit_shader_binding_table_size: DeviceSize,
    ) -> Self {
        self.inner.hit_shader_binding_table_size = hit_shader_binding_table_size;
        self
    }
    #[inline]
    pub fn hit_shader_binding_table_stride(
        mut self,
        hit_shader_binding_table_stride: DeviceSize,
    ) -> Self {
        self.inner.hit_shader_binding_table_stride = hit_shader_binding_table_stride;
        self
    }
    #[inline]
    pub fn callable_shader_binding_table_address(
        mut self,
        callable_shader_binding_table_address: DeviceAddress,
    ) -> Self {
        self.inner.callable_shader_binding_table_address = callable_shader_binding_table_address;
        self
    }
    #[inline]
    pub fn callable_shader_binding_table_size(
        mut self,
        callable_shader_binding_table_size: DeviceSize,
    ) -> Self {
        self.inner.callable_shader_binding_table_size = callable_shader_binding_table_size;
        self
    }
    #[inline]
    pub fn callable_shader_binding_table_stride(
        mut self,
        callable_shader_binding_table_stride: DeviceSize,
    ) -> Self {
        self.inner.callable_shader_binding_table_stride = callable_shader_binding_table_stride;
        self
    }
    #[inline]
    pub fn width(mut self, width: u32) -> Self {
        self.inner.width = width;
        self
    }
    #[inline]
    pub fn height(mut self, height: u32) -> Self {
        self.inner.height = height;
        self
    }
    #[inline]
    pub fn depth(mut self, depth: u32) -> Self {
        self.inner.depth = depth;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> TraceRaysIndirectCommand2KHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR.html>"]
pub struct PhysicalDeviceRayTracingMaintenance1FeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ray_tracing_maintenance1: Bool32,
    pub ray_tracing_pipeline_trace_rays_indirect2: Bool32,
}
impl ::std::default::Default for PhysicalDeviceRayTracingMaintenance1FeaturesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            ray_tracing_maintenance1: Bool32::default(),
            ray_tracing_pipeline_trace_rays_indirect2: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceRayTracingMaintenance1FeaturesKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR;
}
impl PhysicalDeviceRayTracingMaintenance1FeaturesKHR {
    pub fn builder<'a>() -> PhysicalDeviceRayTracingMaintenance1FeaturesKHRBuilder<'a> {
        PhysicalDeviceRayTracingMaintenance1FeaturesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceRayTracingMaintenance1FeaturesKHRBuilder<'a> {
    inner: PhysicalDeviceRayTracingMaintenance1FeaturesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceRayTracingMaintenance1FeaturesKHRBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRayTracingMaintenance1FeaturesKHR {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRayTracingMaintenance1FeaturesKHRBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRayTracingMaintenance1FeaturesKHR {}
impl<'a> ::std::ops::Deref for PhysicalDeviceRayTracingMaintenance1FeaturesKHRBuilder<'a> {
    type Target = PhysicalDeviceRayTracingMaintenance1FeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceRayTracingMaintenance1FeaturesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceRayTracingMaintenance1FeaturesKHRBuilder<'a> {
    #[inline]
    pub fn ray_tracing_maintenance1(mut self, ray_tracing_maintenance1: bool) -> Self {
        self.inner.ray_tracing_maintenance1 = ray_tracing_maintenance1.into();
        self
    }
    #[inline]
    pub fn ray_tracing_pipeline_trace_rays_indirect2(
        mut self,
        ray_tracing_pipeline_trace_rays_indirect2: bool,
    ) -> Self {
        self.inner.ray_tracing_pipeline_trace_rays_indirect2 =
            ray_tracing_pipeline_trace_rays_indirect2.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceRayTracingMaintenance1FeaturesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrmFormatModifierPropertiesListEXT.html>"]
pub struct DrmFormatModifierPropertiesListEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub drm_format_modifier_count: u32,
    pub p_drm_format_modifier_properties: *mut DrmFormatModifierPropertiesEXT,
}
impl ::std::default::Default for DrmFormatModifierPropertiesListEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            drm_format_modifier_count: u32::default(),
            p_drm_format_modifier_properties: ::std::ptr::null_mut(),
        }
    }
}
unsafe impl TaggedStructure for DrmFormatModifierPropertiesListEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT;
}
impl DrmFormatModifierPropertiesListEXT {
    pub fn builder<'a>() -> DrmFormatModifierPropertiesListEXTBuilder<'a> {
        DrmFormatModifierPropertiesListEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DrmFormatModifierPropertiesListEXTBuilder<'a> {
    inner: DrmFormatModifierPropertiesListEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsFormatProperties2 for DrmFormatModifierPropertiesListEXTBuilder<'_> {}
unsafe impl ExtendsFormatProperties2 for DrmFormatModifierPropertiesListEXT {}
impl<'a> ::std::ops::Deref for DrmFormatModifierPropertiesListEXTBuilder<'a> {
    type Target = DrmFormatModifierPropertiesListEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DrmFormatModifierPropertiesListEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DrmFormatModifierPropertiesListEXTBuilder<'a> {
    #[inline]
    pub fn drm_format_modifier_properties(
        mut self,
        drm_format_modifier_properties: &'a mut [DrmFormatModifierPropertiesEXT],
    ) -> Self {
        self.inner.drm_format_modifier_count = drm_format_modifier_properties.len() as _;
        self.inner.p_drm_format_modifier_properties = drm_format_modifier_properties.as_mut_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DrmFormatModifierPropertiesListEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrmFormatModifierPropertiesEXT.html>"]
pub struct DrmFormatModifierPropertiesEXT {
    pub drm_format_modifier: u64,
    pub drm_format_modifier_plane_count: u32,
    pub drm_format_modifier_tiling_features: FormatFeatureFlags,
}
impl DrmFormatModifierPropertiesEXT {
    pub fn builder<'a>() -> DrmFormatModifierPropertiesEXTBuilder<'a> {
        DrmFormatModifierPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DrmFormatModifierPropertiesEXTBuilder<'a> {
    inner: DrmFormatModifierPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DrmFormatModifierPropertiesEXTBuilder<'a> {
    type Target = DrmFormatModifierPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DrmFormatModifierPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DrmFormatModifierPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn drm_format_modifier(mut self, drm_format_modifier: u64) -> Self {
        self.inner.drm_format_modifier = drm_format_modifier;
        self
    }
    #[inline]
    pub fn drm_format_modifier_plane_count(mut self, drm_format_modifier_plane_count: u32) -> Self {
        self.inner.drm_format_modifier_plane_count = drm_format_modifier_plane_count;
        self
    }
    #[inline]
    pub fn drm_format_modifier_tiling_features(
        mut self,
        drm_format_modifier_tiling_features: FormatFeatureFlags,
    ) -> Self {
        self.inner.drm_format_modifier_tiling_features = drm_format_modifier_tiling_features;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DrmFormatModifierPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageDrmFormatModifierInfoEXT.html>"]
pub struct PhysicalDeviceImageDrmFormatModifierInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub drm_format_modifier: u64,
    pub sharing_mode: SharingMode,
    pub queue_family_index_count: u32,
    pub p_queue_family_indices: *const u32,
}
impl ::std::default::Default for PhysicalDeviceImageDrmFormatModifierInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            drm_format_modifier: u64::default(),
            sharing_mode: SharingMode::default(),
            queue_family_index_count: u32::default(),
            p_queue_family_indices: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceImageDrmFormatModifierInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT;
}
impl PhysicalDeviceImageDrmFormatModifierInfoEXT {
    pub fn builder<'a>() -> PhysicalDeviceImageDrmFormatModifierInfoEXTBuilder<'a> {
        PhysicalDeviceImageDrmFormatModifierInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceImageDrmFormatModifierInfoEXTBuilder<'a> {
    inner: PhysicalDeviceImageDrmFormatModifierInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceImageFormatInfo2
    for PhysicalDeviceImageDrmFormatModifierInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceImageFormatInfo2 for PhysicalDeviceImageDrmFormatModifierInfoEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceImageDrmFormatModifierInfoEXTBuilder<'a> {
    type Target = PhysicalDeviceImageDrmFormatModifierInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceImageDrmFormatModifierInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceImageDrmFormatModifierInfoEXTBuilder<'a> {
    #[inline]
    pub fn drm_format_modifier(mut self, drm_format_modifier: u64) -> Self {
        self.inner.drm_format_modifier = drm_format_modifier;
        self
    }
    #[inline]
    pub fn sharing_mode(mut self, sharing_mode: SharingMode) -> Self {
        self.inner.sharing_mode = sharing_mode;
        self
    }
    #[inline]
    pub fn queue_family_indices(mut self, queue_family_indices: &'a [u32]) -> Self {
        self.inner.queue_family_index_count = queue_family_indices.len() as _;
        self.inner.p_queue_family_indices = queue_family_indices.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceImageDrmFormatModifierInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageDrmFormatModifierListCreateInfoEXT.html>"]
pub struct ImageDrmFormatModifierListCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub drm_format_modifier_count: u32,
    pub p_drm_format_modifiers: *const u64,
}
impl ::std::default::Default for ImageDrmFormatModifierListCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            drm_format_modifier_count: u32::default(),
            p_drm_format_modifiers: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for ImageDrmFormatModifierListCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT;
}
impl ImageDrmFormatModifierListCreateInfoEXT {
    pub fn builder<'a>() -> ImageDrmFormatModifierListCreateInfoEXTBuilder<'a> {
        ImageDrmFormatModifierListCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageDrmFormatModifierListCreateInfoEXTBuilder<'a> {
    inner: ImageDrmFormatModifierListCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageCreateInfo for ImageDrmFormatModifierListCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsImageCreateInfo for ImageDrmFormatModifierListCreateInfoEXT {}
impl<'a> ::std::ops::Deref for ImageDrmFormatModifierListCreateInfoEXTBuilder<'a> {
    type Target = ImageDrmFormatModifierListCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageDrmFormatModifierListCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageDrmFormatModifierListCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn drm_format_modifiers(mut self, drm_format_modifiers: &'a [u64]) -> Self {
        self.inner.drm_format_modifier_count = drm_format_modifiers.len() as _;
        self.inner.p_drm_format_modifiers = drm_format_modifiers.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageDrmFormatModifierListCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageDrmFormatModifierExplicitCreateInfoEXT.html>"]
pub struct ImageDrmFormatModifierExplicitCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub drm_format_modifier: u64,
    pub drm_format_modifier_plane_count: u32,
    pub p_plane_layouts: *const SubresourceLayout,
}
impl ::std::default::Default for ImageDrmFormatModifierExplicitCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            drm_format_modifier: u64::default(),
            drm_format_modifier_plane_count: u32::default(),
            p_plane_layouts: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for ImageDrmFormatModifierExplicitCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT;
}
impl ImageDrmFormatModifierExplicitCreateInfoEXT {
    pub fn builder<'a>() -> ImageDrmFormatModifierExplicitCreateInfoEXTBuilder<'a> {
        ImageDrmFormatModifierExplicitCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageDrmFormatModifierExplicitCreateInfoEXTBuilder<'a> {
    inner: ImageDrmFormatModifierExplicitCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageCreateInfo for ImageDrmFormatModifierExplicitCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsImageCreateInfo for ImageDrmFormatModifierExplicitCreateInfoEXT {}
impl<'a> ::std::ops::Deref for ImageDrmFormatModifierExplicitCreateInfoEXTBuilder<'a> {
    type Target = ImageDrmFormatModifierExplicitCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageDrmFormatModifierExplicitCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageDrmFormatModifierExplicitCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn drm_format_modifier(mut self, drm_format_modifier: u64) -> Self {
        self.inner.drm_format_modifier = drm_format_modifier;
        self
    }
    #[inline]
    pub fn plane_layouts(mut self, plane_layouts: &'a [SubresourceLayout]) -> Self {
        self.inner.drm_format_modifier_plane_count = plane_layouts.len() as _;
        self.inner.p_plane_layouts = plane_layouts.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageDrmFormatModifierExplicitCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageDrmFormatModifierPropertiesEXT.html>"]
pub struct ImageDrmFormatModifierPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub drm_format_modifier: u64,
}
impl ::std::default::Default for ImageDrmFormatModifierPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            drm_format_modifier: u64::default(),
        }
    }
}
unsafe impl TaggedStructure for ImageDrmFormatModifierPropertiesEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT;
}
impl ImageDrmFormatModifierPropertiesEXT {
    pub fn builder<'a>() -> ImageDrmFormatModifierPropertiesEXTBuilder<'a> {
        ImageDrmFormatModifierPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageDrmFormatModifierPropertiesEXTBuilder<'a> {
    inner: ImageDrmFormatModifierPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ImageDrmFormatModifierPropertiesEXTBuilder<'a> {
    type Target = ImageDrmFormatModifierPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageDrmFormatModifierPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageDrmFormatModifierPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn drm_format_modifier(mut self, drm_format_modifier: u64) -> Self {
        self.inner.drm_format_modifier = drm_format_modifier;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageDrmFormatModifierPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageStencilUsageCreateInfo.html>"]
pub struct ImageStencilUsageCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub stencil_usage: ImageUsageFlags,
}
impl ::std::default::Default for ImageStencilUsageCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            stencil_usage: ImageUsageFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for ImageStencilUsageCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_STENCIL_USAGE_CREATE_INFO;
}
impl ImageStencilUsageCreateInfo {
    pub fn builder<'a>() -> ImageStencilUsageCreateInfoBuilder<'a> {
        ImageStencilUsageCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageStencilUsageCreateInfoBuilder<'a> {
    inner: ImageStencilUsageCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageCreateInfo for ImageStencilUsageCreateInfoBuilder<'_> {}
unsafe impl ExtendsImageCreateInfo for ImageStencilUsageCreateInfo {}
unsafe impl ExtendsPhysicalDeviceImageFormatInfo2 for ImageStencilUsageCreateInfoBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceImageFormatInfo2 for ImageStencilUsageCreateInfo {}
impl<'a> ::std::ops::Deref for ImageStencilUsageCreateInfoBuilder<'a> {
    type Target = ImageStencilUsageCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageStencilUsageCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageStencilUsageCreateInfoBuilder<'a> {
    #[inline]
    pub fn stencil_usage(mut self, stencil_usage: ImageUsageFlags) -> Self {
        self.inner.stencil_usage = stencil_usage;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageStencilUsageCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceMemoryOverallocationCreateInfoAMD.html>"]
pub struct DeviceMemoryOverallocationCreateInfoAMD {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub overallocation_behavior: MemoryOverallocationBehaviorAMD,
}
impl ::std::default::Default for DeviceMemoryOverallocationCreateInfoAMD {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            overallocation_behavior: MemoryOverallocationBehaviorAMD::default(),
        }
    }
}
unsafe impl TaggedStructure for DeviceMemoryOverallocationCreateInfoAMD {
    const STRUCTURE_TYPE: StructureType =
        StructureType::DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD;
}
impl DeviceMemoryOverallocationCreateInfoAMD {
    pub fn builder<'a>() -> DeviceMemoryOverallocationCreateInfoAMDBuilder<'a> {
        DeviceMemoryOverallocationCreateInfoAMDBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceMemoryOverallocationCreateInfoAMDBuilder<'a> {
    inner: DeviceMemoryOverallocationCreateInfoAMD,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsDeviceCreateInfo for DeviceMemoryOverallocationCreateInfoAMDBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for DeviceMemoryOverallocationCreateInfoAMD {}
impl<'a> ::std::ops::Deref for DeviceMemoryOverallocationCreateInfoAMDBuilder<'a> {
    type Target = DeviceMemoryOverallocationCreateInfoAMD;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceMemoryOverallocationCreateInfoAMDBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceMemoryOverallocationCreateInfoAMDBuilder<'a> {
    #[inline]
    pub fn overallocation_behavior(
        mut self,
        overallocation_behavior: MemoryOverallocationBehaviorAMD,
    ) -> Self {
        self.inner.overallocation_behavior = overallocation_behavior;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceMemoryOverallocationCreateInfoAMD {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentDensityMapFeaturesEXT.html>"]
pub struct PhysicalDeviceFragmentDensityMapFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub fragment_density_map: Bool32,
    pub fragment_density_map_dynamic: Bool32,
    pub fragment_density_map_non_subsampled_images: Bool32,
}
impl ::std::default::Default for PhysicalDeviceFragmentDensityMapFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            fragment_density_map: Bool32::default(),
            fragment_density_map_dynamic: Bool32::default(),
            fragment_density_map_non_subsampled_images: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceFragmentDensityMapFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT;
}
impl PhysicalDeviceFragmentDensityMapFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceFragmentDensityMapFeaturesEXTBuilder<'a> {
        PhysicalDeviceFragmentDensityMapFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceFragmentDensityMapFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceFragmentDensityMapFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceFragmentDensityMapFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceFragmentDensityMapFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentDensityMapFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentDensityMapFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceFragmentDensityMapFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceFragmentDensityMapFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceFragmentDensityMapFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceFragmentDensityMapFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn fragment_density_map(mut self, fragment_density_map: bool) -> Self {
        self.inner.fragment_density_map = fragment_density_map.into();
        self
    }
    #[inline]
    pub fn fragment_density_map_dynamic(mut self, fragment_density_map_dynamic: bool) -> Self {
        self.inner.fragment_density_map_dynamic = fragment_density_map_dynamic.into();
        self
    }
    #[inline]
    pub fn fragment_density_map_non_subsampled_images(
        mut self,
        fragment_density_map_non_subsampled_images: bool,
    ) -> Self {
        self.inner.fragment_density_map_non_subsampled_images =
            fragment_density_map_non_subsampled_images.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceFragmentDensityMapFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentDensityMap2FeaturesEXT.html>"]
pub struct PhysicalDeviceFragmentDensityMap2FeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub fragment_density_map_deferred: Bool32,
}
impl ::std::default::Default for PhysicalDeviceFragmentDensityMap2FeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            fragment_density_map_deferred: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceFragmentDensityMap2FeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT;
}
impl PhysicalDeviceFragmentDensityMap2FeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceFragmentDensityMap2FeaturesEXTBuilder<'a> {
        PhysicalDeviceFragmentDensityMap2FeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceFragmentDensityMap2FeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceFragmentDensityMap2FeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceFragmentDensityMap2FeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceFragmentDensityMap2FeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentDensityMap2FeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentDensityMap2FeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceFragmentDensityMap2FeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceFragmentDensityMap2FeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceFragmentDensityMap2FeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceFragmentDensityMap2FeaturesEXTBuilder<'a> {
    #[inline]
    pub fn fragment_density_map_deferred(mut self, fragment_density_map_deferred: bool) -> Self {
        self.inner.fragment_density_map_deferred = fragment_density_map_deferred.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceFragmentDensityMap2FeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM.html>"]
pub struct PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub fragment_density_map_offset: Bool32,
}
impl ::std::default::Default for PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            fragment_density_map_offset: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM;
}
impl PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM {
    pub fn builder<'a>() -> PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOMBuilder<'a> {
        PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOMBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOMBuilder<'a> {
    inner: PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOMBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM {}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOMBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM {}
impl<'a> ::std::ops::Deref for PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOMBuilder<'a> {
    type Target = PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOMBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOMBuilder<'a> {
    #[inline]
    pub fn fragment_density_map_offset(mut self, fragment_density_map_offset: bool) -> Self {
        self.inner.fragment_density_map_offset = fragment_density_map_offset.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentDensityMapPropertiesEXT.html>"]
pub struct PhysicalDeviceFragmentDensityMapPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_fragment_density_texel_size: Extent2D,
    pub max_fragment_density_texel_size: Extent2D,
    pub fragment_density_invocations: Bool32,
}
impl ::std::default::Default for PhysicalDeviceFragmentDensityMapPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            min_fragment_density_texel_size: Extent2D::default(),
            max_fragment_density_texel_size: Extent2D::default(),
            fragment_density_invocations: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceFragmentDensityMapPropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT;
}
impl PhysicalDeviceFragmentDensityMapPropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceFragmentDensityMapPropertiesEXTBuilder<'a> {
        PhysicalDeviceFragmentDensityMapPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceFragmentDensityMapPropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceFragmentDensityMapPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceFragmentDensityMapPropertiesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceFragmentDensityMapPropertiesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceFragmentDensityMapPropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceFragmentDensityMapPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceFragmentDensityMapPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceFragmentDensityMapPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn min_fragment_density_texel_size(
        mut self,
        min_fragment_density_texel_size: Extent2D,
    ) -> Self {
        self.inner.min_fragment_density_texel_size = min_fragment_density_texel_size;
        self
    }
    #[inline]
    pub fn max_fragment_density_texel_size(
        mut self,
        max_fragment_density_texel_size: Extent2D,
    ) -> Self {
        self.inner.max_fragment_density_texel_size = max_fragment_density_texel_size;
        self
    }
    #[inline]
    pub fn fragment_density_invocations(mut self, fragment_density_invocations: bool) -> Self {
        self.inner.fragment_density_invocations = fragment_density_invocations.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceFragmentDensityMapPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentDensityMap2PropertiesEXT.html>"]
pub struct PhysicalDeviceFragmentDensityMap2PropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub subsampled_loads: Bool32,
    pub subsampled_coarse_reconstruction_early_access: Bool32,
    pub max_subsampled_array_layers: u32,
    pub max_descriptor_set_subsampled_samplers: u32,
}
impl ::std::default::Default for PhysicalDeviceFragmentDensityMap2PropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            subsampled_loads: Bool32::default(),
            subsampled_coarse_reconstruction_early_access: Bool32::default(),
            max_subsampled_array_layers: u32::default(),
            max_descriptor_set_subsampled_samplers: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceFragmentDensityMap2PropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT;
}
impl PhysicalDeviceFragmentDensityMap2PropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceFragmentDensityMap2PropertiesEXTBuilder<'a> {
        PhysicalDeviceFragmentDensityMap2PropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceFragmentDensityMap2PropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceFragmentDensityMap2PropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceFragmentDensityMap2PropertiesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceFragmentDensityMap2PropertiesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceFragmentDensityMap2PropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceFragmentDensityMap2PropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceFragmentDensityMap2PropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceFragmentDensityMap2PropertiesEXTBuilder<'a> {
    #[inline]
    pub fn subsampled_loads(mut self, subsampled_loads: bool) -> Self {
        self.inner.subsampled_loads = subsampled_loads.into();
        self
    }
    #[inline]
    pub fn subsampled_coarse_reconstruction_early_access(
        mut self,
        subsampled_coarse_reconstruction_early_access: bool,
    ) -> Self {
        self.inner.subsampled_coarse_reconstruction_early_access =
            subsampled_coarse_reconstruction_early_access.into();
        self
    }
    #[inline]
    pub fn max_subsampled_array_layers(mut self, max_subsampled_array_layers: u32) -> Self {
        self.inner.max_subsampled_array_layers = max_subsampled_array_layers;
        self
    }
    #[inline]
    pub fn max_descriptor_set_subsampled_samplers(
        mut self,
        max_descriptor_set_subsampled_samplers: u32,
    ) -> Self {
        self.inner.max_descriptor_set_subsampled_samplers = max_descriptor_set_subsampled_samplers;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceFragmentDensityMap2PropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM.html>"]
pub struct PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub fragment_density_offset_granularity: Extent2D,
}
impl ::std::default::Default for PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            fragment_density_offset_granularity: Extent2D::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM;
}
impl PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM {
    pub fn builder<'a>() -> PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOMBuilder<'a> {
        PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOMBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOMBuilder<'a> {
    inner: PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOMBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM
{
}
impl<'a> ::std::ops::Deref for PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOMBuilder<'a> {
    type Target = PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOMBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOMBuilder<'a> {
    #[inline]
    pub fn fragment_density_offset_granularity(
        mut self,
        fragment_density_offset_granularity: Extent2D,
    ) -> Self {
        self.inner.fragment_density_offset_granularity = fragment_density_offset_granularity;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassFragmentDensityMapCreateInfoEXT.html>"]
pub struct RenderPassFragmentDensityMapCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fragment_density_map_attachment: AttachmentReference,
}
impl ::std::default::Default for RenderPassFragmentDensityMapCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            fragment_density_map_attachment: AttachmentReference::default(),
        }
    }
}
unsafe impl TaggedStructure for RenderPassFragmentDensityMapCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT;
}
impl RenderPassFragmentDensityMapCreateInfoEXT {
    pub fn builder<'a>() -> RenderPassFragmentDensityMapCreateInfoEXTBuilder<'a> {
        RenderPassFragmentDensityMapCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RenderPassFragmentDensityMapCreateInfoEXTBuilder<'a> {
    inner: RenderPassFragmentDensityMapCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsRenderPassCreateInfo for RenderPassFragmentDensityMapCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsRenderPassCreateInfo for RenderPassFragmentDensityMapCreateInfoEXT {}
unsafe impl ExtendsRenderPassCreateInfo2 for RenderPassFragmentDensityMapCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsRenderPassCreateInfo2 for RenderPassFragmentDensityMapCreateInfoEXT {}
impl<'a> ::std::ops::Deref for RenderPassFragmentDensityMapCreateInfoEXTBuilder<'a> {
    type Target = RenderPassFragmentDensityMapCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RenderPassFragmentDensityMapCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RenderPassFragmentDensityMapCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn fragment_density_map_attachment(
        mut self,
        fragment_density_map_attachment: AttachmentReference,
    ) -> Self {
        self.inner.fragment_density_map_attachment = fragment_density_map_attachment;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RenderPassFragmentDensityMapCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassFragmentDensityMapOffsetEndInfoQCOM.html>"]
pub struct SubpassFragmentDensityMapOffsetEndInfoQCOM {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fragment_density_offset_count: u32,
    pub p_fragment_density_offsets: *const Offset2D,
}
impl ::std::default::Default for SubpassFragmentDensityMapOffsetEndInfoQCOM {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            fragment_density_offset_count: u32::default(),
            p_fragment_density_offsets: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for SubpassFragmentDensityMapOffsetEndInfoQCOM {
    const STRUCTURE_TYPE: StructureType =
        StructureType::SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM;
}
impl SubpassFragmentDensityMapOffsetEndInfoQCOM {
    pub fn builder<'a>() -> SubpassFragmentDensityMapOffsetEndInfoQCOMBuilder<'a> {
        SubpassFragmentDensityMapOffsetEndInfoQCOMBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SubpassFragmentDensityMapOffsetEndInfoQCOMBuilder<'a> {
    inner: SubpassFragmentDensityMapOffsetEndInfoQCOM,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSubpassEndInfo for SubpassFragmentDensityMapOffsetEndInfoQCOMBuilder<'_> {}
unsafe impl ExtendsSubpassEndInfo for SubpassFragmentDensityMapOffsetEndInfoQCOM {}
impl<'a> ::std::ops::Deref for SubpassFragmentDensityMapOffsetEndInfoQCOMBuilder<'a> {
    type Target = SubpassFragmentDensityMapOffsetEndInfoQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SubpassFragmentDensityMapOffsetEndInfoQCOMBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SubpassFragmentDensityMapOffsetEndInfoQCOMBuilder<'a> {
    #[inline]
    pub fn fragment_density_offsets(mut self, fragment_density_offsets: &'a [Offset2D]) -> Self {
        self.inner.fragment_density_offset_count = fragment_density_offsets.len() as _;
        self.inner.p_fragment_density_offsets = fragment_density_offsets.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SubpassFragmentDensityMapOffsetEndInfoQCOM {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceScalarBlockLayoutFeatures.html>"]
pub struct PhysicalDeviceScalarBlockLayoutFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub scalar_block_layout: Bool32,
}
impl ::std::default::Default for PhysicalDeviceScalarBlockLayoutFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            scalar_block_layout: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceScalarBlockLayoutFeatures {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
}
impl PhysicalDeviceScalarBlockLayoutFeatures {
    pub fn builder<'a>() -> PhysicalDeviceScalarBlockLayoutFeaturesBuilder<'a> {
        PhysicalDeviceScalarBlockLayoutFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceScalarBlockLayoutFeaturesBuilder<'a> {
    inner: PhysicalDeviceScalarBlockLayoutFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceScalarBlockLayoutFeaturesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceScalarBlockLayoutFeatures {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceScalarBlockLayoutFeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceScalarBlockLayoutFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDeviceScalarBlockLayoutFeaturesBuilder<'a> {
    type Target = PhysicalDeviceScalarBlockLayoutFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceScalarBlockLayoutFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceScalarBlockLayoutFeaturesBuilder<'a> {
    #[inline]
    pub fn scalar_block_layout(mut self, scalar_block_layout: bool) -> Self {
        self.inner.scalar_block_layout = scalar_block_layout.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceScalarBlockLayoutFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceProtectedCapabilitiesKHR.html>"]
pub struct SurfaceProtectedCapabilitiesKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub supports_protected: Bool32,
}
impl ::std::default::Default for SurfaceProtectedCapabilitiesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            supports_protected: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for SurfaceProtectedCapabilitiesKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::SURFACE_PROTECTED_CAPABILITIES_KHR;
}
impl SurfaceProtectedCapabilitiesKHR {
    pub fn builder<'a>() -> SurfaceProtectedCapabilitiesKHRBuilder<'a> {
        SurfaceProtectedCapabilitiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SurfaceProtectedCapabilitiesKHRBuilder<'a> {
    inner: SurfaceProtectedCapabilitiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSurfaceCapabilities2KHR for SurfaceProtectedCapabilitiesKHRBuilder<'_> {}
unsafe impl ExtendsSurfaceCapabilities2KHR for SurfaceProtectedCapabilitiesKHR {}
impl<'a> ::std::ops::Deref for SurfaceProtectedCapabilitiesKHRBuilder<'a> {
    type Target = SurfaceProtectedCapabilitiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SurfaceProtectedCapabilitiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SurfaceProtectedCapabilitiesKHRBuilder<'a> {
    #[inline]
    pub fn supports_protected(mut self, supports_protected: bool) -> Self {
        self.inner.supports_protected = supports_protected.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SurfaceProtectedCapabilitiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceUniformBufferStandardLayoutFeatures.html>"]
pub struct PhysicalDeviceUniformBufferStandardLayoutFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub uniform_buffer_standard_layout: Bool32,
}
impl ::std::default::Default for PhysicalDeviceUniformBufferStandardLayoutFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            uniform_buffer_standard_layout: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceUniformBufferStandardLayoutFeatures {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
}
impl PhysicalDeviceUniformBufferStandardLayoutFeatures {
    pub fn builder<'a>() -> PhysicalDeviceUniformBufferStandardLayoutFeaturesBuilder<'a> {
        PhysicalDeviceUniformBufferStandardLayoutFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceUniformBufferStandardLayoutFeaturesBuilder<'a> {
    inner: PhysicalDeviceUniformBufferStandardLayoutFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceUniformBufferStandardLayoutFeaturesBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceUniformBufferStandardLayoutFeatures {}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceUniformBufferStandardLayoutFeaturesBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceUniformBufferStandardLayoutFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDeviceUniformBufferStandardLayoutFeaturesBuilder<'a> {
    type Target = PhysicalDeviceUniformBufferStandardLayoutFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceUniformBufferStandardLayoutFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceUniformBufferStandardLayoutFeaturesBuilder<'a> {
    #[inline]
    pub fn uniform_buffer_standard_layout(mut self, uniform_buffer_standard_layout: bool) -> Self {
        self.inner.uniform_buffer_standard_layout = uniform_buffer_standard_layout.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceUniformBufferStandardLayoutFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDepthClipEnableFeaturesEXT.html>"]
pub struct PhysicalDeviceDepthClipEnableFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub depth_clip_enable: Bool32,
}
impl ::std::default::Default for PhysicalDeviceDepthClipEnableFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            depth_clip_enable: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceDepthClipEnableFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT;
}
impl PhysicalDeviceDepthClipEnableFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceDepthClipEnableFeaturesEXTBuilder<'a> {
        PhysicalDeviceDepthClipEnableFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceDepthClipEnableFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceDepthClipEnableFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDepthClipEnableFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDepthClipEnableFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDepthClipEnableFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDepthClipEnableFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceDepthClipEnableFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceDepthClipEnableFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceDepthClipEnableFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceDepthClipEnableFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn depth_clip_enable(mut self, depth_clip_enable: bool) -> Self {
        self.inner.depth_clip_enable = depth_clip_enable.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceDepthClipEnableFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationDepthClipStateCreateInfoEXT.html>"]
pub struct PipelineRasterizationDepthClipStateCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineRasterizationDepthClipStateCreateFlagsEXT,
    pub depth_clip_enable: Bool32,
}
impl ::std::default::Default for PipelineRasterizationDepthClipStateCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineRasterizationDepthClipStateCreateFlagsEXT::default(),
            depth_clip_enable: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineRasterizationDepthClipStateCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT;
}
impl PipelineRasterizationDepthClipStateCreateInfoEXT {
    pub fn builder<'a>() -> PipelineRasterizationDepthClipStateCreateInfoEXTBuilder<'a> {
        PipelineRasterizationDepthClipStateCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineRasterizationDepthClipStateCreateInfoEXTBuilder<'a> {
    inner: PipelineRasterizationDepthClipStateCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPipelineRasterizationStateCreateInfo
    for PipelineRasterizationDepthClipStateCreateInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsPipelineRasterizationStateCreateInfo
    for PipelineRasterizationDepthClipStateCreateInfoEXT
{
}
impl<'a> ::std::ops::Deref for PipelineRasterizationDepthClipStateCreateInfoEXTBuilder<'a> {
    type Target = PipelineRasterizationDepthClipStateCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineRasterizationDepthClipStateCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineRasterizationDepthClipStateCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineRasterizationDepthClipStateCreateFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn depth_clip_enable(mut self, depth_clip_enable: bool) -> Self {
        self.inner.depth_clip_enable = depth_clip_enable.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineRasterizationDepthClipStateCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryBudgetPropertiesEXT.html>"]
pub struct PhysicalDeviceMemoryBudgetPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub heap_budget: [DeviceSize; MAX_MEMORY_HEAPS],
    pub heap_usage: [DeviceSize; MAX_MEMORY_HEAPS],
}
impl ::std::default::Default for PhysicalDeviceMemoryBudgetPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            heap_budget: unsafe { ::std::mem::zeroed() },
            heap_usage: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceMemoryBudgetPropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT;
}
impl PhysicalDeviceMemoryBudgetPropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceMemoryBudgetPropertiesEXTBuilder<'a> {
        PhysicalDeviceMemoryBudgetPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceMemoryBudgetPropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceMemoryBudgetPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceMemoryProperties2
    for PhysicalDeviceMemoryBudgetPropertiesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceMemoryProperties2 for PhysicalDeviceMemoryBudgetPropertiesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceMemoryBudgetPropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceMemoryBudgetPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceMemoryBudgetPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceMemoryBudgetPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn heap_budget(mut self, heap_budget: [DeviceSize; MAX_MEMORY_HEAPS]) -> Self {
        self.inner.heap_budget = heap_budget;
        self
    }
    #[inline]
    pub fn heap_usage(mut self, heap_usage: [DeviceSize; MAX_MEMORY_HEAPS]) -> Self {
        self.inner.heap_usage = heap_usage;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceMemoryBudgetPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryPriorityFeaturesEXT.html>"]
pub struct PhysicalDeviceMemoryPriorityFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_priority: Bool32,
}
impl ::std::default::Default for PhysicalDeviceMemoryPriorityFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            memory_priority: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceMemoryPriorityFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT;
}
impl PhysicalDeviceMemoryPriorityFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceMemoryPriorityFeaturesEXTBuilder<'a> {
        PhysicalDeviceMemoryPriorityFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceMemoryPriorityFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceMemoryPriorityFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMemoryPriorityFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMemoryPriorityFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMemoryPriorityFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMemoryPriorityFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceMemoryPriorityFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceMemoryPriorityFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceMemoryPriorityFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceMemoryPriorityFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn memory_priority(mut self, memory_priority: bool) -> Self {
        self.inner.memory_priority = memory_priority.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceMemoryPriorityFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryPriorityAllocateInfoEXT.html>"]
pub struct MemoryPriorityAllocateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub priority: f32,
}
impl ::std::default::Default for MemoryPriorityAllocateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            priority: f32::default(),
        }
    }
}
unsafe impl TaggedStructure for MemoryPriorityAllocateInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_PRIORITY_ALLOCATE_INFO_EXT;
}
impl MemoryPriorityAllocateInfoEXT {
    pub fn builder<'a>() -> MemoryPriorityAllocateInfoEXTBuilder<'a> {
        MemoryPriorityAllocateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MemoryPriorityAllocateInfoEXTBuilder<'a> {
    inner: MemoryPriorityAllocateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsMemoryAllocateInfo for MemoryPriorityAllocateInfoEXTBuilder<'_> {}
unsafe impl ExtendsMemoryAllocateInfo for MemoryPriorityAllocateInfoEXT {}
impl<'a> ::std::ops::Deref for MemoryPriorityAllocateInfoEXTBuilder<'a> {
    type Target = MemoryPriorityAllocateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MemoryPriorityAllocateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MemoryPriorityAllocateInfoEXTBuilder<'a> {
    #[inline]
    pub fn priority(mut self, priority: f32) -> Self {
        self.inner.priority = priority;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MemoryPriorityAllocateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT.html>"]
pub struct PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pageable_device_local_memory: Bool32,
}
impl ::std::default::Default for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            pageable_device_local_memory: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT;
}
impl PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDevicePageableDeviceLocalMemoryFeaturesEXTBuilder<'a> {
        PhysicalDevicePageableDeviceLocalMemoryFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevicePageableDeviceLocalMemoryFeaturesEXTBuilder<'a> {
    inner: PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXTBuilder<'a> {
    type Target = PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevicePageableDeviceLocalMemoryFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevicePageableDeviceLocalMemoryFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn pageable_device_local_memory(mut self, pageable_device_local_memory: bool) -> Self {
        self.inner.pageable_device_local_memory = pageable_device_local_memory.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceBufferDeviceAddressFeatures.html>"]
pub struct PhysicalDeviceBufferDeviceAddressFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub buffer_device_address: Bool32,
    pub buffer_device_address_capture_replay: Bool32,
    pub buffer_device_address_multi_device: Bool32,
}
impl ::std::default::Default for PhysicalDeviceBufferDeviceAddressFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            buffer_device_address: Bool32::default(),
            buffer_device_address_capture_replay: Bool32::default(),
            buffer_device_address_multi_device: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceBufferDeviceAddressFeatures {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
}
impl PhysicalDeviceBufferDeviceAddressFeatures {
    pub fn builder<'a>() -> PhysicalDeviceBufferDeviceAddressFeaturesBuilder<'a> {
        PhysicalDeviceBufferDeviceAddressFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceBufferDeviceAddressFeaturesBuilder<'a> {
    inner: PhysicalDeviceBufferDeviceAddressFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceBufferDeviceAddressFeaturesBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceBufferDeviceAddressFeatures {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceBufferDeviceAddressFeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceBufferDeviceAddressFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDeviceBufferDeviceAddressFeaturesBuilder<'a> {
    type Target = PhysicalDeviceBufferDeviceAddressFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceBufferDeviceAddressFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceBufferDeviceAddressFeaturesBuilder<'a> {
    #[inline]
    pub fn buffer_device_address(mut self, buffer_device_address: bool) -> Self {
        self.inner.buffer_device_address = buffer_device_address.into();
        self
    }
    #[inline]
    pub fn buffer_device_address_capture_replay(
        mut self,
        buffer_device_address_capture_replay: bool,
    ) -> Self {
        self.inner.buffer_device_address_capture_replay =
            buffer_device_address_capture_replay.into();
        self
    }
    #[inline]
    pub fn buffer_device_address_multi_device(
        mut self,
        buffer_device_address_multi_device: bool,
    ) -> Self {
        self.inner.buffer_device_address_multi_device = buffer_device_address_multi_device.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceBufferDeviceAddressFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.html>"]
pub struct PhysicalDeviceBufferDeviceAddressFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub buffer_device_address: Bool32,
    pub buffer_device_address_capture_replay: Bool32,
    pub buffer_device_address_multi_device: Bool32,
}
impl ::std::default::Default for PhysicalDeviceBufferDeviceAddressFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            buffer_device_address: Bool32::default(),
            buffer_device_address_capture_replay: Bool32::default(),
            buffer_device_address_multi_device: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceBufferDeviceAddressFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
}
impl PhysicalDeviceBufferDeviceAddressFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceBufferDeviceAddressFeaturesEXTBuilder<'a> {
        PhysicalDeviceBufferDeviceAddressFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceBufferDeviceAddressFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceBufferDeviceAddressFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceBufferDeviceAddressFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceBufferDeviceAddressFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceBufferDeviceAddressFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceBufferDeviceAddressFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceBufferDeviceAddressFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceBufferDeviceAddressFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceBufferDeviceAddressFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceBufferDeviceAddressFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn buffer_device_address(mut self, buffer_device_address: bool) -> Self {
        self.inner.buffer_device_address = buffer_device_address.into();
        self
    }
    #[inline]
    pub fn buffer_device_address_capture_replay(
        mut self,
        buffer_device_address_capture_replay: bool,
    ) -> Self {
        self.inner.buffer_device_address_capture_replay =
            buffer_device_address_capture_replay.into();
        self
    }
    #[inline]
    pub fn buffer_device_address_multi_device(
        mut self,
        buffer_device_address_multi_device: bool,
    ) -> Self {
        self.inner.buffer_device_address_multi_device = buffer_device_address_multi_device.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceBufferDeviceAddressFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferDeviceAddressInfo.html>"]
pub struct BufferDeviceAddressInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub buffer: Buffer,
}
impl ::std::default::Default for BufferDeviceAddressInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            buffer: Buffer::default(),
        }
    }
}
unsafe impl TaggedStructure for BufferDeviceAddressInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_DEVICE_ADDRESS_INFO;
}
impl BufferDeviceAddressInfo {
    pub fn builder<'a>() -> BufferDeviceAddressInfoBuilder<'a> {
        BufferDeviceAddressInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BufferDeviceAddressInfoBuilder<'a> {
    inner: BufferDeviceAddressInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for BufferDeviceAddressInfoBuilder<'a> {
    type Target = BufferDeviceAddressInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BufferDeviceAddressInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BufferDeviceAddressInfoBuilder<'a> {
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BufferDeviceAddressInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferOpaqueCaptureAddressCreateInfo.html>"]
pub struct BufferOpaqueCaptureAddressCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub opaque_capture_address: u64,
}
impl ::std::default::Default for BufferOpaqueCaptureAddressCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            opaque_capture_address: u64::default(),
        }
    }
}
unsafe impl TaggedStructure for BufferOpaqueCaptureAddressCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO;
}
impl BufferOpaqueCaptureAddressCreateInfo {
    pub fn builder<'a>() -> BufferOpaqueCaptureAddressCreateInfoBuilder<'a> {
        BufferOpaqueCaptureAddressCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BufferOpaqueCaptureAddressCreateInfoBuilder<'a> {
    inner: BufferOpaqueCaptureAddressCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsBufferCreateInfo for BufferOpaqueCaptureAddressCreateInfoBuilder<'_> {}
unsafe impl ExtendsBufferCreateInfo for BufferOpaqueCaptureAddressCreateInfo {}
impl<'a> ::std::ops::Deref for BufferOpaqueCaptureAddressCreateInfoBuilder<'a> {
    type Target = BufferOpaqueCaptureAddressCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BufferOpaqueCaptureAddressCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BufferOpaqueCaptureAddressCreateInfoBuilder<'a> {
    #[inline]
    pub fn opaque_capture_address(mut self, opaque_capture_address: u64) -> Self {
        self.inner.opaque_capture_address = opaque_capture_address;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BufferOpaqueCaptureAddressCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferDeviceAddressCreateInfoEXT.html>"]
pub struct BufferDeviceAddressCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub device_address: DeviceAddress,
}
impl ::std::default::Default for BufferDeviceAddressCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            device_address: DeviceAddress::default(),
        }
    }
}
unsafe impl TaggedStructure for BufferDeviceAddressCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT;
}
impl BufferDeviceAddressCreateInfoEXT {
    pub fn builder<'a>() -> BufferDeviceAddressCreateInfoEXTBuilder<'a> {
        BufferDeviceAddressCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BufferDeviceAddressCreateInfoEXTBuilder<'a> {
    inner: BufferDeviceAddressCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsBufferCreateInfo for BufferDeviceAddressCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsBufferCreateInfo for BufferDeviceAddressCreateInfoEXT {}
impl<'a> ::std::ops::Deref for BufferDeviceAddressCreateInfoEXTBuilder<'a> {
    type Target = BufferDeviceAddressCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BufferDeviceAddressCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BufferDeviceAddressCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn device_address(mut self, device_address: DeviceAddress) -> Self {
        self.inner.device_address = device_address;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BufferDeviceAddressCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageViewImageFormatInfoEXT.html>"]
pub struct PhysicalDeviceImageViewImageFormatInfoEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_view_type: ImageViewType,
}
impl ::std::default::Default for PhysicalDeviceImageViewImageFormatInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            image_view_type: ImageViewType::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceImageViewImageFormatInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT;
}
impl PhysicalDeviceImageViewImageFormatInfoEXT {
    pub fn builder<'a>() -> PhysicalDeviceImageViewImageFormatInfoEXTBuilder<'a> {
        PhysicalDeviceImageViewImageFormatInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceImageViewImageFormatInfoEXTBuilder<'a> {
    inner: PhysicalDeviceImageViewImageFormatInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceImageFormatInfo2
    for PhysicalDeviceImageViewImageFormatInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceImageFormatInfo2 for PhysicalDeviceImageViewImageFormatInfoEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceImageViewImageFormatInfoEXTBuilder<'a> {
    type Target = PhysicalDeviceImageViewImageFormatInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceImageViewImageFormatInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceImageViewImageFormatInfoEXTBuilder<'a> {
    #[inline]
    pub fn image_view_type(mut self, image_view_type: ImageViewType) -> Self {
        self.inner.image_view_type = image_view_type;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceImageViewImageFormatInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFilterCubicImageViewImageFormatPropertiesEXT.html>"]
pub struct FilterCubicImageViewImageFormatPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub filter_cubic: Bool32,
    pub filter_cubic_minmax: Bool32,
}
impl ::std::default::Default for FilterCubicImageViewImageFormatPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            filter_cubic: Bool32::default(),
            filter_cubic_minmax: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for FilterCubicImageViewImageFormatPropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT;
}
impl FilterCubicImageViewImageFormatPropertiesEXT {
    pub fn builder<'a>() -> FilterCubicImageViewImageFormatPropertiesEXTBuilder<'a> {
        FilterCubicImageViewImageFormatPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct FilterCubicImageViewImageFormatPropertiesEXTBuilder<'a> {
    inner: FilterCubicImageViewImageFormatPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageFormatProperties2
    for FilterCubicImageViewImageFormatPropertiesEXTBuilder<'_>
{
}
unsafe impl ExtendsImageFormatProperties2 for FilterCubicImageViewImageFormatPropertiesEXT {}
impl<'a> ::std::ops::Deref for FilterCubicImageViewImageFormatPropertiesEXTBuilder<'a> {
    type Target = FilterCubicImageViewImageFormatPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for FilterCubicImageViewImageFormatPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> FilterCubicImageViewImageFormatPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn filter_cubic(mut self, filter_cubic: bool) -> Self {
        self.inner.filter_cubic = filter_cubic.into();
        self
    }
    #[inline]
    pub fn filter_cubic_minmax(mut self, filter_cubic_minmax: bool) -> Self {
        self.inner.filter_cubic_minmax = filter_cubic_minmax.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> FilterCubicImageViewImageFormatPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImagelessFramebufferFeatures.html>"]
pub struct PhysicalDeviceImagelessFramebufferFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub imageless_framebuffer: Bool32,
}
impl ::std::default::Default for PhysicalDeviceImagelessFramebufferFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            imageless_framebuffer: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceImagelessFramebufferFeatures {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
}
impl PhysicalDeviceImagelessFramebufferFeatures {
    pub fn builder<'a>() -> PhysicalDeviceImagelessFramebufferFeaturesBuilder<'a> {
        PhysicalDeviceImagelessFramebufferFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceImagelessFramebufferFeaturesBuilder<'a> {
    inner: PhysicalDeviceImagelessFramebufferFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceImagelessFramebufferFeaturesBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceImagelessFramebufferFeatures {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceImagelessFramebufferFeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceImagelessFramebufferFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDeviceImagelessFramebufferFeaturesBuilder<'a> {
    type Target = PhysicalDeviceImagelessFramebufferFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceImagelessFramebufferFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceImagelessFramebufferFeaturesBuilder<'a> {
    #[inline]
    pub fn imageless_framebuffer(mut self, imageless_framebuffer: bool) -> Self {
        self.inner.imageless_framebuffer = imageless_framebuffer.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceImagelessFramebufferFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferAttachmentsCreateInfo.html>"]
pub struct FramebufferAttachmentsCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub attachment_image_info_count: u32,
    pub p_attachment_image_infos: *const FramebufferAttachmentImageInfo,
}
impl ::std::default::Default for FramebufferAttachmentsCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            attachment_image_info_count: u32::default(),
            p_attachment_image_infos: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for FramebufferAttachmentsCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::FRAMEBUFFER_ATTACHMENTS_CREATE_INFO;
}
impl FramebufferAttachmentsCreateInfo {
    pub fn builder<'a>() -> FramebufferAttachmentsCreateInfoBuilder<'a> {
        FramebufferAttachmentsCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct FramebufferAttachmentsCreateInfoBuilder<'a> {
    inner: FramebufferAttachmentsCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsFramebufferCreateInfo for FramebufferAttachmentsCreateInfoBuilder<'_> {}
unsafe impl ExtendsFramebufferCreateInfo for FramebufferAttachmentsCreateInfo {}
impl<'a> ::std::ops::Deref for FramebufferAttachmentsCreateInfoBuilder<'a> {
    type Target = FramebufferAttachmentsCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for FramebufferAttachmentsCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> FramebufferAttachmentsCreateInfoBuilder<'a> {
    #[inline]
    pub fn attachment_image_infos(
        mut self,
        attachment_image_infos: &'a [FramebufferAttachmentImageInfo],
    ) -> Self {
        self.inner.attachment_image_info_count = attachment_image_infos.len() as _;
        self.inner.p_attachment_image_infos = attachment_image_infos.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> FramebufferAttachmentsCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferAttachmentImageInfo.html>"]
pub struct FramebufferAttachmentImageInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ImageCreateFlags,
    pub usage: ImageUsageFlags,
    pub width: u32,
    pub height: u32,
    pub layer_count: u32,
    pub view_format_count: u32,
    pub p_view_formats: *const Format,
}
impl ::std::default::Default for FramebufferAttachmentImageInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: ImageCreateFlags::default(),
            usage: ImageUsageFlags::default(),
            width: u32::default(),
            height: u32::default(),
            layer_count: u32::default(),
            view_format_count: u32::default(),
            p_view_formats: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for FramebufferAttachmentImageInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::FRAMEBUFFER_ATTACHMENT_IMAGE_INFO;
}
impl FramebufferAttachmentImageInfo {
    pub fn builder<'a>() -> FramebufferAttachmentImageInfoBuilder<'a> {
        FramebufferAttachmentImageInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct FramebufferAttachmentImageInfoBuilder<'a> {
    inner: FramebufferAttachmentImageInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for FramebufferAttachmentImageInfoBuilder<'a> {
    type Target = FramebufferAttachmentImageInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for FramebufferAttachmentImageInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> FramebufferAttachmentImageInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: ImageCreateFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn usage(mut self, usage: ImageUsageFlags) -> Self {
        self.inner.usage = usage;
        self
    }
    #[inline]
    pub fn width(mut self, width: u32) -> Self {
        self.inner.width = width;
        self
    }
    #[inline]
    pub fn height(mut self, height: u32) -> Self {
        self.inner.height = height;
        self
    }
    #[inline]
    pub fn layer_count(mut self, layer_count: u32) -> Self {
        self.inner.layer_count = layer_count;
        self
    }
    #[inline]
    pub fn view_formats(mut self, view_formats: &'a [Format]) -> Self {
        self.inner.view_format_count = view_formats.len() as _;
        self.inner.p_view_formats = view_formats.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> FramebufferAttachmentImageInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassAttachmentBeginInfo.html>"]
pub struct RenderPassAttachmentBeginInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub attachment_count: u32,
    pub p_attachments: *const ImageView,
}
impl ::std::default::Default for RenderPassAttachmentBeginInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            attachment_count: u32::default(),
            p_attachments: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for RenderPassAttachmentBeginInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::RENDER_PASS_ATTACHMENT_BEGIN_INFO;
}
impl RenderPassAttachmentBeginInfo {
    pub fn builder<'a>() -> RenderPassAttachmentBeginInfoBuilder<'a> {
        RenderPassAttachmentBeginInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RenderPassAttachmentBeginInfoBuilder<'a> {
    inner: RenderPassAttachmentBeginInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsRenderPassBeginInfo for RenderPassAttachmentBeginInfoBuilder<'_> {}
unsafe impl ExtendsRenderPassBeginInfo for RenderPassAttachmentBeginInfo {}
impl<'a> ::std::ops::Deref for RenderPassAttachmentBeginInfoBuilder<'a> {
    type Target = RenderPassAttachmentBeginInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RenderPassAttachmentBeginInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RenderPassAttachmentBeginInfoBuilder<'a> {
    #[inline]
    pub fn attachments(mut self, attachments: &'a [ImageView]) -> Self {
        self.inner.attachment_count = attachments.len() as _;
        self.inner.p_attachments = attachments.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RenderPassAttachmentBeginInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTextureCompressionASTCHDRFeatures.html>"]
pub struct PhysicalDeviceTextureCompressionASTCHDRFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub texture_compression_astc_hdr: Bool32,
}
impl ::std::default::Default for PhysicalDeviceTextureCompressionASTCHDRFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            texture_compression_astc_hdr: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceTextureCompressionASTCHDRFeatures {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES;
}
impl PhysicalDeviceTextureCompressionASTCHDRFeatures {
    pub fn builder<'a>() -> PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder<'a> {
        PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder<'a> {
    inner: PhysicalDeviceTextureCompressionASTCHDRFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceTextureCompressionASTCHDRFeatures {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceTextureCompressionASTCHDRFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder<'a> {
    type Target = PhysicalDeviceTextureCompressionASTCHDRFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceTextureCompressionASTCHDRFeaturesBuilder<'a> {
    #[inline]
    pub fn texture_compression_astc_hdr(mut self, texture_compression_astc_hdr: bool) -> Self {
        self.inner.texture_compression_astc_hdr = texture_compression_astc_hdr.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceTextureCompressionASTCHDRFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCooperativeMatrixFeaturesNV.html>"]
pub struct PhysicalDeviceCooperativeMatrixFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub cooperative_matrix: Bool32,
    pub cooperative_matrix_robust_buffer_access: Bool32,
}
impl ::std::default::Default for PhysicalDeviceCooperativeMatrixFeaturesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            cooperative_matrix: Bool32::default(),
            cooperative_matrix_robust_buffer_access: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceCooperativeMatrixFeaturesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV;
}
impl PhysicalDeviceCooperativeMatrixFeaturesNV {
    pub fn builder<'a>() -> PhysicalDeviceCooperativeMatrixFeaturesNVBuilder<'a> {
        PhysicalDeviceCooperativeMatrixFeaturesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceCooperativeMatrixFeaturesNVBuilder<'a> {
    inner: PhysicalDeviceCooperativeMatrixFeaturesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceCooperativeMatrixFeaturesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceCooperativeMatrixFeaturesNV {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCooperativeMatrixFeaturesNVBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCooperativeMatrixFeaturesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceCooperativeMatrixFeaturesNVBuilder<'a> {
    type Target = PhysicalDeviceCooperativeMatrixFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceCooperativeMatrixFeaturesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceCooperativeMatrixFeaturesNVBuilder<'a> {
    #[inline]
    pub fn cooperative_matrix(mut self, cooperative_matrix: bool) -> Self {
        self.inner.cooperative_matrix = cooperative_matrix.into();
        self
    }
    #[inline]
    pub fn cooperative_matrix_robust_buffer_access(
        mut self,
        cooperative_matrix_robust_buffer_access: bool,
    ) -> Self {
        self.inner.cooperative_matrix_robust_buffer_access =
            cooperative_matrix_robust_buffer_access.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceCooperativeMatrixFeaturesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCooperativeMatrixPropertiesNV.html>"]
pub struct PhysicalDeviceCooperativeMatrixPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub cooperative_matrix_supported_stages: ShaderStageFlags,
}
impl ::std::default::Default for PhysicalDeviceCooperativeMatrixPropertiesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            cooperative_matrix_supported_stages: ShaderStageFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceCooperativeMatrixPropertiesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV;
}
impl PhysicalDeviceCooperativeMatrixPropertiesNV {
    pub fn builder<'a>() -> PhysicalDeviceCooperativeMatrixPropertiesNVBuilder<'a> {
        PhysicalDeviceCooperativeMatrixPropertiesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceCooperativeMatrixPropertiesNVBuilder<'a> {
    inner: PhysicalDeviceCooperativeMatrixPropertiesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceCooperativeMatrixPropertiesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceCooperativeMatrixPropertiesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceCooperativeMatrixPropertiesNVBuilder<'a> {
    type Target = PhysicalDeviceCooperativeMatrixPropertiesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceCooperativeMatrixPropertiesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceCooperativeMatrixPropertiesNVBuilder<'a> {
    #[inline]
    pub fn cooperative_matrix_supported_stages(
        mut self,
        cooperative_matrix_supported_stages: ShaderStageFlags,
    ) -> Self {
        self.inner.cooperative_matrix_supported_stages = cooperative_matrix_supported_stages;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceCooperativeMatrixPropertiesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCooperativeMatrixPropertiesNV.html>"]
pub struct CooperativeMatrixPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub m_size: u32,
    pub n_size: u32,
    pub k_size: u32,
    pub a_type: ComponentTypeNV,
    pub b_type: ComponentTypeNV,
    pub c_type: ComponentTypeNV,
    pub d_type: ComponentTypeNV,
    pub scope: ScopeNV,
}
impl ::std::default::Default for CooperativeMatrixPropertiesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            m_size: u32::default(),
            n_size: u32::default(),
            k_size: u32::default(),
            a_type: ComponentTypeNV::default(),
            b_type: ComponentTypeNV::default(),
            c_type: ComponentTypeNV::default(),
            d_type: ComponentTypeNV::default(),
            scope: ScopeNV::default(),
        }
    }
}
unsafe impl TaggedStructure for CooperativeMatrixPropertiesNV {
    const STRUCTURE_TYPE: StructureType = StructureType::COOPERATIVE_MATRIX_PROPERTIES_NV;
}
impl CooperativeMatrixPropertiesNV {
    pub fn builder<'a>() -> CooperativeMatrixPropertiesNVBuilder<'a> {
        CooperativeMatrixPropertiesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CooperativeMatrixPropertiesNVBuilder<'a> {
    inner: CooperativeMatrixPropertiesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CooperativeMatrixPropertiesNVBuilder<'a> {
    type Target = CooperativeMatrixPropertiesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CooperativeMatrixPropertiesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CooperativeMatrixPropertiesNVBuilder<'a> {
    #[inline]
    pub fn m_size(mut self, m_size: u32) -> Self {
        self.inner.m_size = m_size;
        self
    }
    #[inline]
    pub fn n_size(mut self, n_size: u32) -> Self {
        self.inner.n_size = n_size;
        self
    }
    #[inline]
    pub fn k_size(mut self, k_size: u32) -> Self {
        self.inner.k_size = k_size;
        self
    }
    #[inline]
    pub fn a_type(mut self, a_type: ComponentTypeNV) -> Self {
        self.inner.a_type = a_type;
        self
    }
    #[inline]
    pub fn b_type(mut self, b_type: ComponentTypeNV) -> Self {
        self.inner.b_type = b_type;
        self
    }
    #[inline]
    pub fn c_type(mut self, c_type: ComponentTypeNV) -> Self {
        self.inner.c_type = c_type;
        self
    }
    #[inline]
    pub fn d_type(mut self, d_type: ComponentTypeNV) -> Self {
        self.inner.d_type = d_type;
        self
    }
    #[inline]
    pub fn scope(mut self, scope: ScopeNV) -> Self {
        self.inner.scope = scope;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CooperativeMatrixPropertiesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.html>"]
pub struct PhysicalDeviceYcbcrImageArraysFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ycbcr_image_arrays: Bool32,
}
impl ::std::default::Default for PhysicalDeviceYcbcrImageArraysFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            ycbcr_image_arrays: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceYcbcrImageArraysFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT;
}
impl PhysicalDeviceYcbcrImageArraysFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceYcbcrImageArraysFeaturesEXTBuilder<'a> {
        PhysicalDeviceYcbcrImageArraysFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceYcbcrImageArraysFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceYcbcrImageArraysFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceYcbcrImageArraysFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceYcbcrImageArraysFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceYcbcrImageArraysFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceYcbcrImageArraysFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceYcbcrImageArraysFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceYcbcrImageArraysFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceYcbcrImageArraysFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceYcbcrImageArraysFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn ycbcr_image_arrays(mut self, ycbcr_image_arrays: bool) -> Self {
        self.inner.ycbcr_image_arrays = ycbcr_image_arrays.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceYcbcrImageArraysFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewHandleInfoNVX.html>"]
pub struct ImageViewHandleInfoNVX {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image_view: ImageView,
    pub descriptor_type: DescriptorType,
    pub sampler: Sampler,
}
impl ::std::default::Default for ImageViewHandleInfoNVX {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image_view: ImageView::default(),
            descriptor_type: DescriptorType::default(),
            sampler: Sampler::default(),
        }
    }
}
unsafe impl TaggedStructure for ImageViewHandleInfoNVX {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_VIEW_HANDLE_INFO_NVX;
}
impl ImageViewHandleInfoNVX {
    pub fn builder<'a>() -> ImageViewHandleInfoNVXBuilder<'a> {
        ImageViewHandleInfoNVXBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageViewHandleInfoNVXBuilder<'a> {
    inner: ImageViewHandleInfoNVX,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ImageViewHandleInfoNVXBuilder<'a> {
    type Target = ImageViewHandleInfoNVX;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageViewHandleInfoNVXBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageViewHandleInfoNVXBuilder<'a> {
    #[inline]
    pub fn image_view(mut self, image_view: ImageView) -> Self {
        self.inner.image_view = image_view;
        self
    }
    #[inline]
    pub fn descriptor_type(mut self, descriptor_type: DescriptorType) -> Self {
        self.inner.descriptor_type = descriptor_type;
        self
    }
    #[inline]
    pub fn sampler(mut self, sampler: Sampler) -> Self {
        self.inner.sampler = sampler;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageViewHandleInfoNVX {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewAddressPropertiesNVX.html>"]
pub struct ImageViewAddressPropertiesNVX {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_address: DeviceAddress,
    pub size: DeviceSize,
}
impl ::std::default::Default for ImageViewAddressPropertiesNVX {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            device_address: DeviceAddress::default(),
            size: DeviceSize::default(),
        }
    }
}
unsafe impl TaggedStructure for ImageViewAddressPropertiesNVX {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_VIEW_ADDRESS_PROPERTIES_NVX;
}
impl ImageViewAddressPropertiesNVX {
    pub fn builder<'a>() -> ImageViewAddressPropertiesNVXBuilder<'a> {
        ImageViewAddressPropertiesNVXBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageViewAddressPropertiesNVXBuilder<'a> {
    inner: ImageViewAddressPropertiesNVX,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ImageViewAddressPropertiesNVXBuilder<'a> {
    type Target = ImageViewAddressPropertiesNVX;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageViewAddressPropertiesNVXBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageViewAddressPropertiesNVXBuilder<'a> {
    #[inline]
    pub fn device_address(mut self, device_address: DeviceAddress) -> Self {
        self.inner.device_address = device_address;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageViewAddressPropertiesNVX {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentFrameTokenGGP.html>"]
pub struct PresentFrameTokenGGP {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub frame_token: GgpFrameToken,
}
impl ::std::default::Default for PresentFrameTokenGGP {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            frame_token: GgpFrameToken::default(),
        }
    }
}
unsafe impl TaggedStructure for PresentFrameTokenGGP {
    const STRUCTURE_TYPE: StructureType = StructureType::PRESENT_FRAME_TOKEN_GGP;
}
impl PresentFrameTokenGGP {
    pub fn builder<'a>() -> PresentFrameTokenGGPBuilder<'a> {
        PresentFrameTokenGGPBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PresentFrameTokenGGPBuilder<'a> {
    inner: PresentFrameTokenGGP,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPresentInfoKHR for PresentFrameTokenGGPBuilder<'_> {}
unsafe impl ExtendsPresentInfoKHR for PresentFrameTokenGGP {}
impl<'a> ::std::ops::Deref for PresentFrameTokenGGPBuilder<'a> {
    type Target = PresentFrameTokenGGP;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PresentFrameTokenGGPBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PresentFrameTokenGGPBuilder<'a> {
    #[inline]
    pub fn frame_token(mut self, frame_token: GgpFrameToken) -> Self {
        self.inner.frame_token = frame_token;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PresentFrameTokenGGP {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreationFeedback.html>"]
pub struct PipelineCreationFeedback {
    pub flags: PipelineCreationFeedbackFlags,
    pub duration: u64,
}
impl PipelineCreationFeedback {
    pub fn builder<'a>() -> PipelineCreationFeedbackBuilder<'a> {
        PipelineCreationFeedbackBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineCreationFeedbackBuilder<'a> {
    inner: PipelineCreationFeedback,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PipelineCreationFeedbackBuilder<'a> {
    type Target = PipelineCreationFeedback;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineCreationFeedbackBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineCreationFeedbackBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineCreationFeedbackFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn duration(mut self, duration: u64) -> Self {
        self.inner.duration = duration;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineCreationFeedback {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreationFeedbackCreateInfo.html>"]
pub struct PipelineCreationFeedbackCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_pipeline_creation_feedback: *mut PipelineCreationFeedback,
    pub pipeline_stage_creation_feedback_count: u32,
    pub p_pipeline_stage_creation_feedbacks: *mut PipelineCreationFeedback,
}
impl ::std::default::Default for PipelineCreationFeedbackCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_pipeline_creation_feedback: ::std::ptr::null_mut(),
            pipeline_stage_creation_feedback_count: u32::default(),
            p_pipeline_stage_creation_feedbacks: ::std::ptr::null_mut(),
        }
    }
}
unsafe impl TaggedStructure for PipelineCreationFeedbackCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
}
impl PipelineCreationFeedbackCreateInfo {
    pub fn builder<'a>() -> PipelineCreationFeedbackCreateInfoBuilder<'a> {
        PipelineCreationFeedbackCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineCreationFeedbackCreateInfoBuilder<'a> {
    inner: PipelineCreationFeedbackCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsGraphicsPipelineCreateInfo for PipelineCreationFeedbackCreateInfoBuilder<'_> {}
unsafe impl ExtendsGraphicsPipelineCreateInfo for PipelineCreationFeedbackCreateInfo {}
unsafe impl ExtendsComputePipelineCreateInfo for PipelineCreationFeedbackCreateInfoBuilder<'_> {}
unsafe impl ExtendsComputePipelineCreateInfo for PipelineCreationFeedbackCreateInfo {}
unsafe impl ExtendsRayTracingPipelineCreateInfoNV
    for PipelineCreationFeedbackCreateInfoBuilder<'_>
{
}
unsafe impl ExtendsRayTracingPipelineCreateInfoNV for PipelineCreationFeedbackCreateInfo {}
unsafe impl ExtendsRayTracingPipelineCreateInfoKHR
    for PipelineCreationFeedbackCreateInfoBuilder<'_>
{
}
unsafe impl ExtendsRayTracingPipelineCreateInfoKHR for PipelineCreationFeedbackCreateInfo {}
impl<'a> ::std::ops::Deref for PipelineCreationFeedbackCreateInfoBuilder<'a> {
    type Target = PipelineCreationFeedbackCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineCreationFeedbackCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineCreationFeedbackCreateInfoBuilder<'a> {
    #[inline]
    pub fn pipeline_creation_feedback(
        mut self,
        pipeline_creation_feedback: &'a mut PipelineCreationFeedback,
    ) -> Self {
        self.inner.p_pipeline_creation_feedback = pipeline_creation_feedback;
        self
    }
    #[inline]
    pub fn pipeline_stage_creation_feedbacks(
        mut self,
        pipeline_stage_creation_feedbacks: &'a mut [PipelineCreationFeedback],
    ) -> Self {
        self.inner.pipeline_stage_creation_feedback_count =
            pipeline_stage_creation_feedbacks.len() as _;
        self.inner.p_pipeline_stage_creation_feedbacks =
            pipeline_stage_creation_feedbacks.as_mut_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineCreationFeedbackCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceFullScreenExclusiveInfoEXT.html>"]
pub struct SurfaceFullScreenExclusiveInfoEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub full_screen_exclusive: FullScreenExclusiveEXT,
}
impl ::std::default::Default for SurfaceFullScreenExclusiveInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            full_screen_exclusive: FullScreenExclusiveEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for SurfaceFullScreenExclusiveInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT;
}
impl SurfaceFullScreenExclusiveInfoEXT {
    pub fn builder<'a>() -> SurfaceFullScreenExclusiveInfoEXTBuilder<'a> {
        SurfaceFullScreenExclusiveInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SurfaceFullScreenExclusiveInfoEXTBuilder<'a> {
    inner: SurfaceFullScreenExclusiveInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceSurfaceInfo2KHR for SurfaceFullScreenExclusiveInfoEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceSurfaceInfo2KHR for SurfaceFullScreenExclusiveInfoEXT {}
unsafe impl ExtendsSwapchainCreateInfoKHR for SurfaceFullScreenExclusiveInfoEXTBuilder<'_> {}
unsafe impl ExtendsSwapchainCreateInfoKHR for SurfaceFullScreenExclusiveInfoEXT {}
impl<'a> ::std::ops::Deref for SurfaceFullScreenExclusiveInfoEXTBuilder<'a> {
    type Target = SurfaceFullScreenExclusiveInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SurfaceFullScreenExclusiveInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SurfaceFullScreenExclusiveInfoEXTBuilder<'a> {
    #[inline]
    pub fn full_screen_exclusive(mut self, full_screen_exclusive: FullScreenExclusiveEXT) -> Self {
        self.inner.full_screen_exclusive = full_screen_exclusive;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SurfaceFullScreenExclusiveInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceFullScreenExclusiveWin32InfoEXT.html>"]
pub struct SurfaceFullScreenExclusiveWin32InfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub hmonitor: HMONITOR,
}
impl ::std::default::Default for SurfaceFullScreenExclusiveWin32InfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            hmonitor: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for SurfaceFullScreenExclusiveWin32InfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT;
}
impl SurfaceFullScreenExclusiveWin32InfoEXT {
    pub fn builder<'a>() -> SurfaceFullScreenExclusiveWin32InfoEXTBuilder<'a> {
        SurfaceFullScreenExclusiveWin32InfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SurfaceFullScreenExclusiveWin32InfoEXTBuilder<'a> {
    inner: SurfaceFullScreenExclusiveWin32InfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceSurfaceInfo2KHR
    for SurfaceFullScreenExclusiveWin32InfoEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceSurfaceInfo2KHR for SurfaceFullScreenExclusiveWin32InfoEXT {}
unsafe impl ExtendsSwapchainCreateInfoKHR for SurfaceFullScreenExclusiveWin32InfoEXTBuilder<'_> {}
unsafe impl ExtendsSwapchainCreateInfoKHR for SurfaceFullScreenExclusiveWin32InfoEXT {}
impl<'a> ::std::ops::Deref for SurfaceFullScreenExclusiveWin32InfoEXTBuilder<'a> {
    type Target = SurfaceFullScreenExclusiveWin32InfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SurfaceFullScreenExclusiveWin32InfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SurfaceFullScreenExclusiveWin32InfoEXTBuilder<'a> {
    #[inline]
    pub fn hmonitor(mut self, hmonitor: HMONITOR) -> Self {
        self.inner.hmonitor = hmonitor;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SurfaceFullScreenExclusiveWin32InfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilitiesFullScreenExclusiveEXT.html>"]
pub struct SurfaceCapabilitiesFullScreenExclusiveEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub full_screen_exclusive_supported: Bool32,
}
impl ::std::default::Default for SurfaceCapabilitiesFullScreenExclusiveEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            full_screen_exclusive_supported: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for SurfaceCapabilitiesFullScreenExclusiveEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT;
}
impl SurfaceCapabilitiesFullScreenExclusiveEXT {
    pub fn builder<'a>() -> SurfaceCapabilitiesFullScreenExclusiveEXTBuilder<'a> {
        SurfaceCapabilitiesFullScreenExclusiveEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SurfaceCapabilitiesFullScreenExclusiveEXTBuilder<'a> {
    inner: SurfaceCapabilitiesFullScreenExclusiveEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSurfaceCapabilities2KHR
    for SurfaceCapabilitiesFullScreenExclusiveEXTBuilder<'_>
{
}
unsafe impl ExtendsSurfaceCapabilities2KHR for SurfaceCapabilitiesFullScreenExclusiveEXT {}
impl<'a> ::std::ops::Deref for SurfaceCapabilitiesFullScreenExclusiveEXTBuilder<'a> {
    type Target = SurfaceCapabilitiesFullScreenExclusiveEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SurfaceCapabilitiesFullScreenExclusiveEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SurfaceCapabilitiesFullScreenExclusiveEXTBuilder<'a> {
    #[inline]
    pub fn full_screen_exclusive_supported(
        mut self,
        full_screen_exclusive_supported: bool,
    ) -> Self {
        self.inner.full_screen_exclusive_supported = full_screen_exclusive_supported.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SurfaceCapabilitiesFullScreenExclusiveEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePresentBarrierFeaturesNV.html>"]
pub struct PhysicalDevicePresentBarrierFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub present_barrier: Bool32,
}
impl ::std::default::Default for PhysicalDevicePresentBarrierFeaturesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            present_barrier: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevicePresentBarrierFeaturesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV;
}
impl PhysicalDevicePresentBarrierFeaturesNV {
    pub fn builder<'a>() -> PhysicalDevicePresentBarrierFeaturesNVBuilder<'a> {
        PhysicalDevicePresentBarrierFeaturesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevicePresentBarrierFeaturesNVBuilder<'a> {
    inner: PhysicalDevicePresentBarrierFeaturesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePresentBarrierFeaturesNVBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePresentBarrierFeaturesNV {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePresentBarrierFeaturesNVBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePresentBarrierFeaturesNV {}
impl<'a> ::std::ops::Deref for PhysicalDevicePresentBarrierFeaturesNVBuilder<'a> {
    type Target = PhysicalDevicePresentBarrierFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevicePresentBarrierFeaturesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevicePresentBarrierFeaturesNVBuilder<'a> {
    #[inline]
    pub fn present_barrier(mut self, present_barrier: bool) -> Self {
        self.inner.present_barrier = present_barrier.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevicePresentBarrierFeaturesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilitiesPresentBarrierNV.html>"]
pub struct SurfaceCapabilitiesPresentBarrierNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub present_barrier_supported: Bool32,
}
impl ::std::default::Default for SurfaceCapabilitiesPresentBarrierNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            present_barrier_supported: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for SurfaceCapabilitiesPresentBarrierNV {
    const STRUCTURE_TYPE: StructureType = StructureType::SURFACE_CAPABILITIES_PRESENT_BARRIER_NV;
}
impl SurfaceCapabilitiesPresentBarrierNV {
    pub fn builder<'a>() -> SurfaceCapabilitiesPresentBarrierNVBuilder<'a> {
        SurfaceCapabilitiesPresentBarrierNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SurfaceCapabilitiesPresentBarrierNVBuilder<'a> {
    inner: SurfaceCapabilitiesPresentBarrierNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSurfaceCapabilities2KHR for SurfaceCapabilitiesPresentBarrierNVBuilder<'_> {}
unsafe impl ExtendsSurfaceCapabilities2KHR for SurfaceCapabilitiesPresentBarrierNV {}
impl<'a> ::std::ops::Deref for SurfaceCapabilitiesPresentBarrierNVBuilder<'a> {
    type Target = SurfaceCapabilitiesPresentBarrierNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SurfaceCapabilitiesPresentBarrierNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SurfaceCapabilitiesPresentBarrierNVBuilder<'a> {
    #[inline]
    pub fn present_barrier_supported(mut self, present_barrier_supported: bool) -> Self {
        self.inner.present_barrier_supported = present_barrier_supported.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SurfaceCapabilitiesPresentBarrierNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainPresentBarrierCreateInfoNV.html>"]
pub struct SwapchainPresentBarrierCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub present_barrier_enable: Bool32,
}
impl ::std::default::Default for SwapchainPresentBarrierCreateInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            present_barrier_enable: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for SwapchainPresentBarrierCreateInfoNV {
    const STRUCTURE_TYPE: StructureType = StructureType::SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV;
}
impl SwapchainPresentBarrierCreateInfoNV {
    pub fn builder<'a>() -> SwapchainPresentBarrierCreateInfoNVBuilder<'a> {
        SwapchainPresentBarrierCreateInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SwapchainPresentBarrierCreateInfoNVBuilder<'a> {
    inner: SwapchainPresentBarrierCreateInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSwapchainCreateInfoKHR for SwapchainPresentBarrierCreateInfoNVBuilder<'_> {}
unsafe impl ExtendsSwapchainCreateInfoKHR for SwapchainPresentBarrierCreateInfoNV {}
impl<'a> ::std::ops::Deref for SwapchainPresentBarrierCreateInfoNVBuilder<'a> {
    type Target = SwapchainPresentBarrierCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SwapchainPresentBarrierCreateInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SwapchainPresentBarrierCreateInfoNVBuilder<'a> {
    #[inline]
    pub fn present_barrier_enable(mut self, present_barrier_enable: bool) -> Self {
        self.inner.present_barrier_enable = present_barrier_enable.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SwapchainPresentBarrierCreateInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePerformanceQueryFeaturesKHR.html>"]
pub struct PhysicalDevicePerformanceQueryFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub performance_counter_query_pools: Bool32,
    pub performance_counter_multiple_query_pools: Bool32,
}
impl ::std::default::Default for PhysicalDevicePerformanceQueryFeaturesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            performance_counter_query_pools: Bool32::default(),
            performance_counter_multiple_query_pools: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevicePerformanceQueryFeaturesKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR;
}
impl PhysicalDevicePerformanceQueryFeaturesKHR {
    pub fn builder<'a>() -> PhysicalDevicePerformanceQueryFeaturesKHRBuilder<'a> {
        PhysicalDevicePerformanceQueryFeaturesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevicePerformanceQueryFeaturesKHRBuilder<'a> {
    inner: PhysicalDevicePerformanceQueryFeaturesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDevicePerformanceQueryFeaturesKHRBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePerformanceQueryFeaturesKHR {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePerformanceQueryFeaturesKHRBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePerformanceQueryFeaturesKHR {}
impl<'a> ::std::ops::Deref for PhysicalDevicePerformanceQueryFeaturesKHRBuilder<'a> {
    type Target = PhysicalDevicePerformanceQueryFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevicePerformanceQueryFeaturesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevicePerformanceQueryFeaturesKHRBuilder<'a> {
    #[inline]
    pub fn performance_counter_query_pools(
        mut self,
        performance_counter_query_pools: bool,
    ) -> Self {
        self.inner.performance_counter_query_pools = performance_counter_query_pools.into();
        self
    }
    #[inline]
    pub fn performance_counter_multiple_query_pools(
        mut self,
        performance_counter_multiple_query_pools: bool,
    ) -> Self {
        self.inner.performance_counter_multiple_query_pools =
            performance_counter_multiple_query_pools.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevicePerformanceQueryFeaturesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePerformanceQueryPropertiesKHR.html>"]
pub struct PhysicalDevicePerformanceQueryPropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub allow_command_buffer_query_copies: Bool32,
}
impl ::std::default::Default for PhysicalDevicePerformanceQueryPropertiesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            allow_command_buffer_query_copies: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevicePerformanceQueryPropertiesKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR;
}
impl PhysicalDevicePerformanceQueryPropertiesKHR {
    pub fn builder<'a>() -> PhysicalDevicePerformanceQueryPropertiesKHRBuilder<'a> {
        PhysicalDevicePerformanceQueryPropertiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevicePerformanceQueryPropertiesKHRBuilder<'a> {
    inner: PhysicalDevicePerformanceQueryPropertiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDevicePerformanceQueryPropertiesKHRBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDevicePerformanceQueryPropertiesKHR {}
impl<'a> ::std::ops::Deref for PhysicalDevicePerformanceQueryPropertiesKHRBuilder<'a> {
    type Target = PhysicalDevicePerformanceQueryPropertiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevicePerformanceQueryPropertiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevicePerformanceQueryPropertiesKHRBuilder<'a> {
    #[inline]
    pub fn allow_command_buffer_query_copies(
        mut self,
        allow_command_buffer_query_copies: bool,
    ) -> Self {
        self.inner.allow_command_buffer_query_copies = allow_command_buffer_query_copies.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevicePerformanceQueryPropertiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceCounterKHR.html>"]
pub struct PerformanceCounterKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub unit: PerformanceCounterUnitKHR,
    pub scope: PerformanceCounterScopeKHR,
    pub storage: PerformanceCounterStorageKHR,
    pub uuid: [u8; UUID_SIZE],
}
impl ::std::default::Default for PerformanceCounterKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            unit: PerformanceCounterUnitKHR::default(),
            scope: PerformanceCounterScopeKHR::default(),
            storage: PerformanceCounterStorageKHR::default(),
            uuid: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for PerformanceCounterKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::PERFORMANCE_COUNTER_KHR;
}
impl PerformanceCounterKHR {
    pub fn builder<'a>() -> PerformanceCounterKHRBuilder<'a> {
        PerformanceCounterKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PerformanceCounterKHRBuilder<'a> {
    inner: PerformanceCounterKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PerformanceCounterKHRBuilder<'a> {
    type Target = PerformanceCounterKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PerformanceCounterKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PerformanceCounterKHRBuilder<'a> {
    #[inline]
    pub fn unit(mut self, unit: PerformanceCounterUnitKHR) -> Self {
        self.inner.unit = unit;
        self
    }
    #[inline]
    pub fn scope(mut self, scope: PerformanceCounterScopeKHR) -> Self {
        self.inner.scope = scope;
        self
    }
    #[inline]
    pub fn storage(mut self, storage: PerformanceCounterStorageKHR) -> Self {
        self.inner.storage = storage;
        self
    }
    #[inline]
    pub fn uuid(mut self, uuid: [u8; UUID_SIZE]) -> Self {
        self.inner.uuid = uuid;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PerformanceCounterKHR {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceCounterDescriptionKHR.html>"]
pub struct PerformanceCounterDescriptionKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub flags: PerformanceCounterDescriptionFlagsKHR,
    pub name: [c_char; MAX_DESCRIPTION_SIZE],
    pub category: [c_char; MAX_DESCRIPTION_SIZE],
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
}
#[cfg(feature = "debug")]
impl fmt::Debug for PerformanceCounterDescriptionKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PerformanceCounterDescriptionKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field("name", &unsafe {
                ::std::ffi::CStr::from_ptr(self.name.as_ptr())
            })
            .field("category", &unsafe {
                ::std::ffi::CStr::from_ptr(self.category.as_ptr())
            })
            .field("description", &unsafe {
                ::std::ffi::CStr::from_ptr(self.description.as_ptr())
            })
            .finish()
    }
}
impl ::std::default::Default for PerformanceCounterDescriptionKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            flags: PerformanceCounterDescriptionFlagsKHR::default(),
            name: unsafe { ::std::mem::zeroed() },
            category: unsafe { ::std::mem::zeroed() },
            description: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for PerformanceCounterDescriptionKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::PERFORMANCE_COUNTER_DESCRIPTION_KHR;
}
impl PerformanceCounterDescriptionKHR {
    pub fn builder<'a>() -> PerformanceCounterDescriptionKHRBuilder<'a> {
        PerformanceCounterDescriptionKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PerformanceCounterDescriptionKHRBuilder<'a> {
    inner: PerformanceCounterDescriptionKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PerformanceCounterDescriptionKHRBuilder<'a> {
    type Target = PerformanceCounterDescriptionKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PerformanceCounterDescriptionKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PerformanceCounterDescriptionKHRBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PerformanceCounterDescriptionFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn name(mut self, name: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.inner.name = name;
        self
    }
    #[inline]
    pub fn category(mut self, category: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.inner.category = category;
        self
    }
    #[inline]
    pub fn description(mut self, description: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.inner.description = description;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PerformanceCounterDescriptionKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPoolPerformanceCreateInfoKHR.html>"]
pub struct QueryPoolPerformanceCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub queue_family_index: u32,
    pub counter_index_count: u32,
    pub p_counter_indices: *const u32,
}
impl ::std::default::Default for QueryPoolPerformanceCreateInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            queue_family_index: u32::default(),
            counter_index_count: u32::default(),
            p_counter_indices: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for QueryPoolPerformanceCreateInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR;
}
impl QueryPoolPerformanceCreateInfoKHR {
    pub fn builder<'a>() -> QueryPoolPerformanceCreateInfoKHRBuilder<'a> {
        QueryPoolPerformanceCreateInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct QueryPoolPerformanceCreateInfoKHRBuilder<'a> {
    inner: QueryPoolPerformanceCreateInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsQueryPoolCreateInfo for QueryPoolPerformanceCreateInfoKHRBuilder<'_> {}
unsafe impl ExtendsQueryPoolCreateInfo for QueryPoolPerformanceCreateInfoKHR {}
impl<'a> ::std::ops::Deref for QueryPoolPerformanceCreateInfoKHRBuilder<'a> {
    type Target = QueryPoolPerformanceCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for QueryPoolPerformanceCreateInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> QueryPoolPerformanceCreateInfoKHRBuilder<'a> {
    #[inline]
    pub fn queue_family_index(mut self, queue_family_index: u32) -> Self {
        self.inner.queue_family_index = queue_family_index;
        self
    }
    #[inline]
    pub fn counter_indices(mut self, counter_indices: &'a [u32]) -> Self {
        self.inner.counter_index_count = counter_indices.len() as _;
        self.inner.p_counter_indices = counter_indices.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> QueryPoolPerformanceCreateInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceCounterResultKHR.html>"]
pub union PerformanceCounterResultKHR {
    pub int32: i32,
    pub int64: i64,
    pub uint32: u32,
    pub uint64: u64,
    pub float32: f32,
    pub float64: f64,
}
impl ::std::default::Default for PerformanceCounterResultKHR {
    #[inline]
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAcquireProfilingLockInfoKHR.html>"]
pub struct AcquireProfilingLockInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: AcquireProfilingLockFlagsKHR,
    pub timeout: u64,
}
impl ::std::default::Default for AcquireProfilingLockInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: AcquireProfilingLockFlagsKHR::default(),
            timeout: u64::default(),
        }
    }
}
unsafe impl TaggedStructure for AcquireProfilingLockInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::ACQUIRE_PROFILING_LOCK_INFO_KHR;
}
impl AcquireProfilingLockInfoKHR {
    pub fn builder<'a>() -> AcquireProfilingLockInfoKHRBuilder<'a> {
        AcquireProfilingLockInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AcquireProfilingLockInfoKHRBuilder<'a> {
    inner: AcquireProfilingLockInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for AcquireProfilingLockInfoKHRBuilder<'a> {
    type Target = AcquireProfilingLockInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AcquireProfilingLockInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AcquireProfilingLockInfoKHRBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: AcquireProfilingLockFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn timeout(mut self, timeout: u64) -> Self {
        self.inner.timeout = timeout;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AcquireProfilingLockInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceQuerySubmitInfoKHR.html>"]
pub struct PerformanceQuerySubmitInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub counter_pass_index: u32,
}
impl ::std::default::Default for PerformanceQuerySubmitInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            counter_pass_index: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PerformanceQuerySubmitInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::PERFORMANCE_QUERY_SUBMIT_INFO_KHR;
}
impl PerformanceQuerySubmitInfoKHR {
    pub fn builder<'a>() -> PerformanceQuerySubmitInfoKHRBuilder<'a> {
        PerformanceQuerySubmitInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PerformanceQuerySubmitInfoKHRBuilder<'a> {
    inner: PerformanceQuerySubmitInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSubmitInfo for PerformanceQuerySubmitInfoKHRBuilder<'_> {}
unsafe impl ExtendsSubmitInfo for PerformanceQuerySubmitInfoKHR {}
unsafe impl ExtendsSubmitInfo2 for PerformanceQuerySubmitInfoKHRBuilder<'_> {}
unsafe impl ExtendsSubmitInfo2 for PerformanceQuerySubmitInfoKHR {}
impl<'a> ::std::ops::Deref for PerformanceQuerySubmitInfoKHRBuilder<'a> {
    type Target = PerformanceQuerySubmitInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PerformanceQuerySubmitInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PerformanceQuerySubmitInfoKHRBuilder<'a> {
    #[inline]
    pub fn counter_pass_index(mut self, counter_pass_index: u32) -> Self {
        self.inner.counter_pass_index = counter_pass_index;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PerformanceQuerySubmitInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkHeadlessSurfaceCreateInfoEXT.html>"]
pub struct HeadlessSurfaceCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: HeadlessSurfaceCreateFlagsEXT,
}
impl ::std::default::Default for HeadlessSurfaceCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: HeadlessSurfaceCreateFlagsEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for HeadlessSurfaceCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::HEADLESS_SURFACE_CREATE_INFO_EXT;
}
impl HeadlessSurfaceCreateInfoEXT {
    pub fn builder<'a>() -> HeadlessSurfaceCreateInfoEXTBuilder<'a> {
        HeadlessSurfaceCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct HeadlessSurfaceCreateInfoEXTBuilder<'a> {
    inner: HeadlessSurfaceCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for HeadlessSurfaceCreateInfoEXTBuilder<'a> {
    type Target = HeadlessSurfaceCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for HeadlessSurfaceCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> HeadlessSurfaceCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: HeadlessSurfaceCreateFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> HeadlessSurfaceCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCoverageReductionModeFeaturesNV.html>"]
pub struct PhysicalDeviceCoverageReductionModeFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub coverage_reduction_mode: Bool32,
}
impl ::std::default::Default for PhysicalDeviceCoverageReductionModeFeaturesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            coverage_reduction_mode: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceCoverageReductionModeFeaturesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV;
}
impl PhysicalDeviceCoverageReductionModeFeaturesNV {
    pub fn builder<'a>() -> PhysicalDeviceCoverageReductionModeFeaturesNVBuilder<'a> {
        PhysicalDeviceCoverageReductionModeFeaturesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceCoverageReductionModeFeaturesNVBuilder<'a> {
    inner: PhysicalDeviceCoverageReductionModeFeaturesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceCoverageReductionModeFeaturesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceCoverageReductionModeFeaturesNV {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCoverageReductionModeFeaturesNVBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCoverageReductionModeFeaturesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceCoverageReductionModeFeaturesNVBuilder<'a> {
    type Target = PhysicalDeviceCoverageReductionModeFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceCoverageReductionModeFeaturesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceCoverageReductionModeFeaturesNVBuilder<'a> {
    #[inline]
    pub fn coverage_reduction_mode(mut self, coverage_reduction_mode: bool) -> Self {
        self.inner.coverage_reduction_mode = coverage_reduction_mode.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceCoverageReductionModeFeaturesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCoverageReductionStateCreateInfoNV.html>"]
pub struct PipelineCoverageReductionStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: PipelineCoverageReductionStateCreateFlagsNV,
    pub coverage_reduction_mode: CoverageReductionModeNV,
}
impl ::std::default::Default for PipelineCoverageReductionStateCreateInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: PipelineCoverageReductionStateCreateFlagsNV::default(),
            coverage_reduction_mode: CoverageReductionModeNV::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineCoverageReductionStateCreateInfoNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV;
}
impl PipelineCoverageReductionStateCreateInfoNV {
    pub fn builder<'a>() -> PipelineCoverageReductionStateCreateInfoNVBuilder<'a> {
        PipelineCoverageReductionStateCreateInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineCoverageReductionStateCreateInfoNVBuilder<'a> {
    inner: PipelineCoverageReductionStateCreateInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPipelineMultisampleStateCreateInfo
    for PipelineCoverageReductionStateCreateInfoNVBuilder<'_>
{
}
unsafe impl ExtendsPipelineMultisampleStateCreateInfo
    for PipelineCoverageReductionStateCreateInfoNV
{
}
impl<'a> ::std::ops::Deref for PipelineCoverageReductionStateCreateInfoNVBuilder<'a> {
    type Target = PipelineCoverageReductionStateCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineCoverageReductionStateCreateInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineCoverageReductionStateCreateInfoNVBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: PipelineCoverageReductionStateCreateFlagsNV) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn coverage_reduction_mode(
        mut self,
        coverage_reduction_mode: CoverageReductionModeNV,
    ) -> Self {
        self.inner.coverage_reduction_mode = coverage_reduction_mode;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineCoverageReductionStateCreateInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferMixedSamplesCombinationNV.html>"]
pub struct FramebufferMixedSamplesCombinationNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub coverage_reduction_mode: CoverageReductionModeNV,
    pub rasterization_samples: SampleCountFlags,
    pub depth_stencil_samples: SampleCountFlags,
    pub color_samples: SampleCountFlags,
}
impl ::std::default::Default for FramebufferMixedSamplesCombinationNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            coverage_reduction_mode: CoverageReductionModeNV::default(),
            rasterization_samples: SampleCountFlags::default(),
            depth_stencil_samples: SampleCountFlags::default(),
            color_samples: SampleCountFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for FramebufferMixedSamplesCombinationNV {
    const STRUCTURE_TYPE: StructureType = StructureType::FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV;
}
impl FramebufferMixedSamplesCombinationNV {
    pub fn builder<'a>() -> FramebufferMixedSamplesCombinationNVBuilder<'a> {
        FramebufferMixedSamplesCombinationNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct FramebufferMixedSamplesCombinationNVBuilder<'a> {
    inner: FramebufferMixedSamplesCombinationNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for FramebufferMixedSamplesCombinationNVBuilder<'a> {
    type Target = FramebufferMixedSamplesCombinationNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for FramebufferMixedSamplesCombinationNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> FramebufferMixedSamplesCombinationNVBuilder<'a> {
    #[inline]
    pub fn coverage_reduction_mode(
        mut self,
        coverage_reduction_mode: CoverageReductionModeNV,
    ) -> Self {
        self.inner.coverage_reduction_mode = coverage_reduction_mode;
        self
    }
    #[inline]
    pub fn rasterization_samples(mut self, rasterization_samples: SampleCountFlags) -> Self {
        self.inner.rasterization_samples = rasterization_samples;
        self
    }
    #[inline]
    pub fn depth_stencil_samples(mut self, depth_stencil_samples: SampleCountFlags) -> Self {
        self.inner.depth_stencil_samples = depth_stencil_samples;
        self
    }
    #[inline]
    pub fn color_samples(mut self, color_samples: SampleCountFlags) -> Self {
        self.inner.color_samples = color_samples;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> FramebufferMixedSamplesCombinationNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.html>"]
pub struct PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_integer_functions2: Bool32,
}
impl ::std::default::Default for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_integer_functions2: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL;
}
impl PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
    pub fn builder<'a>() -> PhysicalDeviceShaderIntegerFunctions2FeaturesINTELBuilder<'a> {
        PhysicalDeviceShaderIntegerFunctions2FeaturesINTELBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderIntegerFunctions2FeaturesINTELBuilder<'a> {
    inner: PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceShaderIntegerFunctions2FeaturesINTELBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceShaderIntegerFunctions2FeaturesINTELBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderIntegerFunctions2FeaturesINTELBuilder<'a> {
    type Target = PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderIntegerFunctions2FeaturesINTELBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderIntegerFunctions2FeaturesINTELBuilder<'a> {
    #[inline]
    pub fn shader_integer_functions2(mut self, shader_integer_functions2: bool) -> Self {
        self.inner.shader_integer_functions2 = shader_integer_functions2.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceValueDataINTEL.html>"]
pub union PerformanceValueDataINTEL {
    pub value32: u32,
    pub value64: u64,
    pub value_float: f32,
    pub value_bool: Bool32,
    pub value_string: *const c_char,
}
impl ::std::default::Default for PerformanceValueDataINTEL {
    #[inline]
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceValueINTEL.html>"]
pub struct PerformanceValueINTEL {
    pub ty: PerformanceValueTypeINTEL,
    pub data: PerformanceValueDataINTEL,
}
#[cfg(feature = "debug")]
impl fmt::Debug for PerformanceValueINTEL {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PerformanceValueINTEL")
            .field("ty", &self.ty)
            .field("data", &"union")
            .finish()
    }
}
impl PerformanceValueINTEL {
    pub fn builder<'a>() -> PerformanceValueINTELBuilder<'a> {
        PerformanceValueINTELBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PerformanceValueINTELBuilder<'a> {
    inner: PerformanceValueINTEL,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PerformanceValueINTELBuilder<'a> {
    type Target = PerformanceValueINTEL;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PerformanceValueINTELBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PerformanceValueINTELBuilder<'a> {
    #[inline]
    pub fn ty(mut self, ty: PerformanceValueTypeINTEL) -> Self {
        self.inner.ty = ty;
        self
    }
    #[inline]
    pub fn data(mut self, data: PerformanceValueDataINTEL) -> Self {
        self.inner.data = data;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PerformanceValueINTEL {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInitializePerformanceApiInfoINTEL.html>"]
pub struct InitializePerformanceApiInfoINTEL {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_user_data: *mut c_void,
}
impl ::std::default::Default for InitializePerformanceApiInfoINTEL {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_user_data: ::std::ptr::null_mut(),
        }
    }
}
unsafe impl TaggedStructure for InitializePerformanceApiInfoINTEL {
    const STRUCTURE_TYPE: StructureType = StructureType::INITIALIZE_PERFORMANCE_API_INFO_INTEL;
}
impl InitializePerformanceApiInfoINTEL {
    pub fn builder<'a>() -> InitializePerformanceApiInfoINTELBuilder<'a> {
        InitializePerformanceApiInfoINTELBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct InitializePerformanceApiInfoINTELBuilder<'a> {
    inner: InitializePerformanceApiInfoINTEL,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for InitializePerformanceApiInfoINTELBuilder<'a> {
    type Target = InitializePerformanceApiInfoINTEL;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for InitializePerformanceApiInfoINTELBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> InitializePerformanceApiInfoINTELBuilder<'a> {
    #[inline]
    pub fn user_data(mut self, user_data: *mut c_void) -> Self {
        self.inner.p_user_data = user_data;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> InitializePerformanceApiInfoINTEL {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPoolPerformanceQueryCreateInfoINTEL.html>"]
pub struct QueryPoolPerformanceQueryCreateInfoINTEL {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub performance_counters_sampling: QueryPoolSamplingModeINTEL,
}
impl ::std::default::Default for QueryPoolPerformanceQueryCreateInfoINTEL {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            performance_counters_sampling: QueryPoolSamplingModeINTEL::default(),
        }
    }
}
unsafe impl TaggedStructure for QueryPoolPerformanceQueryCreateInfoINTEL {
    const STRUCTURE_TYPE: StructureType =
        StructureType::QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL;
}
impl QueryPoolPerformanceQueryCreateInfoINTEL {
    pub fn builder<'a>() -> QueryPoolPerformanceQueryCreateInfoINTELBuilder<'a> {
        QueryPoolPerformanceQueryCreateInfoINTELBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct QueryPoolPerformanceQueryCreateInfoINTELBuilder<'a> {
    inner: QueryPoolPerformanceQueryCreateInfoINTEL,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsQueryPoolCreateInfo for QueryPoolPerformanceQueryCreateInfoINTELBuilder<'_> {}
unsafe impl ExtendsQueryPoolCreateInfo for QueryPoolPerformanceQueryCreateInfoINTEL {}
impl<'a> ::std::ops::Deref for QueryPoolPerformanceQueryCreateInfoINTELBuilder<'a> {
    type Target = QueryPoolPerformanceQueryCreateInfoINTEL;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for QueryPoolPerformanceQueryCreateInfoINTELBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> QueryPoolPerformanceQueryCreateInfoINTELBuilder<'a> {
    #[inline]
    pub fn performance_counters_sampling(
        mut self,
        performance_counters_sampling: QueryPoolSamplingModeINTEL,
    ) -> Self {
        self.inner.performance_counters_sampling = performance_counters_sampling;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> QueryPoolPerformanceQueryCreateInfoINTEL {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceMarkerInfoINTEL.html>"]
pub struct PerformanceMarkerInfoINTEL {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub marker: u64,
}
impl ::std::default::Default for PerformanceMarkerInfoINTEL {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            marker: u64::default(),
        }
    }
}
unsafe impl TaggedStructure for PerformanceMarkerInfoINTEL {
    const STRUCTURE_TYPE: StructureType = StructureType::PERFORMANCE_MARKER_INFO_INTEL;
}
impl PerformanceMarkerInfoINTEL {
    pub fn builder<'a>() -> PerformanceMarkerInfoINTELBuilder<'a> {
        PerformanceMarkerInfoINTELBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PerformanceMarkerInfoINTELBuilder<'a> {
    inner: PerformanceMarkerInfoINTEL,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PerformanceMarkerInfoINTELBuilder<'a> {
    type Target = PerformanceMarkerInfoINTEL;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PerformanceMarkerInfoINTELBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PerformanceMarkerInfoINTELBuilder<'a> {
    #[inline]
    pub fn marker(mut self, marker: u64) -> Self {
        self.inner.marker = marker;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PerformanceMarkerInfoINTEL {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceStreamMarkerInfoINTEL.html>"]
pub struct PerformanceStreamMarkerInfoINTEL {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub marker: u32,
}
impl ::std::default::Default for PerformanceStreamMarkerInfoINTEL {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            marker: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PerformanceStreamMarkerInfoINTEL {
    const STRUCTURE_TYPE: StructureType = StructureType::PERFORMANCE_STREAM_MARKER_INFO_INTEL;
}
impl PerformanceStreamMarkerInfoINTEL {
    pub fn builder<'a>() -> PerformanceStreamMarkerInfoINTELBuilder<'a> {
        PerformanceStreamMarkerInfoINTELBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PerformanceStreamMarkerInfoINTELBuilder<'a> {
    inner: PerformanceStreamMarkerInfoINTEL,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PerformanceStreamMarkerInfoINTELBuilder<'a> {
    type Target = PerformanceStreamMarkerInfoINTEL;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PerformanceStreamMarkerInfoINTELBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PerformanceStreamMarkerInfoINTELBuilder<'a> {
    #[inline]
    pub fn marker(mut self, marker: u32) -> Self {
        self.inner.marker = marker;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PerformanceStreamMarkerInfoINTEL {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceOverrideInfoINTEL.html>"]
pub struct PerformanceOverrideInfoINTEL {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: PerformanceOverrideTypeINTEL,
    pub enable: Bool32,
    pub parameter: u64,
}
impl ::std::default::Default for PerformanceOverrideInfoINTEL {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            ty: PerformanceOverrideTypeINTEL::default(),
            enable: Bool32::default(),
            parameter: u64::default(),
        }
    }
}
unsafe impl TaggedStructure for PerformanceOverrideInfoINTEL {
    const STRUCTURE_TYPE: StructureType = StructureType::PERFORMANCE_OVERRIDE_INFO_INTEL;
}
impl PerformanceOverrideInfoINTEL {
    pub fn builder<'a>() -> PerformanceOverrideInfoINTELBuilder<'a> {
        PerformanceOverrideInfoINTELBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PerformanceOverrideInfoINTELBuilder<'a> {
    inner: PerformanceOverrideInfoINTEL,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PerformanceOverrideInfoINTELBuilder<'a> {
    type Target = PerformanceOverrideInfoINTEL;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PerformanceOverrideInfoINTELBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PerformanceOverrideInfoINTELBuilder<'a> {
    #[inline]
    pub fn ty(mut self, ty: PerformanceOverrideTypeINTEL) -> Self {
        self.inner.ty = ty;
        self
    }
    #[inline]
    pub fn enable(mut self, enable: bool) -> Self {
        self.inner.enable = enable.into();
        self
    }
    #[inline]
    pub fn parameter(mut self, parameter: u64) -> Self {
        self.inner.parameter = parameter;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PerformanceOverrideInfoINTEL {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPerformanceConfigurationAcquireInfoINTEL.html>"]
pub struct PerformanceConfigurationAcquireInfoINTEL {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: PerformanceConfigurationTypeINTEL,
}
impl ::std::default::Default for PerformanceConfigurationAcquireInfoINTEL {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            ty: PerformanceConfigurationTypeINTEL::default(),
        }
    }
}
unsafe impl TaggedStructure for PerformanceConfigurationAcquireInfoINTEL {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL;
}
impl PerformanceConfigurationAcquireInfoINTEL {
    pub fn builder<'a>() -> PerformanceConfigurationAcquireInfoINTELBuilder<'a> {
        PerformanceConfigurationAcquireInfoINTELBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PerformanceConfigurationAcquireInfoINTELBuilder<'a> {
    inner: PerformanceConfigurationAcquireInfoINTEL,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PerformanceConfigurationAcquireInfoINTELBuilder<'a> {
    type Target = PerformanceConfigurationAcquireInfoINTEL;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PerformanceConfigurationAcquireInfoINTELBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PerformanceConfigurationAcquireInfoINTELBuilder<'a> {
    #[inline]
    pub fn ty(mut self, ty: PerformanceConfigurationTypeINTEL) -> Self {
        self.inner.ty = ty;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PerformanceConfigurationAcquireInfoINTEL {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderClockFeaturesKHR.html>"]
pub struct PhysicalDeviceShaderClockFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_subgroup_clock: Bool32,
    pub shader_device_clock: Bool32,
}
impl ::std::default::Default for PhysicalDeviceShaderClockFeaturesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_subgroup_clock: Bool32::default(),
            shader_device_clock: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderClockFeaturesKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR;
}
impl PhysicalDeviceShaderClockFeaturesKHR {
    pub fn builder<'a>() -> PhysicalDeviceShaderClockFeaturesKHRBuilder<'a> {
        PhysicalDeviceShaderClockFeaturesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderClockFeaturesKHRBuilder<'a> {
    inner: PhysicalDeviceShaderClockFeaturesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderClockFeaturesKHRBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderClockFeaturesKHR {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderClockFeaturesKHRBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderClockFeaturesKHR {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderClockFeaturesKHRBuilder<'a> {
    type Target = PhysicalDeviceShaderClockFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderClockFeaturesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderClockFeaturesKHRBuilder<'a> {
    #[inline]
    pub fn shader_subgroup_clock(mut self, shader_subgroup_clock: bool) -> Self {
        self.inner.shader_subgroup_clock = shader_subgroup_clock.into();
        self
    }
    #[inline]
    pub fn shader_device_clock(mut self, shader_device_clock: bool) -> Self {
        self.inner.shader_device_clock = shader_device_clock.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderClockFeaturesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceIndexTypeUint8FeaturesEXT.html>"]
pub struct PhysicalDeviceIndexTypeUint8FeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub index_type_uint8: Bool32,
}
impl ::std::default::Default for PhysicalDeviceIndexTypeUint8FeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            index_type_uint8: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceIndexTypeUint8FeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT;
}
impl PhysicalDeviceIndexTypeUint8FeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceIndexTypeUint8FeaturesEXTBuilder<'a> {
        PhysicalDeviceIndexTypeUint8FeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceIndexTypeUint8FeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceIndexTypeUint8FeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceIndexTypeUint8FeaturesEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceIndexTypeUint8FeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceIndexTypeUint8FeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceIndexTypeUint8FeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceIndexTypeUint8FeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceIndexTypeUint8FeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceIndexTypeUint8FeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceIndexTypeUint8FeaturesEXTBuilder<'a> {
    #[inline]
    pub fn index_type_uint8(mut self, index_type_uint8: bool) -> Self {
        self.inner.index_type_uint8 = index_type_uint8.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceIndexTypeUint8FeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.html>"]
pub struct PhysicalDeviceShaderSMBuiltinsPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_sm_count: u32,
    pub shader_warps_per_sm: u32,
}
impl ::std::default::Default for PhysicalDeviceShaderSMBuiltinsPropertiesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_sm_count: u32::default(),
            shader_warps_per_sm: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderSMBuiltinsPropertiesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV;
}
impl PhysicalDeviceShaderSMBuiltinsPropertiesNV {
    pub fn builder<'a>() -> PhysicalDeviceShaderSMBuiltinsPropertiesNVBuilder<'a> {
        PhysicalDeviceShaderSMBuiltinsPropertiesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderSMBuiltinsPropertiesNVBuilder<'a> {
    inner: PhysicalDeviceShaderSMBuiltinsPropertiesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceShaderSMBuiltinsPropertiesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceShaderSMBuiltinsPropertiesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderSMBuiltinsPropertiesNVBuilder<'a> {
    type Target = PhysicalDeviceShaderSMBuiltinsPropertiesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderSMBuiltinsPropertiesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderSMBuiltinsPropertiesNVBuilder<'a> {
    #[inline]
    pub fn shader_sm_count(mut self, shader_sm_count: u32) -> Self {
        self.inner.shader_sm_count = shader_sm_count;
        self
    }
    #[inline]
    pub fn shader_warps_per_sm(mut self, shader_warps_per_sm: u32) -> Self {
        self.inner.shader_warps_per_sm = shader_warps_per_sm;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderSMBuiltinsPropertiesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.html>"]
pub struct PhysicalDeviceShaderSMBuiltinsFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_sm_builtins: Bool32,
}
impl ::std::default::Default for PhysicalDeviceShaderSMBuiltinsFeaturesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_sm_builtins: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderSMBuiltinsFeaturesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV;
}
impl PhysicalDeviceShaderSMBuiltinsFeaturesNV {
    pub fn builder<'a>() -> PhysicalDeviceShaderSMBuiltinsFeaturesNVBuilder<'a> {
        PhysicalDeviceShaderSMBuiltinsFeaturesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderSMBuiltinsFeaturesNVBuilder<'a> {
    inner: PhysicalDeviceShaderSMBuiltinsFeaturesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderSMBuiltinsFeaturesNVBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderSMBuiltinsFeaturesNV {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderSMBuiltinsFeaturesNVBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderSMBuiltinsFeaturesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderSMBuiltinsFeaturesNVBuilder<'a> {
    type Target = PhysicalDeviceShaderSMBuiltinsFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderSMBuiltinsFeaturesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderSMBuiltinsFeaturesNVBuilder<'a> {
    #[inline]
    pub fn shader_sm_builtins(mut self, shader_sm_builtins: bool) -> Self {
        self.inner.shader_sm_builtins = shader_sm_builtins.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderSMBuiltinsFeaturesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.html>"]
pub struct PhysicalDeviceFragmentShaderInterlockFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub fragment_shader_sample_interlock: Bool32,
    pub fragment_shader_pixel_interlock: Bool32,
    pub fragment_shader_shading_rate_interlock: Bool32,
}
impl ::std::default::Default for PhysicalDeviceFragmentShaderInterlockFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            fragment_shader_sample_interlock: Bool32::default(),
            fragment_shader_pixel_interlock: Bool32::default(),
            fragment_shader_shading_rate_interlock: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceFragmentShaderInterlockFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT;
}
impl PhysicalDeviceFragmentShaderInterlockFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceFragmentShaderInterlockFeaturesEXTBuilder<'a> {
        PhysicalDeviceFragmentShaderInterlockFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceFragmentShaderInterlockFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceFragmentShaderInterlockFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceFragmentShaderInterlockFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceFragmentShaderInterlockFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceFragmentShaderInterlockFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentShaderInterlockFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceFragmentShaderInterlockFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceFragmentShaderInterlockFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceFragmentShaderInterlockFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceFragmentShaderInterlockFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn fragment_shader_sample_interlock(
        mut self,
        fragment_shader_sample_interlock: bool,
    ) -> Self {
        self.inner.fragment_shader_sample_interlock = fragment_shader_sample_interlock.into();
        self
    }
    #[inline]
    pub fn fragment_shader_pixel_interlock(
        mut self,
        fragment_shader_pixel_interlock: bool,
    ) -> Self {
        self.inner.fragment_shader_pixel_interlock = fragment_shader_pixel_interlock.into();
        self
    }
    #[inline]
    pub fn fragment_shader_shading_rate_interlock(
        mut self,
        fragment_shader_shading_rate_interlock: bool,
    ) -> Self {
        self.inner.fragment_shader_shading_rate_interlock =
            fragment_shader_shading_rate_interlock.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceFragmentShaderInterlockFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.html>"]
pub struct PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub separate_depth_stencil_layouts: Bool32,
}
impl ::std::default::Default for PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            separate_depth_stencil_layouts: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
}
impl PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
    pub fn builder<'a>() -> PhysicalDeviceSeparateDepthStencilLayoutsFeaturesBuilder<'a> {
        PhysicalDeviceSeparateDepthStencilLayoutsFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceSeparateDepthStencilLayoutsFeaturesBuilder<'a> {
    inner: PhysicalDeviceSeparateDepthStencilLayoutsFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceSeparateDepthStencilLayoutsFeaturesBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceSeparateDepthStencilLayoutsFeatures {}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceSeparateDepthStencilLayoutsFeaturesBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSeparateDepthStencilLayoutsFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDeviceSeparateDepthStencilLayoutsFeaturesBuilder<'a> {
    type Target = PhysicalDeviceSeparateDepthStencilLayoutsFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceSeparateDepthStencilLayoutsFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceSeparateDepthStencilLayoutsFeaturesBuilder<'a> {
    #[inline]
    pub fn separate_depth_stencil_layouts(mut self, separate_depth_stencil_layouts: bool) -> Self {
        self.inner.separate_depth_stencil_layouts = separate_depth_stencil_layouts.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentReferenceStencilLayout.html>"]
pub struct AttachmentReferenceStencilLayout {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub stencil_layout: ImageLayout,
}
impl ::std::default::Default for AttachmentReferenceStencilLayout {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            stencil_layout: ImageLayout::default(),
        }
    }
}
unsafe impl TaggedStructure for AttachmentReferenceStencilLayout {
    const STRUCTURE_TYPE: StructureType = StructureType::ATTACHMENT_REFERENCE_STENCIL_LAYOUT;
}
impl AttachmentReferenceStencilLayout {
    pub fn builder<'a>() -> AttachmentReferenceStencilLayoutBuilder<'a> {
        AttachmentReferenceStencilLayoutBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AttachmentReferenceStencilLayoutBuilder<'a> {
    inner: AttachmentReferenceStencilLayout,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsAttachmentReference2 for AttachmentReferenceStencilLayoutBuilder<'_> {}
unsafe impl ExtendsAttachmentReference2 for AttachmentReferenceStencilLayout {}
impl<'a> ::std::ops::Deref for AttachmentReferenceStencilLayoutBuilder<'a> {
    type Target = AttachmentReferenceStencilLayout;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AttachmentReferenceStencilLayoutBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AttachmentReferenceStencilLayoutBuilder<'a> {
    #[inline]
    pub fn stencil_layout(mut self, stencil_layout: ImageLayout) -> Self {
        self.inner.stencil_layout = stencil_layout;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AttachmentReferenceStencilLayout {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT.html>"]
pub struct PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub primitive_topology_list_restart: Bool32,
    pub primitive_topology_patch_list_restart: Bool32,
}
impl ::std::default::Default for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            primitive_topology_list_restart: Bool32::default(),
            primitive_topology_patch_list_restart: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT;
}
impl PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDevicePrimitiveTopologyListRestartFeaturesEXTBuilder<'a> {
        PhysicalDevicePrimitiveTopologyListRestartFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevicePrimitiveTopologyListRestartFeaturesEXTBuilder<'a> {
    inner: PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT
{
}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXTBuilder<'a> {
    type Target = PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevicePrimitiveTopologyListRestartFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevicePrimitiveTopologyListRestartFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn primitive_topology_list_restart(
        mut self,
        primitive_topology_list_restart: bool,
    ) -> Self {
        self.inner.primitive_topology_list_restart = primitive_topology_list_restart.into();
        self
    }
    #[inline]
    pub fn primitive_topology_patch_list_restart(
        mut self,
        primitive_topology_patch_list_restart: bool,
    ) -> Self {
        self.inner.primitive_topology_patch_list_restart =
            primitive_topology_patch_list_restart.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescriptionStencilLayout.html>"]
pub struct AttachmentDescriptionStencilLayout {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub stencil_initial_layout: ImageLayout,
    pub stencil_final_layout: ImageLayout,
}
impl ::std::default::Default for AttachmentDescriptionStencilLayout {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            stencil_initial_layout: ImageLayout::default(),
            stencil_final_layout: ImageLayout::default(),
        }
    }
}
unsafe impl TaggedStructure for AttachmentDescriptionStencilLayout {
    const STRUCTURE_TYPE: StructureType = StructureType::ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT;
}
impl AttachmentDescriptionStencilLayout {
    pub fn builder<'a>() -> AttachmentDescriptionStencilLayoutBuilder<'a> {
        AttachmentDescriptionStencilLayoutBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AttachmentDescriptionStencilLayoutBuilder<'a> {
    inner: AttachmentDescriptionStencilLayout,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsAttachmentDescription2 for AttachmentDescriptionStencilLayoutBuilder<'_> {}
unsafe impl ExtendsAttachmentDescription2 for AttachmentDescriptionStencilLayout {}
impl<'a> ::std::ops::Deref for AttachmentDescriptionStencilLayoutBuilder<'a> {
    type Target = AttachmentDescriptionStencilLayout;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AttachmentDescriptionStencilLayoutBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AttachmentDescriptionStencilLayoutBuilder<'a> {
    #[inline]
    pub fn stencil_initial_layout(mut self, stencil_initial_layout: ImageLayout) -> Self {
        self.inner.stencil_initial_layout = stencil_initial_layout;
        self
    }
    #[inline]
    pub fn stencil_final_layout(mut self, stencil_final_layout: ImageLayout) -> Self {
        self.inner.stencil_final_layout = stencil_final_layout;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AttachmentDescriptionStencilLayout {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR.html>"]
pub struct PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pipeline_executable_info: Bool32,
}
impl ::std::default::Default for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            pipeline_executable_info: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR;
}
impl PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
    pub fn builder<'a>() -> PhysicalDevicePipelineExecutablePropertiesFeaturesKHRBuilder<'a> {
        PhysicalDevicePipelineExecutablePropertiesFeaturesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevicePipelineExecutablePropertiesFeaturesKHRBuilder<'a> {
    inner: PhysicalDevicePipelineExecutablePropertiesFeaturesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDevicePipelineExecutablePropertiesFeaturesKHRBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR
{
}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDevicePipelineExecutablePropertiesFeaturesKHRBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {}
impl<'a> ::std::ops::Deref for PhysicalDevicePipelineExecutablePropertiesFeaturesKHRBuilder<'a> {
    type Target = PhysicalDevicePipelineExecutablePropertiesFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevicePipelineExecutablePropertiesFeaturesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevicePipelineExecutablePropertiesFeaturesKHRBuilder<'a> {
    #[inline]
    pub fn pipeline_executable_info(mut self, pipeline_executable_info: bool) -> Self {
        self.inner.pipeline_executable_info = pipeline_executable_info.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineInfoKHR.html>"]
pub struct PipelineInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub pipeline: Pipeline,
}
impl ::std::default::Default for PipelineInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            pipeline: Pipeline::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_INFO_KHR;
}
impl PipelineInfoKHR {
    pub fn builder<'a>() -> PipelineInfoKHRBuilder<'a> {
        PipelineInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineInfoKHRBuilder<'a> {
    inner: PipelineInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PipelineInfoKHRBuilder<'a> {
    type Target = PipelineInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineInfoKHRBuilder<'a> {
    #[inline]
    pub fn pipeline(mut self, pipeline: Pipeline) -> Self {
        self.inner.pipeline = pipeline;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineExecutablePropertiesKHR.html>"]
pub struct PipelineExecutablePropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub stages: ShaderStageFlags,
    pub name: [c_char; MAX_DESCRIPTION_SIZE],
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
    pub subgroup_size: u32,
}
#[cfg(feature = "debug")]
impl fmt::Debug for PipelineExecutablePropertiesKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineExecutablePropertiesKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("stages", &self.stages)
            .field("name", &unsafe {
                ::std::ffi::CStr::from_ptr(self.name.as_ptr())
            })
            .field("description", &unsafe {
                ::std::ffi::CStr::from_ptr(self.description.as_ptr())
            })
            .field("subgroup_size", &self.subgroup_size)
            .finish()
    }
}
impl ::std::default::Default for PipelineExecutablePropertiesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            stages: ShaderStageFlags::default(),
            name: unsafe { ::std::mem::zeroed() },
            description: unsafe { ::std::mem::zeroed() },
            subgroup_size: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineExecutablePropertiesKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_EXECUTABLE_PROPERTIES_KHR;
}
impl PipelineExecutablePropertiesKHR {
    pub fn builder<'a>() -> PipelineExecutablePropertiesKHRBuilder<'a> {
        PipelineExecutablePropertiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineExecutablePropertiesKHRBuilder<'a> {
    inner: PipelineExecutablePropertiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PipelineExecutablePropertiesKHRBuilder<'a> {
    type Target = PipelineExecutablePropertiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineExecutablePropertiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineExecutablePropertiesKHRBuilder<'a> {
    #[inline]
    pub fn stages(mut self, stages: ShaderStageFlags) -> Self {
        self.inner.stages = stages;
        self
    }
    #[inline]
    pub fn name(mut self, name: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.inner.name = name;
        self
    }
    #[inline]
    pub fn description(mut self, description: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.inner.description = description;
        self
    }
    #[inline]
    pub fn subgroup_size(mut self, subgroup_size: u32) -> Self {
        self.inner.subgroup_size = subgroup_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineExecutablePropertiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineExecutableInfoKHR.html>"]
pub struct PipelineExecutableInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub pipeline: Pipeline,
    pub executable_index: u32,
}
impl ::std::default::Default for PipelineExecutableInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            pipeline: Pipeline::default(),
            executable_index: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineExecutableInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_EXECUTABLE_INFO_KHR;
}
impl PipelineExecutableInfoKHR {
    pub fn builder<'a>() -> PipelineExecutableInfoKHRBuilder<'a> {
        PipelineExecutableInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineExecutableInfoKHRBuilder<'a> {
    inner: PipelineExecutableInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PipelineExecutableInfoKHRBuilder<'a> {
    type Target = PipelineExecutableInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineExecutableInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineExecutableInfoKHRBuilder<'a> {
    #[inline]
    pub fn pipeline(mut self, pipeline: Pipeline) -> Self {
        self.inner.pipeline = pipeline;
        self
    }
    #[inline]
    pub fn executable_index(mut self, executable_index: u32) -> Self {
        self.inner.executable_index = executable_index;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineExecutableInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineExecutableStatisticValueKHR.html>"]
pub union PipelineExecutableStatisticValueKHR {
    pub b32: Bool32,
    pub i64: i64,
    pub u64: u64,
    pub f64: f64,
}
impl ::std::default::Default for PipelineExecutableStatisticValueKHR {
    #[inline]
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineExecutableStatisticKHR.html>"]
pub struct PipelineExecutableStatisticKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub name: [c_char; MAX_DESCRIPTION_SIZE],
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
    pub format: PipelineExecutableStatisticFormatKHR,
    pub value: PipelineExecutableStatisticValueKHR,
}
#[cfg(feature = "debug")]
impl fmt::Debug for PipelineExecutableStatisticKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineExecutableStatisticKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("name", &unsafe {
                ::std::ffi::CStr::from_ptr(self.name.as_ptr())
            })
            .field("description", &unsafe {
                ::std::ffi::CStr::from_ptr(self.description.as_ptr())
            })
            .field("format", &self.format)
            .field("value", &"union")
            .finish()
    }
}
impl ::std::default::Default for PipelineExecutableStatisticKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            name: unsafe { ::std::mem::zeroed() },
            description: unsafe { ::std::mem::zeroed() },
            format: PipelineExecutableStatisticFormatKHR::default(),
            value: PipelineExecutableStatisticValueKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineExecutableStatisticKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_EXECUTABLE_STATISTIC_KHR;
}
impl PipelineExecutableStatisticKHR {
    pub fn builder<'a>() -> PipelineExecutableStatisticKHRBuilder<'a> {
        PipelineExecutableStatisticKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineExecutableStatisticKHRBuilder<'a> {
    inner: PipelineExecutableStatisticKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PipelineExecutableStatisticKHRBuilder<'a> {
    type Target = PipelineExecutableStatisticKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineExecutableStatisticKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineExecutableStatisticKHRBuilder<'a> {
    #[inline]
    pub fn name(mut self, name: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.inner.name = name;
        self
    }
    #[inline]
    pub fn description(mut self, description: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.inner.description = description;
        self
    }
    #[inline]
    pub fn format(mut self, format: PipelineExecutableStatisticFormatKHR) -> Self {
        self.inner.format = format;
        self
    }
    #[inline]
    pub fn value(mut self, value: PipelineExecutableStatisticValueKHR) -> Self {
        self.inner.value = value;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineExecutableStatisticKHR {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineExecutableInternalRepresentationKHR.html>"]
pub struct PipelineExecutableInternalRepresentationKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub name: [c_char; MAX_DESCRIPTION_SIZE],
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
    pub is_text: Bool32,
    pub data_size: usize,
    pub p_data: *mut c_void,
}
#[cfg(feature = "debug")]
impl fmt::Debug for PipelineExecutableInternalRepresentationKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PipelineExecutableInternalRepresentationKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("name", &unsafe {
                ::std::ffi::CStr::from_ptr(self.name.as_ptr())
            })
            .field("description", &unsafe {
                ::std::ffi::CStr::from_ptr(self.description.as_ptr())
            })
            .field("is_text", &self.is_text)
            .field("data_size", &self.data_size)
            .field("p_data", &self.p_data)
            .finish()
    }
}
impl ::std::default::Default for PipelineExecutableInternalRepresentationKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            name: unsafe { ::std::mem::zeroed() },
            description: unsafe { ::std::mem::zeroed() },
            is_text: Bool32::default(),
            data_size: usize::default(),
            p_data: ::std::ptr::null_mut(),
        }
    }
}
unsafe impl TaggedStructure for PipelineExecutableInternalRepresentationKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR;
}
impl PipelineExecutableInternalRepresentationKHR {
    pub fn builder<'a>() -> PipelineExecutableInternalRepresentationKHRBuilder<'a> {
        PipelineExecutableInternalRepresentationKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineExecutableInternalRepresentationKHRBuilder<'a> {
    inner: PipelineExecutableInternalRepresentationKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PipelineExecutableInternalRepresentationKHRBuilder<'a> {
    type Target = PipelineExecutableInternalRepresentationKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineExecutableInternalRepresentationKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineExecutableInternalRepresentationKHRBuilder<'a> {
    #[inline]
    pub fn name(mut self, name: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.inner.name = name;
        self
    }
    #[inline]
    pub fn description(mut self, description: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.inner.description = description;
        self
    }
    #[inline]
    pub fn is_text(mut self, is_text: bool) -> Self {
        self.inner.is_text = is_text.into();
        self
    }
    #[inline]
    pub fn data(mut self, data: &'a mut [u8]) -> Self {
        self.inner.data_size = data.len();
        self.inner.p_data = data.as_mut_ptr().cast();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineExecutableInternalRepresentationKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures.html>"]
pub struct PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_demote_to_helper_invocation: Bool32,
}
impl ::std::default::Default for PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_demote_to_helper_invocation: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES;
}
impl PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
    pub fn builder<'a>() -> PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder<'a> {
        PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder<'a> {
    inner: PhysicalDeviceShaderDemoteToHelperInvocationFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceShaderDemoteToHelperInvocationFeatures
{
}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderDemoteToHelperInvocationFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder<'a> {
    type Target = PhysicalDeviceShaderDemoteToHelperInvocationFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderDemoteToHelperInvocationFeaturesBuilder<'a> {
    #[inline]
    pub fn shader_demote_to_helper_invocation(
        mut self,
        shader_demote_to_helper_invocation: bool,
    ) -> Self {
        self.inner.shader_demote_to_helper_invocation = shader_demote_to_helper_invocation.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.html>"]
pub struct PhysicalDeviceTexelBufferAlignmentFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub texel_buffer_alignment: Bool32,
}
impl ::std::default::Default for PhysicalDeviceTexelBufferAlignmentFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            texel_buffer_alignment: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceTexelBufferAlignmentFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT;
}
impl PhysicalDeviceTexelBufferAlignmentFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceTexelBufferAlignmentFeaturesEXTBuilder<'a> {
        PhysicalDeviceTexelBufferAlignmentFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceTexelBufferAlignmentFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceTexelBufferAlignmentFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceTexelBufferAlignmentFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceTexelBufferAlignmentFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceTexelBufferAlignmentFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceTexelBufferAlignmentFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceTexelBufferAlignmentFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceTexelBufferAlignmentFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceTexelBufferAlignmentFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceTexelBufferAlignmentFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn texel_buffer_alignment(mut self, texel_buffer_alignment: bool) -> Self {
        self.inner.texel_buffer_alignment = texel_buffer_alignment.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceTexelBufferAlignmentFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTexelBufferAlignmentProperties.html>"]
pub struct PhysicalDeviceTexelBufferAlignmentProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub storage_texel_buffer_offset_alignment_bytes: DeviceSize,
    pub storage_texel_buffer_offset_single_texel_alignment: Bool32,
    pub uniform_texel_buffer_offset_alignment_bytes: DeviceSize,
    pub uniform_texel_buffer_offset_single_texel_alignment: Bool32,
}
impl ::std::default::Default for PhysicalDeviceTexelBufferAlignmentProperties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            storage_texel_buffer_offset_alignment_bytes: DeviceSize::default(),
            storage_texel_buffer_offset_single_texel_alignment: Bool32::default(),
            uniform_texel_buffer_offset_alignment_bytes: DeviceSize::default(),
            uniform_texel_buffer_offset_single_texel_alignment: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceTexelBufferAlignmentProperties {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES;
}
impl PhysicalDeviceTexelBufferAlignmentProperties {
    pub fn builder<'a>() -> PhysicalDeviceTexelBufferAlignmentPropertiesBuilder<'a> {
        PhysicalDeviceTexelBufferAlignmentPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceTexelBufferAlignmentPropertiesBuilder<'a> {
    inner: PhysicalDeviceTexelBufferAlignmentProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceTexelBufferAlignmentPropertiesBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceTexelBufferAlignmentProperties {}
impl<'a> ::std::ops::Deref for PhysicalDeviceTexelBufferAlignmentPropertiesBuilder<'a> {
    type Target = PhysicalDeviceTexelBufferAlignmentProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceTexelBufferAlignmentPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceTexelBufferAlignmentPropertiesBuilder<'a> {
    #[inline]
    pub fn storage_texel_buffer_offset_alignment_bytes(
        mut self,
        storage_texel_buffer_offset_alignment_bytes: DeviceSize,
    ) -> Self {
        self.inner.storage_texel_buffer_offset_alignment_bytes =
            storage_texel_buffer_offset_alignment_bytes;
        self
    }
    #[inline]
    pub fn storage_texel_buffer_offset_single_texel_alignment(
        mut self,
        storage_texel_buffer_offset_single_texel_alignment: bool,
    ) -> Self {
        self.inner
            .storage_texel_buffer_offset_single_texel_alignment =
            storage_texel_buffer_offset_single_texel_alignment.into();
        self
    }
    #[inline]
    pub fn uniform_texel_buffer_offset_alignment_bytes(
        mut self,
        uniform_texel_buffer_offset_alignment_bytes: DeviceSize,
    ) -> Self {
        self.inner.uniform_texel_buffer_offset_alignment_bytes =
            uniform_texel_buffer_offset_alignment_bytes;
        self
    }
    #[inline]
    pub fn uniform_texel_buffer_offset_single_texel_alignment(
        mut self,
        uniform_texel_buffer_offset_single_texel_alignment: bool,
    ) -> Self {
        self.inner
            .uniform_texel_buffer_offset_single_texel_alignment =
            uniform_texel_buffer_offset_single_texel_alignment.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceTexelBufferAlignmentProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubgroupSizeControlFeatures.html>"]
pub struct PhysicalDeviceSubgroupSizeControlFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub subgroup_size_control: Bool32,
    pub compute_full_subgroups: Bool32,
}
impl ::std::default::Default for PhysicalDeviceSubgroupSizeControlFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            subgroup_size_control: Bool32::default(),
            compute_full_subgroups: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceSubgroupSizeControlFeatures {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES;
}
impl PhysicalDeviceSubgroupSizeControlFeatures {
    pub fn builder<'a>() -> PhysicalDeviceSubgroupSizeControlFeaturesBuilder<'a> {
        PhysicalDeviceSubgroupSizeControlFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceSubgroupSizeControlFeaturesBuilder<'a> {
    inner: PhysicalDeviceSubgroupSizeControlFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceSubgroupSizeControlFeaturesBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceSubgroupSizeControlFeatures {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSubgroupSizeControlFeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSubgroupSizeControlFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDeviceSubgroupSizeControlFeaturesBuilder<'a> {
    type Target = PhysicalDeviceSubgroupSizeControlFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceSubgroupSizeControlFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceSubgroupSizeControlFeaturesBuilder<'a> {
    #[inline]
    pub fn subgroup_size_control(mut self, subgroup_size_control: bool) -> Self {
        self.inner.subgroup_size_control = subgroup_size_control.into();
        self
    }
    #[inline]
    pub fn compute_full_subgroups(mut self, compute_full_subgroups: bool) -> Self {
        self.inner.compute_full_subgroups = compute_full_subgroups.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceSubgroupSizeControlFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubgroupSizeControlProperties.html>"]
pub struct PhysicalDeviceSubgroupSizeControlProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_subgroup_size: u32,
    pub max_subgroup_size: u32,
    pub max_compute_workgroup_subgroups: u32,
    pub required_subgroup_size_stages: ShaderStageFlags,
}
impl ::std::default::Default for PhysicalDeviceSubgroupSizeControlProperties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            min_subgroup_size: u32::default(),
            max_subgroup_size: u32::default(),
            max_compute_workgroup_subgroups: u32::default(),
            required_subgroup_size_stages: ShaderStageFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceSubgroupSizeControlProperties {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES;
}
impl PhysicalDeviceSubgroupSizeControlProperties {
    pub fn builder<'a>() -> PhysicalDeviceSubgroupSizeControlPropertiesBuilder<'a> {
        PhysicalDeviceSubgroupSizeControlPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceSubgroupSizeControlPropertiesBuilder<'a> {
    inner: PhysicalDeviceSubgroupSizeControlProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceSubgroupSizeControlPropertiesBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceSubgroupSizeControlProperties {}
impl<'a> ::std::ops::Deref for PhysicalDeviceSubgroupSizeControlPropertiesBuilder<'a> {
    type Target = PhysicalDeviceSubgroupSizeControlProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceSubgroupSizeControlPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceSubgroupSizeControlPropertiesBuilder<'a> {
    #[inline]
    pub fn min_subgroup_size(mut self, min_subgroup_size: u32) -> Self {
        self.inner.min_subgroup_size = min_subgroup_size;
        self
    }
    #[inline]
    pub fn max_subgroup_size(mut self, max_subgroup_size: u32) -> Self {
        self.inner.max_subgroup_size = max_subgroup_size;
        self
    }
    #[inline]
    pub fn max_compute_workgroup_subgroups(mut self, max_compute_workgroup_subgroups: u32) -> Self {
        self.inner.max_compute_workgroup_subgroups = max_compute_workgroup_subgroups;
        self
    }
    #[inline]
    pub fn required_subgroup_size_stages(
        mut self,
        required_subgroup_size_stages: ShaderStageFlags,
    ) -> Self {
        self.inner.required_subgroup_size_stages = required_subgroup_size_stages;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceSubgroupSizeControlProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageRequiredSubgroupSizeCreateInfo.html>"]
pub struct PipelineShaderStageRequiredSubgroupSizeCreateInfo {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub required_subgroup_size: u32,
}
impl ::std::default::Default for PipelineShaderStageRequiredSubgroupSizeCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            required_subgroup_size: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineShaderStageRequiredSubgroupSizeCreateInfo {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO;
}
impl PipelineShaderStageRequiredSubgroupSizeCreateInfo {
    pub fn builder<'a>() -> PipelineShaderStageRequiredSubgroupSizeCreateInfoBuilder<'a> {
        PipelineShaderStageRequiredSubgroupSizeCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineShaderStageRequiredSubgroupSizeCreateInfoBuilder<'a> {
    inner: PipelineShaderStageRequiredSubgroupSizeCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPipelineShaderStageCreateInfo
    for PipelineShaderStageRequiredSubgroupSizeCreateInfoBuilder<'_>
{
}
unsafe impl ExtendsPipelineShaderStageCreateInfo
    for PipelineShaderStageRequiredSubgroupSizeCreateInfo
{
}
unsafe impl ExtendsShaderCreateInfoEXT
    for PipelineShaderStageRequiredSubgroupSizeCreateInfoBuilder<'_>
{
}
unsafe impl ExtendsShaderCreateInfoEXT for PipelineShaderStageRequiredSubgroupSizeCreateInfo {}
impl<'a> ::std::ops::Deref for PipelineShaderStageRequiredSubgroupSizeCreateInfoBuilder<'a> {
    type Target = PipelineShaderStageRequiredSubgroupSizeCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineShaderStageRequiredSubgroupSizeCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineShaderStageRequiredSubgroupSizeCreateInfoBuilder<'a> {
    #[inline]
    pub fn required_subgroup_size(mut self, required_subgroup_size: u32) -> Self {
        self.inner.required_subgroup_size = required_subgroup_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineShaderStageRequiredSubgroupSizeCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassShadingPipelineCreateInfoHUAWEI.html>"]
pub struct SubpassShadingPipelineCreateInfoHUAWEI {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub render_pass: RenderPass,
    pub subpass: u32,
}
impl ::std::default::Default for SubpassShadingPipelineCreateInfoHUAWEI {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            render_pass: RenderPass::default(),
            subpass: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for SubpassShadingPipelineCreateInfoHUAWEI {
    const STRUCTURE_TYPE: StructureType =
        StructureType::SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI;
}
impl SubpassShadingPipelineCreateInfoHUAWEI {
    pub fn builder<'a>() -> SubpassShadingPipelineCreateInfoHUAWEIBuilder<'a> {
        SubpassShadingPipelineCreateInfoHUAWEIBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SubpassShadingPipelineCreateInfoHUAWEIBuilder<'a> {
    inner: SubpassShadingPipelineCreateInfoHUAWEI,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsComputePipelineCreateInfo for SubpassShadingPipelineCreateInfoHUAWEIBuilder<'_> {}
unsafe impl ExtendsComputePipelineCreateInfo for SubpassShadingPipelineCreateInfoHUAWEI {}
impl<'a> ::std::ops::Deref for SubpassShadingPipelineCreateInfoHUAWEIBuilder<'a> {
    type Target = SubpassShadingPipelineCreateInfoHUAWEI;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SubpassShadingPipelineCreateInfoHUAWEIBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SubpassShadingPipelineCreateInfoHUAWEIBuilder<'a> {
    #[inline]
    pub fn render_pass(mut self, render_pass: RenderPass) -> Self {
        self.inner.render_pass = render_pass;
        self
    }
    #[inline]
    pub fn subpass(mut self, subpass: u32) -> Self {
        self.inner.subpass = subpass;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SubpassShadingPipelineCreateInfoHUAWEI {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubpassShadingPropertiesHUAWEI.html>"]
pub struct PhysicalDeviceSubpassShadingPropertiesHUAWEI {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_subpass_shading_workgroup_size_aspect_ratio: u32,
}
impl ::std::default::Default for PhysicalDeviceSubpassShadingPropertiesHUAWEI {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_subpass_shading_workgroup_size_aspect_ratio: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceSubpassShadingPropertiesHUAWEI {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI;
}
impl PhysicalDeviceSubpassShadingPropertiesHUAWEI {
    pub fn builder<'a>() -> PhysicalDeviceSubpassShadingPropertiesHUAWEIBuilder<'a> {
        PhysicalDeviceSubpassShadingPropertiesHUAWEIBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceSubpassShadingPropertiesHUAWEIBuilder<'a> {
    inner: PhysicalDeviceSubpassShadingPropertiesHUAWEI,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceSubpassShadingPropertiesHUAWEIBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceSubpassShadingPropertiesHUAWEI {}
impl<'a> ::std::ops::Deref for PhysicalDeviceSubpassShadingPropertiesHUAWEIBuilder<'a> {
    type Target = PhysicalDeviceSubpassShadingPropertiesHUAWEI;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceSubpassShadingPropertiesHUAWEIBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceSubpassShadingPropertiesHUAWEIBuilder<'a> {
    #[inline]
    pub fn max_subpass_shading_workgroup_size_aspect_ratio(
        mut self,
        max_subpass_shading_workgroup_size_aspect_ratio: u32,
    ) -> Self {
        self.inner.max_subpass_shading_workgroup_size_aspect_ratio =
            max_subpass_shading_workgroup_size_aspect_ratio;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceSubpassShadingPropertiesHUAWEI {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI.html>"]
pub struct PhysicalDeviceClusterCullingShaderPropertiesHUAWEI {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_work_group_count: [u32; 3],
    pub max_work_group_size: [u32; 3],
    pub max_output_cluster_count: u32,
    pub indirect_buffer_offset_alignment: DeviceSize,
}
impl ::std::default::Default for PhysicalDeviceClusterCullingShaderPropertiesHUAWEI {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_work_group_count: unsafe { ::std::mem::zeroed() },
            max_work_group_size: unsafe { ::std::mem::zeroed() },
            max_output_cluster_count: u32::default(),
            indirect_buffer_offset_alignment: DeviceSize::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceClusterCullingShaderPropertiesHUAWEI {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI;
}
impl PhysicalDeviceClusterCullingShaderPropertiesHUAWEI {
    pub fn builder<'a>() -> PhysicalDeviceClusterCullingShaderPropertiesHUAWEIBuilder<'a> {
        PhysicalDeviceClusterCullingShaderPropertiesHUAWEIBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceClusterCullingShaderPropertiesHUAWEIBuilder<'a> {
    inner: PhysicalDeviceClusterCullingShaderPropertiesHUAWEI,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceClusterCullingShaderPropertiesHUAWEIBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceClusterCullingShaderPropertiesHUAWEI
{
}
impl<'a> ::std::ops::Deref for PhysicalDeviceClusterCullingShaderPropertiesHUAWEIBuilder<'a> {
    type Target = PhysicalDeviceClusterCullingShaderPropertiesHUAWEI;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceClusterCullingShaderPropertiesHUAWEIBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceClusterCullingShaderPropertiesHUAWEIBuilder<'a> {
    #[inline]
    pub fn max_work_group_count(mut self, max_work_group_count: [u32; 3]) -> Self {
        self.inner.max_work_group_count = max_work_group_count;
        self
    }
    #[inline]
    pub fn max_work_group_size(mut self, max_work_group_size: [u32; 3]) -> Self {
        self.inner.max_work_group_size = max_work_group_size;
        self
    }
    #[inline]
    pub fn max_output_cluster_count(mut self, max_output_cluster_count: u32) -> Self {
        self.inner.max_output_cluster_count = max_output_cluster_count;
        self
    }
    #[inline]
    pub fn indirect_buffer_offset_alignment(
        mut self,
        indirect_buffer_offset_alignment: DeviceSize,
    ) -> Self {
        self.inner.indirect_buffer_offset_alignment = indirect_buffer_offset_alignment;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceClusterCullingShaderPropertiesHUAWEI {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryOpaqueCaptureAddressAllocateInfo.html>"]
pub struct MemoryOpaqueCaptureAddressAllocateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub opaque_capture_address: u64,
}
impl ::std::default::Default for MemoryOpaqueCaptureAddressAllocateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            opaque_capture_address: u64::default(),
        }
    }
}
unsafe impl TaggedStructure for MemoryOpaqueCaptureAddressAllocateInfo {
    const STRUCTURE_TYPE: StructureType =
        StructureType::MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO;
}
impl MemoryOpaqueCaptureAddressAllocateInfo {
    pub fn builder<'a>() -> MemoryOpaqueCaptureAddressAllocateInfoBuilder<'a> {
        MemoryOpaqueCaptureAddressAllocateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MemoryOpaqueCaptureAddressAllocateInfoBuilder<'a> {
    inner: MemoryOpaqueCaptureAddressAllocateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsMemoryAllocateInfo for MemoryOpaqueCaptureAddressAllocateInfoBuilder<'_> {}
unsafe impl ExtendsMemoryAllocateInfo for MemoryOpaqueCaptureAddressAllocateInfo {}
impl<'a> ::std::ops::Deref for MemoryOpaqueCaptureAddressAllocateInfoBuilder<'a> {
    type Target = MemoryOpaqueCaptureAddressAllocateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MemoryOpaqueCaptureAddressAllocateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MemoryOpaqueCaptureAddressAllocateInfoBuilder<'a> {
    #[inline]
    pub fn opaque_capture_address(mut self, opaque_capture_address: u64) -> Self {
        self.inner.opaque_capture_address = opaque_capture_address;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MemoryOpaqueCaptureAddressAllocateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceMemoryOpaqueCaptureAddressInfo.html>"]
pub struct DeviceMemoryOpaqueCaptureAddressInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: DeviceMemory,
}
impl ::std::default::Default for DeviceMemoryOpaqueCaptureAddressInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            memory: DeviceMemory::default(),
        }
    }
}
unsafe impl TaggedStructure for DeviceMemoryOpaqueCaptureAddressInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO;
}
impl DeviceMemoryOpaqueCaptureAddressInfo {
    pub fn builder<'a>() -> DeviceMemoryOpaqueCaptureAddressInfoBuilder<'a> {
        DeviceMemoryOpaqueCaptureAddressInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceMemoryOpaqueCaptureAddressInfoBuilder<'a> {
    inner: DeviceMemoryOpaqueCaptureAddressInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DeviceMemoryOpaqueCaptureAddressInfoBuilder<'a> {
    type Target = DeviceMemoryOpaqueCaptureAddressInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceMemoryOpaqueCaptureAddressInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceMemoryOpaqueCaptureAddressInfoBuilder<'a> {
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceMemoryOpaqueCaptureAddressInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLineRasterizationFeaturesEXT.html>"]
pub struct PhysicalDeviceLineRasterizationFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub rectangular_lines: Bool32,
    pub bresenham_lines: Bool32,
    pub smooth_lines: Bool32,
    pub stippled_rectangular_lines: Bool32,
    pub stippled_bresenham_lines: Bool32,
    pub stippled_smooth_lines: Bool32,
}
impl ::std::default::Default for PhysicalDeviceLineRasterizationFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            rectangular_lines: Bool32::default(),
            bresenham_lines: Bool32::default(),
            smooth_lines: Bool32::default(),
            stippled_rectangular_lines: Bool32::default(),
            stippled_bresenham_lines: Bool32::default(),
            stippled_smooth_lines: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceLineRasterizationFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT;
}
impl PhysicalDeviceLineRasterizationFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceLineRasterizationFeaturesEXTBuilder<'a> {
        PhysicalDeviceLineRasterizationFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceLineRasterizationFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceLineRasterizationFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceLineRasterizationFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceLineRasterizationFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceLineRasterizationFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceLineRasterizationFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceLineRasterizationFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceLineRasterizationFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceLineRasterizationFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceLineRasterizationFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn rectangular_lines(mut self, rectangular_lines: bool) -> Self {
        self.inner.rectangular_lines = rectangular_lines.into();
        self
    }
    #[inline]
    pub fn bresenham_lines(mut self, bresenham_lines: bool) -> Self {
        self.inner.bresenham_lines = bresenham_lines.into();
        self
    }
    #[inline]
    pub fn smooth_lines(mut self, smooth_lines: bool) -> Self {
        self.inner.smooth_lines = smooth_lines.into();
        self
    }
    #[inline]
    pub fn stippled_rectangular_lines(mut self, stippled_rectangular_lines: bool) -> Self {
        self.inner.stippled_rectangular_lines = stippled_rectangular_lines.into();
        self
    }
    #[inline]
    pub fn stippled_bresenham_lines(mut self, stippled_bresenham_lines: bool) -> Self {
        self.inner.stippled_bresenham_lines = stippled_bresenham_lines.into();
        self
    }
    #[inline]
    pub fn stippled_smooth_lines(mut self, stippled_smooth_lines: bool) -> Self {
        self.inner.stippled_smooth_lines = stippled_smooth_lines.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceLineRasterizationFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLineRasterizationPropertiesEXT.html>"]
pub struct PhysicalDeviceLineRasterizationPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub line_sub_pixel_precision_bits: u32,
}
impl ::std::default::Default for PhysicalDeviceLineRasterizationPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            line_sub_pixel_precision_bits: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceLineRasterizationPropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT;
}
impl PhysicalDeviceLineRasterizationPropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceLineRasterizationPropertiesEXTBuilder<'a> {
        PhysicalDeviceLineRasterizationPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceLineRasterizationPropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceLineRasterizationPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceLineRasterizationPropertiesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceLineRasterizationPropertiesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceLineRasterizationPropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceLineRasterizationPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceLineRasterizationPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceLineRasterizationPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn line_sub_pixel_precision_bits(mut self, line_sub_pixel_precision_bits: u32) -> Self {
        self.inner.line_sub_pixel_precision_bits = line_sub_pixel_precision_bits;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceLineRasterizationPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationLineStateCreateInfoEXT.html>"]
pub struct PipelineRasterizationLineStateCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub line_rasterization_mode: LineRasterizationModeEXT,
    pub stippled_line_enable: Bool32,
    pub line_stipple_factor: u32,
    pub line_stipple_pattern: u16,
}
impl ::std::default::Default for PipelineRasterizationLineStateCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            line_rasterization_mode: LineRasterizationModeEXT::default(),
            stippled_line_enable: Bool32::default(),
            line_stipple_factor: u32::default(),
            line_stipple_pattern: u16::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineRasterizationLineStateCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT;
}
impl PipelineRasterizationLineStateCreateInfoEXT {
    pub fn builder<'a>() -> PipelineRasterizationLineStateCreateInfoEXTBuilder<'a> {
        PipelineRasterizationLineStateCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineRasterizationLineStateCreateInfoEXTBuilder<'a> {
    inner: PipelineRasterizationLineStateCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPipelineRasterizationStateCreateInfo
    for PipelineRasterizationLineStateCreateInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsPipelineRasterizationStateCreateInfo
    for PipelineRasterizationLineStateCreateInfoEXT
{
}
impl<'a> ::std::ops::Deref for PipelineRasterizationLineStateCreateInfoEXTBuilder<'a> {
    type Target = PipelineRasterizationLineStateCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineRasterizationLineStateCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineRasterizationLineStateCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn line_rasterization_mode(
        mut self,
        line_rasterization_mode: LineRasterizationModeEXT,
    ) -> Self {
        self.inner.line_rasterization_mode = line_rasterization_mode;
        self
    }
    #[inline]
    pub fn stippled_line_enable(mut self, stippled_line_enable: bool) -> Self {
        self.inner.stippled_line_enable = stippled_line_enable.into();
        self
    }
    #[inline]
    pub fn line_stipple_factor(mut self, line_stipple_factor: u32) -> Self {
        self.inner.line_stipple_factor = line_stipple_factor;
        self
    }
    #[inline]
    pub fn line_stipple_pattern(mut self, line_stipple_pattern: u16) -> Self {
        self.inner.line_stipple_pattern = line_stipple_pattern;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineRasterizationLineStateCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelineCreationCacheControlFeatures.html>"]
pub struct PhysicalDevicePipelineCreationCacheControlFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pipeline_creation_cache_control: Bool32,
}
impl ::std::default::Default for PhysicalDevicePipelineCreationCacheControlFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            pipeline_creation_cache_control: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevicePipelineCreationCacheControlFeatures {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES;
}
impl PhysicalDevicePipelineCreationCacheControlFeatures {
    pub fn builder<'a>() -> PhysicalDevicePipelineCreationCacheControlFeaturesBuilder<'a> {
        PhysicalDevicePipelineCreationCacheControlFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevicePipelineCreationCacheControlFeaturesBuilder<'a> {
    inner: PhysicalDevicePipelineCreationCacheControlFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDevicePipelineCreationCacheControlFeaturesBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePipelineCreationCacheControlFeatures {}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDevicePipelineCreationCacheControlFeaturesBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePipelineCreationCacheControlFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDevicePipelineCreationCacheControlFeaturesBuilder<'a> {
    type Target = PhysicalDevicePipelineCreationCacheControlFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevicePipelineCreationCacheControlFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevicePipelineCreationCacheControlFeaturesBuilder<'a> {
    #[inline]
    pub fn pipeline_creation_cache_control(
        mut self,
        pipeline_creation_cache_control: bool,
    ) -> Self {
        self.inner.pipeline_creation_cache_control = pipeline_creation_cache_control.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevicePipelineCreationCacheControlFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan11Features.html>"]
pub struct PhysicalDeviceVulkan11Features {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub storage_buffer16_bit_access: Bool32,
    pub uniform_and_storage_buffer16_bit_access: Bool32,
    pub storage_push_constant16: Bool32,
    pub storage_input_output16: Bool32,
    pub multiview: Bool32,
    pub multiview_geometry_shader: Bool32,
    pub multiview_tessellation_shader: Bool32,
    pub variable_pointers_storage_buffer: Bool32,
    pub variable_pointers: Bool32,
    pub protected_memory: Bool32,
    pub sampler_ycbcr_conversion: Bool32,
    pub shader_draw_parameters: Bool32,
}
impl ::std::default::Default for PhysicalDeviceVulkan11Features {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            storage_buffer16_bit_access: Bool32::default(),
            uniform_and_storage_buffer16_bit_access: Bool32::default(),
            storage_push_constant16: Bool32::default(),
            storage_input_output16: Bool32::default(),
            multiview: Bool32::default(),
            multiview_geometry_shader: Bool32::default(),
            multiview_tessellation_shader: Bool32::default(),
            variable_pointers_storage_buffer: Bool32::default(),
            variable_pointers: Bool32::default(),
            protected_memory: Bool32::default(),
            sampler_ycbcr_conversion: Bool32::default(),
            shader_draw_parameters: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceVulkan11Features {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_VULKAN_1_1_FEATURES;
}
impl PhysicalDeviceVulkan11Features {
    pub fn builder<'a>() -> PhysicalDeviceVulkan11FeaturesBuilder<'a> {
        PhysicalDeviceVulkan11FeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceVulkan11FeaturesBuilder<'a> {
    inner: PhysicalDeviceVulkan11Features,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVulkan11FeaturesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVulkan11Features {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVulkan11FeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVulkan11Features {}
impl<'a> ::std::ops::Deref for PhysicalDeviceVulkan11FeaturesBuilder<'a> {
    type Target = PhysicalDeviceVulkan11Features;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceVulkan11FeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceVulkan11FeaturesBuilder<'a> {
    #[inline]
    pub fn storage_buffer16_bit_access(mut self, storage_buffer16_bit_access: bool) -> Self {
        self.inner.storage_buffer16_bit_access = storage_buffer16_bit_access.into();
        self
    }
    #[inline]
    pub fn uniform_and_storage_buffer16_bit_access(
        mut self,
        uniform_and_storage_buffer16_bit_access: bool,
    ) -> Self {
        self.inner.uniform_and_storage_buffer16_bit_access =
            uniform_and_storage_buffer16_bit_access.into();
        self
    }
    #[inline]
    pub fn storage_push_constant16(mut self, storage_push_constant16: bool) -> Self {
        self.inner.storage_push_constant16 = storage_push_constant16.into();
        self
    }
    #[inline]
    pub fn storage_input_output16(mut self, storage_input_output16: bool) -> Self {
        self.inner.storage_input_output16 = storage_input_output16.into();
        self
    }
    #[inline]
    pub fn multiview(mut self, multiview: bool) -> Self {
        self.inner.multiview = multiview.into();
        self
    }
    #[inline]
    pub fn multiview_geometry_shader(mut self, multiview_geometry_shader: bool) -> Self {
        self.inner.multiview_geometry_shader = multiview_geometry_shader.into();
        self
    }
    #[inline]
    pub fn multiview_tessellation_shader(mut self, multiview_tessellation_shader: bool) -> Self {
        self.inner.multiview_tessellation_shader = multiview_tessellation_shader.into();
        self
    }
    #[inline]
    pub fn variable_pointers_storage_buffer(
        mut self,
        variable_pointers_storage_buffer: bool,
    ) -> Self {
        self.inner.variable_pointers_storage_buffer = variable_pointers_storage_buffer.into();
        self
    }
    #[inline]
    pub fn variable_pointers(mut self, variable_pointers: bool) -> Self {
        self.inner.variable_pointers = variable_pointers.into();
        self
    }
    #[inline]
    pub fn protected_memory(mut self, protected_memory: bool) -> Self {
        self.inner.protected_memory = protected_memory.into();
        self
    }
    #[inline]
    pub fn sampler_ycbcr_conversion(mut self, sampler_ycbcr_conversion: bool) -> Self {
        self.inner.sampler_ycbcr_conversion = sampler_ycbcr_conversion.into();
        self
    }
    #[inline]
    pub fn shader_draw_parameters(mut self, shader_draw_parameters: bool) -> Self {
        self.inner.shader_draw_parameters = shader_draw_parameters.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceVulkan11Features {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan11Properties.html>"]
pub struct PhysicalDeviceVulkan11Properties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_uuid: [u8; UUID_SIZE],
    pub driver_uuid: [u8; UUID_SIZE],
    pub device_luid: [u8; LUID_SIZE],
    pub device_node_mask: u32,
    pub device_luid_valid: Bool32,
    pub subgroup_size: u32,
    pub subgroup_supported_stages: ShaderStageFlags,
    pub subgroup_supported_operations: SubgroupFeatureFlags,
    pub subgroup_quad_operations_in_all_stages: Bool32,
    pub point_clipping_behavior: PointClippingBehavior,
    pub max_multiview_view_count: u32,
    pub max_multiview_instance_index: u32,
    pub protected_no_fault: Bool32,
    pub max_per_set_descriptors: u32,
    pub max_memory_allocation_size: DeviceSize,
}
impl ::std::default::Default for PhysicalDeviceVulkan11Properties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            device_uuid: unsafe { ::std::mem::zeroed() },
            driver_uuid: unsafe { ::std::mem::zeroed() },
            device_luid: unsafe { ::std::mem::zeroed() },
            device_node_mask: u32::default(),
            device_luid_valid: Bool32::default(),
            subgroup_size: u32::default(),
            subgroup_supported_stages: ShaderStageFlags::default(),
            subgroup_supported_operations: SubgroupFeatureFlags::default(),
            subgroup_quad_operations_in_all_stages: Bool32::default(),
            point_clipping_behavior: PointClippingBehavior::default(),
            max_multiview_view_count: u32::default(),
            max_multiview_instance_index: u32::default(),
            protected_no_fault: Bool32::default(),
            max_per_set_descriptors: u32::default(),
            max_memory_allocation_size: DeviceSize::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceVulkan11Properties {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES;
}
impl PhysicalDeviceVulkan11Properties {
    pub fn builder<'a>() -> PhysicalDeviceVulkan11PropertiesBuilder<'a> {
        PhysicalDeviceVulkan11PropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceVulkan11PropertiesBuilder<'a> {
    inner: PhysicalDeviceVulkan11Properties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceVulkan11PropertiesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceVulkan11Properties {}
impl<'a> ::std::ops::Deref for PhysicalDeviceVulkan11PropertiesBuilder<'a> {
    type Target = PhysicalDeviceVulkan11Properties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceVulkan11PropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceVulkan11PropertiesBuilder<'a> {
    #[inline]
    pub fn device_uuid(mut self, device_uuid: [u8; UUID_SIZE]) -> Self {
        self.inner.device_uuid = device_uuid;
        self
    }
    #[inline]
    pub fn driver_uuid(mut self, driver_uuid: [u8; UUID_SIZE]) -> Self {
        self.inner.driver_uuid = driver_uuid;
        self
    }
    #[inline]
    pub fn device_luid(mut self, device_luid: [u8; LUID_SIZE]) -> Self {
        self.inner.device_luid = device_luid;
        self
    }
    #[inline]
    pub fn device_node_mask(mut self, device_node_mask: u32) -> Self {
        self.inner.device_node_mask = device_node_mask;
        self
    }
    #[inline]
    pub fn device_luid_valid(mut self, device_luid_valid: bool) -> Self {
        self.inner.device_luid_valid = device_luid_valid.into();
        self
    }
    #[inline]
    pub fn subgroup_size(mut self, subgroup_size: u32) -> Self {
        self.inner.subgroup_size = subgroup_size;
        self
    }
    #[inline]
    pub fn subgroup_supported_stages(
        mut self,
        subgroup_supported_stages: ShaderStageFlags,
    ) -> Self {
        self.inner.subgroup_supported_stages = subgroup_supported_stages;
        self
    }
    #[inline]
    pub fn subgroup_supported_operations(
        mut self,
        subgroup_supported_operations: SubgroupFeatureFlags,
    ) -> Self {
        self.inner.subgroup_supported_operations = subgroup_supported_operations;
        self
    }
    #[inline]
    pub fn subgroup_quad_operations_in_all_stages(
        mut self,
        subgroup_quad_operations_in_all_stages: bool,
    ) -> Self {
        self.inner.subgroup_quad_operations_in_all_stages =
            subgroup_quad_operations_in_all_stages.into();
        self
    }
    #[inline]
    pub fn point_clipping_behavior(
        mut self,
        point_clipping_behavior: PointClippingBehavior,
    ) -> Self {
        self.inner.point_clipping_behavior = point_clipping_behavior;
        self
    }
    #[inline]
    pub fn max_multiview_view_count(mut self, max_multiview_view_count: u32) -> Self {
        self.inner.max_multiview_view_count = max_multiview_view_count;
        self
    }
    #[inline]
    pub fn max_multiview_instance_index(mut self, max_multiview_instance_index: u32) -> Self {
        self.inner.max_multiview_instance_index = max_multiview_instance_index;
        self
    }
    #[inline]
    pub fn protected_no_fault(mut self, protected_no_fault: bool) -> Self {
        self.inner.protected_no_fault = protected_no_fault.into();
        self
    }
    #[inline]
    pub fn max_per_set_descriptors(mut self, max_per_set_descriptors: u32) -> Self {
        self.inner.max_per_set_descriptors = max_per_set_descriptors;
        self
    }
    #[inline]
    pub fn max_memory_allocation_size(mut self, max_memory_allocation_size: DeviceSize) -> Self {
        self.inner.max_memory_allocation_size = max_memory_allocation_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceVulkan11Properties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html>"]
pub struct PhysicalDeviceVulkan12Features {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub sampler_mirror_clamp_to_edge: Bool32,
    pub draw_indirect_count: Bool32,
    pub storage_buffer8_bit_access: Bool32,
    pub uniform_and_storage_buffer8_bit_access: Bool32,
    pub storage_push_constant8: Bool32,
    pub shader_buffer_int64_atomics: Bool32,
    pub shader_shared_int64_atomics: Bool32,
    pub shader_float16: Bool32,
    pub shader_int8: Bool32,
    pub descriptor_indexing: Bool32,
    pub shader_input_attachment_array_dynamic_indexing: Bool32,
    pub shader_uniform_texel_buffer_array_dynamic_indexing: Bool32,
    pub shader_storage_texel_buffer_array_dynamic_indexing: Bool32,
    pub shader_uniform_buffer_array_non_uniform_indexing: Bool32,
    pub shader_sampled_image_array_non_uniform_indexing: Bool32,
    pub shader_storage_buffer_array_non_uniform_indexing: Bool32,
    pub shader_storage_image_array_non_uniform_indexing: Bool32,
    pub shader_input_attachment_array_non_uniform_indexing: Bool32,
    pub shader_uniform_texel_buffer_array_non_uniform_indexing: Bool32,
    pub shader_storage_texel_buffer_array_non_uniform_indexing: Bool32,
    pub descriptor_binding_uniform_buffer_update_after_bind: Bool32,
    pub descriptor_binding_sampled_image_update_after_bind: Bool32,
    pub descriptor_binding_storage_image_update_after_bind: Bool32,
    pub descriptor_binding_storage_buffer_update_after_bind: Bool32,
    pub descriptor_binding_uniform_texel_buffer_update_after_bind: Bool32,
    pub descriptor_binding_storage_texel_buffer_update_after_bind: Bool32,
    pub descriptor_binding_update_unused_while_pending: Bool32,
    pub descriptor_binding_partially_bound: Bool32,
    pub descriptor_binding_variable_descriptor_count: Bool32,
    pub runtime_descriptor_array: Bool32,
    pub sampler_filter_minmax: Bool32,
    pub scalar_block_layout: Bool32,
    pub imageless_framebuffer: Bool32,
    pub uniform_buffer_standard_layout: Bool32,
    pub shader_subgroup_extended_types: Bool32,
    pub separate_depth_stencil_layouts: Bool32,
    pub host_query_reset: Bool32,
    pub timeline_semaphore: Bool32,
    pub buffer_device_address: Bool32,
    pub buffer_device_address_capture_replay: Bool32,
    pub buffer_device_address_multi_device: Bool32,
    pub vulkan_memory_model: Bool32,
    pub vulkan_memory_model_device_scope: Bool32,
    pub vulkan_memory_model_availability_visibility_chains: Bool32,
    pub shader_output_viewport_index: Bool32,
    pub shader_output_layer: Bool32,
    pub subgroup_broadcast_dynamic_id: Bool32,
}
impl ::std::default::Default for PhysicalDeviceVulkan12Features {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            sampler_mirror_clamp_to_edge: Bool32::default(),
            draw_indirect_count: Bool32::default(),
            storage_buffer8_bit_access: Bool32::default(),
            uniform_and_storage_buffer8_bit_access: Bool32::default(),
            storage_push_constant8: Bool32::default(),
            shader_buffer_int64_atomics: Bool32::default(),
            shader_shared_int64_atomics: Bool32::default(),
            shader_float16: Bool32::default(),
            shader_int8: Bool32::default(),
            descriptor_indexing: Bool32::default(),
            shader_input_attachment_array_dynamic_indexing: Bool32::default(),
            shader_uniform_texel_buffer_array_dynamic_indexing: Bool32::default(),
            shader_storage_texel_buffer_array_dynamic_indexing: Bool32::default(),
            shader_uniform_buffer_array_non_uniform_indexing: Bool32::default(),
            shader_sampled_image_array_non_uniform_indexing: Bool32::default(),
            shader_storage_buffer_array_non_uniform_indexing: Bool32::default(),
            shader_storage_image_array_non_uniform_indexing: Bool32::default(),
            shader_input_attachment_array_non_uniform_indexing: Bool32::default(),
            shader_uniform_texel_buffer_array_non_uniform_indexing: Bool32::default(),
            shader_storage_texel_buffer_array_non_uniform_indexing: Bool32::default(),
            descriptor_binding_uniform_buffer_update_after_bind: Bool32::default(),
            descriptor_binding_sampled_image_update_after_bind: Bool32::default(),
            descriptor_binding_storage_image_update_after_bind: Bool32::default(),
            descriptor_binding_storage_buffer_update_after_bind: Bool32::default(),
            descriptor_binding_uniform_texel_buffer_update_after_bind: Bool32::default(),
            descriptor_binding_storage_texel_buffer_update_after_bind: Bool32::default(),
            descriptor_binding_update_unused_while_pending: Bool32::default(),
            descriptor_binding_partially_bound: Bool32::default(),
            descriptor_binding_variable_descriptor_count: Bool32::default(),
            runtime_descriptor_array: Bool32::default(),
            sampler_filter_minmax: Bool32::default(),
            scalar_block_layout: Bool32::default(),
            imageless_framebuffer: Bool32::default(),
            uniform_buffer_standard_layout: Bool32::default(),
            shader_subgroup_extended_types: Bool32::default(),
            separate_depth_stencil_layouts: Bool32::default(),
            host_query_reset: Bool32::default(),
            timeline_semaphore: Bool32::default(),
            buffer_device_address: Bool32::default(),
            buffer_device_address_capture_replay: Bool32::default(),
            buffer_device_address_multi_device: Bool32::default(),
            vulkan_memory_model: Bool32::default(),
            vulkan_memory_model_device_scope: Bool32::default(),
            vulkan_memory_model_availability_visibility_chains: Bool32::default(),
            shader_output_viewport_index: Bool32::default(),
            shader_output_layer: Bool32::default(),
            subgroup_broadcast_dynamic_id: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceVulkan12Features {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_VULKAN_1_2_FEATURES;
}
impl PhysicalDeviceVulkan12Features {
    pub fn builder<'a>() -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
        PhysicalDeviceVulkan12FeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceVulkan12FeaturesBuilder<'a> {
    inner: PhysicalDeviceVulkan12Features,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVulkan12FeaturesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVulkan12Features {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVulkan12FeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVulkan12Features {}
impl<'a> ::std::ops::Deref for PhysicalDeviceVulkan12FeaturesBuilder<'a> {
    type Target = PhysicalDeviceVulkan12Features;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceVulkan12FeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
    #[inline]
    pub fn sampler_mirror_clamp_to_edge(mut self, sampler_mirror_clamp_to_edge: bool) -> Self {
        self.inner.sampler_mirror_clamp_to_edge = sampler_mirror_clamp_to_edge.into();
        self
    }
    #[inline]
    pub fn draw_indirect_count(mut self, draw_indirect_count: bool) -> Self {
        self.inner.draw_indirect_count = draw_indirect_count.into();
        self
    }
    #[inline]
    pub fn storage_buffer8_bit_access(mut self, storage_buffer8_bit_access: bool) -> Self {
        self.inner.storage_buffer8_bit_access = storage_buffer8_bit_access.into();
        self
    }
    #[inline]
    pub fn uniform_and_storage_buffer8_bit_access(
        mut self,
        uniform_and_storage_buffer8_bit_access: bool,
    ) -> Self {
        self.inner.uniform_and_storage_buffer8_bit_access =
            uniform_and_storage_buffer8_bit_access.into();
        self
    }
    #[inline]
    pub fn storage_push_constant8(mut self, storage_push_constant8: bool) -> Self {
        self.inner.storage_push_constant8 = storage_push_constant8.into();
        self
    }
    #[inline]
    pub fn shader_buffer_int64_atomics(mut self, shader_buffer_int64_atomics: bool) -> Self {
        self.inner.shader_buffer_int64_atomics = shader_buffer_int64_atomics.into();
        self
    }
    #[inline]
    pub fn shader_shared_int64_atomics(mut self, shader_shared_int64_atomics: bool) -> Self {
        self.inner.shader_shared_int64_atomics = shader_shared_int64_atomics.into();
        self
    }
    #[inline]
    pub fn shader_float16(mut self, shader_float16: bool) -> Self {
        self.inner.shader_float16 = shader_float16.into();
        self
    }
    #[inline]
    pub fn shader_int8(mut self, shader_int8: bool) -> Self {
        self.inner.shader_int8 = shader_int8.into();
        self
    }
    #[inline]
    pub fn descriptor_indexing(mut self, descriptor_indexing: bool) -> Self {
        self.inner.descriptor_indexing = descriptor_indexing.into();
        self
    }
    #[inline]
    pub fn shader_input_attachment_array_dynamic_indexing(
        mut self,
        shader_input_attachment_array_dynamic_indexing: bool,
    ) -> Self {
        self.inner.shader_input_attachment_array_dynamic_indexing =
            shader_input_attachment_array_dynamic_indexing.into();
        self
    }
    #[inline]
    pub fn shader_uniform_texel_buffer_array_dynamic_indexing(
        mut self,
        shader_uniform_texel_buffer_array_dynamic_indexing: bool,
    ) -> Self {
        self.inner
            .shader_uniform_texel_buffer_array_dynamic_indexing =
            shader_uniform_texel_buffer_array_dynamic_indexing.into();
        self
    }
    #[inline]
    pub fn shader_storage_texel_buffer_array_dynamic_indexing(
        mut self,
        shader_storage_texel_buffer_array_dynamic_indexing: bool,
    ) -> Self {
        self.inner
            .shader_storage_texel_buffer_array_dynamic_indexing =
            shader_storage_texel_buffer_array_dynamic_indexing.into();
        self
    }
    #[inline]
    pub fn shader_uniform_buffer_array_non_uniform_indexing(
        mut self,
        shader_uniform_buffer_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner.shader_uniform_buffer_array_non_uniform_indexing =
            shader_uniform_buffer_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn shader_sampled_image_array_non_uniform_indexing(
        mut self,
        shader_sampled_image_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner.shader_sampled_image_array_non_uniform_indexing =
            shader_sampled_image_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn shader_storage_buffer_array_non_uniform_indexing(
        mut self,
        shader_storage_buffer_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner.shader_storage_buffer_array_non_uniform_indexing =
            shader_storage_buffer_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_array_non_uniform_indexing(
        mut self,
        shader_storage_image_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner.shader_storage_image_array_non_uniform_indexing =
            shader_storage_image_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn shader_input_attachment_array_non_uniform_indexing(
        mut self,
        shader_input_attachment_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner
            .shader_input_attachment_array_non_uniform_indexing =
            shader_input_attachment_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn shader_uniform_texel_buffer_array_non_uniform_indexing(
        mut self,
        shader_uniform_texel_buffer_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner
            .shader_uniform_texel_buffer_array_non_uniform_indexing =
            shader_uniform_texel_buffer_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn shader_storage_texel_buffer_array_non_uniform_indexing(
        mut self,
        shader_storage_texel_buffer_array_non_uniform_indexing: bool,
    ) -> Self {
        self.inner
            .shader_storage_texel_buffer_array_non_uniform_indexing =
            shader_storage_texel_buffer_array_non_uniform_indexing.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_uniform_buffer_update_after_bind(
        mut self,
        descriptor_binding_uniform_buffer_update_after_bind: bool,
    ) -> Self {
        self.inner
            .descriptor_binding_uniform_buffer_update_after_bind =
            descriptor_binding_uniform_buffer_update_after_bind.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_sampled_image_update_after_bind(
        mut self,
        descriptor_binding_sampled_image_update_after_bind: bool,
    ) -> Self {
        self.inner
            .descriptor_binding_sampled_image_update_after_bind =
            descriptor_binding_sampled_image_update_after_bind.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_storage_image_update_after_bind(
        mut self,
        descriptor_binding_storage_image_update_after_bind: bool,
    ) -> Self {
        self.inner
            .descriptor_binding_storage_image_update_after_bind =
            descriptor_binding_storage_image_update_after_bind.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_storage_buffer_update_after_bind(
        mut self,
        descriptor_binding_storage_buffer_update_after_bind: bool,
    ) -> Self {
        self.inner
            .descriptor_binding_storage_buffer_update_after_bind =
            descriptor_binding_storage_buffer_update_after_bind.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_uniform_texel_buffer_update_after_bind(
        mut self,
        descriptor_binding_uniform_texel_buffer_update_after_bind: bool,
    ) -> Self {
        self.inner
            .descriptor_binding_uniform_texel_buffer_update_after_bind =
            descriptor_binding_uniform_texel_buffer_update_after_bind.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_storage_texel_buffer_update_after_bind(
        mut self,
        descriptor_binding_storage_texel_buffer_update_after_bind: bool,
    ) -> Self {
        self.inner
            .descriptor_binding_storage_texel_buffer_update_after_bind =
            descriptor_binding_storage_texel_buffer_update_after_bind.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_update_unused_while_pending(
        mut self,
        descriptor_binding_update_unused_while_pending: bool,
    ) -> Self {
        self.inner.descriptor_binding_update_unused_while_pending =
            descriptor_binding_update_unused_while_pending.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_partially_bound(
        mut self,
        descriptor_binding_partially_bound: bool,
    ) -> Self {
        self.inner.descriptor_binding_partially_bound = descriptor_binding_partially_bound.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_variable_descriptor_count(
        mut self,
        descriptor_binding_variable_descriptor_count: bool,
    ) -> Self {
        self.inner.descriptor_binding_variable_descriptor_count =
            descriptor_binding_variable_descriptor_count.into();
        self
    }
    #[inline]
    pub fn runtime_descriptor_array(mut self, runtime_descriptor_array: bool) -> Self {
        self.inner.runtime_descriptor_array = runtime_descriptor_array.into();
        self
    }
    #[inline]
    pub fn sampler_filter_minmax(mut self, sampler_filter_minmax: bool) -> Self {
        self.inner.sampler_filter_minmax = sampler_filter_minmax.into();
        self
    }
    #[inline]
    pub fn scalar_block_layout(mut self, scalar_block_layout: bool) -> Self {
        self.inner.scalar_block_layout = scalar_block_layout.into();
        self
    }
    #[inline]
    pub fn imageless_framebuffer(mut self, imageless_framebuffer: bool) -> Self {
        self.inner.imageless_framebuffer = imageless_framebuffer.into();
        self
    }
    #[inline]
    pub fn uniform_buffer_standard_layout(mut self, uniform_buffer_standard_layout: bool) -> Self {
        self.inner.uniform_buffer_standard_layout = uniform_buffer_standard_layout.into();
        self
    }
    #[inline]
    pub fn shader_subgroup_extended_types(mut self, shader_subgroup_extended_types: bool) -> Self {
        self.inner.shader_subgroup_extended_types = shader_subgroup_extended_types.into();
        self
    }
    #[inline]
    pub fn separate_depth_stencil_layouts(mut self, separate_depth_stencil_layouts: bool) -> Self {
        self.inner.separate_depth_stencil_layouts = separate_depth_stencil_layouts.into();
        self
    }
    #[inline]
    pub fn host_query_reset(mut self, host_query_reset: bool) -> Self {
        self.inner.host_query_reset = host_query_reset.into();
        self
    }
    #[inline]
    pub fn timeline_semaphore(mut self, timeline_semaphore: bool) -> Self {
        self.inner.timeline_semaphore = timeline_semaphore.into();
        self
    }
    #[inline]
    pub fn buffer_device_address(mut self, buffer_device_address: bool) -> Self {
        self.inner.buffer_device_address = buffer_device_address.into();
        self
    }
    #[inline]
    pub fn buffer_device_address_capture_replay(
        mut self,
        buffer_device_address_capture_replay: bool,
    ) -> Self {
        self.inner.buffer_device_address_capture_replay =
            buffer_device_address_capture_replay.into();
        self
    }
    #[inline]
    pub fn buffer_device_address_multi_device(
        mut self,
        buffer_device_address_multi_device: bool,
    ) -> Self {
        self.inner.buffer_device_address_multi_device = buffer_device_address_multi_device.into();
        self
    }
    #[inline]
    pub fn vulkan_memory_model(mut self, vulkan_memory_model: bool) -> Self {
        self.inner.vulkan_memory_model = vulkan_memory_model.into();
        self
    }
    #[inline]
    pub fn vulkan_memory_model_device_scope(
        mut self,
        vulkan_memory_model_device_scope: bool,
    ) -> Self {
        self.inner.vulkan_memory_model_device_scope = vulkan_memory_model_device_scope.into();
        self
    }
    #[inline]
    pub fn vulkan_memory_model_availability_visibility_chains(
        mut self,
        vulkan_memory_model_availability_visibility_chains: bool,
    ) -> Self {
        self.inner
            .vulkan_memory_model_availability_visibility_chains =
            vulkan_memory_model_availability_visibility_chains.into();
        self
    }
    #[inline]
    pub fn shader_output_viewport_index(mut self, shader_output_viewport_index: bool) -> Self {
        self.inner.shader_output_viewport_index = shader_output_viewport_index.into();
        self
    }
    #[inline]
    pub fn shader_output_layer(mut self, shader_output_layer: bool) -> Self {
        self.inner.shader_output_layer = shader_output_layer.into();
        self
    }
    #[inline]
    pub fn subgroup_broadcast_dynamic_id(mut self, subgroup_broadcast_dynamic_id: bool) -> Self {
        self.inner.subgroup_broadcast_dynamic_id = subgroup_broadcast_dynamic_id.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceVulkan12Features {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Properties.html>"]
pub struct PhysicalDeviceVulkan12Properties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub driver_id: DriverId,
    pub driver_name: [c_char; MAX_DRIVER_NAME_SIZE],
    pub driver_info: [c_char; MAX_DRIVER_INFO_SIZE],
    pub conformance_version: ConformanceVersion,
    pub denorm_behavior_independence: ShaderFloatControlsIndependence,
    pub rounding_mode_independence: ShaderFloatControlsIndependence,
    pub shader_signed_zero_inf_nan_preserve_float16: Bool32,
    pub shader_signed_zero_inf_nan_preserve_float32: Bool32,
    pub shader_signed_zero_inf_nan_preserve_float64: Bool32,
    pub shader_denorm_preserve_float16: Bool32,
    pub shader_denorm_preserve_float32: Bool32,
    pub shader_denorm_preserve_float64: Bool32,
    pub shader_denorm_flush_to_zero_float16: Bool32,
    pub shader_denorm_flush_to_zero_float32: Bool32,
    pub shader_denorm_flush_to_zero_float64: Bool32,
    pub shader_rounding_mode_rte_float16: Bool32,
    pub shader_rounding_mode_rte_float32: Bool32,
    pub shader_rounding_mode_rte_float64: Bool32,
    pub shader_rounding_mode_rtz_float16: Bool32,
    pub shader_rounding_mode_rtz_float32: Bool32,
    pub shader_rounding_mode_rtz_float64: Bool32,
    pub max_update_after_bind_descriptors_in_all_pools: u32,
    pub shader_uniform_buffer_array_non_uniform_indexing_native: Bool32,
    pub shader_sampled_image_array_non_uniform_indexing_native: Bool32,
    pub shader_storage_buffer_array_non_uniform_indexing_native: Bool32,
    pub shader_storage_image_array_non_uniform_indexing_native: Bool32,
    pub shader_input_attachment_array_non_uniform_indexing_native: Bool32,
    pub robust_buffer_access_update_after_bind: Bool32,
    pub quad_divergent_implicit_lod: Bool32,
    pub max_per_stage_descriptor_update_after_bind_samplers: u32,
    pub max_per_stage_descriptor_update_after_bind_uniform_buffers: u32,
    pub max_per_stage_descriptor_update_after_bind_storage_buffers: u32,
    pub max_per_stage_descriptor_update_after_bind_sampled_images: u32,
    pub max_per_stage_descriptor_update_after_bind_storage_images: u32,
    pub max_per_stage_descriptor_update_after_bind_input_attachments: u32,
    pub max_per_stage_update_after_bind_resources: u32,
    pub max_descriptor_set_update_after_bind_samplers: u32,
    pub max_descriptor_set_update_after_bind_uniform_buffers: u32,
    pub max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32,
    pub max_descriptor_set_update_after_bind_storage_buffers: u32,
    pub max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32,
    pub max_descriptor_set_update_after_bind_sampled_images: u32,
    pub max_descriptor_set_update_after_bind_storage_images: u32,
    pub max_descriptor_set_update_after_bind_input_attachments: u32,
    pub supported_depth_resolve_modes: ResolveModeFlags,
    pub supported_stencil_resolve_modes: ResolveModeFlags,
    pub independent_resolve_none: Bool32,
    pub independent_resolve: Bool32,
    pub filter_minmax_single_component_formats: Bool32,
    pub filter_minmax_image_component_mapping: Bool32,
    pub max_timeline_semaphore_value_difference: u64,
    pub framebuffer_integer_color_sample_counts: SampleCountFlags,
}
#[cfg(feature = "debug")]
impl fmt::Debug for PhysicalDeviceVulkan12Properties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceVulkan12Properties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("driver_id", &self.driver_id)
            .field("driver_name", &unsafe {
                ::std::ffi::CStr::from_ptr(self.driver_name.as_ptr())
            })
            .field("driver_info", &unsafe {
                ::std::ffi::CStr::from_ptr(self.driver_info.as_ptr())
            })
            .field("conformance_version", &self.conformance_version)
            .field(
                "denorm_behavior_independence",
                &self.denorm_behavior_independence,
            )
            .field(
                "rounding_mode_independence",
                &self.rounding_mode_independence,
            )
            .field(
                "shader_signed_zero_inf_nan_preserve_float16",
                &self.shader_signed_zero_inf_nan_preserve_float16,
            )
            .field(
                "shader_signed_zero_inf_nan_preserve_float32",
                &self.shader_signed_zero_inf_nan_preserve_float32,
            )
            .field(
                "shader_signed_zero_inf_nan_preserve_float64",
                &self.shader_signed_zero_inf_nan_preserve_float64,
            )
            .field(
                "shader_denorm_preserve_float16",
                &self.shader_denorm_preserve_float16,
            )
            .field(
                "shader_denorm_preserve_float32",
                &self.shader_denorm_preserve_float32,
            )
            .field(
                "shader_denorm_preserve_float64",
                &self.shader_denorm_preserve_float64,
            )
            .field(
                "shader_denorm_flush_to_zero_float16",
                &self.shader_denorm_flush_to_zero_float16,
            )
            .field(
                "shader_denorm_flush_to_zero_float32",
                &self.shader_denorm_flush_to_zero_float32,
            )
            .field(
                "shader_denorm_flush_to_zero_float64",
                &self.shader_denorm_flush_to_zero_float64,
            )
            .field(
                "shader_rounding_mode_rte_float16",
                &self.shader_rounding_mode_rte_float16,
            )
            .field(
                "shader_rounding_mode_rte_float32",
                &self.shader_rounding_mode_rte_float32,
            )
            .field(
                "shader_rounding_mode_rte_float64",
                &self.shader_rounding_mode_rte_float64,
            )
            .field(
                "shader_rounding_mode_rtz_float16",
                &self.shader_rounding_mode_rtz_float16,
            )
            .field(
                "shader_rounding_mode_rtz_float32",
                &self.shader_rounding_mode_rtz_float32,
            )
            .field(
                "shader_rounding_mode_rtz_float64",
                &self.shader_rounding_mode_rtz_float64,
            )
            .field(
                "max_update_after_bind_descriptors_in_all_pools",
                &self.max_update_after_bind_descriptors_in_all_pools,
            )
            .field(
                "shader_uniform_buffer_array_non_uniform_indexing_native",
                &self.shader_uniform_buffer_array_non_uniform_indexing_native,
            )
            .field(
                "shader_sampled_image_array_non_uniform_indexing_native",
                &self.shader_sampled_image_array_non_uniform_indexing_native,
            )
            .field(
                "shader_storage_buffer_array_non_uniform_indexing_native",
                &self.shader_storage_buffer_array_non_uniform_indexing_native,
            )
            .field(
                "shader_storage_image_array_non_uniform_indexing_native",
                &self.shader_storage_image_array_non_uniform_indexing_native,
            )
            .field(
                "shader_input_attachment_array_non_uniform_indexing_native",
                &self.shader_input_attachment_array_non_uniform_indexing_native,
            )
            .field(
                "robust_buffer_access_update_after_bind",
                &self.robust_buffer_access_update_after_bind,
            )
            .field(
                "quad_divergent_implicit_lod",
                &self.quad_divergent_implicit_lod,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_samplers",
                &self.max_per_stage_descriptor_update_after_bind_samplers,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_uniform_buffers",
                &self.max_per_stage_descriptor_update_after_bind_uniform_buffers,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_storage_buffers",
                &self.max_per_stage_descriptor_update_after_bind_storage_buffers,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_sampled_images",
                &self.max_per_stage_descriptor_update_after_bind_sampled_images,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_storage_images",
                &self.max_per_stage_descriptor_update_after_bind_storage_images,
            )
            .field(
                "max_per_stage_descriptor_update_after_bind_input_attachments",
                &self.max_per_stage_descriptor_update_after_bind_input_attachments,
            )
            .field(
                "max_per_stage_update_after_bind_resources",
                &self.max_per_stage_update_after_bind_resources,
            )
            .field(
                "max_descriptor_set_update_after_bind_samplers",
                &self.max_descriptor_set_update_after_bind_samplers,
            )
            .field(
                "max_descriptor_set_update_after_bind_uniform_buffers",
                &self.max_descriptor_set_update_after_bind_uniform_buffers,
            )
            .field(
                "max_descriptor_set_update_after_bind_uniform_buffers_dynamic",
                &self.max_descriptor_set_update_after_bind_uniform_buffers_dynamic,
            )
            .field(
                "max_descriptor_set_update_after_bind_storage_buffers",
                &self.max_descriptor_set_update_after_bind_storage_buffers,
            )
            .field(
                "max_descriptor_set_update_after_bind_storage_buffers_dynamic",
                &self.max_descriptor_set_update_after_bind_storage_buffers_dynamic,
            )
            .field(
                "max_descriptor_set_update_after_bind_sampled_images",
                &self.max_descriptor_set_update_after_bind_sampled_images,
            )
            .field(
                "max_descriptor_set_update_after_bind_storage_images",
                &self.max_descriptor_set_update_after_bind_storage_images,
            )
            .field(
                "max_descriptor_set_update_after_bind_input_attachments",
                &self.max_descriptor_set_update_after_bind_input_attachments,
            )
            .field(
                "supported_depth_resolve_modes",
                &self.supported_depth_resolve_modes,
            )
            .field(
                "supported_stencil_resolve_modes",
                &self.supported_stencil_resolve_modes,
            )
            .field("independent_resolve_none", &self.independent_resolve_none)
            .field("independent_resolve", &self.independent_resolve)
            .field(
                "filter_minmax_single_component_formats",
                &self.filter_minmax_single_component_formats,
            )
            .field(
                "filter_minmax_image_component_mapping",
                &self.filter_minmax_image_component_mapping,
            )
            .field(
                "max_timeline_semaphore_value_difference",
                &self.max_timeline_semaphore_value_difference,
            )
            .field(
                "framebuffer_integer_color_sample_counts",
                &self.framebuffer_integer_color_sample_counts,
            )
            .finish()
    }
}
impl ::std::default::Default for PhysicalDeviceVulkan12Properties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            driver_id: DriverId::default(),
            driver_name: unsafe { ::std::mem::zeroed() },
            driver_info: unsafe { ::std::mem::zeroed() },
            conformance_version: ConformanceVersion::default(),
            denorm_behavior_independence: ShaderFloatControlsIndependence::default(),
            rounding_mode_independence: ShaderFloatControlsIndependence::default(),
            shader_signed_zero_inf_nan_preserve_float16: Bool32::default(),
            shader_signed_zero_inf_nan_preserve_float32: Bool32::default(),
            shader_signed_zero_inf_nan_preserve_float64: Bool32::default(),
            shader_denorm_preserve_float16: Bool32::default(),
            shader_denorm_preserve_float32: Bool32::default(),
            shader_denorm_preserve_float64: Bool32::default(),
            shader_denorm_flush_to_zero_float16: Bool32::default(),
            shader_denorm_flush_to_zero_float32: Bool32::default(),
            shader_denorm_flush_to_zero_float64: Bool32::default(),
            shader_rounding_mode_rte_float16: Bool32::default(),
            shader_rounding_mode_rte_float32: Bool32::default(),
            shader_rounding_mode_rte_float64: Bool32::default(),
            shader_rounding_mode_rtz_float16: Bool32::default(),
            shader_rounding_mode_rtz_float32: Bool32::default(),
            shader_rounding_mode_rtz_float64: Bool32::default(),
            max_update_after_bind_descriptors_in_all_pools: u32::default(),
            shader_uniform_buffer_array_non_uniform_indexing_native: Bool32::default(),
            shader_sampled_image_array_non_uniform_indexing_native: Bool32::default(),
            shader_storage_buffer_array_non_uniform_indexing_native: Bool32::default(),
            shader_storage_image_array_non_uniform_indexing_native: Bool32::default(),
            shader_input_attachment_array_non_uniform_indexing_native: Bool32::default(),
            robust_buffer_access_update_after_bind: Bool32::default(),
            quad_divergent_implicit_lod: Bool32::default(),
            max_per_stage_descriptor_update_after_bind_samplers: u32::default(),
            max_per_stage_descriptor_update_after_bind_uniform_buffers: u32::default(),
            max_per_stage_descriptor_update_after_bind_storage_buffers: u32::default(),
            max_per_stage_descriptor_update_after_bind_sampled_images: u32::default(),
            max_per_stage_descriptor_update_after_bind_storage_images: u32::default(),
            max_per_stage_descriptor_update_after_bind_input_attachments: u32::default(),
            max_per_stage_update_after_bind_resources: u32::default(),
            max_descriptor_set_update_after_bind_samplers: u32::default(),
            max_descriptor_set_update_after_bind_uniform_buffers: u32::default(),
            max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32::default(),
            max_descriptor_set_update_after_bind_storage_buffers: u32::default(),
            max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32::default(),
            max_descriptor_set_update_after_bind_sampled_images: u32::default(),
            max_descriptor_set_update_after_bind_storage_images: u32::default(),
            max_descriptor_set_update_after_bind_input_attachments: u32::default(),
            supported_depth_resolve_modes: ResolveModeFlags::default(),
            supported_stencil_resolve_modes: ResolveModeFlags::default(),
            independent_resolve_none: Bool32::default(),
            independent_resolve: Bool32::default(),
            filter_minmax_single_component_formats: Bool32::default(),
            filter_minmax_image_component_mapping: Bool32::default(),
            max_timeline_semaphore_value_difference: u64::default(),
            framebuffer_integer_color_sample_counts: SampleCountFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceVulkan12Properties {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES;
}
impl PhysicalDeviceVulkan12Properties {
    pub fn builder<'a>() -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
        PhysicalDeviceVulkan12PropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceVulkan12PropertiesBuilder<'a> {
    inner: PhysicalDeviceVulkan12Properties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceVulkan12PropertiesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceVulkan12Properties {}
impl<'a> ::std::ops::Deref for PhysicalDeviceVulkan12PropertiesBuilder<'a> {
    type Target = PhysicalDeviceVulkan12Properties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceVulkan12PropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
    #[inline]
    pub fn driver_id(mut self, driver_id: DriverId) -> Self {
        self.inner.driver_id = driver_id;
        self
    }
    #[inline]
    pub fn driver_name(mut self, driver_name: [c_char; MAX_DRIVER_NAME_SIZE]) -> Self {
        self.inner.driver_name = driver_name;
        self
    }
    #[inline]
    pub fn driver_info(mut self, driver_info: [c_char; MAX_DRIVER_INFO_SIZE]) -> Self {
        self.inner.driver_info = driver_info;
        self
    }
    #[inline]
    pub fn conformance_version(mut self, conformance_version: ConformanceVersion) -> Self {
        self.inner.conformance_version = conformance_version;
        self
    }
    #[inline]
    pub fn denorm_behavior_independence(
        mut self,
        denorm_behavior_independence: ShaderFloatControlsIndependence,
    ) -> Self {
        self.inner.denorm_behavior_independence = denorm_behavior_independence;
        self
    }
    #[inline]
    pub fn rounding_mode_independence(
        mut self,
        rounding_mode_independence: ShaderFloatControlsIndependence,
    ) -> Self {
        self.inner.rounding_mode_independence = rounding_mode_independence;
        self
    }
    #[inline]
    pub fn shader_signed_zero_inf_nan_preserve_float16(
        mut self,
        shader_signed_zero_inf_nan_preserve_float16: bool,
    ) -> Self {
        self.inner.shader_signed_zero_inf_nan_preserve_float16 =
            shader_signed_zero_inf_nan_preserve_float16.into();
        self
    }
    #[inline]
    pub fn shader_signed_zero_inf_nan_preserve_float32(
        mut self,
        shader_signed_zero_inf_nan_preserve_float32: bool,
    ) -> Self {
        self.inner.shader_signed_zero_inf_nan_preserve_float32 =
            shader_signed_zero_inf_nan_preserve_float32.into();
        self
    }
    #[inline]
    pub fn shader_signed_zero_inf_nan_preserve_float64(
        mut self,
        shader_signed_zero_inf_nan_preserve_float64: bool,
    ) -> Self {
        self.inner.shader_signed_zero_inf_nan_preserve_float64 =
            shader_signed_zero_inf_nan_preserve_float64.into();
        self
    }
    #[inline]
    pub fn shader_denorm_preserve_float16(mut self, shader_denorm_preserve_float16: bool) -> Self {
        self.inner.shader_denorm_preserve_float16 = shader_denorm_preserve_float16.into();
        self
    }
    #[inline]
    pub fn shader_denorm_preserve_float32(mut self, shader_denorm_preserve_float32: bool) -> Self {
        self.inner.shader_denorm_preserve_float32 = shader_denorm_preserve_float32.into();
        self
    }
    #[inline]
    pub fn shader_denorm_preserve_float64(mut self, shader_denorm_preserve_float64: bool) -> Self {
        self.inner.shader_denorm_preserve_float64 = shader_denorm_preserve_float64.into();
        self
    }
    #[inline]
    pub fn shader_denorm_flush_to_zero_float16(
        mut self,
        shader_denorm_flush_to_zero_float16: bool,
    ) -> Self {
        self.inner.shader_denorm_flush_to_zero_float16 = shader_denorm_flush_to_zero_float16.into();
        self
    }
    #[inline]
    pub fn shader_denorm_flush_to_zero_float32(
        mut self,
        shader_denorm_flush_to_zero_float32: bool,
    ) -> Self {
        self.inner.shader_denorm_flush_to_zero_float32 = shader_denorm_flush_to_zero_float32.into();
        self
    }
    #[inline]
    pub fn shader_denorm_flush_to_zero_float64(
        mut self,
        shader_denorm_flush_to_zero_float64: bool,
    ) -> Self {
        self.inner.shader_denorm_flush_to_zero_float64 = shader_denorm_flush_to_zero_float64.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rte_float16(
        mut self,
        shader_rounding_mode_rte_float16: bool,
    ) -> Self {
        self.inner.shader_rounding_mode_rte_float16 = shader_rounding_mode_rte_float16.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rte_float32(
        mut self,
        shader_rounding_mode_rte_float32: bool,
    ) -> Self {
        self.inner.shader_rounding_mode_rte_float32 = shader_rounding_mode_rte_float32.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rte_float64(
        mut self,
        shader_rounding_mode_rte_float64: bool,
    ) -> Self {
        self.inner.shader_rounding_mode_rte_float64 = shader_rounding_mode_rte_float64.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rtz_float16(
        mut self,
        shader_rounding_mode_rtz_float16: bool,
    ) -> Self {
        self.inner.shader_rounding_mode_rtz_float16 = shader_rounding_mode_rtz_float16.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rtz_float32(
        mut self,
        shader_rounding_mode_rtz_float32: bool,
    ) -> Self {
        self.inner.shader_rounding_mode_rtz_float32 = shader_rounding_mode_rtz_float32.into();
        self
    }
    #[inline]
    pub fn shader_rounding_mode_rtz_float64(
        mut self,
        shader_rounding_mode_rtz_float64: bool,
    ) -> Self {
        self.inner.shader_rounding_mode_rtz_float64 = shader_rounding_mode_rtz_float64.into();
        self
    }
    #[inline]
    pub fn max_update_after_bind_descriptors_in_all_pools(
        mut self,
        max_update_after_bind_descriptors_in_all_pools: u32,
    ) -> Self {
        self.inner.max_update_after_bind_descriptors_in_all_pools =
            max_update_after_bind_descriptors_in_all_pools;
        self
    }
    #[inline]
    pub fn shader_uniform_buffer_array_non_uniform_indexing_native(
        mut self,
        shader_uniform_buffer_array_non_uniform_indexing_native: bool,
    ) -> Self {
        self.inner
            .shader_uniform_buffer_array_non_uniform_indexing_native =
            shader_uniform_buffer_array_non_uniform_indexing_native.into();
        self
    }
    #[inline]
    pub fn shader_sampled_image_array_non_uniform_indexing_native(
        mut self,
        shader_sampled_image_array_non_uniform_indexing_native: bool,
    ) -> Self {
        self.inner
            .shader_sampled_image_array_non_uniform_indexing_native =
            shader_sampled_image_array_non_uniform_indexing_native.into();
        self
    }
    #[inline]
    pub fn shader_storage_buffer_array_non_uniform_indexing_native(
        mut self,
        shader_storage_buffer_array_non_uniform_indexing_native: bool,
    ) -> Self {
        self.inner
            .shader_storage_buffer_array_non_uniform_indexing_native =
            shader_storage_buffer_array_non_uniform_indexing_native.into();
        self
    }
    #[inline]
    pub fn shader_storage_image_array_non_uniform_indexing_native(
        mut self,
        shader_storage_image_array_non_uniform_indexing_native: bool,
    ) -> Self {
        self.inner
            .shader_storage_image_array_non_uniform_indexing_native =
            shader_storage_image_array_non_uniform_indexing_native.into();
        self
    }
    #[inline]
    pub fn shader_input_attachment_array_non_uniform_indexing_native(
        mut self,
        shader_input_attachment_array_non_uniform_indexing_native: bool,
    ) -> Self {
        self.inner
            .shader_input_attachment_array_non_uniform_indexing_native =
            shader_input_attachment_array_non_uniform_indexing_native.into();
        self
    }
    #[inline]
    pub fn robust_buffer_access_update_after_bind(
        mut self,
        robust_buffer_access_update_after_bind: bool,
    ) -> Self {
        self.inner.robust_buffer_access_update_after_bind =
            robust_buffer_access_update_after_bind.into();
        self
    }
    #[inline]
    pub fn quad_divergent_implicit_lod(mut self, quad_divergent_implicit_lod: bool) -> Self {
        self.inner.quad_divergent_implicit_lod = quad_divergent_implicit_lod.into();
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_samplers(
        mut self,
        max_per_stage_descriptor_update_after_bind_samplers: u32,
    ) -> Self {
        self.inner
            .max_per_stage_descriptor_update_after_bind_samplers =
            max_per_stage_descriptor_update_after_bind_samplers;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_uniform_buffers(
        mut self,
        max_per_stage_descriptor_update_after_bind_uniform_buffers: u32,
    ) -> Self {
        self.inner
            .max_per_stage_descriptor_update_after_bind_uniform_buffers =
            max_per_stage_descriptor_update_after_bind_uniform_buffers;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_storage_buffers(
        mut self,
        max_per_stage_descriptor_update_after_bind_storage_buffers: u32,
    ) -> Self {
        self.inner
            .max_per_stage_descriptor_update_after_bind_storage_buffers =
            max_per_stage_descriptor_update_after_bind_storage_buffers;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_sampled_images(
        mut self,
        max_per_stage_descriptor_update_after_bind_sampled_images: u32,
    ) -> Self {
        self.inner
            .max_per_stage_descriptor_update_after_bind_sampled_images =
            max_per_stage_descriptor_update_after_bind_sampled_images;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_storage_images(
        mut self,
        max_per_stage_descriptor_update_after_bind_storage_images: u32,
    ) -> Self {
        self.inner
            .max_per_stage_descriptor_update_after_bind_storage_images =
            max_per_stage_descriptor_update_after_bind_storage_images;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_input_attachments(
        mut self,
        max_per_stage_descriptor_update_after_bind_input_attachments: u32,
    ) -> Self {
        self.inner
            .max_per_stage_descriptor_update_after_bind_input_attachments =
            max_per_stage_descriptor_update_after_bind_input_attachments;
        self
    }
    #[inline]
    pub fn max_per_stage_update_after_bind_resources(
        mut self,
        max_per_stage_update_after_bind_resources: u32,
    ) -> Self {
        self.inner.max_per_stage_update_after_bind_resources =
            max_per_stage_update_after_bind_resources;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_samplers(
        mut self,
        max_descriptor_set_update_after_bind_samplers: u32,
    ) -> Self {
        self.inner.max_descriptor_set_update_after_bind_samplers =
            max_descriptor_set_update_after_bind_samplers;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_uniform_buffers(
        mut self,
        max_descriptor_set_update_after_bind_uniform_buffers: u32,
    ) -> Self {
        self.inner
            .max_descriptor_set_update_after_bind_uniform_buffers =
            max_descriptor_set_update_after_bind_uniform_buffers;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_uniform_buffers_dynamic(
        mut self,
        max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32,
    ) -> Self {
        self.inner
            .max_descriptor_set_update_after_bind_uniform_buffers_dynamic =
            max_descriptor_set_update_after_bind_uniform_buffers_dynamic;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_storage_buffers(
        mut self,
        max_descriptor_set_update_after_bind_storage_buffers: u32,
    ) -> Self {
        self.inner
            .max_descriptor_set_update_after_bind_storage_buffers =
            max_descriptor_set_update_after_bind_storage_buffers;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_storage_buffers_dynamic(
        mut self,
        max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32,
    ) -> Self {
        self.inner
            .max_descriptor_set_update_after_bind_storage_buffers_dynamic =
            max_descriptor_set_update_after_bind_storage_buffers_dynamic;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_sampled_images(
        mut self,
        max_descriptor_set_update_after_bind_sampled_images: u32,
    ) -> Self {
        self.inner
            .max_descriptor_set_update_after_bind_sampled_images =
            max_descriptor_set_update_after_bind_sampled_images;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_storage_images(
        mut self,
        max_descriptor_set_update_after_bind_storage_images: u32,
    ) -> Self {
        self.inner
            .max_descriptor_set_update_after_bind_storage_images =
            max_descriptor_set_update_after_bind_storage_images;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_input_attachments(
        mut self,
        max_descriptor_set_update_after_bind_input_attachments: u32,
    ) -> Self {
        self.inner
            .max_descriptor_set_update_after_bind_input_attachments =
            max_descriptor_set_update_after_bind_input_attachments;
        self
    }
    #[inline]
    pub fn supported_depth_resolve_modes(
        mut self,
        supported_depth_resolve_modes: ResolveModeFlags,
    ) -> Self {
        self.inner.supported_depth_resolve_modes = supported_depth_resolve_modes;
        self
    }
    #[inline]
    pub fn supported_stencil_resolve_modes(
        mut self,
        supported_stencil_resolve_modes: ResolveModeFlags,
    ) -> Self {
        self.inner.supported_stencil_resolve_modes = supported_stencil_resolve_modes;
        self
    }
    #[inline]
    pub fn independent_resolve_none(mut self, independent_resolve_none: bool) -> Self {
        self.inner.independent_resolve_none = independent_resolve_none.into();
        self
    }
    #[inline]
    pub fn independent_resolve(mut self, independent_resolve: bool) -> Self {
        self.inner.independent_resolve = independent_resolve.into();
        self
    }
    #[inline]
    pub fn filter_minmax_single_component_formats(
        mut self,
        filter_minmax_single_component_formats: bool,
    ) -> Self {
        self.inner.filter_minmax_single_component_formats =
            filter_minmax_single_component_formats.into();
        self
    }
    #[inline]
    pub fn filter_minmax_image_component_mapping(
        mut self,
        filter_minmax_image_component_mapping: bool,
    ) -> Self {
        self.inner.filter_minmax_image_component_mapping =
            filter_minmax_image_component_mapping.into();
        self
    }
    #[inline]
    pub fn max_timeline_semaphore_value_difference(
        mut self,
        max_timeline_semaphore_value_difference: u64,
    ) -> Self {
        self.inner.max_timeline_semaphore_value_difference =
            max_timeline_semaphore_value_difference;
        self
    }
    #[inline]
    pub fn framebuffer_integer_color_sample_counts(
        mut self,
        framebuffer_integer_color_sample_counts: SampleCountFlags,
    ) -> Self {
        self.inner.framebuffer_integer_color_sample_counts =
            framebuffer_integer_color_sample_counts;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceVulkan12Properties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Features.html>"]
pub struct PhysicalDeviceVulkan13Features {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub robust_image_access: Bool32,
    pub inline_uniform_block: Bool32,
    pub descriptor_binding_inline_uniform_block_update_after_bind: Bool32,
    pub pipeline_creation_cache_control: Bool32,
    pub private_data: Bool32,
    pub shader_demote_to_helper_invocation: Bool32,
    pub shader_terminate_invocation: Bool32,
    pub subgroup_size_control: Bool32,
    pub compute_full_subgroups: Bool32,
    pub synchronization2: Bool32,
    pub texture_compression_astc_hdr: Bool32,
    pub shader_zero_initialize_workgroup_memory: Bool32,
    pub dynamic_rendering: Bool32,
    pub shader_integer_dot_product: Bool32,
    pub maintenance4: Bool32,
}
impl ::std::default::Default for PhysicalDeviceVulkan13Features {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            robust_image_access: Bool32::default(),
            inline_uniform_block: Bool32::default(),
            descriptor_binding_inline_uniform_block_update_after_bind: Bool32::default(),
            pipeline_creation_cache_control: Bool32::default(),
            private_data: Bool32::default(),
            shader_demote_to_helper_invocation: Bool32::default(),
            shader_terminate_invocation: Bool32::default(),
            subgroup_size_control: Bool32::default(),
            compute_full_subgroups: Bool32::default(),
            synchronization2: Bool32::default(),
            texture_compression_astc_hdr: Bool32::default(),
            shader_zero_initialize_workgroup_memory: Bool32::default(),
            dynamic_rendering: Bool32::default(),
            shader_integer_dot_product: Bool32::default(),
            maintenance4: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceVulkan13Features {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_VULKAN_1_3_FEATURES;
}
impl PhysicalDeviceVulkan13Features {
    pub fn builder<'a>() -> PhysicalDeviceVulkan13FeaturesBuilder<'a> {
        PhysicalDeviceVulkan13FeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceVulkan13FeaturesBuilder<'a> {
    inner: PhysicalDeviceVulkan13Features,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVulkan13FeaturesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVulkan13Features {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVulkan13FeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVulkan13Features {}
impl<'a> ::std::ops::Deref for PhysicalDeviceVulkan13FeaturesBuilder<'a> {
    type Target = PhysicalDeviceVulkan13Features;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceVulkan13FeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceVulkan13FeaturesBuilder<'a> {
    #[inline]
    pub fn robust_image_access(mut self, robust_image_access: bool) -> Self {
        self.inner.robust_image_access = robust_image_access.into();
        self
    }
    #[inline]
    pub fn inline_uniform_block(mut self, inline_uniform_block: bool) -> Self {
        self.inner.inline_uniform_block = inline_uniform_block.into();
        self
    }
    #[inline]
    pub fn descriptor_binding_inline_uniform_block_update_after_bind(
        mut self,
        descriptor_binding_inline_uniform_block_update_after_bind: bool,
    ) -> Self {
        self.inner
            .descriptor_binding_inline_uniform_block_update_after_bind =
            descriptor_binding_inline_uniform_block_update_after_bind.into();
        self
    }
    #[inline]
    pub fn pipeline_creation_cache_control(
        mut self,
        pipeline_creation_cache_control: bool,
    ) -> Self {
        self.inner.pipeline_creation_cache_control = pipeline_creation_cache_control.into();
        self
    }
    #[inline]
    pub fn private_data(mut self, private_data: bool) -> Self {
        self.inner.private_data = private_data.into();
        self
    }
    #[inline]
    pub fn shader_demote_to_helper_invocation(
        mut self,
        shader_demote_to_helper_invocation: bool,
    ) -> Self {
        self.inner.shader_demote_to_helper_invocation = shader_demote_to_helper_invocation.into();
        self
    }
    #[inline]
    pub fn shader_terminate_invocation(mut self, shader_terminate_invocation: bool) -> Self {
        self.inner.shader_terminate_invocation = shader_terminate_invocation.into();
        self
    }
    #[inline]
    pub fn subgroup_size_control(mut self, subgroup_size_control: bool) -> Self {
        self.inner.subgroup_size_control = subgroup_size_control.into();
        self
    }
    #[inline]
    pub fn compute_full_subgroups(mut self, compute_full_subgroups: bool) -> Self {
        self.inner.compute_full_subgroups = compute_full_subgroups.into();
        self
    }
    #[inline]
    pub fn synchronization2(mut self, synchronization2: bool) -> Self {
        self.inner.synchronization2 = synchronization2.into();
        self
    }
    #[inline]
    pub fn texture_compression_astc_hdr(mut self, texture_compression_astc_hdr: bool) -> Self {
        self.inner.texture_compression_astc_hdr = texture_compression_astc_hdr.into();
        self
    }
    #[inline]
    pub fn shader_zero_initialize_workgroup_memory(
        mut self,
        shader_zero_initialize_workgroup_memory: bool,
    ) -> Self {
        self.inner.shader_zero_initialize_workgroup_memory =
            shader_zero_initialize_workgroup_memory.into();
        self
    }
    #[inline]
    pub fn dynamic_rendering(mut self, dynamic_rendering: bool) -> Self {
        self.inner.dynamic_rendering = dynamic_rendering.into();
        self
    }
    #[inline]
    pub fn shader_integer_dot_product(mut self, shader_integer_dot_product: bool) -> Self {
        self.inner.shader_integer_dot_product = shader_integer_dot_product.into();
        self
    }
    #[inline]
    pub fn maintenance4(mut self, maintenance4: bool) -> Self {
        self.inner.maintenance4 = maintenance4.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceVulkan13Features {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Properties.html>"]
pub struct PhysicalDeviceVulkan13Properties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_subgroup_size: u32,
    pub max_subgroup_size: u32,
    pub max_compute_workgroup_subgroups: u32,
    pub required_subgroup_size_stages: ShaderStageFlags,
    pub max_inline_uniform_block_size: u32,
    pub max_per_stage_descriptor_inline_uniform_blocks: u32,
    pub max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
    pub max_descriptor_set_inline_uniform_blocks: u32,
    pub max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
    pub max_inline_uniform_total_size: u32,
    pub integer_dot_product8_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product8_bit_signed_accelerated: Bool32,
    pub integer_dot_product8_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_unsigned_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_signed_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product16_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product16_bit_signed_accelerated: Bool32,
    pub integer_dot_product16_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product32_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product32_bit_signed_accelerated: Bool32,
    pub integer_dot_product32_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product64_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product64_bit_signed_accelerated: Bool32,
    pub integer_dot_product64_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated:
        Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: Bool32,
    pub storage_texel_buffer_offset_alignment_bytes: DeviceSize,
    pub storage_texel_buffer_offset_single_texel_alignment: Bool32,
    pub uniform_texel_buffer_offset_alignment_bytes: DeviceSize,
    pub uniform_texel_buffer_offset_single_texel_alignment: Bool32,
    pub max_buffer_size: DeviceSize,
}
impl ::std::default::Default for PhysicalDeviceVulkan13Properties {
    #[inline]
    fn default() -> Self {
        Self { s_type : Self :: STRUCTURE_TYPE , p_next : :: std :: ptr :: null_mut () , min_subgroup_size : u32 :: default () , max_subgroup_size : u32 :: default () , max_compute_workgroup_subgroups : u32 :: default () , required_subgroup_size_stages : ShaderStageFlags :: default () , max_inline_uniform_block_size : u32 :: default () , max_per_stage_descriptor_inline_uniform_blocks : u32 :: default () , max_per_stage_descriptor_update_after_bind_inline_uniform_blocks : u32 :: default () , max_descriptor_set_inline_uniform_blocks : u32 :: default () , max_descriptor_set_update_after_bind_inline_uniform_blocks : u32 :: default () , max_inline_uniform_total_size : u32 :: default () , integer_dot_product8_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product8_bit_signed_accelerated : Bool32 :: default () , integer_dot_product8_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product4x8_bit_packed_unsigned_accelerated : Bool32 :: default () , integer_dot_product4x8_bit_packed_signed_accelerated : Bool32 :: default () , integer_dot_product4x8_bit_packed_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product16_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product16_bit_signed_accelerated : Bool32 :: default () , integer_dot_product16_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product32_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product32_bit_signed_accelerated : Bool32 :: default () , integer_dot_product32_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product64_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product64_bit_signed_accelerated : Bool32 :: default () , integer_dot_product64_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating8_bit_signed_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating16_bit_signed_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating32_bit_signed_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating64_bit_signed_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated : Bool32 :: default () , storage_texel_buffer_offset_alignment_bytes : DeviceSize :: default () , storage_texel_buffer_offset_single_texel_alignment : Bool32 :: default () , uniform_texel_buffer_offset_alignment_bytes : DeviceSize :: default () , uniform_texel_buffer_offset_single_texel_alignment : Bool32 :: default () , max_buffer_size : DeviceSize :: default () }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceVulkan13Properties {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES;
}
impl PhysicalDeviceVulkan13Properties {
    pub fn builder<'a>() -> PhysicalDeviceVulkan13PropertiesBuilder<'a> {
        PhysicalDeviceVulkan13PropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceVulkan13PropertiesBuilder<'a> {
    inner: PhysicalDeviceVulkan13Properties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceVulkan13PropertiesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceVulkan13Properties {}
impl<'a> ::std::ops::Deref for PhysicalDeviceVulkan13PropertiesBuilder<'a> {
    type Target = PhysicalDeviceVulkan13Properties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceVulkan13PropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceVulkan13PropertiesBuilder<'a> {
    #[inline]
    pub fn min_subgroup_size(mut self, min_subgroup_size: u32) -> Self {
        self.inner.min_subgroup_size = min_subgroup_size;
        self
    }
    #[inline]
    pub fn max_subgroup_size(mut self, max_subgroup_size: u32) -> Self {
        self.inner.max_subgroup_size = max_subgroup_size;
        self
    }
    #[inline]
    pub fn max_compute_workgroup_subgroups(mut self, max_compute_workgroup_subgroups: u32) -> Self {
        self.inner.max_compute_workgroup_subgroups = max_compute_workgroup_subgroups;
        self
    }
    #[inline]
    pub fn required_subgroup_size_stages(
        mut self,
        required_subgroup_size_stages: ShaderStageFlags,
    ) -> Self {
        self.inner.required_subgroup_size_stages = required_subgroup_size_stages;
        self
    }
    #[inline]
    pub fn max_inline_uniform_block_size(mut self, max_inline_uniform_block_size: u32) -> Self {
        self.inner.max_inline_uniform_block_size = max_inline_uniform_block_size;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_inline_uniform_blocks(
        mut self,
        max_per_stage_descriptor_inline_uniform_blocks: u32,
    ) -> Self {
        self.inner.max_per_stage_descriptor_inline_uniform_blocks =
            max_per_stage_descriptor_inline_uniform_blocks;
        self
    }
    #[inline]
    pub fn max_per_stage_descriptor_update_after_bind_inline_uniform_blocks(
        mut self,
        max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
    ) -> Self {
        self.inner
            .max_per_stage_descriptor_update_after_bind_inline_uniform_blocks =
            max_per_stage_descriptor_update_after_bind_inline_uniform_blocks;
        self
    }
    #[inline]
    pub fn max_descriptor_set_inline_uniform_blocks(
        mut self,
        max_descriptor_set_inline_uniform_blocks: u32,
    ) -> Self {
        self.inner.max_descriptor_set_inline_uniform_blocks =
            max_descriptor_set_inline_uniform_blocks;
        self
    }
    #[inline]
    pub fn max_descriptor_set_update_after_bind_inline_uniform_blocks(
        mut self,
        max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
    ) -> Self {
        self.inner
            .max_descriptor_set_update_after_bind_inline_uniform_blocks =
            max_descriptor_set_update_after_bind_inline_uniform_blocks;
        self
    }
    #[inline]
    pub fn max_inline_uniform_total_size(mut self, max_inline_uniform_total_size: u32) -> Self {
        self.inner.max_inline_uniform_total_size = max_inline_uniform_total_size;
        self
    }
    #[inline]
    pub fn integer_dot_product8_bit_unsigned_accelerated(
        mut self,
        integer_dot_product8_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.inner.integer_dot_product8_bit_unsigned_accelerated =
            integer_dot_product8_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product8_bit_signed_accelerated(
        mut self,
        integer_dot_product8_bit_signed_accelerated: bool,
    ) -> Self {
        self.inner.integer_dot_product8_bit_signed_accelerated =
            integer_dot_product8_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product8_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product8_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product8_bit_mixed_signedness_accelerated =
            integer_dot_product8_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product4x8_bit_packed_unsigned_accelerated(
        mut self,
        integer_dot_product4x8_bit_packed_unsigned_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product4x8_bit_packed_unsigned_accelerated =
            integer_dot_product4x8_bit_packed_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product4x8_bit_packed_signed_accelerated(
        mut self,
        integer_dot_product4x8_bit_packed_signed_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product4x8_bit_packed_signed_accelerated =
            integer_dot_product4x8_bit_packed_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product4x8_bit_packed_mixed_signedness_accelerated(
        mut self,
        integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product4x8_bit_packed_mixed_signedness_accelerated =
            integer_dot_product4x8_bit_packed_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product16_bit_unsigned_accelerated(
        mut self,
        integer_dot_product16_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.inner.integer_dot_product16_bit_unsigned_accelerated =
            integer_dot_product16_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product16_bit_signed_accelerated(
        mut self,
        integer_dot_product16_bit_signed_accelerated: bool,
    ) -> Self {
        self.inner.integer_dot_product16_bit_signed_accelerated =
            integer_dot_product16_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product16_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product16_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product16_bit_mixed_signedness_accelerated =
            integer_dot_product16_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product32_bit_unsigned_accelerated(
        mut self,
        integer_dot_product32_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.inner.integer_dot_product32_bit_unsigned_accelerated =
            integer_dot_product32_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product32_bit_signed_accelerated(
        mut self,
        integer_dot_product32_bit_signed_accelerated: bool,
    ) -> Self {
        self.inner.integer_dot_product32_bit_signed_accelerated =
            integer_dot_product32_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product32_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product32_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product32_bit_mixed_signedness_accelerated =
            integer_dot_product32_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product64_bit_unsigned_accelerated(
        mut self,
        integer_dot_product64_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.inner.integer_dot_product64_bit_unsigned_accelerated =
            integer_dot_product64_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product64_bit_signed_accelerated(
        mut self,
        integer_dot_product64_bit_signed_accelerated: bool,
    ) -> Self {
        self.inner.integer_dot_product64_bit_signed_accelerated =
            integer_dot_product64_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product64_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product64_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product64_bit_mixed_signedness_accelerated =
            integer_dot_product64_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated =
            integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating8_bit_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating8_bit_signed_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating8_bit_signed_accelerated =
            integer_dot_product_accumulating_saturating8_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated =
            integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated =
            integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated =
            integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated : bool,
    ) -> Self {
        self . inner . integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated = integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated . into () ;
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated =
            integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating16_bit_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating16_bit_signed_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating16_bit_signed_accelerated =
            integer_dot_product_accumulating_saturating16_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated =
            integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated =
            integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating32_bit_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating32_bit_signed_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating32_bit_signed_accelerated =
            integer_dot_product_accumulating_saturating32_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated =
            integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated =
            integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating64_bit_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating64_bit_signed_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating64_bit_signed_accelerated =
            integer_dot_product_accumulating_saturating64_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated =
            integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn storage_texel_buffer_offset_alignment_bytes(
        mut self,
        storage_texel_buffer_offset_alignment_bytes: DeviceSize,
    ) -> Self {
        self.inner.storage_texel_buffer_offset_alignment_bytes =
            storage_texel_buffer_offset_alignment_bytes;
        self
    }
    #[inline]
    pub fn storage_texel_buffer_offset_single_texel_alignment(
        mut self,
        storage_texel_buffer_offset_single_texel_alignment: bool,
    ) -> Self {
        self.inner
            .storage_texel_buffer_offset_single_texel_alignment =
            storage_texel_buffer_offset_single_texel_alignment.into();
        self
    }
    #[inline]
    pub fn uniform_texel_buffer_offset_alignment_bytes(
        mut self,
        uniform_texel_buffer_offset_alignment_bytes: DeviceSize,
    ) -> Self {
        self.inner.uniform_texel_buffer_offset_alignment_bytes =
            uniform_texel_buffer_offset_alignment_bytes;
        self
    }
    #[inline]
    pub fn uniform_texel_buffer_offset_single_texel_alignment(
        mut self,
        uniform_texel_buffer_offset_single_texel_alignment: bool,
    ) -> Self {
        self.inner
            .uniform_texel_buffer_offset_single_texel_alignment =
            uniform_texel_buffer_offset_single_texel_alignment.into();
        self
    }
    #[inline]
    pub fn max_buffer_size(mut self, max_buffer_size: DeviceSize) -> Self {
        self.inner.max_buffer_size = max_buffer_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceVulkan13Properties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCompilerControlCreateInfoAMD.html>"]
pub struct PipelineCompilerControlCreateInfoAMD {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub compiler_control_flags: PipelineCompilerControlFlagsAMD,
}
impl ::std::default::Default for PipelineCompilerControlCreateInfoAMD {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            compiler_control_flags: PipelineCompilerControlFlagsAMD::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineCompilerControlCreateInfoAMD {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD;
}
impl PipelineCompilerControlCreateInfoAMD {
    pub fn builder<'a>() -> PipelineCompilerControlCreateInfoAMDBuilder<'a> {
        PipelineCompilerControlCreateInfoAMDBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineCompilerControlCreateInfoAMDBuilder<'a> {
    inner: PipelineCompilerControlCreateInfoAMD,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsGraphicsPipelineCreateInfo for PipelineCompilerControlCreateInfoAMDBuilder<'_> {}
unsafe impl ExtendsGraphicsPipelineCreateInfo for PipelineCompilerControlCreateInfoAMD {}
unsafe impl ExtendsComputePipelineCreateInfo for PipelineCompilerControlCreateInfoAMDBuilder<'_> {}
unsafe impl ExtendsComputePipelineCreateInfo for PipelineCompilerControlCreateInfoAMD {}
impl<'a> ::std::ops::Deref for PipelineCompilerControlCreateInfoAMDBuilder<'a> {
    type Target = PipelineCompilerControlCreateInfoAMD;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineCompilerControlCreateInfoAMDBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineCompilerControlCreateInfoAMDBuilder<'a> {
    #[inline]
    pub fn compiler_control_flags(
        mut self,
        compiler_control_flags: PipelineCompilerControlFlagsAMD,
    ) -> Self {
        self.inner.compiler_control_flags = compiler_control_flags;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineCompilerControlCreateInfoAMD {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCoherentMemoryFeaturesAMD.html>"]
pub struct PhysicalDeviceCoherentMemoryFeaturesAMD {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_coherent_memory: Bool32,
}
impl ::std::default::Default for PhysicalDeviceCoherentMemoryFeaturesAMD {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            device_coherent_memory: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceCoherentMemoryFeaturesAMD {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD;
}
impl PhysicalDeviceCoherentMemoryFeaturesAMD {
    pub fn builder<'a>() -> PhysicalDeviceCoherentMemoryFeaturesAMDBuilder<'a> {
        PhysicalDeviceCoherentMemoryFeaturesAMDBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceCoherentMemoryFeaturesAMDBuilder<'a> {
    inner: PhysicalDeviceCoherentMemoryFeaturesAMD,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceCoherentMemoryFeaturesAMDBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceCoherentMemoryFeaturesAMD {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCoherentMemoryFeaturesAMDBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCoherentMemoryFeaturesAMD {}
impl<'a> ::std::ops::Deref for PhysicalDeviceCoherentMemoryFeaturesAMDBuilder<'a> {
    type Target = PhysicalDeviceCoherentMemoryFeaturesAMD;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceCoherentMemoryFeaturesAMDBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceCoherentMemoryFeaturesAMDBuilder<'a> {
    #[inline]
    pub fn device_coherent_memory(mut self, device_coherent_memory: bool) -> Self {
        self.inner.device_coherent_memory = device_coherent_memory.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceCoherentMemoryFeaturesAMD {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceToolProperties.html>"]
pub struct PhysicalDeviceToolProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub name: [c_char; MAX_EXTENSION_NAME_SIZE],
    pub version: [c_char; MAX_EXTENSION_NAME_SIZE],
    pub purposes: ToolPurposeFlags,
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
    pub layer: [c_char; MAX_EXTENSION_NAME_SIZE],
}
#[cfg(feature = "debug")]
impl fmt::Debug for PhysicalDeviceToolProperties {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("PhysicalDeviceToolProperties")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("name", &unsafe {
                ::std::ffi::CStr::from_ptr(self.name.as_ptr())
            })
            .field("version", &unsafe {
                ::std::ffi::CStr::from_ptr(self.version.as_ptr())
            })
            .field("purposes", &self.purposes)
            .field("description", &unsafe {
                ::std::ffi::CStr::from_ptr(self.description.as_ptr())
            })
            .field("layer", &unsafe {
                ::std::ffi::CStr::from_ptr(self.layer.as_ptr())
            })
            .finish()
    }
}
impl ::std::default::Default for PhysicalDeviceToolProperties {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            name: unsafe { ::std::mem::zeroed() },
            version: unsafe { ::std::mem::zeroed() },
            purposes: ToolPurposeFlags::default(),
            description: unsafe { ::std::mem::zeroed() },
            layer: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceToolProperties {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_TOOL_PROPERTIES;
}
impl PhysicalDeviceToolProperties {
    pub fn builder<'a>() -> PhysicalDeviceToolPropertiesBuilder<'a> {
        PhysicalDeviceToolPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceToolPropertiesBuilder<'a> {
    inner: PhysicalDeviceToolProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PhysicalDeviceToolPropertiesBuilder<'a> {
    type Target = PhysicalDeviceToolProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceToolPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceToolPropertiesBuilder<'a> {
    #[inline]
    pub fn name(mut self, name: [c_char; MAX_EXTENSION_NAME_SIZE]) -> Self {
        self.inner.name = name;
        self
    }
    #[inline]
    pub fn version(mut self, version: [c_char; MAX_EXTENSION_NAME_SIZE]) -> Self {
        self.inner.version = version;
        self
    }
    #[inline]
    pub fn purposes(mut self, purposes: ToolPurposeFlags) -> Self {
        self.inner.purposes = purposes;
        self
    }
    #[inline]
    pub fn description(mut self, description: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.inner.description = description;
        self
    }
    #[inline]
    pub fn layer(mut self, layer: [c_char; MAX_EXTENSION_NAME_SIZE]) -> Self {
        self.inner.layer = layer;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceToolProperties {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerCustomBorderColorCreateInfoEXT.html>"]
pub struct SamplerCustomBorderColorCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub custom_border_color: ClearColorValue,
    pub format: Format,
}
#[cfg(feature = "debug")]
impl fmt::Debug for SamplerCustomBorderColorCreateInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("SamplerCustomBorderColorCreateInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("custom_border_color", &"union")
            .field("format", &self.format)
            .finish()
    }
}
impl ::std::default::Default for SamplerCustomBorderColorCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            custom_border_color: ClearColorValue::default(),
            format: Format::default(),
        }
    }
}
unsafe impl TaggedStructure for SamplerCustomBorderColorCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT;
}
impl SamplerCustomBorderColorCreateInfoEXT {
    pub fn builder<'a>() -> SamplerCustomBorderColorCreateInfoEXTBuilder<'a> {
        SamplerCustomBorderColorCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SamplerCustomBorderColorCreateInfoEXTBuilder<'a> {
    inner: SamplerCustomBorderColorCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSamplerCreateInfo for SamplerCustomBorderColorCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsSamplerCreateInfo for SamplerCustomBorderColorCreateInfoEXT {}
impl<'a> ::std::ops::Deref for SamplerCustomBorderColorCreateInfoEXTBuilder<'a> {
    type Target = SamplerCustomBorderColorCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SamplerCustomBorderColorCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SamplerCustomBorderColorCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn custom_border_color(mut self, custom_border_color: ClearColorValue) -> Self {
        self.inner.custom_border_color = custom_border_color;
        self
    }
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.inner.format = format;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SamplerCustomBorderColorCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCustomBorderColorPropertiesEXT.html>"]
pub struct PhysicalDeviceCustomBorderColorPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_custom_border_color_samplers: u32,
}
impl ::std::default::Default for PhysicalDeviceCustomBorderColorPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_custom_border_color_samplers: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceCustomBorderColorPropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT;
}
impl PhysicalDeviceCustomBorderColorPropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceCustomBorderColorPropertiesEXTBuilder<'a> {
        PhysicalDeviceCustomBorderColorPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceCustomBorderColorPropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceCustomBorderColorPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceCustomBorderColorPropertiesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceCustomBorderColorPropertiesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceCustomBorderColorPropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceCustomBorderColorPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceCustomBorderColorPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceCustomBorderColorPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn max_custom_border_color_samplers(
        mut self,
        max_custom_border_color_samplers: u32,
    ) -> Self {
        self.inner.max_custom_border_color_samplers = max_custom_border_color_samplers;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceCustomBorderColorPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCustomBorderColorFeaturesEXT.html>"]
pub struct PhysicalDeviceCustomBorderColorFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub custom_border_colors: Bool32,
    pub custom_border_color_without_format: Bool32,
}
impl ::std::default::Default for PhysicalDeviceCustomBorderColorFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            custom_border_colors: Bool32::default(),
            custom_border_color_without_format: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceCustomBorderColorFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT;
}
impl PhysicalDeviceCustomBorderColorFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceCustomBorderColorFeaturesEXTBuilder<'a> {
        PhysicalDeviceCustomBorderColorFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceCustomBorderColorFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceCustomBorderColorFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceCustomBorderColorFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceCustomBorderColorFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCustomBorderColorFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCustomBorderColorFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceCustomBorderColorFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceCustomBorderColorFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceCustomBorderColorFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceCustomBorderColorFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn custom_border_colors(mut self, custom_border_colors: bool) -> Self {
        self.inner.custom_border_colors = custom_border_colors.into();
        self
    }
    #[inline]
    pub fn custom_border_color_without_format(
        mut self,
        custom_border_color_without_format: bool,
    ) -> Self {
        self.inner.custom_border_color_without_format = custom_border_color_without_format.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceCustomBorderColorFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerBorderColorComponentMappingCreateInfoEXT.html>"]
pub struct SamplerBorderColorComponentMappingCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub components: ComponentMapping,
    pub srgb: Bool32,
}
impl ::std::default::Default for SamplerBorderColorComponentMappingCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            components: ComponentMapping::default(),
            srgb: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for SamplerBorderColorComponentMappingCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT;
}
impl SamplerBorderColorComponentMappingCreateInfoEXT {
    pub fn builder<'a>() -> SamplerBorderColorComponentMappingCreateInfoEXTBuilder<'a> {
        SamplerBorderColorComponentMappingCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SamplerBorderColorComponentMappingCreateInfoEXTBuilder<'a> {
    inner: SamplerBorderColorComponentMappingCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSamplerCreateInfo
    for SamplerBorderColorComponentMappingCreateInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsSamplerCreateInfo for SamplerBorderColorComponentMappingCreateInfoEXT {}
impl<'a> ::std::ops::Deref for SamplerBorderColorComponentMappingCreateInfoEXTBuilder<'a> {
    type Target = SamplerBorderColorComponentMappingCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SamplerBorderColorComponentMappingCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SamplerBorderColorComponentMappingCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn components(mut self, components: ComponentMapping) -> Self {
        self.inner.components = components;
        self
    }
    #[inline]
    pub fn srgb(mut self, srgb: bool) -> Self {
        self.inner.srgb = srgb.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SamplerBorderColorComponentMappingCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceBorderColorSwizzleFeaturesEXT.html>"]
pub struct PhysicalDeviceBorderColorSwizzleFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub border_color_swizzle: Bool32,
    pub border_color_swizzle_from_image: Bool32,
}
impl ::std::default::Default for PhysicalDeviceBorderColorSwizzleFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            border_color_swizzle: Bool32::default(),
            border_color_swizzle_from_image: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceBorderColorSwizzleFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT;
}
impl PhysicalDeviceBorderColorSwizzleFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceBorderColorSwizzleFeaturesEXTBuilder<'a> {
        PhysicalDeviceBorderColorSwizzleFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceBorderColorSwizzleFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceBorderColorSwizzleFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceBorderColorSwizzleFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceBorderColorSwizzleFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceBorderColorSwizzleFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceBorderColorSwizzleFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceBorderColorSwizzleFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceBorderColorSwizzleFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceBorderColorSwizzleFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceBorderColorSwizzleFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn border_color_swizzle(mut self, border_color_swizzle: bool) -> Self {
        self.inner.border_color_swizzle = border_color_swizzle.into();
        self
    }
    #[inline]
    pub fn border_color_swizzle_from_image(
        mut self,
        border_color_swizzle_from_image: bool,
    ) -> Self {
        self.inner.border_color_swizzle_from_image = border_color_swizzle_from_image.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceBorderColorSwizzleFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceOrHostAddressKHR.html>"]
pub union DeviceOrHostAddressKHR {
    pub device_address: DeviceAddress,
    pub host_address: *mut c_void,
}
impl ::std::default::Default for DeviceOrHostAddressKHR {
    #[inline]
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceOrHostAddressConstKHR.html>"]
pub union DeviceOrHostAddressConstKHR {
    pub device_address: DeviceAddress,
    pub host_address: *const c_void,
}
impl ::std::default::Default for DeviceOrHostAddressConstKHR {
    #[inline]
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureGeometryTrianglesDataKHR.html>"]
pub struct AccelerationStructureGeometryTrianglesDataKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub vertex_format: Format,
    pub vertex_data: DeviceOrHostAddressConstKHR,
    pub vertex_stride: DeviceSize,
    pub max_vertex: u32,
    pub index_type: IndexType,
    pub index_data: DeviceOrHostAddressConstKHR,
    pub transform_data: DeviceOrHostAddressConstKHR,
}
#[cfg(feature = "debug")]
impl fmt::Debug for AccelerationStructureGeometryTrianglesDataKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureGeometryTrianglesDataKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("vertex_format", &self.vertex_format)
            .field("vertex_data", &"union")
            .field("vertex_stride", &self.vertex_stride)
            .field("max_vertex", &self.max_vertex)
            .field("index_type", &self.index_type)
            .field("index_data", &"union")
            .field("transform_data", &"union")
            .finish()
    }
}
impl ::std::default::Default for AccelerationStructureGeometryTrianglesDataKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            vertex_format: Format::default(),
            vertex_data: DeviceOrHostAddressConstKHR::default(),
            vertex_stride: DeviceSize::default(),
            max_vertex: u32::default(),
            index_type: IndexType::default(),
            index_data: DeviceOrHostAddressConstKHR::default(),
            transform_data: DeviceOrHostAddressConstKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for AccelerationStructureGeometryTrianglesDataKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR;
}
impl AccelerationStructureGeometryTrianglesDataKHR {
    pub fn builder<'a>() -> AccelerationStructureGeometryTrianglesDataKHRBuilder<'a> {
        AccelerationStructureGeometryTrianglesDataKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AccelerationStructureGeometryTrianglesDataKHRBuilder<'a> {
    inner: AccelerationStructureGeometryTrianglesDataKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsAccelerationStructureGeometryTrianglesDataKHR {}
impl<'a> ::std::ops::Deref for AccelerationStructureGeometryTrianglesDataKHRBuilder<'a> {
    type Target = AccelerationStructureGeometryTrianglesDataKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AccelerationStructureGeometryTrianglesDataKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AccelerationStructureGeometryTrianglesDataKHRBuilder<'a> {
    #[inline]
    pub fn vertex_format(mut self, vertex_format: Format) -> Self {
        self.inner.vertex_format = vertex_format;
        self
    }
    #[inline]
    pub fn vertex_data(mut self, vertex_data: DeviceOrHostAddressConstKHR) -> Self {
        self.inner.vertex_data = vertex_data;
        self
    }
    #[inline]
    pub fn vertex_stride(mut self, vertex_stride: DeviceSize) -> Self {
        self.inner.vertex_stride = vertex_stride;
        self
    }
    #[inline]
    pub fn max_vertex(mut self, max_vertex: u32) -> Self {
        self.inner.max_vertex = max_vertex;
        self
    }
    #[inline]
    pub fn index_type(mut self, index_type: IndexType) -> Self {
        self.inner.index_type = index_type;
        self
    }
    #[inline]
    pub fn index_data(mut self, index_data: DeviceOrHostAddressConstKHR) -> Self {
        self.inner.index_data = index_data;
        self
    }
    #[inline]
    pub fn transform_data(mut self, transform_data: DeviceOrHostAddressConstKHR) -> Self {
        self.inner.transform_data = transform_data;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsAccelerationStructureGeometryTrianglesDataKHR>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AccelerationStructureGeometryTrianglesDataKHR {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureGeometryAabbsDataKHR.html>"]
pub struct AccelerationStructureGeometryAabbsDataKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub data: DeviceOrHostAddressConstKHR,
    pub stride: DeviceSize,
}
#[cfg(feature = "debug")]
impl fmt::Debug for AccelerationStructureGeometryAabbsDataKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureGeometryAabbsDataKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("data", &"union")
            .field("stride", &self.stride)
            .finish()
    }
}
impl ::std::default::Default for AccelerationStructureGeometryAabbsDataKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            data: DeviceOrHostAddressConstKHR::default(),
            stride: DeviceSize::default(),
        }
    }
}
unsafe impl TaggedStructure for AccelerationStructureGeometryAabbsDataKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR;
}
impl AccelerationStructureGeometryAabbsDataKHR {
    pub fn builder<'a>() -> AccelerationStructureGeometryAabbsDataKHRBuilder<'a> {
        AccelerationStructureGeometryAabbsDataKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AccelerationStructureGeometryAabbsDataKHRBuilder<'a> {
    inner: AccelerationStructureGeometryAabbsDataKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for AccelerationStructureGeometryAabbsDataKHRBuilder<'a> {
    type Target = AccelerationStructureGeometryAabbsDataKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AccelerationStructureGeometryAabbsDataKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AccelerationStructureGeometryAabbsDataKHRBuilder<'a> {
    #[inline]
    pub fn data(mut self, data: DeviceOrHostAddressConstKHR) -> Self {
        self.inner.data = data;
        self
    }
    #[inline]
    pub fn stride(mut self, stride: DeviceSize) -> Self {
        self.inner.stride = stride;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AccelerationStructureGeometryAabbsDataKHR {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureGeometryInstancesDataKHR.html>"]
pub struct AccelerationStructureGeometryInstancesDataKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub array_of_pointers: Bool32,
    pub data: DeviceOrHostAddressConstKHR,
}
#[cfg(feature = "debug")]
impl fmt::Debug for AccelerationStructureGeometryInstancesDataKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureGeometryInstancesDataKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("array_of_pointers", &self.array_of_pointers)
            .field("data", &"union")
            .finish()
    }
}
impl ::std::default::Default for AccelerationStructureGeometryInstancesDataKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            array_of_pointers: Bool32::default(),
            data: DeviceOrHostAddressConstKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for AccelerationStructureGeometryInstancesDataKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR;
}
impl AccelerationStructureGeometryInstancesDataKHR {
    pub fn builder<'a>() -> AccelerationStructureGeometryInstancesDataKHRBuilder<'a> {
        AccelerationStructureGeometryInstancesDataKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AccelerationStructureGeometryInstancesDataKHRBuilder<'a> {
    inner: AccelerationStructureGeometryInstancesDataKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for AccelerationStructureGeometryInstancesDataKHRBuilder<'a> {
    type Target = AccelerationStructureGeometryInstancesDataKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AccelerationStructureGeometryInstancesDataKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AccelerationStructureGeometryInstancesDataKHRBuilder<'a> {
    #[inline]
    pub fn array_of_pointers(mut self, array_of_pointers: bool) -> Self {
        self.inner.array_of_pointers = array_of_pointers.into();
        self
    }
    #[inline]
    pub fn data(mut self, data: DeviceOrHostAddressConstKHR) -> Self {
        self.inner.data = data;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AccelerationStructureGeometryInstancesDataKHR {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureGeometryDataKHR.html>"]
pub union AccelerationStructureGeometryDataKHR {
    pub triangles: AccelerationStructureGeometryTrianglesDataKHR,
    pub aabbs: AccelerationStructureGeometryAabbsDataKHR,
    pub instances: AccelerationStructureGeometryInstancesDataKHR,
}
impl ::std::default::Default for AccelerationStructureGeometryDataKHR {
    #[inline]
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureGeometryKHR.html>"]
pub struct AccelerationStructureGeometryKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub geometry_type: GeometryTypeKHR,
    pub geometry: AccelerationStructureGeometryDataKHR,
    pub flags: GeometryFlagsKHR,
}
#[cfg(feature = "debug")]
impl fmt::Debug for AccelerationStructureGeometryKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureGeometryKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("geometry_type", &self.geometry_type)
            .field("geometry", &"union")
            .field("flags", &self.flags)
            .finish()
    }
}
impl ::std::default::Default for AccelerationStructureGeometryKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            geometry_type: GeometryTypeKHR::default(),
            geometry: AccelerationStructureGeometryDataKHR::default(),
            flags: GeometryFlagsKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for AccelerationStructureGeometryKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::ACCELERATION_STRUCTURE_GEOMETRY_KHR;
}
impl AccelerationStructureGeometryKHR {
    pub fn builder<'a>() -> AccelerationStructureGeometryKHRBuilder<'a> {
        AccelerationStructureGeometryKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AccelerationStructureGeometryKHRBuilder<'a> {
    inner: AccelerationStructureGeometryKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for AccelerationStructureGeometryKHRBuilder<'a> {
    type Target = AccelerationStructureGeometryKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AccelerationStructureGeometryKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AccelerationStructureGeometryKHRBuilder<'a> {
    #[inline]
    pub fn geometry_type(mut self, geometry_type: GeometryTypeKHR) -> Self {
        self.inner.geometry_type = geometry_type;
        self
    }
    #[inline]
    pub fn geometry(mut self, geometry: AccelerationStructureGeometryDataKHR) -> Self {
        self.inner.geometry = geometry;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: GeometryFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AccelerationStructureGeometryKHR {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureBuildGeometryInfoKHR.html>"]
pub struct AccelerationStructureBuildGeometryInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: AccelerationStructureTypeKHR,
    pub flags: BuildAccelerationStructureFlagsKHR,
    pub mode: BuildAccelerationStructureModeKHR,
    pub src_acceleration_structure: AccelerationStructureKHR,
    pub dst_acceleration_structure: AccelerationStructureKHR,
    pub geometry_count: u32,
    pub p_geometries: *const AccelerationStructureGeometryKHR,
    pub pp_geometries: *const *const AccelerationStructureGeometryKHR,
    pub scratch_data: DeviceOrHostAddressKHR,
}
#[cfg(feature = "debug")]
impl fmt::Debug for AccelerationStructureBuildGeometryInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureBuildGeometryInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ty", &self.ty)
            .field("flags", &self.flags)
            .field("mode", &self.mode)
            .field(
                "src_acceleration_structure",
                &self.src_acceleration_structure,
            )
            .field(
                "dst_acceleration_structure",
                &self.dst_acceleration_structure,
            )
            .field("geometry_count", &self.geometry_count)
            .field("p_geometries", &self.p_geometries)
            .field("pp_geometries", &self.pp_geometries)
            .field("scratch_data", &"union")
            .finish()
    }
}
impl ::std::default::Default for AccelerationStructureBuildGeometryInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            ty: AccelerationStructureTypeKHR::default(),
            flags: BuildAccelerationStructureFlagsKHR::default(),
            mode: BuildAccelerationStructureModeKHR::default(),
            src_acceleration_structure: AccelerationStructureKHR::default(),
            dst_acceleration_structure: AccelerationStructureKHR::default(),
            geometry_count: u32::default(),
            p_geometries: ::std::ptr::null(),
            pp_geometries: ::std::ptr::null(),
            scratch_data: DeviceOrHostAddressKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for AccelerationStructureBuildGeometryInfoKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR;
}
impl AccelerationStructureBuildGeometryInfoKHR {
    pub fn builder<'a>() -> AccelerationStructureBuildGeometryInfoKHRBuilder<'a> {
        AccelerationStructureBuildGeometryInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AccelerationStructureBuildGeometryInfoKHRBuilder<'a> {
    inner: AccelerationStructureBuildGeometryInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for AccelerationStructureBuildGeometryInfoKHRBuilder<'a> {
    type Target = AccelerationStructureBuildGeometryInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AccelerationStructureBuildGeometryInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AccelerationStructureBuildGeometryInfoKHRBuilder<'a> {
    #[inline]
    pub fn ty(mut self, ty: AccelerationStructureTypeKHR) -> Self {
        self.inner.ty = ty;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: BuildAccelerationStructureFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn mode(mut self, mode: BuildAccelerationStructureModeKHR) -> Self {
        self.inner.mode = mode;
        self
    }
    #[inline]
    pub fn src_acceleration_structure(
        mut self,
        src_acceleration_structure: AccelerationStructureKHR,
    ) -> Self {
        self.inner.src_acceleration_structure = src_acceleration_structure;
        self
    }
    #[inline]
    pub fn dst_acceleration_structure(
        mut self,
        dst_acceleration_structure: AccelerationStructureKHR,
    ) -> Self {
        self.inner.dst_acceleration_structure = dst_acceleration_structure;
        self
    }
    #[inline]
    pub fn geometries(mut self, geometries: &'a [AccelerationStructureGeometryKHR]) -> Self {
        self.inner.geometry_count = geometries.len() as _;
        self.inner.p_geometries = geometries.as_ptr();
        self
    }
    #[inline]
    pub fn geometries_ptrs(
        mut self,
        geometries_ptrs: &'a [&'a AccelerationStructureGeometryKHR],
    ) -> Self {
        self.inner.geometry_count = geometries_ptrs.len() as _;
        self.inner.pp_geometries = geometries_ptrs.as_ptr().cast();
        self
    }
    #[inline]
    pub fn scratch_data(mut self, scratch_data: DeviceOrHostAddressKHR) -> Self {
        self.inner.scratch_data = scratch_data;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AccelerationStructureBuildGeometryInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureBuildRangeInfoKHR.html>"]
pub struct AccelerationStructureBuildRangeInfoKHR {
    pub primitive_count: u32,
    pub primitive_offset: u32,
    pub first_vertex: u32,
    pub transform_offset: u32,
}
impl AccelerationStructureBuildRangeInfoKHR {
    pub fn builder<'a>() -> AccelerationStructureBuildRangeInfoKHRBuilder<'a> {
        AccelerationStructureBuildRangeInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AccelerationStructureBuildRangeInfoKHRBuilder<'a> {
    inner: AccelerationStructureBuildRangeInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for AccelerationStructureBuildRangeInfoKHRBuilder<'a> {
    type Target = AccelerationStructureBuildRangeInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AccelerationStructureBuildRangeInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AccelerationStructureBuildRangeInfoKHRBuilder<'a> {
    #[inline]
    pub fn primitive_count(mut self, primitive_count: u32) -> Self {
        self.inner.primitive_count = primitive_count;
        self
    }
    #[inline]
    pub fn primitive_offset(mut self, primitive_offset: u32) -> Self {
        self.inner.primitive_offset = primitive_offset;
        self
    }
    #[inline]
    pub fn first_vertex(mut self, first_vertex: u32) -> Self {
        self.inner.first_vertex = first_vertex;
        self
    }
    #[inline]
    pub fn transform_offset(mut self, transform_offset: u32) -> Self {
        self.inner.transform_offset = transform_offset;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AccelerationStructureBuildRangeInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureCreateInfoKHR.html>"]
pub struct AccelerationStructureCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub create_flags: AccelerationStructureCreateFlagsKHR,
    pub buffer: Buffer,
    pub offset: DeviceSize,
    pub size: DeviceSize,
    pub ty: AccelerationStructureTypeKHR,
    pub device_address: DeviceAddress,
}
impl ::std::default::Default for AccelerationStructureCreateInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            create_flags: AccelerationStructureCreateFlagsKHR::default(),
            buffer: Buffer::default(),
            offset: DeviceSize::default(),
            size: DeviceSize::default(),
            ty: AccelerationStructureTypeKHR::default(),
            device_address: DeviceAddress::default(),
        }
    }
}
unsafe impl TaggedStructure for AccelerationStructureCreateInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::ACCELERATION_STRUCTURE_CREATE_INFO_KHR;
}
impl AccelerationStructureCreateInfoKHR {
    pub fn builder<'a>() -> AccelerationStructureCreateInfoKHRBuilder<'a> {
        AccelerationStructureCreateInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AccelerationStructureCreateInfoKHRBuilder<'a> {
    inner: AccelerationStructureCreateInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsAccelerationStructureCreateInfoKHR {}
impl<'a> ::std::ops::Deref for AccelerationStructureCreateInfoKHRBuilder<'a> {
    type Target = AccelerationStructureCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AccelerationStructureCreateInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AccelerationStructureCreateInfoKHRBuilder<'a> {
    #[inline]
    pub fn create_flags(mut self, create_flags: AccelerationStructureCreateFlagsKHR) -> Self {
        self.inner.create_flags = create_flags;
        self
    }
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: DeviceSize) -> Self {
        self.inner.offset = offset;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    #[inline]
    pub fn ty(mut self, ty: AccelerationStructureTypeKHR) -> Self {
        self.inner.ty = ty;
        self
    }
    #[inline]
    pub fn device_address(mut self, device_address: DeviceAddress) -> Self {
        self.inner.device_address = device_address;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsAccelerationStructureCreateInfoKHR>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AccelerationStructureCreateInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAabbPositionsKHR.html>"]
pub struct AabbPositionsKHR {
    pub min_x: f32,
    pub min_y: f32,
    pub min_z: f32,
    pub max_x: f32,
    pub max_y: f32,
    pub max_z: f32,
}
impl AabbPositionsKHR {
    pub fn builder<'a>() -> AabbPositionsKHRBuilder<'a> {
        AabbPositionsKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AabbPositionsKHRBuilder<'a> {
    inner: AabbPositionsKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for AabbPositionsKHRBuilder<'a> {
    type Target = AabbPositionsKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AabbPositionsKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AabbPositionsKHRBuilder<'a> {
    #[inline]
    pub fn min_x(mut self, min_x: f32) -> Self {
        self.inner.min_x = min_x;
        self
    }
    #[inline]
    pub fn min_y(mut self, min_y: f32) -> Self {
        self.inner.min_y = min_y;
        self
    }
    #[inline]
    pub fn min_z(mut self, min_z: f32) -> Self {
        self.inner.min_z = min_z;
        self
    }
    #[inline]
    pub fn max_x(mut self, max_x: f32) -> Self {
        self.inner.max_x = max_x;
        self
    }
    #[inline]
    pub fn max_y(mut self, max_y: f32) -> Self {
        self.inner.max_y = max_y;
        self
    }
    #[inline]
    pub fn max_z(mut self, max_z: f32) -> Self {
        self.inner.max_z = max_z;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AabbPositionsKHR {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TransformMatrixKHR {
    pub matrix: [f32; 12],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AccelerationStructureReferenceKHR {
    pub device_handle: DeviceAddress,
    pub host_handle: AccelerationStructureKHR,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureInstanceKHR.html>"]
pub struct AccelerationStructureInstanceKHR {
    pub transform: TransformMatrixKHR,
    #[doc = r" Use [`Packed24_8::new(instance_custom_index, mask)`][Packed24_8::new()] to construct this field"]
    pub instance_custom_index_and_mask: Packed24_8,
    #[doc = r" Use [`Packed24_8::new(instance_shader_binding_table_record_offset, flags)`][Packed24_8::new()] to construct this field"]
    pub instance_shader_binding_table_record_offset_and_flags: Packed24_8,
    pub acceleration_structure_reference: AccelerationStructureReferenceKHR,
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureDeviceAddressInfoKHR.html>"]
pub struct AccelerationStructureDeviceAddressInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acceleration_structure: AccelerationStructureKHR,
}
impl ::std::default::Default for AccelerationStructureDeviceAddressInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            acceleration_structure: AccelerationStructureKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for AccelerationStructureDeviceAddressInfoKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR;
}
impl AccelerationStructureDeviceAddressInfoKHR {
    pub fn builder<'a>() -> AccelerationStructureDeviceAddressInfoKHRBuilder<'a> {
        AccelerationStructureDeviceAddressInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AccelerationStructureDeviceAddressInfoKHRBuilder<'a> {
    inner: AccelerationStructureDeviceAddressInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for AccelerationStructureDeviceAddressInfoKHRBuilder<'a> {
    type Target = AccelerationStructureDeviceAddressInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AccelerationStructureDeviceAddressInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AccelerationStructureDeviceAddressInfoKHRBuilder<'a> {
    #[inline]
    pub fn acceleration_structure(
        mut self,
        acceleration_structure: AccelerationStructureKHR,
    ) -> Self {
        self.inner.acceleration_structure = acceleration_structure;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AccelerationStructureDeviceAddressInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureVersionInfoKHR.html>"]
pub struct AccelerationStructureVersionInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_version_data: *const [u8; 2 * UUID_SIZE],
}
impl ::std::default::Default for AccelerationStructureVersionInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_version_data: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for AccelerationStructureVersionInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::ACCELERATION_STRUCTURE_VERSION_INFO_KHR;
}
impl AccelerationStructureVersionInfoKHR {
    pub fn builder<'a>() -> AccelerationStructureVersionInfoKHRBuilder<'a> {
        AccelerationStructureVersionInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AccelerationStructureVersionInfoKHRBuilder<'a> {
    inner: AccelerationStructureVersionInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for AccelerationStructureVersionInfoKHRBuilder<'a> {
    type Target = AccelerationStructureVersionInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AccelerationStructureVersionInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AccelerationStructureVersionInfoKHRBuilder<'a> {
    #[inline]
    pub fn version_data(mut self, version_data: &'a [u8; 2 * UUID_SIZE]) -> Self {
        self.inner.p_version_data = version_data;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AccelerationStructureVersionInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyAccelerationStructureInfoKHR.html>"]
pub struct CopyAccelerationStructureInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src: AccelerationStructureKHR,
    pub dst: AccelerationStructureKHR,
    pub mode: CopyAccelerationStructureModeKHR,
}
impl ::std::default::Default for CopyAccelerationStructureInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src: AccelerationStructureKHR::default(),
            dst: AccelerationStructureKHR::default(),
            mode: CopyAccelerationStructureModeKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for CopyAccelerationStructureInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::COPY_ACCELERATION_STRUCTURE_INFO_KHR;
}
impl CopyAccelerationStructureInfoKHR {
    pub fn builder<'a>() -> CopyAccelerationStructureInfoKHRBuilder<'a> {
        CopyAccelerationStructureInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CopyAccelerationStructureInfoKHRBuilder<'a> {
    inner: CopyAccelerationStructureInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CopyAccelerationStructureInfoKHRBuilder<'a> {
    type Target = CopyAccelerationStructureInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CopyAccelerationStructureInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CopyAccelerationStructureInfoKHRBuilder<'a> {
    #[inline]
    pub fn src(mut self, src: AccelerationStructureKHR) -> Self {
        self.inner.src = src;
        self
    }
    #[inline]
    pub fn dst(mut self, dst: AccelerationStructureKHR) -> Self {
        self.inner.dst = dst;
        self
    }
    #[inline]
    pub fn mode(mut self, mode: CopyAccelerationStructureModeKHR) -> Self {
        self.inner.mode = mode;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CopyAccelerationStructureInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyAccelerationStructureToMemoryInfoKHR.html>"]
pub struct CopyAccelerationStructureToMemoryInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src: AccelerationStructureKHR,
    pub dst: DeviceOrHostAddressKHR,
    pub mode: CopyAccelerationStructureModeKHR,
}
#[cfg(feature = "debug")]
impl fmt::Debug for CopyAccelerationStructureToMemoryInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CopyAccelerationStructureToMemoryInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src", &self.src)
            .field("dst", &"union")
            .field("mode", &self.mode)
            .finish()
    }
}
impl ::std::default::Default for CopyAccelerationStructureToMemoryInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src: AccelerationStructureKHR::default(),
            dst: DeviceOrHostAddressKHR::default(),
            mode: CopyAccelerationStructureModeKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for CopyAccelerationStructureToMemoryInfoKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR;
}
impl CopyAccelerationStructureToMemoryInfoKHR {
    pub fn builder<'a>() -> CopyAccelerationStructureToMemoryInfoKHRBuilder<'a> {
        CopyAccelerationStructureToMemoryInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CopyAccelerationStructureToMemoryInfoKHRBuilder<'a> {
    inner: CopyAccelerationStructureToMemoryInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CopyAccelerationStructureToMemoryInfoKHRBuilder<'a> {
    type Target = CopyAccelerationStructureToMemoryInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CopyAccelerationStructureToMemoryInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CopyAccelerationStructureToMemoryInfoKHRBuilder<'a> {
    #[inline]
    pub fn src(mut self, src: AccelerationStructureKHR) -> Self {
        self.inner.src = src;
        self
    }
    #[inline]
    pub fn dst(mut self, dst: DeviceOrHostAddressKHR) -> Self {
        self.inner.dst = dst;
        self
    }
    #[inline]
    pub fn mode(mut self, mode: CopyAccelerationStructureModeKHR) -> Self {
        self.inner.mode = mode;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CopyAccelerationStructureToMemoryInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyMemoryToAccelerationStructureInfoKHR.html>"]
pub struct CopyMemoryToAccelerationStructureInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src: DeviceOrHostAddressConstKHR,
    pub dst: AccelerationStructureKHR,
    pub mode: CopyAccelerationStructureModeKHR,
}
#[cfg(feature = "debug")]
impl fmt::Debug for CopyMemoryToAccelerationStructureInfoKHR {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CopyMemoryToAccelerationStructureInfoKHR")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src", &"union")
            .field("dst", &self.dst)
            .field("mode", &self.mode)
            .finish()
    }
}
impl ::std::default::Default for CopyMemoryToAccelerationStructureInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src: DeviceOrHostAddressConstKHR::default(),
            dst: AccelerationStructureKHR::default(),
            mode: CopyAccelerationStructureModeKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for CopyMemoryToAccelerationStructureInfoKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR;
}
impl CopyMemoryToAccelerationStructureInfoKHR {
    pub fn builder<'a>() -> CopyMemoryToAccelerationStructureInfoKHRBuilder<'a> {
        CopyMemoryToAccelerationStructureInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CopyMemoryToAccelerationStructureInfoKHRBuilder<'a> {
    inner: CopyMemoryToAccelerationStructureInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CopyMemoryToAccelerationStructureInfoKHRBuilder<'a> {
    type Target = CopyMemoryToAccelerationStructureInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CopyMemoryToAccelerationStructureInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CopyMemoryToAccelerationStructureInfoKHRBuilder<'a> {
    #[inline]
    pub fn src(mut self, src: DeviceOrHostAddressConstKHR) -> Self {
        self.inner.src = src;
        self
    }
    #[inline]
    pub fn dst(mut self, dst: AccelerationStructureKHR) -> Self {
        self.inner.dst = dst;
        self
    }
    #[inline]
    pub fn mode(mut self, mode: CopyAccelerationStructureModeKHR) -> Self {
        self.inner.mode = mode;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CopyMemoryToAccelerationStructureInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRayTracingPipelineInterfaceCreateInfoKHR.html>"]
pub struct RayTracingPipelineInterfaceCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub max_pipeline_ray_payload_size: u32,
    pub max_pipeline_ray_hit_attribute_size: u32,
}
impl ::std::default::Default for RayTracingPipelineInterfaceCreateInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            max_pipeline_ray_payload_size: u32::default(),
            max_pipeline_ray_hit_attribute_size: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for RayTracingPipelineInterfaceCreateInfoKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR;
}
impl RayTracingPipelineInterfaceCreateInfoKHR {
    pub fn builder<'a>() -> RayTracingPipelineInterfaceCreateInfoKHRBuilder<'a> {
        RayTracingPipelineInterfaceCreateInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RayTracingPipelineInterfaceCreateInfoKHRBuilder<'a> {
    inner: RayTracingPipelineInterfaceCreateInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for RayTracingPipelineInterfaceCreateInfoKHRBuilder<'a> {
    type Target = RayTracingPipelineInterfaceCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RayTracingPipelineInterfaceCreateInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RayTracingPipelineInterfaceCreateInfoKHRBuilder<'a> {
    #[inline]
    pub fn max_pipeline_ray_payload_size(mut self, max_pipeline_ray_payload_size: u32) -> Self {
        self.inner.max_pipeline_ray_payload_size = max_pipeline_ray_payload_size;
        self
    }
    #[inline]
    pub fn max_pipeline_ray_hit_attribute_size(
        mut self,
        max_pipeline_ray_hit_attribute_size: u32,
    ) -> Self {
        self.inner.max_pipeline_ray_hit_attribute_size = max_pipeline_ray_hit_attribute_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RayTracingPipelineInterfaceCreateInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineLibraryCreateInfoKHR.html>"]
pub struct PipelineLibraryCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub library_count: u32,
    pub p_libraries: *const Pipeline,
}
impl ::std::default::Default for PipelineLibraryCreateInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            library_count: u32::default(),
            p_libraries: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for PipelineLibraryCreateInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_LIBRARY_CREATE_INFO_KHR;
}
impl PipelineLibraryCreateInfoKHR {
    pub fn builder<'a>() -> PipelineLibraryCreateInfoKHRBuilder<'a> {
        PipelineLibraryCreateInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineLibraryCreateInfoKHRBuilder<'a> {
    inner: PipelineLibraryCreateInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsGraphicsPipelineCreateInfo for PipelineLibraryCreateInfoKHRBuilder<'_> {}
unsafe impl ExtendsGraphicsPipelineCreateInfo for PipelineLibraryCreateInfoKHR {}
impl<'a> ::std::ops::Deref for PipelineLibraryCreateInfoKHRBuilder<'a> {
    type Target = PipelineLibraryCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineLibraryCreateInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineLibraryCreateInfoKHRBuilder<'a> {
    #[inline]
    pub fn libraries(mut self, libraries: &'a [Pipeline]) -> Self {
        self.inner.library_count = libraries.len() as _;
        self.inner.p_libraries = libraries.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineLibraryCreateInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicStateFeaturesEXT.html>"]
pub struct PhysicalDeviceExtendedDynamicStateFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub extended_dynamic_state: Bool32,
}
impl ::std::default::Default for PhysicalDeviceExtendedDynamicStateFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            extended_dynamic_state: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceExtendedDynamicStateFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT;
}
impl PhysicalDeviceExtendedDynamicStateFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceExtendedDynamicStateFeaturesEXTBuilder<'a> {
        PhysicalDeviceExtendedDynamicStateFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceExtendedDynamicStateFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceExtendedDynamicStateFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceExtendedDynamicStateFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceExtendedDynamicStateFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceExtendedDynamicStateFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceExtendedDynamicStateFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceExtendedDynamicStateFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceExtendedDynamicStateFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceExtendedDynamicStateFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceExtendedDynamicStateFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn extended_dynamic_state(mut self, extended_dynamic_state: bool) -> Self {
        self.inner.extended_dynamic_state = extended_dynamic_state.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceExtendedDynamicStateFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState2FeaturesEXT.html>"]
pub struct PhysicalDeviceExtendedDynamicState2FeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub extended_dynamic_state2: Bool32,
    pub extended_dynamic_state2_logic_op: Bool32,
    pub extended_dynamic_state2_patch_control_points: Bool32,
}
impl ::std::default::Default for PhysicalDeviceExtendedDynamicState2FeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            extended_dynamic_state2: Bool32::default(),
            extended_dynamic_state2_logic_op: Bool32::default(),
            extended_dynamic_state2_patch_control_points: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceExtendedDynamicState2FeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT;
}
impl PhysicalDeviceExtendedDynamicState2FeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceExtendedDynamicState2FeaturesEXTBuilder<'a> {
        PhysicalDeviceExtendedDynamicState2FeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceExtendedDynamicState2FeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceExtendedDynamicState2FeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceExtendedDynamicState2FeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceExtendedDynamicState2FeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceExtendedDynamicState2FeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceExtendedDynamicState2FeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceExtendedDynamicState2FeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceExtendedDynamicState2FeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceExtendedDynamicState2FeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceExtendedDynamicState2FeaturesEXTBuilder<'a> {
    #[inline]
    pub fn extended_dynamic_state2(mut self, extended_dynamic_state2: bool) -> Self {
        self.inner.extended_dynamic_state2 = extended_dynamic_state2.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state2_logic_op(
        mut self,
        extended_dynamic_state2_logic_op: bool,
    ) -> Self {
        self.inner.extended_dynamic_state2_logic_op = extended_dynamic_state2_logic_op.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state2_patch_control_points(
        mut self,
        extended_dynamic_state2_patch_control_points: bool,
    ) -> Self {
        self.inner.extended_dynamic_state2_patch_control_points =
            extended_dynamic_state2_patch_control_points.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceExtendedDynamicState2FeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html>"]
pub struct PhysicalDeviceExtendedDynamicState3FeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub extended_dynamic_state3_tessellation_domain_origin: Bool32,
    pub extended_dynamic_state3_depth_clamp_enable: Bool32,
    pub extended_dynamic_state3_polygon_mode: Bool32,
    pub extended_dynamic_state3_rasterization_samples: Bool32,
    pub extended_dynamic_state3_sample_mask: Bool32,
    pub extended_dynamic_state3_alpha_to_coverage_enable: Bool32,
    pub extended_dynamic_state3_alpha_to_one_enable: Bool32,
    pub extended_dynamic_state3_logic_op_enable: Bool32,
    pub extended_dynamic_state3_color_blend_enable: Bool32,
    pub extended_dynamic_state3_color_blend_equation: Bool32,
    pub extended_dynamic_state3_color_write_mask: Bool32,
    pub extended_dynamic_state3_rasterization_stream: Bool32,
    pub extended_dynamic_state3_conservative_rasterization_mode: Bool32,
    pub extended_dynamic_state3_extra_primitive_overestimation_size: Bool32,
    pub extended_dynamic_state3_depth_clip_enable: Bool32,
    pub extended_dynamic_state3_sample_locations_enable: Bool32,
    pub extended_dynamic_state3_color_blend_advanced: Bool32,
    pub extended_dynamic_state3_provoking_vertex_mode: Bool32,
    pub extended_dynamic_state3_line_rasterization_mode: Bool32,
    pub extended_dynamic_state3_line_stipple_enable: Bool32,
    pub extended_dynamic_state3_depth_clip_negative_one_to_one: Bool32,
    pub extended_dynamic_state3_viewport_w_scaling_enable: Bool32,
    pub extended_dynamic_state3_viewport_swizzle: Bool32,
    pub extended_dynamic_state3_coverage_to_color_enable: Bool32,
    pub extended_dynamic_state3_coverage_to_color_location: Bool32,
    pub extended_dynamic_state3_coverage_modulation_mode: Bool32,
    pub extended_dynamic_state3_coverage_modulation_table_enable: Bool32,
    pub extended_dynamic_state3_coverage_modulation_table: Bool32,
    pub extended_dynamic_state3_coverage_reduction_mode: Bool32,
    pub extended_dynamic_state3_representative_fragment_test_enable: Bool32,
    pub extended_dynamic_state3_shading_rate_image_enable: Bool32,
}
impl ::std::default::Default for PhysicalDeviceExtendedDynamicState3FeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            extended_dynamic_state3_tessellation_domain_origin: Bool32::default(),
            extended_dynamic_state3_depth_clamp_enable: Bool32::default(),
            extended_dynamic_state3_polygon_mode: Bool32::default(),
            extended_dynamic_state3_rasterization_samples: Bool32::default(),
            extended_dynamic_state3_sample_mask: Bool32::default(),
            extended_dynamic_state3_alpha_to_coverage_enable: Bool32::default(),
            extended_dynamic_state3_alpha_to_one_enable: Bool32::default(),
            extended_dynamic_state3_logic_op_enable: Bool32::default(),
            extended_dynamic_state3_color_blend_enable: Bool32::default(),
            extended_dynamic_state3_color_blend_equation: Bool32::default(),
            extended_dynamic_state3_color_write_mask: Bool32::default(),
            extended_dynamic_state3_rasterization_stream: Bool32::default(),
            extended_dynamic_state3_conservative_rasterization_mode: Bool32::default(),
            extended_dynamic_state3_extra_primitive_overestimation_size: Bool32::default(),
            extended_dynamic_state3_depth_clip_enable: Bool32::default(),
            extended_dynamic_state3_sample_locations_enable: Bool32::default(),
            extended_dynamic_state3_color_blend_advanced: Bool32::default(),
            extended_dynamic_state3_provoking_vertex_mode: Bool32::default(),
            extended_dynamic_state3_line_rasterization_mode: Bool32::default(),
            extended_dynamic_state3_line_stipple_enable: Bool32::default(),
            extended_dynamic_state3_depth_clip_negative_one_to_one: Bool32::default(),
            extended_dynamic_state3_viewport_w_scaling_enable: Bool32::default(),
            extended_dynamic_state3_viewport_swizzle: Bool32::default(),
            extended_dynamic_state3_coverage_to_color_enable: Bool32::default(),
            extended_dynamic_state3_coverage_to_color_location: Bool32::default(),
            extended_dynamic_state3_coverage_modulation_mode: Bool32::default(),
            extended_dynamic_state3_coverage_modulation_table_enable: Bool32::default(),
            extended_dynamic_state3_coverage_modulation_table: Bool32::default(),
            extended_dynamic_state3_coverage_reduction_mode: Bool32::default(),
            extended_dynamic_state3_representative_fragment_test_enable: Bool32::default(),
            extended_dynamic_state3_shading_rate_image_enable: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceExtendedDynamicState3FeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT;
}
impl PhysicalDeviceExtendedDynamicState3FeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceExtendedDynamicState3FeaturesEXTBuilder<'a> {
        PhysicalDeviceExtendedDynamicState3FeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceExtendedDynamicState3FeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceExtendedDynamicState3FeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceExtendedDynamicState3FeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceExtendedDynamicState3FeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceExtendedDynamicState3FeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceExtendedDynamicState3FeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceExtendedDynamicState3FeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceExtendedDynamicState3FeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceExtendedDynamicState3FeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceExtendedDynamicState3FeaturesEXTBuilder<'a> {
    #[inline]
    pub fn extended_dynamic_state3_tessellation_domain_origin(
        mut self,
        extended_dynamic_state3_tessellation_domain_origin: bool,
    ) -> Self {
        self.inner
            .extended_dynamic_state3_tessellation_domain_origin =
            extended_dynamic_state3_tessellation_domain_origin.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_depth_clamp_enable(
        mut self,
        extended_dynamic_state3_depth_clamp_enable: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_depth_clamp_enable =
            extended_dynamic_state3_depth_clamp_enable.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_polygon_mode(
        mut self,
        extended_dynamic_state3_polygon_mode: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_polygon_mode =
            extended_dynamic_state3_polygon_mode.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_rasterization_samples(
        mut self,
        extended_dynamic_state3_rasterization_samples: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_rasterization_samples =
            extended_dynamic_state3_rasterization_samples.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_sample_mask(
        mut self,
        extended_dynamic_state3_sample_mask: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_sample_mask = extended_dynamic_state3_sample_mask.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_alpha_to_coverage_enable(
        mut self,
        extended_dynamic_state3_alpha_to_coverage_enable: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_alpha_to_coverage_enable =
            extended_dynamic_state3_alpha_to_coverage_enable.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_alpha_to_one_enable(
        mut self,
        extended_dynamic_state3_alpha_to_one_enable: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_alpha_to_one_enable =
            extended_dynamic_state3_alpha_to_one_enable.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_logic_op_enable(
        mut self,
        extended_dynamic_state3_logic_op_enable: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_logic_op_enable =
            extended_dynamic_state3_logic_op_enable.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_color_blend_enable(
        mut self,
        extended_dynamic_state3_color_blend_enable: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_color_blend_enable =
            extended_dynamic_state3_color_blend_enable.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_color_blend_equation(
        mut self,
        extended_dynamic_state3_color_blend_equation: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_color_blend_equation =
            extended_dynamic_state3_color_blend_equation.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_color_write_mask(
        mut self,
        extended_dynamic_state3_color_write_mask: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_color_write_mask =
            extended_dynamic_state3_color_write_mask.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_rasterization_stream(
        mut self,
        extended_dynamic_state3_rasterization_stream: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_rasterization_stream =
            extended_dynamic_state3_rasterization_stream.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_conservative_rasterization_mode(
        mut self,
        extended_dynamic_state3_conservative_rasterization_mode: bool,
    ) -> Self {
        self.inner
            .extended_dynamic_state3_conservative_rasterization_mode =
            extended_dynamic_state3_conservative_rasterization_mode.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_extra_primitive_overestimation_size(
        mut self,
        extended_dynamic_state3_extra_primitive_overestimation_size: bool,
    ) -> Self {
        self.inner
            .extended_dynamic_state3_extra_primitive_overestimation_size =
            extended_dynamic_state3_extra_primitive_overestimation_size.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_depth_clip_enable(
        mut self,
        extended_dynamic_state3_depth_clip_enable: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_depth_clip_enable =
            extended_dynamic_state3_depth_clip_enable.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_sample_locations_enable(
        mut self,
        extended_dynamic_state3_sample_locations_enable: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_sample_locations_enable =
            extended_dynamic_state3_sample_locations_enable.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_color_blend_advanced(
        mut self,
        extended_dynamic_state3_color_blend_advanced: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_color_blend_advanced =
            extended_dynamic_state3_color_blend_advanced.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_provoking_vertex_mode(
        mut self,
        extended_dynamic_state3_provoking_vertex_mode: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_provoking_vertex_mode =
            extended_dynamic_state3_provoking_vertex_mode.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_line_rasterization_mode(
        mut self,
        extended_dynamic_state3_line_rasterization_mode: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_line_rasterization_mode =
            extended_dynamic_state3_line_rasterization_mode.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_line_stipple_enable(
        mut self,
        extended_dynamic_state3_line_stipple_enable: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_line_stipple_enable =
            extended_dynamic_state3_line_stipple_enable.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_depth_clip_negative_one_to_one(
        mut self,
        extended_dynamic_state3_depth_clip_negative_one_to_one: bool,
    ) -> Self {
        self.inner
            .extended_dynamic_state3_depth_clip_negative_one_to_one =
            extended_dynamic_state3_depth_clip_negative_one_to_one.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_viewport_w_scaling_enable(
        mut self,
        extended_dynamic_state3_viewport_w_scaling_enable: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_viewport_w_scaling_enable =
            extended_dynamic_state3_viewport_w_scaling_enable.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_viewport_swizzle(
        mut self,
        extended_dynamic_state3_viewport_swizzle: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_viewport_swizzle =
            extended_dynamic_state3_viewport_swizzle.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_coverage_to_color_enable(
        mut self,
        extended_dynamic_state3_coverage_to_color_enable: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_coverage_to_color_enable =
            extended_dynamic_state3_coverage_to_color_enable.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_coverage_to_color_location(
        mut self,
        extended_dynamic_state3_coverage_to_color_location: bool,
    ) -> Self {
        self.inner
            .extended_dynamic_state3_coverage_to_color_location =
            extended_dynamic_state3_coverage_to_color_location.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_coverage_modulation_mode(
        mut self,
        extended_dynamic_state3_coverage_modulation_mode: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_coverage_modulation_mode =
            extended_dynamic_state3_coverage_modulation_mode.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_coverage_modulation_table_enable(
        mut self,
        extended_dynamic_state3_coverage_modulation_table_enable: bool,
    ) -> Self {
        self.inner
            .extended_dynamic_state3_coverage_modulation_table_enable =
            extended_dynamic_state3_coverage_modulation_table_enable.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_coverage_modulation_table(
        mut self,
        extended_dynamic_state3_coverage_modulation_table: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_coverage_modulation_table =
            extended_dynamic_state3_coverage_modulation_table.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_coverage_reduction_mode(
        mut self,
        extended_dynamic_state3_coverage_reduction_mode: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_coverage_reduction_mode =
            extended_dynamic_state3_coverage_reduction_mode.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_representative_fragment_test_enable(
        mut self,
        extended_dynamic_state3_representative_fragment_test_enable: bool,
    ) -> Self {
        self.inner
            .extended_dynamic_state3_representative_fragment_test_enable =
            extended_dynamic_state3_representative_fragment_test_enable.into();
        self
    }
    #[inline]
    pub fn extended_dynamic_state3_shading_rate_image_enable(
        mut self,
        extended_dynamic_state3_shading_rate_image_enable: bool,
    ) -> Self {
        self.inner.extended_dynamic_state3_shading_rate_image_enable =
            extended_dynamic_state3_shading_rate_image_enable.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceExtendedDynamicState3FeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3PropertiesEXT.html>"]
pub struct PhysicalDeviceExtendedDynamicState3PropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub dynamic_primitive_topology_unrestricted: Bool32,
}
impl ::std::default::Default for PhysicalDeviceExtendedDynamicState3PropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            dynamic_primitive_topology_unrestricted: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceExtendedDynamicState3PropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT;
}
impl PhysicalDeviceExtendedDynamicState3PropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceExtendedDynamicState3PropertiesEXTBuilder<'a> {
        PhysicalDeviceExtendedDynamicState3PropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceExtendedDynamicState3PropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceExtendedDynamicState3PropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceExtendedDynamicState3PropertiesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceExtendedDynamicState3PropertiesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceExtendedDynamicState3PropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceExtendedDynamicState3PropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceExtendedDynamicState3PropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceExtendedDynamicState3PropertiesEXTBuilder<'a> {
    #[inline]
    pub fn dynamic_primitive_topology_unrestricted(
        mut self,
        dynamic_primitive_topology_unrestricted: bool,
    ) -> Self {
        self.inner.dynamic_primitive_topology_unrestricted =
            dynamic_primitive_topology_unrestricted.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceExtendedDynamicState3PropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkColorBlendEquationEXT.html>"]
pub struct ColorBlendEquationEXT {
    pub src_color_blend_factor: BlendFactor,
    pub dst_color_blend_factor: BlendFactor,
    pub color_blend_op: BlendOp,
    pub src_alpha_blend_factor: BlendFactor,
    pub dst_alpha_blend_factor: BlendFactor,
    pub alpha_blend_op: BlendOp,
}
impl ColorBlendEquationEXT {
    pub fn builder<'a>() -> ColorBlendEquationEXTBuilder<'a> {
        ColorBlendEquationEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ColorBlendEquationEXTBuilder<'a> {
    inner: ColorBlendEquationEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ColorBlendEquationEXTBuilder<'a> {
    type Target = ColorBlendEquationEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ColorBlendEquationEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ColorBlendEquationEXTBuilder<'a> {
    #[inline]
    pub fn src_color_blend_factor(mut self, src_color_blend_factor: BlendFactor) -> Self {
        self.inner.src_color_blend_factor = src_color_blend_factor;
        self
    }
    #[inline]
    pub fn dst_color_blend_factor(mut self, dst_color_blend_factor: BlendFactor) -> Self {
        self.inner.dst_color_blend_factor = dst_color_blend_factor;
        self
    }
    #[inline]
    pub fn color_blend_op(mut self, color_blend_op: BlendOp) -> Self {
        self.inner.color_blend_op = color_blend_op;
        self
    }
    #[inline]
    pub fn src_alpha_blend_factor(mut self, src_alpha_blend_factor: BlendFactor) -> Self {
        self.inner.src_alpha_blend_factor = src_alpha_blend_factor;
        self
    }
    #[inline]
    pub fn dst_alpha_blend_factor(mut self, dst_alpha_blend_factor: BlendFactor) -> Self {
        self.inner.dst_alpha_blend_factor = dst_alpha_blend_factor;
        self
    }
    #[inline]
    pub fn alpha_blend_op(mut self, alpha_blend_op: BlendOp) -> Self {
        self.inner.alpha_blend_op = alpha_blend_op;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ColorBlendEquationEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkColorBlendAdvancedEXT.html>"]
pub struct ColorBlendAdvancedEXT {
    pub advanced_blend_op: BlendOp,
    pub src_premultiplied: Bool32,
    pub dst_premultiplied: Bool32,
    pub blend_overlap: BlendOverlapEXT,
    pub clamp_results: Bool32,
}
impl ColorBlendAdvancedEXT {
    pub fn builder<'a>() -> ColorBlendAdvancedEXTBuilder<'a> {
        ColorBlendAdvancedEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ColorBlendAdvancedEXTBuilder<'a> {
    inner: ColorBlendAdvancedEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ColorBlendAdvancedEXTBuilder<'a> {
    type Target = ColorBlendAdvancedEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ColorBlendAdvancedEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ColorBlendAdvancedEXTBuilder<'a> {
    #[inline]
    pub fn advanced_blend_op(mut self, advanced_blend_op: BlendOp) -> Self {
        self.inner.advanced_blend_op = advanced_blend_op;
        self
    }
    #[inline]
    pub fn src_premultiplied(mut self, src_premultiplied: bool) -> Self {
        self.inner.src_premultiplied = src_premultiplied.into();
        self
    }
    #[inline]
    pub fn dst_premultiplied(mut self, dst_premultiplied: bool) -> Self {
        self.inner.dst_premultiplied = dst_premultiplied.into();
        self
    }
    #[inline]
    pub fn blend_overlap(mut self, blend_overlap: BlendOverlapEXT) -> Self {
        self.inner.blend_overlap = blend_overlap;
        self
    }
    #[inline]
    pub fn clamp_results(mut self, clamp_results: bool) -> Self {
        self.inner.clamp_results = clamp_results.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ColorBlendAdvancedEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassTransformBeginInfoQCOM.html>"]
pub struct RenderPassTransformBeginInfoQCOM {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub transform: SurfaceTransformFlagsKHR,
}
impl ::std::default::Default for RenderPassTransformBeginInfoQCOM {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            transform: SurfaceTransformFlagsKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for RenderPassTransformBeginInfoQCOM {
    const STRUCTURE_TYPE: StructureType = StructureType::RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM;
}
impl RenderPassTransformBeginInfoQCOM {
    pub fn builder<'a>() -> RenderPassTransformBeginInfoQCOMBuilder<'a> {
        RenderPassTransformBeginInfoQCOMBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RenderPassTransformBeginInfoQCOMBuilder<'a> {
    inner: RenderPassTransformBeginInfoQCOM,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsRenderPassBeginInfo for RenderPassTransformBeginInfoQCOMBuilder<'_> {}
unsafe impl ExtendsRenderPassBeginInfo for RenderPassTransformBeginInfoQCOM {}
impl<'a> ::std::ops::Deref for RenderPassTransformBeginInfoQCOMBuilder<'a> {
    type Target = RenderPassTransformBeginInfoQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RenderPassTransformBeginInfoQCOMBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RenderPassTransformBeginInfoQCOMBuilder<'a> {
    #[inline]
    pub fn transform(mut self, transform: SurfaceTransformFlagsKHR) -> Self {
        self.inner.transform = transform;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RenderPassTransformBeginInfoQCOM {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyCommandTransformInfoQCOM.html>"]
pub struct CopyCommandTransformInfoQCOM {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub transform: SurfaceTransformFlagsKHR,
}
impl ::std::default::Default for CopyCommandTransformInfoQCOM {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            transform: SurfaceTransformFlagsKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for CopyCommandTransformInfoQCOM {
    const STRUCTURE_TYPE: StructureType = StructureType::COPY_COMMAND_TRANSFORM_INFO_QCOM;
}
impl CopyCommandTransformInfoQCOM {
    pub fn builder<'a>() -> CopyCommandTransformInfoQCOMBuilder<'a> {
        CopyCommandTransformInfoQCOMBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CopyCommandTransformInfoQCOMBuilder<'a> {
    inner: CopyCommandTransformInfoQCOM,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsBufferImageCopy2 for CopyCommandTransformInfoQCOMBuilder<'_> {}
unsafe impl ExtendsBufferImageCopy2 for CopyCommandTransformInfoQCOM {}
unsafe impl ExtendsImageBlit2 for CopyCommandTransformInfoQCOMBuilder<'_> {}
unsafe impl ExtendsImageBlit2 for CopyCommandTransformInfoQCOM {}
impl<'a> ::std::ops::Deref for CopyCommandTransformInfoQCOMBuilder<'a> {
    type Target = CopyCommandTransformInfoQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CopyCommandTransformInfoQCOMBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CopyCommandTransformInfoQCOMBuilder<'a> {
    #[inline]
    pub fn transform(mut self, transform: SurfaceTransformFlagsKHR) -> Self {
        self.inner.transform = transform;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CopyCommandTransformInfoQCOM {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceRenderPassTransformInfoQCOM.html>"]
pub struct CommandBufferInheritanceRenderPassTransformInfoQCOM {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub transform: SurfaceTransformFlagsKHR,
    pub render_area: Rect2D,
}
impl ::std::default::Default for CommandBufferInheritanceRenderPassTransformInfoQCOM {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            transform: SurfaceTransformFlagsKHR::default(),
            render_area: Rect2D::default(),
        }
    }
}
unsafe impl TaggedStructure for CommandBufferInheritanceRenderPassTransformInfoQCOM {
    const STRUCTURE_TYPE: StructureType =
        StructureType::COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM;
}
impl CommandBufferInheritanceRenderPassTransformInfoQCOM {
    pub fn builder<'a>() -> CommandBufferInheritanceRenderPassTransformInfoQCOMBuilder<'a> {
        CommandBufferInheritanceRenderPassTransformInfoQCOMBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CommandBufferInheritanceRenderPassTransformInfoQCOMBuilder<'a> {
    inner: CommandBufferInheritanceRenderPassTransformInfoQCOM,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsCommandBufferInheritanceInfo
    for CommandBufferInheritanceRenderPassTransformInfoQCOMBuilder<'_>
{
}
unsafe impl ExtendsCommandBufferInheritanceInfo
    for CommandBufferInheritanceRenderPassTransformInfoQCOM
{
}
impl<'a> ::std::ops::Deref for CommandBufferInheritanceRenderPassTransformInfoQCOMBuilder<'a> {
    type Target = CommandBufferInheritanceRenderPassTransformInfoQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CommandBufferInheritanceRenderPassTransformInfoQCOMBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CommandBufferInheritanceRenderPassTransformInfoQCOMBuilder<'a> {
    #[inline]
    pub fn transform(mut self, transform: SurfaceTransformFlagsKHR) -> Self {
        self.inner.transform = transform;
        self
    }
    #[inline]
    pub fn render_area(mut self, render_area: Rect2D) -> Self {
        self.inner.render_area = render_area;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CommandBufferInheritanceRenderPassTransformInfoQCOM {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDiagnosticsConfigFeaturesNV.html>"]
pub struct PhysicalDeviceDiagnosticsConfigFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub diagnostics_config: Bool32,
}
impl ::std::default::Default for PhysicalDeviceDiagnosticsConfigFeaturesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            diagnostics_config: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceDiagnosticsConfigFeaturesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV;
}
impl PhysicalDeviceDiagnosticsConfigFeaturesNV {
    pub fn builder<'a>() -> PhysicalDeviceDiagnosticsConfigFeaturesNVBuilder<'a> {
        PhysicalDeviceDiagnosticsConfigFeaturesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceDiagnosticsConfigFeaturesNVBuilder<'a> {
    inner: PhysicalDeviceDiagnosticsConfigFeaturesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceDiagnosticsConfigFeaturesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDiagnosticsConfigFeaturesNV {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDiagnosticsConfigFeaturesNVBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDiagnosticsConfigFeaturesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceDiagnosticsConfigFeaturesNVBuilder<'a> {
    type Target = PhysicalDeviceDiagnosticsConfigFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceDiagnosticsConfigFeaturesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceDiagnosticsConfigFeaturesNVBuilder<'a> {
    #[inline]
    pub fn diagnostics_config(mut self, diagnostics_config: bool) -> Self {
        self.inner.diagnostics_config = diagnostics_config.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceDiagnosticsConfigFeaturesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceDiagnosticsConfigCreateInfoNV.html>"]
pub struct DeviceDiagnosticsConfigCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: DeviceDiagnosticsConfigFlagsNV,
}
impl ::std::default::Default for DeviceDiagnosticsConfigCreateInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: DeviceDiagnosticsConfigFlagsNV::default(),
        }
    }
}
unsafe impl TaggedStructure for DeviceDiagnosticsConfigCreateInfoNV {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV;
}
impl DeviceDiagnosticsConfigCreateInfoNV {
    pub fn builder<'a>() -> DeviceDiagnosticsConfigCreateInfoNVBuilder<'a> {
        DeviceDiagnosticsConfigCreateInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceDiagnosticsConfigCreateInfoNVBuilder<'a> {
    inner: DeviceDiagnosticsConfigCreateInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsDeviceCreateInfo for DeviceDiagnosticsConfigCreateInfoNVBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for DeviceDiagnosticsConfigCreateInfoNV {}
impl<'a> ::std::ops::Deref for DeviceDiagnosticsConfigCreateInfoNVBuilder<'a> {
    type Target = DeviceDiagnosticsConfigCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceDiagnosticsConfigCreateInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceDiagnosticsConfigCreateInfoNVBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: DeviceDiagnosticsConfigFlagsNV) -> Self {
        self.inner.flags = flags;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceDiagnosticsConfigCreateInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures.html>"]
pub struct PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_zero_initialize_workgroup_memory: Bool32,
}
impl ::std::default::Default for PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_zero_initialize_workgroup_memory: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES;
}
impl PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
    pub fn builder<'a>() -> PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder<'a> {
        PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder<'a> {
    inner: PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder<'a> {
    type Target = PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesBuilder<'a> {
    #[inline]
    pub fn shader_zero_initialize_workgroup_memory(
        mut self,
        shader_zero_initialize_workgroup_memory: bool,
    ) -> Self {
        self.inner.shader_zero_initialize_workgroup_memory =
            shader_zero_initialize_workgroup_memory.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR.html>"]
pub struct PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_subgroup_uniform_control_flow: Bool32,
}
impl ::std::default::Default for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_subgroup_uniform_control_flow: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR;
}
impl PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
    pub fn builder<'a>() -> PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRBuilder<'a> {
        PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRBuilder<'a> {
    inner: PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR
{
}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {}
impl<'a> ::std::ops::Deref
    for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRBuilder<'a>
{
    type Target = PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut
    for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRBuilder<'a>
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRBuilder<'a> {
    #[inline]
    pub fn shader_subgroup_uniform_control_flow(
        mut self,
        shader_subgroup_uniform_control_flow: bool,
    ) -> Self {
        self.inner.shader_subgroup_uniform_control_flow =
            shader_subgroup_uniform_control_flow.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRobustness2FeaturesEXT.html>"]
pub struct PhysicalDeviceRobustness2FeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub robust_buffer_access2: Bool32,
    pub robust_image_access2: Bool32,
    pub null_descriptor: Bool32,
}
impl ::std::default::Default for PhysicalDeviceRobustness2FeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            robust_buffer_access2: Bool32::default(),
            robust_image_access2: Bool32::default(),
            null_descriptor: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceRobustness2FeaturesEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT;
}
impl PhysicalDeviceRobustness2FeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceRobustness2FeaturesEXTBuilder<'a> {
        PhysicalDeviceRobustness2FeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceRobustness2FeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceRobustness2FeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRobustness2FeaturesEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRobustness2FeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRobustness2FeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRobustness2FeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceRobustness2FeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceRobustness2FeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceRobustness2FeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceRobustness2FeaturesEXTBuilder<'a> {
    #[inline]
    pub fn robust_buffer_access2(mut self, robust_buffer_access2: bool) -> Self {
        self.inner.robust_buffer_access2 = robust_buffer_access2.into();
        self
    }
    #[inline]
    pub fn robust_image_access2(mut self, robust_image_access2: bool) -> Self {
        self.inner.robust_image_access2 = robust_image_access2.into();
        self
    }
    #[inline]
    pub fn null_descriptor(mut self, null_descriptor: bool) -> Self {
        self.inner.null_descriptor = null_descriptor.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceRobustness2FeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRobustness2PropertiesEXT.html>"]
pub struct PhysicalDeviceRobustness2PropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub robust_storage_buffer_access_size_alignment: DeviceSize,
    pub robust_uniform_buffer_access_size_alignment: DeviceSize,
}
impl ::std::default::Default for PhysicalDeviceRobustness2PropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            robust_storage_buffer_access_size_alignment: DeviceSize::default(),
            robust_uniform_buffer_access_size_alignment: DeviceSize::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceRobustness2PropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT;
}
impl PhysicalDeviceRobustness2PropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceRobustness2PropertiesEXTBuilder<'a> {
        PhysicalDeviceRobustness2PropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceRobustness2PropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceRobustness2PropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceRobustness2PropertiesEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceRobustness2PropertiesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceRobustness2PropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceRobustness2PropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceRobustness2PropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceRobustness2PropertiesEXTBuilder<'a> {
    #[inline]
    pub fn robust_storage_buffer_access_size_alignment(
        mut self,
        robust_storage_buffer_access_size_alignment: DeviceSize,
    ) -> Self {
        self.inner.robust_storage_buffer_access_size_alignment =
            robust_storage_buffer_access_size_alignment;
        self
    }
    #[inline]
    pub fn robust_uniform_buffer_access_size_alignment(
        mut self,
        robust_uniform_buffer_access_size_alignment: DeviceSize,
    ) -> Self {
        self.inner.robust_uniform_buffer_access_size_alignment =
            robust_uniform_buffer_access_size_alignment;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceRobustness2PropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageRobustnessFeatures.html>"]
pub struct PhysicalDeviceImageRobustnessFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub robust_image_access: Bool32,
}
impl ::std::default::Default for PhysicalDeviceImageRobustnessFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            robust_image_access: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceImageRobustnessFeatures {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES;
}
impl PhysicalDeviceImageRobustnessFeatures {
    pub fn builder<'a>() -> PhysicalDeviceImageRobustnessFeaturesBuilder<'a> {
        PhysicalDeviceImageRobustnessFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceImageRobustnessFeaturesBuilder<'a> {
    inner: PhysicalDeviceImageRobustnessFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceImageRobustnessFeaturesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceImageRobustnessFeatures {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceImageRobustnessFeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceImageRobustnessFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDeviceImageRobustnessFeaturesBuilder<'a> {
    type Target = PhysicalDeviceImageRobustnessFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceImageRobustnessFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceImageRobustnessFeaturesBuilder<'a> {
    #[inline]
    pub fn robust_image_access(mut self, robust_image_access: bool) -> Self {
        self.inner.robust_image_access = robust_image_access.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceImageRobustnessFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.html>"]
pub struct PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub workgroup_memory_explicit_layout: Bool32,
    pub workgroup_memory_explicit_layout_scalar_block_layout: Bool32,
    pub workgroup_memory_explicit_layout8_bit_access: Bool32,
    pub workgroup_memory_explicit_layout16_bit_access: Bool32,
}
impl ::std::default::Default for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            workgroup_memory_explicit_layout: Bool32::default(),
            workgroup_memory_explicit_layout_scalar_block_layout: Bool32::default(),
            workgroup_memory_explicit_layout8_bit_access: Bool32::default(),
            workgroup_memory_explicit_layout16_bit_access: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR;
}
impl PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
    pub fn builder<'a>() -> PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRBuilder<'a> {
        PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRBuilder<'a> {
    inner: PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR
{
}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {}
impl<'a> ::std::ops::Deref for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRBuilder<'a> {
    type Target = PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut
    for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRBuilder<'a>
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRBuilder<'a> {
    #[inline]
    pub fn workgroup_memory_explicit_layout(
        mut self,
        workgroup_memory_explicit_layout: bool,
    ) -> Self {
        self.inner.workgroup_memory_explicit_layout = workgroup_memory_explicit_layout.into();
        self
    }
    #[inline]
    pub fn workgroup_memory_explicit_layout_scalar_block_layout(
        mut self,
        workgroup_memory_explicit_layout_scalar_block_layout: bool,
    ) -> Self {
        self.inner
            .workgroup_memory_explicit_layout_scalar_block_layout =
            workgroup_memory_explicit_layout_scalar_block_layout.into();
        self
    }
    #[inline]
    pub fn workgroup_memory_explicit_layout8_bit_access(
        mut self,
        workgroup_memory_explicit_layout8_bit_access: bool,
    ) -> Self {
        self.inner.workgroup_memory_explicit_layout8_bit_access =
            workgroup_memory_explicit_layout8_bit_access.into();
        self
    }
    #[inline]
    pub fn workgroup_memory_explicit_layout16_bit_access(
        mut self,
        workgroup_memory_explicit_layout16_bit_access: bool,
    ) -> Self {
        self.inner.workgroup_memory_explicit_layout16_bit_access =
            workgroup_memory_explicit_layout16_bit_access.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html>"]
pub struct PhysicalDevicePortabilitySubsetFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub constant_alpha_color_blend_factors: Bool32,
    pub events: Bool32,
    pub image_view_format_reinterpretation: Bool32,
    pub image_view_format_swizzle: Bool32,
    pub image_view2_d_on3_d_image: Bool32,
    pub multisample_array_image: Bool32,
    pub mutable_comparison_samplers: Bool32,
    pub point_polygons: Bool32,
    pub sampler_mip_lod_bias: Bool32,
    pub separate_stencil_mask_ref: Bool32,
    pub shader_sample_rate_interpolation_functions: Bool32,
    pub tessellation_isolines: Bool32,
    pub tessellation_point_mode: Bool32,
    pub triangle_fans: Bool32,
    pub vertex_attribute_access_beyond_stride: Bool32,
}
impl ::std::default::Default for PhysicalDevicePortabilitySubsetFeaturesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            constant_alpha_color_blend_factors: Bool32::default(),
            events: Bool32::default(),
            image_view_format_reinterpretation: Bool32::default(),
            image_view_format_swizzle: Bool32::default(),
            image_view2_d_on3_d_image: Bool32::default(),
            multisample_array_image: Bool32::default(),
            mutable_comparison_samplers: Bool32::default(),
            point_polygons: Bool32::default(),
            sampler_mip_lod_bias: Bool32::default(),
            separate_stencil_mask_ref: Bool32::default(),
            shader_sample_rate_interpolation_functions: Bool32::default(),
            tessellation_isolines: Bool32::default(),
            tessellation_point_mode: Bool32::default(),
            triangle_fans: Bool32::default(),
            vertex_attribute_access_beyond_stride: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevicePortabilitySubsetFeaturesKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR;
}
impl PhysicalDevicePortabilitySubsetFeaturesKHR {
    pub fn builder<'a>() -> PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'a> {
        PhysicalDevicePortabilitySubsetFeaturesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'a> {
    inner: PhysicalDevicePortabilitySubsetFeaturesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePortabilitySubsetFeaturesKHR {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePortabilitySubsetFeaturesKHR {}
impl<'a> ::std::ops::Deref for PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'a> {
    type Target = PhysicalDevicePortabilitySubsetFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'a> {
    #[inline]
    pub fn constant_alpha_color_blend_factors(
        mut self,
        constant_alpha_color_blend_factors: bool,
    ) -> Self {
        self.inner.constant_alpha_color_blend_factors = constant_alpha_color_blend_factors.into();
        self
    }
    #[inline]
    pub fn events(mut self, events: bool) -> Self {
        self.inner.events = events.into();
        self
    }
    #[inline]
    pub fn image_view_format_reinterpretation(
        mut self,
        image_view_format_reinterpretation: bool,
    ) -> Self {
        self.inner.image_view_format_reinterpretation = image_view_format_reinterpretation.into();
        self
    }
    #[inline]
    pub fn image_view_format_swizzle(mut self, image_view_format_swizzle: bool) -> Self {
        self.inner.image_view_format_swizzle = image_view_format_swizzle.into();
        self
    }
    #[inline]
    pub fn image_view2_d_on3_d_image(mut self, image_view2_d_on3_d_image: bool) -> Self {
        self.inner.image_view2_d_on3_d_image = image_view2_d_on3_d_image.into();
        self
    }
    #[inline]
    pub fn multisample_array_image(mut self, multisample_array_image: bool) -> Self {
        self.inner.multisample_array_image = multisample_array_image.into();
        self
    }
    #[inline]
    pub fn mutable_comparison_samplers(mut self, mutable_comparison_samplers: bool) -> Self {
        self.inner.mutable_comparison_samplers = mutable_comparison_samplers.into();
        self
    }
    #[inline]
    pub fn point_polygons(mut self, point_polygons: bool) -> Self {
        self.inner.point_polygons = point_polygons.into();
        self
    }
    #[inline]
    pub fn sampler_mip_lod_bias(mut self, sampler_mip_lod_bias: bool) -> Self {
        self.inner.sampler_mip_lod_bias = sampler_mip_lod_bias.into();
        self
    }
    #[inline]
    pub fn separate_stencil_mask_ref(mut self, separate_stencil_mask_ref: bool) -> Self {
        self.inner.separate_stencil_mask_ref = separate_stencil_mask_ref.into();
        self
    }
    #[inline]
    pub fn shader_sample_rate_interpolation_functions(
        mut self,
        shader_sample_rate_interpolation_functions: bool,
    ) -> Self {
        self.inner.shader_sample_rate_interpolation_functions =
            shader_sample_rate_interpolation_functions.into();
        self
    }
    #[inline]
    pub fn tessellation_isolines(mut self, tessellation_isolines: bool) -> Self {
        self.inner.tessellation_isolines = tessellation_isolines.into();
        self
    }
    #[inline]
    pub fn tessellation_point_mode(mut self, tessellation_point_mode: bool) -> Self {
        self.inner.tessellation_point_mode = tessellation_point_mode.into();
        self
    }
    #[inline]
    pub fn triangle_fans(mut self, triangle_fans: bool) -> Self {
        self.inner.triangle_fans = triangle_fans.into();
        self
    }
    #[inline]
    pub fn vertex_attribute_access_beyond_stride(
        mut self,
        vertex_attribute_access_beyond_stride: bool,
    ) -> Self {
        self.inner.vertex_attribute_access_beyond_stride =
            vertex_attribute_access_beyond_stride.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevicePortabilitySubsetFeaturesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetPropertiesKHR.html>"]
pub struct PhysicalDevicePortabilitySubsetPropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_vertex_input_binding_stride_alignment: u32,
}
impl ::std::default::Default for PhysicalDevicePortabilitySubsetPropertiesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            min_vertex_input_binding_stride_alignment: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevicePortabilitySubsetPropertiesKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR;
}
impl PhysicalDevicePortabilitySubsetPropertiesKHR {
    pub fn builder<'a>() -> PhysicalDevicePortabilitySubsetPropertiesKHRBuilder<'a> {
        PhysicalDevicePortabilitySubsetPropertiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevicePortabilitySubsetPropertiesKHRBuilder<'a> {
    inner: PhysicalDevicePortabilitySubsetPropertiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDevicePortabilitySubsetPropertiesKHRBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDevicePortabilitySubsetPropertiesKHR {}
impl<'a> ::std::ops::Deref for PhysicalDevicePortabilitySubsetPropertiesKHRBuilder<'a> {
    type Target = PhysicalDevicePortabilitySubsetPropertiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevicePortabilitySubsetPropertiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevicePortabilitySubsetPropertiesKHRBuilder<'a> {
    #[inline]
    pub fn min_vertex_input_binding_stride_alignment(
        mut self,
        min_vertex_input_binding_stride_alignment: u32,
    ) -> Self {
        self.inner.min_vertex_input_binding_stride_alignment =
            min_vertex_input_binding_stride_alignment;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevicePortabilitySubsetPropertiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice4444FormatsFeaturesEXT.html>"]
pub struct PhysicalDevice4444FormatsFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub format_a4r4g4b4: Bool32,
    pub format_a4b4g4r4: Bool32,
}
impl ::std::default::Default for PhysicalDevice4444FormatsFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            format_a4r4g4b4: Bool32::default(),
            format_a4b4g4r4: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevice4444FormatsFeaturesEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT;
}
impl PhysicalDevice4444FormatsFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDevice4444FormatsFeaturesEXTBuilder<'a> {
        PhysicalDevice4444FormatsFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevice4444FormatsFeaturesEXTBuilder<'a> {
    inner: PhysicalDevice4444FormatsFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevice4444FormatsFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevice4444FormatsFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevice4444FormatsFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevice4444FormatsFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDevice4444FormatsFeaturesEXTBuilder<'a> {
    type Target = PhysicalDevice4444FormatsFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevice4444FormatsFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevice4444FormatsFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn format_a4r4g4b4(mut self, format_a4r4g4b4: bool) -> Self {
        self.inner.format_a4r4g4b4 = format_a4r4g4b4.into();
        self
    }
    #[inline]
    pub fn format_a4b4g4r4(mut self, format_a4b4g4r4: bool) -> Self {
        self.inner.format_a4b4g4r4 = format_a4b4g4r4.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevice4444FormatsFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubpassShadingFeaturesHUAWEI.html>"]
pub struct PhysicalDeviceSubpassShadingFeaturesHUAWEI {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub subpass_shading: Bool32,
}
impl ::std::default::Default for PhysicalDeviceSubpassShadingFeaturesHUAWEI {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            subpass_shading: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceSubpassShadingFeaturesHUAWEI {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI;
}
impl PhysicalDeviceSubpassShadingFeaturesHUAWEI {
    pub fn builder<'a>() -> PhysicalDeviceSubpassShadingFeaturesHUAWEIBuilder<'a> {
        PhysicalDeviceSubpassShadingFeaturesHUAWEIBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceSubpassShadingFeaturesHUAWEIBuilder<'a> {
    inner: PhysicalDeviceSubpassShadingFeaturesHUAWEI,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceSubpassShadingFeaturesHUAWEIBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceSubpassShadingFeaturesHUAWEI {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSubpassShadingFeaturesHUAWEIBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSubpassShadingFeaturesHUAWEI {}
impl<'a> ::std::ops::Deref for PhysicalDeviceSubpassShadingFeaturesHUAWEIBuilder<'a> {
    type Target = PhysicalDeviceSubpassShadingFeaturesHUAWEI;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceSubpassShadingFeaturesHUAWEIBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceSubpassShadingFeaturesHUAWEIBuilder<'a> {
    #[inline]
    pub fn subpass_shading(mut self, subpass_shading: bool) -> Self {
        self.inner.subpass_shading = subpass_shading.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceSubpassShadingFeaturesHUAWEI {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI.html>"]
pub struct PhysicalDeviceClusterCullingShaderFeaturesHUAWEI {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub clusterculling_shader: Bool32,
    pub multiview_cluster_culling_shader: Bool32,
}
impl ::std::default::Default for PhysicalDeviceClusterCullingShaderFeaturesHUAWEI {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            clusterculling_shader: Bool32::default(),
            multiview_cluster_culling_shader: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceClusterCullingShaderFeaturesHUAWEI {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI;
}
impl PhysicalDeviceClusterCullingShaderFeaturesHUAWEI {
    pub fn builder<'a>() -> PhysicalDeviceClusterCullingShaderFeaturesHUAWEIBuilder<'a> {
        PhysicalDeviceClusterCullingShaderFeaturesHUAWEIBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceClusterCullingShaderFeaturesHUAWEIBuilder<'a> {
    inner: PhysicalDeviceClusterCullingShaderFeaturesHUAWEI,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceClusterCullingShaderFeaturesHUAWEIBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceClusterCullingShaderFeaturesHUAWEI {}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceClusterCullingShaderFeaturesHUAWEIBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceClusterCullingShaderFeaturesHUAWEI {}
impl<'a> ::std::ops::Deref for PhysicalDeviceClusterCullingShaderFeaturesHUAWEIBuilder<'a> {
    type Target = PhysicalDeviceClusterCullingShaderFeaturesHUAWEI;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceClusterCullingShaderFeaturesHUAWEIBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceClusterCullingShaderFeaturesHUAWEIBuilder<'a> {
    #[inline]
    pub fn clusterculling_shader(mut self, clusterculling_shader: bool) -> Self {
        self.inner.clusterculling_shader = clusterculling_shader.into();
        self
    }
    #[inline]
    pub fn multiview_cluster_culling_shader(
        mut self,
        multiview_cluster_culling_shader: bool,
    ) -> Self {
        self.inner.multiview_cluster_culling_shader = multiview_cluster_culling_shader.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceClusterCullingShaderFeaturesHUAWEI {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCopy2.html>"]
pub struct BufferCopy2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_offset: DeviceSize,
    pub dst_offset: DeviceSize,
    pub size: DeviceSize,
}
impl ::std::default::Default for BufferCopy2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_offset: DeviceSize::default(),
            dst_offset: DeviceSize::default(),
            size: DeviceSize::default(),
        }
    }
}
unsafe impl TaggedStructure for BufferCopy2 {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_COPY_2;
}
impl BufferCopy2 {
    pub fn builder<'a>() -> BufferCopy2Builder<'a> {
        BufferCopy2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BufferCopy2Builder<'a> {
    inner: BufferCopy2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for BufferCopy2Builder<'a> {
    type Target = BufferCopy2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BufferCopy2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BufferCopy2Builder<'a> {
    #[inline]
    pub fn src_offset(mut self, src_offset: DeviceSize) -> Self {
        self.inner.src_offset = src_offset;
        self
    }
    #[inline]
    pub fn dst_offset(mut self, dst_offset: DeviceSize) -> Self {
        self.inner.dst_offset = dst_offset;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BufferCopy2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCopy2.html>"]
pub struct ImageCopy2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_subresource: ImageSubresourceLayers,
    pub src_offset: Offset3D,
    pub dst_subresource: ImageSubresourceLayers,
    pub dst_offset: Offset3D,
    pub extent: Extent3D,
}
impl ::std::default::Default for ImageCopy2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_subresource: ImageSubresourceLayers::default(),
            src_offset: Offset3D::default(),
            dst_subresource: ImageSubresourceLayers::default(),
            dst_offset: Offset3D::default(),
            extent: Extent3D::default(),
        }
    }
}
unsafe impl TaggedStructure for ImageCopy2 {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_COPY_2;
}
impl ImageCopy2 {
    pub fn builder<'a>() -> ImageCopy2Builder<'a> {
        ImageCopy2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageCopy2Builder<'a> {
    inner: ImageCopy2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ImageCopy2Builder<'a> {
    type Target = ImageCopy2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageCopy2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageCopy2Builder<'a> {
    #[inline]
    pub fn src_subresource(mut self, src_subresource: ImageSubresourceLayers) -> Self {
        self.inner.src_subresource = src_subresource;
        self
    }
    #[inline]
    pub fn src_offset(mut self, src_offset: Offset3D) -> Self {
        self.inner.src_offset = src_offset;
        self
    }
    #[inline]
    pub fn dst_subresource(mut self, dst_subresource: ImageSubresourceLayers) -> Self {
        self.inner.dst_subresource = dst_subresource;
        self
    }
    #[inline]
    pub fn dst_offset(mut self, dst_offset: Offset3D) -> Self {
        self.inner.dst_offset = dst_offset;
        self
    }
    #[inline]
    pub fn extent(mut self, extent: Extent3D) -> Self {
        self.inner.extent = extent;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageCopy2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageBlit2.html>"]
pub struct ImageBlit2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_subresource: ImageSubresourceLayers,
    pub src_offsets: [Offset3D; 2],
    pub dst_subresource: ImageSubresourceLayers,
    pub dst_offsets: [Offset3D; 2],
}
impl ::std::default::Default for ImageBlit2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_subresource: ImageSubresourceLayers::default(),
            src_offsets: unsafe { ::std::mem::zeroed() },
            dst_subresource: ImageSubresourceLayers::default(),
            dst_offsets: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for ImageBlit2 {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_BLIT_2;
}
impl ImageBlit2 {
    pub fn builder<'a>() -> ImageBlit2Builder<'a> {
        ImageBlit2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageBlit2Builder<'a> {
    inner: ImageBlit2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsImageBlit2 {}
impl<'a> ::std::ops::Deref for ImageBlit2Builder<'a> {
    type Target = ImageBlit2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageBlit2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageBlit2Builder<'a> {
    #[inline]
    pub fn src_subresource(mut self, src_subresource: ImageSubresourceLayers) -> Self {
        self.inner.src_subresource = src_subresource;
        self
    }
    #[inline]
    pub fn src_offsets(mut self, src_offsets: [Offset3D; 2]) -> Self {
        self.inner.src_offsets = src_offsets;
        self
    }
    #[inline]
    pub fn dst_subresource(mut self, dst_subresource: ImageSubresourceLayers) -> Self {
        self.inner.dst_subresource = dst_subresource;
        self
    }
    #[inline]
    pub fn dst_offsets(mut self, dst_offsets: [Offset3D; 2]) -> Self {
        self.inner.dst_offsets = dst_offsets;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsImageBlit2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageBlit2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferImageCopy2.html>"]
pub struct BufferImageCopy2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub buffer_offset: DeviceSize,
    pub buffer_row_length: u32,
    pub buffer_image_height: u32,
    pub image_subresource: ImageSubresourceLayers,
    pub image_offset: Offset3D,
    pub image_extent: Extent3D,
}
impl ::std::default::Default for BufferImageCopy2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            buffer_offset: DeviceSize::default(),
            buffer_row_length: u32::default(),
            buffer_image_height: u32::default(),
            image_subresource: ImageSubresourceLayers::default(),
            image_offset: Offset3D::default(),
            image_extent: Extent3D::default(),
        }
    }
}
unsafe impl TaggedStructure for BufferImageCopy2 {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_IMAGE_COPY_2;
}
impl BufferImageCopy2 {
    pub fn builder<'a>() -> BufferImageCopy2Builder<'a> {
        BufferImageCopy2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BufferImageCopy2Builder<'a> {
    inner: BufferImageCopy2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsBufferImageCopy2 {}
impl<'a> ::std::ops::Deref for BufferImageCopy2Builder<'a> {
    type Target = BufferImageCopy2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BufferImageCopy2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BufferImageCopy2Builder<'a> {
    #[inline]
    pub fn buffer_offset(mut self, buffer_offset: DeviceSize) -> Self {
        self.inner.buffer_offset = buffer_offset;
        self
    }
    #[inline]
    pub fn buffer_row_length(mut self, buffer_row_length: u32) -> Self {
        self.inner.buffer_row_length = buffer_row_length;
        self
    }
    #[inline]
    pub fn buffer_image_height(mut self, buffer_image_height: u32) -> Self {
        self.inner.buffer_image_height = buffer_image_height;
        self
    }
    #[inline]
    pub fn image_subresource(mut self, image_subresource: ImageSubresourceLayers) -> Self {
        self.inner.image_subresource = image_subresource;
        self
    }
    #[inline]
    pub fn image_offset(mut self, image_offset: Offset3D) -> Self {
        self.inner.image_offset = image_offset;
        self
    }
    #[inline]
    pub fn image_extent(mut self, image_extent: Extent3D) -> Self {
        self.inner.image_extent = image_extent;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsBufferImageCopy2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BufferImageCopy2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageResolve2.html>"]
pub struct ImageResolve2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_subresource: ImageSubresourceLayers,
    pub src_offset: Offset3D,
    pub dst_subresource: ImageSubresourceLayers,
    pub dst_offset: Offset3D,
    pub extent: Extent3D,
}
impl ::std::default::Default for ImageResolve2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_subresource: ImageSubresourceLayers::default(),
            src_offset: Offset3D::default(),
            dst_subresource: ImageSubresourceLayers::default(),
            dst_offset: Offset3D::default(),
            extent: Extent3D::default(),
        }
    }
}
unsafe impl TaggedStructure for ImageResolve2 {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_RESOLVE_2;
}
impl ImageResolve2 {
    pub fn builder<'a>() -> ImageResolve2Builder<'a> {
        ImageResolve2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageResolve2Builder<'a> {
    inner: ImageResolve2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ImageResolve2Builder<'a> {
    type Target = ImageResolve2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageResolve2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageResolve2Builder<'a> {
    #[inline]
    pub fn src_subresource(mut self, src_subresource: ImageSubresourceLayers) -> Self {
        self.inner.src_subresource = src_subresource;
        self
    }
    #[inline]
    pub fn src_offset(mut self, src_offset: Offset3D) -> Self {
        self.inner.src_offset = src_offset;
        self
    }
    #[inline]
    pub fn dst_subresource(mut self, dst_subresource: ImageSubresourceLayers) -> Self {
        self.inner.dst_subresource = dst_subresource;
        self
    }
    #[inline]
    pub fn dst_offset(mut self, dst_offset: Offset3D) -> Self {
        self.inner.dst_offset = dst_offset;
        self
    }
    #[inline]
    pub fn extent(mut self, extent: Extent3D) -> Self {
        self.inner.extent = extent;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageResolve2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyBufferInfo2.html>"]
pub struct CopyBufferInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_buffer: Buffer,
    pub dst_buffer: Buffer,
    pub region_count: u32,
    pub p_regions: *const BufferCopy2,
}
impl ::std::default::Default for CopyBufferInfo2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_buffer: Buffer::default(),
            dst_buffer: Buffer::default(),
            region_count: u32::default(),
            p_regions: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for CopyBufferInfo2 {
    const STRUCTURE_TYPE: StructureType = StructureType::COPY_BUFFER_INFO_2;
}
impl CopyBufferInfo2 {
    pub fn builder<'a>() -> CopyBufferInfo2Builder<'a> {
        CopyBufferInfo2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CopyBufferInfo2Builder<'a> {
    inner: CopyBufferInfo2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CopyBufferInfo2Builder<'a> {
    type Target = CopyBufferInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CopyBufferInfo2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CopyBufferInfo2Builder<'a> {
    #[inline]
    pub fn src_buffer(mut self, src_buffer: Buffer) -> Self {
        self.inner.src_buffer = src_buffer;
        self
    }
    #[inline]
    pub fn dst_buffer(mut self, dst_buffer: Buffer) -> Self {
        self.inner.dst_buffer = dst_buffer;
        self
    }
    #[inline]
    pub fn regions(mut self, regions: &'a [BufferCopy2]) -> Self {
        self.inner.region_count = regions.len() as _;
        self.inner.p_regions = regions.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CopyBufferInfo2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyImageInfo2.html>"]
pub struct CopyImageInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_image: Image,
    pub src_image_layout: ImageLayout,
    pub dst_image: Image,
    pub dst_image_layout: ImageLayout,
    pub region_count: u32,
    pub p_regions: *const ImageCopy2,
}
impl ::std::default::Default for CopyImageInfo2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_image: Image::default(),
            src_image_layout: ImageLayout::default(),
            dst_image: Image::default(),
            dst_image_layout: ImageLayout::default(),
            region_count: u32::default(),
            p_regions: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for CopyImageInfo2 {
    const STRUCTURE_TYPE: StructureType = StructureType::COPY_IMAGE_INFO_2;
}
impl CopyImageInfo2 {
    pub fn builder<'a>() -> CopyImageInfo2Builder<'a> {
        CopyImageInfo2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CopyImageInfo2Builder<'a> {
    inner: CopyImageInfo2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CopyImageInfo2Builder<'a> {
    type Target = CopyImageInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CopyImageInfo2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CopyImageInfo2Builder<'a> {
    #[inline]
    pub fn src_image(mut self, src_image: Image) -> Self {
        self.inner.src_image = src_image;
        self
    }
    #[inline]
    pub fn src_image_layout(mut self, src_image_layout: ImageLayout) -> Self {
        self.inner.src_image_layout = src_image_layout;
        self
    }
    #[inline]
    pub fn dst_image(mut self, dst_image: Image) -> Self {
        self.inner.dst_image = dst_image;
        self
    }
    #[inline]
    pub fn dst_image_layout(mut self, dst_image_layout: ImageLayout) -> Self {
        self.inner.dst_image_layout = dst_image_layout;
        self
    }
    #[inline]
    pub fn regions(mut self, regions: &'a [ImageCopy2]) -> Self {
        self.inner.region_count = regions.len() as _;
        self.inner.p_regions = regions.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CopyImageInfo2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBlitImageInfo2.html>"]
pub struct BlitImageInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_image: Image,
    pub src_image_layout: ImageLayout,
    pub dst_image: Image,
    pub dst_image_layout: ImageLayout,
    pub region_count: u32,
    pub p_regions: *const ImageBlit2,
    pub filter: Filter,
}
impl ::std::default::Default for BlitImageInfo2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_image: Image::default(),
            src_image_layout: ImageLayout::default(),
            dst_image: Image::default(),
            dst_image_layout: ImageLayout::default(),
            region_count: u32::default(),
            p_regions: ::std::ptr::null(),
            filter: Filter::default(),
        }
    }
}
unsafe impl TaggedStructure for BlitImageInfo2 {
    const STRUCTURE_TYPE: StructureType = StructureType::BLIT_IMAGE_INFO_2;
}
impl BlitImageInfo2 {
    pub fn builder<'a>() -> BlitImageInfo2Builder<'a> {
        BlitImageInfo2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BlitImageInfo2Builder<'a> {
    inner: BlitImageInfo2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for BlitImageInfo2Builder<'a> {
    type Target = BlitImageInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BlitImageInfo2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BlitImageInfo2Builder<'a> {
    #[inline]
    pub fn src_image(mut self, src_image: Image) -> Self {
        self.inner.src_image = src_image;
        self
    }
    #[inline]
    pub fn src_image_layout(mut self, src_image_layout: ImageLayout) -> Self {
        self.inner.src_image_layout = src_image_layout;
        self
    }
    #[inline]
    pub fn dst_image(mut self, dst_image: Image) -> Self {
        self.inner.dst_image = dst_image;
        self
    }
    #[inline]
    pub fn dst_image_layout(mut self, dst_image_layout: ImageLayout) -> Self {
        self.inner.dst_image_layout = dst_image_layout;
        self
    }
    #[inline]
    pub fn regions(mut self, regions: &'a [ImageBlit2]) -> Self {
        self.inner.region_count = regions.len() as _;
        self.inner.p_regions = regions.as_ptr();
        self
    }
    #[inline]
    pub fn filter(mut self, filter: Filter) -> Self {
        self.inner.filter = filter;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BlitImageInfo2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyBufferToImageInfo2.html>"]
pub struct CopyBufferToImageInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_buffer: Buffer,
    pub dst_image: Image,
    pub dst_image_layout: ImageLayout,
    pub region_count: u32,
    pub p_regions: *const BufferImageCopy2,
}
impl ::std::default::Default for CopyBufferToImageInfo2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_buffer: Buffer::default(),
            dst_image: Image::default(),
            dst_image_layout: ImageLayout::default(),
            region_count: u32::default(),
            p_regions: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for CopyBufferToImageInfo2 {
    const STRUCTURE_TYPE: StructureType = StructureType::COPY_BUFFER_TO_IMAGE_INFO_2;
}
impl CopyBufferToImageInfo2 {
    pub fn builder<'a>() -> CopyBufferToImageInfo2Builder<'a> {
        CopyBufferToImageInfo2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CopyBufferToImageInfo2Builder<'a> {
    inner: CopyBufferToImageInfo2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CopyBufferToImageInfo2Builder<'a> {
    type Target = CopyBufferToImageInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CopyBufferToImageInfo2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CopyBufferToImageInfo2Builder<'a> {
    #[inline]
    pub fn src_buffer(mut self, src_buffer: Buffer) -> Self {
        self.inner.src_buffer = src_buffer;
        self
    }
    #[inline]
    pub fn dst_image(mut self, dst_image: Image) -> Self {
        self.inner.dst_image = dst_image;
        self
    }
    #[inline]
    pub fn dst_image_layout(mut self, dst_image_layout: ImageLayout) -> Self {
        self.inner.dst_image_layout = dst_image_layout;
        self
    }
    #[inline]
    pub fn regions(mut self, regions: &'a [BufferImageCopy2]) -> Self {
        self.inner.region_count = regions.len() as _;
        self.inner.p_regions = regions.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CopyBufferToImageInfo2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyImageToBufferInfo2.html>"]
pub struct CopyImageToBufferInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_image: Image,
    pub src_image_layout: ImageLayout,
    pub dst_buffer: Buffer,
    pub region_count: u32,
    pub p_regions: *const BufferImageCopy2,
}
impl ::std::default::Default for CopyImageToBufferInfo2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_image: Image::default(),
            src_image_layout: ImageLayout::default(),
            dst_buffer: Buffer::default(),
            region_count: u32::default(),
            p_regions: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for CopyImageToBufferInfo2 {
    const STRUCTURE_TYPE: StructureType = StructureType::COPY_IMAGE_TO_BUFFER_INFO_2;
}
impl CopyImageToBufferInfo2 {
    pub fn builder<'a>() -> CopyImageToBufferInfo2Builder<'a> {
        CopyImageToBufferInfo2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CopyImageToBufferInfo2Builder<'a> {
    inner: CopyImageToBufferInfo2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CopyImageToBufferInfo2Builder<'a> {
    type Target = CopyImageToBufferInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CopyImageToBufferInfo2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CopyImageToBufferInfo2Builder<'a> {
    #[inline]
    pub fn src_image(mut self, src_image: Image) -> Self {
        self.inner.src_image = src_image;
        self
    }
    #[inline]
    pub fn src_image_layout(mut self, src_image_layout: ImageLayout) -> Self {
        self.inner.src_image_layout = src_image_layout;
        self
    }
    #[inline]
    pub fn dst_buffer(mut self, dst_buffer: Buffer) -> Self {
        self.inner.dst_buffer = dst_buffer;
        self
    }
    #[inline]
    pub fn regions(mut self, regions: &'a [BufferImageCopy2]) -> Self {
        self.inner.region_count = regions.len() as _;
        self.inner.p_regions = regions.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CopyImageToBufferInfo2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkResolveImageInfo2.html>"]
pub struct ResolveImageInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_image: Image,
    pub src_image_layout: ImageLayout,
    pub dst_image: Image,
    pub dst_image_layout: ImageLayout,
    pub region_count: u32,
    pub p_regions: *const ImageResolve2,
}
impl ::std::default::Default for ResolveImageInfo2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_image: Image::default(),
            src_image_layout: ImageLayout::default(),
            dst_image: Image::default(),
            dst_image_layout: ImageLayout::default(),
            region_count: u32::default(),
            p_regions: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for ResolveImageInfo2 {
    const STRUCTURE_TYPE: StructureType = StructureType::RESOLVE_IMAGE_INFO_2;
}
impl ResolveImageInfo2 {
    pub fn builder<'a>() -> ResolveImageInfo2Builder<'a> {
        ResolveImageInfo2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ResolveImageInfo2Builder<'a> {
    inner: ResolveImageInfo2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ResolveImageInfo2Builder<'a> {
    type Target = ResolveImageInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ResolveImageInfo2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ResolveImageInfo2Builder<'a> {
    #[inline]
    pub fn src_image(mut self, src_image: Image) -> Self {
        self.inner.src_image = src_image;
        self
    }
    #[inline]
    pub fn src_image_layout(mut self, src_image_layout: ImageLayout) -> Self {
        self.inner.src_image_layout = src_image_layout;
        self
    }
    #[inline]
    pub fn dst_image(mut self, dst_image: Image) -> Self {
        self.inner.dst_image = dst_image;
        self
    }
    #[inline]
    pub fn dst_image_layout(mut self, dst_image_layout: ImageLayout) -> Self {
        self.inner.dst_image_layout = dst_image_layout;
        self
    }
    #[inline]
    pub fn regions(mut self, regions: &'a [ImageResolve2]) -> Self {
        self.inner.region_count = regions.len() as _;
        self.inner.p_regions = regions.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ResolveImageInfo2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.html>"]
pub struct PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_image_int64_atomics: Bool32,
    pub sparse_image_int64_atomics: Bool32,
}
impl ::std::default::Default for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_image_int64_atomics: Bool32::default(),
            sparse_image_int64_atomics: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT;
}
impl PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceShaderImageAtomicInt64FeaturesEXTBuilder<'a> {
        PhysicalDeviceShaderImageAtomicInt64FeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderImageAtomicInt64FeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceShaderImageAtomicInt64FeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceShaderImageAtomicInt64FeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderImageAtomicInt64FeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderImageAtomicInt64FeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceShaderImageAtomicInt64FeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderImageAtomicInt64FeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderImageAtomicInt64FeaturesEXTBuilder<'a> {
    #[inline]
    pub fn shader_image_int64_atomics(mut self, shader_image_int64_atomics: bool) -> Self {
        self.inner.shader_image_int64_atomics = shader_image_int64_atomics.into();
        self
    }
    #[inline]
    pub fn sparse_image_int64_atomics(mut self, sparse_image_int64_atomics: bool) -> Self {
        self.inner.sparse_image_int64_atomics = sparse_image_int64_atomics.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFragmentShadingRateAttachmentInfoKHR.html>"]
pub struct FragmentShadingRateAttachmentInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_fragment_shading_rate_attachment: *const AttachmentReference2,
    pub shading_rate_attachment_texel_size: Extent2D,
}
impl ::std::default::Default for FragmentShadingRateAttachmentInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_fragment_shading_rate_attachment: ::std::ptr::null(),
            shading_rate_attachment_texel_size: Extent2D::default(),
        }
    }
}
unsafe impl TaggedStructure for FragmentShadingRateAttachmentInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR;
}
impl FragmentShadingRateAttachmentInfoKHR {
    pub fn builder<'a>() -> FragmentShadingRateAttachmentInfoKHRBuilder<'a> {
        FragmentShadingRateAttachmentInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct FragmentShadingRateAttachmentInfoKHRBuilder<'a> {
    inner: FragmentShadingRateAttachmentInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSubpassDescription2 for FragmentShadingRateAttachmentInfoKHRBuilder<'_> {}
unsafe impl ExtendsSubpassDescription2 for FragmentShadingRateAttachmentInfoKHR {}
impl<'a> ::std::ops::Deref for FragmentShadingRateAttachmentInfoKHRBuilder<'a> {
    type Target = FragmentShadingRateAttachmentInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for FragmentShadingRateAttachmentInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> FragmentShadingRateAttachmentInfoKHRBuilder<'a> {
    #[inline]
    pub fn fragment_shading_rate_attachment(
        mut self,
        fragment_shading_rate_attachment: &'a AttachmentReference2,
    ) -> Self {
        self.inner.p_fragment_shading_rate_attachment = fragment_shading_rate_attachment;
        self
    }
    #[inline]
    pub fn shading_rate_attachment_texel_size(
        mut self,
        shading_rate_attachment_texel_size: Extent2D,
    ) -> Self {
        self.inner.shading_rate_attachment_texel_size = shading_rate_attachment_texel_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> FragmentShadingRateAttachmentInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineFragmentShadingRateStateCreateInfoKHR.html>"]
pub struct PipelineFragmentShadingRateStateCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub fragment_size: Extent2D,
    pub combiner_ops: [FragmentShadingRateCombinerOpKHR; 2],
}
impl ::std::default::Default for PipelineFragmentShadingRateStateCreateInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            fragment_size: Extent2D::default(),
            combiner_ops: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for PipelineFragmentShadingRateStateCreateInfoKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR;
}
impl PipelineFragmentShadingRateStateCreateInfoKHR {
    pub fn builder<'a>() -> PipelineFragmentShadingRateStateCreateInfoKHRBuilder<'a> {
        PipelineFragmentShadingRateStateCreateInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineFragmentShadingRateStateCreateInfoKHRBuilder<'a> {
    inner: PipelineFragmentShadingRateStateCreateInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsGraphicsPipelineCreateInfo
    for PipelineFragmentShadingRateStateCreateInfoKHRBuilder<'_>
{
}
unsafe impl ExtendsGraphicsPipelineCreateInfo for PipelineFragmentShadingRateStateCreateInfoKHR {}
impl<'a> ::std::ops::Deref for PipelineFragmentShadingRateStateCreateInfoKHRBuilder<'a> {
    type Target = PipelineFragmentShadingRateStateCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineFragmentShadingRateStateCreateInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineFragmentShadingRateStateCreateInfoKHRBuilder<'a> {
    #[inline]
    pub fn fragment_size(mut self, fragment_size: Extent2D) -> Self {
        self.inner.fragment_size = fragment_size;
        self
    }
    #[inline]
    pub fn combiner_ops(mut self, combiner_ops: [FragmentShadingRateCombinerOpKHR; 2]) -> Self {
        self.inner.combiner_ops = combiner_ops;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineFragmentShadingRateStateCreateInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShadingRateFeaturesKHR.html>"]
pub struct PhysicalDeviceFragmentShadingRateFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pipeline_fragment_shading_rate: Bool32,
    pub primitive_fragment_shading_rate: Bool32,
    pub attachment_fragment_shading_rate: Bool32,
}
impl ::std::default::Default for PhysicalDeviceFragmentShadingRateFeaturesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            pipeline_fragment_shading_rate: Bool32::default(),
            primitive_fragment_shading_rate: Bool32::default(),
            attachment_fragment_shading_rate: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceFragmentShadingRateFeaturesKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR;
}
impl PhysicalDeviceFragmentShadingRateFeaturesKHR {
    pub fn builder<'a>() -> PhysicalDeviceFragmentShadingRateFeaturesKHRBuilder<'a> {
        PhysicalDeviceFragmentShadingRateFeaturesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceFragmentShadingRateFeaturesKHRBuilder<'a> {
    inner: PhysicalDeviceFragmentShadingRateFeaturesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceFragmentShadingRateFeaturesKHRBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceFragmentShadingRateFeaturesKHR {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentShadingRateFeaturesKHRBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentShadingRateFeaturesKHR {}
impl<'a> ::std::ops::Deref for PhysicalDeviceFragmentShadingRateFeaturesKHRBuilder<'a> {
    type Target = PhysicalDeviceFragmentShadingRateFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceFragmentShadingRateFeaturesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceFragmentShadingRateFeaturesKHRBuilder<'a> {
    #[inline]
    pub fn pipeline_fragment_shading_rate(mut self, pipeline_fragment_shading_rate: bool) -> Self {
        self.inner.pipeline_fragment_shading_rate = pipeline_fragment_shading_rate.into();
        self
    }
    #[inline]
    pub fn primitive_fragment_shading_rate(
        mut self,
        primitive_fragment_shading_rate: bool,
    ) -> Self {
        self.inner.primitive_fragment_shading_rate = primitive_fragment_shading_rate.into();
        self
    }
    #[inline]
    pub fn attachment_fragment_shading_rate(
        mut self,
        attachment_fragment_shading_rate: bool,
    ) -> Self {
        self.inner.attachment_fragment_shading_rate = attachment_fragment_shading_rate.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceFragmentShadingRateFeaturesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShadingRatePropertiesKHR.html>"]
pub struct PhysicalDeviceFragmentShadingRatePropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_fragment_shading_rate_attachment_texel_size: Extent2D,
    pub max_fragment_shading_rate_attachment_texel_size: Extent2D,
    pub max_fragment_shading_rate_attachment_texel_size_aspect_ratio: u32,
    pub primitive_fragment_shading_rate_with_multiple_viewports: Bool32,
    pub layered_shading_rate_attachments: Bool32,
    pub fragment_shading_rate_non_trivial_combiner_ops: Bool32,
    pub max_fragment_size: Extent2D,
    pub max_fragment_size_aspect_ratio: u32,
    pub max_fragment_shading_rate_coverage_samples: u32,
    pub max_fragment_shading_rate_rasterization_samples: SampleCountFlags,
    pub fragment_shading_rate_with_shader_depth_stencil_writes: Bool32,
    pub fragment_shading_rate_with_sample_mask: Bool32,
    pub fragment_shading_rate_with_shader_sample_mask: Bool32,
    pub fragment_shading_rate_with_conservative_rasterization: Bool32,
    pub fragment_shading_rate_with_fragment_shader_interlock: Bool32,
    pub fragment_shading_rate_with_custom_sample_locations: Bool32,
    pub fragment_shading_rate_strict_multiply_combiner: Bool32,
}
impl ::std::default::Default for PhysicalDeviceFragmentShadingRatePropertiesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            min_fragment_shading_rate_attachment_texel_size: Extent2D::default(),
            max_fragment_shading_rate_attachment_texel_size: Extent2D::default(),
            max_fragment_shading_rate_attachment_texel_size_aspect_ratio: u32::default(),
            primitive_fragment_shading_rate_with_multiple_viewports: Bool32::default(),
            layered_shading_rate_attachments: Bool32::default(),
            fragment_shading_rate_non_trivial_combiner_ops: Bool32::default(),
            max_fragment_size: Extent2D::default(),
            max_fragment_size_aspect_ratio: u32::default(),
            max_fragment_shading_rate_coverage_samples: u32::default(),
            max_fragment_shading_rate_rasterization_samples: SampleCountFlags::default(),
            fragment_shading_rate_with_shader_depth_stencil_writes: Bool32::default(),
            fragment_shading_rate_with_sample_mask: Bool32::default(),
            fragment_shading_rate_with_shader_sample_mask: Bool32::default(),
            fragment_shading_rate_with_conservative_rasterization: Bool32::default(),
            fragment_shading_rate_with_fragment_shader_interlock: Bool32::default(),
            fragment_shading_rate_with_custom_sample_locations: Bool32::default(),
            fragment_shading_rate_strict_multiply_combiner: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceFragmentShadingRatePropertiesKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR;
}
impl PhysicalDeviceFragmentShadingRatePropertiesKHR {
    pub fn builder<'a>() -> PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder<'a> {
        PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder<'a> {
    inner: PhysicalDeviceFragmentShadingRatePropertiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceFragmentShadingRatePropertiesKHR {}
impl<'a> ::std::ops::Deref for PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder<'a> {
    type Target = PhysicalDeviceFragmentShadingRatePropertiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder<'a> {
    #[inline]
    pub fn min_fragment_shading_rate_attachment_texel_size(
        mut self,
        min_fragment_shading_rate_attachment_texel_size: Extent2D,
    ) -> Self {
        self.inner.min_fragment_shading_rate_attachment_texel_size =
            min_fragment_shading_rate_attachment_texel_size;
        self
    }
    #[inline]
    pub fn max_fragment_shading_rate_attachment_texel_size(
        mut self,
        max_fragment_shading_rate_attachment_texel_size: Extent2D,
    ) -> Self {
        self.inner.max_fragment_shading_rate_attachment_texel_size =
            max_fragment_shading_rate_attachment_texel_size;
        self
    }
    #[inline]
    pub fn max_fragment_shading_rate_attachment_texel_size_aspect_ratio(
        mut self,
        max_fragment_shading_rate_attachment_texel_size_aspect_ratio: u32,
    ) -> Self {
        self.inner
            .max_fragment_shading_rate_attachment_texel_size_aspect_ratio =
            max_fragment_shading_rate_attachment_texel_size_aspect_ratio;
        self
    }
    #[inline]
    pub fn primitive_fragment_shading_rate_with_multiple_viewports(
        mut self,
        primitive_fragment_shading_rate_with_multiple_viewports: bool,
    ) -> Self {
        self.inner
            .primitive_fragment_shading_rate_with_multiple_viewports =
            primitive_fragment_shading_rate_with_multiple_viewports.into();
        self
    }
    #[inline]
    pub fn layered_shading_rate_attachments(
        mut self,
        layered_shading_rate_attachments: bool,
    ) -> Self {
        self.inner.layered_shading_rate_attachments = layered_shading_rate_attachments.into();
        self
    }
    #[inline]
    pub fn fragment_shading_rate_non_trivial_combiner_ops(
        mut self,
        fragment_shading_rate_non_trivial_combiner_ops: bool,
    ) -> Self {
        self.inner.fragment_shading_rate_non_trivial_combiner_ops =
            fragment_shading_rate_non_trivial_combiner_ops.into();
        self
    }
    #[inline]
    pub fn max_fragment_size(mut self, max_fragment_size: Extent2D) -> Self {
        self.inner.max_fragment_size = max_fragment_size;
        self
    }
    #[inline]
    pub fn max_fragment_size_aspect_ratio(mut self, max_fragment_size_aspect_ratio: u32) -> Self {
        self.inner.max_fragment_size_aspect_ratio = max_fragment_size_aspect_ratio;
        self
    }
    #[inline]
    pub fn max_fragment_shading_rate_coverage_samples(
        mut self,
        max_fragment_shading_rate_coverage_samples: u32,
    ) -> Self {
        self.inner.max_fragment_shading_rate_coverage_samples =
            max_fragment_shading_rate_coverage_samples;
        self
    }
    #[inline]
    pub fn max_fragment_shading_rate_rasterization_samples(
        mut self,
        max_fragment_shading_rate_rasterization_samples: SampleCountFlags,
    ) -> Self {
        self.inner.max_fragment_shading_rate_rasterization_samples =
            max_fragment_shading_rate_rasterization_samples;
        self
    }
    #[inline]
    pub fn fragment_shading_rate_with_shader_depth_stencil_writes(
        mut self,
        fragment_shading_rate_with_shader_depth_stencil_writes: bool,
    ) -> Self {
        self.inner
            .fragment_shading_rate_with_shader_depth_stencil_writes =
            fragment_shading_rate_with_shader_depth_stencil_writes.into();
        self
    }
    #[inline]
    pub fn fragment_shading_rate_with_sample_mask(
        mut self,
        fragment_shading_rate_with_sample_mask: bool,
    ) -> Self {
        self.inner.fragment_shading_rate_with_sample_mask =
            fragment_shading_rate_with_sample_mask.into();
        self
    }
    #[inline]
    pub fn fragment_shading_rate_with_shader_sample_mask(
        mut self,
        fragment_shading_rate_with_shader_sample_mask: bool,
    ) -> Self {
        self.inner.fragment_shading_rate_with_shader_sample_mask =
            fragment_shading_rate_with_shader_sample_mask.into();
        self
    }
    #[inline]
    pub fn fragment_shading_rate_with_conservative_rasterization(
        mut self,
        fragment_shading_rate_with_conservative_rasterization: bool,
    ) -> Self {
        self.inner
            .fragment_shading_rate_with_conservative_rasterization =
            fragment_shading_rate_with_conservative_rasterization.into();
        self
    }
    #[inline]
    pub fn fragment_shading_rate_with_fragment_shader_interlock(
        mut self,
        fragment_shading_rate_with_fragment_shader_interlock: bool,
    ) -> Self {
        self.inner
            .fragment_shading_rate_with_fragment_shader_interlock =
            fragment_shading_rate_with_fragment_shader_interlock.into();
        self
    }
    #[inline]
    pub fn fragment_shading_rate_with_custom_sample_locations(
        mut self,
        fragment_shading_rate_with_custom_sample_locations: bool,
    ) -> Self {
        self.inner
            .fragment_shading_rate_with_custom_sample_locations =
            fragment_shading_rate_with_custom_sample_locations.into();
        self
    }
    #[inline]
    pub fn fragment_shading_rate_strict_multiply_combiner(
        mut self,
        fragment_shading_rate_strict_multiply_combiner: bool,
    ) -> Self {
        self.inner.fragment_shading_rate_strict_multiply_combiner =
            fragment_shading_rate_strict_multiply_combiner.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceFragmentShadingRatePropertiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShadingRateKHR.html>"]
pub struct PhysicalDeviceFragmentShadingRateKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub sample_counts: SampleCountFlags,
    pub fragment_size: Extent2D,
}
impl ::std::default::Default for PhysicalDeviceFragmentShadingRateKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            sample_counts: SampleCountFlags::default(),
            fragment_size: Extent2D::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceFragmentShadingRateKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR;
}
impl PhysicalDeviceFragmentShadingRateKHR {
    pub fn builder<'a>() -> PhysicalDeviceFragmentShadingRateKHRBuilder<'a> {
        PhysicalDeviceFragmentShadingRateKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceFragmentShadingRateKHRBuilder<'a> {
    inner: PhysicalDeviceFragmentShadingRateKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PhysicalDeviceFragmentShadingRateKHRBuilder<'a> {
    type Target = PhysicalDeviceFragmentShadingRateKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceFragmentShadingRateKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceFragmentShadingRateKHRBuilder<'a> {
    #[inline]
    pub fn sample_counts(mut self, sample_counts: SampleCountFlags) -> Self {
        self.inner.sample_counts = sample_counts;
        self
    }
    #[inline]
    pub fn fragment_size(mut self, fragment_size: Extent2D) -> Self {
        self.inner.fragment_size = fragment_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceFragmentShadingRateKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderTerminateInvocationFeatures.html>"]
pub struct PhysicalDeviceShaderTerminateInvocationFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_terminate_invocation: Bool32,
}
impl ::std::default::Default for PhysicalDeviceShaderTerminateInvocationFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_terminate_invocation: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderTerminateInvocationFeatures {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES;
}
impl PhysicalDeviceShaderTerminateInvocationFeatures {
    pub fn builder<'a>() -> PhysicalDeviceShaderTerminateInvocationFeaturesBuilder<'a> {
        PhysicalDeviceShaderTerminateInvocationFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderTerminateInvocationFeaturesBuilder<'a> {
    inner: PhysicalDeviceShaderTerminateInvocationFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceShaderTerminateInvocationFeaturesBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderTerminateInvocationFeatures {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderTerminateInvocationFeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderTerminateInvocationFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderTerminateInvocationFeaturesBuilder<'a> {
    type Target = PhysicalDeviceShaderTerminateInvocationFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderTerminateInvocationFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderTerminateInvocationFeaturesBuilder<'a> {
    #[inline]
    pub fn shader_terminate_invocation(mut self, shader_terminate_invocation: bool) -> Self {
        self.inner.shader_terminate_invocation = shader_terminate_invocation.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderTerminateInvocationFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.html>"]
pub struct PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub fragment_shading_rate_enums: Bool32,
    pub supersample_fragment_shading_rates: Bool32,
    pub no_invocation_fragment_shading_rates: Bool32,
}
impl ::std::default::Default for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            fragment_shading_rate_enums: Bool32::default(),
            supersample_fragment_shading_rates: Bool32::default(),
            no_invocation_fragment_shading_rates: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV;
}
impl PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
    pub fn builder<'a>() -> PhysicalDeviceFragmentShadingRateEnumsFeaturesNVBuilder<'a> {
        PhysicalDeviceFragmentShadingRateEnumsFeaturesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceFragmentShadingRateEnumsFeaturesNVBuilder<'a> {
    inner: PhysicalDeviceFragmentShadingRateEnumsFeaturesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceFragmentShadingRateEnumsFeaturesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceFragmentShadingRateEnumsFeaturesNVBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceFragmentShadingRateEnumsFeaturesNVBuilder<'a> {
    type Target = PhysicalDeviceFragmentShadingRateEnumsFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceFragmentShadingRateEnumsFeaturesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceFragmentShadingRateEnumsFeaturesNVBuilder<'a> {
    #[inline]
    pub fn fragment_shading_rate_enums(mut self, fragment_shading_rate_enums: bool) -> Self {
        self.inner.fragment_shading_rate_enums = fragment_shading_rate_enums.into();
        self
    }
    #[inline]
    pub fn supersample_fragment_shading_rates(
        mut self,
        supersample_fragment_shading_rates: bool,
    ) -> Self {
        self.inner.supersample_fragment_shading_rates = supersample_fragment_shading_rates.into();
        self
    }
    #[inline]
    pub fn no_invocation_fragment_shading_rates(
        mut self,
        no_invocation_fragment_shading_rates: bool,
    ) -> Self {
        self.inner.no_invocation_fragment_shading_rates =
            no_invocation_fragment_shading_rates.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV.html>"]
pub struct PhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_fragment_shading_rate_invocation_count: SampleCountFlags,
}
impl ::std::default::Default for PhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_fragment_shading_rate_invocation_count: SampleCountFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV;
}
impl PhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
    pub fn builder<'a>() -> PhysicalDeviceFragmentShadingRateEnumsPropertiesNVBuilder<'a> {
        PhysicalDeviceFragmentShadingRateEnumsPropertiesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceFragmentShadingRateEnumsPropertiesNVBuilder<'a> {
    inner: PhysicalDeviceFragmentShadingRateEnumsPropertiesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceFragmentShadingRateEnumsPropertiesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceFragmentShadingRateEnumsPropertiesNV
{
}
impl<'a> ::std::ops::Deref for PhysicalDeviceFragmentShadingRateEnumsPropertiesNVBuilder<'a> {
    type Target = PhysicalDeviceFragmentShadingRateEnumsPropertiesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceFragmentShadingRateEnumsPropertiesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceFragmentShadingRateEnumsPropertiesNVBuilder<'a> {
    #[inline]
    pub fn max_fragment_shading_rate_invocation_count(
        mut self,
        max_fragment_shading_rate_invocation_count: SampleCountFlags,
    ) -> Self {
        self.inner.max_fragment_shading_rate_invocation_count =
            max_fragment_shading_rate_invocation_count;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineFragmentShadingRateEnumStateCreateInfoNV.html>"]
pub struct PipelineFragmentShadingRateEnumStateCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub shading_rate_type: FragmentShadingRateTypeNV,
    pub shading_rate: FragmentShadingRateNV,
    pub combiner_ops: [FragmentShadingRateCombinerOpKHR; 2],
}
impl ::std::default::Default for PipelineFragmentShadingRateEnumStateCreateInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            shading_rate_type: FragmentShadingRateTypeNV::default(),
            shading_rate: FragmentShadingRateNV::default(),
            combiner_ops: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for PipelineFragmentShadingRateEnumStateCreateInfoNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV;
}
impl PipelineFragmentShadingRateEnumStateCreateInfoNV {
    pub fn builder<'a>() -> PipelineFragmentShadingRateEnumStateCreateInfoNVBuilder<'a> {
        PipelineFragmentShadingRateEnumStateCreateInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineFragmentShadingRateEnumStateCreateInfoNVBuilder<'a> {
    inner: PipelineFragmentShadingRateEnumStateCreateInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsGraphicsPipelineCreateInfo
    for PipelineFragmentShadingRateEnumStateCreateInfoNVBuilder<'_>
{
}
unsafe impl ExtendsGraphicsPipelineCreateInfo for PipelineFragmentShadingRateEnumStateCreateInfoNV {}
impl<'a> ::std::ops::Deref for PipelineFragmentShadingRateEnumStateCreateInfoNVBuilder<'a> {
    type Target = PipelineFragmentShadingRateEnumStateCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineFragmentShadingRateEnumStateCreateInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineFragmentShadingRateEnumStateCreateInfoNVBuilder<'a> {
    #[inline]
    pub fn shading_rate_type(mut self, shading_rate_type: FragmentShadingRateTypeNV) -> Self {
        self.inner.shading_rate_type = shading_rate_type;
        self
    }
    #[inline]
    pub fn shading_rate(mut self, shading_rate: FragmentShadingRateNV) -> Self {
        self.inner.shading_rate = shading_rate;
        self
    }
    #[inline]
    pub fn combiner_ops(mut self, combiner_ops: [FragmentShadingRateCombinerOpKHR; 2]) -> Self {
        self.inner.combiner_ops = combiner_ops;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineFragmentShadingRateEnumStateCreateInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureBuildSizesInfoKHR.html>"]
pub struct AccelerationStructureBuildSizesInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acceleration_structure_size: DeviceSize,
    pub update_scratch_size: DeviceSize,
    pub build_scratch_size: DeviceSize,
}
impl ::std::default::Default for AccelerationStructureBuildSizesInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            acceleration_structure_size: DeviceSize::default(),
            update_scratch_size: DeviceSize::default(),
            build_scratch_size: DeviceSize::default(),
        }
    }
}
unsafe impl TaggedStructure for AccelerationStructureBuildSizesInfoKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR;
}
impl AccelerationStructureBuildSizesInfoKHR {
    pub fn builder<'a>() -> AccelerationStructureBuildSizesInfoKHRBuilder<'a> {
        AccelerationStructureBuildSizesInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AccelerationStructureBuildSizesInfoKHRBuilder<'a> {
    inner: AccelerationStructureBuildSizesInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for AccelerationStructureBuildSizesInfoKHRBuilder<'a> {
    type Target = AccelerationStructureBuildSizesInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AccelerationStructureBuildSizesInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AccelerationStructureBuildSizesInfoKHRBuilder<'a> {
    #[inline]
    pub fn acceleration_structure_size(mut self, acceleration_structure_size: DeviceSize) -> Self {
        self.inner.acceleration_structure_size = acceleration_structure_size;
        self
    }
    #[inline]
    pub fn update_scratch_size(mut self, update_scratch_size: DeviceSize) -> Self {
        self.inner.update_scratch_size = update_scratch_size;
        self
    }
    #[inline]
    pub fn build_scratch_size(mut self, build_scratch_size: DeviceSize) -> Self {
        self.inner.build_scratch_size = build_scratch_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AccelerationStructureBuildSizesInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImage2DViewOf3DFeaturesEXT.html>"]
pub struct PhysicalDeviceImage2DViewOf3DFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image2_d_view_of3_d: Bool32,
    pub sampler2_d_view_of3_d: Bool32,
}
impl ::std::default::Default for PhysicalDeviceImage2DViewOf3DFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            image2_d_view_of3_d: Bool32::default(),
            sampler2_d_view_of3_d: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceImage2DViewOf3DFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT;
}
impl PhysicalDeviceImage2DViewOf3DFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceImage2DViewOf3DFeaturesEXTBuilder<'a> {
        PhysicalDeviceImage2DViewOf3DFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceImage2DViewOf3DFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceImage2DViewOf3DFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceImage2DViewOf3DFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceImage2DViewOf3DFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceImage2DViewOf3DFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceImage2DViewOf3DFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceImage2DViewOf3DFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceImage2DViewOf3DFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceImage2DViewOf3DFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceImage2DViewOf3DFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn image2_d_view_of3_d(mut self, image2_d_view_of3_d: bool) -> Self {
        self.inner.image2_d_view_of3_d = image2_d_view_of3_d.into();
        self
    }
    #[inline]
    pub fn sampler2_d_view_of3_d(mut self, sampler2_d_view_of3_d: bool) -> Self {
        self.inner.sampler2_d_view_of3_d = sampler2_d_view_of3_d.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceImage2DViewOf3DFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT.html>"]
pub struct PhysicalDeviceImageSlicedViewOf3DFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_sliced_view_of3_d: Bool32,
}
impl ::std::default::Default for PhysicalDeviceImageSlicedViewOf3DFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            image_sliced_view_of3_d: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceImageSlicedViewOf3DFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT;
}
impl PhysicalDeviceImageSlicedViewOf3DFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceImageSlicedViewOf3DFeaturesEXTBuilder<'a> {
        PhysicalDeviceImageSlicedViewOf3DFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceImageSlicedViewOf3DFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceImageSlicedViewOf3DFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceImageSlicedViewOf3DFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceImageSlicedViewOf3DFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceImageSlicedViewOf3DFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceImageSlicedViewOf3DFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceImageSlicedViewOf3DFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceImageSlicedViewOf3DFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceImageSlicedViewOf3DFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceImageSlicedViewOf3DFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn image_sliced_view_of3_d(mut self, image_sliced_view_of3_d: bool) -> Self {
        self.inner.image_sliced_view_of3_d = image_sliced_view_of3_d.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceImageSlicedViewOf3DFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT.html>"]
pub struct PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub attachment_feedback_loop_dynamic_state: Bool32,
}
impl ::std::default::Default for PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            attachment_feedback_loop_dynamic_state: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT;
}
impl PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXTBuilder<'a> {
        PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT
{
}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT
{
}
impl<'a> ::std::ops::Deref
    for PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXTBuilder<'a>
{
    type Target = PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut
    for PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXTBuilder<'a>
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn attachment_feedback_loop_dynamic_state(
        mut self,
        attachment_feedback_loop_dynamic_state: bool,
    ) -> Self {
        self.inner.attachment_feedback_loop_dynamic_state =
            attachment_feedback_loop_dynamic_state.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT.html>"]
pub struct PhysicalDeviceMutableDescriptorTypeFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub mutable_descriptor_type: Bool32,
}
impl ::std::default::Default for PhysicalDeviceMutableDescriptorTypeFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            mutable_descriptor_type: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceMutableDescriptorTypeFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT;
}
impl PhysicalDeviceMutableDescriptorTypeFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceMutableDescriptorTypeFeaturesEXTBuilder<'a> {
        PhysicalDeviceMutableDescriptorTypeFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceMutableDescriptorTypeFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceMutableDescriptorTypeFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceMutableDescriptorTypeFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMutableDescriptorTypeFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMutableDescriptorTypeFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMutableDescriptorTypeFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceMutableDescriptorTypeFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceMutableDescriptorTypeFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceMutableDescriptorTypeFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceMutableDescriptorTypeFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn mutable_descriptor_type(mut self, mutable_descriptor_type: bool) -> Self {
        self.inner.mutable_descriptor_type = mutable_descriptor_type.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceMutableDescriptorTypeFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMutableDescriptorTypeListEXT.html>"]
pub struct MutableDescriptorTypeListEXT {
    pub descriptor_type_count: u32,
    pub p_descriptor_types: *const DescriptorType,
}
impl ::std::default::Default for MutableDescriptorTypeListEXT {
    #[inline]
    fn default() -> Self {
        Self {
            descriptor_type_count: u32::default(),
            p_descriptor_types: ::std::ptr::null(),
        }
    }
}
impl MutableDescriptorTypeListEXT {
    pub fn builder<'a>() -> MutableDescriptorTypeListEXTBuilder<'a> {
        MutableDescriptorTypeListEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MutableDescriptorTypeListEXTBuilder<'a> {
    inner: MutableDescriptorTypeListEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MutableDescriptorTypeListEXTBuilder<'a> {
    type Target = MutableDescriptorTypeListEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MutableDescriptorTypeListEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MutableDescriptorTypeListEXTBuilder<'a> {
    #[inline]
    pub fn descriptor_types(mut self, descriptor_types: &'a [DescriptorType]) -> Self {
        self.inner.descriptor_type_count = descriptor_types.len() as _;
        self.inner.p_descriptor_types = descriptor_types.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MutableDescriptorTypeListEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMutableDescriptorTypeCreateInfoEXT.html>"]
pub struct MutableDescriptorTypeCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub mutable_descriptor_type_list_count: u32,
    pub p_mutable_descriptor_type_lists: *const MutableDescriptorTypeListEXT,
}
impl ::std::default::Default for MutableDescriptorTypeCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            mutable_descriptor_type_list_count: u32::default(),
            p_mutable_descriptor_type_lists: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for MutableDescriptorTypeCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT;
}
impl MutableDescriptorTypeCreateInfoEXT {
    pub fn builder<'a>() -> MutableDescriptorTypeCreateInfoEXTBuilder<'a> {
        MutableDescriptorTypeCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MutableDescriptorTypeCreateInfoEXTBuilder<'a> {
    inner: MutableDescriptorTypeCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsDescriptorSetLayoutCreateInfo for MutableDescriptorTypeCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsDescriptorSetLayoutCreateInfo for MutableDescriptorTypeCreateInfoEXT {}
unsafe impl ExtendsDescriptorPoolCreateInfo for MutableDescriptorTypeCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsDescriptorPoolCreateInfo for MutableDescriptorTypeCreateInfoEXT {}
impl<'a> ::std::ops::Deref for MutableDescriptorTypeCreateInfoEXTBuilder<'a> {
    type Target = MutableDescriptorTypeCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MutableDescriptorTypeCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MutableDescriptorTypeCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn mutable_descriptor_type_lists(
        mut self,
        mutable_descriptor_type_lists: &'a [MutableDescriptorTypeListEXT],
    ) -> Self {
        self.inner.mutable_descriptor_type_list_count = mutable_descriptor_type_lists.len() as _;
        self.inner.p_mutable_descriptor_type_lists = mutable_descriptor_type_lists.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MutableDescriptorTypeCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDepthClipControlFeaturesEXT.html>"]
pub struct PhysicalDeviceDepthClipControlFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub depth_clip_control: Bool32,
}
impl ::std::default::Default for PhysicalDeviceDepthClipControlFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            depth_clip_control: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceDepthClipControlFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT;
}
impl PhysicalDeviceDepthClipControlFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceDepthClipControlFeaturesEXTBuilder<'a> {
        PhysicalDeviceDepthClipControlFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceDepthClipControlFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceDepthClipControlFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceDepthClipControlFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDepthClipControlFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDepthClipControlFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDepthClipControlFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceDepthClipControlFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceDepthClipControlFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceDepthClipControlFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceDepthClipControlFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn depth_clip_control(mut self, depth_clip_control: bool) -> Self {
        self.inner.depth_clip_control = depth_clip_control.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceDepthClipControlFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportDepthClipControlCreateInfoEXT.html>"]
pub struct PipelineViewportDepthClipControlCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub negative_one_to_one: Bool32,
}
impl ::std::default::Default for PipelineViewportDepthClipControlCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            negative_one_to_one: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineViewportDepthClipControlCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT;
}
impl PipelineViewportDepthClipControlCreateInfoEXT {
    pub fn builder<'a>() -> PipelineViewportDepthClipControlCreateInfoEXTBuilder<'a> {
        PipelineViewportDepthClipControlCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineViewportDepthClipControlCreateInfoEXTBuilder<'a> {
    inner: PipelineViewportDepthClipControlCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPipelineViewportStateCreateInfo
    for PipelineViewportDepthClipControlCreateInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsPipelineViewportStateCreateInfo
    for PipelineViewportDepthClipControlCreateInfoEXT
{
}
impl<'a> ::std::ops::Deref for PipelineViewportDepthClipControlCreateInfoEXTBuilder<'a> {
    type Target = PipelineViewportDepthClipControlCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineViewportDepthClipControlCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineViewportDepthClipControlCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn negative_one_to_one(mut self, negative_one_to_one: bool) -> Self {
        self.inner.negative_one_to_one = negative_one_to_one.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineViewportDepthClipControlCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT.html>"]
pub struct PhysicalDeviceVertexInputDynamicStateFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub vertex_input_dynamic_state: Bool32,
}
impl ::std::default::Default for PhysicalDeviceVertexInputDynamicStateFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            vertex_input_dynamic_state: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceVertexInputDynamicStateFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT;
}
impl PhysicalDeviceVertexInputDynamicStateFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceVertexInputDynamicStateFeaturesEXTBuilder<'a> {
        PhysicalDeviceVertexInputDynamicStateFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceVertexInputDynamicStateFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceVertexInputDynamicStateFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceVertexInputDynamicStateFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVertexInputDynamicStateFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceVertexInputDynamicStateFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVertexInputDynamicStateFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceVertexInputDynamicStateFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceVertexInputDynamicStateFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceVertexInputDynamicStateFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceVertexInputDynamicStateFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn vertex_input_dynamic_state(mut self, vertex_input_dynamic_state: bool) -> Self {
        self.inner.vertex_input_dynamic_state = vertex_input_dynamic_state.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceVertexInputDynamicStateFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalMemoryRDMAFeaturesNV.html>"]
pub struct PhysicalDeviceExternalMemoryRDMAFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub external_memory_rdma: Bool32,
}
impl ::std::default::Default for PhysicalDeviceExternalMemoryRDMAFeaturesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            external_memory_rdma: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceExternalMemoryRDMAFeaturesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV;
}
impl PhysicalDeviceExternalMemoryRDMAFeaturesNV {
    pub fn builder<'a>() -> PhysicalDeviceExternalMemoryRDMAFeaturesNVBuilder<'a> {
        PhysicalDeviceExternalMemoryRDMAFeaturesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceExternalMemoryRDMAFeaturesNVBuilder<'a> {
    inner: PhysicalDeviceExternalMemoryRDMAFeaturesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceExternalMemoryRDMAFeaturesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceExternalMemoryRDMAFeaturesNV {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceExternalMemoryRDMAFeaturesNVBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceExternalMemoryRDMAFeaturesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceExternalMemoryRDMAFeaturesNVBuilder<'a> {
    type Target = PhysicalDeviceExternalMemoryRDMAFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceExternalMemoryRDMAFeaturesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceExternalMemoryRDMAFeaturesNVBuilder<'a> {
    #[inline]
    pub fn external_memory_rdma(mut self, external_memory_rdma: bool) -> Self {
        self.inner.external_memory_rdma = external_memory_rdma.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceExternalMemoryRDMAFeaturesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVertexInputBindingDescription2EXT.html>"]
pub struct VertexInputBindingDescription2EXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub binding: u32,
    pub stride: u32,
    pub input_rate: VertexInputRate,
    pub divisor: u32,
}
impl ::std::default::Default for VertexInputBindingDescription2EXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            binding: u32::default(),
            stride: u32::default(),
            input_rate: VertexInputRate::default(),
            divisor: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for VertexInputBindingDescription2EXT {
    const STRUCTURE_TYPE: StructureType = StructureType::VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT;
}
impl VertexInputBindingDescription2EXT {
    pub fn builder<'a>() -> VertexInputBindingDescription2EXTBuilder<'a> {
        VertexInputBindingDescription2EXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VertexInputBindingDescription2EXTBuilder<'a> {
    inner: VertexInputBindingDescription2EXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for VertexInputBindingDescription2EXTBuilder<'a> {
    type Target = VertexInputBindingDescription2EXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VertexInputBindingDescription2EXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VertexInputBindingDescription2EXTBuilder<'a> {
    #[inline]
    pub fn binding(mut self, binding: u32) -> Self {
        self.inner.binding = binding;
        self
    }
    #[inline]
    pub fn stride(mut self, stride: u32) -> Self {
        self.inner.stride = stride;
        self
    }
    #[inline]
    pub fn input_rate(mut self, input_rate: VertexInputRate) -> Self {
        self.inner.input_rate = input_rate;
        self
    }
    #[inline]
    pub fn divisor(mut self, divisor: u32) -> Self {
        self.inner.divisor = divisor;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VertexInputBindingDescription2EXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVertexInputAttributeDescription2EXT.html>"]
pub struct VertexInputAttributeDescription2EXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub location: u32,
    pub binding: u32,
    pub format: Format,
    pub offset: u32,
}
impl ::std::default::Default for VertexInputAttributeDescription2EXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            location: u32::default(),
            binding: u32::default(),
            format: Format::default(),
            offset: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for VertexInputAttributeDescription2EXT {
    const STRUCTURE_TYPE: StructureType = StructureType::VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT;
}
impl VertexInputAttributeDescription2EXT {
    pub fn builder<'a>() -> VertexInputAttributeDescription2EXTBuilder<'a> {
        VertexInputAttributeDescription2EXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VertexInputAttributeDescription2EXTBuilder<'a> {
    inner: VertexInputAttributeDescription2EXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for VertexInputAttributeDescription2EXTBuilder<'a> {
    type Target = VertexInputAttributeDescription2EXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VertexInputAttributeDescription2EXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VertexInputAttributeDescription2EXTBuilder<'a> {
    #[inline]
    pub fn location(mut self, location: u32) -> Self {
        self.inner.location = location;
        self
    }
    #[inline]
    pub fn binding(mut self, binding: u32) -> Self {
        self.inner.binding = binding;
        self
    }
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.inner.format = format;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: u32) -> Self {
        self.inner.offset = offset;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VertexInputAttributeDescription2EXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceColorWriteEnableFeaturesEXT.html>"]
pub struct PhysicalDeviceColorWriteEnableFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub color_write_enable: Bool32,
}
impl ::std::default::Default for PhysicalDeviceColorWriteEnableFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            color_write_enable: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceColorWriteEnableFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT;
}
impl PhysicalDeviceColorWriteEnableFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceColorWriteEnableFeaturesEXTBuilder<'a> {
        PhysicalDeviceColorWriteEnableFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceColorWriteEnableFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceColorWriteEnableFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceColorWriteEnableFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceColorWriteEnableFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceColorWriteEnableFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceColorWriteEnableFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceColorWriteEnableFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceColorWriteEnableFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceColorWriteEnableFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceColorWriteEnableFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn color_write_enable(mut self, color_write_enable: bool) -> Self {
        self.inner.color_write_enable = color_write_enable.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceColorWriteEnableFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineColorWriteCreateInfoEXT.html>"]
pub struct PipelineColorWriteCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub attachment_count: u32,
    pub p_color_write_enables: *const Bool32,
}
impl ::std::default::Default for PipelineColorWriteCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            attachment_count: u32::default(),
            p_color_write_enables: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for PipelineColorWriteCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_COLOR_WRITE_CREATE_INFO_EXT;
}
impl PipelineColorWriteCreateInfoEXT {
    pub fn builder<'a>() -> PipelineColorWriteCreateInfoEXTBuilder<'a> {
        PipelineColorWriteCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineColorWriteCreateInfoEXTBuilder<'a> {
    inner: PipelineColorWriteCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPipelineColorBlendStateCreateInfo
    for PipelineColorWriteCreateInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsPipelineColorBlendStateCreateInfo for PipelineColorWriteCreateInfoEXT {}
impl<'a> ::std::ops::Deref for PipelineColorWriteCreateInfoEXTBuilder<'a> {
    type Target = PipelineColorWriteCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineColorWriteCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineColorWriteCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn color_write_enables(mut self, color_write_enables: &'a [Bool32]) -> Self {
        self.inner.attachment_count = color_write_enables.len() as _;
        self.inner.p_color_write_enables = color_write_enables.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineColorWriteCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryBarrier2.html>"]
pub struct MemoryBarrier2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_stage_mask: PipelineStageFlags2,
    pub src_access_mask: AccessFlags2,
    pub dst_stage_mask: PipelineStageFlags2,
    pub dst_access_mask: AccessFlags2,
}
impl ::std::default::Default for MemoryBarrier2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_stage_mask: PipelineStageFlags2::default(),
            src_access_mask: AccessFlags2::default(),
            dst_stage_mask: PipelineStageFlags2::default(),
            dst_access_mask: AccessFlags2::default(),
        }
    }
}
unsafe impl TaggedStructure for MemoryBarrier2 {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_BARRIER_2;
}
impl MemoryBarrier2 {
    pub fn builder<'a>() -> MemoryBarrier2Builder<'a> {
        MemoryBarrier2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MemoryBarrier2Builder<'a> {
    inner: MemoryBarrier2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSubpassDependency2 for MemoryBarrier2Builder<'_> {}
unsafe impl ExtendsSubpassDependency2 for MemoryBarrier2 {}
impl<'a> ::std::ops::Deref for MemoryBarrier2Builder<'a> {
    type Target = MemoryBarrier2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MemoryBarrier2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MemoryBarrier2Builder<'a> {
    #[inline]
    pub fn src_stage_mask(mut self, src_stage_mask: PipelineStageFlags2) -> Self {
        self.inner.src_stage_mask = src_stage_mask;
        self
    }
    #[inline]
    pub fn src_access_mask(mut self, src_access_mask: AccessFlags2) -> Self {
        self.inner.src_access_mask = src_access_mask;
        self
    }
    #[inline]
    pub fn dst_stage_mask(mut self, dst_stage_mask: PipelineStageFlags2) -> Self {
        self.inner.dst_stage_mask = dst_stage_mask;
        self
    }
    #[inline]
    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags2) -> Self {
        self.inner.dst_access_mask = dst_access_mask;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MemoryBarrier2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageMemoryBarrier2.html>"]
pub struct ImageMemoryBarrier2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_stage_mask: PipelineStageFlags2,
    pub src_access_mask: AccessFlags2,
    pub dst_stage_mask: PipelineStageFlags2,
    pub dst_access_mask: AccessFlags2,
    pub old_layout: ImageLayout,
    pub new_layout: ImageLayout,
    pub src_queue_family_index: u32,
    pub dst_queue_family_index: u32,
    pub image: Image,
    pub subresource_range: ImageSubresourceRange,
}
impl ::std::default::Default for ImageMemoryBarrier2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_stage_mask: PipelineStageFlags2::default(),
            src_access_mask: AccessFlags2::default(),
            dst_stage_mask: PipelineStageFlags2::default(),
            dst_access_mask: AccessFlags2::default(),
            old_layout: ImageLayout::default(),
            new_layout: ImageLayout::default(),
            src_queue_family_index: u32::default(),
            dst_queue_family_index: u32::default(),
            image: Image::default(),
            subresource_range: ImageSubresourceRange::default(),
        }
    }
}
unsafe impl TaggedStructure for ImageMemoryBarrier2 {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_MEMORY_BARRIER_2;
}
impl ImageMemoryBarrier2 {
    pub fn builder<'a>() -> ImageMemoryBarrier2Builder<'a> {
        ImageMemoryBarrier2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageMemoryBarrier2Builder<'a> {
    inner: ImageMemoryBarrier2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsImageMemoryBarrier2 {}
impl<'a> ::std::ops::Deref for ImageMemoryBarrier2Builder<'a> {
    type Target = ImageMemoryBarrier2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageMemoryBarrier2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageMemoryBarrier2Builder<'a> {
    #[inline]
    pub fn src_stage_mask(mut self, src_stage_mask: PipelineStageFlags2) -> Self {
        self.inner.src_stage_mask = src_stage_mask;
        self
    }
    #[inline]
    pub fn src_access_mask(mut self, src_access_mask: AccessFlags2) -> Self {
        self.inner.src_access_mask = src_access_mask;
        self
    }
    #[inline]
    pub fn dst_stage_mask(mut self, dst_stage_mask: PipelineStageFlags2) -> Self {
        self.inner.dst_stage_mask = dst_stage_mask;
        self
    }
    #[inline]
    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags2) -> Self {
        self.inner.dst_access_mask = dst_access_mask;
        self
    }
    #[inline]
    pub fn old_layout(mut self, old_layout: ImageLayout) -> Self {
        self.inner.old_layout = old_layout;
        self
    }
    #[inline]
    pub fn new_layout(mut self, new_layout: ImageLayout) -> Self {
        self.inner.new_layout = new_layout;
        self
    }
    #[inline]
    pub fn src_queue_family_index(mut self, src_queue_family_index: u32) -> Self {
        self.inner.src_queue_family_index = src_queue_family_index;
        self
    }
    #[inline]
    pub fn dst_queue_family_index(mut self, dst_queue_family_index: u32) -> Self {
        self.inner.dst_queue_family_index = dst_queue_family_index;
        self
    }
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.inner.image = image;
        self
    }
    #[inline]
    pub fn subresource_range(mut self, subresource_range: ImageSubresourceRange) -> Self {
        self.inner.subresource_range = subresource_range;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsImageMemoryBarrier2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageMemoryBarrier2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferMemoryBarrier2.html>"]
pub struct BufferMemoryBarrier2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src_stage_mask: PipelineStageFlags2,
    pub src_access_mask: AccessFlags2,
    pub dst_stage_mask: PipelineStageFlags2,
    pub dst_access_mask: AccessFlags2,
    pub src_queue_family_index: u32,
    pub dst_queue_family_index: u32,
    pub buffer: Buffer,
    pub offset: DeviceSize,
    pub size: DeviceSize,
}
impl ::std::default::Default for BufferMemoryBarrier2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src_stage_mask: PipelineStageFlags2::default(),
            src_access_mask: AccessFlags2::default(),
            dst_stage_mask: PipelineStageFlags2::default(),
            dst_access_mask: AccessFlags2::default(),
            src_queue_family_index: u32::default(),
            dst_queue_family_index: u32::default(),
            buffer: Buffer::default(),
            offset: DeviceSize::default(),
            size: DeviceSize::default(),
        }
    }
}
unsafe impl TaggedStructure for BufferMemoryBarrier2 {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_MEMORY_BARRIER_2;
}
impl BufferMemoryBarrier2 {
    pub fn builder<'a>() -> BufferMemoryBarrier2Builder<'a> {
        BufferMemoryBarrier2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BufferMemoryBarrier2Builder<'a> {
    inner: BufferMemoryBarrier2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for BufferMemoryBarrier2Builder<'a> {
    type Target = BufferMemoryBarrier2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BufferMemoryBarrier2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BufferMemoryBarrier2Builder<'a> {
    #[inline]
    pub fn src_stage_mask(mut self, src_stage_mask: PipelineStageFlags2) -> Self {
        self.inner.src_stage_mask = src_stage_mask;
        self
    }
    #[inline]
    pub fn src_access_mask(mut self, src_access_mask: AccessFlags2) -> Self {
        self.inner.src_access_mask = src_access_mask;
        self
    }
    #[inline]
    pub fn dst_stage_mask(mut self, dst_stage_mask: PipelineStageFlags2) -> Self {
        self.inner.dst_stage_mask = dst_stage_mask;
        self
    }
    #[inline]
    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags2) -> Self {
        self.inner.dst_access_mask = dst_access_mask;
        self
    }
    #[inline]
    pub fn src_queue_family_index(mut self, src_queue_family_index: u32) -> Self {
        self.inner.src_queue_family_index = src_queue_family_index;
        self
    }
    #[inline]
    pub fn dst_queue_family_index(mut self, dst_queue_family_index: u32) -> Self {
        self.inner.dst_queue_family_index = dst_queue_family_index;
        self
    }
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: DeviceSize) -> Self {
        self.inner.offset = offset;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BufferMemoryBarrier2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDependencyInfo.html>"]
pub struct DependencyInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub dependency_flags: DependencyFlags,
    pub memory_barrier_count: u32,
    pub p_memory_barriers: *const MemoryBarrier2,
    pub buffer_memory_barrier_count: u32,
    pub p_buffer_memory_barriers: *const BufferMemoryBarrier2,
    pub image_memory_barrier_count: u32,
    pub p_image_memory_barriers: *const ImageMemoryBarrier2,
}
impl ::std::default::Default for DependencyInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            dependency_flags: DependencyFlags::default(),
            memory_barrier_count: u32::default(),
            p_memory_barriers: ::std::ptr::null(),
            buffer_memory_barrier_count: u32::default(),
            p_buffer_memory_barriers: ::std::ptr::null(),
            image_memory_barrier_count: u32::default(),
            p_image_memory_barriers: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for DependencyInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::DEPENDENCY_INFO;
}
impl DependencyInfo {
    pub fn builder<'a>() -> DependencyInfoBuilder<'a> {
        DependencyInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DependencyInfoBuilder<'a> {
    inner: DependencyInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DependencyInfoBuilder<'a> {
    type Target = DependencyInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DependencyInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DependencyInfoBuilder<'a> {
    #[inline]
    pub fn dependency_flags(mut self, dependency_flags: DependencyFlags) -> Self {
        self.inner.dependency_flags = dependency_flags;
        self
    }
    #[inline]
    pub fn memory_barriers(mut self, memory_barriers: &'a [MemoryBarrier2]) -> Self {
        self.inner.memory_barrier_count = memory_barriers.len() as _;
        self.inner.p_memory_barriers = memory_barriers.as_ptr();
        self
    }
    #[inline]
    pub fn buffer_memory_barriers(
        mut self,
        buffer_memory_barriers: &'a [BufferMemoryBarrier2],
    ) -> Self {
        self.inner.buffer_memory_barrier_count = buffer_memory_barriers.len() as _;
        self.inner.p_buffer_memory_barriers = buffer_memory_barriers.as_ptr();
        self
    }
    #[inline]
    pub fn image_memory_barriers(
        mut self,
        image_memory_barriers: &'a [ImageMemoryBarrier2],
    ) -> Self {
        self.inner.image_memory_barrier_count = image_memory_barriers.len() as _;
        self.inner.p_image_memory_barriers = image_memory_barriers.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DependencyInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreSubmitInfo.html>"]
pub struct SemaphoreSubmitInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Semaphore,
    pub value: u64,
    pub stage_mask: PipelineStageFlags2,
    pub device_index: u32,
}
impl ::std::default::Default for SemaphoreSubmitInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            semaphore: Semaphore::default(),
            value: u64::default(),
            stage_mask: PipelineStageFlags2::default(),
            device_index: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for SemaphoreSubmitInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::SEMAPHORE_SUBMIT_INFO;
}
impl SemaphoreSubmitInfo {
    pub fn builder<'a>() -> SemaphoreSubmitInfoBuilder<'a> {
        SemaphoreSubmitInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SemaphoreSubmitInfoBuilder<'a> {
    inner: SemaphoreSubmitInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SemaphoreSubmitInfoBuilder<'a> {
    type Target = SemaphoreSubmitInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SemaphoreSubmitInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SemaphoreSubmitInfoBuilder<'a> {
    #[inline]
    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
        self.inner.semaphore = semaphore;
        self
    }
    #[inline]
    pub fn value(mut self, value: u64) -> Self {
        self.inner.value = value;
        self
    }
    #[inline]
    pub fn stage_mask(mut self, stage_mask: PipelineStageFlags2) -> Self {
        self.inner.stage_mask = stage_mask;
        self
    }
    #[inline]
    pub fn device_index(mut self, device_index: u32) -> Self {
        self.inner.device_index = device_index;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SemaphoreSubmitInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferSubmitInfo.html>"]
pub struct CommandBufferSubmitInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub command_buffer: CommandBuffer,
    pub device_mask: u32,
}
impl ::std::default::Default for CommandBufferSubmitInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            command_buffer: CommandBuffer::default(),
            device_mask: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for CommandBufferSubmitInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::COMMAND_BUFFER_SUBMIT_INFO;
}
impl CommandBufferSubmitInfo {
    pub fn builder<'a>() -> CommandBufferSubmitInfoBuilder<'a> {
        CommandBufferSubmitInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CommandBufferSubmitInfoBuilder<'a> {
    inner: CommandBufferSubmitInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CommandBufferSubmitInfoBuilder<'a> {
    type Target = CommandBufferSubmitInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CommandBufferSubmitInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CommandBufferSubmitInfoBuilder<'a> {
    #[inline]
    pub fn command_buffer(mut self, command_buffer: CommandBuffer) -> Self {
        self.inner.command_buffer = command_buffer;
        self
    }
    #[inline]
    pub fn device_mask(mut self, device_mask: u32) -> Self {
        self.inner.device_mask = device_mask;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CommandBufferSubmitInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubmitInfo2.html>"]
pub struct SubmitInfo2 {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: SubmitFlags,
    pub wait_semaphore_info_count: u32,
    pub p_wait_semaphore_infos: *const SemaphoreSubmitInfo,
    pub command_buffer_info_count: u32,
    pub p_command_buffer_infos: *const CommandBufferSubmitInfo,
    pub signal_semaphore_info_count: u32,
    pub p_signal_semaphore_infos: *const SemaphoreSubmitInfo,
}
impl ::std::default::Default for SubmitInfo2 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: SubmitFlags::default(),
            wait_semaphore_info_count: u32::default(),
            p_wait_semaphore_infos: ::std::ptr::null(),
            command_buffer_info_count: u32::default(),
            p_command_buffer_infos: ::std::ptr::null(),
            signal_semaphore_info_count: u32::default(),
            p_signal_semaphore_infos: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for SubmitInfo2 {
    const STRUCTURE_TYPE: StructureType = StructureType::SUBMIT_INFO_2;
}
impl SubmitInfo2 {
    pub fn builder<'a>() -> SubmitInfo2Builder<'a> {
        SubmitInfo2Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SubmitInfo2Builder<'a> {
    inner: SubmitInfo2,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsSubmitInfo2 {}
impl<'a> ::std::ops::Deref for SubmitInfo2Builder<'a> {
    type Target = SubmitInfo2;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SubmitInfo2Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SubmitInfo2Builder<'a> {
    #[inline]
    pub fn flags(mut self, flags: SubmitFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn wait_semaphore_infos(mut self, wait_semaphore_infos: &'a [SemaphoreSubmitInfo]) -> Self {
        self.inner.wait_semaphore_info_count = wait_semaphore_infos.len() as _;
        self.inner.p_wait_semaphore_infos = wait_semaphore_infos.as_ptr();
        self
    }
    #[inline]
    pub fn command_buffer_infos(
        mut self,
        command_buffer_infos: &'a [CommandBufferSubmitInfo],
    ) -> Self {
        self.inner.command_buffer_info_count = command_buffer_infos.len() as _;
        self.inner.p_command_buffer_infos = command_buffer_infos.as_ptr();
        self
    }
    #[inline]
    pub fn signal_semaphore_infos(
        mut self,
        signal_semaphore_infos: &'a [SemaphoreSubmitInfo],
    ) -> Self {
        self.inner.signal_semaphore_info_count = signal_semaphore_infos.len() as _;
        self.inner.p_signal_semaphore_infos = signal_semaphore_infos.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsSubmitInfo2>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SubmitInfo2 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyCheckpointProperties2NV.html>"]
pub struct QueueFamilyCheckpointProperties2NV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub checkpoint_execution_stage_mask: PipelineStageFlags2,
}
impl ::std::default::Default for QueueFamilyCheckpointProperties2NV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            checkpoint_execution_stage_mask: PipelineStageFlags2::default(),
        }
    }
}
unsafe impl TaggedStructure for QueueFamilyCheckpointProperties2NV {
    const STRUCTURE_TYPE: StructureType = StructureType::QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV;
}
impl QueueFamilyCheckpointProperties2NV {
    pub fn builder<'a>() -> QueueFamilyCheckpointProperties2NVBuilder<'a> {
        QueueFamilyCheckpointProperties2NVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct QueueFamilyCheckpointProperties2NVBuilder<'a> {
    inner: QueueFamilyCheckpointProperties2NV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsQueueFamilyProperties2 for QueueFamilyCheckpointProperties2NVBuilder<'_> {}
unsafe impl ExtendsQueueFamilyProperties2 for QueueFamilyCheckpointProperties2NV {}
impl<'a> ::std::ops::Deref for QueueFamilyCheckpointProperties2NVBuilder<'a> {
    type Target = QueueFamilyCheckpointProperties2NV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for QueueFamilyCheckpointProperties2NVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> QueueFamilyCheckpointProperties2NVBuilder<'a> {
    #[inline]
    pub fn checkpoint_execution_stage_mask(
        mut self,
        checkpoint_execution_stage_mask: PipelineStageFlags2,
    ) -> Self {
        self.inner.checkpoint_execution_stage_mask = checkpoint_execution_stage_mask;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> QueueFamilyCheckpointProperties2NV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCheckpointData2NV.html>"]
pub struct CheckpointData2NV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub stage: PipelineStageFlags2,
    pub p_checkpoint_marker: *mut c_void,
}
impl ::std::default::Default for CheckpointData2NV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            stage: PipelineStageFlags2::default(),
            p_checkpoint_marker: ::std::ptr::null_mut(),
        }
    }
}
unsafe impl TaggedStructure for CheckpointData2NV {
    const STRUCTURE_TYPE: StructureType = StructureType::CHECKPOINT_DATA_2_NV;
}
impl CheckpointData2NV {
    pub fn builder<'a>() -> CheckpointData2NVBuilder<'a> {
        CheckpointData2NVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CheckpointData2NVBuilder<'a> {
    inner: CheckpointData2NV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CheckpointData2NVBuilder<'a> {
    type Target = CheckpointData2NV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CheckpointData2NVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CheckpointData2NVBuilder<'a> {
    #[inline]
    pub fn stage(mut self, stage: PipelineStageFlags2) -> Self {
        self.inner.stage = stage;
        self
    }
    #[inline]
    pub fn checkpoint_marker(mut self, checkpoint_marker: *mut c_void) -> Self {
        self.inner.p_checkpoint_marker = checkpoint_marker;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CheckpointData2NV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSynchronization2Features.html>"]
pub struct PhysicalDeviceSynchronization2Features {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub synchronization2: Bool32,
}
impl ::std::default::Default for PhysicalDeviceSynchronization2Features {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            synchronization2: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceSynchronization2Features {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES;
}
impl PhysicalDeviceSynchronization2Features {
    pub fn builder<'a>() -> PhysicalDeviceSynchronization2FeaturesBuilder<'a> {
        PhysicalDeviceSynchronization2FeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceSynchronization2FeaturesBuilder<'a> {
    inner: PhysicalDeviceSynchronization2Features,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceSynchronization2FeaturesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceSynchronization2Features {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSynchronization2FeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSynchronization2Features {}
impl<'a> ::std::ops::Deref for PhysicalDeviceSynchronization2FeaturesBuilder<'a> {
    type Target = PhysicalDeviceSynchronization2Features;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceSynchronization2FeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceSynchronization2FeaturesBuilder<'a> {
    #[inline]
    pub fn synchronization2(mut self, synchronization2: bool) -> Self {
        self.inner.synchronization2 = synchronization2.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceSynchronization2Features {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT.html>"]
pub struct PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub primitives_generated_query: Bool32,
    pub primitives_generated_query_with_rasterizer_discard: Bool32,
    pub primitives_generated_query_with_non_zero_streams: Bool32,
}
impl ::std::default::Default for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            primitives_generated_query: Bool32::default(),
            primitives_generated_query_with_rasterizer_discard: Bool32::default(),
            primitives_generated_query_with_non_zero_streams: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT;
}
impl PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDevicePrimitivesGeneratedQueryFeaturesEXTBuilder<'a> {
        PhysicalDevicePrimitivesGeneratedQueryFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevicePrimitivesGeneratedQueryFeaturesEXTBuilder<'a> {
    inner: PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXTBuilder<'a> {
    type Target = PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevicePrimitivesGeneratedQueryFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevicePrimitivesGeneratedQueryFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn primitives_generated_query(mut self, primitives_generated_query: bool) -> Self {
        self.inner.primitives_generated_query = primitives_generated_query.into();
        self
    }
    #[inline]
    pub fn primitives_generated_query_with_rasterizer_discard(
        mut self,
        primitives_generated_query_with_rasterizer_discard: bool,
    ) -> Self {
        self.inner
            .primitives_generated_query_with_rasterizer_discard =
            primitives_generated_query_with_rasterizer_discard.into();
        self
    }
    #[inline]
    pub fn primitives_generated_query_with_non_zero_streams(
        mut self,
        primitives_generated_query_with_non_zero_streams: bool,
    ) -> Self {
        self.inner.primitives_generated_query_with_non_zero_streams =
            primitives_generated_query_with_non_zero_streams.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLegacyDitheringFeaturesEXT.html>"]
pub struct PhysicalDeviceLegacyDitheringFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub legacy_dithering: Bool32,
}
impl ::std::default::Default for PhysicalDeviceLegacyDitheringFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            legacy_dithering: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceLegacyDitheringFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT;
}
impl PhysicalDeviceLegacyDitheringFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceLegacyDitheringFeaturesEXTBuilder<'a> {
        PhysicalDeviceLegacyDitheringFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceLegacyDitheringFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceLegacyDitheringFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceLegacyDitheringFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceLegacyDitheringFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceLegacyDitheringFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceLegacyDitheringFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceLegacyDitheringFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceLegacyDitheringFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceLegacyDitheringFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceLegacyDitheringFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn legacy_dithering(mut self, legacy_dithering: bool) -> Self {
        self.inner.legacy_dithering = legacy_dithering.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceLegacyDitheringFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT.html>"]
pub struct PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub multisampled_render_to_single_sampled: Bool32,
}
impl ::std::default::Default for PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            multisampled_render_to_single_sampled: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT;
}
impl PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXTBuilder<'a> {
        PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT
{
}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT {}
impl<'a> ::std::ops::Deref
    for PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXTBuilder<'a>
{
    type Target = PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut
    for PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXTBuilder<'a>
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn multisampled_render_to_single_sampled(
        mut self,
        multisampled_render_to_single_sampled: bool,
    ) -> Self {
        self.inner.multisampled_render_to_single_sampled =
            multisampled_render_to_single_sampled.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassResolvePerformanceQueryEXT.html>"]
pub struct SubpassResolvePerformanceQueryEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub optimal: Bool32,
}
impl ::std::default::Default for SubpassResolvePerformanceQueryEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            optimal: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for SubpassResolvePerformanceQueryEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT;
}
impl SubpassResolvePerformanceQueryEXT {
    pub fn builder<'a>() -> SubpassResolvePerformanceQueryEXTBuilder<'a> {
        SubpassResolvePerformanceQueryEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SubpassResolvePerformanceQueryEXTBuilder<'a> {
    inner: SubpassResolvePerformanceQueryEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsFormatProperties2 for SubpassResolvePerformanceQueryEXTBuilder<'_> {}
unsafe impl ExtendsFormatProperties2 for SubpassResolvePerformanceQueryEXT {}
impl<'a> ::std::ops::Deref for SubpassResolvePerformanceQueryEXTBuilder<'a> {
    type Target = SubpassResolvePerformanceQueryEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SubpassResolvePerformanceQueryEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SubpassResolvePerformanceQueryEXTBuilder<'a> {
    #[inline]
    pub fn optimal(mut self, optimal: bool) -> Self {
        self.inner.optimal = optimal.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SubpassResolvePerformanceQueryEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMultisampledRenderToSingleSampledInfoEXT.html>"]
pub struct MultisampledRenderToSingleSampledInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub multisampled_render_to_single_sampled_enable: Bool32,
    pub rasterization_samples: SampleCountFlags,
}
impl ::std::default::Default for MultisampledRenderToSingleSampledInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            multisampled_render_to_single_sampled_enable: Bool32::default(),
            rasterization_samples: SampleCountFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for MultisampledRenderToSingleSampledInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT;
}
impl MultisampledRenderToSingleSampledInfoEXT {
    pub fn builder<'a>() -> MultisampledRenderToSingleSampledInfoEXTBuilder<'a> {
        MultisampledRenderToSingleSampledInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MultisampledRenderToSingleSampledInfoEXTBuilder<'a> {
    inner: MultisampledRenderToSingleSampledInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSubpassDescription2 for MultisampledRenderToSingleSampledInfoEXTBuilder<'_> {}
unsafe impl ExtendsSubpassDescription2 for MultisampledRenderToSingleSampledInfoEXT {}
unsafe impl ExtendsRenderingInfo for MultisampledRenderToSingleSampledInfoEXTBuilder<'_> {}
unsafe impl ExtendsRenderingInfo for MultisampledRenderToSingleSampledInfoEXT {}
impl<'a> ::std::ops::Deref for MultisampledRenderToSingleSampledInfoEXTBuilder<'a> {
    type Target = MultisampledRenderToSingleSampledInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MultisampledRenderToSingleSampledInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MultisampledRenderToSingleSampledInfoEXTBuilder<'a> {
    #[inline]
    pub fn multisampled_render_to_single_sampled_enable(
        mut self,
        multisampled_render_to_single_sampled_enable: bool,
    ) -> Self {
        self.inner.multisampled_render_to_single_sampled_enable =
            multisampled_render_to_single_sampled_enable.into();
        self
    }
    #[inline]
    pub fn rasterization_samples(mut self, rasterization_samples: SampleCountFlags) -> Self {
        self.inner.rasterization_samples = rasterization_samples;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MultisampledRenderToSingleSampledInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelineProtectedAccessFeaturesEXT.html>"]
pub struct PhysicalDevicePipelineProtectedAccessFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pipeline_protected_access: Bool32,
}
impl ::std::default::Default for PhysicalDevicePipelineProtectedAccessFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            pipeline_protected_access: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevicePipelineProtectedAccessFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT;
}
impl PhysicalDevicePipelineProtectedAccessFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDevicePipelineProtectedAccessFeaturesEXTBuilder<'a> {
        PhysicalDevicePipelineProtectedAccessFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevicePipelineProtectedAccessFeaturesEXTBuilder<'a> {
    inner: PhysicalDevicePipelineProtectedAccessFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDevicePipelineProtectedAccessFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePipelineProtectedAccessFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDevicePipelineProtectedAccessFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePipelineProtectedAccessFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDevicePipelineProtectedAccessFeaturesEXTBuilder<'a> {
    type Target = PhysicalDevicePipelineProtectedAccessFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevicePipelineProtectedAccessFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevicePipelineProtectedAccessFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn pipeline_protected_access(mut self, pipeline_protected_access: bool) -> Self {
        self.inner.pipeline_protected_access = pipeline_protected_access.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevicePipelineProtectedAccessFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyVideoPropertiesKHR.html>"]
pub struct QueueFamilyVideoPropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub video_codec_operations: VideoCodecOperationFlagsKHR,
}
impl ::std::default::Default for QueueFamilyVideoPropertiesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            video_codec_operations: VideoCodecOperationFlagsKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for QueueFamilyVideoPropertiesKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::QUEUE_FAMILY_VIDEO_PROPERTIES_KHR;
}
impl QueueFamilyVideoPropertiesKHR {
    pub fn builder<'a>() -> QueueFamilyVideoPropertiesKHRBuilder<'a> {
        QueueFamilyVideoPropertiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct QueueFamilyVideoPropertiesKHRBuilder<'a> {
    inner: QueueFamilyVideoPropertiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsQueueFamilyProperties2 for QueueFamilyVideoPropertiesKHRBuilder<'_> {}
unsafe impl ExtendsQueueFamilyProperties2 for QueueFamilyVideoPropertiesKHR {}
impl<'a> ::std::ops::Deref for QueueFamilyVideoPropertiesKHRBuilder<'a> {
    type Target = QueueFamilyVideoPropertiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for QueueFamilyVideoPropertiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> QueueFamilyVideoPropertiesKHRBuilder<'a> {
    #[inline]
    pub fn video_codec_operations(
        mut self,
        video_codec_operations: VideoCodecOperationFlagsKHR,
    ) -> Self {
        self.inner.video_codec_operations = video_codec_operations;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> QueueFamilyVideoPropertiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyQueryResultStatusPropertiesKHR.html>"]
pub struct QueueFamilyQueryResultStatusPropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub query_result_status_support: Bool32,
}
impl ::std::default::Default for QueueFamilyQueryResultStatusPropertiesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            query_result_status_support: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for QueueFamilyQueryResultStatusPropertiesKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR;
}
impl QueueFamilyQueryResultStatusPropertiesKHR {
    pub fn builder<'a>() -> QueueFamilyQueryResultStatusPropertiesKHRBuilder<'a> {
        QueueFamilyQueryResultStatusPropertiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct QueueFamilyQueryResultStatusPropertiesKHRBuilder<'a> {
    inner: QueueFamilyQueryResultStatusPropertiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsQueueFamilyProperties2 for QueueFamilyQueryResultStatusPropertiesKHRBuilder<'_> {}
unsafe impl ExtendsQueueFamilyProperties2 for QueueFamilyQueryResultStatusPropertiesKHR {}
impl<'a> ::std::ops::Deref for QueueFamilyQueryResultStatusPropertiesKHRBuilder<'a> {
    type Target = QueueFamilyQueryResultStatusPropertiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for QueueFamilyQueryResultStatusPropertiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> QueueFamilyQueryResultStatusPropertiesKHRBuilder<'a> {
    #[inline]
    pub fn query_result_status_support(mut self, query_result_status_support: bool) -> Self {
        self.inner.query_result_status_support = query_result_status_support.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> QueueFamilyQueryResultStatusPropertiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoProfileListInfoKHR.html>"]
pub struct VideoProfileListInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub profile_count: u32,
    pub p_profiles: *const VideoProfileInfoKHR,
}
impl ::std::default::Default for VideoProfileListInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            profile_count: u32::default(),
            p_profiles: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for VideoProfileListInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_PROFILE_LIST_INFO_KHR;
}
impl VideoProfileListInfoKHR {
    pub fn builder<'a>() -> VideoProfileListInfoKHRBuilder<'a> {
        VideoProfileListInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoProfileListInfoKHRBuilder<'a> {
    inner: VideoProfileListInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceImageFormatInfo2 for VideoProfileListInfoKHRBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceImageFormatInfo2 for VideoProfileListInfoKHR {}
unsafe impl ExtendsPhysicalDeviceVideoFormatInfoKHR for VideoProfileListInfoKHRBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceVideoFormatInfoKHR for VideoProfileListInfoKHR {}
unsafe impl ExtendsImageCreateInfo for VideoProfileListInfoKHRBuilder<'_> {}
unsafe impl ExtendsImageCreateInfo for VideoProfileListInfoKHR {}
unsafe impl ExtendsBufferCreateInfo for VideoProfileListInfoKHRBuilder<'_> {}
unsafe impl ExtendsBufferCreateInfo for VideoProfileListInfoKHR {}
impl<'a> ::std::ops::Deref for VideoProfileListInfoKHRBuilder<'a> {
    type Target = VideoProfileListInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoProfileListInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoProfileListInfoKHRBuilder<'a> {
    #[inline]
    pub fn profiles(mut self, profiles: &'a [VideoProfileInfoKHR]) -> Self {
        self.inner.profile_count = profiles.len() as _;
        self.inner.p_profiles = profiles.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoProfileListInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVideoFormatInfoKHR.html>"]
pub struct PhysicalDeviceVideoFormatInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image_usage: ImageUsageFlags,
}
impl ::std::default::Default for PhysicalDeviceVideoFormatInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image_usage: ImageUsageFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceVideoFormatInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR;
}
impl PhysicalDeviceVideoFormatInfoKHR {
    pub fn builder<'a>() -> PhysicalDeviceVideoFormatInfoKHRBuilder<'a> {
        PhysicalDeviceVideoFormatInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceVideoFormatInfoKHRBuilder<'a> {
    inner: PhysicalDeviceVideoFormatInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsPhysicalDeviceVideoFormatInfoKHR {}
impl<'a> ::std::ops::Deref for PhysicalDeviceVideoFormatInfoKHRBuilder<'a> {
    type Target = PhysicalDeviceVideoFormatInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceVideoFormatInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceVideoFormatInfoKHRBuilder<'a> {
    #[inline]
    pub fn image_usage(mut self, image_usage: ImageUsageFlags) -> Self {
        self.inner.image_usage = image_usage;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsPhysicalDeviceVideoFormatInfoKHR>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceVideoFormatInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoFormatPropertiesKHR.html>"]
pub struct VideoFormatPropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub format: Format,
    pub component_mapping: ComponentMapping,
    pub image_create_flags: ImageCreateFlags,
    pub image_type: ImageType,
    pub image_tiling: ImageTiling,
    pub image_usage_flags: ImageUsageFlags,
}
impl ::std::default::Default for VideoFormatPropertiesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            format: Format::default(),
            component_mapping: ComponentMapping::default(),
            image_create_flags: ImageCreateFlags::default(),
            image_type: ImageType::default(),
            image_tiling: ImageTiling::default(),
            image_usage_flags: ImageUsageFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoFormatPropertiesKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_FORMAT_PROPERTIES_KHR;
}
impl VideoFormatPropertiesKHR {
    pub fn builder<'a>() -> VideoFormatPropertiesKHRBuilder<'a> {
        VideoFormatPropertiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoFormatPropertiesKHRBuilder<'a> {
    inner: VideoFormatPropertiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for VideoFormatPropertiesKHRBuilder<'a> {
    type Target = VideoFormatPropertiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoFormatPropertiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoFormatPropertiesKHRBuilder<'a> {
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.inner.format = format;
        self
    }
    #[inline]
    pub fn component_mapping(mut self, component_mapping: ComponentMapping) -> Self {
        self.inner.component_mapping = component_mapping;
        self
    }
    #[inline]
    pub fn image_create_flags(mut self, image_create_flags: ImageCreateFlags) -> Self {
        self.inner.image_create_flags = image_create_flags;
        self
    }
    #[inline]
    pub fn image_type(mut self, image_type: ImageType) -> Self {
        self.inner.image_type = image_type;
        self
    }
    #[inline]
    pub fn image_tiling(mut self, image_tiling: ImageTiling) -> Self {
        self.inner.image_tiling = image_tiling;
        self
    }
    #[inline]
    pub fn image_usage_flags(mut self, image_usage_flags: ImageUsageFlags) -> Self {
        self.inner.image_usage_flags = image_usage_flags;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoFormatPropertiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoProfileInfoKHR.html>"]
pub struct VideoProfileInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub video_codec_operation: VideoCodecOperationFlagsKHR,
    pub chroma_subsampling: VideoChromaSubsamplingFlagsKHR,
    pub luma_bit_depth: VideoComponentBitDepthFlagsKHR,
    pub chroma_bit_depth: VideoComponentBitDepthFlagsKHR,
}
impl ::std::default::Default for VideoProfileInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            video_codec_operation: VideoCodecOperationFlagsKHR::default(),
            chroma_subsampling: VideoChromaSubsamplingFlagsKHR::default(),
            luma_bit_depth: VideoComponentBitDepthFlagsKHR::default(),
            chroma_bit_depth: VideoComponentBitDepthFlagsKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoProfileInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_PROFILE_INFO_KHR;
}
impl VideoProfileInfoKHR {
    pub fn builder<'a>() -> VideoProfileInfoKHRBuilder<'a> {
        VideoProfileInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoProfileInfoKHRBuilder<'a> {
    inner: VideoProfileInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsQueryPoolCreateInfo for VideoProfileInfoKHRBuilder<'_> {}
unsafe impl ExtendsQueryPoolCreateInfo for VideoProfileInfoKHR {}
pub unsafe trait ExtendsVideoProfileInfoKHR {}
impl<'a> ::std::ops::Deref for VideoProfileInfoKHRBuilder<'a> {
    type Target = VideoProfileInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoProfileInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoProfileInfoKHRBuilder<'a> {
    #[inline]
    pub fn video_codec_operation(
        mut self,
        video_codec_operation: VideoCodecOperationFlagsKHR,
    ) -> Self {
        self.inner.video_codec_operation = video_codec_operation;
        self
    }
    #[inline]
    pub fn chroma_subsampling(
        mut self,
        chroma_subsampling: VideoChromaSubsamplingFlagsKHR,
    ) -> Self {
        self.inner.chroma_subsampling = chroma_subsampling;
        self
    }
    #[inline]
    pub fn luma_bit_depth(mut self, luma_bit_depth: VideoComponentBitDepthFlagsKHR) -> Self {
        self.inner.luma_bit_depth = luma_bit_depth;
        self
    }
    #[inline]
    pub fn chroma_bit_depth(mut self, chroma_bit_depth: VideoComponentBitDepthFlagsKHR) -> Self {
        self.inner.chroma_bit_depth = chroma_bit_depth;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsVideoProfileInfoKHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoProfileInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoCapabilitiesKHR.html>"]
pub struct VideoCapabilitiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub flags: VideoCapabilityFlagsKHR,
    pub min_bitstream_buffer_offset_alignment: DeviceSize,
    pub min_bitstream_buffer_size_alignment: DeviceSize,
    pub picture_access_granularity: Extent2D,
    pub min_coded_extent: Extent2D,
    pub max_coded_extent: Extent2D,
    pub max_dpb_slots: u32,
    pub max_active_reference_pictures: u32,
    pub std_header_version: ExtensionProperties,
}
impl ::std::default::Default for VideoCapabilitiesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            flags: VideoCapabilityFlagsKHR::default(),
            min_bitstream_buffer_offset_alignment: DeviceSize::default(),
            min_bitstream_buffer_size_alignment: DeviceSize::default(),
            picture_access_granularity: Extent2D::default(),
            min_coded_extent: Extent2D::default(),
            max_coded_extent: Extent2D::default(),
            max_dpb_slots: u32::default(),
            max_active_reference_pictures: u32::default(),
            std_header_version: ExtensionProperties::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoCapabilitiesKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_CAPABILITIES_KHR;
}
impl VideoCapabilitiesKHR {
    pub fn builder<'a>() -> VideoCapabilitiesKHRBuilder<'a> {
        VideoCapabilitiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoCapabilitiesKHRBuilder<'a> {
    inner: VideoCapabilitiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsVideoCapabilitiesKHR {}
impl<'a> ::std::ops::Deref for VideoCapabilitiesKHRBuilder<'a> {
    type Target = VideoCapabilitiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoCapabilitiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoCapabilitiesKHRBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: VideoCapabilityFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn min_bitstream_buffer_offset_alignment(
        mut self,
        min_bitstream_buffer_offset_alignment: DeviceSize,
    ) -> Self {
        self.inner.min_bitstream_buffer_offset_alignment = min_bitstream_buffer_offset_alignment;
        self
    }
    #[inline]
    pub fn min_bitstream_buffer_size_alignment(
        mut self,
        min_bitstream_buffer_size_alignment: DeviceSize,
    ) -> Self {
        self.inner.min_bitstream_buffer_size_alignment = min_bitstream_buffer_size_alignment;
        self
    }
    #[inline]
    pub fn picture_access_granularity(mut self, picture_access_granularity: Extent2D) -> Self {
        self.inner.picture_access_granularity = picture_access_granularity;
        self
    }
    #[inline]
    pub fn min_coded_extent(mut self, min_coded_extent: Extent2D) -> Self {
        self.inner.min_coded_extent = min_coded_extent;
        self
    }
    #[inline]
    pub fn max_coded_extent(mut self, max_coded_extent: Extent2D) -> Self {
        self.inner.max_coded_extent = max_coded_extent;
        self
    }
    #[inline]
    pub fn max_dpb_slots(mut self, max_dpb_slots: u32) -> Self {
        self.inner.max_dpb_slots = max_dpb_slots;
        self
    }
    #[inline]
    pub fn max_active_reference_pictures(mut self, max_active_reference_pictures: u32) -> Self {
        self.inner.max_active_reference_pictures = max_active_reference_pictures;
        self
    }
    #[inline]
    pub fn std_header_version(mut self, std_header_version: ExtensionProperties) -> Self {
        self.inner.std_header_version = std_header_version;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsVideoCapabilitiesKHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoCapabilitiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoSessionMemoryRequirementsKHR.html>"]
pub struct VideoSessionMemoryRequirementsKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_bind_index: u32,
    pub memory_requirements: MemoryRequirements,
}
impl ::std::default::Default for VideoSessionMemoryRequirementsKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            memory_bind_index: u32::default(),
            memory_requirements: MemoryRequirements::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoSessionMemoryRequirementsKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR;
}
impl VideoSessionMemoryRequirementsKHR {
    pub fn builder<'a>() -> VideoSessionMemoryRequirementsKHRBuilder<'a> {
        VideoSessionMemoryRequirementsKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoSessionMemoryRequirementsKHRBuilder<'a> {
    inner: VideoSessionMemoryRequirementsKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for VideoSessionMemoryRequirementsKHRBuilder<'a> {
    type Target = VideoSessionMemoryRequirementsKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoSessionMemoryRequirementsKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoSessionMemoryRequirementsKHRBuilder<'a> {
    #[inline]
    pub fn memory_bind_index(mut self, memory_bind_index: u32) -> Self {
        self.inner.memory_bind_index = memory_bind_index;
        self
    }
    #[inline]
    pub fn memory_requirements(mut self, memory_requirements: MemoryRequirements) -> Self {
        self.inner.memory_requirements = memory_requirements;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoSessionMemoryRequirementsKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindVideoSessionMemoryInfoKHR.html>"]
pub struct BindVideoSessionMemoryInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory_bind_index: u32,
    pub memory: DeviceMemory,
    pub memory_offset: DeviceSize,
    pub memory_size: DeviceSize,
}
impl ::std::default::Default for BindVideoSessionMemoryInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            memory_bind_index: u32::default(),
            memory: DeviceMemory::default(),
            memory_offset: DeviceSize::default(),
            memory_size: DeviceSize::default(),
        }
    }
}
unsafe impl TaggedStructure for BindVideoSessionMemoryInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::BIND_VIDEO_SESSION_MEMORY_INFO_KHR;
}
impl BindVideoSessionMemoryInfoKHR {
    pub fn builder<'a>() -> BindVideoSessionMemoryInfoKHRBuilder<'a> {
        BindVideoSessionMemoryInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BindVideoSessionMemoryInfoKHRBuilder<'a> {
    inner: BindVideoSessionMemoryInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for BindVideoSessionMemoryInfoKHRBuilder<'a> {
    type Target = BindVideoSessionMemoryInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BindVideoSessionMemoryInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BindVideoSessionMemoryInfoKHRBuilder<'a> {
    #[inline]
    pub fn memory_bind_index(mut self, memory_bind_index: u32) -> Self {
        self.inner.memory_bind_index = memory_bind_index;
        self
    }
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    #[inline]
    pub fn memory_offset(mut self, memory_offset: DeviceSize) -> Self {
        self.inner.memory_offset = memory_offset;
        self
    }
    #[inline]
    pub fn memory_size(mut self, memory_size: DeviceSize) -> Self {
        self.inner.memory_size = memory_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BindVideoSessionMemoryInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoPictureResourceInfoKHR.html>"]
pub struct VideoPictureResourceInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub coded_offset: Offset2D,
    pub coded_extent: Extent2D,
    pub base_array_layer: u32,
    pub image_view_binding: ImageView,
}
impl ::std::default::Default for VideoPictureResourceInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            coded_offset: Offset2D::default(),
            coded_extent: Extent2D::default(),
            base_array_layer: u32::default(),
            image_view_binding: ImageView::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoPictureResourceInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_PICTURE_RESOURCE_INFO_KHR;
}
impl VideoPictureResourceInfoKHR {
    pub fn builder<'a>() -> VideoPictureResourceInfoKHRBuilder<'a> {
        VideoPictureResourceInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoPictureResourceInfoKHRBuilder<'a> {
    inner: VideoPictureResourceInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for VideoPictureResourceInfoKHRBuilder<'a> {
    type Target = VideoPictureResourceInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoPictureResourceInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoPictureResourceInfoKHRBuilder<'a> {
    #[inline]
    pub fn coded_offset(mut self, coded_offset: Offset2D) -> Self {
        self.inner.coded_offset = coded_offset;
        self
    }
    #[inline]
    pub fn coded_extent(mut self, coded_extent: Extent2D) -> Self {
        self.inner.coded_extent = coded_extent;
        self
    }
    #[inline]
    pub fn base_array_layer(mut self, base_array_layer: u32) -> Self {
        self.inner.base_array_layer = base_array_layer;
        self
    }
    #[inline]
    pub fn image_view_binding(mut self, image_view_binding: ImageView) -> Self {
        self.inner.image_view_binding = image_view_binding;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoPictureResourceInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoReferenceSlotInfoKHR.html>"]
pub struct VideoReferenceSlotInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub slot_index: i32,
    pub p_picture_resource: *const VideoPictureResourceInfoKHR,
}
impl ::std::default::Default for VideoReferenceSlotInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            slot_index: i32::default(),
            p_picture_resource: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for VideoReferenceSlotInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_REFERENCE_SLOT_INFO_KHR;
}
impl VideoReferenceSlotInfoKHR {
    pub fn builder<'a>() -> VideoReferenceSlotInfoKHRBuilder<'a> {
        VideoReferenceSlotInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoReferenceSlotInfoKHRBuilder<'a> {
    inner: VideoReferenceSlotInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsVideoReferenceSlotInfoKHR {}
impl<'a> ::std::ops::Deref for VideoReferenceSlotInfoKHRBuilder<'a> {
    type Target = VideoReferenceSlotInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoReferenceSlotInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoReferenceSlotInfoKHRBuilder<'a> {
    #[inline]
    pub fn slot_index(mut self, slot_index: i32) -> Self {
        self.inner.slot_index = slot_index;
        self
    }
    #[inline]
    pub fn picture_resource(mut self, picture_resource: &'a VideoPictureResourceInfoKHR) -> Self {
        self.inner.p_picture_resource = picture_resource;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsVideoReferenceSlotInfoKHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoReferenceSlotInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeCapabilitiesKHR.html>"]
pub struct VideoDecodeCapabilitiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub flags: VideoDecodeCapabilityFlagsKHR,
}
impl ::std::default::Default for VideoDecodeCapabilitiesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            flags: VideoDecodeCapabilityFlagsKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoDecodeCapabilitiesKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_DECODE_CAPABILITIES_KHR;
}
impl VideoDecodeCapabilitiesKHR {
    pub fn builder<'a>() -> VideoDecodeCapabilitiesKHRBuilder<'a> {
        VideoDecodeCapabilitiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoDecodeCapabilitiesKHRBuilder<'a> {
    inner: VideoDecodeCapabilitiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoCapabilitiesKHR for VideoDecodeCapabilitiesKHRBuilder<'_> {}
unsafe impl ExtendsVideoCapabilitiesKHR for VideoDecodeCapabilitiesKHR {}
impl<'a> ::std::ops::Deref for VideoDecodeCapabilitiesKHRBuilder<'a> {
    type Target = VideoDecodeCapabilitiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoDecodeCapabilitiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoDecodeCapabilitiesKHRBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: VideoDecodeCapabilityFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoDecodeCapabilitiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeUsageInfoKHR.html>"]
pub struct VideoDecodeUsageInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub video_usage_hints: VideoDecodeUsageFlagsKHR,
}
impl ::std::default::Default for VideoDecodeUsageInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            video_usage_hints: VideoDecodeUsageFlagsKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoDecodeUsageInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_DECODE_USAGE_INFO_KHR;
}
impl VideoDecodeUsageInfoKHR {
    pub fn builder<'a>() -> VideoDecodeUsageInfoKHRBuilder<'a> {
        VideoDecodeUsageInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoDecodeUsageInfoKHRBuilder<'a> {
    inner: VideoDecodeUsageInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoProfileInfoKHR for VideoDecodeUsageInfoKHRBuilder<'_> {}
unsafe impl ExtendsVideoProfileInfoKHR for VideoDecodeUsageInfoKHR {}
unsafe impl ExtendsQueryPoolCreateInfo for VideoDecodeUsageInfoKHRBuilder<'_> {}
unsafe impl ExtendsQueryPoolCreateInfo for VideoDecodeUsageInfoKHR {}
impl<'a> ::std::ops::Deref for VideoDecodeUsageInfoKHRBuilder<'a> {
    type Target = VideoDecodeUsageInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoDecodeUsageInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoDecodeUsageInfoKHRBuilder<'a> {
    #[inline]
    pub fn video_usage_hints(mut self, video_usage_hints: VideoDecodeUsageFlagsKHR) -> Self {
        self.inner.video_usage_hints = video_usage_hints;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoDecodeUsageInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeInfoKHR.html>"]
pub struct VideoDecodeInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: VideoDecodeFlagsKHR,
    pub src_buffer: Buffer,
    pub src_buffer_offset: DeviceSize,
    pub src_buffer_range: DeviceSize,
    pub dst_picture_resource: VideoPictureResourceInfoKHR,
    pub p_setup_reference_slot: *const VideoReferenceSlotInfoKHR,
    pub reference_slot_count: u32,
    pub p_reference_slots: *const VideoReferenceSlotInfoKHR,
}
impl ::std::default::Default for VideoDecodeInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: VideoDecodeFlagsKHR::default(),
            src_buffer: Buffer::default(),
            src_buffer_offset: DeviceSize::default(),
            src_buffer_range: DeviceSize::default(),
            dst_picture_resource: VideoPictureResourceInfoKHR::default(),
            p_setup_reference_slot: ::std::ptr::null(),
            reference_slot_count: u32::default(),
            p_reference_slots: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for VideoDecodeInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_DECODE_INFO_KHR;
}
impl VideoDecodeInfoKHR {
    pub fn builder<'a>() -> VideoDecodeInfoKHRBuilder<'a> {
        VideoDecodeInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoDecodeInfoKHRBuilder<'a> {
    inner: VideoDecodeInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsVideoDecodeInfoKHR {}
impl<'a> ::std::ops::Deref for VideoDecodeInfoKHRBuilder<'a> {
    type Target = VideoDecodeInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoDecodeInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoDecodeInfoKHRBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: VideoDecodeFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn src_buffer(mut self, src_buffer: Buffer) -> Self {
        self.inner.src_buffer = src_buffer;
        self
    }
    #[inline]
    pub fn src_buffer_offset(mut self, src_buffer_offset: DeviceSize) -> Self {
        self.inner.src_buffer_offset = src_buffer_offset;
        self
    }
    #[inline]
    pub fn src_buffer_range(mut self, src_buffer_range: DeviceSize) -> Self {
        self.inner.src_buffer_range = src_buffer_range;
        self
    }
    #[inline]
    pub fn dst_picture_resource(
        mut self,
        dst_picture_resource: VideoPictureResourceInfoKHR,
    ) -> Self {
        self.inner.dst_picture_resource = dst_picture_resource;
        self
    }
    #[inline]
    pub fn setup_reference_slot(
        mut self,
        setup_reference_slot: &'a VideoReferenceSlotInfoKHR,
    ) -> Self {
        self.inner.p_setup_reference_slot = setup_reference_slot;
        self
    }
    #[inline]
    pub fn reference_slots(mut self, reference_slots: &'a [VideoReferenceSlotInfoKHR]) -> Self {
        self.inner.reference_slot_count = reference_slots.len() as _;
        self.inner.p_reference_slots = reference_slots.as_ptr();
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsVideoDecodeInfoKHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoDecodeInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH264ProfileInfoKHR.html>"]
pub struct VideoDecodeH264ProfileInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub std_profile_idc: StdVideoH264ProfileIdc,
    pub picture_layout: VideoDecodeH264PictureLayoutFlagsKHR,
}
impl ::std::default::Default for VideoDecodeH264ProfileInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            std_profile_idc: StdVideoH264ProfileIdc::default(),
            picture_layout: VideoDecodeH264PictureLayoutFlagsKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoDecodeH264ProfileInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_DECODE_H264_PROFILE_INFO_KHR;
}
impl VideoDecodeH264ProfileInfoKHR {
    pub fn builder<'a>() -> VideoDecodeH264ProfileInfoKHRBuilder<'a> {
        VideoDecodeH264ProfileInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoDecodeH264ProfileInfoKHRBuilder<'a> {
    inner: VideoDecodeH264ProfileInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoProfileInfoKHR for VideoDecodeH264ProfileInfoKHRBuilder<'_> {}
unsafe impl ExtendsVideoProfileInfoKHR for VideoDecodeH264ProfileInfoKHR {}
unsafe impl ExtendsQueryPoolCreateInfo for VideoDecodeH264ProfileInfoKHRBuilder<'_> {}
unsafe impl ExtendsQueryPoolCreateInfo for VideoDecodeH264ProfileInfoKHR {}
impl<'a> ::std::ops::Deref for VideoDecodeH264ProfileInfoKHRBuilder<'a> {
    type Target = VideoDecodeH264ProfileInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoDecodeH264ProfileInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoDecodeH264ProfileInfoKHRBuilder<'a> {
    #[inline]
    pub fn std_profile_idc(mut self, std_profile_idc: StdVideoH264ProfileIdc) -> Self {
        self.inner.std_profile_idc = std_profile_idc;
        self
    }
    #[inline]
    pub fn picture_layout(mut self, picture_layout: VideoDecodeH264PictureLayoutFlagsKHR) -> Self {
        self.inner.picture_layout = picture_layout;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoDecodeH264ProfileInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH264CapabilitiesKHR.html>"]
pub struct VideoDecodeH264CapabilitiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_level_idc: StdVideoH264LevelIdc,
    pub field_offset_granularity: Offset2D,
}
impl ::std::default::Default for VideoDecodeH264CapabilitiesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_level_idc: StdVideoH264LevelIdc::default(),
            field_offset_granularity: Offset2D::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoDecodeH264CapabilitiesKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_DECODE_H264_CAPABILITIES_KHR;
}
impl VideoDecodeH264CapabilitiesKHR {
    pub fn builder<'a>() -> VideoDecodeH264CapabilitiesKHRBuilder<'a> {
        VideoDecodeH264CapabilitiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoDecodeH264CapabilitiesKHRBuilder<'a> {
    inner: VideoDecodeH264CapabilitiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoCapabilitiesKHR for VideoDecodeH264CapabilitiesKHRBuilder<'_> {}
unsafe impl ExtendsVideoCapabilitiesKHR for VideoDecodeH264CapabilitiesKHR {}
impl<'a> ::std::ops::Deref for VideoDecodeH264CapabilitiesKHRBuilder<'a> {
    type Target = VideoDecodeH264CapabilitiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoDecodeH264CapabilitiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoDecodeH264CapabilitiesKHRBuilder<'a> {
    #[inline]
    pub fn max_level_idc(mut self, max_level_idc: StdVideoH264LevelIdc) -> Self {
        self.inner.max_level_idc = max_level_idc;
        self
    }
    #[inline]
    pub fn field_offset_granularity(mut self, field_offset_granularity: Offset2D) -> Self {
        self.inner.field_offset_granularity = field_offset_granularity;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoDecodeH264CapabilitiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH264SessionParametersAddInfoKHR.html>"]
pub struct VideoDecodeH264SessionParametersAddInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub std_sps_count: u32,
    pub p_std_sp_ss: *const StdVideoH264SequenceParameterSet,
    pub std_pps_count: u32,
    pub p_std_pp_ss: *const StdVideoH264PictureParameterSet,
}
impl ::std::default::Default for VideoDecodeH264SessionParametersAddInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            std_sps_count: u32::default(),
            p_std_sp_ss: ::std::ptr::null(),
            std_pps_count: u32::default(),
            p_std_pp_ss: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for VideoDecodeH264SessionParametersAddInfoKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR;
}
impl VideoDecodeH264SessionParametersAddInfoKHR {
    pub fn builder<'a>() -> VideoDecodeH264SessionParametersAddInfoKHRBuilder<'a> {
        VideoDecodeH264SessionParametersAddInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoDecodeH264SessionParametersAddInfoKHRBuilder<'a> {
    inner: VideoDecodeH264SessionParametersAddInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoSessionParametersUpdateInfoKHR
    for VideoDecodeH264SessionParametersAddInfoKHRBuilder<'_>
{
}
unsafe impl ExtendsVideoSessionParametersUpdateInfoKHR
    for VideoDecodeH264SessionParametersAddInfoKHR
{
}
impl<'a> ::std::ops::Deref for VideoDecodeH264SessionParametersAddInfoKHRBuilder<'a> {
    type Target = VideoDecodeH264SessionParametersAddInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoDecodeH264SessionParametersAddInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoDecodeH264SessionParametersAddInfoKHRBuilder<'a> {
    #[inline]
    pub fn std_sp_ss(mut self, std_sp_ss: &'a [StdVideoH264SequenceParameterSet]) -> Self {
        self.inner.std_sps_count = std_sp_ss.len() as _;
        self.inner.p_std_sp_ss = std_sp_ss.as_ptr();
        self
    }
    #[inline]
    pub fn std_pp_ss(mut self, std_pp_ss: &'a [StdVideoH264PictureParameterSet]) -> Self {
        self.inner.std_pps_count = std_pp_ss.len() as _;
        self.inner.p_std_pp_ss = std_pp_ss.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoDecodeH264SessionParametersAddInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH264SessionParametersCreateInfoKHR.html>"]
pub struct VideoDecodeH264SessionParametersCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub max_std_sps_count: u32,
    pub max_std_pps_count: u32,
    pub p_parameters_add_info: *const VideoDecodeH264SessionParametersAddInfoKHR,
}
impl ::std::default::Default for VideoDecodeH264SessionParametersCreateInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            max_std_sps_count: u32::default(),
            max_std_pps_count: u32::default(),
            p_parameters_add_info: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for VideoDecodeH264SessionParametersCreateInfoKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR;
}
impl VideoDecodeH264SessionParametersCreateInfoKHR {
    pub fn builder<'a>() -> VideoDecodeH264SessionParametersCreateInfoKHRBuilder<'a> {
        VideoDecodeH264SessionParametersCreateInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoDecodeH264SessionParametersCreateInfoKHRBuilder<'a> {
    inner: VideoDecodeH264SessionParametersCreateInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoSessionParametersCreateInfoKHR
    for VideoDecodeH264SessionParametersCreateInfoKHRBuilder<'_>
{
}
unsafe impl ExtendsVideoSessionParametersCreateInfoKHR
    for VideoDecodeH264SessionParametersCreateInfoKHR
{
}
impl<'a> ::std::ops::Deref for VideoDecodeH264SessionParametersCreateInfoKHRBuilder<'a> {
    type Target = VideoDecodeH264SessionParametersCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoDecodeH264SessionParametersCreateInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoDecodeH264SessionParametersCreateInfoKHRBuilder<'a> {
    #[inline]
    pub fn max_std_sps_count(mut self, max_std_sps_count: u32) -> Self {
        self.inner.max_std_sps_count = max_std_sps_count;
        self
    }
    #[inline]
    pub fn max_std_pps_count(mut self, max_std_pps_count: u32) -> Self {
        self.inner.max_std_pps_count = max_std_pps_count;
        self
    }
    #[inline]
    pub fn parameters_add_info(
        mut self,
        parameters_add_info: &'a VideoDecodeH264SessionParametersAddInfoKHR,
    ) -> Self {
        self.inner.p_parameters_add_info = parameters_add_info;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoDecodeH264SessionParametersCreateInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH264PictureInfoKHR.html>"]
pub struct VideoDecodeH264PictureInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_std_picture_info: *const StdVideoDecodeH264PictureInfo,
    pub slice_count: u32,
    pub p_slice_offsets: *const u32,
}
impl ::std::default::Default for VideoDecodeH264PictureInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_std_picture_info: ::std::ptr::null(),
            slice_count: u32::default(),
            p_slice_offsets: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for VideoDecodeH264PictureInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_DECODE_H264_PICTURE_INFO_KHR;
}
impl VideoDecodeH264PictureInfoKHR {
    pub fn builder<'a>() -> VideoDecodeH264PictureInfoKHRBuilder<'a> {
        VideoDecodeH264PictureInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoDecodeH264PictureInfoKHRBuilder<'a> {
    inner: VideoDecodeH264PictureInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoDecodeInfoKHR for VideoDecodeH264PictureInfoKHRBuilder<'_> {}
unsafe impl ExtendsVideoDecodeInfoKHR for VideoDecodeH264PictureInfoKHR {}
impl<'a> ::std::ops::Deref for VideoDecodeH264PictureInfoKHRBuilder<'a> {
    type Target = VideoDecodeH264PictureInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoDecodeH264PictureInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoDecodeH264PictureInfoKHRBuilder<'a> {
    #[inline]
    pub fn std_picture_info(mut self, std_picture_info: &'a StdVideoDecodeH264PictureInfo) -> Self {
        self.inner.p_std_picture_info = std_picture_info;
        self
    }
    #[inline]
    pub fn slice_offsets(mut self, slice_offsets: &'a [u32]) -> Self {
        self.inner.slice_count = slice_offsets.len() as _;
        self.inner.p_slice_offsets = slice_offsets.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoDecodeH264PictureInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH264DpbSlotInfoKHR.html>"]
pub struct VideoDecodeH264DpbSlotInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_std_reference_info: *const StdVideoDecodeH264ReferenceInfo,
}
impl ::std::default::Default for VideoDecodeH264DpbSlotInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_std_reference_info: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for VideoDecodeH264DpbSlotInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR;
}
impl VideoDecodeH264DpbSlotInfoKHR {
    pub fn builder<'a>() -> VideoDecodeH264DpbSlotInfoKHRBuilder<'a> {
        VideoDecodeH264DpbSlotInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoDecodeH264DpbSlotInfoKHRBuilder<'a> {
    inner: VideoDecodeH264DpbSlotInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoReferenceSlotInfoKHR for VideoDecodeH264DpbSlotInfoKHRBuilder<'_> {}
unsafe impl ExtendsVideoReferenceSlotInfoKHR for VideoDecodeH264DpbSlotInfoKHR {}
impl<'a> ::std::ops::Deref for VideoDecodeH264DpbSlotInfoKHRBuilder<'a> {
    type Target = VideoDecodeH264DpbSlotInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoDecodeH264DpbSlotInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoDecodeH264DpbSlotInfoKHRBuilder<'a> {
    #[inline]
    pub fn std_reference_info(
        mut self,
        std_reference_info: &'a StdVideoDecodeH264ReferenceInfo,
    ) -> Self {
        self.inner.p_std_reference_info = std_reference_info;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoDecodeH264DpbSlotInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH265ProfileInfoKHR.html>"]
pub struct VideoDecodeH265ProfileInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub std_profile_idc: StdVideoH265ProfileIdc,
}
impl ::std::default::Default for VideoDecodeH265ProfileInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            std_profile_idc: StdVideoH265ProfileIdc::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoDecodeH265ProfileInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_DECODE_H265_PROFILE_INFO_KHR;
}
impl VideoDecodeH265ProfileInfoKHR {
    pub fn builder<'a>() -> VideoDecodeH265ProfileInfoKHRBuilder<'a> {
        VideoDecodeH265ProfileInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoDecodeH265ProfileInfoKHRBuilder<'a> {
    inner: VideoDecodeH265ProfileInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoProfileInfoKHR for VideoDecodeH265ProfileInfoKHRBuilder<'_> {}
unsafe impl ExtendsVideoProfileInfoKHR for VideoDecodeH265ProfileInfoKHR {}
unsafe impl ExtendsQueryPoolCreateInfo for VideoDecodeH265ProfileInfoKHRBuilder<'_> {}
unsafe impl ExtendsQueryPoolCreateInfo for VideoDecodeH265ProfileInfoKHR {}
impl<'a> ::std::ops::Deref for VideoDecodeH265ProfileInfoKHRBuilder<'a> {
    type Target = VideoDecodeH265ProfileInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoDecodeH265ProfileInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoDecodeH265ProfileInfoKHRBuilder<'a> {
    #[inline]
    pub fn std_profile_idc(mut self, std_profile_idc: StdVideoH265ProfileIdc) -> Self {
        self.inner.std_profile_idc = std_profile_idc;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoDecodeH265ProfileInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH265CapabilitiesKHR.html>"]
pub struct VideoDecodeH265CapabilitiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_level_idc: StdVideoH265LevelIdc,
}
impl ::std::default::Default for VideoDecodeH265CapabilitiesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_level_idc: StdVideoH265LevelIdc::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoDecodeH265CapabilitiesKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_DECODE_H265_CAPABILITIES_KHR;
}
impl VideoDecodeH265CapabilitiesKHR {
    pub fn builder<'a>() -> VideoDecodeH265CapabilitiesKHRBuilder<'a> {
        VideoDecodeH265CapabilitiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoDecodeH265CapabilitiesKHRBuilder<'a> {
    inner: VideoDecodeH265CapabilitiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoCapabilitiesKHR for VideoDecodeH265CapabilitiesKHRBuilder<'_> {}
unsafe impl ExtendsVideoCapabilitiesKHR for VideoDecodeH265CapabilitiesKHR {}
impl<'a> ::std::ops::Deref for VideoDecodeH265CapabilitiesKHRBuilder<'a> {
    type Target = VideoDecodeH265CapabilitiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoDecodeH265CapabilitiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoDecodeH265CapabilitiesKHRBuilder<'a> {
    #[inline]
    pub fn max_level_idc(mut self, max_level_idc: StdVideoH265LevelIdc) -> Self {
        self.inner.max_level_idc = max_level_idc;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoDecodeH265CapabilitiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH265SessionParametersAddInfoKHR.html>"]
pub struct VideoDecodeH265SessionParametersAddInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub std_vps_count: u32,
    pub p_std_vp_ss: *const StdVideoH265VideoParameterSet,
    pub std_sps_count: u32,
    pub p_std_sp_ss: *const StdVideoH265SequenceParameterSet,
    pub std_pps_count: u32,
    pub p_std_pp_ss: *const StdVideoH265PictureParameterSet,
}
impl ::std::default::Default for VideoDecodeH265SessionParametersAddInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            std_vps_count: u32::default(),
            p_std_vp_ss: ::std::ptr::null(),
            std_sps_count: u32::default(),
            p_std_sp_ss: ::std::ptr::null(),
            std_pps_count: u32::default(),
            p_std_pp_ss: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for VideoDecodeH265SessionParametersAddInfoKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR;
}
impl VideoDecodeH265SessionParametersAddInfoKHR {
    pub fn builder<'a>() -> VideoDecodeH265SessionParametersAddInfoKHRBuilder<'a> {
        VideoDecodeH265SessionParametersAddInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoDecodeH265SessionParametersAddInfoKHRBuilder<'a> {
    inner: VideoDecodeH265SessionParametersAddInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoSessionParametersUpdateInfoKHR
    for VideoDecodeH265SessionParametersAddInfoKHRBuilder<'_>
{
}
unsafe impl ExtendsVideoSessionParametersUpdateInfoKHR
    for VideoDecodeH265SessionParametersAddInfoKHR
{
}
impl<'a> ::std::ops::Deref for VideoDecodeH265SessionParametersAddInfoKHRBuilder<'a> {
    type Target = VideoDecodeH265SessionParametersAddInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoDecodeH265SessionParametersAddInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoDecodeH265SessionParametersAddInfoKHRBuilder<'a> {
    #[inline]
    pub fn std_vp_ss(mut self, std_vp_ss: &'a [StdVideoH265VideoParameterSet]) -> Self {
        self.inner.std_vps_count = std_vp_ss.len() as _;
        self.inner.p_std_vp_ss = std_vp_ss.as_ptr();
        self
    }
    #[inline]
    pub fn std_sp_ss(mut self, std_sp_ss: &'a [StdVideoH265SequenceParameterSet]) -> Self {
        self.inner.std_sps_count = std_sp_ss.len() as _;
        self.inner.p_std_sp_ss = std_sp_ss.as_ptr();
        self
    }
    #[inline]
    pub fn std_pp_ss(mut self, std_pp_ss: &'a [StdVideoH265PictureParameterSet]) -> Self {
        self.inner.std_pps_count = std_pp_ss.len() as _;
        self.inner.p_std_pp_ss = std_pp_ss.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoDecodeH265SessionParametersAddInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH265SessionParametersCreateInfoKHR.html>"]
pub struct VideoDecodeH265SessionParametersCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub max_std_vps_count: u32,
    pub max_std_sps_count: u32,
    pub max_std_pps_count: u32,
    pub p_parameters_add_info: *const VideoDecodeH265SessionParametersAddInfoKHR,
}
impl ::std::default::Default for VideoDecodeH265SessionParametersCreateInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            max_std_vps_count: u32::default(),
            max_std_sps_count: u32::default(),
            max_std_pps_count: u32::default(),
            p_parameters_add_info: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for VideoDecodeH265SessionParametersCreateInfoKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR;
}
impl VideoDecodeH265SessionParametersCreateInfoKHR {
    pub fn builder<'a>() -> VideoDecodeH265SessionParametersCreateInfoKHRBuilder<'a> {
        VideoDecodeH265SessionParametersCreateInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoDecodeH265SessionParametersCreateInfoKHRBuilder<'a> {
    inner: VideoDecodeH265SessionParametersCreateInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoSessionParametersCreateInfoKHR
    for VideoDecodeH265SessionParametersCreateInfoKHRBuilder<'_>
{
}
unsafe impl ExtendsVideoSessionParametersCreateInfoKHR
    for VideoDecodeH265SessionParametersCreateInfoKHR
{
}
impl<'a> ::std::ops::Deref for VideoDecodeH265SessionParametersCreateInfoKHRBuilder<'a> {
    type Target = VideoDecodeH265SessionParametersCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoDecodeH265SessionParametersCreateInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoDecodeH265SessionParametersCreateInfoKHRBuilder<'a> {
    #[inline]
    pub fn max_std_vps_count(mut self, max_std_vps_count: u32) -> Self {
        self.inner.max_std_vps_count = max_std_vps_count;
        self
    }
    #[inline]
    pub fn max_std_sps_count(mut self, max_std_sps_count: u32) -> Self {
        self.inner.max_std_sps_count = max_std_sps_count;
        self
    }
    #[inline]
    pub fn max_std_pps_count(mut self, max_std_pps_count: u32) -> Self {
        self.inner.max_std_pps_count = max_std_pps_count;
        self
    }
    #[inline]
    pub fn parameters_add_info(
        mut self,
        parameters_add_info: &'a VideoDecodeH265SessionParametersAddInfoKHR,
    ) -> Self {
        self.inner.p_parameters_add_info = parameters_add_info;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoDecodeH265SessionParametersCreateInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH265PictureInfoKHR.html>"]
pub struct VideoDecodeH265PictureInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_std_picture_info: *const StdVideoDecodeH265PictureInfo,
    pub slice_segment_count: u32,
    pub p_slice_segment_offsets: *const u32,
}
impl ::std::default::Default for VideoDecodeH265PictureInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_std_picture_info: ::std::ptr::null(),
            slice_segment_count: u32::default(),
            p_slice_segment_offsets: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for VideoDecodeH265PictureInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_DECODE_H265_PICTURE_INFO_KHR;
}
impl VideoDecodeH265PictureInfoKHR {
    pub fn builder<'a>() -> VideoDecodeH265PictureInfoKHRBuilder<'a> {
        VideoDecodeH265PictureInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoDecodeH265PictureInfoKHRBuilder<'a> {
    inner: VideoDecodeH265PictureInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoDecodeInfoKHR for VideoDecodeH265PictureInfoKHRBuilder<'_> {}
unsafe impl ExtendsVideoDecodeInfoKHR for VideoDecodeH265PictureInfoKHR {}
impl<'a> ::std::ops::Deref for VideoDecodeH265PictureInfoKHRBuilder<'a> {
    type Target = VideoDecodeH265PictureInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoDecodeH265PictureInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoDecodeH265PictureInfoKHRBuilder<'a> {
    #[inline]
    pub fn std_picture_info(mut self, std_picture_info: &'a StdVideoDecodeH265PictureInfo) -> Self {
        self.inner.p_std_picture_info = std_picture_info;
        self
    }
    #[inline]
    pub fn slice_segment_offsets(mut self, slice_segment_offsets: &'a [u32]) -> Self {
        self.inner.slice_segment_count = slice_segment_offsets.len() as _;
        self.inner.p_slice_segment_offsets = slice_segment_offsets.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoDecodeH265PictureInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoDecodeH265DpbSlotInfoKHR.html>"]
pub struct VideoDecodeH265DpbSlotInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_std_reference_info: *const StdVideoDecodeH265ReferenceInfo,
}
impl ::std::default::Default for VideoDecodeH265DpbSlotInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_std_reference_info: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for VideoDecodeH265DpbSlotInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR;
}
impl VideoDecodeH265DpbSlotInfoKHR {
    pub fn builder<'a>() -> VideoDecodeH265DpbSlotInfoKHRBuilder<'a> {
        VideoDecodeH265DpbSlotInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoDecodeH265DpbSlotInfoKHRBuilder<'a> {
    inner: VideoDecodeH265DpbSlotInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoReferenceSlotInfoKHR for VideoDecodeH265DpbSlotInfoKHRBuilder<'_> {}
unsafe impl ExtendsVideoReferenceSlotInfoKHR for VideoDecodeH265DpbSlotInfoKHR {}
impl<'a> ::std::ops::Deref for VideoDecodeH265DpbSlotInfoKHRBuilder<'a> {
    type Target = VideoDecodeH265DpbSlotInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoDecodeH265DpbSlotInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoDecodeH265DpbSlotInfoKHRBuilder<'a> {
    #[inline]
    pub fn std_reference_info(
        mut self,
        std_reference_info: &'a StdVideoDecodeH265ReferenceInfo,
    ) -> Self {
        self.inner.p_std_reference_info = std_reference_info;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoDecodeH265DpbSlotInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoSessionCreateInfoKHR.html>"]
pub struct VideoSessionCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub queue_family_index: u32,
    pub flags: VideoSessionCreateFlagsKHR,
    pub p_video_profile: *const VideoProfileInfoKHR,
    pub picture_format: Format,
    pub max_coded_extent: Extent2D,
    pub reference_picture_format: Format,
    pub max_dpb_slots: u32,
    pub max_active_reference_pictures: u32,
    pub p_std_header_version: *const ExtensionProperties,
}
impl ::std::default::Default for VideoSessionCreateInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            queue_family_index: u32::default(),
            flags: VideoSessionCreateFlagsKHR::default(),
            p_video_profile: ::std::ptr::null(),
            picture_format: Format::default(),
            max_coded_extent: Extent2D::default(),
            reference_picture_format: Format::default(),
            max_dpb_slots: u32::default(),
            max_active_reference_pictures: u32::default(),
            p_std_header_version: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for VideoSessionCreateInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_SESSION_CREATE_INFO_KHR;
}
impl VideoSessionCreateInfoKHR {
    pub fn builder<'a>() -> VideoSessionCreateInfoKHRBuilder<'a> {
        VideoSessionCreateInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoSessionCreateInfoKHRBuilder<'a> {
    inner: VideoSessionCreateInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for VideoSessionCreateInfoKHRBuilder<'a> {
    type Target = VideoSessionCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoSessionCreateInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoSessionCreateInfoKHRBuilder<'a> {
    #[inline]
    pub fn queue_family_index(mut self, queue_family_index: u32) -> Self {
        self.inner.queue_family_index = queue_family_index;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: VideoSessionCreateFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn video_profile(mut self, video_profile: &'a VideoProfileInfoKHR) -> Self {
        self.inner.p_video_profile = video_profile;
        self
    }
    #[inline]
    pub fn picture_format(mut self, picture_format: Format) -> Self {
        self.inner.picture_format = picture_format;
        self
    }
    #[inline]
    pub fn max_coded_extent(mut self, max_coded_extent: Extent2D) -> Self {
        self.inner.max_coded_extent = max_coded_extent;
        self
    }
    #[inline]
    pub fn reference_picture_format(mut self, reference_picture_format: Format) -> Self {
        self.inner.reference_picture_format = reference_picture_format;
        self
    }
    #[inline]
    pub fn max_dpb_slots(mut self, max_dpb_slots: u32) -> Self {
        self.inner.max_dpb_slots = max_dpb_slots;
        self
    }
    #[inline]
    pub fn max_active_reference_pictures(mut self, max_active_reference_pictures: u32) -> Self {
        self.inner.max_active_reference_pictures = max_active_reference_pictures;
        self
    }
    #[inline]
    pub fn std_header_version(mut self, std_header_version: &'a ExtensionProperties) -> Self {
        self.inner.p_std_header_version = std_header_version;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoSessionCreateInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoSessionParametersCreateInfoKHR.html>"]
pub struct VideoSessionParametersCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: VideoSessionParametersCreateFlagsKHR,
    pub video_session_parameters_template: VideoSessionParametersKHR,
    pub video_session: VideoSessionKHR,
}
impl ::std::default::Default for VideoSessionParametersCreateInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: VideoSessionParametersCreateFlagsKHR::default(),
            video_session_parameters_template: VideoSessionParametersKHR::default(),
            video_session: VideoSessionKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoSessionParametersCreateInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR;
}
impl VideoSessionParametersCreateInfoKHR {
    pub fn builder<'a>() -> VideoSessionParametersCreateInfoKHRBuilder<'a> {
        VideoSessionParametersCreateInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoSessionParametersCreateInfoKHRBuilder<'a> {
    inner: VideoSessionParametersCreateInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsVideoSessionParametersCreateInfoKHR {}
impl<'a> ::std::ops::Deref for VideoSessionParametersCreateInfoKHRBuilder<'a> {
    type Target = VideoSessionParametersCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoSessionParametersCreateInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoSessionParametersCreateInfoKHRBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: VideoSessionParametersCreateFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn video_session_parameters_template(
        mut self,
        video_session_parameters_template: VideoSessionParametersKHR,
    ) -> Self {
        self.inner.video_session_parameters_template = video_session_parameters_template;
        self
    }
    #[inline]
    pub fn video_session(mut self, video_session: VideoSessionKHR) -> Self {
        self.inner.video_session = video_session;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsVideoSessionParametersCreateInfoKHR>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoSessionParametersCreateInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoSessionParametersUpdateInfoKHR.html>"]
pub struct VideoSessionParametersUpdateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub update_sequence_count: u32,
}
impl ::std::default::Default for VideoSessionParametersUpdateInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            update_sequence_count: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoSessionParametersUpdateInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR;
}
impl VideoSessionParametersUpdateInfoKHR {
    pub fn builder<'a>() -> VideoSessionParametersUpdateInfoKHRBuilder<'a> {
        VideoSessionParametersUpdateInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoSessionParametersUpdateInfoKHRBuilder<'a> {
    inner: VideoSessionParametersUpdateInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsVideoSessionParametersUpdateInfoKHR {}
impl<'a> ::std::ops::Deref for VideoSessionParametersUpdateInfoKHRBuilder<'a> {
    type Target = VideoSessionParametersUpdateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoSessionParametersUpdateInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoSessionParametersUpdateInfoKHRBuilder<'a> {
    #[inline]
    pub fn update_sequence_count(mut self, update_sequence_count: u32) -> Self {
        self.inner.update_sequence_count = update_sequence_count;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsVideoSessionParametersUpdateInfoKHR>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoSessionParametersUpdateInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoBeginCodingInfoKHR.html>"]
pub struct VideoBeginCodingInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: VideoBeginCodingFlagsKHR,
    pub video_session: VideoSessionKHR,
    pub video_session_parameters: VideoSessionParametersKHR,
    pub reference_slot_count: u32,
    pub p_reference_slots: *const VideoReferenceSlotInfoKHR,
}
impl ::std::default::Default for VideoBeginCodingInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: VideoBeginCodingFlagsKHR::default(),
            video_session: VideoSessionKHR::default(),
            video_session_parameters: VideoSessionParametersKHR::default(),
            reference_slot_count: u32::default(),
            p_reference_slots: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for VideoBeginCodingInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_BEGIN_CODING_INFO_KHR;
}
impl VideoBeginCodingInfoKHR {
    pub fn builder<'a>() -> VideoBeginCodingInfoKHRBuilder<'a> {
        VideoBeginCodingInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoBeginCodingInfoKHRBuilder<'a> {
    inner: VideoBeginCodingInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for VideoBeginCodingInfoKHRBuilder<'a> {
    type Target = VideoBeginCodingInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoBeginCodingInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoBeginCodingInfoKHRBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: VideoBeginCodingFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn video_session(mut self, video_session: VideoSessionKHR) -> Self {
        self.inner.video_session = video_session;
        self
    }
    #[inline]
    pub fn video_session_parameters(
        mut self,
        video_session_parameters: VideoSessionParametersKHR,
    ) -> Self {
        self.inner.video_session_parameters = video_session_parameters;
        self
    }
    #[inline]
    pub fn reference_slots(mut self, reference_slots: &'a [VideoReferenceSlotInfoKHR]) -> Self {
        self.inner.reference_slot_count = reference_slots.len() as _;
        self.inner.p_reference_slots = reference_slots.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoBeginCodingInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEndCodingInfoKHR.html>"]
pub struct VideoEndCodingInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: VideoEndCodingFlagsKHR,
}
impl ::std::default::Default for VideoEndCodingInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: VideoEndCodingFlagsKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoEndCodingInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_END_CODING_INFO_KHR;
}
impl VideoEndCodingInfoKHR {
    pub fn builder<'a>() -> VideoEndCodingInfoKHRBuilder<'a> {
        VideoEndCodingInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEndCodingInfoKHRBuilder<'a> {
    inner: VideoEndCodingInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for VideoEndCodingInfoKHRBuilder<'a> {
    type Target = VideoEndCodingInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEndCodingInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEndCodingInfoKHRBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: VideoEndCodingFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEndCodingInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoCodingControlInfoKHR.html>"]
pub struct VideoCodingControlInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: VideoCodingControlFlagsKHR,
}
impl ::std::default::Default for VideoCodingControlInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: VideoCodingControlFlagsKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoCodingControlInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_CODING_CONTROL_INFO_KHR;
}
impl VideoCodingControlInfoKHR {
    pub fn builder<'a>() -> VideoCodingControlInfoKHRBuilder<'a> {
        VideoCodingControlInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoCodingControlInfoKHRBuilder<'a> {
    inner: VideoCodingControlInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsVideoCodingControlInfoKHR {}
impl<'a> ::std::ops::Deref for VideoCodingControlInfoKHRBuilder<'a> {
    type Target = VideoCodingControlInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoCodingControlInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoCodingControlInfoKHRBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: VideoCodingControlFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsVideoCodingControlInfoKHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoCodingControlInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeUsageInfoKHR.html>"]
pub struct VideoEncodeUsageInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub video_usage_hints: VideoEncodeUsageFlagsKHR,
    pub video_content_hints: VideoEncodeContentFlagsKHR,
    pub tuning_mode: VideoEncodeTuningModeKHR,
}
impl ::std::default::Default for VideoEncodeUsageInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            video_usage_hints: VideoEncodeUsageFlagsKHR::default(),
            video_content_hints: VideoEncodeContentFlagsKHR::default(),
            tuning_mode: VideoEncodeTuningModeKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoEncodeUsageInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_USAGE_INFO_KHR;
}
impl VideoEncodeUsageInfoKHR {
    pub fn builder<'a>() -> VideoEncodeUsageInfoKHRBuilder<'a> {
        VideoEncodeUsageInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeUsageInfoKHRBuilder<'a> {
    inner: VideoEncodeUsageInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoProfileInfoKHR for VideoEncodeUsageInfoKHRBuilder<'_> {}
unsafe impl ExtendsVideoProfileInfoKHR for VideoEncodeUsageInfoKHR {}
unsafe impl ExtendsQueryPoolCreateInfo for VideoEncodeUsageInfoKHRBuilder<'_> {}
unsafe impl ExtendsQueryPoolCreateInfo for VideoEncodeUsageInfoKHR {}
impl<'a> ::std::ops::Deref for VideoEncodeUsageInfoKHRBuilder<'a> {
    type Target = VideoEncodeUsageInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeUsageInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeUsageInfoKHRBuilder<'a> {
    #[inline]
    pub fn video_usage_hints(mut self, video_usage_hints: VideoEncodeUsageFlagsKHR) -> Self {
        self.inner.video_usage_hints = video_usage_hints;
        self
    }
    #[inline]
    pub fn video_content_hints(mut self, video_content_hints: VideoEncodeContentFlagsKHR) -> Self {
        self.inner.video_content_hints = video_content_hints;
        self
    }
    #[inline]
    pub fn tuning_mode(mut self, tuning_mode: VideoEncodeTuningModeKHR) -> Self {
        self.inner.tuning_mode = tuning_mode;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeUsageInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeInfoKHR.html>"]
pub struct VideoEncodeInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: VideoEncodeFlagsKHR,
    pub quality_level: u32,
    pub dst_buffer: Buffer,
    pub dst_buffer_offset: DeviceSize,
    pub dst_buffer_range: DeviceSize,
    pub src_picture_resource: VideoPictureResourceInfoKHR,
    pub p_setup_reference_slot: *const VideoReferenceSlotInfoKHR,
    pub reference_slot_count: u32,
    pub p_reference_slots: *const VideoReferenceSlotInfoKHR,
    pub preceding_externally_encoded_bytes: u32,
}
impl ::std::default::Default for VideoEncodeInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: VideoEncodeFlagsKHR::default(),
            quality_level: u32::default(),
            dst_buffer: Buffer::default(),
            dst_buffer_offset: DeviceSize::default(),
            dst_buffer_range: DeviceSize::default(),
            src_picture_resource: VideoPictureResourceInfoKHR::default(),
            p_setup_reference_slot: ::std::ptr::null(),
            reference_slot_count: u32::default(),
            p_reference_slots: ::std::ptr::null(),
            preceding_externally_encoded_bytes: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoEncodeInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_INFO_KHR;
}
impl VideoEncodeInfoKHR {
    pub fn builder<'a>() -> VideoEncodeInfoKHRBuilder<'a> {
        VideoEncodeInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeInfoKHRBuilder<'a> {
    inner: VideoEncodeInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsVideoEncodeInfoKHR {}
impl<'a> ::std::ops::Deref for VideoEncodeInfoKHRBuilder<'a> {
    type Target = VideoEncodeInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeInfoKHRBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: VideoEncodeFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn quality_level(mut self, quality_level: u32) -> Self {
        self.inner.quality_level = quality_level;
        self
    }
    #[inline]
    pub fn dst_buffer(mut self, dst_buffer: Buffer) -> Self {
        self.inner.dst_buffer = dst_buffer;
        self
    }
    #[inline]
    pub fn dst_buffer_offset(mut self, dst_buffer_offset: DeviceSize) -> Self {
        self.inner.dst_buffer_offset = dst_buffer_offset;
        self
    }
    #[inline]
    pub fn dst_buffer_range(mut self, dst_buffer_range: DeviceSize) -> Self {
        self.inner.dst_buffer_range = dst_buffer_range;
        self
    }
    #[inline]
    pub fn src_picture_resource(
        mut self,
        src_picture_resource: VideoPictureResourceInfoKHR,
    ) -> Self {
        self.inner.src_picture_resource = src_picture_resource;
        self
    }
    #[inline]
    pub fn setup_reference_slot(
        mut self,
        setup_reference_slot: &'a VideoReferenceSlotInfoKHR,
    ) -> Self {
        self.inner.p_setup_reference_slot = setup_reference_slot;
        self
    }
    #[inline]
    pub fn reference_slots(mut self, reference_slots: &'a [VideoReferenceSlotInfoKHR]) -> Self {
        self.inner.reference_slot_count = reference_slots.len() as _;
        self.inner.p_reference_slots = reference_slots.as_ptr();
        self
    }
    #[inline]
    pub fn preceding_externally_encoded_bytes(
        mut self,
        preceding_externally_encoded_bytes: u32,
    ) -> Self {
        self.inner.preceding_externally_encoded_bytes = preceding_externally_encoded_bytes;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsVideoEncodeInfoKHR>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPoolVideoEncodeFeedbackCreateInfoKHR.html>"]
pub struct QueryPoolVideoEncodeFeedbackCreateInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub encode_feedback_flags: VideoEncodeFeedbackFlagsKHR,
}
impl ::std::default::Default for QueryPoolVideoEncodeFeedbackCreateInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            encode_feedback_flags: VideoEncodeFeedbackFlagsKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for QueryPoolVideoEncodeFeedbackCreateInfoKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR;
}
impl QueryPoolVideoEncodeFeedbackCreateInfoKHR {
    pub fn builder<'a>() -> QueryPoolVideoEncodeFeedbackCreateInfoKHRBuilder<'a> {
        QueryPoolVideoEncodeFeedbackCreateInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct QueryPoolVideoEncodeFeedbackCreateInfoKHRBuilder<'a> {
    inner: QueryPoolVideoEncodeFeedbackCreateInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsQueryPoolCreateInfo for QueryPoolVideoEncodeFeedbackCreateInfoKHRBuilder<'_> {}
unsafe impl ExtendsQueryPoolCreateInfo for QueryPoolVideoEncodeFeedbackCreateInfoKHR {}
impl<'a> ::std::ops::Deref for QueryPoolVideoEncodeFeedbackCreateInfoKHRBuilder<'a> {
    type Target = QueryPoolVideoEncodeFeedbackCreateInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for QueryPoolVideoEncodeFeedbackCreateInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> QueryPoolVideoEncodeFeedbackCreateInfoKHRBuilder<'a> {
    #[inline]
    pub fn encode_feedback_flags(
        mut self,
        encode_feedback_flags: VideoEncodeFeedbackFlagsKHR,
    ) -> Self {
        self.inner.encode_feedback_flags = encode_feedback_flags;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> QueryPoolVideoEncodeFeedbackCreateInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeRateControlInfoKHR.html>"]
pub struct VideoEncodeRateControlInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: VideoEncodeRateControlFlagsKHR,
    pub rate_control_mode: VideoEncodeRateControlModeFlagsKHR,
    pub layer_count: u32,
    pub p_layers: *const VideoEncodeRateControlLayerInfoKHR,
}
impl ::std::default::Default for VideoEncodeRateControlInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: VideoEncodeRateControlFlagsKHR::default(),
            rate_control_mode: VideoEncodeRateControlModeFlagsKHR::default(),
            layer_count: u32::default(),
            p_layers: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for VideoEncodeRateControlInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_RATE_CONTROL_INFO_KHR;
}
impl VideoEncodeRateControlInfoKHR {
    pub fn builder<'a>() -> VideoEncodeRateControlInfoKHRBuilder<'a> {
        VideoEncodeRateControlInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeRateControlInfoKHRBuilder<'a> {
    inner: VideoEncodeRateControlInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoCodingControlInfoKHR for VideoEncodeRateControlInfoKHRBuilder<'_> {}
unsafe impl ExtendsVideoCodingControlInfoKHR for VideoEncodeRateControlInfoKHR {}
impl<'a> ::std::ops::Deref for VideoEncodeRateControlInfoKHRBuilder<'a> {
    type Target = VideoEncodeRateControlInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeRateControlInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeRateControlInfoKHRBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: VideoEncodeRateControlFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn rate_control_mode(
        mut self,
        rate_control_mode: VideoEncodeRateControlModeFlagsKHR,
    ) -> Self {
        self.inner.rate_control_mode = rate_control_mode;
        self
    }
    #[inline]
    pub fn layers(mut self, layers: &'a [VideoEncodeRateControlLayerInfoKHR]) -> Self {
        self.inner.layer_count = layers.len() as _;
        self.inner.p_layers = layers.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeRateControlInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeRateControlLayerInfoKHR.html>"]
pub struct VideoEncodeRateControlLayerInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub average_bitrate: u64,
    pub max_bitrate: u64,
    pub frame_rate_numerator: u32,
    pub frame_rate_denominator: u32,
    pub virtual_buffer_size_in_ms: u32,
    pub initial_virtual_buffer_size_in_ms: u32,
}
impl ::std::default::Default for VideoEncodeRateControlLayerInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            average_bitrate: u64::default(),
            max_bitrate: u64::default(),
            frame_rate_numerator: u32::default(),
            frame_rate_denominator: u32::default(),
            virtual_buffer_size_in_ms: u32::default(),
            initial_virtual_buffer_size_in_ms: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoEncodeRateControlLayerInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR;
}
impl VideoEncodeRateControlLayerInfoKHR {
    pub fn builder<'a>() -> VideoEncodeRateControlLayerInfoKHRBuilder<'a> {
        VideoEncodeRateControlLayerInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeRateControlLayerInfoKHRBuilder<'a> {
    inner: VideoEncodeRateControlLayerInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoCodingControlInfoKHR for VideoEncodeRateControlLayerInfoKHRBuilder<'_> {}
unsafe impl ExtendsVideoCodingControlInfoKHR for VideoEncodeRateControlLayerInfoKHR {}
pub unsafe trait ExtendsVideoEncodeRateControlLayerInfoKHR {}
impl<'a> ::std::ops::Deref for VideoEncodeRateControlLayerInfoKHRBuilder<'a> {
    type Target = VideoEncodeRateControlLayerInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeRateControlLayerInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeRateControlLayerInfoKHRBuilder<'a> {
    #[inline]
    pub fn average_bitrate(mut self, average_bitrate: u64) -> Self {
        self.inner.average_bitrate = average_bitrate;
        self
    }
    #[inline]
    pub fn max_bitrate(mut self, max_bitrate: u64) -> Self {
        self.inner.max_bitrate = max_bitrate;
        self
    }
    #[inline]
    pub fn frame_rate_numerator(mut self, frame_rate_numerator: u32) -> Self {
        self.inner.frame_rate_numerator = frame_rate_numerator;
        self
    }
    #[inline]
    pub fn frame_rate_denominator(mut self, frame_rate_denominator: u32) -> Self {
        self.inner.frame_rate_denominator = frame_rate_denominator;
        self
    }
    #[inline]
    pub fn virtual_buffer_size_in_ms(mut self, virtual_buffer_size_in_ms: u32) -> Self {
        self.inner.virtual_buffer_size_in_ms = virtual_buffer_size_in_ms;
        self
    }
    #[inline]
    pub fn initial_virtual_buffer_size_in_ms(
        mut self,
        initial_virtual_buffer_size_in_ms: u32,
    ) -> Self {
        self.inner.initial_virtual_buffer_size_in_ms = initial_virtual_buffer_size_in_ms;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsVideoEncodeRateControlLayerInfoKHR>(
        mut self,
        next: &'a mut T,
    ) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeRateControlLayerInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeCapabilitiesKHR.html>"]
pub struct VideoEncodeCapabilitiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub flags: VideoEncodeCapabilityFlagsKHR,
    pub rate_control_modes: VideoEncodeRateControlModeFlagsKHR,
    pub max_rate_control_layers: u32,
    pub max_quality_levels: u32,
    pub input_image_data_fill_alignment: Extent2D,
    pub supported_encode_feedback_flags: VideoEncodeFeedbackFlagsKHR,
}
impl ::std::default::Default for VideoEncodeCapabilitiesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            flags: VideoEncodeCapabilityFlagsKHR::default(),
            rate_control_modes: VideoEncodeRateControlModeFlagsKHR::default(),
            max_rate_control_layers: u32::default(),
            max_quality_levels: u32::default(),
            input_image_data_fill_alignment: Extent2D::default(),
            supported_encode_feedback_flags: VideoEncodeFeedbackFlagsKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoEncodeCapabilitiesKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_CAPABILITIES_KHR;
}
impl VideoEncodeCapabilitiesKHR {
    pub fn builder<'a>() -> VideoEncodeCapabilitiesKHRBuilder<'a> {
        VideoEncodeCapabilitiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeCapabilitiesKHRBuilder<'a> {
    inner: VideoEncodeCapabilitiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoCapabilitiesKHR for VideoEncodeCapabilitiesKHRBuilder<'_> {}
unsafe impl ExtendsVideoCapabilitiesKHR for VideoEncodeCapabilitiesKHR {}
impl<'a> ::std::ops::Deref for VideoEncodeCapabilitiesKHRBuilder<'a> {
    type Target = VideoEncodeCapabilitiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeCapabilitiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeCapabilitiesKHRBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: VideoEncodeCapabilityFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn rate_control_modes(
        mut self,
        rate_control_modes: VideoEncodeRateControlModeFlagsKHR,
    ) -> Self {
        self.inner.rate_control_modes = rate_control_modes;
        self
    }
    #[inline]
    pub fn max_rate_control_layers(mut self, max_rate_control_layers: u32) -> Self {
        self.inner.max_rate_control_layers = max_rate_control_layers;
        self
    }
    #[inline]
    pub fn max_quality_levels(mut self, max_quality_levels: u32) -> Self {
        self.inner.max_quality_levels = max_quality_levels;
        self
    }
    #[inline]
    pub fn input_image_data_fill_alignment(
        mut self,
        input_image_data_fill_alignment: Extent2D,
    ) -> Self {
        self.inner.input_image_data_fill_alignment = input_image_data_fill_alignment;
        self
    }
    #[inline]
    pub fn supported_encode_feedback_flags(
        mut self,
        supported_encode_feedback_flags: VideoEncodeFeedbackFlagsKHR,
    ) -> Self {
        self.inner.supported_encode_feedback_flags = supported_encode_feedback_flags;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeCapabilitiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH264CapabilitiesEXT.html>"]
pub struct VideoEncodeH264CapabilitiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub flags: VideoEncodeH264CapabilityFlagsEXT,
    pub max_p_picture_l0_reference_count: u32,
    pub max_b_picture_l0_reference_count: u32,
    pub max_l1_reference_count: u32,
    pub motion_vectors_over_pic_boundaries_flag: Bool32,
    pub max_bytes_per_pic_denom: u32,
    pub max_bits_per_mb_denom: u32,
    pub log2_max_mv_length_horizontal: u32,
    pub log2_max_mv_length_vertical: u32,
}
impl ::std::default::Default for VideoEncodeH264CapabilitiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            flags: VideoEncodeH264CapabilityFlagsEXT::default(),
            max_p_picture_l0_reference_count: u32::default(),
            max_b_picture_l0_reference_count: u32::default(),
            max_l1_reference_count: u32::default(),
            motion_vectors_over_pic_boundaries_flag: Bool32::default(),
            max_bytes_per_pic_denom: u32::default(),
            max_bits_per_mb_denom: u32::default(),
            log2_max_mv_length_horizontal: u32::default(),
            log2_max_mv_length_vertical: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoEncodeH264CapabilitiesEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H264_CAPABILITIES_EXT;
}
impl VideoEncodeH264CapabilitiesEXT {
    pub fn builder<'a>() -> VideoEncodeH264CapabilitiesEXTBuilder<'a> {
        VideoEncodeH264CapabilitiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeH264CapabilitiesEXTBuilder<'a> {
    inner: VideoEncodeH264CapabilitiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoCapabilitiesKHR for VideoEncodeH264CapabilitiesEXTBuilder<'_> {}
unsafe impl ExtendsVideoCapabilitiesKHR for VideoEncodeH264CapabilitiesEXT {}
impl<'a> ::std::ops::Deref for VideoEncodeH264CapabilitiesEXTBuilder<'a> {
    type Target = VideoEncodeH264CapabilitiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeH264CapabilitiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeH264CapabilitiesEXTBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: VideoEncodeH264CapabilityFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn max_p_picture_l0_reference_count(
        mut self,
        max_p_picture_l0_reference_count: u32,
    ) -> Self {
        self.inner.max_p_picture_l0_reference_count = max_p_picture_l0_reference_count;
        self
    }
    #[inline]
    pub fn max_b_picture_l0_reference_count(
        mut self,
        max_b_picture_l0_reference_count: u32,
    ) -> Self {
        self.inner.max_b_picture_l0_reference_count = max_b_picture_l0_reference_count;
        self
    }
    #[inline]
    pub fn max_l1_reference_count(mut self, max_l1_reference_count: u32) -> Self {
        self.inner.max_l1_reference_count = max_l1_reference_count;
        self
    }
    #[inline]
    pub fn motion_vectors_over_pic_boundaries_flag(
        mut self,
        motion_vectors_over_pic_boundaries_flag: bool,
    ) -> Self {
        self.inner.motion_vectors_over_pic_boundaries_flag =
            motion_vectors_over_pic_boundaries_flag.into();
        self
    }
    #[inline]
    pub fn max_bytes_per_pic_denom(mut self, max_bytes_per_pic_denom: u32) -> Self {
        self.inner.max_bytes_per_pic_denom = max_bytes_per_pic_denom;
        self
    }
    #[inline]
    pub fn max_bits_per_mb_denom(mut self, max_bits_per_mb_denom: u32) -> Self {
        self.inner.max_bits_per_mb_denom = max_bits_per_mb_denom;
        self
    }
    #[inline]
    pub fn log2_max_mv_length_horizontal(mut self, log2_max_mv_length_horizontal: u32) -> Self {
        self.inner.log2_max_mv_length_horizontal = log2_max_mv_length_horizontal;
        self
    }
    #[inline]
    pub fn log2_max_mv_length_vertical(mut self, log2_max_mv_length_vertical: u32) -> Self {
        self.inner.log2_max_mv_length_vertical = log2_max_mv_length_vertical;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeH264CapabilitiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH264SessionParametersAddInfoEXT.html>"]
pub struct VideoEncodeH264SessionParametersAddInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub std_sps_count: u32,
    pub p_std_sp_ss: *const StdVideoH264SequenceParameterSet,
    pub std_pps_count: u32,
    pub p_std_pp_ss: *const StdVideoH264PictureParameterSet,
}
impl ::std::default::Default for VideoEncodeH264SessionParametersAddInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            std_sps_count: u32::default(),
            p_std_sp_ss: ::std::ptr::null(),
            std_pps_count: u32::default(),
            p_std_pp_ss: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for VideoEncodeH264SessionParametersAddInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT;
}
impl VideoEncodeH264SessionParametersAddInfoEXT {
    pub fn builder<'a>() -> VideoEncodeH264SessionParametersAddInfoEXTBuilder<'a> {
        VideoEncodeH264SessionParametersAddInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeH264SessionParametersAddInfoEXTBuilder<'a> {
    inner: VideoEncodeH264SessionParametersAddInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoSessionParametersUpdateInfoKHR
    for VideoEncodeH264SessionParametersAddInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsVideoSessionParametersUpdateInfoKHR
    for VideoEncodeH264SessionParametersAddInfoEXT
{
}
impl<'a> ::std::ops::Deref for VideoEncodeH264SessionParametersAddInfoEXTBuilder<'a> {
    type Target = VideoEncodeH264SessionParametersAddInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeH264SessionParametersAddInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeH264SessionParametersAddInfoEXTBuilder<'a> {
    #[inline]
    pub fn std_sp_ss(mut self, std_sp_ss: &'a [StdVideoH264SequenceParameterSet]) -> Self {
        self.inner.std_sps_count = std_sp_ss.len() as _;
        self.inner.p_std_sp_ss = std_sp_ss.as_ptr();
        self
    }
    #[inline]
    pub fn std_pp_ss(mut self, std_pp_ss: &'a [StdVideoH264PictureParameterSet]) -> Self {
        self.inner.std_pps_count = std_pp_ss.len() as _;
        self.inner.p_std_pp_ss = std_pp_ss.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeH264SessionParametersAddInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH264SessionParametersCreateInfoEXT.html>"]
pub struct VideoEncodeH264SessionParametersCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub max_std_sps_count: u32,
    pub max_std_pps_count: u32,
    pub p_parameters_add_info: *const VideoEncodeH264SessionParametersAddInfoEXT,
}
impl ::std::default::Default for VideoEncodeH264SessionParametersCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            max_std_sps_count: u32::default(),
            max_std_pps_count: u32::default(),
            p_parameters_add_info: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for VideoEncodeH264SessionParametersCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT;
}
impl VideoEncodeH264SessionParametersCreateInfoEXT {
    pub fn builder<'a>() -> VideoEncodeH264SessionParametersCreateInfoEXTBuilder<'a> {
        VideoEncodeH264SessionParametersCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeH264SessionParametersCreateInfoEXTBuilder<'a> {
    inner: VideoEncodeH264SessionParametersCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoSessionParametersCreateInfoKHR
    for VideoEncodeH264SessionParametersCreateInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsVideoSessionParametersCreateInfoKHR
    for VideoEncodeH264SessionParametersCreateInfoEXT
{
}
impl<'a> ::std::ops::Deref for VideoEncodeH264SessionParametersCreateInfoEXTBuilder<'a> {
    type Target = VideoEncodeH264SessionParametersCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeH264SessionParametersCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeH264SessionParametersCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn max_std_sps_count(mut self, max_std_sps_count: u32) -> Self {
        self.inner.max_std_sps_count = max_std_sps_count;
        self
    }
    #[inline]
    pub fn max_std_pps_count(mut self, max_std_pps_count: u32) -> Self {
        self.inner.max_std_pps_count = max_std_pps_count;
        self
    }
    #[inline]
    pub fn parameters_add_info(
        mut self,
        parameters_add_info: &'a VideoEncodeH264SessionParametersAddInfoEXT,
    ) -> Self {
        self.inner.p_parameters_add_info = parameters_add_info;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeH264SessionParametersCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH264DpbSlotInfoEXT.html>"]
pub struct VideoEncodeH264DpbSlotInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_std_reference_info: *const StdVideoEncodeH264ReferenceInfo,
}
impl ::std::default::Default for VideoEncodeH264DpbSlotInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_std_reference_info: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for VideoEncodeH264DpbSlotInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT;
}
impl VideoEncodeH264DpbSlotInfoEXT {
    pub fn builder<'a>() -> VideoEncodeH264DpbSlotInfoEXTBuilder<'a> {
        VideoEncodeH264DpbSlotInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeH264DpbSlotInfoEXTBuilder<'a> {
    inner: VideoEncodeH264DpbSlotInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoReferenceSlotInfoKHR for VideoEncodeH264DpbSlotInfoEXTBuilder<'_> {}
unsafe impl ExtendsVideoReferenceSlotInfoKHR for VideoEncodeH264DpbSlotInfoEXT {}
impl<'a> ::std::ops::Deref for VideoEncodeH264DpbSlotInfoEXTBuilder<'a> {
    type Target = VideoEncodeH264DpbSlotInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeH264DpbSlotInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeH264DpbSlotInfoEXTBuilder<'a> {
    #[inline]
    pub fn std_reference_info(
        mut self,
        std_reference_info: &'a StdVideoEncodeH264ReferenceInfo,
    ) -> Self {
        self.inner.p_std_reference_info = std_reference_info;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeH264DpbSlotInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH264VclFrameInfoEXT.html>"]
pub struct VideoEncodeH264VclFrameInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_std_reference_final_lists: *const StdVideoEncodeH264ReferenceListsInfo,
    pub nalu_slice_entry_count: u32,
    pub p_nalu_slice_entries: *const VideoEncodeH264NaluSliceInfoEXT,
    pub p_std_picture_info: *const StdVideoEncodeH264PictureInfo,
}
impl ::std::default::Default for VideoEncodeH264VclFrameInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_std_reference_final_lists: ::std::ptr::null(),
            nalu_slice_entry_count: u32::default(),
            p_nalu_slice_entries: ::std::ptr::null(),
            p_std_picture_info: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for VideoEncodeH264VclFrameInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H264_VCL_FRAME_INFO_EXT;
}
impl VideoEncodeH264VclFrameInfoEXT {
    pub fn builder<'a>() -> VideoEncodeH264VclFrameInfoEXTBuilder<'a> {
        VideoEncodeH264VclFrameInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeH264VclFrameInfoEXTBuilder<'a> {
    inner: VideoEncodeH264VclFrameInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoEncodeInfoKHR for VideoEncodeH264VclFrameInfoEXTBuilder<'_> {}
unsafe impl ExtendsVideoEncodeInfoKHR for VideoEncodeH264VclFrameInfoEXT {}
impl<'a> ::std::ops::Deref for VideoEncodeH264VclFrameInfoEXTBuilder<'a> {
    type Target = VideoEncodeH264VclFrameInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeH264VclFrameInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeH264VclFrameInfoEXTBuilder<'a> {
    #[inline]
    pub fn std_reference_final_lists(
        mut self,
        std_reference_final_lists: &'a StdVideoEncodeH264ReferenceListsInfo,
    ) -> Self {
        self.inner.p_std_reference_final_lists = std_reference_final_lists;
        self
    }
    #[inline]
    pub fn nalu_slice_entries(
        mut self,
        nalu_slice_entries: &'a [VideoEncodeH264NaluSliceInfoEXT],
    ) -> Self {
        self.inner.nalu_slice_entry_count = nalu_slice_entries.len() as _;
        self.inner.p_nalu_slice_entries = nalu_slice_entries.as_ptr();
        self
    }
    #[inline]
    pub fn std_picture_info(mut self, std_picture_info: &'a StdVideoEncodeH264PictureInfo) -> Self {
        self.inner.p_std_picture_info = std_picture_info;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeH264VclFrameInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH264ProfileInfoEXT.html>"]
pub struct VideoEncodeH264ProfileInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub std_profile_idc: StdVideoH264ProfileIdc,
}
impl ::std::default::Default for VideoEncodeH264ProfileInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            std_profile_idc: StdVideoH264ProfileIdc::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoEncodeH264ProfileInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H264_PROFILE_INFO_EXT;
}
impl VideoEncodeH264ProfileInfoEXT {
    pub fn builder<'a>() -> VideoEncodeH264ProfileInfoEXTBuilder<'a> {
        VideoEncodeH264ProfileInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeH264ProfileInfoEXTBuilder<'a> {
    inner: VideoEncodeH264ProfileInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoProfileInfoKHR for VideoEncodeH264ProfileInfoEXTBuilder<'_> {}
unsafe impl ExtendsVideoProfileInfoKHR for VideoEncodeH264ProfileInfoEXT {}
unsafe impl ExtendsQueryPoolCreateInfo for VideoEncodeH264ProfileInfoEXTBuilder<'_> {}
unsafe impl ExtendsQueryPoolCreateInfo for VideoEncodeH264ProfileInfoEXT {}
impl<'a> ::std::ops::Deref for VideoEncodeH264ProfileInfoEXTBuilder<'a> {
    type Target = VideoEncodeH264ProfileInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeH264ProfileInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeH264ProfileInfoEXTBuilder<'a> {
    #[inline]
    pub fn std_profile_idc(mut self, std_profile_idc: StdVideoH264ProfileIdc) -> Self {
        self.inner.std_profile_idc = std_profile_idc;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeH264ProfileInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH264NaluSliceInfoEXT.html>"]
pub struct VideoEncodeH264NaluSliceInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub mb_count: u32,
    pub p_std_reference_final_lists: *const StdVideoEncodeH264ReferenceListsInfo,
    pub p_std_slice_header: *const StdVideoEncodeH264SliceHeader,
}
impl ::std::default::Default for VideoEncodeH264NaluSliceInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            mb_count: u32::default(),
            p_std_reference_final_lists: ::std::ptr::null(),
            p_std_slice_header: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for VideoEncodeH264NaluSliceInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H264_NALU_SLICE_INFO_EXT;
}
impl VideoEncodeH264NaluSliceInfoEXT {
    pub fn builder<'a>() -> VideoEncodeH264NaluSliceInfoEXTBuilder<'a> {
        VideoEncodeH264NaluSliceInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeH264NaluSliceInfoEXTBuilder<'a> {
    inner: VideoEncodeH264NaluSliceInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for VideoEncodeH264NaluSliceInfoEXTBuilder<'a> {
    type Target = VideoEncodeH264NaluSliceInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeH264NaluSliceInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeH264NaluSliceInfoEXTBuilder<'a> {
    #[inline]
    pub fn mb_count(mut self, mb_count: u32) -> Self {
        self.inner.mb_count = mb_count;
        self
    }
    #[inline]
    pub fn std_reference_final_lists(
        mut self,
        std_reference_final_lists: &'a StdVideoEncodeH264ReferenceListsInfo,
    ) -> Self {
        self.inner.p_std_reference_final_lists = std_reference_final_lists;
        self
    }
    #[inline]
    pub fn std_slice_header(mut self, std_slice_header: &'a StdVideoEncodeH264SliceHeader) -> Self {
        self.inner.p_std_slice_header = std_slice_header;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeH264NaluSliceInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH264RateControlInfoEXT.html>"]
pub struct VideoEncodeH264RateControlInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub gop_frame_count: u32,
    pub idr_period: u32,
    pub consecutive_b_frame_count: u32,
    pub rate_control_structure: VideoEncodeH264RateControlStructureEXT,
    pub temporal_layer_count: u32,
}
impl ::std::default::Default for VideoEncodeH264RateControlInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            gop_frame_count: u32::default(),
            idr_period: u32::default(),
            consecutive_b_frame_count: u32::default(),
            rate_control_structure: VideoEncodeH264RateControlStructureEXT::default(),
            temporal_layer_count: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoEncodeH264RateControlInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H264_RATE_CONTROL_INFO_EXT;
}
impl VideoEncodeH264RateControlInfoEXT {
    pub fn builder<'a>() -> VideoEncodeH264RateControlInfoEXTBuilder<'a> {
        VideoEncodeH264RateControlInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeH264RateControlInfoEXTBuilder<'a> {
    inner: VideoEncodeH264RateControlInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoCodingControlInfoKHR for VideoEncodeH264RateControlInfoEXTBuilder<'_> {}
unsafe impl ExtendsVideoCodingControlInfoKHR for VideoEncodeH264RateControlInfoEXT {}
impl<'a> ::std::ops::Deref for VideoEncodeH264RateControlInfoEXTBuilder<'a> {
    type Target = VideoEncodeH264RateControlInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeH264RateControlInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeH264RateControlInfoEXTBuilder<'a> {
    #[inline]
    pub fn gop_frame_count(mut self, gop_frame_count: u32) -> Self {
        self.inner.gop_frame_count = gop_frame_count;
        self
    }
    #[inline]
    pub fn idr_period(mut self, idr_period: u32) -> Self {
        self.inner.idr_period = idr_period;
        self
    }
    #[inline]
    pub fn consecutive_b_frame_count(mut self, consecutive_b_frame_count: u32) -> Self {
        self.inner.consecutive_b_frame_count = consecutive_b_frame_count;
        self
    }
    #[inline]
    pub fn rate_control_structure(
        mut self,
        rate_control_structure: VideoEncodeH264RateControlStructureEXT,
    ) -> Self {
        self.inner.rate_control_structure = rate_control_structure;
        self
    }
    #[inline]
    pub fn temporal_layer_count(mut self, temporal_layer_count: u32) -> Self {
        self.inner.temporal_layer_count = temporal_layer_count;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeH264RateControlInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH264QpEXT.html>"]
pub struct VideoEncodeH264QpEXT {
    pub qp_i: i32,
    pub qp_p: i32,
    pub qp_b: i32,
}
impl VideoEncodeH264QpEXT {
    pub fn builder<'a>() -> VideoEncodeH264QpEXTBuilder<'a> {
        VideoEncodeH264QpEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeH264QpEXTBuilder<'a> {
    inner: VideoEncodeH264QpEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for VideoEncodeH264QpEXTBuilder<'a> {
    type Target = VideoEncodeH264QpEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeH264QpEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeH264QpEXTBuilder<'a> {
    #[inline]
    pub fn qp_i(mut self, qp_i: i32) -> Self {
        self.inner.qp_i = qp_i;
        self
    }
    #[inline]
    pub fn qp_p(mut self, qp_p: i32) -> Self {
        self.inner.qp_p = qp_p;
        self
    }
    #[inline]
    pub fn qp_b(mut self, qp_b: i32) -> Self {
        self.inner.qp_b = qp_b;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeH264QpEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH264FrameSizeEXT.html>"]
pub struct VideoEncodeH264FrameSizeEXT {
    pub frame_i_size: u32,
    pub frame_p_size: u32,
    pub frame_b_size: u32,
}
impl VideoEncodeH264FrameSizeEXT {
    pub fn builder<'a>() -> VideoEncodeH264FrameSizeEXTBuilder<'a> {
        VideoEncodeH264FrameSizeEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeH264FrameSizeEXTBuilder<'a> {
    inner: VideoEncodeH264FrameSizeEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for VideoEncodeH264FrameSizeEXTBuilder<'a> {
    type Target = VideoEncodeH264FrameSizeEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeH264FrameSizeEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeH264FrameSizeEXTBuilder<'a> {
    #[inline]
    pub fn frame_i_size(mut self, frame_i_size: u32) -> Self {
        self.inner.frame_i_size = frame_i_size;
        self
    }
    #[inline]
    pub fn frame_p_size(mut self, frame_p_size: u32) -> Self {
        self.inner.frame_p_size = frame_p_size;
        self
    }
    #[inline]
    pub fn frame_b_size(mut self, frame_b_size: u32) -> Self {
        self.inner.frame_b_size = frame_b_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeH264FrameSizeEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH264RateControlLayerInfoEXT.html>"]
pub struct VideoEncodeH264RateControlLayerInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub temporal_layer_id: u32,
    pub use_initial_rc_qp: Bool32,
    pub initial_rc_qp: VideoEncodeH264QpEXT,
    pub use_min_qp: Bool32,
    pub min_qp: VideoEncodeH264QpEXT,
    pub use_max_qp: Bool32,
    pub max_qp: VideoEncodeH264QpEXT,
    pub use_max_frame_size: Bool32,
    pub max_frame_size: VideoEncodeH264FrameSizeEXT,
}
impl ::std::default::Default for VideoEncodeH264RateControlLayerInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            temporal_layer_id: u32::default(),
            use_initial_rc_qp: Bool32::default(),
            initial_rc_qp: VideoEncodeH264QpEXT::default(),
            use_min_qp: Bool32::default(),
            min_qp: VideoEncodeH264QpEXT::default(),
            use_max_qp: Bool32::default(),
            max_qp: VideoEncodeH264QpEXT::default(),
            use_max_frame_size: Bool32::default(),
            max_frame_size: VideoEncodeH264FrameSizeEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoEncodeH264RateControlLayerInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_EXT;
}
impl VideoEncodeH264RateControlLayerInfoEXT {
    pub fn builder<'a>() -> VideoEncodeH264RateControlLayerInfoEXTBuilder<'a> {
        VideoEncodeH264RateControlLayerInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeH264RateControlLayerInfoEXTBuilder<'a> {
    inner: VideoEncodeH264RateControlLayerInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoCodingControlInfoKHR for VideoEncodeH264RateControlLayerInfoEXTBuilder<'_> {}
unsafe impl ExtendsVideoCodingControlInfoKHR for VideoEncodeH264RateControlLayerInfoEXT {}
unsafe impl ExtendsVideoEncodeRateControlLayerInfoKHR
    for VideoEncodeH264RateControlLayerInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsVideoEncodeRateControlLayerInfoKHR for VideoEncodeH264RateControlLayerInfoEXT {}
impl<'a> ::std::ops::Deref for VideoEncodeH264RateControlLayerInfoEXTBuilder<'a> {
    type Target = VideoEncodeH264RateControlLayerInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeH264RateControlLayerInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeH264RateControlLayerInfoEXTBuilder<'a> {
    #[inline]
    pub fn temporal_layer_id(mut self, temporal_layer_id: u32) -> Self {
        self.inner.temporal_layer_id = temporal_layer_id;
        self
    }
    #[inline]
    pub fn use_initial_rc_qp(mut self, use_initial_rc_qp: bool) -> Self {
        self.inner.use_initial_rc_qp = use_initial_rc_qp.into();
        self
    }
    #[inline]
    pub fn initial_rc_qp(mut self, initial_rc_qp: VideoEncodeH264QpEXT) -> Self {
        self.inner.initial_rc_qp = initial_rc_qp;
        self
    }
    #[inline]
    pub fn use_min_qp(mut self, use_min_qp: bool) -> Self {
        self.inner.use_min_qp = use_min_qp.into();
        self
    }
    #[inline]
    pub fn min_qp(mut self, min_qp: VideoEncodeH264QpEXT) -> Self {
        self.inner.min_qp = min_qp;
        self
    }
    #[inline]
    pub fn use_max_qp(mut self, use_max_qp: bool) -> Self {
        self.inner.use_max_qp = use_max_qp.into();
        self
    }
    #[inline]
    pub fn max_qp(mut self, max_qp: VideoEncodeH264QpEXT) -> Self {
        self.inner.max_qp = max_qp;
        self
    }
    #[inline]
    pub fn use_max_frame_size(mut self, use_max_frame_size: bool) -> Self {
        self.inner.use_max_frame_size = use_max_frame_size.into();
        self
    }
    #[inline]
    pub fn max_frame_size(mut self, max_frame_size: VideoEncodeH264FrameSizeEXT) -> Self {
        self.inner.max_frame_size = max_frame_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeH264RateControlLayerInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH265CapabilitiesEXT.html>"]
pub struct VideoEncodeH265CapabilitiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub flags: VideoEncodeH265CapabilityFlagsEXT,
    pub ctb_sizes: VideoEncodeH265CtbSizeFlagsEXT,
    pub transform_block_sizes: VideoEncodeH265TransformBlockSizeFlagsEXT,
    pub max_p_picture_l0_reference_count: u32,
    pub max_b_picture_l0_reference_count: u32,
    pub max_l1_reference_count: u32,
    pub max_sub_layers_count: u32,
    pub min_log2_min_luma_coding_block_size_minus3: u32,
    pub max_log2_min_luma_coding_block_size_minus3: u32,
    pub min_log2_min_luma_transform_block_size_minus2: u32,
    pub max_log2_min_luma_transform_block_size_minus2: u32,
    pub min_max_transform_hierarchy_depth_inter: u32,
    pub max_max_transform_hierarchy_depth_inter: u32,
    pub min_max_transform_hierarchy_depth_intra: u32,
    pub max_max_transform_hierarchy_depth_intra: u32,
    pub max_diff_cu_qp_delta_depth: u32,
    pub min_max_num_merge_cand: u32,
    pub max_max_num_merge_cand: u32,
}
impl ::std::default::Default for VideoEncodeH265CapabilitiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            flags: VideoEncodeH265CapabilityFlagsEXT::default(),
            ctb_sizes: VideoEncodeH265CtbSizeFlagsEXT::default(),
            transform_block_sizes: VideoEncodeH265TransformBlockSizeFlagsEXT::default(),
            max_p_picture_l0_reference_count: u32::default(),
            max_b_picture_l0_reference_count: u32::default(),
            max_l1_reference_count: u32::default(),
            max_sub_layers_count: u32::default(),
            min_log2_min_luma_coding_block_size_minus3: u32::default(),
            max_log2_min_luma_coding_block_size_minus3: u32::default(),
            min_log2_min_luma_transform_block_size_minus2: u32::default(),
            max_log2_min_luma_transform_block_size_minus2: u32::default(),
            min_max_transform_hierarchy_depth_inter: u32::default(),
            max_max_transform_hierarchy_depth_inter: u32::default(),
            min_max_transform_hierarchy_depth_intra: u32::default(),
            max_max_transform_hierarchy_depth_intra: u32::default(),
            max_diff_cu_qp_delta_depth: u32::default(),
            min_max_num_merge_cand: u32::default(),
            max_max_num_merge_cand: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoEncodeH265CapabilitiesEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H265_CAPABILITIES_EXT;
}
impl VideoEncodeH265CapabilitiesEXT {
    pub fn builder<'a>() -> VideoEncodeH265CapabilitiesEXTBuilder<'a> {
        VideoEncodeH265CapabilitiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeH265CapabilitiesEXTBuilder<'a> {
    inner: VideoEncodeH265CapabilitiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoCapabilitiesKHR for VideoEncodeH265CapabilitiesEXTBuilder<'_> {}
unsafe impl ExtendsVideoCapabilitiesKHR for VideoEncodeH265CapabilitiesEXT {}
impl<'a> ::std::ops::Deref for VideoEncodeH265CapabilitiesEXTBuilder<'a> {
    type Target = VideoEncodeH265CapabilitiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeH265CapabilitiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeH265CapabilitiesEXTBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: VideoEncodeH265CapabilityFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn ctb_sizes(mut self, ctb_sizes: VideoEncodeH265CtbSizeFlagsEXT) -> Self {
        self.inner.ctb_sizes = ctb_sizes;
        self
    }
    #[inline]
    pub fn transform_block_sizes(
        mut self,
        transform_block_sizes: VideoEncodeH265TransformBlockSizeFlagsEXT,
    ) -> Self {
        self.inner.transform_block_sizes = transform_block_sizes;
        self
    }
    #[inline]
    pub fn max_p_picture_l0_reference_count(
        mut self,
        max_p_picture_l0_reference_count: u32,
    ) -> Self {
        self.inner.max_p_picture_l0_reference_count = max_p_picture_l0_reference_count;
        self
    }
    #[inline]
    pub fn max_b_picture_l0_reference_count(
        mut self,
        max_b_picture_l0_reference_count: u32,
    ) -> Self {
        self.inner.max_b_picture_l0_reference_count = max_b_picture_l0_reference_count;
        self
    }
    #[inline]
    pub fn max_l1_reference_count(mut self, max_l1_reference_count: u32) -> Self {
        self.inner.max_l1_reference_count = max_l1_reference_count;
        self
    }
    #[inline]
    pub fn max_sub_layers_count(mut self, max_sub_layers_count: u32) -> Self {
        self.inner.max_sub_layers_count = max_sub_layers_count;
        self
    }
    #[inline]
    pub fn min_log2_min_luma_coding_block_size_minus3(
        mut self,
        min_log2_min_luma_coding_block_size_minus3: u32,
    ) -> Self {
        self.inner.min_log2_min_luma_coding_block_size_minus3 =
            min_log2_min_luma_coding_block_size_minus3;
        self
    }
    #[inline]
    pub fn max_log2_min_luma_coding_block_size_minus3(
        mut self,
        max_log2_min_luma_coding_block_size_minus3: u32,
    ) -> Self {
        self.inner.max_log2_min_luma_coding_block_size_minus3 =
            max_log2_min_luma_coding_block_size_minus3;
        self
    }
    #[inline]
    pub fn min_log2_min_luma_transform_block_size_minus2(
        mut self,
        min_log2_min_luma_transform_block_size_minus2: u32,
    ) -> Self {
        self.inner.min_log2_min_luma_transform_block_size_minus2 =
            min_log2_min_luma_transform_block_size_minus2;
        self
    }
    #[inline]
    pub fn max_log2_min_luma_transform_block_size_minus2(
        mut self,
        max_log2_min_luma_transform_block_size_minus2: u32,
    ) -> Self {
        self.inner.max_log2_min_luma_transform_block_size_minus2 =
            max_log2_min_luma_transform_block_size_minus2;
        self
    }
    #[inline]
    pub fn min_max_transform_hierarchy_depth_inter(
        mut self,
        min_max_transform_hierarchy_depth_inter: u32,
    ) -> Self {
        self.inner.min_max_transform_hierarchy_depth_inter =
            min_max_transform_hierarchy_depth_inter;
        self
    }
    #[inline]
    pub fn max_max_transform_hierarchy_depth_inter(
        mut self,
        max_max_transform_hierarchy_depth_inter: u32,
    ) -> Self {
        self.inner.max_max_transform_hierarchy_depth_inter =
            max_max_transform_hierarchy_depth_inter;
        self
    }
    #[inline]
    pub fn min_max_transform_hierarchy_depth_intra(
        mut self,
        min_max_transform_hierarchy_depth_intra: u32,
    ) -> Self {
        self.inner.min_max_transform_hierarchy_depth_intra =
            min_max_transform_hierarchy_depth_intra;
        self
    }
    #[inline]
    pub fn max_max_transform_hierarchy_depth_intra(
        mut self,
        max_max_transform_hierarchy_depth_intra: u32,
    ) -> Self {
        self.inner.max_max_transform_hierarchy_depth_intra =
            max_max_transform_hierarchy_depth_intra;
        self
    }
    #[inline]
    pub fn max_diff_cu_qp_delta_depth(mut self, max_diff_cu_qp_delta_depth: u32) -> Self {
        self.inner.max_diff_cu_qp_delta_depth = max_diff_cu_qp_delta_depth;
        self
    }
    #[inline]
    pub fn min_max_num_merge_cand(mut self, min_max_num_merge_cand: u32) -> Self {
        self.inner.min_max_num_merge_cand = min_max_num_merge_cand;
        self
    }
    #[inline]
    pub fn max_max_num_merge_cand(mut self, max_max_num_merge_cand: u32) -> Self {
        self.inner.max_max_num_merge_cand = max_max_num_merge_cand;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeH265CapabilitiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH265SessionParametersAddInfoEXT.html>"]
pub struct VideoEncodeH265SessionParametersAddInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub std_vps_count: u32,
    pub p_std_vp_ss: *const StdVideoH265VideoParameterSet,
    pub std_sps_count: u32,
    pub p_std_sp_ss: *const StdVideoH265SequenceParameterSet,
    pub std_pps_count: u32,
    pub p_std_pp_ss: *const StdVideoH265PictureParameterSet,
}
impl ::std::default::Default for VideoEncodeH265SessionParametersAddInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            std_vps_count: u32::default(),
            p_std_vp_ss: ::std::ptr::null(),
            std_sps_count: u32::default(),
            p_std_sp_ss: ::std::ptr::null(),
            std_pps_count: u32::default(),
            p_std_pp_ss: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for VideoEncodeH265SessionParametersAddInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT;
}
impl VideoEncodeH265SessionParametersAddInfoEXT {
    pub fn builder<'a>() -> VideoEncodeH265SessionParametersAddInfoEXTBuilder<'a> {
        VideoEncodeH265SessionParametersAddInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeH265SessionParametersAddInfoEXTBuilder<'a> {
    inner: VideoEncodeH265SessionParametersAddInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoSessionParametersUpdateInfoKHR
    for VideoEncodeH265SessionParametersAddInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsVideoSessionParametersUpdateInfoKHR
    for VideoEncodeH265SessionParametersAddInfoEXT
{
}
impl<'a> ::std::ops::Deref for VideoEncodeH265SessionParametersAddInfoEXTBuilder<'a> {
    type Target = VideoEncodeH265SessionParametersAddInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeH265SessionParametersAddInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeH265SessionParametersAddInfoEXTBuilder<'a> {
    #[inline]
    pub fn std_vp_ss(mut self, std_vp_ss: &'a [StdVideoH265VideoParameterSet]) -> Self {
        self.inner.std_vps_count = std_vp_ss.len() as _;
        self.inner.p_std_vp_ss = std_vp_ss.as_ptr();
        self
    }
    #[inline]
    pub fn std_sp_ss(mut self, std_sp_ss: &'a [StdVideoH265SequenceParameterSet]) -> Self {
        self.inner.std_sps_count = std_sp_ss.len() as _;
        self.inner.p_std_sp_ss = std_sp_ss.as_ptr();
        self
    }
    #[inline]
    pub fn std_pp_ss(mut self, std_pp_ss: &'a [StdVideoH265PictureParameterSet]) -> Self {
        self.inner.std_pps_count = std_pp_ss.len() as _;
        self.inner.p_std_pp_ss = std_pp_ss.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeH265SessionParametersAddInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH265SessionParametersCreateInfoEXT.html>"]
pub struct VideoEncodeH265SessionParametersCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub max_std_vps_count: u32,
    pub max_std_sps_count: u32,
    pub max_std_pps_count: u32,
    pub p_parameters_add_info: *const VideoEncodeH265SessionParametersAddInfoEXT,
}
impl ::std::default::Default for VideoEncodeH265SessionParametersCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            max_std_vps_count: u32::default(),
            max_std_sps_count: u32::default(),
            max_std_pps_count: u32::default(),
            p_parameters_add_info: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for VideoEncodeH265SessionParametersCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT;
}
impl VideoEncodeH265SessionParametersCreateInfoEXT {
    pub fn builder<'a>() -> VideoEncodeH265SessionParametersCreateInfoEXTBuilder<'a> {
        VideoEncodeH265SessionParametersCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeH265SessionParametersCreateInfoEXTBuilder<'a> {
    inner: VideoEncodeH265SessionParametersCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoSessionParametersCreateInfoKHR
    for VideoEncodeH265SessionParametersCreateInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsVideoSessionParametersCreateInfoKHR
    for VideoEncodeH265SessionParametersCreateInfoEXT
{
}
impl<'a> ::std::ops::Deref for VideoEncodeH265SessionParametersCreateInfoEXTBuilder<'a> {
    type Target = VideoEncodeH265SessionParametersCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeH265SessionParametersCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeH265SessionParametersCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn max_std_vps_count(mut self, max_std_vps_count: u32) -> Self {
        self.inner.max_std_vps_count = max_std_vps_count;
        self
    }
    #[inline]
    pub fn max_std_sps_count(mut self, max_std_sps_count: u32) -> Self {
        self.inner.max_std_sps_count = max_std_sps_count;
        self
    }
    #[inline]
    pub fn max_std_pps_count(mut self, max_std_pps_count: u32) -> Self {
        self.inner.max_std_pps_count = max_std_pps_count;
        self
    }
    #[inline]
    pub fn parameters_add_info(
        mut self,
        parameters_add_info: &'a VideoEncodeH265SessionParametersAddInfoEXT,
    ) -> Self {
        self.inner.p_parameters_add_info = parameters_add_info;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeH265SessionParametersCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH265VclFrameInfoEXT.html>"]
pub struct VideoEncodeH265VclFrameInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_std_reference_final_lists: *const StdVideoEncodeH265ReferenceListsInfo,
    pub nalu_slice_segment_entry_count: u32,
    pub p_nalu_slice_segment_entries: *const VideoEncodeH265NaluSliceSegmentInfoEXT,
    pub p_std_picture_info: *const StdVideoEncodeH265PictureInfo,
}
impl ::std::default::Default for VideoEncodeH265VclFrameInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_std_reference_final_lists: ::std::ptr::null(),
            nalu_slice_segment_entry_count: u32::default(),
            p_nalu_slice_segment_entries: ::std::ptr::null(),
            p_std_picture_info: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for VideoEncodeH265VclFrameInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H265_VCL_FRAME_INFO_EXT;
}
impl VideoEncodeH265VclFrameInfoEXT {
    pub fn builder<'a>() -> VideoEncodeH265VclFrameInfoEXTBuilder<'a> {
        VideoEncodeH265VclFrameInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeH265VclFrameInfoEXTBuilder<'a> {
    inner: VideoEncodeH265VclFrameInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoEncodeInfoKHR for VideoEncodeH265VclFrameInfoEXTBuilder<'_> {}
unsafe impl ExtendsVideoEncodeInfoKHR for VideoEncodeH265VclFrameInfoEXT {}
impl<'a> ::std::ops::Deref for VideoEncodeH265VclFrameInfoEXTBuilder<'a> {
    type Target = VideoEncodeH265VclFrameInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeH265VclFrameInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeH265VclFrameInfoEXTBuilder<'a> {
    #[inline]
    pub fn std_reference_final_lists(
        mut self,
        std_reference_final_lists: &'a StdVideoEncodeH265ReferenceListsInfo,
    ) -> Self {
        self.inner.p_std_reference_final_lists = std_reference_final_lists;
        self
    }
    #[inline]
    pub fn nalu_slice_segment_entries(
        mut self,
        nalu_slice_segment_entries: &'a [VideoEncodeH265NaluSliceSegmentInfoEXT],
    ) -> Self {
        self.inner.nalu_slice_segment_entry_count = nalu_slice_segment_entries.len() as _;
        self.inner.p_nalu_slice_segment_entries = nalu_slice_segment_entries.as_ptr();
        self
    }
    #[inline]
    pub fn std_picture_info(mut self, std_picture_info: &'a StdVideoEncodeH265PictureInfo) -> Self {
        self.inner.p_std_picture_info = std_picture_info;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeH265VclFrameInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH265NaluSliceSegmentInfoEXT.html>"]
pub struct VideoEncodeH265NaluSliceSegmentInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ctb_count: u32,
    pub p_std_reference_final_lists: *const StdVideoEncodeH265ReferenceListsInfo,
    pub p_std_slice_segment_header: *const StdVideoEncodeH265SliceSegmentHeader,
}
impl ::std::default::Default for VideoEncodeH265NaluSliceSegmentInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            ctb_count: u32::default(),
            p_std_reference_final_lists: ::std::ptr::null(),
            p_std_slice_segment_header: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for VideoEncodeH265NaluSliceSegmentInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_EXT;
}
impl VideoEncodeH265NaluSliceSegmentInfoEXT {
    pub fn builder<'a>() -> VideoEncodeH265NaluSliceSegmentInfoEXTBuilder<'a> {
        VideoEncodeH265NaluSliceSegmentInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeH265NaluSliceSegmentInfoEXTBuilder<'a> {
    inner: VideoEncodeH265NaluSliceSegmentInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for VideoEncodeH265NaluSliceSegmentInfoEXTBuilder<'a> {
    type Target = VideoEncodeH265NaluSliceSegmentInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeH265NaluSliceSegmentInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeH265NaluSliceSegmentInfoEXTBuilder<'a> {
    #[inline]
    pub fn ctb_count(mut self, ctb_count: u32) -> Self {
        self.inner.ctb_count = ctb_count;
        self
    }
    #[inline]
    pub fn std_reference_final_lists(
        mut self,
        std_reference_final_lists: &'a StdVideoEncodeH265ReferenceListsInfo,
    ) -> Self {
        self.inner.p_std_reference_final_lists = std_reference_final_lists;
        self
    }
    #[inline]
    pub fn std_slice_segment_header(
        mut self,
        std_slice_segment_header: &'a StdVideoEncodeH265SliceSegmentHeader,
    ) -> Self {
        self.inner.p_std_slice_segment_header = std_slice_segment_header;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeH265NaluSliceSegmentInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH265RateControlInfoEXT.html>"]
pub struct VideoEncodeH265RateControlInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub gop_frame_count: u32,
    pub idr_period: u32,
    pub consecutive_b_frame_count: u32,
    pub rate_control_structure: VideoEncodeH265RateControlStructureEXT,
    pub sub_layer_count: u32,
}
impl ::std::default::Default for VideoEncodeH265RateControlInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            gop_frame_count: u32::default(),
            idr_period: u32::default(),
            consecutive_b_frame_count: u32::default(),
            rate_control_structure: VideoEncodeH265RateControlStructureEXT::default(),
            sub_layer_count: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoEncodeH265RateControlInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H265_RATE_CONTROL_INFO_EXT;
}
impl VideoEncodeH265RateControlInfoEXT {
    pub fn builder<'a>() -> VideoEncodeH265RateControlInfoEXTBuilder<'a> {
        VideoEncodeH265RateControlInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeH265RateControlInfoEXTBuilder<'a> {
    inner: VideoEncodeH265RateControlInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoCodingControlInfoKHR for VideoEncodeH265RateControlInfoEXTBuilder<'_> {}
unsafe impl ExtendsVideoCodingControlInfoKHR for VideoEncodeH265RateControlInfoEXT {}
impl<'a> ::std::ops::Deref for VideoEncodeH265RateControlInfoEXTBuilder<'a> {
    type Target = VideoEncodeH265RateControlInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeH265RateControlInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeH265RateControlInfoEXTBuilder<'a> {
    #[inline]
    pub fn gop_frame_count(mut self, gop_frame_count: u32) -> Self {
        self.inner.gop_frame_count = gop_frame_count;
        self
    }
    #[inline]
    pub fn idr_period(mut self, idr_period: u32) -> Self {
        self.inner.idr_period = idr_period;
        self
    }
    #[inline]
    pub fn consecutive_b_frame_count(mut self, consecutive_b_frame_count: u32) -> Self {
        self.inner.consecutive_b_frame_count = consecutive_b_frame_count;
        self
    }
    #[inline]
    pub fn rate_control_structure(
        mut self,
        rate_control_structure: VideoEncodeH265RateControlStructureEXT,
    ) -> Self {
        self.inner.rate_control_structure = rate_control_structure;
        self
    }
    #[inline]
    pub fn sub_layer_count(mut self, sub_layer_count: u32) -> Self {
        self.inner.sub_layer_count = sub_layer_count;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeH265RateControlInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH265QpEXT.html>"]
pub struct VideoEncodeH265QpEXT {
    pub qp_i: i32,
    pub qp_p: i32,
    pub qp_b: i32,
}
impl VideoEncodeH265QpEXT {
    pub fn builder<'a>() -> VideoEncodeH265QpEXTBuilder<'a> {
        VideoEncodeH265QpEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeH265QpEXTBuilder<'a> {
    inner: VideoEncodeH265QpEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for VideoEncodeH265QpEXTBuilder<'a> {
    type Target = VideoEncodeH265QpEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeH265QpEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeH265QpEXTBuilder<'a> {
    #[inline]
    pub fn qp_i(mut self, qp_i: i32) -> Self {
        self.inner.qp_i = qp_i;
        self
    }
    #[inline]
    pub fn qp_p(mut self, qp_p: i32) -> Self {
        self.inner.qp_p = qp_p;
        self
    }
    #[inline]
    pub fn qp_b(mut self, qp_b: i32) -> Self {
        self.inner.qp_b = qp_b;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeH265QpEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH265FrameSizeEXT.html>"]
pub struct VideoEncodeH265FrameSizeEXT {
    pub frame_i_size: u32,
    pub frame_p_size: u32,
    pub frame_b_size: u32,
}
impl VideoEncodeH265FrameSizeEXT {
    pub fn builder<'a>() -> VideoEncodeH265FrameSizeEXTBuilder<'a> {
        VideoEncodeH265FrameSizeEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeH265FrameSizeEXTBuilder<'a> {
    inner: VideoEncodeH265FrameSizeEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for VideoEncodeH265FrameSizeEXTBuilder<'a> {
    type Target = VideoEncodeH265FrameSizeEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeH265FrameSizeEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeH265FrameSizeEXTBuilder<'a> {
    #[inline]
    pub fn frame_i_size(mut self, frame_i_size: u32) -> Self {
        self.inner.frame_i_size = frame_i_size;
        self
    }
    #[inline]
    pub fn frame_p_size(mut self, frame_p_size: u32) -> Self {
        self.inner.frame_p_size = frame_p_size;
        self
    }
    #[inline]
    pub fn frame_b_size(mut self, frame_b_size: u32) -> Self {
        self.inner.frame_b_size = frame_b_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeH265FrameSizeEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH265RateControlLayerInfoEXT.html>"]
pub struct VideoEncodeH265RateControlLayerInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub temporal_id: u32,
    pub use_initial_rc_qp: Bool32,
    pub initial_rc_qp: VideoEncodeH265QpEXT,
    pub use_min_qp: Bool32,
    pub min_qp: VideoEncodeH265QpEXT,
    pub use_max_qp: Bool32,
    pub max_qp: VideoEncodeH265QpEXT,
    pub use_max_frame_size: Bool32,
    pub max_frame_size: VideoEncodeH265FrameSizeEXT,
}
impl ::std::default::Default for VideoEncodeH265RateControlLayerInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            temporal_id: u32::default(),
            use_initial_rc_qp: Bool32::default(),
            initial_rc_qp: VideoEncodeH265QpEXT::default(),
            use_min_qp: Bool32::default(),
            min_qp: VideoEncodeH265QpEXT::default(),
            use_max_qp: Bool32::default(),
            max_qp: VideoEncodeH265QpEXT::default(),
            use_max_frame_size: Bool32::default(),
            max_frame_size: VideoEncodeH265FrameSizeEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoEncodeH265RateControlLayerInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_EXT;
}
impl VideoEncodeH265RateControlLayerInfoEXT {
    pub fn builder<'a>() -> VideoEncodeH265RateControlLayerInfoEXTBuilder<'a> {
        VideoEncodeH265RateControlLayerInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeH265RateControlLayerInfoEXTBuilder<'a> {
    inner: VideoEncodeH265RateControlLayerInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoCodingControlInfoKHR for VideoEncodeH265RateControlLayerInfoEXTBuilder<'_> {}
unsafe impl ExtendsVideoCodingControlInfoKHR for VideoEncodeH265RateControlLayerInfoEXT {}
unsafe impl ExtendsVideoEncodeRateControlLayerInfoKHR
    for VideoEncodeH265RateControlLayerInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsVideoEncodeRateControlLayerInfoKHR for VideoEncodeH265RateControlLayerInfoEXT {}
impl<'a> ::std::ops::Deref for VideoEncodeH265RateControlLayerInfoEXTBuilder<'a> {
    type Target = VideoEncodeH265RateControlLayerInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeH265RateControlLayerInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeH265RateControlLayerInfoEXTBuilder<'a> {
    #[inline]
    pub fn temporal_id(mut self, temporal_id: u32) -> Self {
        self.inner.temporal_id = temporal_id;
        self
    }
    #[inline]
    pub fn use_initial_rc_qp(mut self, use_initial_rc_qp: bool) -> Self {
        self.inner.use_initial_rc_qp = use_initial_rc_qp.into();
        self
    }
    #[inline]
    pub fn initial_rc_qp(mut self, initial_rc_qp: VideoEncodeH265QpEXT) -> Self {
        self.inner.initial_rc_qp = initial_rc_qp;
        self
    }
    #[inline]
    pub fn use_min_qp(mut self, use_min_qp: bool) -> Self {
        self.inner.use_min_qp = use_min_qp.into();
        self
    }
    #[inline]
    pub fn min_qp(mut self, min_qp: VideoEncodeH265QpEXT) -> Self {
        self.inner.min_qp = min_qp;
        self
    }
    #[inline]
    pub fn use_max_qp(mut self, use_max_qp: bool) -> Self {
        self.inner.use_max_qp = use_max_qp.into();
        self
    }
    #[inline]
    pub fn max_qp(mut self, max_qp: VideoEncodeH265QpEXT) -> Self {
        self.inner.max_qp = max_qp;
        self
    }
    #[inline]
    pub fn use_max_frame_size(mut self, use_max_frame_size: bool) -> Self {
        self.inner.use_max_frame_size = use_max_frame_size.into();
        self
    }
    #[inline]
    pub fn max_frame_size(mut self, max_frame_size: VideoEncodeH265FrameSizeEXT) -> Self {
        self.inner.max_frame_size = max_frame_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeH265RateControlLayerInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH265ProfileInfoEXT.html>"]
pub struct VideoEncodeH265ProfileInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub std_profile_idc: StdVideoH265ProfileIdc,
}
impl ::std::default::Default for VideoEncodeH265ProfileInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            std_profile_idc: StdVideoH265ProfileIdc::default(),
        }
    }
}
unsafe impl TaggedStructure for VideoEncodeH265ProfileInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H265_PROFILE_INFO_EXT;
}
impl VideoEncodeH265ProfileInfoEXT {
    pub fn builder<'a>() -> VideoEncodeH265ProfileInfoEXTBuilder<'a> {
        VideoEncodeH265ProfileInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeH265ProfileInfoEXTBuilder<'a> {
    inner: VideoEncodeH265ProfileInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoProfileInfoKHR for VideoEncodeH265ProfileInfoEXTBuilder<'_> {}
unsafe impl ExtendsVideoProfileInfoKHR for VideoEncodeH265ProfileInfoEXT {}
unsafe impl ExtendsQueryPoolCreateInfo for VideoEncodeH265ProfileInfoEXTBuilder<'_> {}
unsafe impl ExtendsQueryPoolCreateInfo for VideoEncodeH265ProfileInfoEXT {}
impl<'a> ::std::ops::Deref for VideoEncodeH265ProfileInfoEXTBuilder<'a> {
    type Target = VideoEncodeH265ProfileInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeH265ProfileInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeH265ProfileInfoEXTBuilder<'a> {
    #[inline]
    pub fn std_profile_idc(mut self, std_profile_idc: StdVideoH265ProfileIdc) -> Self {
        self.inner.std_profile_idc = std_profile_idc;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeH265ProfileInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVideoEncodeH265DpbSlotInfoEXT.html>"]
pub struct VideoEncodeH265DpbSlotInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_std_reference_info: *const StdVideoEncodeH265ReferenceInfo,
}
impl ::std::default::Default for VideoEncodeH265DpbSlotInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_std_reference_info: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for VideoEncodeH265DpbSlotInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT;
}
impl VideoEncodeH265DpbSlotInfoEXT {
    pub fn builder<'a>() -> VideoEncodeH265DpbSlotInfoEXTBuilder<'a> {
        VideoEncodeH265DpbSlotInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct VideoEncodeH265DpbSlotInfoEXTBuilder<'a> {
    inner: VideoEncodeH265DpbSlotInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsVideoReferenceSlotInfoKHR for VideoEncodeH265DpbSlotInfoEXTBuilder<'_> {}
unsafe impl ExtendsVideoReferenceSlotInfoKHR for VideoEncodeH265DpbSlotInfoEXT {}
impl<'a> ::std::ops::Deref for VideoEncodeH265DpbSlotInfoEXTBuilder<'a> {
    type Target = VideoEncodeH265DpbSlotInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for VideoEncodeH265DpbSlotInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> VideoEncodeH265DpbSlotInfoEXTBuilder<'a> {
    #[inline]
    pub fn std_reference_info(
        mut self,
        std_reference_info: &'a StdVideoEncodeH265ReferenceInfo,
    ) -> Self {
        self.inner.p_std_reference_info = std_reference_info;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> VideoEncodeH265DpbSlotInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceInheritedViewportScissorFeaturesNV.html>"]
pub struct PhysicalDeviceInheritedViewportScissorFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub inherited_viewport_scissor2_d: Bool32,
}
impl ::std::default::Default for PhysicalDeviceInheritedViewportScissorFeaturesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            inherited_viewport_scissor2_d: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceInheritedViewportScissorFeaturesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV;
}
impl PhysicalDeviceInheritedViewportScissorFeaturesNV {
    pub fn builder<'a>() -> PhysicalDeviceInheritedViewportScissorFeaturesNVBuilder<'a> {
        PhysicalDeviceInheritedViewportScissorFeaturesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceInheritedViewportScissorFeaturesNVBuilder<'a> {
    inner: PhysicalDeviceInheritedViewportScissorFeaturesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceInheritedViewportScissorFeaturesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceInheritedViewportScissorFeaturesNV {}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceInheritedViewportScissorFeaturesNVBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceInheritedViewportScissorFeaturesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceInheritedViewportScissorFeaturesNVBuilder<'a> {
    type Target = PhysicalDeviceInheritedViewportScissorFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceInheritedViewportScissorFeaturesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceInheritedViewportScissorFeaturesNVBuilder<'a> {
    #[inline]
    pub fn inherited_viewport_scissor2_d(mut self, inherited_viewport_scissor2_d: bool) -> Self {
        self.inner.inherited_viewport_scissor2_d = inherited_viewport_scissor2_d.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceInheritedViewportScissorFeaturesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceViewportScissorInfoNV.html>"]
pub struct CommandBufferInheritanceViewportScissorInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub viewport_scissor2_d: Bool32,
    pub viewport_depth_count: u32,
    pub p_viewport_depths: *const Viewport,
}
impl ::std::default::Default for CommandBufferInheritanceViewportScissorInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            viewport_scissor2_d: Bool32::default(),
            viewport_depth_count: u32::default(),
            p_viewport_depths: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for CommandBufferInheritanceViewportScissorInfoNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV;
}
impl CommandBufferInheritanceViewportScissorInfoNV {
    pub fn builder<'a>() -> CommandBufferInheritanceViewportScissorInfoNVBuilder<'a> {
        CommandBufferInheritanceViewportScissorInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CommandBufferInheritanceViewportScissorInfoNVBuilder<'a> {
    inner: CommandBufferInheritanceViewportScissorInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsCommandBufferInheritanceInfo
    for CommandBufferInheritanceViewportScissorInfoNVBuilder<'_>
{
}
unsafe impl ExtendsCommandBufferInheritanceInfo for CommandBufferInheritanceViewportScissorInfoNV {}
impl<'a> ::std::ops::Deref for CommandBufferInheritanceViewportScissorInfoNVBuilder<'a> {
    type Target = CommandBufferInheritanceViewportScissorInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CommandBufferInheritanceViewportScissorInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CommandBufferInheritanceViewportScissorInfoNVBuilder<'a> {
    #[inline]
    pub fn viewport_scissor2_d(mut self, viewport_scissor2_d: bool) -> Self {
        self.inner.viewport_scissor2_d = viewport_scissor2_d.into();
        self
    }
    #[inline]
    pub fn viewport_depth_count(mut self, viewport_depth_count: u32) -> Self {
        self.inner.viewport_depth_count = viewport_depth_count;
        self
    }
    #[inline]
    pub fn viewport_depths(mut self, viewport_depths: &'a Viewport) -> Self {
        self.inner.p_viewport_depths = viewport_depths;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CommandBufferInheritanceViewportScissorInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT.html>"]
pub struct PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ycbcr2plane444_formats: Bool32,
}
impl ::std::default::Default for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            ycbcr2plane444_formats: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT;
}
impl PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTBuilder<'a> {
        PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn ycbcr2plane444_formats(mut self, ycbcr2plane444_formats: bool) -> Self {
        self.inner.ycbcr2plane444_formats = ycbcr2plane444_formats.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProvokingVertexFeaturesEXT.html>"]
pub struct PhysicalDeviceProvokingVertexFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub provoking_vertex_last: Bool32,
    pub transform_feedback_preserves_provoking_vertex: Bool32,
}
impl ::std::default::Default for PhysicalDeviceProvokingVertexFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            provoking_vertex_last: Bool32::default(),
            transform_feedback_preserves_provoking_vertex: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceProvokingVertexFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT;
}
impl PhysicalDeviceProvokingVertexFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceProvokingVertexFeaturesEXTBuilder<'a> {
        PhysicalDeviceProvokingVertexFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceProvokingVertexFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceProvokingVertexFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceProvokingVertexFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceProvokingVertexFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceProvokingVertexFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceProvokingVertexFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceProvokingVertexFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceProvokingVertexFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceProvokingVertexFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceProvokingVertexFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn provoking_vertex_last(mut self, provoking_vertex_last: bool) -> Self {
        self.inner.provoking_vertex_last = provoking_vertex_last.into();
        self
    }
    #[inline]
    pub fn transform_feedback_preserves_provoking_vertex(
        mut self,
        transform_feedback_preserves_provoking_vertex: bool,
    ) -> Self {
        self.inner.transform_feedback_preserves_provoking_vertex =
            transform_feedback_preserves_provoking_vertex.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceProvokingVertexFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProvokingVertexPropertiesEXT.html>"]
pub struct PhysicalDeviceProvokingVertexPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub provoking_vertex_mode_per_pipeline: Bool32,
    pub transform_feedback_preserves_triangle_fan_provoking_vertex: Bool32,
}
impl ::std::default::Default for PhysicalDeviceProvokingVertexPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            provoking_vertex_mode_per_pipeline: Bool32::default(),
            transform_feedback_preserves_triangle_fan_provoking_vertex: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceProvokingVertexPropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT;
}
impl PhysicalDeviceProvokingVertexPropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceProvokingVertexPropertiesEXTBuilder<'a> {
        PhysicalDeviceProvokingVertexPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceProvokingVertexPropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceProvokingVertexPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceProvokingVertexPropertiesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceProvokingVertexPropertiesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceProvokingVertexPropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceProvokingVertexPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceProvokingVertexPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceProvokingVertexPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn provoking_vertex_mode_per_pipeline(
        mut self,
        provoking_vertex_mode_per_pipeline: bool,
    ) -> Self {
        self.inner.provoking_vertex_mode_per_pipeline = provoking_vertex_mode_per_pipeline.into();
        self
    }
    #[inline]
    pub fn transform_feedback_preserves_triangle_fan_provoking_vertex(
        mut self,
        transform_feedback_preserves_triangle_fan_provoking_vertex: bool,
    ) -> Self {
        self.inner
            .transform_feedback_preserves_triangle_fan_provoking_vertex =
            transform_feedback_preserves_triangle_fan_provoking_vertex.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceProvokingVertexPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationProvokingVertexStateCreateInfoEXT.html>"]
pub struct PipelineRasterizationProvokingVertexStateCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub provoking_vertex_mode: ProvokingVertexModeEXT,
}
impl ::std::default::Default for PipelineRasterizationProvokingVertexStateCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            provoking_vertex_mode: ProvokingVertexModeEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineRasterizationProvokingVertexStateCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT;
}
impl PipelineRasterizationProvokingVertexStateCreateInfoEXT {
    pub fn builder<'a>() -> PipelineRasterizationProvokingVertexStateCreateInfoEXTBuilder<'a> {
        PipelineRasterizationProvokingVertexStateCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineRasterizationProvokingVertexStateCreateInfoEXTBuilder<'a> {
    inner: PipelineRasterizationProvokingVertexStateCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPipelineRasterizationStateCreateInfo
    for PipelineRasterizationProvokingVertexStateCreateInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsPipelineRasterizationStateCreateInfo
    for PipelineRasterizationProvokingVertexStateCreateInfoEXT
{
}
impl<'a> ::std::ops::Deref for PipelineRasterizationProvokingVertexStateCreateInfoEXTBuilder<'a> {
    type Target = PipelineRasterizationProvokingVertexStateCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut
    for PipelineRasterizationProvokingVertexStateCreateInfoEXTBuilder<'a>
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineRasterizationProvokingVertexStateCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn provoking_vertex_mode(mut self, provoking_vertex_mode: ProvokingVertexModeEXT) -> Self {
        self.inner.provoking_vertex_mode = provoking_vertex_mode;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineRasterizationProvokingVertexStateCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCuModuleCreateInfoNVX.html>"]
pub struct CuModuleCreateInfoNVX {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub data_size: usize,
    pub p_data: *const c_void,
}
impl ::std::default::Default for CuModuleCreateInfoNVX {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            data_size: usize::default(),
            p_data: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for CuModuleCreateInfoNVX {
    const STRUCTURE_TYPE: StructureType = StructureType::CU_MODULE_CREATE_INFO_NVX;
}
impl CuModuleCreateInfoNVX {
    pub fn builder<'a>() -> CuModuleCreateInfoNVXBuilder<'a> {
        CuModuleCreateInfoNVXBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CuModuleCreateInfoNVXBuilder<'a> {
    inner: CuModuleCreateInfoNVX,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CuModuleCreateInfoNVXBuilder<'a> {
    type Target = CuModuleCreateInfoNVX;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CuModuleCreateInfoNVXBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CuModuleCreateInfoNVXBuilder<'a> {
    #[inline]
    pub fn data(mut self, data: &'a [u8]) -> Self {
        self.inner.data_size = data.len();
        self.inner.p_data = data.as_ptr().cast();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CuModuleCreateInfoNVX {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCuFunctionCreateInfoNVX.html>"]
pub struct CuFunctionCreateInfoNVX {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub module: CuModuleNVX,
    pub p_name: *const c_char,
}
impl ::std::default::Default for CuFunctionCreateInfoNVX {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            module: CuModuleNVX::default(),
            p_name: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for CuFunctionCreateInfoNVX {
    const STRUCTURE_TYPE: StructureType = StructureType::CU_FUNCTION_CREATE_INFO_NVX;
}
impl CuFunctionCreateInfoNVX {
    pub fn builder<'a>() -> CuFunctionCreateInfoNVXBuilder<'a> {
        CuFunctionCreateInfoNVXBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CuFunctionCreateInfoNVXBuilder<'a> {
    inner: CuFunctionCreateInfoNVX,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CuFunctionCreateInfoNVXBuilder<'a> {
    type Target = CuFunctionCreateInfoNVX;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CuFunctionCreateInfoNVXBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CuFunctionCreateInfoNVXBuilder<'a> {
    #[inline]
    pub fn module(mut self, module: CuModuleNVX) -> Self {
        self.inner.module = module;
        self
    }
    #[inline]
    pub fn name(mut self, name: &'a ::std::ffi::CStr) -> Self {
        self.inner.p_name = name.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CuFunctionCreateInfoNVX {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCuLaunchInfoNVX.html>"]
pub struct CuLaunchInfoNVX {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub function: CuFunctionNVX,
    pub grid_dim_x: u32,
    pub grid_dim_y: u32,
    pub grid_dim_z: u32,
    pub block_dim_x: u32,
    pub block_dim_y: u32,
    pub block_dim_z: u32,
    pub shared_mem_bytes: u32,
    pub param_count: usize,
    pub p_params: *const *const c_void,
    pub extra_count: usize,
    pub p_extras: *const *const c_void,
}
impl ::std::default::Default for CuLaunchInfoNVX {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            function: CuFunctionNVX::default(),
            grid_dim_x: u32::default(),
            grid_dim_y: u32::default(),
            grid_dim_z: u32::default(),
            block_dim_x: u32::default(),
            block_dim_y: u32::default(),
            block_dim_z: u32::default(),
            shared_mem_bytes: u32::default(),
            param_count: usize::default(),
            p_params: ::std::ptr::null(),
            extra_count: usize::default(),
            p_extras: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for CuLaunchInfoNVX {
    const STRUCTURE_TYPE: StructureType = StructureType::CU_LAUNCH_INFO_NVX;
}
impl CuLaunchInfoNVX {
    pub fn builder<'a>() -> CuLaunchInfoNVXBuilder<'a> {
        CuLaunchInfoNVXBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CuLaunchInfoNVXBuilder<'a> {
    inner: CuLaunchInfoNVX,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CuLaunchInfoNVXBuilder<'a> {
    type Target = CuLaunchInfoNVX;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CuLaunchInfoNVXBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CuLaunchInfoNVXBuilder<'a> {
    #[inline]
    pub fn function(mut self, function: CuFunctionNVX) -> Self {
        self.inner.function = function;
        self
    }
    #[inline]
    pub fn grid_dim_x(mut self, grid_dim_x: u32) -> Self {
        self.inner.grid_dim_x = grid_dim_x;
        self
    }
    #[inline]
    pub fn grid_dim_y(mut self, grid_dim_y: u32) -> Self {
        self.inner.grid_dim_y = grid_dim_y;
        self
    }
    #[inline]
    pub fn grid_dim_z(mut self, grid_dim_z: u32) -> Self {
        self.inner.grid_dim_z = grid_dim_z;
        self
    }
    #[inline]
    pub fn block_dim_x(mut self, block_dim_x: u32) -> Self {
        self.inner.block_dim_x = block_dim_x;
        self
    }
    #[inline]
    pub fn block_dim_y(mut self, block_dim_y: u32) -> Self {
        self.inner.block_dim_y = block_dim_y;
        self
    }
    #[inline]
    pub fn block_dim_z(mut self, block_dim_z: u32) -> Self {
        self.inner.block_dim_z = block_dim_z;
        self
    }
    #[inline]
    pub fn shared_mem_bytes(mut self, shared_mem_bytes: u32) -> Self {
        self.inner.shared_mem_bytes = shared_mem_bytes;
        self
    }
    #[inline]
    pub fn params(mut self, params: &'a [*const c_void]) -> Self {
        self.inner.param_count = params.len();
        self.inner.p_params = params.as_ptr();
        self
    }
    #[inline]
    pub fn extras(mut self, extras: &'a [*const c_void]) -> Self {
        self.inner.extra_count = extras.len();
        self.inner.p_extras = extras.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CuLaunchInfoNVX {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorBufferFeaturesEXT.html>"]
pub struct PhysicalDeviceDescriptorBufferFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub descriptor_buffer: Bool32,
    pub descriptor_buffer_capture_replay: Bool32,
    pub descriptor_buffer_image_layout_ignored: Bool32,
    pub descriptor_buffer_push_descriptors: Bool32,
}
impl ::std::default::Default for PhysicalDeviceDescriptorBufferFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            descriptor_buffer: Bool32::default(),
            descriptor_buffer_capture_replay: Bool32::default(),
            descriptor_buffer_image_layout_ignored: Bool32::default(),
            descriptor_buffer_push_descriptors: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceDescriptorBufferFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT;
}
impl PhysicalDeviceDescriptorBufferFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceDescriptorBufferFeaturesEXTBuilder<'a> {
        PhysicalDeviceDescriptorBufferFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceDescriptorBufferFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceDescriptorBufferFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceDescriptorBufferFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDescriptorBufferFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDescriptorBufferFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDescriptorBufferFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceDescriptorBufferFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceDescriptorBufferFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceDescriptorBufferFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceDescriptorBufferFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn descriptor_buffer(mut self, descriptor_buffer: bool) -> Self {
        self.inner.descriptor_buffer = descriptor_buffer.into();
        self
    }
    #[inline]
    pub fn descriptor_buffer_capture_replay(
        mut self,
        descriptor_buffer_capture_replay: bool,
    ) -> Self {
        self.inner.descriptor_buffer_capture_replay = descriptor_buffer_capture_replay.into();
        self
    }
    #[inline]
    pub fn descriptor_buffer_image_layout_ignored(
        mut self,
        descriptor_buffer_image_layout_ignored: bool,
    ) -> Self {
        self.inner.descriptor_buffer_image_layout_ignored =
            descriptor_buffer_image_layout_ignored.into();
        self
    }
    #[inline]
    pub fn descriptor_buffer_push_descriptors(
        mut self,
        descriptor_buffer_push_descriptors: bool,
    ) -> Self {
        self.inner.descriptor_buffer_push_descriptors = descriptor_buffer_push_descriptors.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceDescriptorBufferFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorBufferPropertiesEXT.html>"]
pub struct PhysicalDeviceDescriptorBufferPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub combined_image_sampler_descriptor_single_array: Bool32,
    pub bufferless_push_descriptors: Bool32,
    pub allow_sampler_image_view_post_submit_creation: Bool32,
    pub descriptor_buffer_offset_alignment: DeviceSize,
    pub max_descriptor_buffer_bindings: u32,
    pub max_resource_descriptor_buffer_bindings: u32,
    pub max_sampler_descriptor_buffer_bindings: u32,
    pub max_embedded_immutable_sampler_bindings: u32,
    pub max_embedded_immutable_samplers: u32,
    pub buffer_capture_replay_descriptor_data_size: usize,
    pub image_capture_replay_descriptor_data_size: usize,
    pub image_view_capture_replay_descriptor_data_size: usize,
    pub sampler_capture_replay_descriptor_data_size: usize,
    pub acceleration_structure_capture_replay_descriptor_data_size: usize,
    pub sampler_descriptor_size: usize,
    pub combined_image_sampler_descriptor_size: usize,
    pub sampled_image_descriptor_size: usize,
    pub storage_image_descriptor_size: usize,
    pub uniform_texel_buffer_descriptor_size: usize,
    pub robust_uniform_texel_buffer_descriptor_size: usize,
    pub storage_texel_buffer_descriptor_size: usize,
    pub robust_storage_texel_buffer_descriptor_size: usize,
    pub uniform_buffer_descriptor_size: usize,
    pub robust_uniform_buffer_descriptor_size: usize,
    pub storage_buffer_descriptor_size: usize,
    pub robust_storage_buffer_descriptor_size: usize,
    pub input_attachment_descriptor_size: usize,
    pub acceleration_structure_descriptor_size: usize,
    pub max_sampler_descriptor_buffer_range: DeviceSize,
    pub max_resource_descriptor_buffer_range: DeviceSize,
    pub sampler_descriptor_buffer_address_space_size: DeviceSize,
    pub resource_descriptor_buffer_address_space_size: DeviceSize,
    pub descriptor_buffer_address_space_size: DeviceSize,
}
impl ::std::default::Default for PhysicalDeviceDescriptorBufferPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            combined_image_sampler_descriptor_single_array: Bool32::default(),
            bufferless_push_descriptors: Bool32::default(),
            allow_sampler_image_view_post_submit_creation: Bool32::default(),
            descriptor_buffer_offset_alignment: DeviceSize::default(),
            max_descriptor_buffer_bindings: u32::default(),
            max_resource_descriptor_buffer_bindings: u32::default(),
            max_sampler_descriptor_buffer_bindings: u32::default(),
            max_embedded_immutable_sampler_bindings: u32::default(),
            max_embedded_immutable_samplers: u32::default(),
            buffer_capture_replay_descriptor_data_size: usize::default(),
            image_capture_replay_descriptor_data_size: usize::default(),
            image_view_capture_replay_descriptor_data_size: usize::default(),
            sampler_capture_replay_descriptor_data_size: usize::default(),
            acceleration_structure_capture_replay_descriptor_data_size: usize::default(),
            sampler_descriptor_size: usize::default(),
            combined_image_sampler_descriptor_size: usize::default(),
            sampled_image_descriptor_size: usize::default(),
            storage_image_descriptor_size: usize::default(),
            uniform_texel_buffer_descriptor_size: usize::default(),
            robust_uniform_texel_buffer_descriptor_size: usize::default(),
            storage_texel_buffer_descriptor_size: usize::default(),
            robust_storage_texel_buffer_descriptor_size: usize::default(),
            uniform_buffer_descriptor_size: usize::default(),
            robust_uniform_buffer_descriptor_size: usize::default(),
            storage_buffer_descriptor_size: usize::default(),
            robust_storage_buffer_descriptor_size: usize::default(),
            input_attachment_descriptor_size: usize::default(),
            acceleration_structure_descriptor_size: usize::default(),
            max_sampler_descriptor_buffer_range: DeviceSize::default(),
            max_resource_descriptor_buffer_range: DeviceSize::default(),
            sampler_descriptor_buffer_address_space_size: DeviceSize::default(),
            resource_descriptor_buffer_address_space_size: DeviceSize::default(),
            descriptor_buffer_address_space_size: DeviceSize::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceDescriptorBufferPropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT;
}
impl PhysicalDeviceDescriptorBufferPropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceDescriptorBufferPropertiesEXTBuilder<'a> {
        PhysicalDeviceDescriptorBufferPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceDescriptorBufferPropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceDescriptorBufferPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceDescriptorBufferPropertiesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceDescriptorBufferPropertiesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceDescriptorBufferPropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceDescriptorBufferPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceDescriptorBufferPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceDescriptorBufferPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn combined_image_sampler_descriptor_single_array(
        mut self,
        combined_image_sampler_descriptor_single_array: bool,
    ) -> Self {
        self.inner.combined_image_sampler_descriptor_single_array =
            combined_image_sampler_descriptor_single_array.into();
        self
    }
    #[inline]
    pub fn bufferless_push_descriptors(mut self, bufferless_push_descriptors: bool) -> Self {
        self.inner.bufferless_push_descriptors = bufferless_push_descriptors.into();
        self
    }
    #[inline]
    pub fn allow_sampler_image_view_post_submit_creation(
        mut self,
        allow_sampler_image_view_post_submit_creation: bool,
    ) -> Self {
        self.inner.allow_sampler_image_view_post_submit_creation =
            allow_sampler_image_view_post_submit_creation.into();
        self
    }
    #[inline]
    pub fn descriptor_buffer_offset_alignment(
        mut self,
        descriptor_buffer_offset_alignment: DeviceSize,
    ) -> Self {
        self.inner.descriptor_buffer_offset_alignment = descriptor_buffer_offset_alignment;
        self
    }
    #[inline]
    pub fn max_descriptor_buffer_bindings(mut self, max_descriptor_buffer_bindings: u32) -> Self {
        self.inner.max_descriptor_buffer_bindings = max_descriptor_buffer_bindings;
        self
    }
    #[inline]
    pub fn max_resource_descriptor_buffer_bindings(
        mut self,
        max_resource_descriptor_buffer_bindings: u32,
    ) -> Self {
        self.inner.max_resource_descriptor_buffer_bindings =
            max_resource_descriptor_buffer_bindings;
        self
    }
    #[inline]
    pub fn max_sampler_descriptor_buffer_bindings(
        mut self,
        max_sampler_descriptor_buffer_bindings: u32,
    ) -> Self {
        self.inner.max_sampler_descriptor_buffer_bindings = max_sampler_descriptor_buffer_bindings;
        self
    }
    #[inline]
    pub fn max_embedded_immutable_sampler_bindings(
        mut self,
        max_embedded_immutable_sampler_bindings: u32,
    ) -> Self {
        self.inner.max_embedded_immutable_sampler_bindings =
            max_embedded_immutable_sampler_bindings;
        self
    }
    #[inline]
    pub fn max_embedded_immutable_samplers(mut self, max_embedded_immutable_samplers: u32) -> Self {
        self.inner.max_embedded_immutable_samplers = max_embedded_immutable_samplers;
        self
    }
    #[inline]
    pub fn buffer_capture_replay_descriptor_data_size(
        mut self,
        buffer_capture_replay_descriptor_data_size: usize,
    ) -> Self {
        self.inner.buffer_capture_replay_descriptor_data_size =
            buffer_capture_replay_descriptor_data_size;
        self
    }
    #[inline]
    pub fn image_capture_replay_descriptor_data_size(
        mut self,
        image_capture_replay_descriptor_data_size: usize,
    ) -> Self {
        self.inner.image_capture_replay_descriptor_data_size =
            image_capture_replay_descriptor_data_size;
        self
    }
    #[inline]
    pub fn image_view_capture_replay_descriptor_data_size(
        mut self,
        image_view_capture_replay_descriptor_data_size: usize,
    ) -> Self {
        self.inner.image_view_capture_replay_descriptor_data_size =
            image_view_capture_replay_descriptor_data_size;
        self
    }
    #[inline]
    pub fn sampler_capture_replay_descriptor_data_size(
        mut self,
        sampler_capture_replay_descriptor_data_size: usize,
    ) -> Self {
        self.inner.sampler_capture_replay_descriptor_data_size =
            sampler_capture_replay_descriptor_data_size;
        self
    }
    #[inline]
    pub fn acceleration_structure_capture_replay_descriptor_data_size(
        mut self,
        acceleration_structure_capture_replay_descriptor_data_size: usize,
    ) -> Self {
        self.inner
            .acceleration_structure_capture_replay_descriptor_data_size =
            acceleration_structure_capture_replay_descriptor_data_size;
        self
    }
    #[inline]
    pub fn sampler_descriptor_size(mut self, sampler_descriptor_size: usize) -> Self {
        self.inner.sampler_descriptor_size = sampler_descriptor_size;
        self
    }
    #[inline]
    pub fn combined_image_sampler_descriptor_size(
        mut self,
        combined_image_sampler_descriptor_size: usize,
    ) -> Self {
        self.inner.combined_image_sampler_descriptor_size = combined_image_sampler_descriptor_size;
        self
    }
    #[inline]
    pub fn sampled_image_descriptor_size(mut self, sampled_image_descriptor_size: usize) -> Self {
        self.inner.sampled_image_descriptor_size = sampled_image_descriptor_size;
        self
    }
    #[inline]
    pub fn storage_image_descriptor_size(mut self, storage_image_descriptor_size: usize) -> Self {
        self.inner.storage_image_descriptor_size = storage_image_descriptor_size;
        self
    }
    #[inline]
    pub fn uniform_texel_buffer_descriptor_size(
        mut self,
        uniform_texel_buffer_descriptor_size: usize,
    ) -> Self {
        self.inner.uniform_texel_buffer_descriptor_size = uniform_texel_buffer_descriptor_size;
        self
    }
    #[inline]
    pub fn robust_uniform_texel_buffer_descriptor_size(
        mut self,
        robust_uniform_texel_buffer_descriptor_size: usize,
    ) -> Self {
        self.inner.robust_uniform_texel_buffer_descriptor_size =
            robust_uniform_texel_buffer_descriptor_size;
        self
    }
    #[inline]
    pub fn storage_texel_buffer_descriptor_size(
        mut self,
        storage_texel_buffer_descriptor_size: usize,
    ) -> Self {
        self.inner.storage_texel_buffer_descriptor_size = storage_texel_buffer_descriptor_size;
        self
    }
    #[inline]
    pub fn robust_storage_texel_buffer_descriptor_size(
        mut self,
        robust_storage_texel_buffer_descriptor_size: usize,
    ) -> Self {
        self.inner.robust_storage_texel_buffer_descriptor_size =
            robust_storage_texel_buffer_descriptor_size;
        self
    }
    #[inline]
    pub fn uniform_buffer_descriptor_size(mut self, uniform_buffer_descriptor_size: usize) -> Self {
        self.inner.uniform_buffer_descriptor_size = uniform_buffer_descriptor_size;
        self
    }
    #[inline]
    pub fn robust_uniform_buffer_descriptor_size(
        mut self,
        robust_uniform_buffer_descriptor_size: usize,
    ) -> Self {
        self.inner.robust_uniform_buffer_descriptor_size = robust_uniform_buffer_descriptor_size;
        self
    }
    #[inline]
    pub fn storage_buffer_descriptor_size(mut self, storage_buffer_descriptor_size: usize) -> Self {
        self.inner.storage_buffer_descriptor_size = storage_buffer_descriptor_size;
        self
    }
    #[inline]
    pub fn robust_storage_buffer_descriptor_size(
        mut self,
        robust_storage_buffer_descriptor_size: usize,
    ) -> Self {
        self.inner.robust_storage_buffer_descriptor_size = robust_storage_buffer_descriptor_size;
        self
    }
    #[inline]
    pub fn input_attachment_descriptor_size(
        mut self,
        input_attachment_descriptor_size: usize,
    ) -> Self {
        self.inner.input_attachment_descriptor_size = input_attachment_descriptor_size;
        self
    }
    #[inline]
    pub fn acceleration_structure_descriptor_size(
        mut self,
        acceleration_structure_descriptor_size: usize,
    ) -> Self {
        self.inner.acceleration_structure_descriptor_size = acceleration_structure_descriptor_size;
        self
    }
    #[inline]
    pub fn max_sampler_descriptor_buffer_range(
        mut self,
        max_sampler_descriptor_buffer_range: DeviceSize,
    ) -> Self {
        self.inner.max_sampler_descriptor_buffer_range = max_sampler_descriptor_buffer_range;
        self
    }
    #[inline]
    pub fn max_resource_descriptor_buffer_range(
        mut self,
        max_resource_descriptor_buffer_range: DeviceSize,
    ) -> Self {
        self.inner.max_resource_descriptor_buffer_range = max_resource_descriptor_buffer_range;
        self
    }
    #[inline]
    pub fn sampler_descriptor_buffer_address_space_size(
        mut self,
        sampler_descriptor_buffer_address_space_size: DeviceSize,
    ) -> Self {
        self.inner.sampler_descriptor_buffer_address_space_size =
            sampler_descriptor_buffer_address_space_size;
        self
    }
    #[inline]
    pub fn resource_descriptor_buffer_address_space_size(
        mut self,
        resource_descriptor_buffer_address_space_size: DeviceSize,
    ) -> Self {
        self.inner.resource_descriptor_buffer_address_space_size =
            resource_descriptor_buffer_address_space_size;
        self
    }
    #[inline]
    pub fn descriptor_buffer_address_space_size(
        mut self,
        descriptor_buffer_address_space_size: DeviceSize,
    ) -> Self {
        self.inner.descriptor_buffer_address_space_size = descriptor_buffer_address_space_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceDescriptorBufferPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT.html>"]
pub struct PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub combined_image_sampler_density_map_descriptor_size: usize,
}
impl ::std::default::Default for PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            combined_image_sampler_density_map_descriptor_size: usize::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT;
}
impl PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceDescriptorBufferDensityMapPropertiesEXTBuilder<'a> {
        PhysicalDeviceDescriptorBufferDensityMapPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceDescriptorBufferDensityMapPropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceDescriptorBufferDensityMapPropertiesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT
{
}
impl<'a> ::std::ops::Deref for PhysicalDeviceDescriptorBufferDensityMapPropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceDescriptorBufferDensityMapPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceDescriptorBufferDensityMapPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn combined_image_sampler_density_map_descriptor_size(
        mut self,
        combined_image_sampler_density_map_descriptor_size: usize,
    ) -> Self {
        self.inner
            .combined_image_sampler_density_map_descriptor_size =
            combined_image_sampler_density_map_descriptor_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorAddressInfoEXT.html>"]
pub struct DescriptorAddressInfoEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub address: DeviceAddress,
    pub range: DeviceSize,
    pub format: Format,
}
impl ::std::default::Default for DescriptorAddressInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            address: DeviceAddress::default(),
            range: DeviceSize::default(),
            format: Format::default(),
        }
    }
}
unsafe impl TaggedStructure for DescriptorAddressInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::DESCRIPTOR_ADDRESS_INFO_EXT;
}
impl DescriptorAddressInfoEXT {
    pub fn builder<'a>() -> DescriptorAddressInfoEXTBuilder<'a> {
        DescriptorAddressInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DescriptorAddressInfoEXTBuilder<'a> {
    inner: DescriptorAddressInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DescriptorAddressInfoEXTBuilder<'a> {
    type Target = DescriptorAddressInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DescriptorAddressInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DescriptorAddressInfoEXTBuilder<'a> {
    #[inline]
    pub fn address(mut self, address: DeviceAddress) -> Self {
        self.inner.address = address;
        self
    }
    #[inline]
    pub fn range(mut self, range: DeviceSize) -> Self {
        self.inner.range = range;
        self
    }
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.inner.format = format;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DescriptorAddressInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorBufferBindingInfoEXT.html>"]
pub struct DescriptorBufferBindingInfoEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub address: DeviceAddress,
    pub usage: BufferUsageFlags,
}
impl ::std::default::Default for DescriptorBufferBindingInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            address: DeviceAddress::default(),
            usage: BufferUsageFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for DescriptorBufferBindingInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::DESCRIPTOR_BUFFER_BINDING_INFO_EXT;
}
impl DescriptorBufferBindingInfoEXT {
    pub fn builder<'a>() -> DescriptorBufferBindingInfoEXTBuilder<'a> {
        DescriptorBufferBindingInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DescriptorBufferBindingInfoEXTBuilder<'a> {
    inner: DescriptorBufferBindingInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsDescriptorBufferBindingInfoEXT {}
impl<'a> ::std::ops::Deref for DescriptorBufferBindingInfoEXTBuilder<'a> {
    type Target = DescriptorBufferBindingInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DescriptorBufferBindingInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DescriptorBufferBindingInfoEXTBuilder<'a> {
    #[inline]
    pub fn address(mut self, address: DeviceAddress) -> Self {
        self.inner.address = address;
        self
    }
    #[inline]
    pub fn usage(mut self, usage: BufferUsageFlags) -> Self {
        self.inner.usage = usage;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsDescriptorBufferBindingInfoEXT>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DescriptorBufferBindingInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorBufferBindingPushDescriptorBufferHandleEXT.html>"]
pub struct DescriptorBufferBindingPushDescriptorBufferHandleEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub buffer: Buffer,
}
impl ::std::default::Default for DescriptorBufferBindingPushDescriptorBufferHandleEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            buffer: Buffer::default(),
        }
    }
}
unsafe impl TaggedStructure for DescriptorBufferBindingPushDescriptorBufferHandleEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT;
}
impl DescriptorBufferBindingPushDescriptorBufferHandleEXT {
    pub fn builder<'a>() -> DescriptorBufferBindingPushDescriptorBufferHandleEXTBuilder<'a> {
        DescriptorBufferBindingPushDescriptorBufferHandleEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DescriptorBufferBindingPushDescriptorBufferHandleEXTBuilder<'a> {
    inner: DescriptorBufferBindingPushDescriptorBufferHandleEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsDescriptorBufferBindingInfoEXT
    for DescriptorBufferBindingPushDescriptorBufferHandleEXTBuilder<'_>
{
}
unsafe impl ExtendsDescriptorBufferBindingInfoEXT
    for DescriptorBufferBindingPushDescriptorBufferHandleEXT
{
}
impl<'a> ::std::ops::Deref for DescriptorBufferBindingPushDescriptorBufferHandleEXTBuilder<'a> {
    type Target = DescriptorBufferBindingPushDescriptorBufferHandleEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DescriptorBufferBindingPushDescriptorBufferHandleEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DescriptorBufferBindingPushDescriptorBufferHandleEXTBuilder<'a> {
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DescriptorBufferBindingPushDescriptorBufferHandleEXT {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorDataEXT.html>"]
pub union DescriptorDataEXT {
    pub p_sampler: *const Sampler,
    pub p_combined_image_sampler: *const DescriptorImageInfo,
    pub p_input_attachment_image: *const DescriptorImageInfo,
    pub p_sampled_image: *const DescriptorImageInfo,
    pub p_storage_image: *const DescriptorImageInfo,
    pub p_uniform_texel_buffer: *const DescriptorAddressInfoEXT,
    pub p_storage_texel_buffer: *const DescriptorAddressInfoEXT,
    pub p_uniform_buffer: *const DescriptorAddressInfoEXT,
    pub p_storage_buffer: *const DescriptorAddressInfoEXT,
    pub acceleration_structure: DeviceAddress,
}
impl ::std::default::Default for DescriptorDataEXT {
    #[inline]
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorGetInfoEXT.html>"]
pub struct DescriptorGetInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: DescriptorType,
    pub data: DescriptorDataEXT,
}
#[cfg(feature = "debug")]
impl fmt::Debug for DescriptorGetInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DescriptorGetInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ty", &self.ty)
            .field("data", &"union")
            .finish()
    }
}
impl ::std::default::Default for DescriptorGetInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            ty: DescriptorType::default(),
            data: DescriptorDataEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for DescriptorGetInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::DESCRIPTOR_GET_INFO_EXT;
}
impl DescriptorGetInfoEXT {
    pub fn builder<'a>() -> DescriptorGetInfoEXTBuilder<'a> {
        DescriptorGetInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DescriptorGetInfoEXTBuilder<'a> {
    inner: DescriptorGetInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DescriptorGetInfoEXTBuilder<'a> {
    type Target = DescriptorGetInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DescriptorGetInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DescriptorGetInfoEXTBuilder<'a> {
    #[inline]
    pub fn ty(mut self, ty: DescriptorType) -> Self {
        self.inner.ty = ty;
        self
    }
    #[inline]
    pub fn data(mut self, data: DescriptorDataEXT) -> Self {
        self.inner.data = data;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DescriptorGetInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCaptureDescriptorDataInfoEXT.html>"]
pub struct BufferCaptureDescriptorDataInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub buffer: Buffer,
}
impl ::std::default::Default for BufferCaptureDescriptorDataInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            buffer: Buffer::default(),
        }
    }
}
unsafe impl TaggedStructure for BufferCaptureDescriptorDataInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT;
}
impl BufferCaptureDescriptorDataInfoEXT {
    pub fn builder<'a>() -> BufferCaptureDescriptorDataInfoEXTBuilder<'a> {
        BufferCaptureDescriptorDataInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BufferCaptureDescriptorDataInfoEXTBuilder<'a> {
    inner: BufferCaptureDescriptorDataInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for BufferCaptureDescriptorDataInfoEXTBuilder<'a> {
    type Target = BufferCaptureDescriptorDataInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BufferCaptureDescriptorDataInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BufferCaptureDescriptorDataInfoEXTBuilder<'a> {
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BufferCaptureDescriptorDataInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCaptureDescriptorDataInfoEXT.html>"]
pub struct ImageCaptureDescriptorDataInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image: Image,
}
impl ::std::default::Default for ImageCaptureDescriptorDataInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image: Image::default(),
        }
    }
}
unsafe impl TaggedStructure for ImageCaptureDescriptorDataInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT;
}
impl ImageCaptureDescriptorDataInfoEXT {
    pub fn builder<'a>() -> ImageCaptureDescriptorDataInfoEXTBuilder<'a> {
        ImageCaptureDescriptorDataInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageCaptureDescriptorDataInfoEXTBuilder<'a> {
    inner: ImageCaptureDescriptorDataInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ImageCaptureDescriptorDataInfoEXTBuilder<'a> {
    type Target = ImageCaptureDescriptorDataInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageCaptureDescriptorDataInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageCaptureDescriptorDataInfoEXTBuilder<'a> {
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.inner.image = image;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageCaptureDescriptorDataInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewCaptureDescriptorDataInfoEXT.html>"]
pub struct ImageViewCaptureDescriptorDataInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image_view: ImageView,
}
impl ::std::default::Default for ImageViewCaptureDescriptorDataInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image_view: ImageView::default(),
        }
    }
}
unsafe impl TaggedStructure for ImageViewCaptureDescriptorDataInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT;
}
impl ImageViewCaptureDescriptorDataInfoEXT {
    pub fn builder<'a>() -> ImageViewCaptureDescriptorDataInfoEXTBuilder<'a> {
        ImageViewCaptureDescriptorDataInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageViewCaptureDescriptorDataInfoEXTBuilder<'a> {
    inner: ImageViewCaptureDescriptorDataInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ImageViewCaptureDescriptorDataInfoEXTBuilder<'a> {
    type Target = ImageViewCaptureDescriptorDataInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageViewCaptureDescriptorDataInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageViewCaptureDescriptorDataInfoEXTBuilder<'a> {
    #[inline]
    pub fn image_view(mut self, image_view: ImageView) -> Self {
        self.inner.image_view = image_view;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageViewCaptureDescriptorDataInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerCaptureDescriptorDataInfoEXT.html>"]
pub struct SamplerCaptureDescriptorDataInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub sampler: Sampler,
}
impl ::std::default::Default for SamplerCaptureDescriptorDataInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            sampler: Sampler::default(),
        }
    }
}
unsafe impl TaggedStructure for SamplerCaptureDescriptorDataInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT;
}
impl SamplerCaptureDescriptorDataInfoEXT {
    pub fn builder<'a>() -> SamplerCaptureDescriptorDataInfoEXTBuilder<'a> {
        SamplerCaptureDescriptorDataInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SamplerCaptureDescriptorDataInfoEXTBuilder<'a> {
    inner: SamplerCaptureDescriptorDataInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SamplerCaptureDescriptorDataInfoEXTBuilder<'a> {
    type Target = SamplerCaptureDescriptorDataInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SamplerCaptureDescriptorDataInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SamplerCaptureDescriptorDataInfoEXTBuilder<'a> {
    #[inline]
    pub fn sampler(mut self, sampler: Sampler) -> Self {
        self.inner.sampler = sampler;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SamplerCaptureDescriptorDataInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureCaptureDescriptorDataInfoEXT.html>"]
pub struct AccelerationStructureCaptureDescriptorDataInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub acceleration_structure: AccelerationStructureKHR,
    pub acceleration_structure_nv: AccelerationStructureNV,
}
impl ::std::default::Default for AccelerationStructureCaptureDescriptorDataInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            acceleration_structure: AccelerationStructureKHR::default(),
            acceleration_structure_nv: AccelerationStructureNV::default(),
        }
    }
}
unsafe impl TaggedStructure for AccelerationStructureCaptureDescriptorDataInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT;
}
impl AccelerationStructureCaptureDescriptorDataInfoEXT {
    pub fn builder<'a>() -> AccelerationStructureCaptureDescriptorDataInfoEXTBuilder<'a> {
        AccelerationStructureCaptureDescriptorDataInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AccelerationStructureCaptureDescriptorDataInfoEXTBuilder<'a> {
    inner: AccelerationStructureCaptureDescriptorDataInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for AccelerationStructureCaptureDescriptorDataInfoEXTBuilder<'a> {
    type Target = AccelerationStructureCaptureDescriptorDataInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AccelerationStructureCaptureDescriptorDataInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AccelerationStructureCaptureDescriptorDataInfoEXTBuilder<'a> {
    #[inline]
    pub fn acceleration_structure(
        mut self,
        acceleration_structure: AccelerationStructureKHR,
    ) -> Self {
        self.inner.acceleration_structure = acceleration_structure;
        self
    }
    #[inline]
    pub fn acceleration_structure_nv(
        mut self,
        acceleration_structure_nv: AccelerationStructureNV,
    ) -> Self {
        self.inner.acceleration_structure_nv = acceleration_structure_nv;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AccelerationStructureCaptureDescriptorDataInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOpaqueCaptureDescriptorDataCreateInfoEXT.html>"]
pub struct OpaqueCaptureDescriptorDataCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub opaque_capture_descriptor_data: *const c_void,
}
impl ::std::default::Default for OpaqueCaptureDescriptorDataCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            opaque_capture_descriptor_data: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for OpaqueCaptureDescriptorDataCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
}
impl OpaqueCaptureDescriptorDataCreateInfoEXT {
    pub fn builder<'a>() -> OpaqueCaptureDescriptorDataCreateInfoEXTBuilder<'a> {
        OpaqueCaptureDescriptorDataCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct OpaqueCaptureDescriptorDataCreateInfoEXTBuilder<'a> {
    inner: OpaqueCaptureDescriptorDataCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsBufferCreateInfo for OpaqueCaptureDescriptorDataCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsBufferCreateInfo for OpaqueCaptureDescriptorDataCreateInfoEXT {}
unsafe impl ExtendsImageCreateInfo for OpaqueCaptureDescriptorDataCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsImageCreateInfo for OpaqueCaptureDescriptorDataCreateInfoEXT {}
unsafe impl ExtendsImageViewCreateInfo for OpaqueCaptureDescriptorDataCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsImageViewCreateInfo for OpaqueCaptureDescriptorDataCreateInfoEXT {}
unsafe impl ExtendsSamplerCreateInfo for OpaqueCaptureDescriptorDataCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsSamplerCreateInfo for OpaqueCaptureDescriptorDataCreateInfoEXT {}
unsafe impl ExtendsAccelerationStructureCreateInfoKHR
    for OpaqueCaptureDescriptorDataCreateInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsAccelerationStructureCreateInfoKHR for OpaqueCaptureDescriptorDataCreateInfoEXT {}
unsafe impl ExtendsAccelerationStructureCreateInfoNV
    for OpaqueCaptureDescriptorDataCreateInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsAccelerationStructureCreateInfoNV for OpaqueCaptureDescriptorDataCreateInfoEXT {}
impl<'a> ::std::ops::Deref for OpaqueCaptureDescriptorDataCreateInfoEXTBuilder<'a> {
    type Target = OpaqueCaptureDescriptorDataCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for OpaqueCaptureDescriptorDataCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> OpaqueCaptureDescriptorDataCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn opaque_capture_descriptor_data(
        mut self,
        opaque_capture_descriptor_data: *const c_void,
    ) -> Self {
        self.inner.opaque_capture_descriptor_data = opaque_capture_descriptor_data;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> OpaqueCaptureDescriptorDataCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderIntegerDotProductFeatures.html>"]
pub struct PhysicalDeviceShaderIntegerDotProductFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_integer_dot_product: Bool32,
}
impl ::std::default::Default for PhysicalDeviceShaderIntegerDotProductFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_integer_dot_product: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderIntegerDotProductFeatures {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES;
}
impl PhysicalDeviceShaderIntegerDotProductFeatures {
    pub fn builder<'a>() -> PhysicalDeviceShaderIntegerDotProductFeaturesBuilder<'a> {
        PhysicalDeviceShaderIntegerDotProductFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderIntegerDotProductFeaturesBuilder<'a> {
    inner: PhysicalDeviceShaderIntegerDotProductFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceShaderIntegerDotProductFeaturesBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderIntegerDotProductFeatures {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderIntegerDotProductFeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderIntegerDotProductFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderIntegerDotProductFeaturesBuilder<'a> {
    type Target = PhysicalDeviceShaderIntegerDotProductFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderIntegerDotProductFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderIntegerDotProductFeaturesBuilder<'a> {
    #[inline]
    pub fn shader_integer_dot_product(mut self, shader_integer_dot_product: bool) -> Self {
        self.inner.shader_integer_dot_product = shader_integer_dot_product.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderIntegerDotProductFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderIntegerDotProductProperties.html>"]
pub struct PhysicalDeviceShaderIntegerDotProductProperties {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub integer_dot_product8_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product8_bit_signed_accelerated: Bool32,
    pub integer_dot_product8_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_unsigned_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_signed_accelerated: Bool32,
    pub integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product16_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product16_bit_signed_accelerated: Bool32,
    pub integer_dot_product16_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product32_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product32_bit_signed_accelerated: Bool32,
    pub integer_dot_product32_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product64_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product64_bit_signed_accelerated: Bool32,
    pub integer_dot_product64_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated:
        Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_signed_accelerated: Bool32,
    pub integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: Bool32,
}
impl ::std::default::Default for PhysicalDeviceShaderIntegerDotProductProperties {
    #[inline]
    fn default() -> Self {
        Self { s_type : Self :: STRUCTURE_TYPE , p_next : :: std :: ptr :: null_mut () , integer_dot_product8_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product8_bit_signed_accelerated : Bool32 :: default () , integer_dot_product8_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product4x8_bit_packed_unsigned_accelerated : Bool32 :: default () , integer_dot_product4x8_bit_packed_signed_accelerated : Bool32 :: default () , integer_dot_product4x8_bit_packed_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product16_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product16_bit_signed_accelerated : Bool32 :: default () , integer_dot_product16_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product32_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product32_bit_signed_accelerated : Bool32 :: default () , integer_dot_product32_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product64_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product64_bit_signed_accelerated : Bool32 :: default () , integer_dot_product64_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating8_bit_signed_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating16_bit_signed_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating32_bit_signed_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating64_bit_signed_accelerated : Bool32 :: default () , integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated : Bool32 :: default () }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderIntegerDotProductProperties {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES;
}
impl PhysicalDeviceShaderIntegerDotProductProperties {
    pub fn builder<'a>() -> PhysicalDeviceShaderIntegerDotProductPropertiesBuilder<'a> {
        PhysicalDeviceShaderIntegerDotProductPropertiesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderIntegerDotProductPropertiesBuilder<'a> {
    inner: PhysicalDeviceShaderIntegerDotProductProperties,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceShaderIntegerDotProductPropertiesBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceShaderIntegerDotProductProperties {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderIntegerDotProductPropertiesBuilder<'a> {
    type Target = PhysicalDeviceShaderIntegerDotProductProperties;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderIntegerDotProductPropertiesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderIntegerDotProductPropertiesBuilder<'a> {
    #[inline]
    pub fn integer_dot_product8_bit_unsigned_accelerated(
        mut self,
        integer_dot_product8_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.inner.integer_dot_product8_bit_unsigned_accelerated =
            integer_dot_product8_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product8_bit_signed_accelerated(
        mut self,
        integer_dot_product8_bit_signed_accelerated: bool,
    ) -> Self {
        self.inner.integer_dot_product8_bit_signed_accelerated =
            integer_dot_product8_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product8_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product8_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product8_bit_mixed_signedness_accelerated =
            integer_dot_product8_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product4x8_bit_packed_unsigned_accelerated(
        mut self,
        integer_dot_product4x8_bit_packed_unsigned_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product4x8_bit_packed_unsigned_accelerated =
            integer_dot_product4x8_bit_packed_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product4x8_bit_packed_signed_accelerated(
        mut self,
        integer_dot_product4x8_bit_packed_signed_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product4x8_bit_packed_signed_accelerated =
            integer_dot_product4x8_bit_packed_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product4x8_bit_packed_mixed_signedness_accelerated(
        mut self,
        integer_dot_product4x8_bit_packed_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product4x8_bit_packed_mixed_signedness_accelerated =
            integer_dot_product4x8_bit_packed_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product16_bit_unsigned_accelerated(
        mut self,
        integer_dot_product16_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.inner.integer_dot_product16_bit_unsigned_accelerated =
            integer_dot_product16_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product16_bit_signed_accelerated(
        mut self,
        integer_dot_product16_bit_signed_accelerated: bool,
    ) -> Self {
        self.inner.integer_dot_product16_bit_signed_accelerated =
            integer_dot_product16_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product16_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product16_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product16_bit_mixed_signedness_accelerated =
            integer_dot_product16_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product32_bit_unsigned_accelerated(
        mut self,
        integer_dot_product32_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.inner.integer_dot_product32_bit_unsigned_accelerated =
            integer_dot_product32_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product32_bit_signed_accelerated(
        mut self,
        integer_dot_product32_bit_signed_accelerated: bool,
    ) -> Self {
        self.inner.integer_dot_product32_bit_signed_accelerated =
            integer_dot_product32_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product32_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product32_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product32_bit_mixed_signedness_accelerated =
            integer_dot_product32_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product64_bit_unsigned_accelerated(
        mut self,
        integer_dot_product64_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.inner.integer_dot_product64_bit_unsigned_accelerated =
            integer_dot_product64_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product64_bit_signed_accelerated(
        mut self,
        integer_dot_product64_bit_signed_accelerated: bool,
    ) -> Self {
        self.inner.integer_dot_product64_bit_signed_accelerated =
            integer_dot_product64_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product64_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product64_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product64_bit_mixed_signedness_accelerated =
            integer_dot_product64_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated =
            integer_dot_product_accumulating_saturating8_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating8_bit_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating8_bit_signed_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating8_bit_signed_accelerated =
            integer_dot_product_accumulating_saturating8_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated =
            integer_dot_product_accumulating_saturating8_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated =
            integer_dot_product_accumulating_saturating4x8_bit_packed_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated =
            integer_dot_product_accumulating_saturating4x8_bit_packed_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated : bool,
    ) -> Self {
        self . inner . integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated = integer_dot_product_accumulating_saturating4x8_bit_packed_mixed_signedness_accelerated . into () ;
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated =
            integer_dot_product_accumulating_saturating16_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating16_bit_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating16_bit_signed_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating16_bit_signed_accelerated =
            integer_dot_product_accumulating_saturating16_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated =
            integer_dot_product_accumulating_saturating16_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated =
            integer_dot_product_accumulating_saturating32_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating32_bit_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating32_bit_signed_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating32_bit_signed_accelerated =
            integer_dot_product_accumulating_saturating32_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated =
            integer_dot_product_accumulating_saturating32_bit_mixed_signedness_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated =
            integer_dot_product_accumulating_saturating64_bit_unsigned_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating64_bit_signed_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating64_bit_signed_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating64_bit_signed_accelerated =
            integer_dot_product_accumulating_saturating64_bit_signed_accelerated.into();
        self
    }
    #[inline]
    pub fn integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated(
        mut self,
        integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated: bool,
    ) -> Self {
        self.inner
            .integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated =
            integer_dot_product_accumulating_saturating64_bit_mixed_signedness_accelerated.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderIntegerDotProductProperties {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDrmPropertiesEXT.html>"]
pub struct PhysicalDeviceDrmPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub has_primary: Bool32,
    pub has_render: Bool32,
    pub primary_major: i64,
    pub primary_minor: i64,
    pub render_major: i64,
    pub render_minor: i64,
}
impl ::std::default::Default for PhysicalDeviceDrmPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            has_primary: Bool32::default(),
            has_render: Bool32::default(),
            primary_major: i64::default(),
            primary_minor: i64::default(),
            render_major: i64::default(),
            render_minor: i64::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceDrmPropertiesEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_DRM_PROPERTIES_EXT;
}
impl PhysicalDeviceDrmPropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceDrmPropertiesEXTBuilder<'a> {
        PhysicalDeviceDrmPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceDrmPropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceDrmPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceDrmPropertiesEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceDrmPropertiesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceDrmPropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceDrmPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceDrmPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceDrmPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn has_primary(mut self, has_primary: bool) -> Self {
        self.inner.has_primary = has_primary.into();
        self
    }
    #[inline]
    pub fn has_render(mut self, has_render: bool) -> Self {
        self.inner.has_render = has_render.into();
        self
    }
    #[inline]
    pub fn primary_major(mut self, primary_major: i64) -> Self {
        self.inner.primary_major = primary_major;
        self
    }
    #[inline]
    pub fn primary_minor(mut self, primary_minor: i64) -> Self {
        self.inner.primary_minor = primary_minor;
        self
    }
    #[inline]
    pub fn render_major(mut self, render_major: i64) -> Self {
        self.inner.render_major = render_major;
        self
    }
    #[inline]
    pub fn render_minor(mut self, render_minor: i64) -> Self {
        self.inner.render_minor = render_minor;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceDrmPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR.html>"]
pub struct PhysicalDeviceFragmentShaderBarycentricFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub fragment_shader_barycentric: Bool32,
}
impl ::std::default::Default for PhysicalDeviceFragmentShaderBarycentricFeaturesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            fragment_shader_barycentric: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceFragmentShaderBarycentricFeaturesKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR;
}
impl PhysicalDeviceFragmentShaderBarycentricFeaturesKHR {
    pub fn builder<'a>() -> PhysicalDeviceFragmentShaderBarycentricFeaturesKHRBuilder<'a> {
        PhysicalDeviceFragmentShaderBarycentricFeaturesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceFragmentShaderBarycentricFeaturesKHRBuilder<'a> {
    inner: PhysicalDeviceFragmentShaderBarycentricFeaturesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceFragmentShaderBarycentricFeaturesKHRBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceFragmentShaderBarycentricFeaturesKHR {}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceFragmentShaderBarycentricFeaturesKHRBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentShaderBarycentricFeaturesKHR {}
impl<'a> ::std::ops::Deref for PhysicalDeviceFragmentShaderBarycentricFeaturesKHRBuilder<'a> {
    type Target = PhysicalDeviceFragmentShaderBarycentricFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceFragmentShaderBarycentricFeaturesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceFragmentShaderBarycentricFeaturesKHRBuilder<'a> {
    #[inline]
    pub fn fragment_shader_barycentric(mut self, fragment_shader_barycentric: bool) -> Self {
        self.inner.fragment_shader_barycentric = fragment_shader_barycentric.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceFragmentShaderBarycentricFeaturesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR.html>"]
pub struct PhysicalDeviceFragmentShaderBarycentricPropertiesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub tri_strip_vertex_order_independent_of_provoking_vertex: Bool32,
}
impl ::std::default::Default for PhysicalDeviceFragmentShaderBarycentricPropertiesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            tri_strip_vertex_order_independent_of_provoking_vertex: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceFragmentShaderBarycentricPropertiesKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR;
}
impl PhysicalDeviceFragmentShaderBarycentricPropertiesKHR {
    pub fn builder<'a>() -> PhysicalDeviceFragmentShaderBarycentricPropertiesKHRBuilder<'a> {
        PhysicalDeviceFragmentShaderBarycentricPropertiesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceFragmentShaderBarycentricPropertiesKHRBuilder<'a> {
    inner: PhysicalDeviceFragmentShaderBarycentricPropertiesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceFragmentShaderBarycentricPropertiesKHRBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceFragmentShaderBarycentricPropertiesKHR
{
}
impl<'a> ::std::ops::Deref for PhysicalDeviceFragmentShaderBarycentricPropertiesKHRBuilder<'a> {
    type Target = PhysicalDeviceFragmentShaderBarycentricPropertiesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceFragmentShaderBarycentricPropertiesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceFragmentShaderBarycentricPropertiesKHRBuilder<'a> {
    #[inline]
    pub fn tri_strip_vertex_order_independent_of_provoking_vertex(
        mut self,
        tri_strip_vertex_order_independent_of_provoking_vertex: bool,
    ) -> Self {
        self.inner
            .tri_strip_vertex_order_independent_of_provoking_vertex =
            tri_strip_vertex_order_independent_of_provoking_vertex.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceFragmentShaderBarycentricPropertiesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingMotionBlurFeaturesNV.html>"]
pub struct PhysicalDeviceRayTracingMotionBlurFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ray_tracing_motion_blur: Bool32,
    pub ray_tracing_motion_blur_pipeline_trace_rays_indirect: Bool32,
}
impl ::std::default::Default for PhysicalDeviceRayTracingMotionBlurFeaturesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            ray_tracing_motion_blur: Bool32::default(),
            ray_tracing_motion_blur_pipeline_trace_rays_indirect: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceRayTracingMotionBlurFeaturesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV;
}
impl PhysicalDeviceRayTracingMotionBlurFeaturesNV {
    pub fn builder<'a>() -> PhysicalDeviceRayTracingMotionBlurFeaturesNVBuilder<'a> {
        PhysicalDeviceRayTracingMotionBlurFeaturesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceRayTracingMotionBlurFeaturesNVBuilder<'a> {
    inner: PhysicalDeviceRayTracingMotionBlurFeaturesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceRayTracingMotionBlurFeaturesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRayTracingMotionBlurFeaturesNV {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRayTracingMotionBlurFeaturesNVBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRayTracingMotionBlurFeaturesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceRayTracingMotionBlurFeaturesNVBuilder<'a> {
    type Target = PhysicalDeviceRayTracingMotionBlurFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceRayTracingMotionBlurFeaturesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceRayTracingMotionBlurFeaturesNVBuilder<'a> {
    #[inline]
    pub fn ray_tracing_motion_blur(mut self, ray_tracing_motion_blur: bool) -> Self {
        self.inner.ray_tracing_motion_blur = ray_tracing_motion_blur.into();
        self
    }
    #[inline]
    pub fn ray_tracing_motion_blur_pipeline_trace_rays_indirect(
        mut self,
        ray_tracing_motion_blur_pipeline_trace_rays_indirect: bool,
    ) -> Self {
        self.inner
            .ray_tracing_motion_blur_pipeline_trace_rays_indirect =
            ray_tracing_motion_blur_pipeline_trace_rays_indirect.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceRayTracingMotionBlurFeaturesNV {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureGeometryMotionTrianglesDataNV.html>"]
pub struct AccelerationStructureGeometryMotionTrianglesDataNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub vertex_data: DeviceOrHostAddressConstKHR,
}
#[cfg(feature = "debug")]
impl fmt::Debug for AccelerationStructureGeometryMotionTrianglesDataNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureGeometryMotionTrianglesDataNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("vertex_data", &"union")
            .finish()
    }
}
impl ::std::default::Default for AccelerationStructureGeometryMotionTrianglesDataNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            vertex_data: DeviceOrHostAddressConstKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for AccelerationStructureGeometryMotionTrianglesDataNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV;
}
impl AccelerationStructureGeometryMotionTrianglesDataNV {
    pub fn builder<'a>() -> AccelerationStructureGeometryMotionTrianglesDataNVBuilder<'a> {
        AccelerationStructureGeometryMotionTrianglesDataNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AccelerationStructureGeometryMotionTrianglesDataNVBuilder<'a> {
    inner: AccelerationStructureGeometryMotionTrianglesDataNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsAccelerationStructureGeometryTrianglesDataKHR
    for AccelerationStructureGeometryMotionTrianglesDataNVBuilder<'_>
{
}
unsafe impl ExtendsAccelerationStructureGeometryTrianglesDataKHR
    for AccelerationStructureGeometryMotionTrianglesDataNV
{
}
impl<'a> ::std::ops::Deref for AccelerationStructureGeometryMotionTrianglesDataNVBuilder<'a> {
    type Target = AccelerationStructureGeometryMotionTrianglesDataNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AccelerationStructureGeometryMotionTrianglesDataNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AccelerationStructureGeometryMotionTrianglesDataNVBuilder<'a> {
    #[inline]
    pub fn vertex_data(mut self, vertex_data: DeviceOrHostAddressConstKHR) -> Self {
        self.inner.vertex_data = vertex_data;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AccelerationStructureGeometryMotionTrianglesDataNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureMotionInfoNV.html>"]
pub struct AccelerationStructureMotionInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub max_instances: u32,
    pub flags: AccelerationStructureMotionInfoFlagsNV,
}
impl ::std::default::Default for AccelerationStructureMotionInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            max_instances: u32::default(),
            flags: AccelerationStructureMotionInfoFlagsNV::default(),
        }
    }
}
unsafe impl TaggedStructure for AccelerationStructureMotionInfoNV {
    const STRUCTURE_TYPE: StructureType = StructureType::ACCELERATION_STRUCTURE_MOTION_INFO_NV;
}
impl AccelerationStructureMotionInfoNV {
    pub fn builder<'a>() -> AccelerationStructureMotionInfoNVBuilder<'a> {
        AccelerationStructureMotionInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AccelerationStructureMotionInfoNVBuilder<'a> {
    inner: AccelerationStructureMotionInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsAccelerationStructureCreateInfoKHR
    for AccelerationStructureMotionInfoNVBuilder<'_>
{
}
unsafe impl ExtendsAccelerationStructureCreateInfoKHR for AccelerationStructureMotionInfoNV {}
impl<'a> ::std::ops::Deref for AccelerationStructureMotionInfoNVBuilder<'a> {
    type Target = AccelerationStructureMotionInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AccelerationStructureMotionInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AccelerationStructureMotionInfoNVBuilder<'a> {
    #[inline]
    pub fn max_instances(mut self, max_instances: u32) -> Self {
        self.inner.max_instances = max_instances;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: AccelerationStructureMotionInfoFlagsNV) -> Self {
        self.inner.flags = flags;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AccelerationStructureMotionInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSRTDataNV.html>"]
pub struct SRTDataNV {
    pub sx: f32,
    pub a: f32,
    pub b: f32,
    pub pvx: f32,
    pub sy: f32,
    pub c: f32,
    pub pvy: f32,
    pub sz: f32,
    pub pvz: f32,
    pub qx: f32,
    pub qy: f32,
    pub qz: f32,
    pub qw: f32,
    pub tx: f32,
    pub ty: f32,
    pub tz: f32,
}
impl SRTDataNV {
    pub fn builder<'a>() -> SRTDataNVBuilder<'a> {
        SRTDataNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SRTDataNVBuilder<'a> {
    inner: SRTDataNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SRTDataNVBuilder<'a> {
    type Target = SRTDataNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SRTDataNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SRTDataNVBuilder<'a> {
    #[inline]
    pub fn sx(mut self, sx: f32) -> Self {
        self.inner.sx = sx;
        self
    }
    #[inline]
    pub fn a(mut self, a: f32) -> Self {
        self.inner.a = a;
        self
    }
    #[inline]
    pub fn b(mut self, b: f32) -> Self {
        self.inner.b = b;
        self
    }
    #[inline]
    pub fn pvx(mut self, pvx: f32) -> Self {
        self.inner.pvx = pvx;
        self
    }
    #[inline]
    pub fn sy(mut self, sy: f32) -> Self {
        self.inner.sy = sy;
        self
    }
    #[inline]
    pub fn c(mut self, c: f32) -> Self {
        self.inner.c = c;
        self
    }
    #[inline]
    pub fn pvy(mut self, pvy: f32) -> Self {
        self.inner.pvy = pvy;
        self
    }
    #[inline]
    pub fn sz(mut self, sz: f32) -> Self {
        self.inner.sz = sz;
        self
    }
    #[inline]
    pub fn pvz(mut self, pvz: f32) -> Self {
        self.inner.pvz = pvz;
        self
    }
    #[inline]
    pub fn qx(mut self, qx: f32) -> Self {
        self.inner.qx = qx;
        self
    }
    #[inline]
    pub fn qy(mut self, qy: f32) -> Self {
        self.inner.qy = qy;
        self
    }
    #[inline]
    pub fn qz(mut self, qz: f32) -> Self {
        self.inner.qz = qz;
        self
    }
    #[inline]
    pub fn qw(mut self, qw: f32) -> Self {
        self.inner.qw = qw;
        self
    }
    #[inline]
    pub fn tx(mut self, tx: f32) -> Self {
        self.inner.tx = tx;
        self
    }
    #[inline]
    pub fn ty(mut self, ty: f32) -> Self {
        self.inner.ty = ty;
        self
    }
    #[inline]
    pub fn tz(mut self, tz: f32) -> Self {
        self.inner.tz = tz;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SRTDataNV {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureSRTMotionInstanceNV.html>"]
pub struct AccelerationStructureSRTMotionInstanceNV {
    pub transform_t0: SRTDataNV,
    pub transform_t1: SRTDataNV,
    #[doc = r" Use [`Packed24_8::new(instance_custom_index, mask)`][Packed24_8::new()] to construct this field"]
    pub instance_custom_index_and_mask: Packed24_8,
    #[doc = r" Use [`Packed24_8::new(instance_shader_binding_table_record_offset, flags)`][Packed24_8::new()] to construct this field"]
    pub instance_shader_binding_table_record_offset_and_flags: Packed24_8,
    pub acceleration_structure_reference: AccelerationStructureReferenceKHR,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/AccelerationStructureMatrixMotionInstanceNV.html>"]
pub struct AccelerationStructureMatrixMotionInstanceNV {
    pub transform_t0: TransformMatrixKHR,
    pub transform_t1: TransformMatrixKHR,
    #[doc = r" Use [`Packed24_8::new(instance_custom_index, mask)`][Packed24_8::new()] to construct this field"]
    pub instance_custom_index_and_mask: Packed24_8,
    #[doc = r" Use [`Packed24_8::new(instance_shader_binding_table_record_offset, flags)`][Packed24_8::new()] to construct this field"]
    pub instance_shader_binding_table_record_offset_and_flags: Packed24_8,
    pub acceleration_structure_reference: AccelerationStructureReferenceKHR,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureMotionInstanceDataNV.html>"]
pub union AccelerationStructureMotionInstanceDataNV {
    pub static_instance: AccelerationStructureInstanceKHR,
    pub matrix_motion_instance: AccelerationStructureMatrixMotionInstanceNV,
    pub srt_motion_instance: AccelerationStructureSRTMotionInstanceNV,
}
impl ::std::default::Default for AccelerationStructureMotionInstanceDataNV {
    #[inline]
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureMotionInstanceNV.html>"]
pub struct AccelerationStructureMotionInstanceNV {
    pub ty: AccelerationStructureMotionInstanceTypeNV,
    pub flags: AccelerationStructureMotionInstanceFlagsNV,
    pub data: AccelerationStructureMotionInstanceDataNV,
}
#[cfg(feature = "debug")]
impl fmt::Debug for AccelerationStructureMotionInstanceNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureMotionInstanceNV")
            .field("ty", &self.ty)
            .field("flags", &self.flags)
            .field("data", &"union")
            .finish()
    }
}
impl AccelerationStructureMotionInstanceNV {
    pub fn builder<'a>() -> AccelerationStructureMotionInstanceNVBuilder<'a> {
        AccelerationStructureMotionInstanceNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AccelerationStructureMotionInstanceNVBuilder<'a> {
    inner: AccelerationStructureMotionInstanceNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for AccelerationStructureMotionInstanceNVBuilder<'a> {
    type Target = AccelerationStructureMotionInstanceNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AccelerationStructureMotionInstanceNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AccelerationStructureMotionInstanceNVBuilder<'a> {
    #[inline]
    pub fn ty(mut self, ty: AccelerationStructureMotionInstanceTypeNV) -> Self {
        self.inner.ty = ty;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: AccelerationStructureMotionInstanceFlagsNV) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn data(mut self, data: AccelerationStructureMotionInstanceDataNV) -> Self {
        self.inner.data = data;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AccelerationStructureMotionInstanceNV {
        self.inner
    }
}
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRemoteAddressNV.html>"]
pub type RemoteAddressNV = c_void;
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryGetRemoteAddressInfoNV.html>"]
pub struct MemoryGetRemoteAddressInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: DeviceMemory,
    pub handle_type: ExternalMemoryHandleTypeFlags,
}
impl ::std::default::Default for MemoryGetRemoteAddressInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            memory: DeviceMemory::default(),
            handle_type: ExternalMemoryHandleTypeFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for MemoryGetRemoteAddressInfoNV {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_GET_REMOTE_ADDRESS_INFO_NV;
}
impl MemoryGetRemoteAddressInfoNV {
    pub fn builder<'a>() -> MemoryGetRemoteAddressInfoNVBuilder<'a> {
        MemoryGetRemoteAddressInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MemoryGetRemoteAddressInfoNVBuilder<'a> {
    inner: MemoryGetRemoteAddressInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MemoryGetRemoteAddressInfoNVBuilder<'a> {
    type Target = MemoryGetRemoteAddressInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MemoryGetRemoteAddressInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MemoryGetRemoteAddressInfoNVBuilder<'a> {
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    #[inline]
    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
        self.inner.handle_type = handle_type;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MemoryGetRemoteAddressInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMemoryBufferCollectionFUCHSIA.html>"]
pub struct ImportMemoryBufferCollectionFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub collection: BufferCollectionFUCHSIA,
    pub index: u32,
}
impl ::std::default::Default for ImportMemoryBufferCollectionFUCHSIA {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            collection: BufferCollectionFUCHSIA::default(),
            index: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for ImportMemoryBufferCollectionFUCHSIA {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA;
}
impl ImportMemoryBufferCollectionFUCHSIA {
    pub fn builder<'a>() -> ImportMemoryBufferCollectionFUCHSIABuilder<'a> {
        ImportMemoryBufferCollectionFUCHSIABuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImportMemoryBufferCollectionFUCHSIABuilder<'a> {
    inner: ImportMemoryBufferCollectionFUCHSIA,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsMemoryAllocateInfo for ImportMemoryBufferCollectionFUCHSIABuilder<'_> {}
unsafe impl ExtendsMemoryAllocateInfo for ImportMemoryBufferCollectionFUCHSIA {}
impl<'a> ::std::ops::Deref for ImportMemoryBufferCollectionFUCHSIABuilder<'a> {
    type Target = ImportMemoryBufferCollectionFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImportMemoryBufferCollectionFUCHSIABuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImportMemoryBufferCollectionFUCHSIABuilder<'a> {
    #[inline]
    pub fn collection(mut self, collection: BufferCollectionFUCHSIA) -> Self {
        self.inner.collection = collection;
        self
    }
    #[inline]
    pub fn index(mut self, index: u32) -> Self {
        self.inner.index = index;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImportMemoryBufferCollectionFUCHSIA {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCollectionImageCreateInfoFUCHSIA.html>"]
pub struct BufferCollectionImageCreateInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub collection: BufferCollectionFUCHSIA,
    pub index: u32,
}
impl ::std::default::Default for BufferCollectionImageCreateInfoFUCHSIA {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            collection: BufferCollectionFUCHSIA::default(),
            index: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for BufferCollectionImageCreateInfoFUCHSIA {
    const STRUCTURE_TYPE: StructureType =
        StructureType::BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA;
}
impl BufferCollectionImageCreateInfoFUCHSIA {
    pub fn builder<'a>() -> BufferCollectionImageCreateInfoFUCHSIABuilder<'a> {
        BufferCollectionImageCreateInfoFUCHSIABuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BufferCollectionImageCreateInfoFUCHSIABuilder<'a> {
    inner: BufferCollectionImageCreateInfoFUCHSIA,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageCreateInfo for BufferCollectionImageCreateInfoFUCHSIABuilder<'_> {}
unsafe impl ExtendsImageCreateInfo for BufferCollectionImageCreateInfoFUCHSIA {}
impl<'a> ::std::ops::Deref for BufferCollectionImageCreateInfoFUCHSIABuilder<'a> {
    type Target = BufferCollectionImageCreateInfoFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BufferCollectionImageCreateInfoFUCHSIABuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BufferCollectionImageCreateInfoFUCHSIABuilder<'a> {
    #[inline]
    pub fn collection(mut self, collection: BufferCollectionFUCHSIA) -> Self {
        self.inner.collection = collection;
        self
    }
    #[inline]
    pub fn index(mut self, index: u32) -> Self {
        self.inner.index = index;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BufferCollectionImageCreateInfoFUCHSIA {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCollectionBufferCreateInfoFUCHSIA.html>"]
pub struct BufferCollectionBufferCreateInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub collection: BufferCollectionFUCHSIA,
    pub index: u32,
}
impl ::std::default::Default for BufferCollectionBufferCreateInfoFUCHSIA {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            collection: BufferCollectionFUCHSIA::default(),
            index: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for BufferCollectionBufferCreateInfoFUCHSIA {
    const STRUCTURE_TYPE: StructureType =
        StructureType::BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA;
}
impl BufferCollectionBufferCreateInfoFUCHSIA {
    pub fn builder<'a>() -> BufferCollectionBufferCreateInfoFUCHSIABuilder<'a> {
        BufferCollectionBufferCreateInfoFUCHSIABuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BufferCollectionBufferCreateInfoFUCHSIABuilder<'a> {
    inner: BufferCollectionBufferCreateInfoFUCHSIA,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsBufferCreateInfo for BufferCollectionBufferCreateInfoFUCHSIABuilder<'_> {}
unsafe impl ExtendsBufferCreateInfo for BufferCollectionBufferCreateInfoFUCHSIA {}
impl<'a> ::std::ops::Deref for BufferCollectionBufferCreateInfoFUCHSIABuilder<'a> {
    type Target = BufferCollectionBufferCreateInfoFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BufferCollectionBufferCreateInfoFUCHSIABuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BufferCollectionBufferCreateInfoFUCHSIABuilder<'a> {
    #[inline]
    pub fn collection(mut self, collection: BufferCollectionFUCHSIA) -> Self {
        self.inner.collection = collection;
        self
    }
    #[inline]
    pub fn index(mut self, index: u32) -> Self {
        self.inner.index = index;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BufferCollectionBufferCreateInfoFUCHSIA {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCollectionCreateInfoFUCHSIA.html>"]
pub struct BufferCollectionCreateInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub collection_token: zx_handle_t,
}
impl ::std::default::Default for BufferCollectionCreateInfoFUCHSIA {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            collection_token: zx_handle_t::default(),
        }
    }
}
unsafe impl TaggedStructure for BufferCollectionCreateInfoFUCHSIA {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_COLLECTION_CREATE_INFO_FUCHSIA;
}
impl BufferCollectionCreateInfoFUCHSIA {
    pub fn builder<'a>() -> BufferCollectionCreateInfoFUCHSIABuilder<'a> {
        BufferCollectionCreateInfoFUCHSIABuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BufferCollectionCreateInfoFUCHSIABuilder<'a> {
    inner: BufferCollectionCreateInfoFUCHSIA,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for BufferCollectionCreateInfoFUCHSIABuilder<'a> {
    type Target = BufferCollectionCreateInfoFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BufferCollectionCreateInfoFUCHSIABuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BufferCollectionCreateInfoFUCHSIABuilder<'a> {
    #[inline]
    pub fn collection_token(mut self, collection_token: zx_handle_t) -> Self {
        self.inner.collection_token = collection_token;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BufferCollectionCreateInfoFUCHSIA {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCollectionPropertiesFUCHSIA.html>"]
pub struct BufferCollectionPropertiesFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub memory_type_bits: u32,
    pub buffer_count: u32,
    pub create_info_index: u32,
    pub sysmem_pixel_format: u64,
    pub format_features: FormatFeatureFlags,
    pub sysmem_color_space_index: SysmemColorSpaceFUCHSIA,
    pub sampler_ycbcr_conversion_components: ComponentMapping,
    pub suggested_ycbcr_model: SamplerYcbcrModelConversion,
    pub suggested_ycbcr_range: SamplerYcbcrRange,
    pub suggested_x_chroma_offset: ChromaLocation,
    pub suggested_y_chroma_offset: ChromaLocation,
}
impl ::std::default::Default for BufferCollectionPropertiesFUCHSIA {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            memory_type_bits: u32::default(),
            buffer_count: u32::default(),
            create_info_index: u32::default(),
            sysmem_pixel_format: u64::default(),
            format_features: FormatFeatureFlags::default(),
            sysmem_color_space_index: SysmemColorSpaceFUCHSIA::default(),
            sampler_ycbcr_conversion_components: ComponentMapping::default(),
            suggested_ycbcr_model: SamplerYcbcrModelConversion::default(),
            suggested_ycbcr_range: SamplerYcbcrRange::default(),
            suggested_x_chroma_offset: ChromaLocation::default(),
            suggested_y_chroma_offset: ChromaLocation::default(),
        }
    }
}
unsafe impl TaggedStructure for BufferCollectionPropertiesFUCHSIA {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_COLLECTION_PROPERTIES_FUCHSIA;
}
impl BufferCollectionPropertiesFUCHSIA {
    pub fn builder<'a>() -> BufferCollectionPropertiesFUCHSIABuilder<'a> {
        BufferCollectionPropertiesFUCHSIABuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BufferCollectionPropertiesFUCHSIABuilder<'a> {
    inner: BufferCollectionPropertiesFUCHSIA,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for BufferCollectionPropertiesFUCHSIABuilder<'a> {
    type Target = BufferCollectionPropertiesFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BufferCollectionPropertiesFUCHSIABuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BufferCollectionPropertiesFUCHSIABuilder<'a> {
    #[inline]
    pub fn memory_type_bits(mut self, memory_type_bits: u32) -> Self {
        self.inner.memory_type_bits = memory_type_bits;
        self
    }
    #[inline]
    pub fn buffer_count(mut self, buffer_count: u32) -> Self {
        self.inner.buffer_count = buffer_count;
        self
    }
    #[inline]
    pub fn create_info_index(mut self, create_info_index: u32) -> Self {
        self.inner.create_info_index = create_info_index;
        self
    }
    #[inline]
    pub fn sysmem_pixel_format(mut self, sysmem_pixel_format: u64) -> Self {
        self.inner.sysmem_pixel_format = sysmem_pixel_format;
        self
    }
    #[inline]
    pub fn format_features(mut self, format_features: FormatFeatureFlags) -> Self {
        self.inner.format_features = format_features;
        self
    }
    #[inline]
    pub fn sysmem_color_space_index(
        mut self,
        sysmem_color_space_index: SysmemColorSpaceFUCHSIA,
    ) -> Self {
        self.inner.sysmem_color_space_index = sysmem_color_space_index;
        self
    }
    #[inline]
    pub fn sampler_ycbcr_conversion_components(
        mut self,
        sampler_ycbcr_conversion_components: ComponentMapping,
    ) -> Self {
        self.inner.sampler_ycbcr_conversion_components = sampler_ycbcr_conversion_components;
        self
    }
    #[inline]
    pub fn suggested_ycbcr_model(
        mut self,
        suggested_ycbcr_model: SamplerYcbcrModelConversion,
    ) -> Self {
        self.inner.suggested_ycbcr_model = suggested_ycbcr_model;
        self
    }
    #[inline]
    pub fn suggested_ycbcr_range(mut self, suggested_ycbcr_range: SamplerYcbcrRange) -> Self {
        self.inner.suggested_ycbcr_range = suggested_ycbcr_range;
        self
    }
    #[inline]
    pub fn suggested_x_chroma_offset(mut self, suggested_x_chroma_offset: ChromaLocation) -> Self {
        self.inner.suggested_x_chroma_offset = suggested_x_chroma_offset;
        self
    }
    #[inline]
    pub fn suggested_y_chroma_offset(mut self, suggested_y_chroma_offset: ChromaLocation) -> Self {
        self.inner.suggested_y_chroma_offset = suggested_y_chroma_offset;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BufferCollectionPropertiesFUCHSIA {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferConstraintsInfoFUCHSIA.html>"]
pub struct BufferConstraintsInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub create_info: BufferCreateInfo,
    pub required_format_features: FormatFeatureFlags,
    pub buffer_collection_constraints: BufferCollectionConstraintsInfoFUCHSIA,
}
impl ::std::default::Default for BufferConstraintsInfoFUCHSIA {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            create_info: BufferCreateInfo::default(),
            required_format_features: FormatFeatureFlags::default(),
            buffer_collection_constraints: BufferCollectionConstraintsInfoFUCHSIA::default(),
        }
    }
}
unsafe impl TaggedStructure for BufferConstraintsInfoFUCHSIA {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_CONSTRAINTS_INFO_FUCHSIA;
}
impl BufferConstraintsInfoFUCHSIA {
    pub fn builder<'a>() -> BufferConstraintsInfoFUCHSIABuilder<'a> {
        BufferConstraintsInfoFUCHSIABuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BufferConstraintsInfoFUCHSIABuilder<'a> {
    inner: BufferConstraintsInfoFUCHSIA,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for BufferConstraintsInfoFUCHSIABuilder<'a> {
    type Target = BufferConstraintsInfoFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BufferConstraintsInfoFUCHSIABuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BufferConstraintsInfoFUCHSIABuilder<'a> {
    #[inline]
    pub fn create_info(mut self, create_info: BufferCreateInfo) -> Self {
        self.inner.create_info = create_info;
        self
    }
    #[inline]
    pub fn required_format_features(
        mut self,
        required_format_features: FormatFeatureFlags,
    ) -> Self {
        self.inner.required_format_features = required_format_features;
        self
    }
    #[inline]
    pub fn buffer_collection_constraints(
        mut self,
        buffer_collection_constraints: BufferCollectionConstraintsInfoFUCHSIA,
    ) -> Self {
        self.inner.buffer_collection_constraints = buffer_collection_constraints;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BufferConstraintsInfoFUCHSIA {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSysmemColorSpaceFUCHSIA.html>"]
pub struct SysmemColorSpaceFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub color_space: u32,
}
impl ::std::default::Default for SysmemColorSpaceFUCHSIA {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            color_space: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for SysmemColorSpaceFUCHSIA {
    const STRUCTURE_TYPE: StructureType = StructureType::SYSMEM_COLOR_SPACE_FUCHSIA;
}
impl SysmemColorSpaceFUCHSIA {
    pub fn builder<'a>() -> SysmemColorSpaceFUCHSIABuilder<'a> {
        SysmemColorSpaceFUCHSIABuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SysmemColorSpaceFUCHSIABuilder<'a> {
    inner: SysmemColorSpaceFUCHSIA,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for SysmemColorSpaceFUCHSIABuilder<'a> {
    type Target = SysmemColorSpaceFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SysmemColorSpaceFUCHSIABuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SysmemColorSpaceFUCHSIABuilder<'a> {
    #[inline]
    pub fn color_space(mut self, color_space: u32) -> Self {
        self.inner.color_space = color_space;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SysmemColorSpaceFUCHSIA {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageFormatConstraintsInfoFUCHSIA.html>"]
pub struct ImageFormatConstraintsInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image_create_info: ImageCreateInfo,
    pub required_format_features: FormatFeatureFlags,
    pub flags: ImageFormatConstraintsFlagsFUCHSIA,
    pub sysmem_pixel_format: u64,
    pub color_space_count: u32,
    pub p_color_spaces: *const SysmemColorSpaceFUCHSIA,
}
impl ::std::default::Default for ImageFormatConstraintsInfoFUCHSIA {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image_create_info: ImageCreateInfo::default(),
            required_format_features: FormatFeatureFlags::default(),
            flags: ImageFormatConstraintsFlagsFUCHSIA::default(),
            sysmem_pixel_format: u64::default(),
            color_space_count: u32::default(),
            p_color_spaces: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for ImageFormatConstraintsInfoFUCHSIA {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA;
}
impl ImageFormatConstraintsInfoFUCHSIA {
    pub fn builder<'a>() -> ImageFormatConstraintsInfoFUCHSIABuilder<'a> {
        ImageFormatConstraintsInfoFUCHSIABuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageFormatConstraintsInfoFUCHSIABuilder<'a> {
    inner: ImageFormatConstraintsInfoFUCHSIA,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ImageFormatConstraintsInfoFUCHSIABuilder<'a> {
    type Target = ImageFormatConstraintsInfoFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageFormatConstraintsInfoFUCHSIABuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageFormatConstraintsInfoFUCHSIABuilder<'a> {
    #[inline]
    pub fn image_create_info(mut self, image_create_info: ImageCreateInfo) -> Self {
        self.inner.image_create_info = image_create_info;
        self
    }
    #[inline]
    pub fn required_format_features(
        mut self,
        required_format_features: FormatFeatureFlags,
    ) -> Self {
        self.inner.required_format_features = required_format_features;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: ImageFormatConstraintsFlagsFUCHSIA) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn sysmem_pixel_format(mut self, sysmem_pixel_format: u64) -> Self {
        self.inner.sysmem_pixel_format = sysmem_pixel_format;
        self
    }
    #[inline]
    pub fn color_spaces(mut self, color_spaces: &'a [SysmemColorSpaceFUCHSIA]) -> Self {
        self.inner.color_space_count = color_spaces.len() as _;
        self.inner.p_color_spaces = color_spaces.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageFormatConstraintsInfoFUCHSIA {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageConstraintsInfoFUCHSIA.html>"]
pub struct ImageConstraintsInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub format_constraints_count: u32,
    pub p_format_constraints: *const ImageFormatConstraintsInfoFUCHSIA,
    pub buffer_collection_constraints: BufferCollectionConstraintsInfoFUCHSIA,
    pub flags: ImageConstraintsInfoFlagsFUCHSIA,
}
impl ::std::default::Default for ImageConstraintsInfoFUCHSIA {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            format_constraints_count: u32::default(),
            p_format_constraints: ::std::ptr::null(),
            buffer_collection_constraints: BufferCollectionConstraintsInfoFUCHSIA::default(),
            flags: ImageConstraintsInfoFlagsFUCHSIA::default(),
        }
    }
}
unsafe impl TaggedStructure for ImageConstraintsInfoFUCHSIA {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_CONSTRAINTS_INFO_FUCHSIA;
}
impl ImageConstraintsInfoFUCHSIA {
    pub fn builder<'a>() -> ImageConstraintsInfoFUCHSIABuilder<'a> {
        ImageConstraintsInfoFUCHSIABuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageConstraintsInfoFUCHSIABuilder<'a> {
    inner: ImageConstraintsInfoFUCHSIA,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ImageConstraintsInfoFUCHSIABuilder<'a> {
    type Target = ImageConstraintsInfoFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageConstraintsInfoFUCHSIABuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageConstraintsInfoFUCHSIABuilder<'a> {
    #[inline]
    pub fn format_constraints(
        mut self,
        format_constraints: &'a [ImageFormatConstraintsInfoFUCHSIA],
    ) -> Self {
        self.inner.format_constraints_count = format_constraints.len() as _;
        self.inner.p_format_constraints = format_constraints.as_ptr();
        self
    }
    #[inline]
    pub fn buffer_collection_constraints(
        mut self,
        buffer_collection_constraints: BufferCollectionConstraintsInfoFUCHSIA,
    ) -> Self {
        self.inner.buffer_collection_constraints = buffer_collection_constraints;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: ImageConstraintsInfoFlagsFUCHSIA) -> Self {
        self.inner.flags = flags;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageConstraintsInfoFUCHSIA {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCollectionConstraintsInfoFUCHSIA.html>"]
pub struct BufferCollectionConstraintsInfoFUCHSIA {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub min_buffer_count: u32,
    pub max_buffer_count: u32,
    pub min_buffer_count_for_camping: u32,
    pub min_buffer_count_for_dedicated_slack: u32,
    pub min_buffer_count_for_shared_slack: u32,
}
impl ::std::default::Default for BufferCollectionConstraintsInfoFUCHSIA {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            min_buffer_count: u32::default(),
            max_buffer_count: u32::default(),
            min_buffer_count_for_camping: u32::default(),
            min_buffer_count_for_dedicated_slack: u32::default(),
            min_buffer_count_for_shared_slack: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for BufferCollectionConstraintsInfoFUCHSIA {
    const STRUCTURE_TYPE: StructureType = StructureType::BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA;
}
impl BufferCollectionConstraintsInfoFUCHSIA {
    pub fn builder<'a>() -> BufferCollectionConstraintsInfoFUCHSIABuilder<'a> {
        BufferCollectionConstraintsInfoFUCHSIABuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct BufferCollectionConstraintsInfoFUCHSIABuilder<'a> {
    inner: BufferCollectionConstraintsInfoFUCHSIA,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for BufferCollectionConstraintsInfoFUCHSIABuilder<'a> {
    type Target = BufferCollectionConstraintsInfoFUCHSIA;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for BufferCollectionConstraintsInfoFUCHSIABuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> BufferCollectionConstraintsInfoFUCHSIABuilder<'a> {
    #[inline]
    pub fn min_buffer_count(mut self, min_buffer_count: u32) -> Self {
        self.inner.min_buffer_count = min_buffer_count;
        self
    }
    #[inline]
    pub fn max_buffer_count(mut self, max_buffer_count: u32) -> Self {
        self.inner.max_buffer_count = max_buffer_count;
        self
    }
    #[inline]
    pub fn min_buffer_count_for_camping(mut self, min_buffer_count_for_camping: u32) -> Self {
        self.inner.min_buffer_count_for_camping = min_buffer_count_for_camping;
        self
    }
    #[inline]
    pub fn min_buffer_count_for_dedicated_slack(
        mut self,
        min_buffer_count_for_dedicated_slack: u32,
    ) -> Self {
        self.inner.min_buffer_count_for_dedicated_slack = min_buffer_count_for_dedicated_slack;
        self
    }
    #[inline]
    pub fn min_buffer_count_for_shared_slack(
        mut self,
        min_buffer_count_for_shared_slack: u32,
    ) -> Self {
        self.inner.min_buffer_count_for_shared_slack = min_buffer_count_for_shared_slack;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> BufferCollectionConstraintsInfoFUCHSIA {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT.html>"]
pub struct PhysicalDeviceRGBA10X6FormatsFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub format_rgba10x6_without_y_cb_cr_sampler: Bool32,
}
impl ::std::default::Default for PhysicalDeviceRGBA10X6FormatsFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            format_rgba10x6_without_y_cb_cr_sampler: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceRGBA10X6FormatsFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT;
}
impl PhysicalDeviceRGBA10X6FormatsFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceRGBA10X6FormatsFeaturesEXTBuilder<'a> {
        PhysicalDeviceRGBA10X6FormatsFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceRGBA10X6FormatsFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceRGBA10X6FormatsFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRGBA10X6FormatsFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRGBA10X6FormatsFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRGBA10X6FormatsFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRGBA10X6FormatsFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceRGBA10X6FormatsFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceRGBA10X6FormatsFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceRGBA10X6FormatsFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceRGBA10X6FormatsFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn format_rgba10x6_without_y_cb_cr_sampler(
        mut self,
        format_rgba10x6_without_y_cb_cr_sampler: bool,
    ) -> Self {
        self.inner.format_rgba10x6_without_y_cb_cr_sampler =
            format_rgba10x6_without_y_cb_cr_sampler.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceRGBA10X6FormatsFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatProperties3.html>"]
pub struct FormatProperties3 {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub linear_tiling_features: FormatFeatureFlags2,
    pub optimal_tiling_features: FormatFeatureFlags2,
    pub buffer_features: FormatFeatureFlags2,
}
impl ::std::default::Default for FormatProperties3 {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            linear_tiling_features: FormatFeatureFlags2::default(),
            optimal_tiling_features: FormatFeatureFlags2::default(),
            buffer_features: FormatFeatureFlags2::default(),
        }
    }
}
unsafe impl TaggedStructure for FormatProperties3 {
    const STRUCTURE_TYPE: StructureType = StructureType::FORMAT_PROPERTIES_3;
}
impl FormatProperties3 {
    pub fn builder<'a>() -> FormatProperties3Builder<'a> {
        FormatProperties3Builder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct FormatProperties3Builder<'a> {
    inner: FormatProperties3,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsFormatProperties2 for FormatProperties3Builder<'_> {}
unsafe impl ExtendsFormatProperties2 for FormatProperties3 {}
impl<'a> ::std::ops::Deref for FormatProperties3Builder<'a> {
    type Target = FormatProperties3;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for FormatProperties3Builder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> FormatProperties3Builder<'a> {
    #[inline]
    pub fn linear_tiling_features(mut self, linear_tiling_features: FormatFeatureFlags2) -> Self {
        self.inner.linear_tiling_features = linear_tiling_features;
        self
    }
    #[inline]
    pub fn optimal_tiling_features(mut self, optimal_tiling_features: FormatFeatureFlags2) -> Self {
        self.inner.optimal_tiling_features = optimal_tiling_features;
        self
    }
    #[inline]
    pub fn buffer_features(mut self, buffer_features: FormatFeatureFlags2) -> Self {
        self.inner.buffer_features = buffer_features;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> FormatProperties3 {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrmFormatModifierPropertiesList2EXT.html>"]
pub struct DrmFormatModifierPropertiesList2EXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub drm_format_modifier_count: u32,
    pub p_drm_format_modifier_properties: *mut DrmFormatModifierProperties2EXT,
}
impl ::std::default::Default for DrmFormatModifierPropertiesList2EXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            drm_format_modifier_count: u32::default(),
            p_drm_format_modifier_properties: ::std::ptr::null_mut(),
        }
    }
}
unsafe impl TaggedStructure for DrmFormatModifierPropertiesList2EXT {
    const STRUCTURE_TYPE: StructureType = StructureType::DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT;
}
impl DrmFormatModifierPropertiesList2EXT {
    pub fn builder<'a>() -> DrmFormatModifierPropertiesList2EXTBuilder<'a> {
        DrmFormatModifierPropertiesList2EXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DrmFormatModifierPropertiesList2EXTBuilder<'a> {
    inner: DrmFormatModifierPropertiesList2EXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsFormatProperties2 for DrmFormatModifierPropertiesList2EXTBuilder<'_> {}
unsafe impl ExtendsFormatProperties2 for DrmFormatModifierPropertiesList2EXT {}
impl<'a> ::std::ops::Deref for DrmFormatModifierPropertiesList2EXTBuilder<'a> {
    type Target = DrmFormatModifierPropertiesList2EXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DrmFormatModifierPropertiesList2EXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DrmFormatModifierPropertiesList2EXTBuilder<'a> {
    #[inline]
    pub fn drm_format_modifier_properties(
        mut self,
        drm_format_modifier_properties: &'a mut [DrmFormatModifierProperties2EXT],
    ) -> Self {
        self.inner.drm_format_modifier_count = drm_format_modifier_properties.len() as _;
        self.inner.p_drm_format_modifier_properties = drm_format_modifier_properties.as_mut_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DrmFormatModifierPropertiesList2EXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrmFormatModifierProperties2EXT.html>"]
pub struct DrmFormatModifierProperties2EXT {
    pub drm_format_modifier: u64,
    pub drm_format_modifier_plane_count: u32,
    pub drm_format_modifier_tiling_features: FormatFeatureFlags2,
}
impl DrmFormatModifierProperties2EXT {
    pub fn builder<'a>() -> DrmFormatModifierProperties2EXTBuilder<'a> {
        DrmFormatModifierProperties2EXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DrmFormatModifierProperties2EXTBuilder<'a> {
    inner: DrmFormatModifierProperties2EXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DrmFormatModifierProperties2EXTBuilder<'a> {
    type Target = DrmFormatModifierProperties2EXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DrmFormatModifierProperties2EXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DrmFormatModifierProperties2EXTBuilder<'a> {
    #[inline]
    pub fn drm_format_modifier(mut self, drm_format_modifier: u64) -> Self {
        self.inner.drm_format_modifier = drm_format_modifier;
        self
    }
    #[inline]
    pub fn drm_format_modifier_plane_count(mut self, drm_format_modifier_plane_count: u32) -> Self {
        self.inner.drm_format_modifier_plane_count = drm_format_modifier_plane_count;
        self
    }
    #[inline]
    pub fn drm_format_modifier_tiling_features(
        mut self,
        drm_format_modifier_tiling_features: FormatFeatureFlags2,
    ) -> Self {
        self.inner.drm_format_modifier_tiling_features = drm_format_modifier_tiling_features;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DrmFormatModifierProperties2EXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAndroidHardwareBufferFormatProperties2ANDROID.html>"]
pub struct AndroidHardwareBufferFormatProperties2ANDROID {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub format: Format,
    pub external_format: u64,
    pub format_features: FormatFeatureFlags2,
    pub sampler_ycbcr_conversion_components: ComponentMapping,
    pub suggested_ycbcr_model: SamplerYcbcrModelConversion,
    pub suggested_ycbcr_range: SamplerYcbcrRange,
    pub suggested_x_chroma_offset: ChromaLocation,
    pub suggested_y_chroma_offset: ChromaLocation,
}
impl ::std::default::Default for AndroidHardwareBufferFormatProperties2ANDROID {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            format: Format::default(),
            external_format: u64::default(),
            format_features: FormatFeatureFlags2::default(),
            sampler_ycbcr_conversion_components: ComponentMapping::default(),
            suggested_ycbcr_model: SamplerYcbcrModelConversion::default(),
            suggested_ycbcr_range: SamplerYcbcrRange::default(),
            suggested_x_chroma_offset: ChromaLocation::default(),
            suggested_y_chroma_offset: ChromaLocation::default(),
        }
    }
}
unsafe impl TaggedStructure for AndroidHardwareBufferFormatProperties2ANDROID {
    const STRUCTURE_TYPE: StructureType =
        StructureType::ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID;
}
impl AndroidHardwareBufferFormatProperties2ANDROID {
    pub fn builder<'a>() -> AndroidHardwareBufferFormatProperties2ANDROIDBuilder<'a> {
        AndroidHardwareBufferFormatProperties2ANDROIDBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AndroidHardwareBufferFormatProperties2ANDROIDBuilder<'a> {
    inner: AndroidHardwareBufferFormatProperties2ANDROID,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsAndroidHardwareBufferPropertiesANDROID
    for AndroidHardwareBufferFormatProperties2ANDROIDBuilder<'_>
{
}
unsafe impl ExtendsAndroidHardwareBufferPropertiesANDROID
    for AndroidHardwareBufferFormatProperties2ANDROID
{
}
impl<'a> ::std::ops::Deref for AndroidHardwareBufferFormatProperties2ANDROIDBuilder<'a> {
    type Target = AndroidHardwareBufferFormatProperties2ANDROID;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AndroidHardwareBufferFormatProperties2ANDROIDBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AndroidHardwareBufferFormatProperties2ANDROIDBuilder<'a> {
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.inner.format = format;
        self
    }
    #[inline]
    pub fn external_format(mut self, external_format: u64) -> Self {
        self.inner.external_format = external_format;
        self
    }
    #[inline]
    pub fn format_features(mut self, format_features: FormatFeatureFlags2) -> Self {
        self.inner.format_features = format_features;
        self
    }
    #[inline]
    pub fn sampler_ycbcr_conversion_components(
        mut self,
        sampler_ycbcr_conversion_components: ComponentMapping,
    ) -> Self {
        self.inner.sampler_ycbcr_conversion_components = sampler_ycbcr_conversion_components;
        self
    }
    #[inline]
    pub fn suggested_ycbcr_model(
        mut self,
        suggested_ycbcr_model: SamplerYcbcrModelConversion,
    ) -> Self {
        self.inner.suggested_ycbcr_model = suggested_ycbcr_model;
        self
    }
    #[inline]
    pub fn suggested_ycbcr_range(mut self, suggested_ycbcr_range: SamplerYcbcrRange) -> Self {
        self.inner.suggested_ycbcr_range = suggested_ycbcr_range;
        self
    }
    #[inline]
    pub fn suggested_x_chroma_offset(mut self, suggested_x_chroma_offset: ChromaLocation) -> Self {
        self.inner.suggested_x_chroma_offset = suggested_x_chroma_offset;
        self
    }
    #[inline]
    pub fn suggested_y_chroma_offset(mut self, suggested_y_chroma_offset: ChromaLocation) -> Self {
        self.inner.suggested_y_chroma_offset = suggested_y_chroma_offset;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AndroidHardwareBufferFormatProperties2ANDROID {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRenderingCreateInfo.html>"]
pub struct PipelineRenderingCreateInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub view_mask: u32,
    pub color_attachment_count: u32,
    pub p_color_attachment_formats: *const Format,
    pub depth_attachment_format: Format,
    pub stencil_attachment_format: Format,
}
impl ::std::default::Default for PipelineRenderingCreateInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            view_mask: u32::default(),
            color_attachment_count: u32::default(),
            p_color_attachment_formats: ::std::ptr::null(),
            depth_attachment_format: Format::default(),
            stencil_attachment_format: Format::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineRenderingCreateInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_RENDERING_CREATE_INFO;
}
impl PipelineRenderingCreateInfo {
    pub fn builder<'a>() -> PipelineRenderingCreateInfoBuilder<'a> {
        PipelineRenderingCreateInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineRenderingCreateInfoBuilder<'a> {
    inner: PipelineRenderingCreateInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsGraphicsPipelineCreateInfo for PipelineRenderingCreateInfoBuilder<'_> {}
unsafe impl ExtendsGraphicsPipelineCreateInfo for PipelineRenderingCreateInfo {}
impl<'a> ::std::ops::Deref for PipelineRenderingCreateInfoBuilder<'a> {
    type Target = PipelineRenderingCreateInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineRenderingCreateInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineRenderingCreateInfoBuilder<'a> {
    #[inline]
    pub fn view_mask(mut self, view_mask: u32) -> Self {
        self.inner.view_mask = view_mask;
        self
    }
    #[inline]
    pub fn color_attachment_formats(mut self, color_attachment_formats: &'a [Format]) -> Self {
        self.inner.color_attachment_count = color_attachment_formats.len() as _;
        self.inner.p_color_attachment_formats = color_attachment_formats.as_ptr();
        self
    }
    #[inline]
    pub fn depth_attachment_format(mut self, depth_attachment_format: Format) -> Self {
        self.inner.depth_attachment_format = depth_attachment_format;
        self
    }
    #[inline]
    pub fn stencil_attachment_format(mut self, stencil_attachment_format: Format) -> Self {
        self.inner.stencil_attachment_format = stencil_attachment_format;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineRenderingCreateInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingInfo.html>"]
pub struct RenderingInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: RenderingFlags,
    pub render_area: Rect2D,
    pub layer_count: u32,
    pub view_mask: u32,
    pub color_attachment_count: u32,
    pub p_color_attachments: *const RenderingAttachmentInfo,
    pub p_depth_attachment: *const RenderingAttachmentInfo,
    pub p_stencil_attachment: *const RenderingAttachmentInfo,
}
impl ::std::default::Default for RenderingInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: RenderingFlags::default(),
            render_area: Rect2D::default(),
            layer_count: u32::default(),
            view_mask: u32::default(),
            color_attachment_count: u32::default(),
            p_color_attachments: ::std::ptr::null(),
            p_depth_attachment: ::std::ptr::null(),
            p_stencil_attachment: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for RenderingInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::RENDERING_INFO;
}
impl RenderingInfo {
    pub fn builder<'a>() -> RenderingInfoBuilder<'a> {
        RenderingInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RenderingInfoBuilder<'a> {
    inner: RenderingInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsRenderingInfo {}
impl<'a> ::std::ops::Deref for RenderingInfoBuilder<'a> {
    type Target = RenderingInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RenderingInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RenderingInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: RenderingFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn render_area(mut self, render_area: Rect2D) -> Self {
        self.inner.render_area = render_area;
        self
    }
    #[inline]
    pub fn layer_count(mut self, layer_count: u32) -> Self {
        self.inner.layer_count = layer_count;
        self
    }
    #[inline]
    pub fn view_mask(mut self, view_mask: u32) -> Self {
        self.inner.view_mask = view_mask;
        self
    }
    #[inline]
    pub fn color_attachments(mut self, color_attachments: &'a [RenderingAttachmentInfo]) -> Self {
        self.inner.color_attachment_count = color_attachments.len() as _;
        self.inner.p_color_attachments = color_attachments.as_ptr();
        self
    }
    #[inline]
    pub fn depth_attachment(mut self, depth_attachment: &'a RenderingAttachmentInfo) -> Self {
        self.inner.p_depth_attachment = depth_attachment;
        self
    }
    #[inline]
    pub fn stencil_attachment(mut self, stencil_attachment: &'a RenderingAttachmentInfo) -> Self {
        self.inner.p_stencil_attachment = stencil_attachment;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsRenderingInfo>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RenderingInfo {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingAttachmentInfo.html>"]
pub struct RenderingAttachmentInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image_view: ImageView,
    pub image_layout: ImageLayout,
    pub resolve_mode: ResolveModeFlags,
    pub resolve_image_view: ImageView,
    pub resolve_image_layout: ImageLayout,
    pub load_op: AttachmentLoadOp,
    pub store_op: AttachmentStoreOp,
    pub clear_value: ClearValue,
}
#[cfg(feature = "debug")]
impl fmt::Debug for RenderingAttachmentInfo {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderingAttachmentInfo")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("image_view", &self.image_view)
            .field("image_layout", &self.image_layout)
            .field("resolve_mode", &self.resolve_mode)
            .field("resolve_image_view", &self.resolve_image_view)
            .field("resolve_image_layout", &self.resolve_image_layout)
            .field("load_op", &self.load_op)
            .field("store_op", &self.store_op)
            .field("clear_value", &"union")
            .finish()
    }
}
impl ::std::default::Default for RenderingAttachmentInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image_view: ImageView::default(),
            image_layout: ImageLayout::default(),
            resolve_mode: ResolveModeFlags::default(),
            resolve_image_view: ImageView::default(),
            resolve_image_layout: ImageLayout::default(),
            load_op: AttachmentLoadOp::default(),
            store_op: AttachmentStoreOp::default(),
            clear_value: ClearValue::default(),
        }
    }
}
unsafe impl TaggedStructure for RenderingAttachmentInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::RENDERING_ATTACHMENT_INFO;
}
impl RenderingAttachmentInfo {
    pub fn builder<'a>() -> RenderingAttachmentInfoBuilder<'a> {
        RenderingAttachmentInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RenderingAttachmentInfoBuilder<'a> {
    inner: RenderingAttachmentInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for RenderingAttachmentInfoBuilder<'a> {
    type Target = RenderingAttachmentInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RenderingAttachmentInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RenderingAttachmentInfoBuilder<'a> {
    #[inline]
    pub fn image_view(mut self, image_view: ImageView) -> Self {
        self.inner.image_view = image_view;
        self
    }
    #[inline]
    pub fn image_layout(mut self, image_layout: ImageLayout) -> Self {
        self.inner.image_layout = image_layout;
        self
    }
    #[inline]
    pub fn resolve_mode(mut self, resolve_mode: ResolveModeFlags) -> Self {
        self.inner.resolve_mode = resolve_mode;
        self
    }
    #[inline]
    pub fn resolve_image_view(mut self, resolve_image_view: ImageView) -> Self {
        self.inner.resolve_image_view = resolve_image_view;
        self
    }
    #[inline]
    pub fn resolve_image_layout(mut self, resolve_image_layout: ImageLayout) -> Self {
        self.inner.resolve_image_layout = resolve_image_layout;
        self
    }
    #[inline]
    pub fn load_op(mut self, load_op: AttachmentLoadOp) -> Self {
        self.inner.load_op = load_op;
        self
    }
    #[inline]
    pub fn store_op(mut self, store_op: AttachmentStoreOp) -> Self {
        self.inner.store_op = store_op;
        self
    }
    #[inline]
    pub fn clear_value(mut self, clear_value: ClearValue) -> Self {
        self.inner.clear_value = clear_value;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RenderingAttachmentInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingFragmentShadingRateAttachmentInfoKHR.html>"]
pub struct RenderingFragmentShadingRateAttachmentInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image_view: ImageView,
    pub image_layout: ImageLayout,
    pub shading_rate_attachment_texel_size: Extent2D,
}
impl ::std::default::Default for RenderingFragmentShadingRateAttachmentInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image_view: ImageView::default(),
            image_layout: ImageLayout::default(),
            shading_rate_attachment_texel_size: Extent2D::default(),
        }
    }
}
unsafe impl TaggedStructure for RenderingFragmentShadingRateAttachmentInfoKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR;
}
impl RenderingFragmentShadingRateAttachmentInfoKHR {
    pub fn builder<'a>() -> RenderingFragmentShadingRateAttachmentInfoKHRBuilder<'a> {
        RenderingFragmentShadingRateAttachmentInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RenderingFragmentShadingRateAttachmentInfoKHRBuilder<'a> {
    inner: RenderingFragmentShadingRateAttachmentInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsRenderingInfo for RenderingFragmentShadingRateAttachmentInfoKHRBuilder<'_> {}
unsafe impl ExtendsRenderingInfo for RenderingFragmentShadingRateAttachmentInfoKHR {}
impl<'a> ::std::ops::Deref for RenderingFragmentShadingRateAttachmentInfoKHRBuilder<'a> {
    type Target = RenderingFragmentShadingRateAttachmentInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RenderingFragmentShadingRateAttachmentInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RenderingFragmentShadingRateAttachmentInfoKHRBuilder<'a> {
    #[inline]
    pub fn image_view(mut self, image_view: ImageView) -> Self {
        self.inner.image_view = image_view;
        self
    }
    #[inline]
    pub fn image_layout(mut self, image_layout: ImageLayout) -> Self {
        self.inner.image_layout = image_layout;
        self
    }
    #[inline]
    pub fn shading_rate_attachment_texel_size(
        mut self,
        shading_rate_attachment_texel_size: Extent2D,
    ) -> Self {
        self.inner.shading_rate_attachment_texel_size = shading_rate_attachment_texel_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RenderingFragmentShadingRateAttachmentInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingFragmentDensityMapAttachmentInfoEXT.html>"]
pub struct RenderingFragmentDensityMapAttachmentInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image_view: ImageView,
    pub image_layout: ImageLayout,
}
impl ::std::default::Default for RenderingFragmentDensityMapAttachmentInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image_view: ImageView::default(),
            image_layout: ImageLayout::default(),
        }
    }
}
unsafe impl TaggedStructure for RenderingFragmentDensityMapAttachmentInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT;
}
impl RenderingFragmentDensityMapAttachmentInfoEXT {
    pub fn builder<'a>() -> RenderingFragmentDensityMapAttachmentInfoEXTBuilder<'a> {
        RenderingFragmentDensityMapAttachmentInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RenderingFragmentDensityMapAttachmentInfoEXTBuilder<'a> {
    inner: RenderingFragmentDensityMapAttachmentInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsRenderingInfo for RenderingFragmentDensityMapAttachmentInfoEXTBuilder<'_> {}
unsafe impl ExtendsRenderingInfo for RenderingFragmentDensityMapAttachmentInfoEXT {}
impl<'a> ::std::ops::Deref for RenderingFragmentDensityMapAttachmentInfoEXTBuilder<'a> {
    type Target = RenderingFragmentDensityMapAttachmentInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RenderingFragmentDensityMapAttachmentInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RenderingFragmentDensityMapAttachmentInfoEXTBuilder<'a> {
    #[inline]
    pub fn image_view(mut self, image_view: ImageView) -> Self {
        self.inner.image_view = image_view;
        self
    }
    #[inline]
    pub fn image_layout(mut self, image_layout: ImageLayout) -> Self {
        self.inner.image_layout = image_layout;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RenderingFragmentDensityMapAttachmentInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDynamicRenderingFeatures.html>"]
pub struct PhysicalDeviceDynamicRenderingFeatures {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub dynamic_rendering: Bool32,
}
impl ::std::default::Default for PhysicalDeviceDynamicRenderingFeatures {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            dynamic_rendering: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceDynamicRenderingFeatures {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES;
}
impl PhysicalDeviceDynamicRenderingFeatures {
    pub fn builder<'a>() -> PhysicalDeviceDynamicRenderingFeaturesBuilder<'a> {
        PhysicalDeviceDynamicRenderingFeaturesBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceDynamicRenderingFeaturesBuilder<'a> {
    inner: PhysicalDeviceDynamicRenderingFeatures,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDynamicRenderingFeaturesBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDynamicRenderingFeatures {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDynamicRenderingFeaturesBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDynamicRenderingFeatures {}
impl<'a> ::std::ops::Deref for PhysicalDeviceDynamicRenderingFeaturesBuilder<'a> {
    type Target = PhysicalDeviceDynamicRenderingFeatures;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceDynamicRenderingFeaturesBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceDynamicRenderingFeaturesBuilder<'a> {
    #[inline]
    pub fn dynamic_rendering(mut self, dynamic_rendering: bool) -> Self {
        self.inner.dynamic_rendering = dynamic_rendering.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceDynamicRenderingFeatures {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceRenderingInfo.html>"]
pub struct CommandBufferInheritanceRenderingInfo {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: RenderingFlags,
    pub view_mask: u32,
    pub color_attachment_count: u32,
    pub p_color_attachment_formats: *const Format,
    pub depth_attachment_format: Format,
    pub stencil_attachment_format: Format,
    pub rasterization_samples: SampleCountFlags,
}
impl ::std::default::Default for CommandBufferInheritanceRenderingInfo {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: RenderingFlags::default(),
            view_mask: u32::default(),
            color_attachment_count: u32::default(),
            p_color_attachment_formats: ::std::ptr::null(),
            depth_attachment_format: Format::default(),
            stencil_attachment_format: Format::default(),
            rasterization_samples: SampleCountFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for CommandBufferInheritanceRenderingInfo {
    const STRUCTURE_TYPE: StructureType = StructureType::COMMAND_BUFFER_INHERITANCE_RENDERING_INFO;
}
impl CommandBufferInheritanceRenderingInfo {
    pub fn builder<'a>() -> CommandBufferInheritanceRenderingInfoBuilder<'a> {
        CommandBufferInheritanceRenderingInfoBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CommandBufferInheritanceRenderingInfoBuilder<'a> {
    inner: CommandBufferInheritanceRenderingInfo,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsCommandBufferInheritanceInfo
    for CommandBufferInheritanceRenderingInfoBuilder<'_>
{
}
unsafe impl ExtendsCommandBufferInheritanceInfo for CommandBufferInheritanceRenderingInfo {}
impl<'a> ::std::ops::Deref for CommandBufferInheritanceRenderingInfoBuilder<'a> {
    type Target = CommandBufferInheritanceRenderingInfo;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CommandBufferInheritanceRenderingInfoBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CommandBufferInheritanceRenderingInfoBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: RenderingFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn view_mask(mut self, view_mask: u32) -> Self {
        self.inner.view_mask = view_mask;
        self
    }
    #[inline]
    pub fn color_attachment_formats(mut self, color_attachment_formats: &'a [Format]) -> Self {
        self.inner.color_attachment_count = color_attachment_formats.len() as _;
        self.inner.p_color_attachment_formats = color_attachment_formats.as_ptr();
        self
    }
    #[inline]
    pub fn depth_attachment_format(mut self, depth_attachment_format: Format) -> Self {
        self.inner.depth_attachment_format = depth_attachment_format;
        self
    }
    #[inline]
    pub fn stencil_attachment_format(mut self, stencil_attachment_format: Format) -> Self {
        self.inner.stencil_attachment_format = stencil_attachment_format;
        self
    }
    #[inline]
    pub fn rasterization_samples(mut self, rasterization_samples: SampleCountFlags) -> Self {
        self.inner.rasterization_samples = rasterization_samples;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CommandBufferInheritanceRenderingInfo {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentSampleCountInfoAMD.html>"]
pub struct AttachmentSampleCountInfoAMD {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub color_attachment_count: u32,
    pub p_color_attachment_samples: *const SampleCountFlags,
    pub depth_stencil_attachment_samples: SampleCountFlags,
}
impl ::std::default::Default for AttachmentSampleCountInfoAMD {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            color_attachment_count: u32::default(),
            p_color_attachment_samples: ::std::ptr::null(),
            depth_stencil_attachment_samples: SampleCountFlags::default(),
        }
    }
}
unsafe impl TaggedStructure for AttachmentSampleCountInfoAMD {
    const STRUCTURE_TYPE: StructureType = StructureType::ATTACHMENT_SAMPLE_COUNT_INFO_AMD;
}
impl AttachmentSampleCountInfoAMD {
    pub fn builder<'a>() -> AttachmentSampleCountInfoAMDBuilder<'a> {
        AttachmentSampleCountInfoAMDBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AttachmentSampleCountInfoAMDBuilder<'a> {
    inner: AttachmentSampleCountInfoAMD,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsCommandBufferInheritanceInfo for AttachmentSampleCountInfoAMDBuilder<'_> {}
unsafe impl ExtendsCommandBufferInheritanceInfo for AttachmentSampleCountInfoAMD {}
unsafe impl ExtendsGraphicsPipelineCreateInfo for AttachmentSampleCountInfoAMDBuilder<'_> {}
unsafe impl ExtendsGraphicsPipelineCreateInfo for AttachmentSampleCountInfoAMD {}
impl<'a> ::std::ops::Deref for AttachmentSampleCountInfoAMDBuilder<'a> {
    type Target = AttachmentSampleCountInfoAMD;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AttachmentSampleCountInfoAMDBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AttachmentSampleCountInfoAMDBuilder<'a> {
    #[inline]
    pub fn color_attachment_samples(
        mut self,
        color_attachment_samples: &'a [SampleCountFlags],
    ) -> Self {
        self.inner.color_attachment_count = color_attachment_samples.len() as _;
        self.inner.p_color_attachment_samples = color_attachment_samples.as_ptr();
        self
    }
    #[inline]
    pub fn depth_stencil_attachment_samples(
        mut self,
        depth_stencil_attachment_samples: SampleCountFlags,
    ) -> Self {
        self.inner.depth_stencil_attachment_samples = depth_stencil_attachment_samples;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AttachmentSampleCountInfoAMD {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMultiviewPerViewAttributesInfoNVX.html>"]
pub struct MultiviewPerViewAttributesInfoNVX {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub per_view_attributes: Bool32,
    pub per_view_attributes_position_x_only: Bool32,
}
impl ::std::default::Default for MultiviewPerViewAttributesInfoNVX {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            per_view_attributes: Bool32::default(),
            per_view_attributes_position_x_only: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for MultiviewPerViewAttributesInfoNVX {
    const STRUCTURE_TYPE: StructureType = StructureType::MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX;
}
impl MultiviewPerViewAttributesInfoNVX {
    pub fn builder<'a>() -> MultiviewPerViewAttributesInfoNVXBuilder<'a> {
        MultiviewPerViewAttributesInfoNVXBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MultiviewPerViewAttributesInfoNVXBuilder<'a> {
    inner: MultiviewPerViewAttributesInfoNVX,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsCommandBufferInheritanceInfo for MultiviewPerViewAttributesInfoNVXBuilder<'_> {}
unsafe impl ExtendsCommandBufferInheritanceInfo for MultiviewPerViewAttributesInfoNVX {}
unsafe impl ExtendsGraphicsPipelineCreateInfo for MultiviewPerViewAttributesInfoNVXBuilder<'_> {}
unsafe impl ExtendsGraphicsPipelineCreateInfo for MultiviewPerViewAttributesInfoNVX {}
unsafe impl ExtendsRenderingInfo for MultiviewPerViewAttributesInfoNVXBuilder<'_> {}
unsafe impl ExtendsRenderingInfo for MultiviewPerViewAttributesInfoNVX {}
impl<'a> ::std::ops::Deref for MultiviewPerViewAttributesInfoNVXBuilder<'a> {
    type Target = MultiviewPerViewAttributesInfoNVX;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MultiviewPerViewAttributesInfoNVXBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MultiviewPerViewAttributesInfoNVXBuilder<'a> {
    #[inline]
    pub fn per_view_attributes(mut self, per_view_attributes: bool) -> Self {
        self.inner.per_view_attributes = per_view_attributes.into();
        self
    }
    #[inline]
    pub fn per_view_attributes_position_x_only(
        mut self,
        per_view_attributes_position_x_only: bool,
    ) -> Self {
        self.inner.per_view_attributes_position_x_only = per_view_attributes_position_x_only.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MultiviewPerViewAttributesInfoNVX {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageViewMinLodFeaturesEXT.html>"]
pub struct PhysicalDeviceImageViewMinLodFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub min_lod: Bool32,
}
impl ::std::default::Default for PhysicalDeviceImageViewMinLodFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            min_lod: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceImageViewMinLodFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT;
}
impl PhysicalDeviceImageViewMinLodFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceImageViewMinLodFeaturesEXTBuilder<'a> {
        PhysicalDeviceImageViewMinLodFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceImageViewMinLodFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceImageViewMinLodFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceImageViewMinLodFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceImageViewMinLodFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceImageViewMinLodFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceImageViewMinLodFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceImageViewMinLodFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceImageViewMinLodFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceImageViewMinLodFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceImageViewMinLodFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn min_lod(mut self, min_lod: bool) -> Self {
        self.inner.min_lod = min_lod.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceImageViewMinLodFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewMinLodCreateInfoEXT.html>"]
pub struct ImageViewMinLodCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub min_lod: f32,
}
impl ::std::default::Default for ImageViewMinLodCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            min_lod: f32::default(),
        }
    }
}
unsafe impl TaggedStructure for ImageViewMinLodCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT;
}
impl ImageViewMinLodCreateInfoEXT {
    pub fn builder<'a>() -> ImageViewMinLodCreateInfoEXTBuilder<'a> {
        ImageViewMinLodCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageViewMinLodCreateInfoEXTBuilder<'a> {
    inner: ImageViewMinLodCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageViewCreateInfo for ImageViewMinLodCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsImageViewCreateInfo for ImageViewMinLodCreateInfoEXT {}
impl<'a> ::std::ops::Deref for ImageViewMinLodCreateInfoEXTBuilder<'a> {
    type Target = ImageViewMinLodCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageViewMinLodCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageViewMinLodCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn min_lod(mut self, min_lod: f32) -> Self {
        self.inner.min_lod = min_lod;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageViewMinLodCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT.html>"]
pub struct PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub rasterization_order_color_attachment_access: Bool32,
    pub rasterization_order_depth_attachment_access: Bool32,
    pub rasterization_order_stencil_attachment_access: Bool32,
}
impl ::std::default::Default for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            rasterization_order_color_attachment_access: Bool32::default(),
            rasterization_order_depth_attachment_access: Bool32::default(),
            rasterization_order_stencil_attachment_access: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT;
}
impl PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXTBuilder<'a> {
        PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT
{
}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT
{
}
impl<'a> ::std::ops::Deref
    for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXTBuilder<'a>
{
    type Target = PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut
    for PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXTBuilder<'a>
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn rasterization_order_color_attachment_access(
        mut self,
        rasterization_order_color_attachment_access: bool,
    ) -> Self {
        self.inner.rasterization_order_color_attachment_access =
            rasterization_order_color_attachment_access.into();
        self
    }
    #[inline]
    pub fn rasterization_order_depth_attachment_access(
        mut self,
        rasterization_order_depth_attachment_access: bool,
    ) -> Self {
        self.inner.rasterization_order_depth_attachment_access =
            rasterization_order_depth_attachment_access.into();
        self
    }
    #[inline]
    pub fn rasterization_order_stencil_attachment_access(
        mut self,
        rasterization_order_stencil_attachment_access: bool,
    ) -> Self {
        self.inner.rasterization_order_stencil_attachment_access =
            rasterization_order_stencil_attachment_access.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLinearColorAttachmentFeaturesNV.html>"]
pub struct PhysicalDeviceLinearColorAttachmentFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub linear_color_attachment: Bool32,
}
impl ::std::default::Default for PhysicalDeviceLinearColorAttachmentFeaturesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            linear_color_attachment: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceLinearColorAttachmentFeaturesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV;
}
impl PhysicalDeviceLinearColorAttachmentFeaturesNV {
    pub fn builder<'a>() -> PhysicalDeviceLinearColorAttachmentFeaturesNVBuilder<'a> {
        PhysicalDeviceLinearColorAttachmentFeaturesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceLinearColorAttachmentFeaturesNVBuilder<'a> {
    inner: PhysicalDeviceLinearColorAttachmentFeaturesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceLinearColorAttachmentFeaturesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceLinearColorAttachmentFeaturesNV {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceLinearColorAttachmentFeaturesNVBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceLinearColorAttachmentFeaturesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceLinearColorAttachmentFeaturesNVBuilder<'a> {
    type Target = PhysicalDeviceLinearColorAttachmentFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceLinearColorAttachmentFeaturesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceLinearColorAttachmentFeaturesNVBuilder<'a> {
    #[inline]
    pub fn linear_color_attachment(mut self, linear_color_attachment: bool) -> Self {
        self.inner.linear_color_attachment = linear_color_attachment.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceLinearColorAttachmentFeaturesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT.html>"]
pub struct PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub graphics_pipeline_library: Bool32,
}
impl ::std::default::Default for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            graphics_pipeline_library: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT;
}
impl PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceGraphicsPipelineLibraryFeaturesEXTBuilder<'a> {
        PhysicalDeviceGraphicsPipelineLibraryFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceGraphicsPipelineLibraryFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceGraphicsPipelineLibraryFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceGraphicsPipelineLibraryFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn graphics_pipeline_library(mut self, graphics_pipeline_library: bool) -> Self {
        self.inner.graphics_pipeline_library = graphics_pipeline_library.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT.html>"]
pub struct PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub graphics_pipeline_library_fast_linking: Bool32,
    pub graphics_pipeline_library_independent_interpolation_decoration: Bool32,
}
impl ::std::default::Default for PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            graphics_pipeline_library_fast_linking: Bool32::default(),
            graphics_pipeline_library_independent_interpolation_decoration: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT;
}
impl PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceGraphicsPipelineLibraryPropertiesEXTBuilder<'a> {
        PhysicalDeviceGraphicsPipelineLibraryPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceGraphicsPipelineLibraryPropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceGraphicsPipelineLibraryPropertiesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT
{
}
impl<'a> ::std::ops::Deref for PhysicalDeviceGraphicsPipelineLibraryPropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceGraphicsPipelineLibraryPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceGraphicsPipelineLibraryPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn graphics_pipeline_library_fast_linking(
        mut self,
        graphics_pipeline_library_fast_linking: bool,
    ) -> Self {
        self.inner.graphics_pipeline_library_fast_linking =
            graphics_pipeline_library_fast_linking.into();
        self
    }
    #[inline]
    pub fn graphics_pipeline_library_independent_interpolation_decoration(
        mut self,
        graphics_pipeline_library_independent_interpolation_decoration: bool,
    ) -> Self {
        self.inner
            .graphics_pipeline_library_independent_interpolation_decoration =
            graphics_pipeline_library_independent_interpolation_decoration.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGraphicsPipelineLibraryCreateInfoEXT.html>"]
pub struct GraphicsPipelineLibraryCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub flags: GraphicsPipelineLibraryFlagsEXT,
}
impl ::std::default::Default for GraphicsPipelineLibraryCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            flags: GraphicsPipelineLibraryFlagsEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for GraphicsPipelineLibraryCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT;
}
impl GraphicsPipelineLibraryCreateInfoEXT {
    pub fn builder<'a>() -> GraphicsPipelineLibraryCreateInfoEXTBuilder<'a> {
        GraphicsPipelineLibraryCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct GraphicsPipelineLibraryCreateInfoEXTBuilder<'a> {
    inner: GraphicsPipelineLibraryCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsGraphicsPipelineCreateInfo for GraphicsPipelineLibraryCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsGraphicsPipelineCreateInfo for GraphicsPipelineLibraryCreateInfoEXT {}
impl<'a> ::std::ops::Deref for GraphicsPipelineLibraryCreateInfoEXTBuilder<'a> {
    type Target = GraphicsPipelineLibraryCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for GraphicsPipelineLibraryCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> GraphicsPipelineLibraryCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: GraphicsPipelineLibraryFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> GraphicsPipelineLibraryCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE.html>"]
pub struct PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub descriptor_set_host_mapping: Bool32,
}
impl ::std::default::Default for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            descriptor_set_host_mapping: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE;
}
impl PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {
    pub fn builder<'a>() -> PhysicalDeviceDescriptorSetHostMappingFeaturesVALVEBuilder<'a> {
        PhysicalDeviceDescriptorSetHostMappingFeaturesVALVEBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceDescriptorSetHostMappingFeaturesVALVEBuilder<'a> {
    inner: PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVEBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVEBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {}
impl<'a> ::std::ops::Deref for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVEBuilder<'a> {
    type Target = PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceDescriptorSetHostMappingFeaturesVALVEBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceDescriptorSetHostMappingFeaturesVALVEBuilder<'a> {
    #[inline]
    pub fn descriptor_set_host_mapping(mut self, descriptor_set_host_mapping: bool) -> Self {
        self.inner.descriptor_set_host_mapping = descriptor_set_host_mapping.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetBindingReferenceVALVE.html>"]
pub struct DescriptorSetBindingReferenceVALVE {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub descriptor_set_layout: DescriptorSetLayout,
    pub binding: u32,
}
impl ::std::default::Default for DescriptorSetBindingReferenceVALVE {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            descriptor_set_layout: DescriptorSetLayout::default(),
            binding: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for DescriptorSetBindingReferenceVALVE {
    const STRUCTURE_TYPE: StructureType = StructureType::DESCRIPTOR_SET_BINDING_REFERENCE_VALVE;
}
impl DescriptorSetBindingReferenceVALVE {
    pub fn builder<'a>() -> DescriptorSetBindingReferenceVALVEBuilder<'a> {
        DescriptorSetBindingReferenceVALVEBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DescriptorSetBindingReferenceVALVEBuilder<'a> {
    inner: DescriptorSetBindingReferenceVALVE,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DescriptorSetBindingReferenceVALVEBuilder<'a> {
    type Target = DescriptorSetBindingReferenceVALVE;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DescriptorSetBindingReferenceVALVEBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DescriptorSetBindingReferenceVALVEBuilder<'a> {
    #[inline]
    pub fn descriptor_set_layout(mut self, descriptor_set_layout: DescriptorSetLayout) -> Self {
        self.inner.descriptor_set_layout = descriptor_set_layout;
        self
    }
    #[inline]
    pub fn binding(mut self, binding: u32) -> Self {
        self.inner.binding = binding;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DescriptorSetBindingReferenceVALVE {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutHostMappingInfoVALVE.html>"]
pub struct DescriptorSetLayoutHostMappingInfoVALVE {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub descriptor_offset: usize,
    pub descriptor_size: u32,
}
impl ::std::default::Default for DescriptorSetLayoutHostMappingInfoVALVE {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            descriptor_offset: usize::default(),
            descriptor_size: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for DescriptorSetLayoutHostMappingInfoVALVE {
    const STRUCTURE_TYPE: StructureType =
        StructureType::DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE;
}
impl DescriptorSetLayoutHostMappingInfoVALVE {
    pub fn builder<'a>() -> DescriptorSetLayoutHostMappingInfoVALVEBuilder<'a> {
        DescriptorSetLayoutHostMappingInfoVALVEBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DescriptorSetLayoutHostMappingInfoVALVEBuilder<'a> {
    inner: DescriptorSetLayoutHostMappingInfoVALVE,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DescriptorSetLayoutHostMappingInfoVALVEBuilder<'a> {
    type Target = DescriptorSetLayoutHostMappingInfoVALVE;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DescriptorSetLayoutHostMappingInfoVALVEBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DescriptorSetLayoutHostMappingInfoVALVEBuilder<'a> {
    #[inline]
    pub fn descriptor_offset(mut self, descriptor_offset: usize) -> Self {
        self.inner.descriptor_offset = descriptor_offset;
        self
    }
    #[inline]
    pub fn descriptor_size(mut self, descriptor_size: u32) -> Self {
        self.inner.descriptor_size = descriptor_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DescriptorSetLayoutHostMappingInfoVALVE {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT.html>"]
pub struct PhysicalDeviceShaderModuleIdentifierFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_module_identifier: Bool32,
}
impl ::std::default::Default for PhysicalDeviceShaderModuleIdentifierFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_module_identifier: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderModuleIdentifierFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT;
}
impl PhysicalDeviceShaderModuleIdentifierFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceShaderModuleIdentifierFeaturesEXTBuilder<'a> {
        PhysicalDeviceShaderModuleIdentifierFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderModuleIdentifierFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceShaderModuleIdentifierFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceShaderModuleIdentifierFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderModuleIdentifierFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderModuleIdentifierFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderModuleIdentifierFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderModuleIdentifierFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceShaderModuleIdentifierFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderModuleIdentifierFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderModuleIdentifierFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn shader_module_identifier(mut self, shader_module_identifier: bool) -> Self {
        self.inner.shader_module_identifier = shader_module_identifier.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderModuleIdentifierFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT.html>"]
pub struct PhysicalDeviceShaderModuleIdentifierPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_module_identifier_algorithm_uuid: [u8; UUID_SIZE],
}
impl ::std::default::Default for PhysicalDeviceShaderModuleIdentifierPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_module_identifier_algorithm_uuid: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderModuleIdentifierPropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT;
}
impl PhysicalDeviceShaderModuleIdentifierPropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceShaderModuleIdentifierPropertiesEXTBuilder<'a> {
        PhysicalDeviceShaderModuleIdentifierPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderModuleIdentifierPropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceShaderModuleIdentifierPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceShaderModuleIdentifierPropertiesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceShaderModuleIdentifierPropertiesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderModuleIdentifierPropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceShaderModuleIdentifierPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderModuleIdentifierPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderModuleIdentifierPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn shader_module_identifier_algorithm_uuid(
        mut self,
        shader_module_identifier_algorithm_uuid: [u8; UUID_SIZE],
    ) -> Self {
        self.inner.shader_module_identifier_algorithm_uuid =
            shader_module_identifier_algorithm_uuid;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderModuleIdentifierPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageModuleIdentifierCreateInfoEXT.html>"]
pub struct PipelineShaderStageModuleIdentifierCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub identifier_size: u32,
    pub p_identifier: *const u8,
}
impl ::std::default::Default for PipelineShaderStageModuleIdentifierCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            identifier_size: u32::default(),
            p_identifier: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for PipelineShaderStageModuleIdentifierCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT;
}
impl PipelineShaderStageModuleIdentifierCreateInfoEXT {
    pub fn builder<'a>() -> PipelineShaderStageModuleIdentifierCreateInfoEXTBuilder<'a> {
        PipelineShaderStageModuleIdentifierCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineShaderStageModuleIdentifierCreateInfoEXTBuilder<'a> {
    inner: PipelineShaderStageModuleIdentifierCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPipelineShaderStageCreateInfo
    for PipelineShaderStageModuleIdentifierCreateInfoEXTBuilder<'_>
{
}
unsafe impl ExtendsPipelineShaderStageCreateInfo
    for PipelineShaderStageModuleIdentifierCreateInfoEXT
{
}
impl<'a> ::std::ops::Deref for PipelineShaderStageModuleIdentifierCreateInfoEXTBuilder<'a> {
    type Target = PipelineShaderStageModuleIdentifierCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineShaderStageModuleIdentifierCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineShaderStageModuleIdentifierCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn identifier(mut self, identifier: &'a [u8]) -> Self {
        self.inner.identifier_size = identifier.len() as _;
        self.inner.p_identifier = identifier.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineShaderStageModuleIdentifierCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderModuleIdentifierEXT.html>"]
pub struct ShaderModuleIdentifierEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub identifier_size: u32,
    pub identifier: [u8; MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT],
}
impl ::std::default::Default for ShaderModuleIdentifierEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            identifier_size: u32::default(),
            identifier: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for ShaderModuleIdentifierEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::SHADER_MODULE_IDENTIFIER_EXT;
}
impl ShaderModuleIdentifierEXT {
    pub fn builder<'a>() -> ShaderModuleIdentifierEXTBuilder<'a> {
        ShaderModuleIdentifierEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ShaderModuleIdentifierEXTBuilder<'a> {
    inner: ShaderModuleIdentifierEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ShaderModuleIdentifierEXTBuilder<'a> {
    type Target = ShaderModuleIdentifierEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ShaderModuleIdentifierEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ShaderModuleIdentifierEXTBuilder<'a> {
    #[inline]
    pub fn identifier_size(mut self, identifier_size: u32) -> Self {
        self.inner.identifier_size = identifier_size;
        self
    }
    #[inline]
    pub fn identifier(mut self, identifier: [u8; MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT]) -> Self {
        self.inner.identifier = identifier;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ShaderModuleIdentifierEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCompressionControlEXT.html>"]
pub struct ImageCompressionControlEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ImageCompressionFlagsEXT,
    pub compression_control_plane_count: u32,
    pub p_fixed_rate_flags: *mut ImageCompressionFixedRateFlagsEXT,
}
impl ::std::default::Default for ImageCompressionControlEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: ImageCompressionFlagsEXT::default(),
            compression_control_plane_count: u32::default(),
            p_fixed_rate_flags: ::std::ptr::null_mut(),
        }
    }
}
unsafe impl TaggedStructure for ImageCompressionControlEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_COMPRESSION_CONTROL_EXT;
}
impl ImageCompressionControlEXT {
    pub fn builder<'a>() -> ImageCompressionControlEXTBuilder<'a> {
        ImageCompressionControlEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageCompressionControlEXTBuilder<'a> {
    inner: ImageCompressionControlEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageCreateInfo for ImageCompressionControlEXTBuilder<'_> {}
unsafe impl ExtendsImageCreateInfo for ImageCompressionControlEXT {}
unsafe impl ExtendsSwapchainCreateInfoKHR for ImageCompressionControlEXTBuilder<'_> {}
unsafe impl ExtendsSwapchainCreateInfoKHR for ImageCompressionControlEXT {}
unsafe impl ExtendsPhysicalDeviceImageFormatInfo2 for ImageCompressionControlEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceImageFormatInfo2 for ImageCompressionControlEXT {}
impl<'a> ::std::ops::Deref for ImageCompressionControlEXTBuilder<'a> {
    type Target = ImageCompressionControlEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageCompressionControlEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageCompressionControlEXTBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: ImageCompressionFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn fixed_rate_flags(
        mut self,
        fixed_rate_flags: &'a mut [ImageCompressionFixedRateFlagsEXT],
    ) -> Self {
        self.inner.compression_control_plane_count = fixed_rate_flags.len() as _;
        self.inner.p_fixed_rate_flags = fixed_rate_flags.as_mut_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageCompressionControlEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageCompressionControlFeaturesEXT.html>"]
pub struct PhysicalDeviceImageCompressionControlFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_compression_control: Bool32,
}
impl ::std::default::Default for PhysicalDeviceImageCompressionControlFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            image_compression_control: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceImageCompressionControlFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT;
}
impl PhysicalDeviceImageCompressionControlFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceImageCompressionControlFeaturesEXTBuilder<'a> {
        PhysicalDeviceImageCompressionControlFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceImageCompressionControlFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceImageCompressionControlFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceImageCompressionControlFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceImageCompressionControlFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceImageCompressionControlFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceImageCompressionControlFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceImageCompressionControlFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceImageCompressionControlFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceImageCompressionControlFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceImageCompressionControlFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn image_compression_control(mut self, image_compression_control: bool) -> Self {
        self.inner.image_compression_control = image_compression_control.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceImageCompressionControlFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCompressionPropertiesEXT.html>"]
pub struct ImageCompressionPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_compression_flags: ImageCompressionFlagsEXT,
    pub image_compression_fixed_rate_flags: ImageCompressionFixedRateFlagsEXT,
}
impl ::std::default::Default for ImageCompressionPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            image_compression_flags: ImageCompressionFlagsEXT::default(),
            image_compression_fixed_rate_flags: ImageCompressionFixedRateFlagsEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for ImageCompressionPropertiesEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_COMPRESSION_PROPERTIES_EXT;
}
impl ImageCompressionPropertiesEXT {
    pub fn builder<'a>() -> ImageCompressionPropertiesEXTBuilder<'a> {
        ImageCompressionPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageCompressionPropertiesEXTBuilder<'a> {
    inner: ImageCompressionPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageFormatProperties2 for ImageCompressionPropertiesEXTBuilder<'_> {}
unsafe impl ExtendsImageFormatProperties2 for ImageCompressionPropertiesEXT {}
unsafe impl ExtendsSurfaceFormat2KHR for ImageCompressionPropertiesEXTBuilder<'_> {}
unsafe impl ExtendsSurfaceFormat2KHR for ImageCompressionPropertiesEXT {}
unsafe impl ExtendsSubresourceLayout2EXT for ImageCompressionPropertiesEXTBuilder<'_> {}
unsafe impl ExtendsSubresourceLayout2EXT for ImageCompressionPropertiesEXT {}
impl<'a> ::std::ops::Deref for ImageCompressionPropertiesEXTBuilder<'a> {
    type Target = ImageCompressionPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageCompressionPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageCompressionPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn image_compression_flags(
        mut self,
        image_compression_flags: ImageCompressionFlagsEXT,
    ) -> Self {
        self.inner.image_compression_flags = image_compression_flags;
        self
    }
    #[inline]
    pub fn image_compression_fixed_rate_flags(
        mut self,
        image_compression_fixed_rate_flags: ImageCompressionFixedRateFlagsEXT,
    ) -> Self {
        self.inner.image_compression_fixed_rate_flags = image_compression_fixed_rate_flags;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageCompressionPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT.html>"]
pub struct PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_compression_control_swapchain: Bool32,
}
impl ::std::default::Default for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            image_compression_control_swapchain: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT;
}
impl PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceImageCompressionControlSwapchainFeaturesEXTBuilder<'a> {
        PhysicalDeviceImageCompressionControlSwapchainFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceImageCompressionControlSwapchainFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT
{
}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {}
impl<'a> ::std::ops::Deref
    for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXTBuilder<'a>
{
    type Target = PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut
    for PhysicalDeviceImageCompressionControlSwapchainFeaturesEXTBuilder<'a>
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceImageCompressionControlSwapchainFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn image_compression_control_swapchain(
        mut self,
        image_compression_control_swapchain: bool,
    ) -> Self {
        self.inner.image_compression_control_swapchain = image_compression_control_swapchain.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSubresource2EXT.html>"]
pub struct ImageSubresource2EXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub image_subresource: ImageSubresource,
}
impl ::std::default::Default for ImageSubresource2EXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            image_subresource: ImageSubresource::default(),
        }
    }
}
unsafe impl TaggedStructure for ImageSubresource2EXT {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_SUBRESOURCE_2_EXT;
}
impl ImageSubresource2EXT {
    pub fn builder<'a>() -> ImageSubresource2EXTBuilder<'a> {
        ImageSubresource2EXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageSubresource2EXTBuilder<'a> {
    inner: ImageSubresource2EXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ImageSubresource2EXTBuilder<'a> {
    type Target = ImageSubresource2EXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageSubresource2EXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageSubresource2EXTBuilder<'a> {
    #[inline]
    pub fn image_subresource(mut self, image_subresource: ImageSubresource) -> Self {
        self.inner.image_subresource = image_subresource;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageSubresource2EXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubresourceLayout2EXT.html>"]
pub struct SubresourceLayout2EXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub subresource_layout: SubresourceLayout,
}
impl ::std::default::Default for SubresourceLayout2EXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            subresource_layout: SubresourceLayout::default(),
        }
    }
}
unsafe impl TaggedStructure for SubresourceLayout2EXT {
    const STRUCTURE_TYPE: StructureType = StructureType::SUBRESOURCE_LAYOUT_2_EXT;
}
impl SubresourceLayout2EXT {
    pub fn builder<'a>() -> SubresourceLayout2EXTBuilder<'a> {
        SubresourceLayout2EXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SubresourceLayout2EXTBuilder<'a> {
    inner: SubresourceLayout2EXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsSubresourceLayout2EXT {}
impl<'a> ::std::ops::Deref for SubresourceLayout2EXTBuilder<'a> {
    type Target = SubresourceLayout2EXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SubresourceLayout2EXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SubresourceLayout2EXTBuilder<'a> {
    #[inline]
    pub fn subresource_layout(mut self, subresource_layout: SubresourceLayout) -> Self {
        self.inner.subresource_layout = subresource_layout;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsSubresourceLayout2EXT>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SubresourceLayout2EXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreationControlEXT.html>"]
pub struct RenderPassCreationControlEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub disallow_merging: Bool32,
}
impl ::std::default::Default for RenderPassCreationControlEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            disallow_merging: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for RenderPassCreationControlEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::RENDER_PASS_CREATION_CONTROL_EXT;
}
impl RenderPassCreationControlEXT {
    pub fn builder<'a>() -> RenderPassCreationControlEXTBuilder<'a> {
        RenderPassCreationControlEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RenderPassCreationControlEXTBuilder<'a> {
    inner: RenderPassCreationControlEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsRenderPassCreateInfo2 for RenderPassCreationControlEXTBuilder<'_> {}
unsafe impl ExtendsRenderPassCreateInfo2 for RenderPassCreationControlEXT {}
unsafe impl ExtendsSubpassDescription2 for RenderPassCreationControlEXTBuilder<'_> {}
unsafe impl ExtendsSubpassDescription2 for RenderPassCreationControlEXT {}
impl<'a> ::std::ops::Deref for RenderPassCreationControlEXTBuilder<'a> {
    type Target = RenderPassCreationControlEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RenderPassCreationControlEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RenderPassCreationControlEXTBuilder<'a> {
    #[inline]
    pub fn disallow_merging(mut self, disallow_merging: bool) -> Self {
        self.inner.disallow_merging = disallow_merging.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RenderPassCreationControlEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreationFeedbackInfoEXT.html>"]
pub struct RenderPassCreationFeedbackInfoEXT {
    pub post_merge_subpass_count: u32,
}
impl RenderPassCreationFeedbackInfoEXT {
    pub fn builder<'a>() -> RenderPassCreationFeedbackInfoEXTBuilder<'a> {
        RenderPassCreationFeedbackInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RenderPassCreationFeedbackInfoEXTBuilder<'a> {
    inner: RenderPassCreationFeedbackInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for RenderPassCreationFeedbackInfoEXTBuilder<'a> {
    type Target = RenderPassCreationFeedbackInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RenderPassCreationFeedbackInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RenderPassCreationFeedbackInfoEXTBuilder<'a> {
    #[inline]
    pub fn post_merge_subpass_count(mut self, post_merge_subpass_count: u32) -> Self {
        self.inner.post_merge_subpass_count = post_merge_subpass_count;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RenderPassCreationFeedbackInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreationFeedbackCreateInfoEXT.html>"]
pub struct RenderPassCreationFeedbackCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_render_pass_feedback: *mut RenderPassCreationFeedbackInfoEXT,
}
impl ::std::default::Default for RenderPassCreationFeedbackCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_render_pass_feedback: ::std::ptr::null_mut(),
        }
    }
}
unsafe impl TaggedStructure for RenderPassCreationFeedbackCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT;
}
impl RenderPassCreationFeedbackCreateInfoEXT {
    pub fn builder<'a>() -> RenderPassCreationFeedbackCreateInfoEXTBuilder<'a> {
        RenderPassCreationFeedbackCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RenderPassCreationFeedbackCreateInfoEXTBuilder<'a> {
    inner: RenderPassCreationFeedbackCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsRenderPassCreateInfo2 for RenderPassCreationFeedbackCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsRenderPassCreateInfo2 for RenderPassCreationFeedbackCreateInfoEXT {}
impl<'a> ::std::ops::Deref for RenderPassCreationFeedbackCreateInfoEXTBuilder<'a> {
    type Target = RenderPassCreationFeedbackCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RenderPassCreationFeedbackCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RenderPassCreationFeedbackCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn render_pass_feedback(
        mut self,
        render_pass_feedback: &'a mut RenderPassCreationFeedbackInfoEXT,
    ) -> Self {
        self.inner.p_render_pass_feedback = render_pass_feedback;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RenderPassCreationFeedbackCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassSubpassFeedbackInfoEXT.html>"]
pub struct RenderPassSubpassFeedbackInfoEXT {
    pub subpass_merge_status: SubpassMergeStatusEXT,
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
    pub post_merge_index: u32,
}
#[cfg(feature = "debug")]
impl fmt::Debug for RenderPassSubpassFeedbackInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("RenderPassSubpassFeedbackInfoEXT")
            .field("subpass_merge_status", &self.subpass_merge_status)
            .field("description", &unsafe {
                ::std::ffi::CStr::from_ptr(self.description.as_ptr())
            })
            .field("post_merge_index", &self.post_merge_index)
            .finish()
    }
}
impl ::std::default::Default for RenderPassSubpassFeedbackInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            subpass_merge_status: SubpassMergeStatusEXT::default(),
            description: unsafe { ::std::mem::zeroed() },
            post_merge_index: u32::default(),
        }
    }
}
impl RenderPassSubpassFeedbackInfoEXT {
    pub fn builder<'a>() -> RenderPassSubpassFeedbackInfoEXTBuilder<'a> {
        RenderPassSubpassFeedbackInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RenderPassSubpassFeedbackInfoEXTBuilder<'a> {
    inner: RenderPassSubpassFeedbackInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for RenderPassSubpassFeedbackInfoEXTBuilder<'a> {
    type Target = RenderPassSubpassFeedbackInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RenderPassSubpassFeedbackInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RenderPassSubpassFeedbackInfoEXTBuilder<'a> {
    #[inline]
    pub fn subpass_merge_status(mut self, subpass_merge_status: SubpassMergeStatusEXT) -> Self {
        self.inner.subpass_merge_status = subpass_merge_status;
        self
    }
    #[inline]
    pub fn description(mut self, description: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.inner.description = description;
        self
    }
    #[inline]
    pub fn post_merge_index(mut self, post_merge_index: u32) -> Self {
        self.inner.post_merge_index = post_merge_index;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RenderPassSubpassFeedbackInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassSubpassFeedbackCreateInfoEXT.html>"]
pub struct RenderPassSubpassFeedbackCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_subpass_feedback: *mut RenderPassSubpassFeedbackInfoEXT,
}
impl ::std::default::Default for RenderPassSubpassFeedbackCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_subpass_feedback: ::std::ptr::null_mut(),
        }
    }
}
unsafe impl TaggedStructure for RenderPassSubpassFeedbackCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT;
}
impl RenderPassSubpassFeedbackCreateInfoEXT {
    pub fn builder<'a>() -> RenderPassSubpassFeedbackCreateInfoEXTBuilder<'a> {
        RenderPassSubpassFeedbackCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct RenderPassSubpassFeedbackCreateInfoEXTBuilder<'a> {
    inner: RenderPassSubpassFeedbackCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSubpassDescription2 for RenderPassSubpassFeedbackCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsSubpassDescription2 for RenderPassSubpassFeedbackCreateInfoEXT {}
impl<'a> ::std::ops::Deref for RenderPassSubpassFeedbackCreateInfoEXTBuilder<'a> {
    type Target = RenderPassSubpassFeedbackCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for RenderPassSubpassFeedbackCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> RenderPassSubpassFeedbackCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn subpass_feedback(
        mut self,
        subpass_feedback: &'a mut RenderPassSubpassFeedbackInfoEXT,
    ) -> Self {
        self.inner.p_subpass_feedback = subpass_feedback;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> RenderPassSubpassFeedbackCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT.html>"]
pub struct PhysicalDeviceSubpassMergeFeedbackFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub subpass_merge_feedback: Bool32,
}
impl ::std::default::Default for PhysicalDeviceSubpassMergeFeedbackFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            subpass_merge_feedback: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceSubpassMergeFeedbackFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT;
}
impl PhysicalDeviceSubpassMergeFeedbackFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceSubpassMergeFeedbackFeaturesEXTBuilder<'a> {
        PhysicalDeviceSubpassMergeFeedbackFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceSubpassMergeFeedbackFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceSubpassMergeFeedbackFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceSubpassMergeFeedbackFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceSubpassMergeFeedbackFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSubpassMergeFeedbackFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSubpassMergeFeedbackFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceSubpassMergeFeedbackFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceSubpassMergeFeedbackFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceSubpassMergeFeedbackFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceSubpassMergeFeedbackFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn subpass_merge_feedback(mut self, subpass_merge_feedback: bool) -> Self {
        self.inner.subpass_merge_feedback = subpass_merge_feedback.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceSubpassMergeFeedbackFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMicromapBuildInfoEXT.html>"]
pub struct MicromapBuildInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub ty: MicromapTypeEXT,
    pub flags: BuildMicromapFlagsEXT,
    pub mode: BuildMicromapModeEXT,
    pub dst_micromap: MicromapEXT,
    pub usage_counts_count: u32,
    pub p_usage_counts: *const MicromapUsageEXT,
    pub pp_usage_counts: *const *const MicromapUsageEXT,
    pub data: DeviceOrHostAddressConstKHR,
    pub scratch_data: DeviceOrHostAddressKHR,
    pub triangle_array: DeviceOrHostAddressConstKHR,
    pub triangle_array_stride: DeviceSize,
}
#[cfg(feature = "debug")]
impl fmt::Debug for MicromapBuildInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("MicromapBuildInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("ty", &self.ty)
            .field("flags", &self.flags)
            .field("mode", &self.mode)
            .field("dst_micromap", &self.dst_micromap)
            .field("usage_counts_count", &self.usage_counts_count)
            .field("p_usage_counts", &self.p_usage_counts)
            .field("pp_usage_counts", &self.pp_usage_counts)
            .field("data", &"union")
            .field("scratch_data", &"union")
            .field("triangle_array", &"union")
            .field("triangle_array_stride", &self.triangle_array_stride)
            .finish()
    }
}
impl ::std::default::Default for MicromapBuildInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            ty: MicromapTypeEXT::default(),
            flags: BuildMicromapFlagsEXT::default(),
            mode: BuildMicromapModeEXT::default(),
            dst_micromap: MicromapEXT::default(),
            usage_counts_count: u32::default(),
            p_usage_counts: ::std::ptr::null(),
            pp_usage_counts: ::std::ptr::null(),
            data: DeviceOrHostAddressConstKHR::default(),
            scratch_data: DeviceOrHostAddressKHR::default(),
            triangle_array: DeviceOrHostAddressConstKHR::default(),
            triangle_array_stride: DeviceSize::default(),
        }
    }
}
unsafe impl TaggedStructure for MicromapBuildInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::MICROMAP_BUILD_INFO_EXT;
}
impl MicromapBuildInfoEXT {
    pub fn builder<'a>() -> MicromapBuildInfoEXTBuilder<'a> {
        MicromapBuildInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MicromapBuildInfoEXTBuilder<'a> {
    inner: MicromapBuildInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MicromapBuildInfoEXTBuilder<'a> {
    type Target = MicromapBuildInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MicromapBuildInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MicromapBuildInfoEXTBuilder<'a> {
    #[inline]
    pub fn ty(mut self, ty: MicromapTypeEXT) -> Self {
        self.inner.ty = ty;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: BuildMicromapFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn mode(mut self, mode: BuildMicromapModeEXT) -> Self {
        self.inner.mode = mode;
        self
    }
    #[inline]
    pub fn dst_micromap(mut self, dst_micromap: MicromapEXT) -> Self {
        self.inner.dst_micromap = dst_micromap;
        self
    }
    #[inline]
    pub fn usage_counts(mut self, usage_counts: &'a [MicromapUsageEXT]) -> Self {
        self.inner.usage_counts_count = usage_counts.len() as _;
        self.inner.p_usage_counts = usage_counts.as_ptr();
        self
    }
    #[inline]
    pub fn usage_counts_ptrs(mut self, usage_counts_ptrs: &'a [&'a MicromapUsageEXT]) -> Self {
        self.inner.usage_counts_count = usage_counts_ptrs.len() as _;
        self.inner.pp_usage_counts = usage_counts_ptrs.as_ptr().cast();
        self
    }
    #[inline]
    pub fn data(mut self, data: DeviceOrHostAddressConstKHR) -> Self {
        self.inner.data = data;
        self
    }
    #[inline]
    pub fn scratch_data(mut self, scratch_data: DeviceOrHostAddressKHR) -> Self {
        self.inner.scratch_data = scratch_data;
        self
    }
    #[inline]
    pub fn triangle_array(mut self, triangle_array: DeviceOrHostAddressConstKHR) -> Self {
        self.inner.triangle_array = triangle_array;
        self
    }
    #[inline]
    pub fn triangle_array_stride(mut self, triangle_array_stride: DeviceSize) -> Self {
        self.inner.triangle_array_stride = triangle_array_stride;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MicromapBuildInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMicromapCreateInfoEXT.html>"]
pub struct MicromapCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub create_flags: MicromapCreateFlagsEXT,
    pub buffer: Buffer,
    pub offset: DeviceSize,
    pub size: DeviceSize,
    pub ty: MicromapTypeEXT,
    pub device_address: DeviceAddress,
}
impl ::std::default::Default for MicromapCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            create_flags: MicromapCreateFlagsEXT::default(),
            buffer: Buffer::default(),
            offset: DeviceSize::default(),
            size: DeviceSize::default(),
            ty: MicromapTypeEXT::default(),
            device_address: DeviceAddress::default(),
        }
    }
}
unsafe impl TaggedStructure for MicromapCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::MICROMAP_CREATE_INFO_EXT;
}
impl MicromapCreateInfoEXT {
    pub fn builder<'a>() -> MicromapCreateInfoEXTBuilder<'a> {
        MicromapCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MicromapCreateInfoEXTBuilder<'a> {
    inner: MicromapCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MicromapCreateInfoEXTBuilder<'a> {
    type Target = MicromapCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MicromapCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MicromapCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn create_flags(mut self, create_flags: MicromapCreateFlagsEXT) -> Self {
        self.inner.create_flags = create_flags;
        self
    }
    #[inline]
    pub fn buffer(mut self, buffer: Buffer) -> Self {
        self.inner.buffer = buffer;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: DeviceSize) -> Self {
        self.inner.offset = offset;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    #[inline]
    pub fn ty(mut self, ty: MicromapTypeEXT) -> Self {
        self.inner.ty = ty;
        self
    }
    #[inline]
    pub fn device_address(mut self, device_address: DeviceAddress) -> Self {
        self.inner.device_address = device_address;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MicromapCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMicromapVersionInfoEXT.html>"]
pub struct MicromapVersionInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_version_data: *const [u8; 2 * UUID_SIZE],
}
impl ::std::default::Default for MicromapVersionInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_version_data: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for MicromapVersionInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::MICROMAP_VERSION_INFO_EXT;
}
impl MicromapVersionInfoEXT {
    pub fn builder<'a>() -> MicromapVersionInfoEXTBuilder<'a> {
        MicromapVersionInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MicromapVersionInfoEXTBuilder<'a> {
    inner: MicromapVersionInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MicromapVersionInfoEXTBuilder<'a> {
    type Target = MicromapVersionInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MicromapVersionInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MicromapVersionInfoEXTBuilder<'a> {
    #[inline]
    pub fn version_data(mut self, version_data: &'a [u8; 2 * UUID_SIZE]) -> Self {
        self.inner.p_version_data = version_data;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MicromapVersionInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyMicromapInfoEXT.html>"]
pub struct CopyMicromapInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src: MicromapEXT,
    pub dst: MicromapEXT,
    pub mode: CopyMicromapModeEXT,
}
impl ::std::default::Default for CopyMicromapInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src: MicromapEXT::default(),
            dst: MicromapEXT::default(),
            mode: CopyMicromapModeEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for CopyMicromapInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::COPY_MICROMAP_INFO_EXT;
}
impl CopyMicromapInfoEXT {
    pub fn builder<'a>() -> CopyMicromapInfoEXTBuilder<'a> {
        CopyMicromapInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CopyMicromapInfoEXTBuilder<'a> {
    inner: CopyMicromapInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CopyMicromapInfoEXTBuilder<'a> {
    type Target = CopyMicromapInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CopyMicromapInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CopyMicromapInfoEXTBuilder<'a> {
    #[inline]
    pub fn src(mut self, src: MicromapEXT) -> Self {
        self.inner.src = src;
        self
    }
    #[inline]
    pub fn dst(mut self, dst: MicromapEXT) -> Self {
        self.inner.dst = dst;
        self
    }
    #[inline]
    pub fn mode(mut self, mode: CopyMicromapModeEXT) -> Self {
        self.inner.mode = mode;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CopyMicromapInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyMicromapToMemoryInfoEXT.html>"]
pub struct CopyMicromapToMemoryInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src: MicromapEXT,
    pub dst: DeviceOrHostAddressKHR,
    pub mode: CopyMicromapModeEXT,
}
#[cfg(feature = "debug")]
impl fmt::Debug for CopyMicromapToMemoryInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CopyMicromapToMemoryInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src", &self.src)
            .field("dst", &"union")
            .field("mode", &self.mode)
            .finish()
    }
}
impl ::std::default::Default for CopyMicromapToMemoryInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src: MicromapEXT::default(),
            dst: DeviceOrHostAddressKHR::default(),
            mode: CopyMicromapModeEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for CopyMicromapToMemoryInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::COPY_MICROMAP_TO_MEMORY_INFO_EXT;
}
impl CopyMicromapToMemoryInfoEXT {
    pub fn builder<'a>() -> CopyMicromapToMemoryInfoEXTBuilder<'a> {
        CopyMicromapToMemoryInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CopyMicromapToMemoryInfoEXTBuilder<'a> {
    inner: CopyMicromapToMemoryInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CopyMicromapToMemoryInfoEXTBuilder<'a> {
    type Target = CopyMicromapToMemoryInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CopyMicromapToMemoryInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CopyMicromapToMemoryInfoEXTBuilder<'a> {
    #[inline]
    pub fn src(mut self, src: MicromapEXT) -> Self {
        self.inner.src = src;
        self
    }
    #[inline]
    pub fn dst(mut self, dst: DeviceOrHostAddressKHR) -> Self {
        self.inner.dst = dst;
        self
    }
    #[inline]
    pub fn mode(mut self, mode: CopyMicromapModeEXT) -> Self {
        self.inner.mode = mode;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CopyMicromapToMemoryInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyMemoryToMicromapInfoEXT.html>"]
pub struct CopyMemoryToMicromapInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub src: DeviceOrHostAddressConstKHR,
    pub dst: MicromapEXT,
    pub mode: CopyMicromapModeEXT,
}
#[cfg(feature = "debug")]
impl fmt::Debug for CopyMemoryToMicromapInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("CopyMemoryToMicromapInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("src", &"union")
            .field("dst", &self.dst)
            .field("mode", &self.mode)
            .finish()
    }
}
impl ::std::default::Default for CopyMemoryToMicromapInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            src: DeviceOrHostAddressConstKHR::default(),
            dst: MicromapEXT::default(),
            mode: CopyMicromapModeEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for CopyMemoryToMicromapInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::COPY_MEMORY_TO_MICROMAP_INFO_EXT;
}
impl CopyMemoryToMicromapInfoEXT {
    pub fn builder<'a>() -> CopyMemoryToMicromapInfoEXTBuilder<'a> {
        CopyMemoryToMicromapInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct CopyMemoryToMicromapInfoEXTBuilder<'a> {
    inner: CopyMemoryToMicromapInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for CopyMemoryToMicromapInfoEXTBuilder<'a> {
    type Target = CopyMemoryToMicromapInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for CopyMemoryToMicromapInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> CopyMemoryToMicromapInfoEXTBuilder<'a> {
    #[inline]
    pub fn src(mut self, src: DeviceOrHostAddressConstKHR) -> Self {
        self.inner.src = src;
        self
    }
    #[inline]
    pub fn dst(mut self, dst: MicromapEXT) -> Self {
        self.inner.dst = dst;
        self
    }
    #[inline]
    pub fn mode(mut self, mode: CopyMicromapModeEXT) -> Self {
        self.inner.mode = mode;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> CopyMemoryToMicromapInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMicromapBuildSizesInfoEXT.html>"]
pub struct MicromapBuildSizesInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub micromap_size: DeviceSize,
    pub build_scratch_size: DeviceSize,
    pub discardable: Bool32,
}
impl ::std::default::Default for MicromapBuildSizesInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            micromap_size: DeviceSize::default(),
            build_scratch_size: DeviceSize::default(),
            discardable: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for MicromapBuildSizesInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::MICROMAP_BUILD_SIZES_INFO_EXT;
}
impl MicromapBuildSizesInfoEXT {
    pub fn builder<'a>() -> MicromapBuildSizesInfoEXTBuilder<'a> {
        MicromapBuildSizesInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MicromapBuildSizesInfoEXTBuilder<'a> {
    inner: MicromapBuildSizesInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MicromapBuildSizesInfoEXTBuilder<'a> {
    type Target = MicromapBuildSizesInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MicromapBuildSizesInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MicromapBuildSizesInfoEXTBuilder<'a> {
    #[inline]
    pub fn micromap_size(mut self, micromap_size: DeviceSize) -> Self {
        self.inner.micromap_size = micromap_size;
        self
    }
    #[inline]
    pub fn build_scratch_size(mut self, build_scratch_size: DeviceSize) -> Self {
        self.inner.build_scratch_size = build_scratch_size;
        self
    }
    #[inline]
    pub fn discardable(mut self, discardable: bool) -> Self {
        self.inner.discardable = discardable.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MicromapBuildSizesInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMicromapUsageEXT.html>"]
pub struct MicromapUsageEXT {
    pub count: u32,
    pub subdivision_level: u32,
    pub format: u32,
}
impl MicromapUsageEXT {
    pub fn builder<'a>() -> MicromapUsageEXTBuilder<'a> {
        MicromapUsageEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MicromapUsageEXTBuilder<'a> {
    inner: MicromapUsageEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MicromapUsageEXTBuilder<'a> {
    type Target = MicromapUsageEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MicromapUsageEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MicromapUsageEXTBuilder<'a> {
    #[inline]
    pub fn count(mut self, count: u32) -> Self {
        self.inner.count = count;
        self
    }
    #[inline]
    pub fn subdivision_level(mut self, subdivision_level: u32) -> Self {
        self.inner.subdivision_level = subdivision_level;
        self
    }
    #[inline]
    pub fn format(mut self, format: u32) -> Self {
        self.inner.format = format;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MicromapUsageEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMicromapTriangleEXT.html>"]
pub struct MicromapTriangleEXT {
    pub data_offset: u32,
    pub subdivision_level: u16,
    pub format: u16,
}
impl MicromapTriangleEXT {
    pub fn builder<'a>() -> MicromapTriangleEXTBuilder<'a> {
        MicromapTriangleEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MicromapTriangleEXTBuilder<'a> {
    inner: MicromapTriangleEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MicromapTriangleEXTBuilder<'a> {
    type Target = MicromapTriangleEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MicromapTriangleEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MicromapTriangleEXTBuilder<'a> {
    #[inline]
    pub fn data_offset(mut self, data_offset: u32) -> Self {
        self.inner.data_offset = data_offset;
        self
    }
    #[inline]
    pub fn subdivision_level(mut self, subdivision_level: u16) -> Self {
        self.inner.subdivision_level = subdivision_level;
        self
    }
    #[inline]
    pub fn format(mut self, format: u16) -> Self {
        self.inner.format = format;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MicromapTriangleEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceOpacityMicromapFeaturesEXT.html>"]
pub struct PhysicalDeviceOpacityMicromapFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub micromap: Bool32,
    pub micromap_capture_replay: Bool32,
    pub micromap_host_commands: Bool32,
}
impl ::std::default::Default for PhysicalDeviceOpacityMicromapFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            micromap: Bool32::default(),
            micromap_capture_replay: Bool32::default(),
            micromap_host_commands: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceOpacityMicromapFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT;
}
impl PhysicalDeviceOpacityMicromapFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceOpacityMicromapFeaturesEXTBuilder<'a> {
        PhysicalDeviceOpacityMicromapFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceOpacityMicromapFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceOpacityMicromapFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceOpacityMicromapFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceOpacityMicromapFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceOpacityMicromapFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceOpacityMicromapFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceOpacityMicromapFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceOpacityMicromapFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceOpacityMicromapFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceOpacityMicromapFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn micromap(mut self, micromap: bool) -> Self {
        self.inner.micromap = micromap.into();
        self
    }
    #[inline]
    pub fn micromap_capture_replay(mut self, micromap_capture_replay: bool) -> Self {
        self.inner.micromap_capture_replay = micromap_capture_replay.into();
        self
    }
    #[inline]
    pub fn micromap_host_commands(mut self, micromap_host_commands: bool) -> Self {
        self.inner.micromap_host_commands = micromap_host_commands.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceOpacityMicromapFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceOpacityMicromapPropertiesEXT.html>"]
pub struct PhysicalDeviceOpacityMicromapPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_opacity2_state_subdivision_level: u32,
    pub max_opacity4_state_subdivision_level: u32,
}
impl ::std::default::Default for PhysicalDeviceOpacityMicromapPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_opacity2_state_subdivision_level: u32::default(),
            max_opacity4_state_subdivision_level: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceOpacityMicromapPropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT;
}
impl PhysicalDeviceOpacityMicromapPropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceOpacityMicromapPropertiesEXTBuilder<'a> {
        PhysicalDeviceOpacityMicromapPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceOpacityMicromapPropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceOpacityMicromapPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceOpacityMicromapPropertiesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceOpacityMicromapPropertiesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceOpacityMicromapPropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceOpacityMicromapPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceOpacityMicromapPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceOpacityMicromapPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn max_opacity2_state_subdivision_level(
        mut self,
        max_opacity2_state_subdivision_level: u32,
    ) -> Self {
        self.inner.max_opacity2_state_subdivision_level = max_opacity2_state_subdivision_level;
        self
    }
    #[inline]
    pub fn max_opacity4_state_subdivision_level(
        mut self,
        max_opacity4_state_subdivision_level: u32,
    ) -> Self {
        self.inner.max_opacity4_state_subdivision_level = max_opacity4_state_subdivision_level;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceOpacityMicromapPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureTrianglesOpacityMicromapEXT.html>"]
pub struct AccelerationStructureTrianglesOpacityMicromapEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub index_type: IndexType,
    pub index_buffer: DeviceOrHostAddressConstKHR,
    pub index_stride: DeviceSize,
    pub base_triangle: u32,
    pub usage_counts_count: u32,
    pub p_usage_counts: *const MicromapUsageEXT,
    pub pp_usage_counts: *const *const MicromapUsageEXT,
    pub micromap: MicromapEXT,
}
#[cfg(feature = "debug")]
impl fmt::Debug for AccelerationStructureTrianglesOpacityMicromapEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureTrianglesOpacityMicromapEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("index_type", &self.index_type)
            .field("index_buffer", &"union")
            .field("index_stride", &self.index_stride)
            .field("base_triangle", &self.base_triangle)
            .field("usage_counts_count", &self.usage_counts_count)
            .field("p_usage_counts", &self.p_usage_counts)
            .field("pp_usage_counts", &self.pp_usage_counts)
            .field("micromap", &self.micromap)
            .finish()
    }
}
impl ::std::default::Default for AccelerationStructureTrianglesOpacityMicromapEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            index_type: IndexType::default(),
            index_buffer: DeviceOrHostAddressConstKHR::default(),
            index_stride: DeviceSize::default(),
            base_triangle: u32::default(),
            usage_counts_count: u32::default(),
            p_usage_counts: ::std::ptr::null(),
            pp_usage_counts: ::std::ptr::null(),
            micromap: MicromapEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for AccelerationStructureTrianglesOpacityMicromapEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT;
}
impl AccelerationStructureTrianglesOpacityMicromapEXT {
    pub fn builder<'a>() -> AccelerationStructureTrianglesOpacityMicromapEXTBuilder<'a> {
        AccelerationStructureTrianglesOpacityMicromapEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AccelerationStructureTrianglesOpacityMicromapEXTBuilder<'a> {
    inner: AccelerationStructureTrianglesOpacityMicromapEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsAccelerationStructureGeometryTrianglesDataKHR
    for AccelerationStructureTrianglesOpacityMicromapEXTBuilder<'_>
{
}
unsafe impl ExtendsAccelerationStructureGeometryTrianglesDataKHR
    for AccelerationStructureTrianglesOpacityMicromapEXT
{
}
impl<'a> ::std::ops::Deref for AccelerationStructureTrianglesOpacityMicromapEXTBuilder<'a> {
    type Target = AccelerationStructureTrianglesOpacityMicromapEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AccelerationStructureTrianglesOpacityMicromapEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AccelerationStructureTrianglesOpacityMicromapEXTBuilder<'a> {
    #[inline]
    pub fn index_type(mut self, index_type: IndexType) -> Self {
        self.inner.index_type = index_type;
        self
    }
    #[inline]
    pub fn index_buffer(mut self, index_buffer: DeviceOrHostAddressConstKHR) -> Self {
        self.inner.index_buffer = index_buffer;
        self
    }
    #[inline]
    pub fn index_stride(mut self, index_stride: DeviceSize) -> Self {
        self.inner.index_stride = index_stride;
        self
    }
    #[inline]
    pub fn base_triangle(mut self, base_triangle: u32) -> Self {
        self.inner.base_triangle = base_triangle;
        self
    }
    #[inline]
    pub fn usage_counts(mut self, usage_counts: &'a [MicromapUsageEXT]) -> Self {
        self.inner.usage_counts_count = usage_counts.len() as _;
        self.inner.p_usage_counts = usage_counts.as_ptr();
        self
    }
    #[inline]
    pub fn usage_counts_ptrs(mut self, usage_counts_ptrs: &'a [&'a MicromapUsageEXT]) -> Self {
        self.inner.usage_counts_count = usage_counts_ptrs.len() as _;
        self.inner.pp_usage_counts = usage_counts_ptrs.as_ptr().cast();
        self
    }
    #[inline]
    pub fn micromap(mut self, micromap: MicromapEXT) -> Self {
        self.inner.micromap = micromap;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AccelerationStructureTrianglesOpacityMicromapEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDisplacementMicromapFeaturesNV.html>"]
pub struct PhysicalDeviceDisplacementMicromapFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub displacement_micromap: Bool32,
}
impl ::std::default::Default for PhysicalDeviceDisplacementMicromapFeaturesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            displacement_micromap: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceDisplacementMicromapFeaturesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV;
}
impl PhysicalDeviceDisplacementMicromapFeaturesNV {
    pub fn builder<'a>() -> PhysicalDeviceDisplacementMicromapFeaturesNVBuilder<'a> {
        PhysicalDeviceDisplacementMicromapFeaturesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceDisplacementMicromapFeaturesNVBuilder<'a> {
    inner: PhysicalDeviceDisplacementMicromapFeaturesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceDisplacementMicromapFeaturesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDisplacementMicromapFeaturesNV {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDisplacementMicromapFeaturesNVBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDisplacementMicromapFeaturesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceDisplacementMicromapFeaturesNVBuilder<'a> {
    type Target = PhysicalDeviceDisplacementMicromapFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceDisplacementMicromapFeaturesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceDisplacementMicromapFeaturesNVBuilder<'a> {
    #[inline]
    pub fn displacement_micromap(mut self, displacement_micromap: bool) -> Self {
        self.inner.displacement_micromap = displacement_micromap.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceDisplacementMicromapFeaturesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDisplacementMicromapPropertiesNV.html>"]
pub struct PhysicalDeviceDisplacementMicromapPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_displacement_micromap_subdivision_level: u32,
}
impl ::std::default::Default for PhysicalDeviceDisplacementMicromapPropertiesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_displacement_micromap_subdivision_level: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceDisplacementMicromapPropertiesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV;
}
impl PhysicalDeviceDisplacementMicromapPropertiesNV {
    pub fn builder<'a>() -> PhysicalDeviceDisplacementMicromapPropertiesNVBuilder<'a> {
        PhysicalDeviceDisplacementMicromapPropertiesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceDisplacementMicromapPropertiesNVBuilder<'a> {
    inner: PhysicalDeviceDisplacementMicromapPropertiesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceDisplacementMicromapPropertiesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceDisplacementMicromapPropertiesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceDisplacementMicromapPropertiesNVBuilder<'a> {
    type Target = PhysicalDeviceDisplacementMicromapPropertiesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceDisplacementMicromapPropertiesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceDisplacementMicromapPropertiesNVBuilder<'a> {
    #[inline]
    pub fn max_displacement_micromap_subdivision_level(
        mut self,
        max_displacement_micromap_subdivision_level: u32,
    ) -> Self {
        self.inner.max_displacement_micromap_subdivision_level =
            max_displacement_micromap_subdivision_level;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceDisplacementMicromapPropertiesNV {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureTrianglesDisplacementMicromapNV.html>"]
pub struct AccelerationStructureTrianglesDisplacementMicromapNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub displacement_bias_and_scale_format: Format,
    pub displacement_vector_format: Format,
    pub displacement_bias_and_scale_buffer: DeviceOrHostAddressConstKHR,
    pub displacement_bias_and_scale_stride: DeviceSize,
    pub displacement_vector_buffer: DeviceOrHostAddressConstKHR,
    pub displacement_vector_stride: DeviceSize,
    pub displaced_micromap_primitive_flags: DeviceOrHostAddressConstKHR,
    pub displaced_micromap_primitive_flags_stride: DeviceSize,
    pub index_type: IndexType,
    pub index_buffer: DeviceOrHostAddressConstKHR,
    pub index_stride: DeviceSize,
    pub base_triangle: u32,
    pub usage_counts_count: u32,
    pub p_usage_counts: *const MicromapUsageEXT,
    pub pp_usage_counts: *const *const MicromapUsageEXT,
    pub micromap: MicromapEXT,
}
#[cfg(feature = "debug")]
impl fmt::Debug for AccelerationStructureTrianglesDisplacementMicromapNV {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("AccelerationStructureTrianglesDisplacementMicromapNV")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field(
                "displacement_bias_and_scale_format",
                &self.displacement_bias_and_scale_format,
            )
            .field(
                "displacement_vector_format",
                &self.displacement_vector_format,
            )
            .field("displacement_bias_and_scale_buffer", &"union")
            .field(
                "displacement_bias_and_scale_stride",
                &self.displacement_bias_and_scale_stride,
            )
            .field("displacement_vector_buffer", &"union")
            .field(
                "displacement_vector_stride",
                &self.displacement_vector_stride,
            )
            .field("displaced_micromap_primitive_flags", &"union")
            .field(
                "displaced_micromap_primitive_flags_stride",
                &self.displaced_micromap_primitive_flags_stride,
            )
            .field("index_type", &self.index_type)
            .field("index_buffer", &"union")
            .field("index_stride", &self.index_stride)
            .field("base_triangle", &self.base_triangle)
            .field("usage_counts_count", &self.usage_counts_count)
            .field("p_usage_counts", &self.p_usage_counts)
            .field("pp_usage_counts", &self.pp_usage_counts)
            .field("micromap", &self.micromap)
            .finish()
    }
}
impl ::std::default::Default for AccelerationStructureTrianglesDisplacementMicromapNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            displacement_bias_and_scale_format: Format::default(),
            displacement_vector_format: Format::default(),
            displacement_bias_and_scale_buffer: DeviceOrHostAddressConstKHR::default(),
            displacement_bias_and_scale_stride: DeviceSize::default(),
            displacement_vector_buffer: DeviceOrHostAddressConstKHR::default(),
            displacement_vector_stride: DeviceSize::default(),
            displaced_micromap_primitive_flags: DeviceOrHostAddressConstKHR::default(),
            displaced_micromap_primitive_flags_stride: DeviceSize::default(),
            index_type: IndexType::default(),
            index_buffer: DeviceOrHostAddressConstKHR::default(),
            index_stride: DeviceSize::default(),
            base_triangle: u32::default(),
            usage_counts_count: u32::default(),
            p_usage_counts: ::std::ptr::null(),
            pp_usage_counts: ::std::ptr::null(),
            micromap: MicromapEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for AccelerationStructureTrianglesDisplacementMicromapNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV;
}
impl AccelerationStructureTrianglesDisplacementMicromapNV {
    pub fn builder<'a>() -> AccelerationStructureTrianglesDisplacementMicromapNVBuilder<'a> {
        AccelerationStructureTrianglesDisplacementMicromapNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AccelerationStructureTrianglesDisplacementMicromapNVBuilder<'a> {
    inner: AccelerationStructureTrianglesDisplacementMicromapNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsAccelerationStructureGeometryTrianglesDataKHR
    for AccelerationStructureTrianglesDisplacementMicromapNVBuilder<'_>
{
}
unsafe impl ExtendsAccelerationStructureGeometryTrianglesDataKHR
    for AccelerationStructureTrianglesDisplacementMicromapNV
{
}
impl<'a> ::std::ops::Deref for AccelerationStructureTrianglesDisplacementMicromapNVBuilder<'a> {
    type Target = AccelerationStructureTrianglesDisplacementMicromapNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AccelerationStructureTrianglesDisplacementMicromapNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AccelerationStructureTrianglesDisplacementMicromapNVBuilder<'a> {
    #[inline]
    pub fn displacement_bias_and_scale_format(
        mut self,
        displacement_bias_and_scale_format: Format,
    ) -> Self {
        self.inner.displacement_bias_and_scale_format = displacement_bias_and_scale_format;
        self
    }
    #[inline]
    pub fn displacement_vector_format(mut self, displacement_vector_format: Format) -> Self {
        self.inner.displacement_vector_format = displacement_vector_format;
        self
    }
    #[inline]
    pub fn displacement_bias_and_scale_buffer(
        mut self,
        displacement_bias_and_scale_buffer: DeviceOrHostAddressConstKHR,
    ) -> Self {
        self.inner.displacement_bias_and_scale_buffer = displacement_bias_and_scale_buffer;
        self
    }
    #[inline]
    pub fn displacement_bias_and_scale_stride(
        mut self,
        displacement_bias_and_scale_stride: DeviceSize,
    ) -> Self {
        self.inner.displacement_bias_and_scale_stride = displacement_bias_and_scale_stride;
        self
    }
    #[inline]
    pub fn displacement_vector_buffer(
        mut self,
        displacement_vector_buffer: DeviceOrHostAddressConstKHR,
    ) -> Self {
        self.inner.displacement_vector_buffer = displacement_vector_buffer;
        self
    }
    #[inline]
    pub fn displacement_vector_stride(mut self, displacement_vector_stride: DeviceSize) -> Self {
        self.inner.displacement_vector_stride = displacement_vector_stride;
        self
    }
    #[inline]
    pub fn displaced_micromap_primitive_flags(
        mut self,
        displaced_micromap_primitive_flags: DeviceOrHostAddressConstKHR,
    ) -> Self {
        self.inner.displaced_micromap_primitive_flags = displaced_micromap_primitive_flags;
        self
    }
    #[inline]
    pub fn displaced_micromap_primitive_flags_stride(
        mut self,
        displaced_micromap_primitive_flags_stride: DeviceSize,
    ) -> Self {
        self.inner.displaced_micromap_primitive_flags_stride =
            displaced_micromap_primitive_flags_stride;
        self
    }
    #[inline]
    pub fn index_type(mut self, index_type: IndexType) -> Self {
        self.inner.index_type = index_type;
        self
    }
    #[inline]
    pub fn index_buffer(mut self, index_buffer: DeviceOrHostAddressConstKHR) -> Self {
        self.inner.index_buffer = index_buffer;
        self
    }
    #[inline]
    pub fn index_stride(mut self, index_stride: DeviceSize) -> Self {
        self.inner.index_stride = index_stride;
        self
    }
    #[inline]
    pub fn base_triangle(mut self, base_triangle: u32) -> Self {
        self.inner.base_triangle = base_triangle;
        self
    }
    #[inline]
    pub fn usage_counts(mut self, usage_counts: &'a [MicromapUsageEXT]) -> Self {
        self.inner.usage_counts_count = usage_counts.len() as _;
        self.inner.p_usage_counts = usage_counts.as_ptr();
        self
    }
    #[inline]
    pub fn usage_counts_ptrs(mut self, usage_counts_ptrs: &'a [&'a MicromapUsageEXT]) -> Self {
        self.inner.usage_counts_count = usage_counts_ptrs.len() as _;
        self.inner.pp_usage_counts = usage_counts_ptrs.as_ptr().cast();
        self
    }
    #[inline]
    pub fn micromap(mut self, micromap: MicromapEXT) -> Self {
        self.inner.micromap = micromap;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AccelerationStructureTrianglesDisplacementMicromapNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelinePropertiesIdentifierEXT.html>"]
pub struct PipelinePropertiesIdentifierEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pipeline_identifier: [u8; UUID_SIZE],
}
impl ::std::default::Default for PipelinePropertiesIdentifierEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            pipeline_identifier: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for PipelinePropertiesIdentifierEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_PROPERTIES_IDENTIFIER_EXT;
}
impl PipelinePropertiesIdentifierEXT {
    pub fn builder<'a>() -> PipelinePropertiesIdentifierEXTBuilder<'a> {
        PipelinePropertiesIdentifierEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelinePropertiesIdentifierEXTBuilder<'a> {
    inner: PipelinePropertiesIdentifierEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for PipelinePropertiesIdentifierEXTBuilder<'a> {
    type Target = PipelinePropertiesIdentifierEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelinePropertiesIdentifierEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelinePropertiesIdentifierEXTBuilder<'a> {
    #[inline]
    pub fn pipeline_identifier(mut self, pipeline_identifier: [u8; UUID_SIZE]) -> Self {
        self.inner.pipeline_identifier = pipeline_identifier;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelinePropertiesIdentifierEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelinePropertiesFeaturesEXT.html>"]
pub struct PhysicalDevicePipelinePropertiesFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pipeline_properties_identifier: Bool32,
}
impl ::std::default::Default for PhysicalDevicePipelinePropertiesFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            pipeline_properties_identifier: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevicePipelinePropertiesFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT;
}
impl PhysicalDevicePipelinePropertiesFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDevicePipelinePropertiesFeaturesEXTBuilder<'a> {
        PhysicalDevicePipelinePropertiesFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevicePipelinePropertiesFeaturesEXTBuilder<'a> {
    inner: PhysicalDevicePipelinePropertiesFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDevicePipelinePropertiesFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePipelinePropertiesFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePipelinePropertiesFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePipelinePropertiesFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDevicePipelinePropertiesFeaturesEXTBuilder<'a> {
    type Target = PhysicalDevicePipelinePropertiesFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevicePipelinePropertiesFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevicePipelinePropertiesFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn pipeline_properties_identifier(mut self, pipeline_properties_identifier: bool) -> Self {
        self.inner.pipeline_properties_identifier = pipeline_properties_identifier.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevicePipelinePropertiesFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD.html>"]
pub struct PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_early_and_late_fragment_tests: Bool32,
}
impl ::std::default::Default for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_early_and_late_fragment_tests: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD;
}
impl PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {
    pub fn builder<'a>() -> PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMDBuilder<'a> {
        PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMDBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMDBuilder<'a> {
    inner: PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMDBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD
{
}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMDBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMDBuilder<'a> {
    type Target = PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut
    for PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMDBuilder<'a>
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMDBuilder<'a> {
    #[inline]
    pub fn shader_early_and_late_fragment_tests(
        mut self,
        shader_early_and_late_fragment_tests: bool,
    ) -> Self {
        self.inner.shader_early_and_late_fragment_tests =
            shader_early_and_late_fragment_tests.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMetalObjectCreateInfoEXT.html>"]
pub struct ExportMetalObjectCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub export_object_type: ExportMetalObjectTypeFlagsEXT,
}
impl ::std::default::Default for ExportMetalObjectCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            export_object_type: ExportMetalObjectTypeFlagsEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for ExportMetalObjectCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_METAL_OBJECT_CREATE_INFO_EXT;
}
impl ExportMetalObjectCreateInfoEXT {
    pub fn builder<'a>() -> ExportMetalObjectCreateInfoEXTBuilder<'a> {
        ExportMetalObjectCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExportMetalObjectCreateInfoEXTBuilder<'a> {
    inner: ExportMetalObjectCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsInstanceCreateInfo for ExportMetalObjectCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsInstanceCreateInfo for ExportMetalObjectCreateInfoEXT {}
unsafe impl ExtendsMemoryAllocateInfo for ExportMetalObjectCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsMemoryAllocateInfo for ExportMetalObjectCreateInfoEXT {}
unsafe impl ExtendsImageCreateInfo for ExportMetalObjectCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsImageCreateInfo for ExportMetalObjectCreateInfoEXT {}
unsafe impl ExtendsImageViewCreateInfo for ExportMetalObjectCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsImageViewCreateInfo for ExportMetalObjectCreateInfoEXT {}
unsafe impl ExtendsBufferViewCreateInfo for ExportMetalObjectCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsBufferViewCreateInfo for ExportMetalObjectCreateInfoEXT {}
unsafe impl ExtendsSemaphoreCreateInfo for ExportMetalObjectCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsSemaphoreCreateInfo for ExportMetalObjectCreateInfoEXT {}
unsafe impl ExtendsEventCreateInfo for ExportMetalObjectCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsEventCreateInfo for ExportMetalObjectCreateInfoEXT {}
impl<'a> ::std::ops::Deref for ExportMetalObjectCreateInfoEXTBuilder<'a> {
    type Target = ExportMetalObjectCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExportMetalObjectCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExportMetalObjectCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn export_object_type(mut self, export_object_type: ExportMetalObjectTypeFlagsEXT) -> Self {
        self.inner.export_object_type = export_object_type;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExportMetalObjectCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMetalObjectsInfoEXT.html>"]
pub struct ExportMetalObjectsInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
}
impl ::std::default::Default for ExportMetalObjectsInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for ExportMetalObjectsInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_METAL_OBJECTS_INFO_EXT;
}
impl ExportMetalObjectsInfoEXT {
    pub fn builder<'a>() -> ExportMetalObjectsInfoEXTBuilder<'a> {
        ExportMetalObjectsInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExportMetalObjectsInfoEXTBuilder<'a> {
    inner: ExportMetalObjectsInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsExportMetalObjectsInfoEXT {}
impl<'a> ::std::ops::Deref for ExportMetalObjectsInfoEXTBuilder<'a> {
    type Target = ExportMetalObjectsInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExportMetalObjectsInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExportMetalObjectsInfoEXTBuilder<'a> {
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsExportMetalObjectsInfoEXT>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExportMetalObjectsInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMetalDeviceInfoEXT.html>"]
pub struct ExportMetalDeviceInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub mtl_device: MTLDevice_id,
}
impl ::std::default::Default for ExportMetalDeviceInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            mtl_device: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for ExportMetalDeviceInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_METAL_DEVICE_INFO_EXT;
}
impl ExportMetalDeviceInfoEXT {
    pub fn builder<'a>() -> ExportMetalDeviceInfoEXTBuilder<'a> {
        ExportMetalDeviceInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExportMetalDeviceInfoEXTBuilder<'a> {
    inner: ExportMetalDeviceInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsExportMetalObjectsInfoEXT for ExportMetalDeviceInfoEXTBuilder<'_> {}
unsafe impl ExtendsExportMetalObjectsInfoEXT for ExportMetalDeviceInfoEXT {}
impl<'a> ::std::ops::Deref for ExportMetalDeviceInfoEXTBuilder<'a> {
    type Target = ExportMetalDeviceInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExportMetalDeviceInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExportMetalDeviceInfoEXTBuilder<'a> {
    #[inline]
    pub fn mtl_device(mut self, mtl_device: MTLDevice_id) -> Self {
        self.inner.mtl_device = mtl_device;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExportMetalDeviceInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMetalCommandQueueInfoEXT.html>"]
pub struct ExportMetalCommandQueueInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub queue: Queue,
    pub mtl_command_queue: MTLCommandQueue_id,
}
impl ::std::default::Default for ExportMetalCommandQueueInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            queue: Queue::default(),
            mtl_command_queue: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for ExportMetalCommandQueueInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_METAL_COMMAND_QUEUE_INFO_EXT;
}
impl ExportMetalCommandQueueInfoEXT {
    pub fn builder<'a>() -> ExportMetalCommandQueueInfoEXTBuilder<'a> {
        ExportMetalCommandQueueInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExportMetalCommandQueueInfoEXTBuilder<'a> {
    inner: ExportMetalCommandQueueInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsExportMetalObjectsInfoEXT for ExportMetalCommandQueueInfoEXTBuilder<'_> {}
unsafe impl ExtendsExportMetalObjectsInfoEXT for ExportMetalCommandQueueInfoEXT {}
impl<'a> ::std::ops::Deref for ExportMetalCommandQueueInfoEXTBuilder<'a> {
    type Target = ExportMetalCommandQueueInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExportMetalCommandQueueInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExportMetalCommandQueueInfoEXTBuilder<'a> {
    #[inline]
    pub fn queue(mut self, queue: Queue) -> Self {
        self.inner.queue = queue;
        self
    }
    #[inline]
    pub fn mtl_command_queue(mut self, mtl_command_queue: MTLCommandQueue_id) -> Self {
        self.inner.mtl_command_queue = mtl_command_queue;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExportMetalCommandQueueInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMetalBufferInfoEXT.html>"]
pub struct ExportMetalBufferInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub memory: DeviceMemory,
    pub mtl_buffer: MTLBuffer_id,
}
impl ::std::default::Default for ExportMetalBufferInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            memory: DeviceMemory::default(),
            mtl_buffer: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for ExportMetalBufferInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_METAL_BUFFER_INFO_EXT;
}
impl ExportMetalBufferInfoEXT {
    pub fn builder<'a>() -> ExportMetalBufferInfoEXTBuilder<'a> {
        ExportMetalBufferInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExportMetalBufferInfoEXTBuilder<'a> {
    inner: ExportMetalBufferInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsExportMetalObjectsInfoEXT for ExportMetalBufferInfoEXTBuilder<'_> {}
unsafe impl ExtendsExportMetalObjectsInfoEXT for ExportMetalBufferInfoEXT {}
impl<'a> ::std::ops::Deref for ExportMetalBufferInfoEXTBuilder<'a> {
    type Target = ExportMetalBufferInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExportMetalBufferInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExportMetalBufferInfoEXTBuilder<'a> {
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    #[inline]
    pub fn mtl_buffer(mut self, mtl_buffer: MTLBuffer_id) -> Self {
        self.inner.mtl_buffer = mtl_buffer;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExportMetalBufferInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMetalBufferInfoEXT.html>"]
pub struct ImportMetalBufferInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub mtl_buffer: MTLBuffer_id,
}
impl ::std::default::Default for ImportMetalBufferInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            mtl_buffer: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for ImportMetalBufferInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_METAL_BUFFER_INFO_EXT;
}
impl ImportMetalBufferInfoEXT {
    pub fn builder<'a>() -> ImportMetalBufferInfoEXTBuilder<'a> {
        ImportMetalBufferInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImportMetalBufferInfoEXTBuilder<'a> {
    inner: ImportMetalBufferInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsMemoryAllocateInfo for ImportMetalBufferInfoEXTBuilder<'_> {}
unsafe impl ExtendsMemoryAllocateInfo for ImportMetalBufferInfoEXT {}
impl<'a> ::std::ops::Deref for ImportMetalBufferInfoEXTBuilder<'a> {
    type Target = ImportMetalBufferInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImportMetalBufferInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImportMetalBufferInfoEXTBuilder<'a> {
    #[inline]
    pub fn mtl_buffer(mut self, mtl_buffer: MTLBuffer_id) -> Self {
        self.inner.mtl_buffer = mtl_buffer;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImportMetalBufferInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMetalTextureInfoEXT.html>"]
pub struct ExportMetalTextureInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image: Image,
    pub image_view: ImageView,
    pub buffer_view: BufferView,
    pub plane: ImageAspectFlags,
    pub mtl_texture: MTLTexture_id,
}
impl ::std::default::Default for ExportMetalTextureInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image: Image::default(),
            image_view: ImageView::default(),
            buffer_view: BufferView::default(),
            plane: ImageAspectFlags::default(),
            mtl_texture: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for ExportMetalTextureInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_METAL_TEXTURE_INFO_EXT;
}
impl ExportMetalTextureInfoEXT {
    pub fn builder<'a>() -> ExportMetalTextureInfoEXTBuilder<'a> {
        ExportMetalTextureInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExportMetalTextureInfoEXTBuilder<'a> {
    inner: ExportMetalTextureInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsExportMetalObjectsInfoEXT for ExportMetalTextureInfoEXTBuilder<'_> {}
unsafe impl ExtendsExportMetalObjectsInfoEXT for ExportMetalTextureInfoEXT {}
impl<'a> ::std::ops::Deref for ExportMetalTextureInfoEXTBuilder<'a> {
    type Target = ExportMetalTextureInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExportMetalTextureInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExportMetalTextureInfoEXTBuilder<'a> {
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.inner.image = image;
        self
    }
    #[inline]
    pub fn image_view(mut self, image_view: ImageView) -> Self {
        self.inner.image_view = image_view;
        self
    }
    #[inline]
    pub fn buffer_view(mut self, buffer_view: BufferView) -> Self {
        self.inner.buffer_view = buffer_view;
        self
    }
    #[inline]
    pub fn plane(mut self, plane: ImageAspectFlags) -> Self {
        self.inner.plane = plane;
        self
    }
    #[inline]
    pub fn mtl_texture(mut self, mtl_texture: MTLTexture_id) -> Self {
        self.inner.mtl_texture = mtl_texture;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExportMetalTextureInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMetalTextureInfoEXT.html>"]
pub struct ImportMetalTextureInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub plane: ImageAspectFlags,
    pub mtl_texture: MTLTexture_id,
}
impl ::std::default::Default for ImportMetalTextureInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            plane: ImageAspectFlags::default(),
            mtl_texture: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for ImportMetalTextureInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_METAL_TEXTURE_INFO_EXT;
}
impl ImportMetalTextureInfoEXT {
    pub fn builder<'a>() -> ImportMetalTextureInfoEXTBuilder<'a> {
        ImportMetalTextureInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImportMetalTextureInfoEXTBuilder<'a> {
    inner: ImportMetalTextureInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageCreateInfo for ImportMetalTextureInfoEXTBuilder<'_> {}
unsafe impl ExtendsImageCreateInfo for ImportMetalTextureInfoEXT {}
impl<'a> ::std::ops::Deref for ImportMetalTextureInfoEXTBuilder<'a> {
    type Target = ImportMetalTextureInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImportMetalTextureInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImportMetalTextureInfoEXTBuilder<'a> {
    #[inline]
    pub fn plane(mut self, plane: ImageAspectFlags) -> Self {
        self.inner.plane = plane;
        self
    }
    #[inline]
    pub fn mtl_texture(mut self, mtl_texture: MTLTexture_id) -> Self {
        self.inner.mtl_texture = mtl_texture;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImportMetalTextureInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMetalIOSurfaceInfoEXT.html>"]
pub struct ExportMetalIOSurfaceInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub image: Image,
    pub io_surface: IOSurfaceRef,
}
impl ::std::default::Default for ExportMetalIOSurfaceInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            image: Image::default(),
            io_surface: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for ExportMetalIOSurfaceInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_METAL_IO_SURFACE_INFO_EXT;
}
impl ExportMetalIOSurfaceInfoEXT {
    pub fn builder<'a>() -> ExportMetalIOSurfaceInfoEXTBuilder<'a> {
        ExportMetalIOSurfaceInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExportMetalIOSurfaceInfoEXTBuilder<'a> {
    inner: ExportMetalIOSurfaceInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsExportMetalObjectsInfoEXT for ExportMetalIOSurfaceInfoEXTBuilder<'_> {}
unsafe impl ExtendsExportMetalObjectsInfoEXT for ExportMetalIOSurfaceInfoEXT {}
impl<'a> ::std::ops::Deref for ExportMetalIOSurfaceInfoEXTBuilder<'a> {
    type Target = ExportMetalIOSurfaceInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExportMetalIOSurfaceInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExportMetalIOSurfaceInfoEXTBuilder<'a> {
    #[inline]
    pub fn image(mut self, image: Image) -> Self {
        self.inner.image = image;
        self
    }
    #[inline]
    pub fn io_surface(mut self, io_surface: IOSurfaceRef) -> Self {
        self.inner.io_surface = io_surface;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExportMetalIOSurfaceInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMetalIOSurfaceInfoEXT.html>"]
pub struct ImportMetalIOSurfaceInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub io_surface: IOSurfaceRef,
}
impl ::std::default::Default for ImportMetalIOSurfaceInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            io_surface: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for ImportMetalIOSurfaceInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_METAL_IO_SURFACE_INFO_EXT;
}
impl ImportMetalIOSurfaceInfoEXT {
    pub fn builder<'a>() -> ImportMetalIOSurfaceInfoEXTBuilder<'a> {
        ImportMetalIOSurfaceInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImportMetalIOSurfaceInfoEXTBuilder<'a> {
    inner: ImportMetalIOSurfaceInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageCreateInfo for ImportMetalIOSurfaceInfoEXTBuilder<'_> {}
unsafe impl ExtendsImageCreateInfo for ImportMetalIOSurfaceInfoEXT {}
impl<'a> ::std::ops::Deref for ImportMetalIOSurfaceInfoEXTBuilder<'a> {
    type Target = ImportMetalIOSurfaceInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImportMetalIOSurfaceInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImportMetalIOSurfaceInfoEXTBuilder<'a> {
    #[inline]
    pub fn io_surface(mut self, io_surface: IOSurfaceRef) -> Self {
        self.inner.io_surface = io_surface;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImportMetalIOSurfaceInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMetalSharedEventInfoEXT.html>"]
pub struct ExportMetalSharedEventInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub semaphore: Semaphore,
    pub event: Event,
    pub mtl_shared_event: MTLSharedEvent_id,
}
impl ::std::default::Default for ExportMetalSharedEventInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            semaphore: Semaphore::default(),
            event: Event::default(),
            mtl_shared_event: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for ExportMetalSharedEventInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::EXPORT_METAL_SHARED_EVENT_INFO_EXT;
}
impl ExportMetalSharedEventInfoEXT {
    pub fn builder<'a>() -> ExportMetalSharedEventInfoEXTBuilder<'a> {
        ExportMetalSharedEventInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ExportMetalSharedEventInfoEXTBuilder<'a> {
    inner: ExportMetalSharedEventInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsExportMetalObjectsInfoEXT for ExportMetalSharedEventInfoEXTBuilder<'_> {}
unsafe impl ExtendsExportMetalObjectsInfoEXT for ExportMetalSharedEventInfoEXT {}
impl<'a> ::std::ops::Deref for ExportMetalSharedEventInfoEXTBuilder<'a> {
    type Target = ExportMetalSharedEventInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ExportMetalSharedEventInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ExportMetalSharedEventInfoEXTBuilder<'a> {
    #[inline]
    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
        self.inner.semaphore = semaphore;
        self
    }
    #[inline]
    pub fn event(mut self, event: Event) -> Self {
        self.inner.event = event;
        self
    }
    #[inline]
    pub fn mtl_shared_event(mut self, mtl_shared_event: MTLSharedEvent_id) -> Self {
        self.inner.mtl_shared_event = mtl_shared_event;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ExportMetalSharedEventInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImportMetalSharedEventInfoEXT.html>"]
pub struct ImportMetalSharedEventInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub mtl_shared_event: MTLSharedEvent_id,
}
impl ::std::default::Default for ImportMetalSharedEventInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            mtl_shared_event: unsafe { ::std::mem::zeroed() },
        }
    }
}
unsafe impl TaggedStructure for ImportMetalSharedEventInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::IMPORT_METAL_SHARED_EVENT_INFO_EXT;
}
impl ImportMetalSharedEventInfoEXT {
    pub fn builder<'a>() -> ImportMetalSharedEventInfoEXTBuilder<'a> {
        ImportMetalSharedEventInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImportMetalSharedEventInfoEXTBuilder<'a> {
    inner: ImportMetalSharedEventInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSemaphoreCreateInfo for ImportMetalSharedEventInfoEXTBuilder<'_> {}
unsafe impl ExtendsSemaphoreCreateInfo for ImportMetalSharedEventInfoEXT {}
unsafe impl ExtendsEventCreateInfo for ImportMetalSharedEventInfoEXTBuilder<'_> {}
unsafe impl ExtendsEventCreateInfo for ImportMetalSharedEventInfoEXT {}
impl<'a> ::std::ops::Deref for ImportMetalSharedEventInfoEXTBuilder<'a> {
    type Target = ImportMetalSharedEventInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImportMetalSharedEventInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImportMetalSharedEventInfoEXTBuilder<'a> {
    #[inline]
    pub fn mtl_shared_event(mut self, mtl_shared_event: MTLSharedEvent_id) -> Self {
        self.inner.mtl_shared_event = mtl_shared_event;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImportMetalSharedEventInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT.html>"]
pub struct PhysicalDeviceNonSeamlessCubeMapFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub non_seamless_cube_map: Bool32,
}
impl ::std::default::Default for PhysicalDeviceNonSeamlessCubeMapFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            non_seamless_cube_map: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceNonSeamlessCubeMapFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT;
}
impl PhysicalDeviceNonSeamlessCubeMapFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceNonSeamlessCubeMapFeaturesEXTBuilder<'a> {
        PhysicalDeviceNonSeamlessCubeMapFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceNonSeamlessCubeMapFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceNonSeamlessCubeMapFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceNonSeamlessCubeMapFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceNonSeamlessCubeMapFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceNonSeamlessCubeMapFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceNonSeamlessCubeMapFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceNonSeamlessCubeMapFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceNonSeamlessCubeMapFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceNonSeamlessCubeMapFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceNonSeamlessCubeMapFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn non_seamless_cube_map(mut self, non_seamless_cube_map: bool) -> Self {
        self.inner.non_seamless_cube_map = non_seamless_cube_map.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceNonSeamlessCubeMapFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelineRobustnessFeaturesEXT.html>"]
pub struct PhysicalDevicePipelineRobustnessFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pipeline_robustness: Bool32,
}
impl ::std::default::Default for PhysicalDevicePipelineRobustnessFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            pipeline_robustness: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevicePipelineRobustnessFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT;
}
impl PhysicalDevicePipelineRobustnessFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDevicePipelineRobustnessFeaturesEXTBuilder<'a> {
        PhysicalDevicePipelineRobustnessFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevicePipelineRobustnessFeaturesEXTBuilder<'a> {
    inner: PhysicalDevicePipelineRobustnessFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDevicePipelineRobustnessFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePipelineRobustnessFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePipelineRobustnessFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePipelineRobustnessFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDevicePipelineRobustnessFeaturesEXTBuilder<'a> {
    type Target = PhysicalDevicePipelineRobustnessFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevicePipelineRobustnessFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevicePipelineRobustnessFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn pipeline_robustness(mut self, pipeline_robustness: bool) -> Self {
        self.inner.pipeline_robustness = pipeline_robustness.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevicePipelineRobustnessFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRobustnessCreateInfoEXT.html>"]
pub struct PipelineRobustnessCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub storage_buffers: PipelineRobustnessBufferBehaviorEXT,
    pub uniform_buffers: PipelineRobustnessBufferBehaviorEXT,
    pub vertex_inputs: PipelineRobustnessBufferBehaviorEXT,
    pub images: PipelineRobustnessImageBehaviorEXT,
}
impl ::std::default::Default for PipelineRobustnessCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            storage_buffers: PipelineRobustnessBufferBehaviorEXT::default(),
            uniform_buffers: PipelineRobustnessBufferBehaviorEXT::default(),
            vertex_inputs: PipelineRobustnessBufferBehaviorEXT::default(),
            images: PipelineRobustnessImageBehaviorEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for PipelineRobustnessCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::PIPELINE_ROBUSTNESS_CREATE_INFO_EXT;
}
impl PipelineRobustnessCreateInfoEXT {
    pub fn builder<'a>() -> PipelineRobustnessCreateInfoEXTBuilder<'a> {
        PipelineRobustnessCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PipelineRobustnessCreateInfoEXTBuilder<'a> {
    inner: PipelineRobustnessCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsGraphicsPipelineCreateInfo for PipelineRobustnessCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsGraphicsPipelineCreateInfo for PipelineRobustnessCreateInfoEXT {}
unsafe impl ExtendsComputePipelineCreateInfo for PipelineRobustnessCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsComputePipelineCreateInfo for PipelineRobustnessCreateInfoEXT {}
unsafe impl ExtendsPipelineShaderStageCreateInfo for PipelineRobustnessCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsPipelineShaderStageCreateInfo for PipelineRobustnessCreateInfoEXT {}
unsafe impl ExtendsRayTracingPipelineCreateInfoKHR for PipelineRobustnessCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsRayTracingPipelineCreateInfoKHR for PipelineRobustnessCreateInfoEXT {}
impl<'a> ::std::ops::Deref for PipelineRobustnessCreateInfoEXTBuilder<'a> {
    type Target = PipelineRobustnessCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PipelineRobustnessCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PipelineRobustnessCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn storage_buffers(mut self, storage_buffers: PipelineRobustnessBufferBehaviorEXT) -> Self {
        self.inner.storage_buffers = storage_buffers;
        self
    }
    #[inline]
    pub fn uniform_buffers(mut self, uniform_buffers: PipelineRobustnessBufferBehaviorEXT) -> Self {
        self.inner.uniform_buffers = uniform_buffers;
        self
    }
    #[inline]
    pub fn vertex_inputs(mut self, vertex_inputs: PipelineRobustnessBufferBehaviorEXT) -> Self {
        self.inner.vertex_inputs = vertex_inputs;
        self
    }
    #[inline]
    pub fn images(mut self, images: PipelineRobustnessImageBehaviorEXT) -> Self {
        self.inner.images = images;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PipelineRobustnessCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelineRobustnessPropertiesEXT.html>"]
pub struct PhysicalDevicePipelineRobustnessPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub default_robustness_storage_buffers: PipelineRobustnessBufferBehaviorEXT,
    pub default_robustness_uniform_buffers: PipelineRobustnessBufferBehaviorEXT,
    pub default_robustness_vertex_inputs: PipelineRobustnessBufferBehaviorEXT,
    pub default_robustness_images: PipelineRobustnessImageBehaviorEXT,
}
impl ::std::default::Default for PhysicalDevicePipelineRobustnessPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            default_robustness_storage_buffers: PipelineRobustnessBufferBehaviorEXT::default(),
            default_robustness_uniform_buffers: PipelineRobustnessBufferBehaviorEXT::default(),
            default_robustness_vertex_inputs: PipelineRobustnessBufferBehaviorEXT::default(),
            default_robustness_images: PipelineRobustnessImageBehaviorEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevicePipelineRobustnessPropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT;
}
impl PhysicalDevicePipelineRobustnessPropertiesEXT {
    pub fn builder<'a>() -> PhysicalDevicePipelineRobustnessPropertiesEXTBuilder<'a> {
        PhysicalDevicePipelineRobustnessPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevicePipelineRobustnessPropertiesEXTBuilder<'a> {
    inner: PhysicalDevicePipelineRobustnessPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDevicePipelineRobustnessPropertiesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDevicePipelineRobustnessPropertiesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDevicePipelineRobustnessPropertiesEXTBuilder<'a> {
    type Target = PhysicalDevicePipelineRobustnessPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevicePipelineRobustnessPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevicePipelineRobustnessPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn default_robustness_storage_buffers(
        mut self,
        default_robustness_storage_buffers: PipelineRobustnessBufferBehaviorEXT,
    ) -> Self {
        self.inner.default_robustness_storage_buffers = default_robustness_storage_buffers;
        self
    }
    #[inline]
    pub fn default_robustness_uniform_buffers(
        mut self,
        default_robustness_uniform_buffers: PipelineRobustnessBufferBehaviorEXT,
    ) -> Self {
        self.inner.default_robustness_uniform_buffers = default_robustness_uniform_buffers;
        self
    }
    #[inline]
    pub fn default_robustness_vertex_inputs(
        mut self,
        default_robustness_vertex_inputs: PipelineRobustnessBufferBehaviorEXT,
    ) -> Self {
        self.inner.default_robustness_vertex_inputs = default_robustness_vertex_inputs;
        self
    }
    #[inline]
    pub fn default_robustness_images(
        mut self,
        default_robustness_images: PipelineRobustnessImageBehaviorEXT,
    ) -> Self {
        self.inner.default_robustness_images = default_robustness_images;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevicePipelineRobustnessPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewSampleWeightCreateInfoQCOM.html>"]
pub struct ImageViewSampleWeightCreateInfoQCOM {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub filter_center: Offset2D,
    pub filter_size: Extent2D,
    pub num_phases: u32,
}
impl ::std::default::Default for ImageViewSampleWeightCreateInfoQCOM {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            filter_center: Offset2D::default(),
            filter_size: Extent2D::default(),
            num_phases: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for ImageViewSampleWeightCreateInfoQCOM {
    const STRUCTURE_TYPE: StructureType = StructureType::IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM;
}
impl ImageViewSampleWeightCreateInfoQCOM {
    pub fn builder<'a>() -> ImageViewSampleWeightCreateInfoQCOMBuilder<'a> {
        ImageViewSampleWeightCreateInfoQCOMBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ImageViewSampleWeightCreateInfoQCOMBuilder<'a> {
    inner: ImageViewSampleWeightCreateInfoQCOM,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsImageViewCreateInfo for ImageViewSampleWeightCreateInfoQCOMBuilder<'_> {}
unsafe impl ExtendsImageViewCreateInfo for ImageViewSampleWeightCreateInfoQCOM {}
impl<'a> ::std::ops::Deref for ImageViewSampleWeightCreateInfoQCOMBuilder<'a> {
    type Target = ImageViewSampleWeightCreateInfoQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ImageViewSampleWeightCreateInfoQCOMBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ImageViewSampleWeightCreateInfoQCOMBuilder<'a> {
    #[inline]
    pub fn filter_center(mut self, filter_center: Offset2D) -> Self {
        self.inner.filter_center = filter_center;
        self
    }
    #[inline]
    pub fn filter_size(mut self, filter_size: Extent2D) -> Self {
        self.inner.filter_size = filter_size;
        self
    }
    #[inline]
    pub fn num_phases(mut self, num_phases: u32) -> Self {
        self.inner.num_phases = num_phases;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ImageViewSampleWeightCreateInfoQCOM {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageProcessingFeaturesQCOM.html>"]
pub struct PhysicalDeviceImageProcessingFeaturesQCOM {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub texture_sample_weighted: Bool32,
    pub texture_box_filter: Bool32,
    pub texture_block_match: Bool32,
}
impl ::std::default::Default for PhysicalDeviceImageProcessingFeaturesQCOM {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            texture_sample_weighted: Bool32::default(),
            texture_box_filter: Bool32::default(),
            texture_block_match: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceImageProcessingFeaturesQCOM {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM;
}
impl PhysicalDeviceImageProcessingFeaturesQCOM {
    pub fn builder<'a>() -> PhysicalDeviceImageProcessingFeaturesQCOMBuilder<'a> {
        PhysicalDeviceImageProcessingFeaturesQCOMBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceImageProcessingFeaturesQCOMBuilder<'a> {
    inner: PhysicalDeviceImageProcessingFeaturesQCOM,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceImageProcessingFeaturesQCOMBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceImageProcessingFeaturesQCOM {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceImageProcessingFeaturesQCOMBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceImageProcessingFeaturesQCOM {}
impl<'a> ::std::ops::Deref for PhysicalDeviceImageProcessingFeaturesQCOMBuilder<'a> {
    type Target = PhysicalDeviceImageProcessingFeaturesQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceImageProcessingFeaturesQCOMBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceImageProcessingFeaturesQCOMBuilder<'a> {
    #[inline]
    pub fn texture_sample_weighted(mut self, texture_sample_weighted: bool) -> Self {
        self.inner.texture_sample_weighted = texture_sample_weighted.into();
        self
    }
    #[inline]
    pub fn texture_box_filter(mut self, texture_box_filter: bool) -> Self {
        self.inner.texture_box_filter = texture_box_filter.into();
        self
    }
    #[inline]
    pub fn texture_block_match(mut self, texture_block_match: bool) -> Self {
        self.inner.texture_block_match = texture_block_match.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceImageProcessingFeaturesQCOM {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageProcessingPropertiesQCOM.html>"]
pub struct PhysicalDeviceImageProcessingPropertiesQCOM {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub max_weight_filter_phases: u32,
    pub max_weight_filter_dimension: Extent2D,
    pub max_block_match_region: Extent2D,
    pub max_box_filter_block_size: Extent2D,
}
impl ::std::default::Default for PhysicalDeviceImageProcessingPropertiesQCOM {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            max_weight_filter_phases: u32::default(),
            max_weight_filter_dimension: Extent2D::default(),
            max_block_match_region: Extent2D::default(),
            max_box_filter_block_size: Extent2D::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceImageProcessingPropertiesQCOM {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM;
}
impl PhysicalDeviceImageProcessingPropertiesQCOM {
    pub fn builder<'a>() -> PhysicalDeviceImageProcessingPropertiesQCOMBuilder<'a> {
        PhysicalDeviceImageProcessingPropertiesQCOMBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceImageProcessingPropertiesQCOMBuilder<'a> {
    inner: PhysicalDeviceImageProcessingPropertiesQCOM,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceImageProcessingPropertiesQCOMBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceImageProcessingPropertiesQCOM {}
impl<'a> ::std::ops::Deref for PhysicalDeviceImageProcessingPropertiesQCOMBuilder<'a> {
    type Target = PhysicalDeviceImageProcessingPropertiesQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceImageProcessingPropertiesQCOMBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceImageProcessingPropertiesQCOMBuilder<'a> {
    #[inline]
    pub fn max_weight_filter_phases(mut self, max_weight_filter_phases: u32) -> Self {
        self.inner.max_weight_filter_phases = max_weight_filter_phases;
        self
    }
    #[inline]
    pub fn max_weight_filter_dimension(mut self, max_weight_filter_dimension: Extent2D) -> Self {
        self.inner.max_weight_filter_dimension = max_weight_filter_dimension;
        self
    }
    #[inline]
    pub fn max_block_match_region(mut self, max_block_match_region: Extent2D) -> Self {
        self.inner.max_block_match_region = max_block_match_region;
        self
    }
    #[inline]
    pub fn max_box_filter_block_size(mut self, max_box_filter_block_size: Extent2D) -> Self {
        self.inner.max_box_filter_block_size = max_box_filter_block_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceImageProcessingPropertiesQCOM {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTilePropertiesFeaturesQCOM.html>"]
pub struct PhysicalDeviceTilePropertiesFeaturesQCOM {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub tile_properties: Bool32,
}
impl ::std::default::Default for PhysicalDeviceTilePropertiesFeaturesQCOM {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            tile_properties: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceTilePropertiesFeaturesQCOM {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM;
}
impl PhysicalDeviceTilePropertiesFeaturesQCOM {
    pub fn builder<'a>() -> PhysicalDeviceTilePropertiesFeaturesQCOMBuilder<'a> {
        PhysicalDeviceTilePropertiesFeaturesQCOMBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceTilePropertiesFeaturesQCOMBuilder<'a> {
    inner: PhysicalDeviceTilePropertiesFeaturesQCOM,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceTilePropertiesFeaturesQCOMBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceTilePropertiesFeaturesQCOM {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceTilePropertiesFeaturesQCOMBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceTilePropertiesFeaturesQCOM {}
impl<'a> ::std::ops::Deref for PhysicalDeviceTilePropertiesFeaturesQCOMBuilder<'a> {
    type Target = PhysicalDeviceTilePropertiesFeaturesQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceTilePropertiesFeaturesQCOMBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceTilePropertiesFeaturesQCOMBuilder<'a> {
    #[inline]
    pub fn tile_properties(mut self, tile_properties: bool) -> Self {
        self.inner.tile_properties = tile_properties.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceTilePropertiesFeaturesQCOM {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkTilePropertiesQCOM.html>"]
pub struct TilePropertiesQCOM {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub tile_size: Extent3D,
    pub apron_size: Extent2D,
    pub origin: Offset2D,
}
impl ::std::default::Default for TilePropertiesQCOM {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            tile_size: Extent3D::default(),
            apron_size: Extent2D::default(),
            origin: Offset2D::default(),
        }
    }
}
unsafe impl TaggedStructure for TilePropertiesQCOM {
    const STRUCTURE_TYPE: StructureType = StructureType::TILE_PROPERTIES_QCOM;
}
impl TilePropertiesQCOM {
    pub fn builder<'a>() -> TilePropertiesQCOMBuilder<'a> {
        TilePropertiesQCOMBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct TilePropertiesQCOMBuilder<'a> {
    inner: TilePropertiesQCOM,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for TilePropertiesQCOMBuilder<'a> {
    type Target = TilePropertiesQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for TilePropertiesQCOMBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> TilePropertiesQCOMBuilder<'a> {
    #[inline]
    pub fn tile_size(mut self, tile_size: Extent3D) -> Self {
        self.inner.tile_size = tile_size;
        self
    }
    #[inline]
    pub fn apron_size(mut self, apron_size: Extent2D) -> Self {
        self.inner.apron_size = apron_size;
        self
    }
    #[inline]
    pub fn origin(mut self, origin: Offset2D) -> Self {
        self.inner.origin = origin;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> TilePropertiesQCOM {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceAmigoProfilingFeaturesSEC.html>"]
pub struct PhysicalDeviceAmigoProfilingFeaturesSEC {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub amigo_profiling: Bool32,
}
impl ::std::default::Default for PhysicalDeviceAmigoProfilingFeaturesSEC {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            amigo_profiling: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceAmigoProfilingFeaturesSEC {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC;
}
impl PhysicalDeviceAmigoProfilingFeaturesSEC {
    pub fn builder<'a>() -> PhysicalDeviceAmigoProfilingFeaturesSECBuilder<'a> {
        PhysicalDeviceAmigoProfilingFeaturesSECBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceAmigoProfilingFeaturesSECBuilder<'a> {
    inner: PhysicalDeviceAmigoProfilingFeaturesSEC,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceAmigoProfilingFeaturesSECBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceAmigoProfilingFeaturesSEC {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceAmigoProfilingFeaturesSECBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceAmigoProfilingFeaturesSEC {}
impl<'a> ::std::ops::Deref for PhysicalDeviceAmigoProfilingFeaturesSECBuilder<'a> {
    type Target = PhysicalDeviceAmigoProfilingFeaturesSEC;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceAmigoProfilingFeaturesSECBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceAmigoProfilingFeaturesSECBuilder<'a> {
    #[inline]
    pub fn amigo_profiling(mut self, amigo_profiling: bool) -> Self {
        self.inner.amigo_profiling = amigo_profiling.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceAmigoProfilingFeaturesSEC {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAmigoProfilingSubmitInfoSEC.html>"]
pub struct AmigoProfilingSubmitInfoSEC {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub first_draw_timestamp: u64,
    pub swap_buffer_timestamp: u64,
}
impl ::std::default::Default for AmigoProfilingSubmitInfoSEC {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            first_draw_timestamp: u64::default(),
            swap_buffer_timestamp: u64::default(),
        }
    }
}
unsafe impl TaggedStructure for AmigoProfilingSubmitInfoSEC {
    const STRUCTURE_TYPE: StructureType = StructureType::AMIGO_PROFILING_SUBMIT_INFO_SEC;
}
impl AmigoProfilingSubmitInfoSEC {
    pub fn builder<'a>() -> AmigoProfilingSubmitInfoSECBuilder<'a> {
        AmigoProfilingSubmitInfoSECBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct AmigoProfilingSubmitInfoSECBuilder<'a> {
    inner: AmigoProfilingSubmitInfoSEC,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSubmitInfo for AmigoProfilingSubmitInfoSECBuilder<'_> {}
unsafe impl ExtendsSubmitInfo for AmigoProfilingSubmitInfoSEC {}
impl<'a> ::std::ops::Deref for AmigoProfilingSubmitInfoSECBuilder<'a> {
    type Target = AmigoProfilingSubmitInfoSEC;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for AmigoProfilingSubmitInfoSECBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> AmigoProfilingSubmitInfoSECBuilder<'a> {
    #[inline]
    pub fn first_draw_timestamp(mut self, first_draw_timestamp: u64) -> Self {
        self.inner.first_draw_timestamp = first_draw_timestamp;
        self
    }
    #[inline]
    pub fn swap_buffer_timestamp(mut self, swap_buffer_timestamp: u64) -> Self {
        self.inner.swap_buffer_timestamp = swap_buffer_timestamp;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> AmigoProfilingSubmitInfoSEC {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT.html>"]
pub struct PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub attachment_feedback_loop_layout: Bool32,
}
impl ::std::default::Default for PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            attachment_feedback_loop_layout: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT;
}
impl PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXTBuilder<'a> {
        PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT
{
}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn attachment_feedback_loop_layout(
        mut self,
        attachment_feedback_loop_layout: bool,
    ) -> Self {
        self.inner.attachment_feedback_loop_layout = attachment_feedback_loop_layout.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDepthClampZeroOneFeaturesEXT.html>"]
pub struct PhysicalDeviceDepthClampZeroOneFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub depth_clamp_zero_one: Bool32,
}
impl ::std::default::Default for PhysicalDeviceDepthClampZeroOneFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            depth_clamp_zero_one: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceDepthClampZeroOneFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT;
}
impl PhysicalDeviceDepthClampZeroOneFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceDepthClampZeroOneFeaturesEXTBuilder<'a> {
        PhysicalDeviceDepthClampZeroOneFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceDepthClampZeroOneFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceDepthClampZeroOneFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceDepthClampZeroOneFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDepthClampZeroOneFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDepthClampZeroOneFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDepthClampZeroOneFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceDepthClampZeroOneFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceDepthClampZeroOneFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceDepthClampZeroOneFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceDepthClampZeroOneFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn depth_clamp_zero_one(mut self, depth_clamp_zero_one: bool) -> Self {
        self.inner.depth_clamp_zero_one = depth_clamp_zero_one.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceDepthClampZeroOneFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceAddressBindingReportFeaturesEXT.html>"]
pub struct PhysicalDeviceAddressBindingReportFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub report_address_binding: Bool32,
}
impl ::std::default::Default for PhysicalDeviceAddressBindingReportFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            report_address_binding: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceAddressBindingReportFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT;
}
impl PhysicalDeviceAddressBindingReportFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceAddressBindingReportFeaturesEXTBuilder<'a> {
        PhysicalDeviceAddressBindingReportFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceAddressBindingReportFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceAddressBindingReportFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceAddressBindingReportFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceAddressBindingReportFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceAddressBindingReportFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceAddressBindingReportFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceAddressBindingReportFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceAddressBindingReportFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceAddressBindingReportFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceAddressBindingReportFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn report_address_binding(mut self, report_address_binding: bool) -> Self {
        self.inner.report_address_binding = report_address_binding.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceAddressBindingReportFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceAddressBindingCallbackDataEXT.html>"]
pub struct DeviceAddressBindingCallbackDataEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub flags: DeviceAddressBindingFlagsEXT,
    pub base_address: DeviceAddress,
    pub size: DeviceSize,
    pub binding_type: DeviceAddressBindingTypeEXT,
}
impl ::std::default::Default for DeviceAddressBindingCallbackDataEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            flags: DeviceAddressBindingFlagsEXT::default(),
            base_address: DeviceAddress::default(),
            size: DeviceSize::default(),
            binding_type: DeviceAddressBindingTypeEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for DeviceAddressBindingCallbackDataEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT;
}
impl DeviceAddressBindingCallbackDataEXT {
    pub fn builder<'a>() -> DeviceAddressBindingCallbackDataEXTBuilder<'a> {
        DeviceAddressBindingCallbackDataEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceAddressBindingCallbackDataEXTBuilder<'a> {
    inner: DeviceAddressBindingCallbackDataEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsDebugUtilsMessengerCallbackDataEXT
    for DeviceAddressBindingCallbackDataEXTBuilder<'_>
{
}
unsafe impl ExtendsDebugUtilsMessengerCallbackDataEXT for DeviceAddressBindingCallbackDataEXT {}
impl<'a> ::std::ops::Deref for DeviceAddressBindingCallbackDataEXTBuilder<'a> {
    type Target = DeviceAddressBindingCallbackDataEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceAddressBindingCallbackDataEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceAddressBindingCallbackDataEXTBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: DeviceAddressBindingFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn base_address(mut self, base_address: DeviceAddress) -> Self {
        self.inner.base_address = base_address;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    #[inline]
    pub fn binding_type(mut self, binding_type: DeviceAddressBindingTypeEXT) -> Self {
        self.inner.binding_type = binding_type;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceAddressBindingCallbackDataEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceOpticalFlowFeaturesNV.html>"]
pub struct PhysicalDeviceOpticalFlowFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub optical_flow: Bool32,
}
impl ::std::default::Default for PhysicalDeviceOpticalFlowFeaturesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            optical_flow: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceOpticalFlowFeaturesNV {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV;
}
impl PhysicalDeviceOpticalFlowFeaturesNV {
    pub fn builder<'a>() -> PhysicalDeviceOpticalFlowFeaturesNVBuilder<'a> {
        PhysicalDeviceOpticalFlowFeaturesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceOpticalFlowFeaturesNVBuilder<'a> {
    inner: PhysicalDeviceOpticalFlowFeaturesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceOpticalFlowFeaturesNVBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceOpticalFlowFeaturesNV {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceOpticalFlowFeaturesNVBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceOpticalFlowFeaturesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceOpticalFlowFeaturesNVBuilder<'a> {
    type Target = PhysicalDeviceOpticalFlowFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceOpticalFlowFeaturesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceOpticalFlowFeaturesNVBuilder<'a> {
    #[inline]
    pub fn optical_flow(mut self, optical_flow: bool) -> Self {
        self.inner.optical_flow = optical_flow.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceOpticalFlowFeaturesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceOpticalFlowPropertiesNV.html>"]
pub struct PhysicalDeviceOpticalFlowPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub supported_output_grid_sizes: OpticalFlowGridSizeFlagsNV,
    pub supported_hint_grid_sizes: OpticalFlowGridSizeFlagsNV,
    pub hint_supported: Bool32,
    pub cost_supported: Bool32,
    pub bidirectional_flow_supported: Bool32,
    pub global_flow_supported: Bool32,
    pub min_width: u32,
    pub min_height: u32,
    pub max_width: u32,
    pub max_height: u32,
    pub max_num_regions_of_interest: u32,
}
impl ::std::default::Default for PhysicalDeviceOpticalFlowPropertiesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            supported_output_grid_sizes: OpticalFlowGridSizeFlagsNV::default(),
            supported_hint_grid_sizes: OpticalFlowGridSizeFlagsNV::default(),
            hint_supported: Bool32::default(),
            cost_supported: Bool32::default(),
            bidirectional_flow_supported: Bool32::default(),
            global_flow_supported: Bool32::default(),
            min_width: u32::default(),
            min_height: u32::default(),
            max_width: u32::default(),
            max_height: u32::default(),
            max_num_regions_of_interest: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceOpticalFlowPropertiesNV {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV;
}
impl PhysicalDeviceOpticalFlowPropertiesNV {
    pub fn builder<'a>() -> PhysicalDeviceOpticalFlowPropertiesNVBuilder<'a> {
        PhysicalDeviceOpticalFlowPropertiesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceOpticalFlowPropertiesNVBuilder<'a> {
    inner: PhysicalDeviceOpticalFlowPropertiesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceOpticalFlowPropertiesNVBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceOpticalFlowPropertiesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceOpticalFlowPropertiesNVBuilder<'a> {
    type Target = PhysicalDeviceOpticalFlowPropertiesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceOpticalFlowPropertiesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceOpticalFlowPropertiesNVBuilder<'a> {
    #[inline]
    pub fn supported_output_grid_sizes(
        mut self,
        supported_output_grid_sizes: OpticalFlowGridSizeFlagsNV,
    ) -> Self {
        self.inner.supported_output_grid_sizes = supported_output_grid_sizes;
        self
    }
    #[inline]
    pub fn supported_hint_grid_sizes(
        mut self,
        supported_hint_grid_sizes: OpticalFlowGridSizeFlagsNV,
    ) -> Self {
        self.inner.supported_hint_grid_sizes = supported_hint_grid_sizes;
        self
    }
    #[inline]
    pub fn hint_supported(mut self, hint_supported: bool) -> Self {
        self.inner.hint_supported = hint_supported.into();
        self
    }
    #[inline]
    pub fn cost_supported(mut self, cost_supported: bool) -> Self {
        self.inner.cost_supported = cost_supported.into();
        self
    }
    #[inline]
    pub fn bidirectional_flow_supported(mut self, bidirectional_flow_supported: bool) -> Self {
        self.inner.bidirectional_flow_supported = bidirectional_flow_supported.into();
        self
    }
    #[inline]
    pub fn global_flow_supported(mut self, global_flow_supported: bool) -> Self {
        self.inner.global_flow_supported = global_flow_supported.into();
        self
    }
    #[inline]
    pub fn min_width(mut self, min_width: u32) -> Self {
        self.inner.min_width = min_width;
        self
    }
    #[inline]
    pub fn min_height(mut self, min_height: u32) -> Self {
        self.inner.min_height = min_height;
        self
    }
    #[inline]
    pub fn max_width(mut self, max_width: u32) -> Self {
        self.inner.max_width = max_width;
        self
    }
    #[inline]
    pub fn max_height(mut self, max_height: u32) -> Self {
        self.inner.max_height = max_height;
        self
    }
    #[inline]
    pub fn max_num_regions_of_interest(mut self, max_num_regions_of_interest: u32) -> Self {
        self.inner.max_num_regions_of_interest = max_num_regions_of_interest;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceOpticalFlowPropertiesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOpticalFlowImageFormatInfoNV.html>"]
pub struct OpticalFlowImageFormatInfoNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub usage: OpticalFlowUsageFlagsNV,
}
impl ::std::default::Default for OpticalFlowImageFormatInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            usage: OpticalFlowUsageFlagsNV::default(),
        }
    }
}
unsafe impl TaggedStructure for OpticalFlowImageFormatInfoNV {
    const STRUCTURE_TYPE: StructureType = StructureType::OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV;
}
impl OpticalFlowImageFormatInfoNV {
    pub fn builder<'a>() -> OpticalFlowImageFormatInfoNVBuilder<'a> {
        OpticalFlowImageFormatInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct OpticalFlowImageFormatInfoNVBuilder<'a> {
    inner: OpticalFlowImageFormatInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceImageFormatInfo2 for OpticalFlowImageFormatInfoNVBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceImageFormatInfo2 for OpticalFlowImageFormatInfoNV {}
unsafe impl ExtendsImageCreateInfo for OpticalFlowImageFormatInfoNVBuilder<'_> {}
unsafe impl ExtendsImageCreateInfo for OpticalFlowImageFormatInfoNV {}
impl<'a> ::std::ops::Deref for OpticalFlowImageFormatInfoNVBuilder<'a> {
    type Target = OpticalFlowImageFormatInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for OpticalFlowImageFormatInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> OpticalFlowImageFormatInfoNVBuilder<'a> {
    #[inline]
    pub fn usage(mut self, usage: OpticalFlowUsageFlagsNV) -> Self {
        self.inner.usage = usage;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> OpticalFlowImageFormatInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOpticalFlowImageFormatPropertiesNV.html>"]
pub struct OpticalFlowImageFormatPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub format: Format,
}
impl ::std::default::Default for OpticalFlowImageFormatPropertiesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            format: Format::default(),
        }
    }
}
unsafe impl TaggedStructure for OpticalFlowImageFormatPropertiesNV {
    const STRUCTURE_TYPE: StructureType = StructureType::OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV;
}
impl OpticalFlowImageFormatPropertiesNV {
    pub fn builder<'a>() -> OpticalFlowImageFormatPropertiesNVBuilder<'a> {
        OpticalFlowImageFormatPropertiesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct OpticalFlowImageFormatPropertiesNVBuilder<'a> {
    inner: OpticalFlowImageFormatPropertiesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for OpticalFlowImageFormatPropertiesNVBuilder<'a> {
    type Target = OpticalFlowImageFormatPropertiesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for OpticalFlowImageFormatPropertiesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> OpticalFlowImageFormatPropertiesNVBuilder<'a> {
    #[inline]
    pub fn format(mut self, format: Format) -> Self {
        self.inner.format = format;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> OpticalFlowImageFormatPropertiesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOpticalFlowSessionCreateInfoNV.html>"]
pub struct OpticalFlowSessionCreateInfoNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub width: u32,
    pub height: u32,
    pub image_format: Format,
    pub flow_vector_format: Format,
    pub cost_format: Format,
    pub output_grid_size: OpticalFlowGridSizeFlagsNV,
    pub hint_grid_size: OpticalFlowGridSizeFlagsNV,
    pub performance_level: OpticalFlowPerformanceLevelNV,
    pub flags: OpticalFlowSessionCreateFlagsNV,
}
impl ::std::default::Default for OpticalFlowSessionCreateInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            width: u32::default(),
            height: u32::default(),
            image_format: Format::default(),
            flow_vector_format: Format::default(),
            cost_format: Format::default(),
            output_grid_size: OpticalFlowGridSizeFlagsNV::default(),
            hint_grid_size: OpticalFlowGridSizeFlagsNV::default(),
            performance_level: OpticalFlowPerformanceLevelNV::default(),
            flags: OpticalFlowSessionCreateFlagsNV::default(),
        }
    }
}
unsafe impl TaggedStructure for OpticalFlowSessionCreateInfoNV {
    const STRUCTURE_TYPE: StructureType = StructureType::OPTICAL_FLOW_SESSION_CREATE_INFO_NV;
}
impl OpticalFlowSessionCreateInfoNV {
    pub fn builder<'a>() -> OpticalFlowSessionCreateInfoNVBuilder<'a> {
        OpticalFlowSessionCreateInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct OpticalFlowSessionCreateInfoNVBuilder<'a> {
    inner: OpticalFlowSessionCreateInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsOpticalFlowSessionCreateInfoNV {}
impl<'a> ::std::ops::Deref for OpticalFlowSessionCreateInfoNVBuilder<'a> {
    type Target = OpticalFlowSessionCreateInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for OpticalFlowSessionCreateInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> OpticalFlowSessionCreateInfoNVBuilder<'a> {
    #[inline]
    pub fn width(mut self, width: u32) -> Self {
        self.inner.width = width;
        self
    }
    #[inline]
    pub fn height(mut self, height: u32) -> Self {
        self.inner.height = height;
        self
    }
    #[inline]
    pub fn image_format(mut self, image_format: Format) -> Self {
        self.inner.image_format = image_format;
        self
    }
    #[inline]
    pub fn flow_vector_format(mut self, flow_vector_format: Format) -> Self {
        self.inner.flow_vector_format = flow_vector_format;
        self
    }
    #[inline]
    pub fn cost_format(mut self, cost_format: Format) -> Self {
        self.inner.cost_format = cost_format;
        self
    }
    #[inline]
    pub fn output_grid_size(mut self, output_grid_size: OpticalFlowGridSizeFlagsNV) -> Self {
        self.inner.output_grid_size = output_grid_size;
        self
    }
    #[inline]
    pub fn hint_grid_size(mut self, hint_grid_size: OpticalFlowGridSizeFlagsNV) -> Self {
        self.inner.hint_grid_size = hint_grid_size;
        self
    }
    #[inline]
    pub fn performance_level(mut self, performance_level: OpticalFlowPerformanceLevelNV) -> Self {
        self.inner.performance_level = performance_level;
        self
    }
    #[inline]
    pub fn flags(mut self, flags: OpticalFlowSessionCreateFlagsNV) -> Self {
        self.inner.flags = flags;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsOpticalFlowSessionCreateInfoNV>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*mut T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> OpticalFlowSessionCreateInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOpticalFlowSessionCreatePrivateDataInfoNV.html>"]
pub struct OpticalFlowSessionCreatePrivateDataInfoNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub id: u32,
    pub size: u32,
    pub p_private_data: *const c_void,
}
impl ::std::default::Default for OpticalFlowSessionCreatePrivateDataInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            id: u32::default(),
            size: u32::default(),
            p_private_data: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for OpticalFlowSessionCreatePrivateDataInfoNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV;
}
impl OpticalFlowSessionCreatePrivateDataInfoNV {
    pub fn builder<'a>() -> OpticalFlowSessionCreatePrivateDataInfoNVBuilder<'a> {
        OpticalFlowSessionCreatePrivateDataInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct OpticalFlowSessionCreatePrivateDataInfoNVBuilder<'a> {
    inner: OpticalFlowSessionCreatePrivateDataInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsOpticalFlowSessionCreateInfoNV
    for OpticalFlowSessionCreatePrivateDataInfoNVBuilder<'_>
{
}
unsafe impl ExtendsOpticalFlowSessionCreateInfoNV for OpticalFlowSessionCreatePrivateDataInfoNV {}
impl<'a> ::std::ops::Deref for OpticalFlowSessionCreatePrivateDataInfoNVBuilder<'a> {
    type Target = OpticalFlowSessionCreatePrivateDataInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for OpticalFlowSessionCreatePrivateDataInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> OpticalFlowSessionCreatePrivateDataInfoNVBuilder<'a> {
    #[inline]
    pub fn id(mut self, id: u32) -> Self {
        self.inner.id = id;
        self
    }
    #[inline]
    pub fn size(mut self, size: u32) -> Self {
        self.inner.size = size;
        self
    }
    #[inline]
    pub fn private_data(mut self, private_data: *const c_void) -> Self {
        self.inner.p_private_data = private_data;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> OpticalFlowSessionCreatePrivateDataInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOpticalFlowExecuteInfoNV.html>"]
pub struct OpticalFlowExecuteInfoNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub flags: OpticalFlowExecuteFlagsNV,
    pub region_count: u32,
    pub p_regions: *const Rect2D,
}
impl ::std::default::Default for OpticalFlowExecuteInfoNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            flags: OpticalFlowExecuteFlagsNV::default(),
            region_count: u32::default(),
            p_regions: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for OpticalFlowExecuteInfoNV {
    const STRUCTURE_TYPE: StructureType = StructureType::OPTICAL_FLOW_EXECUTE_INFO_NV;
}
impl OpticalFlowExecuteInfoNV {
    pub fn builder<'a>() -> OpticalFlowExecuteInfoNVBuilder<'a> {
        OpticalFlowExecuteInfoNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct OpticalFlowExecuteInfoNVBuilder<'a> {
    inner: OpticalFlowExecuteInfoNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for OpticalFlowExecuteInfoNVBuilder<'a> {
    type Target = OpticalFlowExecuteInfoNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for OpticalFlowExecuteInfoNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> OpticalFlowExecuteInfoNVBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: OpticalFlowExecuteFlagsNV) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn regions(mut self, regions: &'a [Rect2D]) -> Self {
        self.inner.region_count = regions.len() as _;
        self.inner.p_regions = regions.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> OpticalFlowExecuteInfoNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFaultFeaturesEXT.html>"]
pub struct PhysicalDeviceFaultFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub device_fault: Bool32,
    pub device_fault_vendor_binary: Bool32,
}
impl ::std::default::Default for PhysicalDeviceFaultFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            device_fault: Bool32::default(),
            device_fault_vendor_binary: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceFaultFeaturesEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_FAULT_FEATURES_EXT;
}
impl PhysicalDeviceFaultFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceFaultFeaturesEXTBuilder<'a> {
        PhysicalDeviceFaultFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceFaultFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceFaultFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceFaultFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceFaultFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFaultFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFaultFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceFaultFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceFaultFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceFaultFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceFaultFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn device_fault(mut self, device_fault: bool) -> Self {
        self.inner.device_fault = device_fault.into();
        self
    }
    #[inline]
    pub fn device_fault_vendor_binary(mut self, device_fault_vendor_binary: bool) -> Self {
        self.inner.device_fault_vendor_binary = device_fault_vendor_binary.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceFaultFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceFaultAddressInfoEXT.html>"]
pub struct DeviceFaultAddressInfoEXT {
    pub address_type: DeviceFaultAddressTypeEXT,
    pub reported_address: DeviceAddress,
    pub address_precision: DeviceSize,
}
impl DeviceFaultAddressInfoEXT {
    pub fn builder<'a>() -> DeviceFaultAddressInfoEXTBuilder<'a> {
        DeviceFaultAddressInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceFaultAddressInfoEXTBuilder<'a> {
    inner: DeviceFaultAddressInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DeviceFaultAddressInfoEXTBuilder<'a> {
    type Target = DeviceFaultAddressInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceFaultAddressInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceFaultAddressInfoEXTBuilder<'a> {
    #[inline]
    pub fn address_type(mut self, address_type: DeviceFaultAddressTypeEXT) -> Self {
        self.inner.address_type = address_type;
        self
    }
    #[inline]
    pub fn reported_address(mut self, reported_address: DeviceAddress) -> Self {
        self.inner.reported_address = reported_address;
        self
    }
    #[inline]
    pub fn address_precision(mut self, address_precision: DeviceSize) -> Self {
        self.inner.address_precision = address_precision;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceFaultAddressInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceFaultVendorInfoEXT.html>"]
pub struct DeviceFaultVendorInfoEXT {
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
    pub vendor_fault_code: u64,
    pub vendor_fault_data: u64,
}
#[cfg(feature = "debug")]
impl fmt::Debug for DeviceFaultVendorInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceFaultVendorInfoEXT")
            .field("description", &unsafe {
                ::std::ffi::CStr::from_ptr(self.description.as_ptr())
            })
            .field("vendor_fault_code", &self.vendor_fault_code)
            .field("vendor_fault_data", &self.vendor_fault_data)
            .finish()
    }
}
impl ::std::default::Default for DeviceFaultVendorInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            description: unsafe { ::std::mem::zeroed() },
            vendor_fault_code: u64::default(),
            vendor_fault_data: u64::default(),
        }
    }
}
impl DeviceFaultVendorInfoEXT {
    pub fn builder<'a>() -> DeviceFaultVendorInfoEXTBuilder<'a> {
        DeviceFaultVendorInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceFaultVendorInfoEXTBuilder<'a> {
    inner: DeviceFaultVendorInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DeviceFaultVendorInfoEXTBuilder<'a> {
    type Target = DeviceFaultVendorInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceFaultVendorInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceFaultVendorInfoEXTBuilder<'a> {
    #[inline]
    pub fn description(mut self, description: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.inner.description = description;
        self
    }
    #[inline]
    pub fn vendor_fault_code(mut self, vendor_fault_code: u64) -> Self {
        self.inner.vendor_fault_code = vendor_fault_code;
        self
    }
    #[inline]
    pub fn vendor_fault_data(mut self, vendor_fault_data: u64) -> Self {
        self.inner.vendor_fault_data = vendor_fault_data;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceFaultVendorInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceFaultCountsEXT.html>"]
pub struct DeviceFaultCountsEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub address_info_count: u32,
    pub vendor_info_count: u32,
    pub vendor_binary_size: DeviceSize,
}
impl ::std::default::Default for DeviceFaultCountsEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            address_info_count: u32::default(),
            vendor_info_count: u32::default(),
            vendor_binary_size: DeviceSize::default(),
        }
    }
}
unsafe impl TaggedStructure for DeviceFaultCountsEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_FAULT_COUNTS_EXT;
}
impl DeviceFaultCountsEXT {
    pub fn builder<'a>() -> DeviceFaultCountsEXTBuilder<'a> {
        DeviceFaultCountsEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceFaultCountsEXTBuilder<'a> {
    inner: DeviceFaultCountsEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DeviceFaultCountsEXTBuilder<'a> {
    type Target = DeviceFaultCountsEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceFaultCountsEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceFaultCountsEXTBuilder<'a> {
    #[inline]
    pub fn address_info_count(mut self, address_info_count: u32) -> Self {
        self.inner.address_info_count = address_info_count;
        self
    }
    #[inline]
    pub fn vendor_info_count(mut self, vendor_info_count: u32) -> Self {
        self.inner.vendor_info_count = vendor_info_count;
        self
    }
    #[inline]
    pub fn vendor_binary_size(mut self, vendor_binary_size: DeviceSize) -> Self {
        self.inner.vendor_binary_size = vendor_binary_size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceFaultCountsEXT {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceFaultInfoEXT.html>"]
pub struct DeviceFaultInfoEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub description: [c_char; MAX_DESCRIPTION_SIZE],
    pub p_address_infos: *mut DeviceFaultAddressInfoEXT,
    pub p_vendor_infos: *mut DeviceFaultVendorInfoEXT,
    pub p_vendor_binary_data: *mut c_void,
}
#[cfg(feature = "debug")]
impl fmt::Debug for DeviceFaultInfoEXT {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DeviceFaultInfoEXT")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("description", &unsafe {
                ::std::ffi::CStr::from_ptr(self.description.as_ptr())
            })
            .field("p_address_infos", &self.p_address_infos)
            .field("p_vendor_infos", &self.p_vendor_infos)
            .field("p_vendor_binary_data", &self.p_vendor_binary_data)
            .finish()
    }
}
impl ::std::default::Default for DeviceFaultInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            description: unsafe { ::std::mem::zeroed() },
            p_address_infos: ::std::ptr::null_mut(),
            p_vendor_infos: ::std::ptr::null_mut(),
            p_vendor_binary_data: ::std::ptr::null_mut(),
        }
    }
}
unsafe impl TaggedStructure for DeviceFaultInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::DEVICE_FAULT_INFO_EXT;
}
impl DeviceFaultInfoEXT {
    pub fn builder<'a>() -> DeviceFaultInfoEXTBuilder<'a> {
        DeviceFaultInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceFaultInfoEXTBuilder<'a> {
    inner: DeviceFaultInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DeviceFaultInfoEXTBuilder<'a> {
    type Target = DeviceFaultInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceFaultInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceFaultInfoEXTBuilder<'a> {
    #[inline]
    pub fn description(mut self, description: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
        self.inner.description = description;
        self
    }
    #[inline]
    pub fn address_infos(mut self, address_infos: &'a mut DeviceFaultAddressInfoEXT) -> Self {
        self.inner.p_address_infos = address_infos;
        self
    }
    #[inline]
    pub fn vendor_infos(mut self, vendor_infos: &'a mut DeviceFaultVendorInfoEXT) -> Self {
        self.inner.p_vendor_infos = vendor_infos;
        self
    }
    #[inline]
    pub fn vendor_binary_data(mut self, vendor_binary_data: *mut c_void) -> Self {
        self.inner.p_vendor_binary_data = vendor_binary_data;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceFaultInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceFaultVendorBinaryHeaderVersionOneEXT.html>"]
pub struct DeviceFaultVendorBinaryHeaderVersionOneEXT {
    pub header_size: u32,
    pub header_version: DeviceFaultVendorBinaryHeaderVersionEXT,
    pub vendor_id: u32,
    pub device_id: u32,
    pub driver_version: u32,
    pub pipeline_cache_uuid: [u8; UUID_SIZE],
    pub application_name_offset: u32,
    pub application_version: u32,
    pub engine_name_offset: u32,
    pub engine_version: u32,
    pub api_version: u32,
}
impl ::std::default::Default for DeviceFaultVendorBinaryHeaderVersionOneEXT {
    #[inline]
    fn default() -> Self {
        Self {
            header_size: u32::default(),
            header_version: DeviceFaultVendorBinaryHeaderVersionEXT::default(),
            vendor_id: u32::default(),
            device_id: u32::default(),
            driver_version: u32::default(),
            pipeline_cache_uuid: unsafe { ::std::mem::zeroed() },
            application_name_offset: u32::default(),
            application_version: u32::default(),
            engine_name_offset: u32::default(),
            engine_version: u32::default(),
            api_version: u32::default(),
        }
    }
}
impl DeviceFaultVendorBinaryHeaderVersionOneEXT {
    pub fn builder<'a>() -> DeviceFaultVendorBinaryHeaderVersionOneEXTBuilder<'a> {
        DeviceFaultVendorBinaryHeaderVersionOneEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DeviceFaultVendorBinaryHeaderVersionOneEXTBuilder<'a> {
    inner: DeviceFaultVendorBinaryHeaderVersionOneEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DeviceFaultVendorBinaryHeaderVersionOneEXTBuilder<'a> {
    type Target = DeviceFaultVendorBinaryHeaderVersionOneEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DeviceFaultVendorBinaryHeaderVersionOneEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DeviceFaultVendorBinaryHeaderVersionOneEXTBuilder<'a> {
    #[inline]
    pub fn header_size(mut self, header_size: u32) -> Self {
        self.inner.header_size = header_size;
        self
    }
    #[inline]
    pub fn header_version(
        mut self,
        header_version: DeviceFaultVendorBinaryHeaderVersionEXT,
    ) -> Self {
        self.inner.header_version = header_version;
        self
    }
    #[inline]
    pub fn vendor_id(mut self, vendor_id: u32) -> Self {
        self.inner.vendor_id = vendor_id;
        self
    }
    #[inline]
    pub fn device_id(mut self, device_id: u32) -> Self {
        self.inner.device_id = device_id;
        self
    }
    #[inline]
    pub fn driver_version(mut self, driver_version: u32) -> Self {
        self.inner.driver_version = driver_version;
        self
    }
    #[inline]
    pub fn pipeline_cache_uuid(mut self, pipeline_cache_uuid: [u8; UUID_SIZE]) -> Self {
        self.inner.pipeline_cache_uuid = pipeline_cache_uuid;
        self
    }
    #[inline]
    pub fn application_name_offset(mut self, application_name_offset: u32) -> Self {
        self.inner.application_name_offset = application_name_offset;
        self
    }
    #[inline]
    pub fn application_version(mut self, application_version: u32) -> Self {
        self.inner.application_version = application_version;
        self
    }
    #[inline]
    pub fn engine_name_offset(mut self, engine_name_offset: u32) -> Self {
        self.inner.engine_name_offset = engine_name_offset;
        self
    }
    #[inline]
    pub fn engine_version(mut self, engine_version: u32) -> Self {
        self.inner.engine_version = engine_version;
        self
    }
    #[inline]
    pub fn api_version(mut self, api_version: u32) -> Self {
        self.inner.api_version = api_version;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DeviceFaultVendorBinaryHeaderVersionOneEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT.html>"]
pub struct PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pipeline_library_group_handles: Bool32,
}
impl ::std::default::Default for PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            pipeline_library_group_handles: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT;
}
impl PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXTBuilder<'a> {
        PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXTBuilder<'a> {
    inner: PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT
{
}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXTBuilder<'a> {
    type Target = PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn pipeline_library_group_handles(mut self, pipeline_library_group_handles: bool) -> Self {
        self.inner.pipeline_library_group_handles = pipeline_library_group_handles.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone, Default)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDecompressMemoryRegionNV.html>"]
pub struct DecompressMemoryRegionNV {
    pub src_address: DeviceAddress,
    pub dst_address: DeviceAddress,
    pub compressed_size: DeviceSize,
    pub decompressed_size: DeviceSize,
    pub decompression_method: MemoryDecompressionMethodFlagsNV,
}
impl DecompressMemoryRegionNV {
    pub fn builder<'a>() -> DecompressMemoryRegionNVBuilder<'a> {
        DecompressMemoryRegionNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DecompressMemoryRegionNVBuilder<'a> {
    inner: DecompressMemoryRegionNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DecompressMemoryRegionNVBuilder<'a> {
    type Target = DecompressMemoryRegionNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DecompressMemoryRegionNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DecompressMemoryRegionNVBuilder<'a> {
    #[inline]
    pub fn src_address(mut self, src_address: DeviceAddress) -> Self {
        self.inner.src_address = src_address;
        self
    }
    #[inline]
    pub fn dst_address(mut self, dst_address: DeviceAddress) -> Self {
        self.inner.dst_address = dst_address;
        self
    }
    #[inline]
    pub fn compressed_size(mut self, compressed_size: DeviceSize) -> Self {
        self.inner.compressed_size = compressed_size;
        self
    }
    #[inline]
    pub fn decompressed_size(mut self, decompressed_size: DeviceSize) -> Self {
        self.inner.decompressed_size = decompressed_size;
        self
    }
    #[inline]
    pub fn decompression_method(
        mut self,
        decompression_method: MemoryDecompressionMethodFlagsNV,
    ) -> Self {
        self.inner.decompression_method = decompression_method;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DecompressMemoryRegionNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM.html>"]
pub struct PhysicalDeviceShaderCoreBuiltinsPropertiesARM {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_core_mask: u64,
    pub shader_core_count: u32,
    pub shader_warps_per_core: u32,
}
impl ::std::default::Default for PhysicalDeviceShaderCoreBuiltinsPropertiesARM {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_core_mask: u64::default(),
            shader_core_count: u32::default(),
            shader_warps_per_core: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderCoreBuiltinsPropertiesARM {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM;
}
impl PhysicalDeviceShaderCoreBuiltinsPropertiesARM {
    pub fn builder<'a>() -> PhysicalDeviceShaderCoreBuiltinsPropertiesARMBuilder<'a> {
        PhysicalDeviceShaderCoreBuiltinsPropertiesARMBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderCoreBuiltinsPropertiesARMBuilder<'a> {
    inner: PhysicalDeviceShaderCoreBuiltinsPropertiesARM,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceShaderCoreBuiltinsPropertiesARMBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceShaderCoreBuiltinsPropertiesARM {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderCoreBuiltinsPropertiesARMBuilder<'a> {
    type Target = PhysicalDeviceShaderCoreBuiltinsPropertiesARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderCoreBuiltinsPropertiesARMBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderCoreBuiltinsPropertiesARMBuilder<'a> {
    #[inline]
    pub fn shader_core_mask(mut self, shader_core_mask: u64) -> Self {
        self.inner.shader_core_mask = shader_core_mask;
        self
    }
    #[inline]
    pub fn shader_core_count(mut self, shader_core_count: u32) -> Self {
        self.inner.shader_core_count = shader_core_count;
        self
    }
    #[inline]
    pub fn shader_warps_per_core(mut self, shader_warps_per_core: u32) -> Self {
        self.inner.shader_warps_per_core = shader_warps_per_core;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderCoreBuiltinsPropertiesARM {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM.html>"]
pub struct PhysicalDeviceShaderCoreBuiltinsFeaturesARM {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_core_builtins: Bool32,
}
impl ::std::default::Default for PhysicalDeviceShaderCoreBuiltinsFeaturesARM {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_core_builtins: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderCoreBuiltinsFeaturesARM {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM;
}
impl PhysicalDeviceShaderCoreBuiltinsFeaturesARM {
    pub fn builder<'a>() -> PhysicalDeviceShaderCoreBuiltinsFeaturesARMBuilder<'a> {
        PhysicalDeviceShaderCoreBuiltinsFeaturesARMBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderCoreBuiltinsFeaturesARMBuilder<'a> {
    inner: PhysicalDeviceShaderCoreBuiltinsFeaturesARM,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceShaderCoreBuiltinsFeaturesARMBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderCoreBuiltinsFeaturesARM {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderCoreBuiltinsFeaturesARMBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderCoreBuiltinsFeaturesARM {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderCoreBuiltinsFeaturesARMBuilder<'a> {
    type Target = PhysicalDeviceShaderCoreBuiltinsFeaturesARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderCoreBuiltinsFeaturesARMBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderCoreBuiltinsFeaturesARMBuilder<'a> {
    #[inline]
    pub fn shader_core_builtins(mut self, shader_core_builtins: bool) -> Self {
        self.inner.shader_core_builtins = shader_core_builtins.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderCoreBuiltinsFeaturesARM {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT.html>"]
pub struct PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub dynamic_rendering_unused_attachments: Bool32,
}
impl ::std::default::Default for PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            dynamic_rendering_unused_attachments: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT;
}
impl PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXTBuilder<'a> {
        PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT
{
}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT {}
impl<'a> ::std::ops::Deref
    for PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXTBuilder<'a>
{
    type Target = PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut
    for PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXTBuilder<'a>
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn dynamic_rendering_unused_attachments(
        mut self,
        dynamic_rendering_unused_attachments: bool,
    ) -> Self {
        self.inner.dynamic_rendering_unused_attachments =
            dynamic_rendering_unused_attachments.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfacePresentModeEXT.html>"]
pub struct SurfacePresentModeEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub present_mode: PresentModeKHR,
}
impl ::std::default::Default for SurfacePresentModeEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            present_mode: PresentModeKHR::default(),
        }
    }
}
unsafe impl TaggedStructure for SurfacePresentModeEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::SURFACE_PRESENT_MODE_EXT;
}
impl SurfacePresentModeEXT {
    pub fn builder<'a>() -> SurfacePresentModeEXTBuilder<'a> {
        SurfacePresentModeEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SurfacePresentModeEXTBuilder<'a> {
    inner: SurfacePresentModeEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceSurfaceInfo2KHR for SurfacePresentModeEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceSurfaceInfo2KHR for SurfacePresentModeEXT {}
impl<'a> ::std::ops::Deref for SurfacePresentModeEXTBuilder<'a> {
    type Target = SurfacePresentModeEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SurfacePresentModeEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SurfacePresentModeEXTBuilder<'a> {
    #[inline]
    pub fn present_mode(mut self, present_mode: PresentModeKHR) -> Self {
        self.inner.present_mode = present_mode;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SurfacePresentModeEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfacePresentScalingCapabilitiesEXT.html>"]
pub struct SurfacePresentScalingCapabilitiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub supported_present_scaling: PresentScalingFlagsEXT,
    pub supported_present_gravity_x: PresentGravityFlagsEXT,
    pub supported_present_gravity_y: PresentGravityFlagsEXT,
    pub min_scaled_image_extent: Extent2D,
    pub max_scaled_image_extent: Extent2D,
}
impl ::std::default::Default for SurfacePresentScalingCapabilitiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            supported_present_scaling: PresentScalingFlagsEXT::default(),
            supported_present_gravity_x: PresentGravityFlagsEXT::default(),
            supported_present_gravity_y: PresentGravityFlagsEXT::default(),
            min_scaled_image_extent: Extent2D::default(),
            max_scaled_image_extent: Extent2D::default(),
        }
    }
}
unsafe impl TaggedStructure for SurfacePresentScalingCapabilitiesEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::SURFACE_PRESENT_SCALING_CAPABILITIES_EXT;
}
impl SurfacePresentScalingCapabilitiesEXT {
    pub fn builder<'a>() -> SurfacePresentScalingCapabilitiesEXTBuilder<'a> {
        SurfacePresentScalingCapabilitiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SurfacePresentScalingCapabilitiesEXTBuilder<'a> {
    inner: SurfacePresentScalingCapabilitiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSurfaceCapabilities2KHR for SurfacePresentScalingCapabilitiesEXTBuilder<'_> {}
unsafe impl ExtendsSurfaceCapabilities2KHR for SurfacePresentScalingCapabilitiesEXT {}
impl<'a> ::std::ops::Deref for SurfacePresentScalingCapabilitiesEXTBuilder<'a> {
    type Target = SurfacePresentScalingCapabilitiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SurfacePresentScalingCapabilitiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SurfacePresentScalingCapabilitiesEXTBuilder<'a> {
    #[inline]
    pub fn supported_present_scaling(
        mut self,
        supported_present_scaling: PresentScalingFlagsEXT,
    ) -> Self {
        self.inner.supported_present_scaling = supported_present_scaling;
        self
    }
    #[inline]
    pub fn supported_present_gravity_x(
        mut self,
        supported_present_gravity_x: PresentGravityFlagsEXT,
    ) -> Self {
        self.inner.supported_present_gravity_x = supported_present_gravity_x;
        self
    }
    #[inline]
    pub fn supported_present_gravity_y(
        mut self,
        supported_present_gravity_y: PresentGravityFlagsEXT,
    ) -> Self {
        self.inner.supported_present_gravity_y = supported_present_gravity_y;
        self
    }
    #[inline]
    pub fn min_scaled_image_extent(mut self, min_scaled_image_extent: Extent2D) -> Self {
        self.inner.min_scaled_image_extent = min_scaled_image_extent;
        self
    }
    #[inline]
    pub fn max_scaled_image_extent(mut self, max_scaled_image_extent: Extent2D) -> Self {
        self.inner.max_scaled_image_extent = max_scaled_image_extent;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SurfacePresentScalingCapabilitiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfacePresentModeCompatibilityEXT.html>"]
pub struct SurfacePresentModeCompatibilityEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub present_mode_count: u32,
    pub p_present_modes: *mut PresentModeKHR,
}
impl ::std::default::Default for SurfacePresentModeCompatibilityEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            present_mode_count: u32::default(),
            p_present_modes: ::std::ptr::null_mut(),
        }
    }
}
unsafe impl TaggedStructure for SurfacePresentModeCompatibilityEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::SURFACE_PRESENT_MODE_COMPATIBILITY_EXT;
}
impl SurfacePresentModeCompatibilityEXT {
    pub fn builder<'a>() -> SurfacePresentModeCompatibilityEXTBuilder<'a> {
        SurfacePresentModeCompatibilityEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SurfacePresentModeCompatibilityEXTBuilder<'a> {
    inner: SurfacePresentModeCompatibilityEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSurfaceCapabilities2KHR for SurfacePresentModeCompatibilityEXTBuilder<'_> {}
unsafe impl ExtendsSurfaceCapabilities2KHR for SurfacePresentModeCompatibilityEXT {}
impl<'a> ::std::ops::Deref for SurfacePresentModeCompatibilityEXTBuilder<'a> {
    type Target = SurfacePresentModeCompatibilityEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SurfacePresentModeCompatibilityEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SurfacePresentModeCompatibilityEXTBuilder<'a> {
    #[inline]
    pub fn present_modes(mut self, present_modes: &'a mut [PresentModeKHR]) -> Self {
        self.inner.present_mode_count = present_modes.len() as _;
        self.inner.p_present_modes = present_modes.as_mut_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SurfacePresentModeCompatibilityEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT.html>"]
pub struct PhysicalDeviceSwapchainMaintenance1FeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub swapchain_maintenance1: Bool32,
}
impl ::std::default::Default for PhysicalDeviceSwapchainMaintenance1FeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            swapchain_maintenance1: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceSwapchainMaintenance1FeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT;
}
impl PhysicalDeviceSwapchainMaintenance1FeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceSwapchainMaintenance1FeaturesEXTBuilder<'a> {
        PhysicalDeviceSwapchainMaintenance1FeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceSwapchainMaintenance1FeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceSwapchainMaintenance1FeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceSwapchainMaintenance1FeaturesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceSwapchainMaintenance1FeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSwapchainMaintenance1FeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSwapchainMaintenance1FeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceSwapchainMaintenance1FeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceSwapchainMaintenance1FeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceSwapchainMaintenance1FeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceSwapchainMaintenance1FeaturesEXTBuilder<'a> {
    #[inline]
    pub fn swapchain_maintenance1(mut self, swapchain_maintenance1: bool) -> Self {
        self.inner.swapchain_maintenance1 = swapchain_maintenance1.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceSwapchainMaintenance1FeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainPresentFenceInfoEXT.html>"]
pub struct SwapchainPresentFenceInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain_count: u32,
    pub p_fences: *const Fence,
}
impl ::std::default::Default for SwapchainPresentFenceInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            swapchain_count: u32::default(),
            p_fences: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for SwapchainPresentFenceInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::SWAPCHAIN_PRESENT_FENCE_INFO_EXT;
}
impl SwapchainPresentFenceInfoEXT {
    pub fn builder<'a>() -> SwapchainPresentFenceInfoEXTBuilder<'a> {
        SwapchainPresentFenceInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SwapchainPresentFenceInfoEXTBuilder<'a> {
    inner: SwapchainPresentFenceInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPresentInfoKHR for SwapchainPresentFenceInfoEXTBuilder<'_> {}
unsafe impl ExtendsPresentInfoKHR for SwapchainPresentFenceInfoEXT {}
impl<'a> ::std::ops::Deref for SwapchainPresentFenceInfoEXTBuilder<'a> {
    type Target = SwapchainPresentFenceInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SwapchainPresentFenceInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SwapchainPresentFenceInfoEXTBuilder<'a> {
    #[inline]
    pub fn fences(mut self, fences: &'a [Fence]) -> Self {
        self.inner.swapchain_count = fences.len() as _;
        self.inner.p_fences = fences.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SwapchainPresentFenceInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainPresentModesCreateInfoEXT.html>"]
pub struct SwapchainPresentModesCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub present_mode_count: u32,
    pub p_present_modes: *const PresentModeKHR,
}
impl ::std::default::Default for SwapchainPresentModesCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            present_mode_count: u32::default(),
            p_present_modes: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for SwapchainPresentModesCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT;
}
impl SwapchainPresentModesCreateInfoEXT {
    pub fn builder<'a>() -> SwapchainPresentModesCreateInfoEXTBuilder<'a> {
        SwapchainPresentModesCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SwapchainPresentModesCreateInfoEXTBuilder<'a> {
    inner: SwapchainPresentModesCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSwapchainCreateInfoKHR for SwapchainPresentModesCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsSwapchainCreateInfoKHR for SwapchainPresentModesCreateInfoEXT {}
impl<'a> ::std::ops::Deref for SwapchainPresentModesCreateInfoEXTBuilder<'a> {
    type Target = SwapchainPresentModesCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SwapchainPresentModesCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SwapchainPresentModesCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn present_modes(mut self, present_modes: &'a [PresentModeKHR]) -> Self {
        self.inner.present_mode_count = present_modes.len() as _;
        self.inner.p_present_modes = present_modes.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SwapchainPresentModesCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainPresentModeInfoEXT.html>"]
pub struct SwapchainPresentModeInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain_count: u32,
    pub p_present_modes: *const PresentModeKHR,
}
impl ::std::default::Default for SwapchainPresentModeInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            swapchain_count: u32::default(),
            p_present_modes: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for SwapchainPresentModeInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::SWAPCHAIN_PRESENT_MODE_INFO_EXT;
}
impl SwapchainPresentModeInfoEXT {
    pub fn builder<'a>() -> SwapchainPresentModeInfoEXTBuilder<'a> {
        SwapchainPresentModeInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SwapchainPresentModeInfoEXTBuilder<'a> {
    inner: SwapchainPresentModeInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPresentInfoKHR for SwapchainPresentModeInfoEXTBuilder<'_> {}
unsafe impl ExtendsPresentInfoKHR for SwapchainPresentModeInfoEXT {}
impl<'a> ::std::ops::Deref for SwapchainPresentModeInfoEXTBuilder<'a> {
    type Target = SwapchainPresentModeInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SwapchainPresentModeInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SwapchainPresentModeInfoEXTBuilder<'a> {
    #[inline]
    pub fn present_modes(mut self, present_modes: &'a [PresentModeKHR]) -> Self {
        self.inner.swapchain_count = present_modes.len() as _;
        self.inner.p_present_modes = present_modes.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SwapchainPresentModeInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainPresentScalingCreateInfoEXT.html>"]
pub struct SwapchainPresentScalingCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub scaling_behavior: PresentScalingFlagsEXT,
    pub present_gravity_x: PresentGravityFlagsEXT,
    pub present_gravity_y: PresentGravityFlagsEXT,
}
impl ::std::default::Default for SwapchainPresentScalingCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            scaling_behavior: PresentScalingFlagsEXT::default(),
            present_gravity_x: PresentGravityFlagsEXT::default(),
            present_gravity_y: PresentGravityFlagsEXT::default(),
        }
    }
}
unsafe impl TaggedStructure for SwapchainPresentScalingCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT;
}
impl SwapchainPresentScalingCreateInfoEXT {
    pub fn builder<'a>() -> SwapchainPresentScalingCreateInfoEXTBuilder<'a> {
        SwapchainPresentScalingCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct SwapchainPresentScalingCreateInfoEXTBuilder<'a> {
    inner: SwapchainPresentScalingCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSwapchainCreateInfoKHR for SwapchainPresentScalingCreateInfoEXTBuilder<'_> {}
unsafe impl ExtendsSwapchainCreateInfoKHR for SwapchainPresentScalingCreateInfoEXT {}
impl<'a> ::std::ops::Deref for SwapchainPresentScalingCreateInfoEXTBuilder<'a> {
    type Target = SwapchainPresentScalingCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for SwapchainPresentScalingCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> SwapchainPresentScalingCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn scaling_behavior(mut self, scaling_behavior: PresentScalingFlagsEXT) -> Self {
        self.inner.scaling_behavior = scaling_behavior;
        self
    }
    #[inline]
    pub fn present_gravity_x(mut self, present_gravity_x: PresentGravityFlagsEXT) -> Self {
        self.inner.present_gravity_x = present_gravity_x;
        self
    }
    #[inline]
    pub fn present_gravity_y(mut self, present_gravity_y: PresentGravityFlagsEXT) -> Self {
        self.inner.present_gravity_y = present_gravity_y;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> SwapchainPresentScalingCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkReleaseSwapchainImagesInfoEXT.html>"]
pub struct ReleaseSwapchainImagesInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub swapchain: SwapchainKHR,
    pub image_index_count: u32,
    pub p_image_indices: *const u32,
}
impl ::std::default::Default for ReleaseSwapchainImagesInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            swapchain: SwapchainKHR::default(),
            image_index_count: u32::default(),
            p_image_indices: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for ReleaseSwapchainImagesInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::RELEASE_SWAPCHAIN_IMAGES_INFO_EXT;
}
impl ReleaseSwapchainImagesInfoEXT {
    pub fn builder<'a>() -> ReleaseSwapchainImagesInfoEXTBuilder<'a> {
        ReleaseSwapchainImagesInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ReleaseSwapchainImagesInfoEXTBuilder<'a> {
    inner: ReleaseSwapchainImagesInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for ReleaseSwapchainImagesInfoEXTBuilder<'a> {
    type Target = ReleaseSwapchainImagesInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ReleaseSwapchainImagesInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ReleaseSwapchainImagesInfoEXTBuilder<'a> {
    #[inline]
    pub fn swapchain(mut self, swapchain: SwapchainKHR) -> Self {
        self.inner.swapchain = swapchain;
        self
    }
    #[inline]
    pub fn image_indices(mut self, image_indices: &'a [u32]) -> Self {
        self.inner.image_index_count = image_indices.len() as _;
        self.inner.p_image_indices = image_indices.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ReleaseSwapchainImagesInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV.html>"]
pub struct PhysicalDeviceRayTracingInvocationReorderFeaturesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ray_tracing_invocation_reorder: Bool32,
}
impl ::std::default::Default for PhysicalDeviceRayTracingInvocationReorderFeaturesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            ray_tracing_invocation_reorder: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceRayTracingInvocationReorderFeaturesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV;
}
impl PhysicalDeviceRayTracingInvocationReorderFeaturesNV {
    pub fn builder<'a>() -> PhysicalDeviceRayTracingInvocationReorderFeaturesNVBuilder<'a> {
        PhysicalDeviceRayTracingInvocationReorderFeaturesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceRayTracingInvocationReorderFeaturesNVBuilder<'a> {
    inner: PhysicalDeviceRayTracingInvocationReorderFeaturesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceRayTracingInvocationReorderFeaturesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRayTracingInvocationReorderFeaturesNV {}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceRayTracingInvocationReorderFeaturesNVBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRayTracingInvocationReorderFeaturesNV {}
impl<'a> ::std::ops::Deref for PhysicalDeviceRayTracingInvocationReorderFeaturesNVBuilder<'a> {
    type Target = PhysicalDeviceRayTracingInvocationReorderFeaturesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceRayTracingInvocationReorderFeaturesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceRayTracingInvocationReorderFeaturesNVBuilder<'a> {
    #[inline]
    pub fn ray_tracing_invocation_reorder(mut self, ray_tracing_invocation_reorder: bool) -> Self {
        self.inner.ray_tracing_invocation_reorder = ray_tracing_invocation_reorder.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceRayTracingInvocationReorderFeaturesNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV.html>"]
pub struct PhysicalDeviceRayTracingInvocationReorderPropertiesNV {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ray_tracing_invocation_reorder_reordering_hint: RayTracingInvocationReorderModeNV,
}
impl ::std::default::Default for PhysicalDeviceRayTracingInvocationReorderPropertiesNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            ray_tracing_invocation_reorder_reordering_hint:
                RayTracingInvocationReorderModeNV::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceRayTracingInvocationReorderPropertiesNV {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV;
}
impl PhysicalDeviceRayTracingInvocationReorderPropertiesNV {
    pub fn builder<'a>() -> PhysicalDeviceRayTracingInvocationReorderPropertiesNVBuilder<'a> {
        PhysicalDeviceRayTracingInvocationReorderPropertiesNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceRayTracingInvocationReorderPropertiesNVBuilder<'a> {
    inner: PhysicalDeviceRayTracingInvocationReorderPropertiesNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceRayTracingInvocationReorderPropertiesNVBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceRayTracingInvocationReorderPropertiesNV
{
}
impl<'a> ::std::ops::Deref for PhysicalDeviceRayTracingInvocationReorderPropertiesNVBuilder<'a> {
    type Target = PhysicalDeviceRayTracingInvocationReorderPropertiesNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceRayTracingInvocationReorderPropertiesNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceRayTracingInvocationReorderPropertiesNVBuilder<'a> {
    #[inline]
    pub fn ray_tracing_invocation_reorder_reordering_hint(
        mut self,
        ray_tracing_invocation_reorder_reordering_hint: RayTracingInvocationReorderModeNV,
    ) -> Self {
        self.inner.ray_tracing_invocation_reorder_reordering_hint =
            ray_tracing_invocation_reorder_reordering_hint;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceRayTracingInvocationReorderPropertiesNV {
        self.inner
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDirectDriverLoadingInfoLUNARG.html>"]
pub struct DirectDriverLoadingInfoLUNARG {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub flags: DirectDriverLoadingFlagsLUNARG,
    pub pfn_get_instance_proc_addr: PFN_vkGetInstanceProcAddrLUNARG,
}
#[cfg(feature = "debug")]
impl fmt::Debug for DirectDriverLoadingInfoLUNARG {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("DirectDriverLoadingInfoLUNARG")
            .field("s_type", &self.s_type)
            .field("p_next", &self.p_next)
            .field("flags", &self.flags)
            .field(
                "pfn_get_instance_proc_addr",
                &(self.pfn_get_instance_proc_addr.map(|x| x as *const ())),
            )
            .finish()
    }
}
impl ::std::default::Default for DirectDriverLoadingInfoLUNARG {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            flags: DirectDriverLoadingFlagsLUNARG::default(),
            pfn_get_instance_proc_addr: PFN_vkGetInstanceProcAddrLUNARG::default(),
        }
    }
}
unsafe impl TaggedStructure for DirectDriverLoadingInfoLUNARG {
    const STRUCTURE_TYPE: StructureType = StructureType::DIRECT_DRIVER_LOADING_INFO_LUNARG;
}
impl DirectDriverLoadingInfoLUNARG {
    pub fn builder<'a>() -> DirectDriverLoadingInfoLUNARGBuilder<'a> {
        DirectDriverLoadingInfoLUNARGBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DirectDriverLoadingInfoLUNARGBuilder<'a> {
    inner: DirectDriverLoadingInfoLUNARG,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for DirectDriverLoadingInfoLUNARGBuilder<'a> {
    type Target = DirectDriverLoadingInfoLUNARG;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DirectDriverLoadingInfoLUNARGBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DirectDriverLoadingInfoLUNARGBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: DirectDriverLoadingFlagsLUNARG) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn pfn_get_instance_proc_addr(
        mut self,
        pfn_get_instance_proc_addr: PFN_vkGetInstanceProcAddrLUNARG,
    ) -> Self {
        self.inner.pfn_get_instance_proc_addr = pfn_get_instance_proc_addr;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DirectDriverLoadingInfoLUNARG {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDirectDriverLoadingListLUNARG.html>"]
pub struct DirectDriverLoadingListLUNARG {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub mode: DirectDriverLoadingModeLUNARG,
    pub driver_count: u32,
    pub p_drivers: *const DirectDriverLoadingInfoLUNARG,
}
impl ::std::default::Default for DirectDriverLoadingListLUNARG {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            mode: DirectDriverLoadingModeLUNARG::default(),
            driver_count: u32::default(),
            p_drivers: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for DirectDriverLoadingListLUNARG {
    const STRUCTURE_TYPE: StructureType = StructureType::DIRECT_DRIVER_LOADING_LIST_LUNARG;
}
impl DirectDriverLoadingListLUNARG {
    pub fn builder<'a>() -> DirectDriverLoadingListLUNARGBuilder<'a> {
        DirectDriverLoadingListLUNARGBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct DirectDriverLoadingListLUNARGBuilder<'a> {
    inner: DirectDriverLoadingListLUNARG,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsInstanceCreateInfo for DirectDriverLoadingListLUNARGBuilder<'_> {}
unsafe impl ExtendsInstanceCreateInfo for DirectDriverLoadingListLUNARG {}
impl<'a> ::std::ops::Deref for DirectDriverLoadingListLUNARGBuilder<'a> {
    type Target = DirectDriverLoadingListLUNARG;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for DirectDriverLoadingListLUNARGBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> DirectDriverLoadingListLUNARGBuilder<'a> {
    #[inline]
    pub fn mode(mut self, mode: DirectDriverLoadingModeLUNARG) -> Self {
        self.inner.mode = mode;
        self
    }
    #[inline]
    pub fn drivers(mut self, drivers: &'a [DirectDriverLoadingInfoLUNARG]) -> Self {
        self.inner.driver_count = drivers.len() as _;
        self.inner.p_drivers = drivers.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> DirectDriverLoadingListLUNARG {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM.html>"]
pub struct PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub multiview_per_view_viewports: Bool32,
}
impl ::std::default::Default for PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            multiview_per_view_viewports: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM;
}
impl PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM {
    pub fn builder<'a>() -> PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOMBuilder<'a> {
        PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOMBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOMBuilder<'a> {
    inner: PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOMBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM {}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOMBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM {}
impl<'a> ::std::ops::Deref for PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOMBuilder<'a> {
    type Target = PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOMBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOMBuilder<'a> {
    #[inline]
    pub fn multiview_per_view_viewports(mut self, multiview_per_view_viewports: bool) -> Self {
        self.inner.multiview_per_view_viewports = multiview_per_view_viewports.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR.html>"]
pub struct PhysicalDeviceRayTracingPositionFetchFeaturesKHR {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub ray_tracing_position_fetch: Bool32,
}
impl ::std::default::Default for PhysicalDeviceRayTracingPositionFetchFeaturesKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            ray_tracing_position_fetch: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceRayTracingPositionFetchFeaturesKHR {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR;
}
impl PhysicalDeviceRayTracingPositionFetchFeaturesKHR {
    pub fn builder<'a>() -> PhysicalDeviceRayTracingPositionFetchFeaturesKHRBuilder<'a> {
        PhysicalDeviceRayTracingPositionFetchFeaturesKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceRayTracingPositionFetchFeaturesKHRBuilder<'a> {
    inner: PhysicalDeviceRayTracingPositionFetchFeaturesKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceRayTracingPositionFetchFeaturesKHRBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRayTracingPositionFetchFeaturesKHR {}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceRayTracingPositionFetchFeaturesKHRBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRayTracingPositionFetchFeaturesKHR {}
impl<'a> ::std::ops::Deref for PhysicalDeviceRayTracingPositionFetchFeaturesKHRBuilder<'a> {
    type Target = PhysicalDeviceRayTracingPositionFetchFeaturesKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceRayTracingPositionFetchFeaturesKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceRayTracingPositionFetchFeaturesKHRBuilder<'a> {
    #[inline]
    pub fn ray_tracing_position_fetch(mut self, ray_tracing_position_fetch: bool) -> Self {
        self.inner.ray_tracing_position_fetch = ray_tracing_position_fetch.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceRayTracingPositionFetchFeaturesKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderCorePropertiesARM.html>"]
pub struct PhysicalDeviceShaderCorePropertiesARM {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub pixel_rate: u32,
    pub texel_rate: u32,
    pub fma_rate: u32,
}
impl ::std::default::Default for PhysicalDeviceShaderCorePropertiesARM {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            pixel_rate: u32::default(),
            texel_rate: u32::default(),
            fma_rate: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderCorePropertiesARM {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM;
}
impl PhysicalDeviceShaderCorePropertiesARM {
    pub fn builder<'a>() -> PhysicalDeviceShaderCorePropertiesARMBuilder<'a> {
        PhysicalDeviceShaderCorePropertiesARMBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderCorePropertiesARMBuilder<'a> {
    inner: PhysicalDeviceShaderCorePropertiesARM,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceShaderCorePropertiesARMBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceShaderCorePropertiesARM {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderCorePropertiesARMBuilder<'a> {
    type Target = PhysicalDeviceShaderCorePropertiesARM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderCorePropertiesARMBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderCorePropertiesARMBuilder<'a> {
    #[inline]
    pub fn pixel_rate(mut self, pixel_rate: u32) -> Self {
        self.inner.pixel_rate = pixel_rate;
        self
    }
    #[inline]
    pub fn texel_rate(mut self, texel_rate: u32) -> Self {
        self.inner.texel_rate = texel_rate;
        self
    }
    #[inline]
    pub fn fma_rate(mut self, fma_rate: u32) -> Self {
        self.inner.fma_rate = fma_rate;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderCorePropertiesARM {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM.html>"]
pub struct PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub multiview_per_view_render_areas: Bool32,
}
impl ::std::default::Default for PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            multiview_per_view_render_areas: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM;
}
impl PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM {
    pub fn builder<'a>() -> PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOMBuilder<'a> {
        PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOMBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOMBuilder<'a> {
    inner: PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOMBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceFeatures2
    for PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM
{
}
unsafe impl ExtendsDeviceCreateInfo
    for PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOMBuilder<'_>
{
}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM {}
impl<'a> ::std::ops::Deref for PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOMBuilder<'a> {
    type Target = PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOMBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOMBuilder<'a> {
    #[inline]
    pub fn multiview_per_view_render_areas(
        mut self,
        multiview_per_view_render_areas: bool,
    ) -> Self {
        self.inner.multiview_per_view_render_areas = multiview_per_view_render_areas.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM.html>"]
pub struct MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub per_view_render_area_count: u32,
    pub p_per_view_render_areas: *const Rect2D,
}
impl ::std::default::Default for MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            per_view_render_area_count: u32::default(),
            p_per_view_render_areas: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM {
    const STRUCTURE_TYPE: StructureType =
        StructureType::MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM;
}
impl MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM {
    pub fn builder<'a>() -> MultiviewPerViewRenderAreasRenderPassBeginInfoQCOMBuilder<'a> {
        MultiviewPerViewRenderAreasRenderPassBeginInfoQCOMBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MultiviewPerViewRenderAreasRenderPassBeginInfoQCOMBuilder<'a> {
    inner: MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsRenderPassBeginInfo
    for MultiviewPerViewRenderAreasRenderPassBeginInfoQCOMBuilder<'_>
{
}
unsafe impl ExtendsRenderPassBeginInfo for MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM {}
unsafe impl ExtendsRenderingInfo for MultiviewPerViewRenderAreasRenderPassBeginInfoQCOMBuilder<'_> {}
unsafe impl ExtendsRenderingInfo for MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM {}
impl<'a> ::std::ops::Deref for MultiviewPerViewRenderAreasRenderPassBeginInfoQCOMBuilder<'a> {
    type Target = MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MultiviewPerViewRenderAreasRenderPassBeginInfoQCOMBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MultiviewPerViewRenderAreasRenderPassBeginInfoQCOMBuilder<'a> {
    #[inline]
    pub fn per_view_render_areas(mut self, per_view_render_areas: &'a [Rect2D]) -> Self {
        self.inner.per_view_render_area_count = per_view_render_areas.len() as _;
        self.inner.p_per_view_render_areas = per_view_render_areas.as_ptr();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryLowLatencySupportNV.html>"]
pub struct QueryLowLatencySupportNV {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub p_queried_low_latency_data: *mut c_void,
}
impl ::std::default::Default for QueryLowLatencySupportNV {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            p_queried_low_latency_data: ::std::ptr::null_mut(),
        }
    }
}
unsafe impl TaggedStructure for QueryLowLatencySupportNV {
    const STRUCTURE_TYPE: StructureType = StructureType::QUERY_LOW_LATENCY_SUPPORT_NV;
}
impl QueryLowLatencySupportNV {
    pub fn builder<'a>() -> QueryLowLatencySupportNVBuilder<'a> {
        QueryLowLatencySupportNVBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct QueryLowLatencySupportNVBuilder<'a> {
    inner: QueryLowLatencySupportNV,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsSemaphoreCreateInfo for QueryLowLatencySupportNVBuilder<'_> {}
unsafe impl ExtendsSemaphoreCreateInfo for QueryLowLatencySupportNV {}
impl<'a> ::std::ops::Deref for QueryLowLatencySupportNVBuilder<'a> {
    type Target = QueryLowLatencySupportNV;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for QueryLowLatencySupportNVBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> QueryLowLatencySupportNVBuilder<'a> {
    #[inline]
    pub fn queried_low_latency_data(mut self, queried_low_latency_data: *mut c_void) -> Self {
        self.inner.p_queried_low_latency_data = queried_low_latency_data;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> QueryLowLatencySupportNV {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryMapInfoKHR.html>"]
pub struct MemoryMapInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: MemoryMapFlags,
    pub memory: DeviceMemory,
    pub offset: DeviceSize,
    pub size: DeviceSize,
}
impl ::std::default::Default for MemoryMapInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: MemoryMapFlags::default(),
            memory: DeviceMemory::default(),
            offset: DeviceSize::default(),
            size: DeviceSize::default(),
        }
    }
}
unsafe impl TaggedStructure for MemoryMapInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_MAP_INFO_KHR;
}
impl MemoryMapInfoKHR {
    pub fn builder<'a>() -> MemoryMapInfoKHRBuilder<'a> {
        MemoryMapInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MemoryMapInfoKHRBuilder<'a> {
    inner: MemoryMapInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MemoryMapInfoKHRBuilder<'a> {
    type Target = MemoryMapInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MemoryMapInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MemoryMapInfoKHRBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: MemoryMapFlags) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    #[inline]
    pub fn offset(mut self, offset: DeviceSize) -> Self {
        self.inner.offset = offset;
        self
    }
    #[inline]
    pub fn size(mut self, size: DeviceSize) -> Self {
        self.inner.size = size;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MemoryMapInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryUnmapInfoKHR.html>"]
pub struct MemoryUnmapInfoKHR {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: MemoryUnmapFlagsKHR,
    pub memory: DeviceMemory,
}
impl ::std::default::Default for MemoryUnmapInfoKHR {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: MemoryUnmapFlagsKHR::default(),
            memory: DeviceMemory::default(),
        }
    }
}
unsafe impl TaggedStructure for MemoryUnmapInfoKHR {
    const STRUCTURE_TYPE: StructureType = StructureType::MEMORY_UNMAP_INFO_KHR;
}
impl MemoryUnmapInfoKHR {
    pub fn builder<'a>() -> MemoryUnmapInfoKHRBuilder<'a> {
        MemoryUnmapInfoKHRBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct MemoryUnmapInfoKHRBuilder<'a> {
    inner: MemoryUnmapInfoKHR,
    marker: ::std::marker::PhantomData<&'a ()>,
}
impl<'a> ::std::ops::Deref for MemoryUnmapInfoKHRBuilder<'a> {
    type Target = MemoryUnmapInfoKHR;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for MemoryUnmapInfoKHRBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> MemoryUnmapInfoKHRBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: MemoryUnmapFlagsKHR) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn memory(mut self, memory: DeviceMemory) -> Self {
        self.inner.memory = memory;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> MemoryUnmapInfoKHR {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderObjectFeaturesEXT.html>"]
pub struct PhysicalDeviceShaderObjectFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_object: Bool32,
}
impl ::std::default::Default for PhysicalDeviceShaderObjectFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_object: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderObjectFeaturesEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT;
}
impl PhysicalDeviceShaderObjectFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceShaderObjectFeaturesEXTBuilder<'a> {
        PhysicalDeviceShaderObjectFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderObjectFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceShaderObjectFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderObjectFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderObjectFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderObjectFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderObjectFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderObjectFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceShaderObjectFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderObjectFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderObjectFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn shader_object(mut self, shader_object: bool) -> Self {
        self.inner.shader_object = shader_object.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderObjectFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderObjectPropertiesEXT.html>"]
pub struct PhysicalDeviceShaderObjectPropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_binary_uuid: [u8; UUID_SIZE],
    pub shader_binary_version: u32,
}
impl ::std::default::Default for PhysicalDeviceShaderObjectPropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_binary_uuid: unsafe { ::std::mem::zeroed() },
            shader_binary_version: u32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderObjectPropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT;
}
impl PhysicalDeviceShaderObjectPropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceShaderObjectPropertiesEXTBuilder<'a> {
        PhysicalDeviceShaderObjectPropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderObjectPropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceShaderObjectPropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceShaderObjectPropertiesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceShaderObjectPropertiesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderObjectPropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceShaderObjectPropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderObjectPropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderObjectPropertiesEXTBuilder<'a> {
    #[inline]
    pub fn shader_binary_uuid(mut self, shader_binary_uuid: [u8; UUID_SIZE]) -> Self {
        self.inner.shader_binary_uuid = shader_binary_uuid;
        self
    }
    #[inline]
    pub fn shader_binary_version(mut self, shader_binary_version: u32) -> Self {
        self.inner.shader_binary_version = shader_binary_version;
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderObjectPropertiesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderCreateInfoEXT.html>"]
pub struct ShaderCreateInfoEXT {
    pub s_type: StructureType,
    pub p_next: *const c_void,
    pub flags: ShaderCreateFlagsEXT,
    pub stage: ShaderStageFlags,
    pub next_stage: ShaderStageFlags,
    pub code_type: ShaderCodeTypeEXT,
    pub code_size: usize,
    pub p_code: *const c_void,
    pub p_name: *const c_char,
    pub set_layout_count: u32,
    pub p_set_layouts: *const DescriptorSetLayout,
    pub push_constant_range_count: u32,
    pub p_push_constant_ranges: *const PushConstantRange,
    pub p_specialization_info: *const SpecializationInfo,
}
impl ::std::default::Default for ShaderCreateInfoEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null(),
            flags: ShaderCreateFlagsEXT::default(),
            stage: ShaderStageFlags::default(),
            next_stage: ShaderStageFlags::default(),
            code_type: ShaderCodeTypeEXT::default(),
            code_size: usize::default(),
            p_code: ::std::ptr::null(),
            p_name: ::std::ptr::null(),
            set_layout_count: u32::default(),
            p_set_layouts: ::std::ptr::null(),
            push_constant_range_count: u32::default(),
            p_push_constant_ranges: ::std::ptr::null(),
            p_specialization_info: ::std::ptr::null(),
        }
    }
}
unsafe impl TaggedStructure for ShaderCreateInfoEXT {
    const STRUCTURE_TYPE: StructureType = StructureType::SHADER_CREATE_INFO_EXT;
}
impl ShaderCreateInfoEXT {
    pub fn builder<'a>() -> ShaderCreateInfoEXTBuilder<'a> {
        ShaderCreateInfoEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct ShaderCreateInfoEXTBuilder<'a> {
    inner: ShaderCreateInfoEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
pub unsafe trait ExtendsShaderCreateInfoEXT {}
impl<'a> ::std::ops::Deref for ShaderCreateInfoEXTBuilder<'a> {
    type Target = ShaderCreateInfoEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for ShaderCreateInfoEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> ShaderCreateInfoEXTBuilder<'a> {
    #[inline]
    pub fn flags(mut self, flags: ShaderCreateFlagsEXT) -> Self {
        self.inner.flags = flags;
        self
    }
    #[inline]
    pub fn stage(mut self, stage: ShaderStageFlags) -> Self {
        self.inner.stage = stage;
        self
    }
    #[inline]
    pub fn next_stage(mut self, next_stage: ShaderStageFlags) -> Self {
        self.inner.next_stage = next_stage;
        self
    }
    #[inline]
    pub fn code_type(mut self, code_type: ShaderCodeTypeEXT) -> Self {
        self.inner.code_type = code_type;
        self
    }
    #[inline]
    pub fn code(mut self, code: &'a [u8]) -> Self {
        self.inner.code_size = code.len();
        self.inner.p_code = code.as_ptr().cast();
        self
    }
    #[inline]
    pub fn name(mut self, name: &'a ::std::ffi::CStr) -> Self {
        self.inner.p_name = name.as_ptr();
        self
    }
    #[inline]
    pub fn set_layouts(mut self, set_layouts: &'a [DescriptorSetLayout]) -> Self {
        self.inner.set_layout_count = set_layouts.len() as _;
        self.inner.p_set_layouts = set_layouts.as_ptr();
        self
    }
    #[inline]
    pub fn push_constant_ranges(mut self, push_constant_ranges: &'a [PushConstantRange]) -> Self {
        self.inner.push_constant_range_count = push_constant_ranges.len() as _;
        self.inner.p_push_constant_ranges = push_constant_ranges.as_ptr();
        self
    }
    #[inline]
    pub fn specialization_info(mut self, specialization_info: &'a SpecializationInfo) -> Self {
        self.inner.p_specialization_info = specialization_info;
        self
    }
    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
    #[doc = r" valid extension structs can be pushed into the chain."]
    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
    #[doc = r" chain will look like `A -> D -> B -> C`."]
    pub fn push_next<T: ExtendsShaderCreateInfoEXT>(mut self, next: &'a mut T) -> Self {
        unsafe {
            let next_ptr = <*const T>::cast(next);
            let last_next = ptr_chain_iter(next).last().unwrap();
            (*last_next).p_next = self.inner.p_next as _;
            self.inner.p_next = next_ptr;
        }
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> ShaderCreateInfoEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderTileImageFeaturesEXT.html>"]
pub struct PhysicalDeviceShaderTileImageFeaturesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_tile_image_color_read_access: Bool32,
    pub shader_tile_image_depth_read_access: Bool32,
    pub shader_tile_image_stencil_read_access: Bool32,
}
impl ::std::default::Default for PhysicalDeviceShaderTileImageFeaturesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_tile_image_color_read_access: Bool32::default(),
            shader_tile_image_depth_read_access: Bool32::default(),
            shader_tile_image_stencil_read_access: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderTileImageFeaturesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT;
}
impl PhysicalDeviceShaderTileImageFeaturesEXT {
    pub fn builder<'a>() -> PhysicalDeviceShaderTileImageFeaturesEXTBuilder<'a> {
        PhysicalDeviceShaderTileImageFeaturesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderTileImageFeaturesEXTBuilder<'a> {
    inner: PhysicalDeviceShaderTileImageFeaturesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderTileImageFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderTileImageFeaturesEXT {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderTileImageFeaturesEXTBuilder<'_> {}
unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderTileImageFeaturesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderTileImageFeaturesEXTBuilder<'a> {
    type Target = PhysicalDeviceShaderTileImageFeaturesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderTileImageFeaturesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderTileImageFeaturesEXTBuilder<'a> {
    #[inline]
    pub fn shader_tile_image_color_read_access(
        mut self,
        shader_tile_image_color_read_access: bool,
    ) -> Self {
        self.inner.shader_tile_image_color_read_access = shader_tile_image_color_read_access.into();
        self
    }
    #[inline]
    pub fn shader_tile_image_depth_read_access(
        mut self,
        shader_tile_image_depth_read_access: bool,
    ) -> Self {
        self.inner.shader_tile_image_depth_read_access = shader_tile_image_depth_read_access.into();
        self
    }
    #[inline]
    pub fn shader_tile_image_stencil_read_access(
        mut self,
        shader_tile_image_stencil_read_access: bool,
    ) -> Self {
        self.inner.shader_tile_image_stencil_read_access =
            shader_tile_image_stencil_read_access.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderTileImageFeaturesEXT {
        self.inner
    }
}
#[repr(C)]
#[cfg_attr(feature = "debug", derive(Debug))]
#[derive(Copy, Clone)]
#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderTileImagePropertiesEXT.html>"]
pub struct PhysicalDeviceShaderTileImagePropertiesEXT {
    pub s_type: StructureType,
    pub p_next: *mut c_void,
    pub shader_tile_image_coherent_read_accelerated: Bool32,
    pub shader_tile_image_read_sample_from_pixel_rate_invocation: Bool32,
    pub shader_tile_image_read_from_helper_invocation: Bool32,
}
impl ::std::default::Default for PhysicalDeviceShaderTileImagePropertiesEXT {
    #[inline]
    fn default() -> Self {
        Self {
            s_type: Self::STRUCTURE_TYPE,
            p_next: ::std::ptr::null_mut(),
            shader_tile_image_coherent_read_accelerated: Bool32::default(),
            shader_tile_image_read_sample_from_pixel_rate_invocation: Bool32::default(),
            shader_tile_image_read_from_helper_invocation: Bool32::default(),
        }
    }
}
unsafe impl TaggedStructure for PhysicalDeviceShaderTileImagePropertiesEXT {
    const STRUCTURE_TYPE: StructureType =
        StructureType::PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT;
}
impl PhysicalDeviceShaderTileImagePropertiesEXT {
    pub fn builder<'a>() -> PhysicalDeviceShaderTileImagePropertiesEXTBuilder<'a> {
        PhysicalDeviceShaderTileImagePropertiesEXTBuilder {
            inner: Self::default(),
            marker: ::std::marker::PhantomData,
        }
    }
}
#[repr(transparent)]
pub struct PhysicalDeviceShaderTileImagePropertiesEXTBuilder<'a> {
    inner: PhysicalDeviceShaderTileImagePropertiesEXT,
    marker: ::std::marker::PhantomData<&'a ()>,
}
unsafe impl ExtendsPhysicalDeviceProperties2
    for PhysicalDeviceShaderTileImagePropertiesEXTBuilder<'_>
{
}
unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceShaderTileImagePropertiesEXT {}
impl<'a> ::std::ops::Deref for PhysicalDeviceShaderTileImagePropertiesEXTBuilder<'a> {
    type Target = PhysicalDeviceShaderTileImagePropertiesEXT;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}
impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderTileImagePropertiesEXTBuilder<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}
impl<'a> PhysicalDeviceShaderTileImagePropertiesEXTBuilder<'a> {
    #[inline]
    pub fn shader_tile_image_coherent_read_accelerated(
        mut self,
        shader_tile_image_coherent_read_accelerated: bool,
    ) -> Self {
        self.inner.shader_tile_image_coherent_read_accelerated =
            shader_tile_image_coherent_read_accelerated.into();
        self
    }
    #[inline]
    pub fn shader_tile_image_read_sample_from_pixel_rate_invocation(
        mut self,
        shader_tile_image_read_sample_from_pixel_rate_invocation: bool,
    ) -> Self {
        self.inner
            .shader_tile_image_read_sample_from_pixel_rate_invocation =
            shader_tile_image_read_sample_from_pixel_rate_invocation.into();
        self
    }
    #[inline]
    pub fn shader_tile_image_read_from_helper_invocation(
        mut self,
        shader_tile_image_read_from_helper_invocation: bool,
    ) -> Self {
        self.inner.shader_tile_image_read_from_helper_invocation =
            shader_tile_image_read_from_helper_invocation.into();
        self
    }
    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
    pub fn build(self) -> PhysicalDeviceShaderTileImagePropertiesEXT {
        self.inner
    }
}
