<?xml version="1.0"?>

<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is this file as it was released on March 28, 2001.
   -
   - The Initial Developer of the Original Code is
   - Peter Annema.
   - Portions created by the Initial Developer are Copyright (C) 2001
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -   David Hyatt <hyatt@netscape.com> (Original Author of <tabbrowser>)
   -   Mike Connor <mconnor@steelgryphon.com>
   -   Christopher Thomas <cst@yecc.com>
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either of the GNU General Public License Version 2 or later (the "GPL"),
   - or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the GPL or the LGPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK ***** -->

<!DOCTYPE bindings [
<!ENTITY % tabBrowserDTD SYSTEM "chrome://global/locale/tabbrowser.dtd" >
%tabBrowserDTD;
]>

<bindings id="tabBrowserBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="tabbrowser">
    <resources>
      <stylesheet src="chrome://global/skin/browser.css"/>
    </resources>

    <content>
      <xul:stringbundle anonid="tbstringbundle" src="chrome://global/locale/tabbrowser.properties"/>
      <xul:tabbox anonid="tabbox" flex="1" eventnode="document" xbl:inherits="handleCtrlPageUpDown">
        <xul:hbox class="tab-drop-indicator-bar" hidden="true">
          <xul:image class="tab-drop-indicator" mousethrough="always"/>
        </xul:hbox>
        <xul:hbox class="tabbrowser-strip" collapsed="true" tooltip="_child" context="_child"
                  anonid="strip"
                  ondraggesture="nsDragAndDrop.startDrag(event, this.parentNode.parentNode); event.stopPropagation();"
                  ondragover="nsDragAndDrop.dragOver(event, this.parentNode.parentNode); event.stopPropagation();"
                  ondragdrop="nsDragAndDrop.drop(event, this.parentNode.parentNode); event.stopPropagation();"
                  ondragexit="nsDragAndDrop.dragExit(event, this.parentNode.parentNode); event.stopPropagation();">
          <xul:tooltip onpopupshowing="event.stopPropagation(); return this.parentNode.parentNode.parentNode.doPreview(this);" orient="vertical">
            <xul:label class="tooltip-label" crop="right"/>
            <xul:label class="tooltip-label" hidden="true"><html:canvas class="tab-tooltip-canvas"/></xul:label>
          </xul:tooltip>
          <xul:menupopup onpopupshowing="this.parentNode.parentNode.parentNode.updatePopupMenu(this);">
            <xul:menuitem label="&closeTab.label;" accesskey="&closeTab.accesskey;"
                          tbattr="tabbrowser-multiple"
                          oncommand="var tabbrowser = this.parentNode.parentNode.parentNode.parentNode;
                                     tabbrowser.removeTab(tabbrowser.mContextTab);"/>
            <xul:menuitem label="&closeOtherTabs.label;" accesskey="&closeOtherTabs.accesskey;"
                          tbattr="tabbrowser-multiple"
                          oncommand="var tabbrowser = this.parentNode.parentNode.parentNode.parentNode;
                                     tabbrowser.removeAllTabsBut(tabbrowser.mContextTab);"/>
            <xul:menuseparator/>
            <xul:menuitem label="&newTab.label;" accesskey="&newTab.accesskey;"
                          xbl:inherits="oncommand=onnewtab"/>
            <xul:menuitem label="&undoCloseTab.label;" accesskey="&undoCloseTab.accesskey;" tbattr="tabbrowser-undoclosetab"
                          oncommand="var tabbrowser = this.parentNode.parentNode.parentNode.parentNode;
                                     tabbrowser.restoreTab(0);"/>
            <xul:menuseparator/>
            <xul:menuitem label="&bookmarkGroup.label;" accesskey="&bookmarkGroup.accesskey;"
                          tbattr="tabbrowser-multiple"
                          xbl:inherits="oncommand=onbookmarkgroup"/>
            <xul:menuseparator/>
            <xul:menuitem label="&reloadTab.label;" accesskey="&reloadTab.accesskey;"
                          oncommand="var tabbrowser = this.parentNode.parentNode.parentNode.parentNode;
                                     tabbrowser.reloadTab(tabbrowser.mContextTab);"/>
            <xul:menuitem label="&reloadAllTabs.label;" accesskey="&reloadAllTabs.accesskey;"
                          tbattr="tabbrowser-multiple"
                          oncommand="var tabbrowser = this.parentNode.parentNode.parentNode.parentNode;
                                     tabbrowser.reloadAllTabs(tabbrowser.mContextTab);"/>
          </xul:menupopup>

          <xul:tabs class="tabbrowser-tabs" closebutton="true" flex="1"
                    anonid="tabcontainer"
                    tooltiptextnew="&newTabButton.tooltip;"
                    setfocus="false"
                    onclick="this.parentNode.parentNode.parentNode.onTabClick(event);"
                    xbl:inherits="onnewtab"
                    onclosetab="var node = this.parentNode;
                                while (node.localName != 'tabbrowser')
                                  node = node.parentNode;
                                node.removeCurrentTab();">
            <xul:tab selected="true" validate="never"
                     onerror="this.parentNode.parentNode.parentNode.parentNode.addToMissedIconCache(this.getAttribute('image'));
                              this.removeAttribute('image');"
                     maxwidth="250" width="0" minwidth="30" flex="100"
                     class="tabbrowser-tab" label="&untitledTab;" crop="end"/>
          </xul:tabs>
        </xul:hbox>
        <xul:tabpanels flex="1" class="plain" selectedIndex="0" anonid="panelcontainer">
          <xul:browser type="content-primary" xbl:inherits="tooltip=contenttooltip,contextmenu=contentcontextmenu"/>
        </xul:tabpanels>
      </xul:tabbox>
      <children/>
    </content>
    <implementation>
      <field name="mPrefs" readonly="true">
        Components.classes['@mozilla.org/preferences-service;1']
                  .getService(Components.interfaces.nsIPrefService)
                  .getBranch(null);
      </field>
      <field name="mURIFixup" readonly="true">
        Components.classes["@mozilla.org/docshell/urifixup;1"]
                  .getService(Components.interfaces.nsIURIFixup);
      </field>
      <field name="mTabBox" readonly="true">
        document.getAnonymousElementByAttribute(this, "anonid", "tabbox");
      </field>
      <field name="mStrip" readonly="true">
        document.getAnonymousElementByAttribute(this, "anonid", "strip");
      </field>
      <field name="mTabContainer" readonly="true">
        document.getAnonymousElementByAttribute(this, "anonid", "tabcontainer");
      </field>
      <field name="mPanelContainer" readonly="true">
        document.getAnonymousElementByAttribute(this, "anonid", "panelcontainer");
      </field>
      <field name="mTabs" readonly="true">
        this.mTabContainer.childNodes
      </field>
      <field name="mStringBundle">
        document.getAnonymousElementByAttribute(this, "anonid", "tbstringbundle");
      </field>
      <field name="mCurrentTab">
        null
      </field>
      <field name="mPreviousTab">
        null
      </field>
      <field name="mCurrentBrowser">
        null
      </field>
      <field name="mProgressListeners">
        []
      </field>
      <field name="mTabListeners">
        new Array()
      </field>
      <field name="mTabFilters">
        new Array()
      </field>
      <field name="mIsBusy">
        false
      </field>
      <field name="mMissedIconCache">
        null
      </field>
      <field name="mContextTab">
        null
      </field>
      <field name="_keyEventHandler" readonly="true">
      <![CDATA[({
        tabbrowser: this,
        handleEvent: function handleEvent(aEvent) {
          if (aEvent.ctrlKey && aEvent.keyCode == KeyEvent.DOM_VK_F4 &&
              this.tabbrowser.mTabBox.handleCtrlPageUpDown &&
              this.tabbrowser.getStripVisibility())
            this.tabbrowser.removeCurrentTab();
        }
      })]]>
      </field>
      <field name="arrowKeysShouldWrap">
        null
      </field>
      <field name="nextTabNumber">
        0
      </field>
      <field name="_browsers">
        null
      </field>
      <field name="savedBrowsers">
        new Array()
      </field>
      <field name="referenceTab">
        null
      </field>

      <method name="doPreview">
        <parameter name="aPopup"/>
        <body>
        <![CDATA[
          var tab = document.tooltipNode;
          if (tab.localName != "tab")
            return false;
          var b = tab.linkedBrowser;
          if (!b)
            return false;

          var label = aPopup.firstChild;
          label.setAttribute("value", tab.getAttribute("label"));

          var canvas = aPopup.lastChild.firstChild;
          canvas.parentNode.hidden = true;

          if (tab == this.mCurrentTab ||
              !this.mPrefs.getBoolPref("browser.tabs.tooltippreview.enable")) {
            label.removeAttribute("width");
            aPopup.removeAttribute("tabpreview");
            return true;
          }

          var ctx;
          try {
            ctx = canvas.getContext("2d");
          } catch (e) {
            return true;
          }

          label.width = 0;
          aPopup.setAttribute("tabpreview", "true");
          var win = b.contentWindow;
          var w = win.innerWidth;
          var h = win.innerHeight;

          var canvasW = this.mPrefs.getIntPref("browser.tabs.tooltippreview.width");
          var canvasH = Math.round(canvasW * h / w);
          canvas.width = canvasW;
          canvas.height = canvasH;
          canvas.parentNode.hidden = false;

          var bgColor = this.mPrefs.getCharPref("browser.display.background_color");
          if (b.contentDocument instanceof ImageDocument &&
              !(b.contentDocument.imageRequest.imageStatus &
                Components.interfaces.imgIRequest.STATUS_ERROR)) {
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, canvasW, canvasH);
            var img = b.contentDocument.body.firstChild;
            var ratio = img.naturalHeight / img.naturalWidth;
            if (img.naturalHeight <= canvasH && img.naturalWidth <= canvasW) {
              ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight);
            }
            else if (ratio * canvasW > canvasH) {
              ctx.drawImage(img, 0, 0, canvasH / ratio, canvasH);
            }
            else {
              ctx.drawImage(img, 0, 0, canvasW, ratio * canvasW);
            }
          }
          else {
            ctx.save();
            ctx.scale(canvasW / w, canvasH / h);
            ctx.drawWindow(win, win.pageXOffset, win.pageYOffset, w, h, bgColor);
            ctx.restore();
          }
          return true;
        ]]>
        </body>
      </method>

      <!-- A web progress listener object definition for a given tab. -->
      <method name="mTabProgressListener">
        <parameter name="aTab"/>
        <parameter name="aBrowser"/>
        <parameter name="aStartsBlank"/>
        <body>
        <![CDATA[
          return ({
            mTabBrowser: this,
            mTab: aTab,
            mBrowser: aBrowser,
            mBlank: aStartsBlank,
            mIcon: "",

            onProgressChange : function (aWebProgress, aRequest,
                                         aCurSelfProgress, aMaxSelfProgress,
                                         aCurTotalProgress, aMaxTotalProgress)
            {
              if (aMaxTotalProgress > 0)
                this.mTab.setAttribute("progress", Math.floor(aCurTotalProgress * 9.9 / aMaxTotalProgress));
              if (!this.mBlank && this.mTabBrowser.mCurrentTab == this.mTab) {
                for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {
                  var p = this.mTabBrowser.mProgressListeners[i];
                  if (p)
                    p.onProgressChange(aWebProgress, aRequest,
                                       aCurSelfProgress, aMaxSelfProgress,
                                       aCurTotalProgress, aMaxTotalProgress);
                }
              }
            },

            onStateChange : function(aWebProgress, aRequest, aStateFlags, aStatus)
            {
              if (!aRequest)
                return;

              var oldBlank = this.mBlank;

              const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
              const nsIChannel = Components.interfaces.nsIChannel;

              if (aStateFlags & nsIWebProgressListener.STATE_START &&
                  aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) {
                // It's okay to clear what the user typed when we start
                // loading a document. If the user types, this flag gets
                // set to false, if the document load ends without an
                // onLocationChange, this flag also gets set to false
                // (so we keep it while switching tabs after a failed load).
                // We need to add 2 because loadURIWithFlags may have
                // cancelled a pending load which would have cleared
                // its anchor scroll detection temporary increment.
                if (aWebProgress.DOMWindow == this.mBrowser.contentWindow)
                  this.mBrowser.userTypedClear += 2;

                if (!this.mBlank) {
                  this.mTab.removeAttribute("progress");
                  this.mTab.setAttribute("busy", "true");
                  this.mTab.label = this.mTabBrowser.mStringBundle.getString("tabs.loading");
                  this.mTab.removeAttribute("image");

                  if (this.mTabBrowser.mCurrentTab == this.mTab)
                    this.mTabBrowser.mIsBusy = true;
                }
              }
              else if (aStateFlags & nsIWebProgressListener.STATE_STOP &&
                       aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) {
                // The document is done loading, it's okay to clear
                // the value again.
                if (aWebProgress.DOMWindow == this.mBrowser.contentWindow)
                  if (this.mBrowser.userTypedClear > 1)
                    this.mBrowser.userTypedClear -= 2;
                  else if (this.mBrowser.userTypedClear > 0)
                    this.mBrowser.userTypedClear--;

                if (this.mBlank)
                  this.mBlank = false;

                this.mTab.removeAttribute("busy");

                var location = this.mBrowser.currentURI;
                if (this.mIcon) {
                  this.mTab.setAttribute("image", this.mIcon);
                }
                else if (this.mBrowser.contentDocument instanceof ImageDocument &&
                         this.mTabBrowser.mPrefs.getBoolPref("browser.chrome.site_icons")) {
                  var req = this.mBrowser.contentDocument.imageRequest;
                  if (req && !(req.imageStatus & Components.interfaces.imgIRequest.STATUS_ERROR)) {
                    try {
                      var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                      var tabImg = document.getAnonymousElementByAttribute(this.mTab, "anonid", "tab-icon");
                      var w = tabImg.boxObject.width;
                      var h = tabImg.boxObject.height;
                      canvas.width = w;
                      canvas.height = h;
                      var ctx = canvas.getContext('2d');
                      ctx.drawImage(this.mBrowser.contentDocument.body.firstChild, 0, 0, w, h);
                      this.mTab.setAttribute("image", canvas.toDataURL());
                    } catch (e) { // non-canvas build, fall back to the old method
                      var sz = this.mTabBrowser.mPrefs.getIntPref("browser.chrome.image_icons.max_size");
                      if (req.image.width <= sz && req.image.height <= sz)
                        this.mTab.setAttribute("image", this.mBrowser.currentURI.spec);
                    }
                  }
                }
                else if (this.mTabBrowser.shouldLoadFavIcon(location))
                  this.mTabBrowser.loadFavIcon(location, "image", this.mTab);

                if (this.mTab.label == this.mTabBrowser.mStringBundle.getString("tabs.loading"))
                  this.mTabBrowser.setTabTitle(this.mTab);

                if (this.mTabBrowser.mCurrentTab == this.mTab)
                  this.mTabBrowser.mIsBusy = false;
              }

              if (!oldBlank && this.mTabBrowser.mCurrentTab == this.mTab) {
                for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {
                  var p = this.mTabBrowser.mProgressListeners[i];
                  if (p)
                    p.onStateChange(aWebProgress, aRequest, aStateFlags, aStatus);
                }
              }
            },

            // The first location change is gotoIndex called from mInstallSH,
            // the second one is considered a user action.
            mLocationChangeCount : 0,

            onLocationChange : function(aWebProgress, aRequest, aLocation)
            {
              this.mIcon = "";

              if (this.mLocationChangeCount > 0 ||
                  aLocation.spec != "about:blank")
                ++this.mLocationChangeCount;

              if (this.mLocationChangeCount == 2) {
                this.mTabBrowser.backBrowserGroup = [];
                this.mTabBrowser.forwardBrowserGroup = [];
              }

              // The document loaded correctly, clear the value if we should
              if (this.mBrowser.userTypedClear > 0)
                this.mBrowser.userTypedValue = null;

              if (!this.mBlank && this.mTabBrowser.mCurrentTab == this.mTab) {
                for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {
                  var p = this.mTabBrowser.mProgressListeners[i];
                  if (p)
                    p.onLocationChange(aWebProgress, aRequest, aLocation);
                }
              }
            },

            onStatusChange : function(aWebProgress, aRequest, aStatus, aMessage)
            {
              if (this.mBlank)
                return;

              if (this.mTabBrowser.mCurrentTab == this.mTab) {
                for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {
                  var p = this.mTabBrowser.mProgressListeners[i];
                  if (p)
                    p.onStatusChange(aWebProgress, aRequest, aStatus, aMessage);
                }
              }
            },

            onSecurityChange : function(aWebProgress, aRequest, aState)
            {
              if (this.mTabBrowser.mCurrentTab == this.mTab) {
                for (var i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {
                  var p = this.mTabBrowser.mProgressListeners[i];
                  if (p)
                    p.onSecurityChange(aWebProgress, aRequest, aState);
                }
              }
            },

            setIcon : function(aURI)
            {
              this.mIcon = aURI;
              if (!this.mTab.hasAttribute("busy"))
                this.mTab.setAttribute("image", aURI);
            },

            QueryInterface : function(aIID)
            {
              if (aIID.equals(Components.interfaces.nsIWebProgressListener) ||
                  aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
                  aIID.equals(Components.interfaces.nsISupports))
                return this;
              throw Components.results.NS_NOINTERFACE;
            }
          });
        ]]>
        </body>
      </method>

      <method name="mInstallSH">
        <parameter name="aBrowser"/>
        <parameter name="aSH"/>
        <body>
        <![CDATA[
          return ({
            mBrowser: aBrowser,
            mSH: aSH,

            onProgressChange : function (aWebProgress, aRequest,
                                         aCurSelfProgress, aMaxSelfProgress,
                                         aCurTotalProgress, aMaxTotalProgress)
            {
            },

            onStateChange : function(aWebProgress, aRequest, aStateFlags, aStatus)
            {
              const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
              if ((aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) &&
                  (aStateFlags & nsIWebProgressListener.STATE_STOP)) {
                function refresh(closure) {
                  closure.mBrowser.webNavigation.sessionHistory = closure.mSH;
                  closure.mBrowser.webProgress.removeProgressListener(closure);
                  delete closure.mBrowser._SHListener;
                  closure.mSH.QueryInterface(Components.interfaces.nsIWebNavigation)
                         .gotoIndex(closure.mSH.index);
                }
                setTimeout(refresh, 0, this);
              }
            },

            onLocationChange : function(aWebProgress, aRequest, aLocation)
            {
            },

            onStatusChange : function(aWebProgress, aRequest, aStatus, aMessage)
            {
            },

            onSecurityChange : function(aWebProgress, aRequest, aState)
            {
            },

            QueryInterface : function(aIID)
            {
              if (aIID.equals(Components.interfaces.nsIWebProgressListener) ||
                  aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
                  aIID.equals(Components.interfaces.nsISupports))
                return this;
              throw Components.results.NS_NOINTERFACE;
            }
          });
        ]]>
        </body>
      </method>

      <method name="buildFavIconString">
        <parameter name="aURI"/>
        <body>
          <![CDATA[
            try {
              aURI = this.mURIFixup.createExposableURI(aURI);
            } catch(ex) { }
            return aURI.resolve("/favicon.ico");
          ]]>
        </body>
      </method>

      <method name="shouldLoadFavIcon">
        <parameter name="aURI"/>
        <body>
          <![CDATA[
            try {
              aURI = this.mURIFixup.createExposableURI(aURI);
            } catch(ex) { }
            return (aURI && this.mPrefs.getBoolPref("browser.chrome.site_icons") &&
                    this.mPrefs.getBoolPref("browser.chrome.favicons") &&
                    ("schemeIs" in aURI) && (aURI.schemeIs("http") || aURI.schemeIs("https")));
          ]]>
        </body>
      </method>

      <method name="loadFavIcon">
        <parameter name="aURI"/>
        <parameter name="aAttr"/>
        <parameter name="aElt"/>
        <body>
          <![CDATA[
            var iconURL = this.buildFavIconString(aURI);
            var entry = this.openCacheEntry(iconURL, Components.interfaces.nsICache.ACCESS_READ);
            if (!entry)
              aElt.setAttribute(aAttr, iconURL);
            else {
              entry.close();
              entry = null;
            }
          ]]>
        </body>
      </method>

      <method name="addToMissedIconCache">
        <parameter name="aURI"/>
        <body>
          <![CDATA[
            var entry = this.openCacheEntry(aURI, Components.interfaces.nsICache.ACCESS_READ_WRITE);
            if (!entry)
              return;

            if (entry.accessGranted == Components.interfaces.nsICache.ACCESS_WRITE)
              // It's a new entry.  Just write a bit of metadata in to the entry.
              entry.setMetaDataElement("Icon", "Missed");
            entry.markValid();
            entry.close();
          ]]>
        </body>
      </method>

      <method name="openCacheEntry">
        <parameter name="key"/>
        <parameter name="access"/>
        <body>
          <![CDATA[
            try {
              if (!this.mMissedIconCache) {
                var cacheService = Components.classes['@mozilla.org/network/cache-service;1'].getService(Components.interfaces.nsICacheService);
                this.mMissedIconCache = cacheService.createSession("MissedIconCache", Components.interfaces.nsICache.STORE_ANYWHERE, true);
                if (!this.mMissedIconCache)
                  return null;
              }
              return this.mMissedIconCache.openCacheEntry(key, access, true);
            }
            catch (e) {
              return null;
            }
          ]]>
        </body>
      </method>

      <method name="updateTitlebar">
        <body>
          <![CDATA[
            var newTitle = "";
            var docTitle;
            var docElement = this.ownerDocument.documentElement;
            var sep = docElement.getAttribute("titlemenuseparator");

            if (this.docShell.contentViewer)
              docTitle = this.contentTitle;

            if (docTitle) {
              newTitle += docElement.getAttribute("titlepreface");
              newTitle += docTitle;
              newTitle += sep;
            }
            newTitle += docElement.getAttribute("titlemodifier");

            // If location bar is hidden and the URL type supports a host,
            // add the scheme and host to the title to prevent spoofing.
            // XXX https://bugzilla.mozilla.org/show_bug.cgi?id=22183#c239
            // (only for schemes that support a host)
            try {
              if (docElement.getAttribute("chromehidden").indexOf("location") != -1) {
                var uri  = this.mURIFixup.createExposableURI(
                             this.mCurrentBrowser.currentURI);
                if (uri.host)
                  newTitle = uri.prePath + sep + newTitle;
              }
            } catch (e) {}

            this.ownerDocument.title = newTitle;
          ]]>
        </body>
      </method>

      <method name="updatePopupMenu">
        <parameter name="aPopupMenu"/>
        <body>
          <![CDATA[
            this.mContextTab = document.popupNode;
            var disabled = this.mTabs.length == 1;
            var menuItems = aPopupMenu.getElementsByAttribute("tbattr", "tabbrowser-multiple");
            for (var i = 0; i < menuItems.length; i++)
              menuItems[i].setAttribute("disabled", disabled);

            var undoItem = document.getAnonymousElementByAttribute(this, "tbattr", "tabbrowser-undoclosetab");
            undoItem.setAttribute("disabled", this.savedBrowsers.length == 0);
            undoItem.hidden = this.mPrefs.getIntPref("browser.tabs.undoclose.depth") <= 0;
          ]]>
        </body>
      </method>

      <method name="updateCurrentBrowser">
        <body>
          <![CDATA[
            // we only want to return to the parent tab if no other
            // tabs have been opened and the user hasn't switched tabs
            this.mPreviousTab = null;

            var newBrowser = this.mPanelContainer.selectedPanel;
            if (this.mCurrentBrowser) {
              // Only save the focused element if it is in our content window
              // or in an ancestor window.
              var focusedWindow = document.commandDispatcher.focusedWindow;
              var saveFocus = false;

              if (focusedWindow && focusedWindow.top == window.content) {
                saveFocus = true;
              } else {
                var contentWindow = window;

                while (contentWindow) {
                  if (contentWindow == focusedWindow) {
                    saveFocus = true;
                    break;
                  }

                  if (contentWindow.parent == contentWindow) {
                    break;
                  }

                  contentWindow = contentWindow.parent;
                }
              }

              if (saveFocus) {
                // Preserve the currently-focused element or DOM window for
                // this tab.

                this.mCurrentBrowser.focusedWindow = focusedWindow;
                this.mCurrentBrowser.focusedElement = document.commandDispatcher.focusedElement;
              }

              if (this.mCurrentBrowser.focusedElement &&
                  this.mCurrentBrowser.focusedElement.parentNode !=
                  this.mCurrentTab.parentNode) {
                // Clear focus outline before we draw on top of it.
                // Only blur the focused element if it isn't a tab, 
                // to avoid breaking keyboard tab navigation
                this.mCurrentBrowser.focusedElement.blur();
              }
              this.mCurrentBrowser.setAttribute("type", "content-targetable");
            }

            newBrowser.setAttribute("type", "content-primary");
            this.mCurrentBrowser = newBrowser;
            this.mCurrentTab = this.selectedTab;

            // Update the URL bar.
            var loc = this.mCurrentBrowser.currentURI;
            var webProgress = this.mCurrentBrowser.webProgress;
            var securityUI = this.mCurrentBrowser.securityUI;
            // Remember the current clear state, then set it to false
            // so we don't clear the userTypedValue when just switching
            // tabs. Set it back to its old state after we're done.
            var userTypedClear = this.mCurrentBrowser.userTypedClear;
            this.mCurrentBrowser.userTypedClear = 0;
            var i, p;
            for (i = 0; i < this.mProgressListeners.length; i++) {
              p = this.mProgressListeners[i];
              if (p) {
                p.onLocationChange(webProgress, null, loc);
                if (securityUI)
                  p.onSecurityChange(webProgress, null, securityUI.state);
                var listener = this.mTabListeners[this.mTabContainer.selectedIndex];
                if (listener.mIcon && 'onLinkIconAvailable' in p)
                  p.onLinkIconAvailable(listener.mIcon);
              }
            }
            this.mCurrentBrowser.userTypedClear = userTypedClear;

            // Update the window title.
            this.updateTitlebar();

            // If the new tab is busy, and our current state is not busy, then
            // we need to fire a start to all progress listeners.
            const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
            if (this.mCurrentTab.hasAttribute("busy") && !this.mIsBusy) {
              this.mIsBusy = true;
              webProgress = this.mCurrentBrowser.webProgress;
              for (i = 0; i < this.mProgressListeners.length; i++) {
                p = this.mProgressListeners[i];
                if (p)
                  p.onStateChange(webProgress, null, nsIWebProgressListener.STATE_START | nsIWebProgressListener.STATE_IS_NETWORK, 0);
              }
            }

            // If the new tab is not busy, and our current state is busy, then
            // we need to fire a stop to all progress listeners.
            if (!this.mCurrentTab.hasAttribute("busy") && this.mIsBusy) {
              this.mIsBusy = false;
              webProgress = this.mCurrentBrowser.webProgress;
              for (i = 0; i < this.mProgressListeners.length; i++) {
                p = this.mProgressListeners[i];
                if (p)
                  p.onStateChange(webProgress, null, nsIWebProgressListener.STATE_STOP | nsIWebProgressListener.STATE_IS_NETWORK, 0);
              }
            }

            // We've selected the new tab, so go ahead and notify listeners
            var event = document.createEvent("Events");
            event.initEvent("TabSelect", true, false);
            this.mCurrentTab.dispatchEvent(event);

            if (document.commandDispatcher.focusedElement && 
                document.commandDispatcher.focusedElement.parentNode == 
                this.mCurrentTab.parentNode) {
              // The focus is on a tab in the same tab panel
              return;  // If focus was on a tab, switching tabs focuses the new tab
            }
            
            var whatToFocus = window.content;

            // Focus the previously focused element or window
            if (newBrowser.focusedElement) {
              if (newBrowser.focusedElement.parentNode != 
                  this.mCurrentTab.parentNode) {
                // Focus the remembered element unless it's in the current tab panel
                whatToFocus = newBrowser.focusedElement;
              }
            }
            else if (newBrowser.focusedWindow) {
              whatToFocus = newBrowser.focusedWindow;
            }

            function setFocus(element) {
              document.commandDispatcher.suppressFocusScroll = true;
              element.focus();
              document.commandDispatcher.suppressFocusScroll = false;
            }

            // Use setTimeout to avoid focus outline ghosting.
            setTimeout(setFocus, 0, whatToFocus);
          ]]>
        </body>
      </method>

      <method name="onTabClick">
        <parameter name="event"/>
        <body>
          <![CDATA[
            if (event.button != 1 || event.target.localName != 'tab' ||
                this.mPrefs.getBoolPref("middlemouse.contentLoadURL"))
              return;

            this.removeTab(event.target);
            event.stopPropagation();
          ]]>
        </body>
      </method>

      <method name="onLinkAdded">
        <parameter name="event"/>
        <body>
          <![CDATA[
            if (!this.mPrefs.getBoolPref("browser.chrome.site_icons"))
              return;

            if (!event.originalTarget.rel.match((/(?:^|\s)icon(?:\s|$)/i)))
              return;

            // We have an icon.
            var href = event.originalTarget.href;
            if (!href)
              return;

            const nsIContentPolicy = Components.interfaces.nsIContentPolicy;
            try {
              var contentPolicy =
                Components.classes['@mozilla.org/layout/content-policy;1']
                          .getService(nsIContentPolicy);
            } catch(e) {
              return; // Refuse to load if we can't do a security check.
            }

            // Verify that the load of this icon is legal.
            // We check first with the security manager
            const secMan =
              Components.classes["@mozilla.org/scriptsecuritymanager;1"]
                        .getService(Components.interfaces.nsIScriptSecurityManager);

            // Get the IOService so we can make URIs
            const ioService =
              Components.classes["@mozilla.org/network/io-service;1"]
                        .getService(Components.interfaces.nsIIOService);

            const targetDoc = event.target.ownerDocument;
            // Make a URI out of our href.
            var uri = ioService.newURI(href, targetDoc.characterSet, null);

            var origURI = ioService.newURI(targetDoc.documentURI, targetDoc.characterSet, null);

            const nsIScriptSecMan =
              Components.interfaces.nsIScriptSecurityManager;

            try {
              secMan.checkLoadURI(origURI, uri,
                                  nsIScriptSecMan.DISALLOW_SCRIPT);
            } catch(e) {
              return;
            }

            // Security says okay, now ask content policy
            for (var i = 0; i < this.browsers.length; i++) {
              if (this.browsers[i].contentDocument == event.originalTarget.ownerDocument) {
                if (contentPolicy.shouldLoad(nsIContentPolicy.TYPE_IMAGE,
                                             uri, origURI, event.target,
                                             event.target.type,
                                             null) == nsIContentPolicy.ACCEPT) {
                  this.mTabListeners[i].setIcon(href);
                  if (this.browsers[i] == this.mCurrentBrowser)
                    for each (var p in this.mProgressListeners)
                      if (p && 'onLinkIconAvailable' in p)
                        p.onLinkIconAvailable(href);
                }
                return;
              }
            }
          ]]>
        </body>
      </method>

      <method name="onTitleChanged">
        <parameter name="evt"/>
        <body>
          <![CDATA[
            if (evt.target != this.contentDocument)
              return;

            var tabBrowser = this.parentNode.parentNode.parentNode;
            var tab = document.getAnonymousElementByAttribute(tabBrowser, "linkedpanel", this.id);

            tabBrowser.setTabTitle(tab);

            if (tab == tabBrowser.mCurrentTab)
              tabBrowser.updateTitlebar();
          ]]>
        </body>
      </method>

      <method name="setTabTitle">
        <parameter name="aTab"/>
        <body>
          <![CDATA[
            var browser = aTab.linkedBrowser;
            var title = browser.contentTitle;
            var crop = "end";

            if (!title) {
              if (browser.currentURI.spec) {
                try {
                  title = this.mURIFixup.createExposableURI(browser.currentURI).spec;
                }
                catch(ex) {
                  title = browser.currentURI.spec;
                }
              }

              if (title && title != "about:blank") {
                // At this point, we now have a URI.
                // Let's try to unescape it using a character set
                // in case the URI is not ASCII.
                try {
                  var characterSet = browser.contentDocument.characterSet;
                  const textToSubURI = Components.classes["@mozilla.org/intl/texttosuburi;1"]
                                                 .getService(Components.interfaces.nsITextToSubURI);
                  title = textToSubURI.unEscapeNonAsciiURI(characterSet, title);
                }
                catch(ex) {
                  // Do nothing.
                }

                crop = "center";
              } else // Still no title?  Fall back to our untitled string.
                title = this.mStringBundle.getString("tabs.untitled");
            }

            aTab.label = title;
            aTab.setAttribute("crop", crop);
          ]]>
        </body>
      </method>

      <method name="setStripVisibilityTo">
        <parameter name="aShow"/>
        <body>
          <![CDATA[
            this.mStrip.collapsed = !aShow;
          ]]>
        </body>
      </method>

      <method name="getStripVisibility">
        <body>
          return !this.mStrip.collapsed;
        </body>
      </method>

      <method name="addTab">
        <parameter name="aURI"/>
        <parameter name="aReferrerURI"/>
        <parameter name="aCharset"/>
        <parameter name="aFocusNewTab"/>
        <parameter name="aFlags"/>
        <body>
          <![CDATA[
            this._browsers = null; // invalidate cache

            var t = this.referenceTab.cloneNode(true);

            var blank = (aURI == "about:blank");

            if (!blank)
              t.setAttribute("label", aURI);

            this.mTabContainer.appendChild(t);

            var b = document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
                                             "browser");
            b.setAttribute("type", "content-targetable");
            b.setAttribute("contextmenu", this.getAttribute("contentcontextmenu"));
            b.setAttribute("tooltip", this.getAttribute("contenttooltip"));

            this.mPanelContainer.appendChild(b);

            b.addEventListener("DOMTitleChanged", this.onTitleChanged, true);

            this.mStrip.collapsed = false;

            this.mPrefs.setBoolPref("browser.tabs.forceHide", false);

            // wire up a progress listener for the new browser object.
            var position = this.mTabs.length - 1;
            var tabListener = this.mTabProgressListener(t, b, blank);
            const filter = Components.classes["@mozilla.org/appshell/component/browser-status-filter;1"]
                                     .createInstance(Components.interfaces.nsIWebProgress);
            filter.addProgressListener(tabListener, Components.interfaces.nsIWebProgress.NOTIFY_ALL);
            b.webProgress.addProgressListener(filter, Components.interfaces.nsIWebProgress.NOTIFY_ALL);
            this.mTabListeners[position] = tabListener;
            this.mTabFilters[position] = filter;

            var uniqueId = "panel" + this.nextTabNumber++;
            b.id = uniqueId;
            t.linkedPanel = uniqueId;
            t.linkedBrowser = b;
            if (t.previousSibling.selected)
              t.setAttribute("afterselected", true);

            if (!blank) {
              // Stop the existing about:blank load.  Otherwise, if aURI
              // doesn't stop in-progress loads on its own, we'll get into
              // trouble with multiple parallel loads running at once.
              b.stop();

              // pretend the user typed this so it'll be available till
              // the document successfully loads
              b.userTypedValue = aURI;

              b.loadURIWithFlags(aURI, aFlags, aReferrerURI, aCharset);
            }

            if (aFocusNewTab) {
              var parentTab = this.selectedTab;
              this.selectedTab = t;
              this.mPreviousTab = parentTab;
            }
            else
              // The user opened a background tab, so updateCurrentBrowser
              // won't be called.  Explicitly clear the previous tab.
              this.mPreviousTab = null;

            var evt = document.createEvent("Events");
            evt.initEvent("TabOpen", true, false);
            t.dispatchEvent(evt);

            return t;
          ]]>
        </body>
      </method>

      <method name="removeAllTabsBut">
        <parameter name="aTab"/>
        <body>
          <![CDATA[
            var numTabs = this.mTabs.length;

            if (numTabs > 1) {
              const closeOtherTabsPref = "browser.tabs.warnOnCloseOther";
              var shouldPrompt = this.mPrefs.getBoolPref(closeOtherTabsPref);
              var reallyClose = true;

              if (shouldPrompt) {
                var promptService = Components.classes["@mozilla.org/embedcomp/prompt-service;1"]
                                              .getService(Components.interfaces.nsIPromptService);

                //default to true: if it were false, we wouldn't get this far
                var warnOnClose = { value:true };
                var bundle = this.mStringBundle;
                var tabsToClose = numTabs - 1; //number of tabs to be removed

                var buttonPressed = promptService.confirmEx(window, 
                                                            bundle.getString('tabs.closeWarningTitle'), 
                                                            bundle.getFormattedString("tabs.closeWarning", [tabsToClose]),
                                                            (promptService.BUTTON_TITLE_IS_STRING * promptService.BUTTON_POS_0)
                                                            + (promptService.BUTTON_TITLE_CANCEL * promptService.BUTTON_POS_1),
                                                            bundle.getString('tabs.closeButton'),
                                                            null, null,
                                                            bundle.getString('tabs.closeWarningPromptMe'),
                                                            warnOnClose);
                reallyClose = (buttonPressed == 0);
                //don't set the pref unless they press OK and it's false
                if (reallyClose && !warnOnClose.value)
                  this.mPrefs.setBoolPref(closeOtherTabsPref, false);
              }

              if (reallyClose) {
                if (aTab.localName != "tab")
                  aTab = this.mCurrentTab;
                else
                  this.mTabContainer.selectedItem = aTab;

                for (var i = this.mTabs.length - 1; i >= 0; --i) {
                  if (this.mTabs[i] != aTab)
                    this.removeTab(this.mTabs[i]);
                }
              }
            }
          ]]>
        </body>
      </method>

      <method name="removeCurrentTab">
        <body>
          <![CDATA[
            return this.removeTab(this.mCurrentTab);
          ]]>
        </body>
      </method>

      <method name="getUndoList">
        <body>
          <![CDATA[
            var list = [];
            for (var i = 0; i < this.savedBrowsers.length; i++) {
              var hist = this.savedBrowsers[i].history;
              list.push(hist.getEntryAtIndex(hist.index, false).title);
            }
            return list;
          ]]>
        </body>
      </method>

      <method name="restoreTab">
        <parameter name="aIndex"/>
        <body>
          <![CDATA[
            if (aIndex >= this.savedBrowsers.length || aIndex < 0)
              return;

            this._browsers = null;

            var t = this.referenceTab.cloneNode(true);
            var savedData = this.savedBrowsers.splice(aIndex, 1)[0];
            var b = savedData.browser;
            var hist = savedData.history;

            this.mTabContainer.appendChild(t);
            if (t.previousSibling.selected)
              t.setAttribute("afterselected", true);

            // navigate back to the proper page from the light page
            b.webNavigation.goBack();

            // reattach the old history
            b.webNavigation.sessionHistory = hist;

            var uniqueID = b.id;
            t.linkedPanel = uniqueID;
            t.linkedBrowser = b;

            // Hook up the title change listener again
            b.addEventListener("DOMTitleChanged", this.onTitleChanged, true);

            // add back the filters, security first (bug 313335)
            const nsIWebProgress = Components.interfaces.nsIWebProgress;
            var secFlags = nsIWebProgress.NOTIFY_STATE_ALL | nsIWebProgress.NOTIFY_LOCATION | nsIWebProgress.NOTIFY_SECURITY;
            b.webProgress.addProgressListener(b.securityUI, secFlags);

            var position = this.mTabs.length - 1;
            var tabListener = this.mTabProgressListener(t, b, false);
            const filter = Components.classes["@mozilla.org/appshell/component/browser-status-filter;1"]
                                     .createInstance(nsIWebProgress);
            filter.addProgressListener(tabListener, nsIWebProgress.NOTIFY_ALL);
            b.webProgress.addProgressListener(filter, nsIWebProgress.NOTIFY_ALL);
            this.mTabListeners[position] = tabListener;
            this.mTabFilters[position] = filter;

            if (this.mTabs.length == 2 &&
                !this.mTabs[0].linkedBrowser.webNavigation.sessionHistory.count)
              this.removeTab(this.mTabs[0]); // only one tab => selected anyway
            else {
              this.selectedTab = t;
              this.mStrip.collapsed = false;
            }
          ]]>
        </body>
      </method>

      <method name="removeTab">
        <parameter name="aTab"/>
        <parameter name="aDisableUndo"/>
        <body>
          <![CDATA[
            this._browsers = null; // invalidate cache

            if (aTab.localName != "tab")
              aTab = this.mCurrentTab;

            var oldBrowser = aTab.linkedBrowser;

            var ds = oldBrowser.docShell;

            if (ds.contentViewer && !ds.contentViewer.permitUnload())
              return;

            // We're committed to closing the tab now.
            // Dispatch a notification.
            // We dispatch it before any teardown so that event listeners can
            // inspect the tab that's about to close.
            var event = document.createEvent('Events');
            event.initEvent("TabClose", true, false);
            aTab.dispatchEvent(event);

            var l = this.mTabs.length;
            if (l == 1) {
              // add a new blank tab to replace the one we're about to close
              // (this ensures that the remaining tab is as good as new)
              this.addTab("about:blank");
              l++;
            }
            else if (l == 2) {
              if (this.mPrefs.getBoolPref("browser.tabs.autoHide"))
                this.mStrip.collapsed = true;
            }

            var index = this.getTabIndex(aTab);

            // Remove SSL listener
            oldBrowser.webProgress.removeProgressListener(oldBrowser.securityUI);

            // Remove the tab's filter and progress listener.
            const filter = this.mTabFilters[index];
            oldBrowser.webProgress.removeProgressListener(filter);
            filter.removeProgressListener(this.mTabListeners[index]);
            this.mTabFilters.splice(index, 1);
            this.mTabListeners.splice(index, 1);

            // Remove our title change listener
            oldBrowser.removeEventListener("DOMTitleChanged", this.onTitleChanged, true);

            // We are no longer a targetable content area
            oldBrowser.setAttribute("type", "content");

            // Now select the new tab before nuking the old one.
            var currentIndex = this.mTabContainer.selectedIndex;

            var newIndex = -1;
            if (currentIndex > index)
              newIndex = currentIndex - 1;
            else if (currentIndex < index)
              newIndex = currentIndex;
            else if (index == l - 1)
              newIndex = index - 1;
            else
              newIndex = index;

            if (oldBrowser == this.mCurrentBrowser)
              this.mCurrentBrowser = null;

            // Clean up before/afterselected attributes before removing the tab
            aTab.selected = false;
            this.mTabContainer.removeChild(aTab);

            // When the current tab is removed select a new tab
            // and fire select events on tabpanels and tabs
            if (this.mPreviousTab && (aTab == this.mCurrentTab))
              this.selectedTab = this.mPreviousTab;
            else {
              this.mTabContainer.selectedIndex = newIndex;

              // We need to explicitly clear this, because updateCurrentBrowser
              // doesn't get called for a background tab
              this.mPreviousTab = null;
            }

            // Save the tab for undo.
            // Even though we navigate to about:blank, it costs more RAM than
            // really closing the tab.  The pref controls how far you can undo
            var maxUndoDepth = this.mPrefs.getIntPref("browser.tabs.undoclose.depth");
            var oldSH = oldBrowser.webNavigation.sessionHistory;
            if (maxUndoDepth <= 0 || oldSH.count == 0 || aDisableUndo) {
              // Undo is disabled/tab is blank.  Kill the browser for real.
              // Because of the way XBL works (fields just set JS
              // properties on the element) and the code we have in place
              // to preserve the JS objects for any elements that have
              // JS properties set on them, the browser element won't be
              // destroyed until the document goes away.  So we force a
              // cleanup ourselves.
              oldBrowser.destroy();
              this.mPanelContainer.removeChild(oldBrowser);

              // Fix up the selected panel in the case the removed
              // browser was to the left of the current browser
              this.mTabBox.selectedPanel = this.selectedTab.linkedBrowser;
              return;
            } 

            // preserve a pointer to the browser for undoing the close
            // 1. save a copy of the session history (oldSH)
            // 2. hook up a new history
            // 3. add the last history entry from the old history the new
            //    history so we'll be able to go back from about:blank
            // 4. load a light URL in the browser, pushing the current page
            //    into bfcache - allows for saving of JS modifications
            //    and also saves RAM by allowing bfcache to evict the full page

            this.savedBrowsers.unshift({browser: oldBrowser, history: oldSH});

            var newSH = Components.classes["@mozilla.org/browser/shistory;1"]
                                    .createInstance(Components.interfaces.nsISHistoryInternal);
            oldBrowser.webNavigation.sessionHistory = newSH;
            var entry = oldSH.getEntryAtIndex(oldSH.index, false)
            newSH.addEntry(entry, true);

            // about:blank is light
            oldBrowser.loadURI("about:blank");

            // remove overflow from the undo stack
            if (this.savedBrowsers.length > maxUndoDepth) {
              var deadBrowser = this.savedBrowsers.pop().browser;
              deadBrowser.destroy();

              // The pagehide event that this removal triggers is safe
              // because the browser is no longer current at this point
              this.mPanelContainer.removeChild(deadBrowser);
              this.mTabBox.selectedPanel = this.selectedTab.linkedBrowser;
            }
          ]]>
        </body>
      </method>

      <method name="reloadAllTabs">
        <body>
          <![CDATA[
            var l = this.mTabs.length;
            for (var i = 0; i < l; i++) {
              try {
                this.mTabs[i].linkedBrowser.reload();
              } catch (e) {
                // ignore failure to reload so others will be reloaded
              }
            }
          ]]>
        </body>
      </method>

      <method name="reloadTab">
        <parameter name="aTab"/>
        <body>
          <![CDATA[
            if (aTab.localName != "tab")
              aTab = this.mCurrentTab;

            aTab.linkedBrowser.reload();
          ]]>
        </body>
      </method>

      <method name="addProgressListener">
        <parameter name="aListener"/>
        <parameter name="aMask"/>
        <body>
          <![CDATA[
            this.mProgressListeners.push(aListener);
          ]]>
        </body>
      </method>

      <method name="removeProgressListener">
        <parameter name="aListener"/>
        <body>
          <![CDATA[
            for (var i = 0; i < this.mProgressListeners.length; i++) {
              if (this.mProgressListeners[i] == aListener) {
                this.mProgressListeners[i] = null;
                break;
              }
            }
         ]]>
        </body>
      </method>

      <method name="getBrowserForTab">
        <parameter name="aTab"/>
        <body>
          <![CDATA[
            if (aTab.localName != "tab")
              return null;
            return aTab.linkedBrowser;
          ]]>
        </body>
      </method>

      <method name="getTabIndex">
        <parameter name="aTab"/>
        <body>
          <![CDATA[
            for (var i = 0; i < this.mTabs.length; ++i)
              if (this.mTabs[i] == aTab) 
                return i;

            throw Components.results.NS_ERROR_ILLEGAL_VALUE;
          ]]>
        </body>
      </method>

      <property name="tabContainer">
        <getter>
          return this.mTabContainer;
        </getter>
      </property>

      <property name="selectedTab">
        <getter>
          return this.mTabBox.selectedTab;
        </getter>
        <setter>
          <![CDATA[
          // Update the tab
          this.mTabBox.selectedTab = val;
          return val;
          ]]>
        </setter>
      </property>

      <property name="selectedBrowser"
                onget="return this.mCurrentBrowser;"
                readonly="true"/>

      <property name="browsers" readonly="true">
        <getter>
          <![CDATA[
            if (!this._browsers) {
              var browsers = [];
              browsers.item = function(i) {return this[i];}
              for (var i = 0; i < this.mTabs.length; i++)
                browsers.push(this.mTabs[i].linkedBrowser);
              this._browsers = browsers;
            }
            return this._browsers;
          ]]>
        </getter>
      </property>

      <!-- Drag and drop observer API -->
      <method name="onDragStart">
        <parameter name="aEvent"/>
        <parameter name="aXferData"/>
        <parameter name="aDragAction"/>
        <body>
          <![CDATA[
            if (aEvent.target.localName == "tab") {
              aXferData.data = new TransferData();

              var URI = aEvent.target.linkedBrowser.currentURI;
              var title = aEvent.target.linkedBrowser.contentTitle || URI.spec;
              aXferData.data.addDataForFlavour("text/unicode", URI.spec);
              aXferData.data.addDataForFlavour("text/x-moz-url", URI.spec + "\n" + title);
              aXferData.data.addDataForFlavour("text/html", '<a href="' + URI.spec + '">' + title + '</a>');
            }
          ]]>
        </body>
      </method>

      <method name="canDrop">
        <parameter name="aEvent"/>
        <parameter name="aDragSession"/>
        <body>
          <![CDATA[
            if (aDragSession.sourceNode &&
                aDragSession.sourceNode.parentNode == this.mTabContainer) {
              var newIndex = this.getDropIndex(aEvent);
              var tabIndex = this.getTabIndex(aDragSession.sourceNode);
              if (newIndex == tabIndex || newIndex == tabIndex + 1)
                return false;
            }
            return true;
          ]]>
        </body>
      </method>

      <method name="onDragOver">
        <parameter name="aEvent"/>
        <parameter name="aFlavour"/>
        <parameter name="aDragSession"/>
        <body>
          <![CDATA[
            var ib = document.getAnonymousElementByAttribute(this, "class", "tab-drop-indicator-bar");

            if (!aDragSession.canDrop) {
              ib.hidden = true;
              return;
            }

            var ind = document.getAnonymousElementByAttribute(this, "class", "tab-drop-indicator");

            var newIndexOn = aDragSession.sourceNode &&
                             aDragSession.sourceNode.parentNode == this.mTabContainer ?
                             -1 : this.getDropOnIndex(aEvent);

            var ltr = window.getComputedStyle(this, null).direction == "ltr";
            var arrowX, tabBoxObject;
            if (newIndexOn != -1) {
              tabBoxObject = this.mTabs[newIndexOn].boxObject;
              arrowX = tabBoxObject.x + tabBoxObject.width / 2;
            }
            else {
              var newIndexBetween = this.getDropIndex(aEvent);
              if (newIndexBetween == this.mTabs.length) {
                tabBoxObject = this.mTabs[this.mTabs.length - 1].boxObject;
                arrowX = tabBoxObject.x;
                if (ltr) // for LTR "after" is on the right-hand side of the tab
                  arrowX += tabBoxObject.width;
              }
              else {
                tabBoxObject = this.mTabs[newIndexBetween].boxObject;
                arrowX = tabBoxObject.x;
                if (!ltr) // for RTL "before" is on the right-hand side of the tab
                  arrowX += tabBoxObject.width;
              }
            }

            if (ltr)
              ind.style.marginLeft = (arrowX - this.boxObject.x) + "px";
            else
              ind.style.marginRight = (this.boxObject.x + this.boxObject.width - arrowX) + "px";

            ib.hidden = false;
          ]]>
        </body>
      </method>

      <method name="onDrop">
        <parameter name="aEvent"/>
        <parameter name="aXferData"/>
        <parameter name="aDragSession"/>
        <body>
          <![CDATA[
            var newIndex = this.getDropIndex(aEvent);
            var tabIndex;
            if (aDragSession.sourceNode &&
                aDragSession.sourceNode.parentNode == this.mTabContainer) {
              tabIndex = this.getTabIndex(aDragSession.sourceNode);
              if (newIndex > tabIndex)
                newIndex--;
              this.moveTabTo(tabIndex, newIndex);
            } else {
              var url = transferUtils.retrieveURLFromData(aXferData.data, aXferData.flavour.contentType);

              // valid urls don't contain spaces ' '; if we have a space it isn't a valid url.
              // Also disallow dropping javascript: or data: urls--bail out
              if (!url || !url.length || url.indexOf(" ", 0) != -1 ||
                  /^\s*(javascript|data):/.test(url))
                return;

              // Perform a security check before loading the URI
              nsDragAndDrop.dragDropSecurityCheck(aEvent, aDragSession, url);

              var bgLoad = this.mPrefs.getBoolPref("browser.tabs.loadInBackground");

              var tab = null;
              tabIndex = this.getDropOnIndex(aEvent);
              if (tabIndex != -1) {
                // Load in an existing tab
                tab = this.mTabs[tabIndex];
                tab.linkedBrowser.loadURI(getShortcutOrURI(url));
                if (this.mCurrentTab != tab && !bgLoad)
                  this.selectedTab = tab;
              }
              else if (aDragSession.sourceDocument &&
                       aDragSession.sourceDocument.defaultView.top == content) {
                // We're adding a new tab, and we may want parent-tab tracking
                tab = this.addTab(getShortcutOrURI(url), null, null, !bgLoad);
                if (newIndex != this.mTabs.length - 1)
                  this.moveTabTo(this.mTabs.length - 1, newIndex);
              }
              else {
                // We're adding a new tab, but do not want parent-tab tracking
                tab = this.addTab(getShortcutOrURI(url));
                if (newIndex != this.mTabs.length - 1)
                  this.moveTabTo(this.mTabs.length - 1, newIndex);
                if (this.mCurrentTab != tab && !bgLoad)
                  this.selectedTab = tab;
              }
            }
          ]]>
        </body>
      </method>

      <method name="onDragExit">
        <parameter name="aEvent"/>
        <parameter name="aDragSession"/>
        <body>
          <![CDATA[
            var target = aEvent.relatedTarget;
            while (target && target != this.mStrip)
              target = target.parentNode;

            if (target)
              return;

            document.getAnonymousElementByAttribute(this, "class",
                                                    "tab-drop-indicator-bar")
                    .hidden = true;
          ]]>
        </body>
      </method>

      <method name="getSupportedFlavours">
        <body>
          <![CDATA[
            var flavourSet = new FlavourSet();
            flavourSet.appendFlavour("text/x-moz-url");
            flavourSet.appendFlavour("text/unicode");
            flavourSet.appendFlavour("application/x-moz-file", "nsIFile");
            return flavourSet;
          ]]>
        </body>
      </method>

      <method name="moveTabTo">
        <parameter name="aSrcIndex"/>
        <parameter name="aDestIndex"/>
        <body>
          <![CDATA[
            this._browsers = null; // invalidate cache

            // for compatibility with extensions
            if (typeof(aSrcIndex) != "number")
              aSrcIndex = this.getTabIndex(aSrcIndex);

            this.mTabFilters.splice(aDestIndex, 0, this.mTabFilters.splice(aSrcIndex, 1)[0]);
            this.mTabListeners.splice(aDestIndex, 0, this.mTabListeners.splice(aSrcIndex, 1)[0]);

            this.mCurrentTab.selected = false;

            if (aDestIndex >= aSrcIndex)
              ++aDestIndex;
            var tab = this.mTabContainer.insertBefore(this.mTabs[aSrcIndex], this.mTabs.item(aDestIndex));

            this.mCurrentTab.selected = true;

            var evt = document.createEvent("UIEvents");
            evt.initUIEvent("TabMove", true, false, window, aSrcIndex);
            tab.dispatchEvent(evt);

            return tab;
          ]]>
        </body>
      </method>

      <method name="getDropIndex">
        <parameter name="aEvent"/>
        <body>
          <![CDATA[     
            for (var i = 0; i < this.mTabs.length; ++i) {
              var coord = this.mTabs[i].boxObject.x +
                          this.mTabs[i].boxObject.width / 2;
              if (window.getComputedStyle(this, null).direction == "ltr") {
                if (aEvent.clientX < coord) 
                  return i;
              } else {
                if (aEvent.clientX > coord) 
                  return i;
              }
            }

            return this.mTabs.length;
          ]]>
        </body>
      </method>

      <method name="getDropOnIndex">
        <parameter name="aEvent"/>
        <body>
          <![CDATA[     
            for (var i = 0; i < this.mTabs.length; ++i) {
              var tabBoxObject = this.mTabs[i].boxObject;
              if (aEvent.clientX > tabBoxObject.x + tabBoxObject.width * .25 &&
                  aEvent.clientX < tabBoxObject.x + tabBoxObject.width * .75)
                return i;
            }

            return -1;
          ]]>
        </body>
      </method>

      <method name="moveTabLeft">
        <body>
          <![CDATA[
            if (window.getComputedStyle(this, null).direction == "ltr")
              this.moveTabBackward();
            else
              this.moveTabForward();
          ]]>
        </body>
      </method>

      <method name="moveTabRight">
        <body>
          <![CDATA[
            if (window.getComputedStyle(this, null).direction == "ltr")
              this.moveTabForward();
            else
              this.moveTabBackward();
          ]]>
        </body>
      </method>

      <method name="moveTabForward">
        <body>
          <![CDATA[
            var tabPos = this.mTabContainer.selectedIndex;
            if (tabPos < this.browsers.length - 1) {
              this.moveTabTo(tabPos, tabPos + 1);
              this.mCurrentTab.focus();
            }
            else if (this.arrowKeysShouldWrap)
              this.moveTabToStart();
          ]]>
        </body>
      </method>

      <method name="moveTabBackward">
        <body>
          <![CDATA[
            var tabPos = this.mTabContainer.selectedIndex;
            if (tabPos > 0) {
              this.moveTabTo(tabPos, tabPos - 1);
              this.mCurrentTab.focus();
            }
            else if (this.arrowKeysShouldWrap)
              this.moveTabToEnd();
          ]]>
        </body>
      </method>

      <method name="moveTabToStart">
        <body>
          <![CDATA[
            var tabPos = this.mTabContainer.selectedIndex;
            if (tabPos > 0) {
              this.moveTabTo(tabPos, 0);
              this.mCurrentTab.focus();
            }
          ]]>
        </body>
      </method>
      
      <method name="moveTabToEnd">
        <body>
          <![CDATA[
            var tabPos = this.mTabContainer.selectedIndex;
            if (tabPos < this.browsers.length - 1) {
              this.moveTabTo(tabPos, this.browsers.length - 1);
              this.mCurrentTab.focus();
            }
          ]]>
        </body>
      </method>
      
      <field name="backBrowserGroup">
        []
      </field>

      <field name="forwardBrowserGroup">
        []
      </field>

      <method name="replaceGroup">
        <parameter name="aGroup"/>
        <body>
        <![CDATA[
          var oldBrowserGroup = [];
          var oldCount = this.mTabs.length;
          var newCount = aGroup.length;
          var n = Math.max(oldCount, newCount);
          for (var i = 0; i < n; ++i) {
            if (i < newCount) {
              var data = aGroup[i];
              if ("sessionHistory" in data) {
                this.addTab("about:blank", null);
                var browser = this.mTabContainer.lastChild.linkedBrowser;
                // need to hold on to the listener so it won't go away
                // addProgressListener only has a weak pointer to it
                browser._SHListener =
                    this.mInstallSH(browser, aGroup[i].sessionHistory);
                browser.webProgress.addProgressListener(browser._SHListener, Components.interfaces.nsIWebProgress.NOTIFY_ALL);
              } else {
                var referrerURI = "referrerURI" in data ? data.referrerURI : null;
                this.addTab(data.URI, referrerURI);
              }
            }
            if (i < oldCount) {
              var firstTab = this.mTabContainer.firstChild;
              var browserData = {
                sessionHistory : firstTab.linkedBrowser.sessionHistory
              }
              oldBrowserGroup.push(browserData);
              this.removeTab(firstTab, true);
            }
          }
          return oldBrowserGroup;
        ]]>
        </body>
      </method>

      <method name="appendGroup">
        <parameter name="aGroup"/>
        <body>
        <![CDATA[
          for (var i in aGroup) {
            var page = aGroup[i];
            var referrerURI = "referrerURI" in page ? page.referrerURI : null;
            this.addTab(page.URI, referrerURI);
          }
        ]]>
        </body>
      </method>

      <method name="loadGroup">
        <parameter name="aGroup"/>
        <body>
        <![CDATA[
          if (aGroup.length == 0)
            return null;

          var tab;
          if (this.mPrefs.getIntPref("browser.tabs.loadGroup") == 0) {
            var oldCount = this.mTabs.length;
            this.appendGroup(aGroup);
            tab = this.mTabs[oldCount];
          } else {
            this.backBrowserGroup = this.replaceGroup(aGroup);
            this.forwardBrowserGroup = [];
            tab = this.mTabContainer.firstChild;
          }
          return tab;
        ]]>
        </body>
      </method>

      <method name="goBackGroup">
        <body>
        <![CDATA[
          this.forwardBrowserGroup = this.replaceGroup(this.backBrowserGroup);
          this.backBrowserGroup = [];
        ]]>
        </body>
      </method>

      <method name="goForwardGroup">
        <body>
        <![CDATA[
          this.backBrowserGroup = this.replaceGroup(this.forwardBrowserGroup);
          this.forwardBrowserGroup = [];
        ]]>
        </body>
      </method>

      <!-- BEGIN FORWARDED BROWSER PROPERTIES.  IF YOU ADD A PROPERTY TO THE BROWSER ELEMENT
           MAKE SURE TO ADD IT HERE AS WELL. -->
      <property name="canGoBack"
                onget="return this.backBrowserGroup.length != 0 || this.mCurrentBrowser.canGoBack;"
                readonly="true"/>

      <property name="canGoForward"
                onget="return this.forwardBrowserGroup.length != 0 || this.mCurrentBrowser.canGoForward;"
                readonly="true"/>

      <method name="goBack">
        <body>
          <![CDATA[
            if (this.backBrowserGroup.length != 0)
              return this.goBackGroup();

            return this.mCurrentBrowser.goBack();
          ]]>
        </body>
      </method>

      <method name="goForward">
        <body>
          <![CDATA[
            if (this.forwardBrowserGroup.length != 0)
              return this.goForwardGroup();

            return this.mCurrentBrowser.goForward();
          ]]>
        </body>
      </method>

      <method name="reload">
        <body>
          <![CDATA[
            return this.mCurrentBrowser.reload();
          ]]>
        </body>
      </method>

      <method name="reloadWithFlags">
        <parameter name="aFlags"/>
        <body>
          <![CDATA[
            return this.mCurrentBrowser.reloadWithFlags(aFlags);
          ]]>
        </body>
      </method>

      <method name="stop">
        <body>
          <![CDATA[
            return this.mCurrentBrowser.stop();
          ]]>
        </body>
      </method>

      <!-- throws exception for unknown schemes -->
      <method name="loadURI">
        <parameter name="aURI"/>
        <parameter name="aReferrerURI"/>
        <parameter name="aCharset"/>
        <body>
          <![CDATA[
            return this.mCurrentBrowser.loadURI(aURI, aReferrerURI, aCharset);
          ]]>
        </body>
      </method>

      <!-- throws exception for unknown schemes -->
      <method name="loadURIWithFlags">
        <parameter name="aURI"/>
        <parameter name="aFlags"/>
        <parameter name="aReferrerURI"/>
        <parameter name="aCharset"/>
        <body>
          <![CDATA[
            return this.mCurrentBrowser.loadURIWithFlags(aURI, aFlags, aReferrerURI, aCharset);
          ]]>
        </body>
      </method>

      <method name="goHome">
        <body>
          <![CDATA[
            return this.mCurrentBrowser.goHome();
          ]]>
        </body>
      </method>

      <property name="homePage">
        <getter>
          <![CDATA[
            return this.mCurrentBrowser.homePage;
          ]]>
        </getter>
        <setter>
          <![CDATA[
            this.mCurrentBrowser.homePage = val;
            return val;
          ]]>
        </setter>
      </property>

      <method name="gotoIndex">
        <parameter name="aIndex"/>
        <body>
          <![CDATA[
            return this.mCurrentBrowser.gotoIndex(aIndex);
          ]]>
        </body>
      </method>

      <property name="currentURI"
                onget="return this.mCurrentBrowser.currentURI;"
                readonly="true"/>

      <property name="docShell"
                onget="return this.mCurrentBrowser.docShell"
                readonly="true"/>

      <property name="webNavigation"
                onget="return this.mCurrentBrowser.webNavigation"
                readonly="true"/>

      <property name="webBrowserFind"
                readonly="true"
                onget="return this.mCurrentBrowser.webBrowserFind"/>

      <property name="webProgress"
                readonly="true"
                onget="return this.mCurrentBrowser.webProgress"/>

      <property name="contentWindow"
                readonly="true"
                onget="return this.mCurrentBrowser.contentWindow"/>

      <property name="sessionHistory"
                onget="return this.mCurrentBrowser.sessionHistory;"
                readonly="true"/>

      <property name="markupDocumentViewer"
                onget="return this.mCurrentBrowser.markupDocumentViewer;"
                readonly="true"/>

      <property name="contentViewerEdit"
                onget="return this.mCurrentBrowser.contentViewerEdit;"
                readonly="true"/>

      <property name="contentViewerFile"
                onget="return this.mCurrentBrowser.contentViewerFile;"
                readonly="true"/>

      <property name="documentCharsetInfo"
                onget="return this.mCurrentBrowser.documentCharsetInfo;"
                readonly="true"/>

      <property name="contentDocument"
                onget="return this.mCurrentBrowser.contentDocument;"
                readonly="true"/>

      <property name="contentTitle"
                onget="return this.mCurrentBrowser.contentTitle;"
                readonly="true"/>

      <property name="securityUI"
                onget="return this.mCurrentBrowser.securityUI;"
                readonly="true"/>

      <property name="userTypedClear"
                onget="return this.mCurrentBrowser.userTypedClear;"
                onset="return this.mCurrentBrowser.userTypedClear = val;"/>

      <property name="userTypedValue"
                onget="return this.mCurrentBrowser.userTypedValue;"
                onset="return this.mCurrentBrowser.userTypedValue = val;"/>

      <constructor>
        <![CDATA[
          this.mCurrentBrowser = this.mPanelContainer.firstChild;
          this.mCurrentTab = this.mTabContainer.firstChild;
          document.addEventListener("keypress", this._keyEventHandler, false);
          this.mTabBox.handleCtrlTab = !/Mac/.test(navigator.platform);
          this.arrowKeysShouldWrap = /Mac/.test(navigator.platform);

          var uniqueId = "panel" + this.nextTabNumber++;
          this.mPanelContainer.childNodes[0].id = uniqueId;
          this.mTabs[0].linkedPanel = uniqueId;
          this.mTabs[0].linkedBrowser = this.mPanelContainer.childNodes[0];

          // Wire up the first title change listener.
          this.mCurrentBrowser.addEventListener("DOMTitleChanged", this.onTitleChanged, true);

          // Ensure the browser's session history and security UI are wired up
          this.mCurrentBrowser.init();

          // Wire up the tab's progress listener and filter.
          const nsIWebProgress = Components.interfaces.nsIWebProgress;
          var tabListener = this.mTabProgressListener(this.mCurrentTab,
                                                      this.mCurrentBrowser,
                                                      false);
          var filter = Components.classes["@mozilla.org/appshell/component/browser-status-filter;1"]
                                 .createInstance(nsIWebProgress);
          filter.addProgressListener(tabListener, nsIWebProgress.NOTIFY_ALL);
          this.webProgress.addProgressListener(filter,
                                               nsIWebProgress.NOTIFY_ALL);
          this.mTabListeners[0] = tabListener;
          this.mTabFilters[0] = filter;

          if (!this.mPrefs.getBoolPref("browser.tabs.autoHide") &&
              !this.mPrefs.getBoolPref("browser.tabs.forceHide") &&
              window.toolbar.visible)
            this.mStrip.collapsed = false;

          var t = document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", "tab");
          t.setAttribute("label", this.mStringBundle.getString("tabs.untitled"));
          t.setAttribute("crop", "end");
          t.setAttribute("className", "tabbrowser-tab");
          t.setAttribute("maxwidth", 250);
          t.setAttribute("minwidth", 30);
          t.setAttribute("width", 0);
          t.setAttribute("flex", 100);
          t.setAttribute("validate", "never");
          t.setAttribute("onerror", "this.parentNode.parentNode.parentNode.parentNode.addToMissedIconCache(this.getAttribute('image')); this.removeAttribute('image');");
          this.referenceTab = t;
        ]]>
      </constructor>

      <destructor>
        <![CDATA[
          for (var i = 0; i < this.mTabListeners.length; ++i) {
            this.browsers[i].webProgress.removeProgressListener(this.mTabFilters[i]);
            this.mTabFilters[i].removeProgressListener(this.mTabListeners[i]);
            this.mTabFilters[i] = null;
            this.mTabListeners[i] = null;
            this.mPanelContainer.childNodes[i].removeEventListener("DOMTitleChanged", this.onTitleChanged, true);
          }
          document.removeEventListener("keypress", this._keyEventHandler, false);
        ]]>
      </destructor>
    </implementation>

    <handlers>
      <handler event="select" action="if (event.originalTarget == this.mPanelContainer) this.updateCurrentBrowser();"/>

      <handler event="DOMLinkAdded" phase="capturing" action="this.onLinkAdded(event);"/>

      <handler event="DOMWindowClose" phase="capturing">
        <![CDATA[
          if (!event.isTrusted)
            return;

          const browsers = this.browsers;
          if (browsers.length == 1)
            return;
          var i = 0;
          for (; i < browsers.length; ++i) {
            if (browsers[i].contentWindow == event.target)
              break;
          }
          this.removeTab(this.mTabs[i]);
          event.preventDefault();
        ]]>
      </handler>
      <handler event="DOMWillOpenModalDialog" phase="capturing">
        <![CDATA[
          if (!event.isTrusted)
            return;

          // We're about to open a modal dialog, make sure the opening
          // tab is brought to the front.

          const browsers = this.browsers;
          for (var i = 0; i < browsers.length; ++i) {
            if (browsers[i].contentWindow == event.target.top) {
              this.selectedTab = this.mTabs[i];

              break;
            }
          }
        ]]>
      </handler>

      <handler event="keypress" keycode="VK_LEFT" modifiers="accel" action="if (event.target == this) { this.moveTabLeft(); event.preventDefault(); }"/>
      <handler event="keypress" keycode="VK_RIGHT" modifiers="accel" action="if (event.target == this) { this.moveTabRight(); event.preventDefault(); }"/>
      <handler event="keypress" keycode="VK_UP" modifiers="accel" action="if (event.target == this) { this.moveTabBackward(); event.preventDefault(); }"/>
      <handler event="keypress" keycode="VK_DOWN" modifiers="accel" action="if (event.target == this) { this.moveTabForward(); event.preventDefault(); }"/>
      <handler event="keypress" keycode="VK_HOME" modifiers="accel" action="if (event.target == this) { this.moveTabToStart(); event.preventDefault(); }"/>
      <handler event="keypress" keycode="VK_END" modifiers="accel" action="if (event.target == this) { this.moveTabToEnd(); event.preventDefault(); }"/>
    </handlers>
  </binding>

</bindings>
