# -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
# vim: set filetype=python:
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

# Templates implementing some generic checks.
# ==============================================================

# Declare some exceptions. This is cumbersome, but since we shouldn't need a
# lot of them, let's stack them all here. When adding a new one, put it in the
# _declare_exceptions template, and add it to the return statement. Then
# destructure in the assignment below the function declaration.
@template
@advanced
def _declare_exceptions():
    class FatalCheckError(Exception):
        '''An exception to throw from a function decorated with @checking.
        It will result in calling die() with the given message.
        Debugging messages emitted from the decorated function will also be
        printed out.'''
    return (FatalCheckError,)

(FatalCheckError,) = _declare_exceptions()

del _declare_exceptions

# Helper to display "checking" messages
#   @checking('for foo')
#   def foo():
#       return 'foo'
# is equivalent to:
#   def foo():
#       log.info('checking for foo... ')
#       ret = foo
#       log.info(ret)
#       return ret
# This can be combined with e.g. @depends:
#   @depends(some_option)
#   @checking('for something')
#   def check(value):
#       ...
# An optional callback can be given, that will be used to format the returned
# value when displaying it.
@template
def checking(what, callback=None):
    def decorator(func):
        def wrapped(*args, **kwargs):
            log.info('checking %s... ', what)
            with log.queue_debug():
                error, ret = None, None
                try:
                    ret = func(*args, **kwargs)
                except FatalCheckError as e:
                    error = e.message
                if callback:
                    log.info(callback(ret))
                elif ret is True:
                    log.info('yes')
                elif ret is False:
                    log.info('no')
                else:
                    log.info(ret)
                if error:
                    die(error)
            return ret
        return wrapped
    return decorator


# Template to check for programs in $PATH.
#   check('PROG', ('a', 'b'))
# will look for 'a' or 'b' in $PATH, and set_config PROG to the one
# it can find. If PROG is already set from the environment or command line,
# use that value instead.
@template
@advanced
def check_prog(var, progs, allow_missing=False):
    from mozbuild.shellutil import quote

    option(env=var, nargs=1, help='Path to the %s program' % var.lower())

    if not (isinstance(progs, tuple) or isinstance(progs, list)):
        configure_error('progs should be a list or tuple!')
    progs = list(progs)

    @depends(var)
    @checking('for %s' % var.lower(), lambda x: quote(x) if x else 'not found')
    def check(value):
        if value:
            progs[:] = value
        for prog in progs:
            log.debug('%s: Trying %s', var.lower(), quote(prog))
            result = find_program(prog)
            if result:
                return result

        if not allow_missing or value:
            raise FatalCheckError('Cannot find %s' % var.lower())

    @depends(check)
    def normalized_for_config(value):
        return ':' if value is None else value

    set_config(var, normalized_for_config)

    return check
