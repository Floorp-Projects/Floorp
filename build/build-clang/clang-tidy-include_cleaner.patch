[clang-tidy] Implement an include-cleaner check.

Differential Revision: https://reviews.llvm.org/D148793
diff --git a/clang-tools-extra/clang-tidy/misc/CMakeLists.txt b/clang-tools-extra/clang-tidy/misc/CMakeLists.txt
index a72362906e0b..b17c45ee7694 100644
--- a/clang-tools-extra/clang-tidy/misc/CMakeLists.txt
+++ b/clang-tools-extra/clang-tidy/misc/CMakeLists.txt
@@ -7,6 +7,7 @@ setup_host_tool(clang-tidy-confusable-chars-gen CLANG_TIDY_CONFUSABLE_CHARS_GEN

 add_subdirectory(ConfusableTable)

+include_directories(BEFORE "${CMAKE_CURRENT_SOURCE_DIR}/../../include-cleaner/include")

 add_custom_command(
     OUTPUT Confusables.inc
@@ -19,6 +20,7 @@ add_clang_library(clangTidyMiscModule
   ConstCorrectnessCheck.cpp
   DefinitionsInHeadersCheck.cpp
   ConfusableIdentifierCheck.cpp
+  IncludeCleanerCheck.cpp
   MiscTidyModule.cpp
   MisleadingBidirectional.cpp
   MisleadingIdentifier.cpp
@@ -53,7 +55,15 @@ clang_target_link_libraries(clangTidyMiscModule
   clangAST
   clangASTMatchers
   clangBasic
+  clangFormat
   clangLex
   clangSerialization
   clangTooling
+  clangToolingInclusions
+  clangToolingInclusionsStdlib
   )
+
+target_link_libraries(clangTidyMiscModule
+  PRIVATE
+  clangIncludeCleaner
+  )
\ No newline at end of file
diff --git a/clang-tools-extra/clang-tidy/misc/IncludeCleanerCheck.cpp b/clang-tools-extra/clang-tidy/misc/IncludeCleanerCheck.cpp
new file mode 100644
index 000000000000..c7aca83f2ca8
--- /dev/null
+++ b/clang-tools-extra/clang-tidy/misc/IncludeCleanerCheck.cpp
@@ -0,0 +1,202 @@
+//===--- IncludeCleanerCheck.cpp - clang-tidy -----------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "IncludeCleanerCheck.h"
+#include "../ClangTidyCheck.h"
+#include "../ClangTidyDiagnosticConsumer.h"
+#include "../ClangTidyOptions.h"
+#include "../utils/OptionsUtils.h"
+#include "clang-include-cleaner/Analysis.h"
+#include "clang-include-cleaner/Record.h"
+#include "clang-include-cleaner/Types.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/Decl.h"
+#include "clang/AST/DeclBase.h"
+#include "clang/ASTMatchers/ASTMatchFinder.h"
+#include "clang/ASTMatchers/ASTMatchers.h"
+#include "clang/Basic/Diagnostic.h"
+#include "clang/Basic/FileEntry.h"
+#include "clang/Basic/LLVM.h"
+#include "clang/Basic/LangOptions.h"
+#include "clang/Basic/SourceLocation.h"
+#include "clang/Format/Format.h"
+#include "clang/Lex/Preprocessor.h"
+#include "clang/Tooling/Core/Replacement.h"
+#include "clang/Tooling/Inclusions/HeaderIncludes.h"
+#include "llvm/ADT/DenseSet.h"
+#include "llvm/ADT/STLExtras.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/ADT/StringRef.h"
+#include "llvm/Support/ErrorHandling.h"
+#include "llvm/Support/Regex.h"
+#include <optional>
+#include <string>
+#include <vector>
+
+using namespace clang::ast_matchers;
+
+namespace clang::tidy::misc {
+
+namespace {
+struct MissingIncludeInfo {
+  SourceLocation SymRefLocation;
+  include_cleaner::Header Missing;
+};
+} // namespace
+
+IncludeCleanerCheck::IncludeCleanerCheck(StringRef Name,
+                                         ClangTidyContext *Context)
+    : ClangTidyCheck(Name, Context),
+      IgnoreHeaders(utils::options::parseStringList(
+          Options.getLocalOrGlobal("IgnoreHeaders", ""))) {
+  for (const auto &Header : IgnoreHeaders) {
+    if (!llvm::Regex{Header}.isValid())
+      configurationDiag("Invalid ignore headers regex '%0'") << Header;
+    std::string HeaderSuffix{Header.str()};
+    if (!Header.ends_with("$"))
+      HeaderSuffix += "$";
+    IgnoreHeadersRegex.emplace_back(HeaderSuffix);
+  }
+}
+
+void IncludeCleanerCheck::storeOptions(ClangTidyOptions::OptionMap &Opts) {
+  Options.store(Opts, "IgnoreHeaders",
+                utils::options::serializeStringList(IgnoreHeaders));
+}
+
+bool IncludeCleanerCheck::isLanguageVersionSupported(
+    const LangOptions &LangOpts) const {
+  return !LangOpts.ObjC;
+}
+
+void IncludeCleanerCheck::registerMatchers(MatchFinder *Finder) {
+  Finder->addMatcher(translationUnitDecl().bind("top"), this);
+}
+
+void IncludeCleanerCheck::registerPPCallbacks(const SourceManager &SM,
+                                              Preprocessor *PP,
+                                              Preprocessor *ModuleExpanderPP) {
+  PP->addPPCallbacks(RecordedPreprocessor.record(*PP));
+  HS = &PP->getHeaderSearchInfo();
+  RecordedPI.record(*PP);
+}
+
+bool IncludeCleanerCheck::shouldIgnore(const include_cleaner::Header &H) {
+  return llvm::any_of(IgnoreHeadersRegex, [&H](const llvm::Regex &R) {
+    switch (H.kind()) {
+    case include_cleaner::Header::Standard:
+      return R.match(H.standard().name());
+    case include_cleaner::Header::Verbatim:
+      return R.match(H.verbatim());
+    case include_cleaner::Header::Physical:
+      return R.match(H.physical()->tryGetRealPathName());
+    }
+    llvm_unreachable("Unknown Header kind.");
+  });
+}
+
+void IncludeCleanerCheck::check(const MatchFinder::MatchResult &Result) {
+  const SourceManager *SM = Result.SourceManager;
+  const FileEntry *MainFile = SM->getFileEntryForID(SM->getMainFileID());
+  llvm::DenseSet<const include_cleaner::Include *> Used;
+  std::vector<MissingIncludeInfo> Missing;
+  llvm::SmallVector<Decl *> MainFileDecls;
+  for (Decl *D : Result.Nodes.getNodeAs<TranslationUnitDecl>("top")->decls()) {
+    if (!SM->isWrittenInMainFile(SM->getExpansionLoc(D->getLocation())))
+      continue;
+    // FIXME: Filter out implicit template specializations.
+    MainFileDecls.push_back(D);
+  }
+  // FIXME: Find a way to have less code duplication between include-cleaner
+  // analysis implementation and the below code.
+  walkUsed(MainFileDecls, RecordedPreprocessor.MacroReferences, &RecordedPI,
+           *SM,
+           [&](const include_cleaner::SymbolReference &Ref,
+               llvm::ArrayRef<include_cleaner::Header> Providers) {
+             bool Satisfied = false;
+             for (const include_cleaner::Header &H : Providers) {
+               if (H.kind() == include_cleaner::Header::Physical &&
+                   H.physical() == MainFile)
+                 Satisfied = true;
+
+               for (const include_cleaner::Include *I :
+                    RecordedPreprocessor.Includes.match(H)) {
+                 Used.insert(I);
+                 Satisfied = true;
+               }
+             }
+             if (!Satisfied && !Providers.empty() &&
+                 Ref.RT == include_cleaner::RefType::Explicit &&
+                 !shouldIgnore(Providers.front()))
+               Missing.push_back({Ref.RefLocation, Providers.front()});
+           });
+
+  std::vector<const include_cleaner::Include *> Unused;
+  for (const include_cleaner::Include &I :
+       RecordedPreprocessor.Includes.all()) {
+    if (Used.contains(&I) || !I.Resolved)
+      continue;
+    if (RecordedPI.shouldKeep(I.Line))
+      continue;
+    // Check if main file is the public interface for a private header. If so
+    // we shouldn't diagnose it as unused.
+    if (auto PHeader = RecordedPI.getPublic(I.Resolved); !PHeader.empty()) {
+      PHeader = PHeader.trim("<>\"");
+      // Since most private -> public mappings happen in a verbatim way, we
+      // check textually here. This might go wrong in presence of symlinks or
+      // header mappings. But that's not different than rest of the places.
+      if (getCurrentMainFile().endswith(PHeader))
+        continue;
+    }
+
+    if (llvm::none_of(IgnoreHeadersRegex,
+                      [Resolved = I.Resolved->tryGetRealPathName()](
+                          const llvm::Regex &R) { return R.match(Resolved); }))
+      Unused.push_back(&I);
+  }
+
+  llvm::StringRef Code = SM->getBufferData(SM->getMainFileID());
+  auto FileStyle =
+      format::getStyle(format::DefaultFormatStyle, getCurrentMainFile(),
+                       format::DefaultFallbackStyle, Code,
+                       &SM->getFileManager().getVirtualFileSystem());
+  if (!FileStyle)
+    FileStyle = format::getLLVMStyle();
+
+  for (const auto *Inc : Unused) {
+    diag(Inc->HashLocation, "included header %0 is not used directly")
+        << Inc->quote()
+        << FixItHint::CreateRemoval(CharSourceRange::getCharRange(
+               SM->translateLineCol(SM->getMainFileID(), Inc->Line, 1),
+               SM->translateLineCol(SM->getMainFileID(), Inc->Line + 1, 1)));
+  }
+
+  tooling::HeaderIncludes HeaderIncludes(getCurrentMainFile(), Code,
+                                         FileStyle->IncludeStyle);
+  for (const auto &Inc : Missing) {
+    std::string Spelling =
+        include_cleaner::spellHeader(Inc.Missing, *HS, MainFile);
+    bool Angled = llvm::StringRef{Spelling}.starts_with("<");
+    // We might suggest insertion of an existing include in edge cases, e.g.,
+    // include is present in a PP-disabled region, or spelling of the header
+    // turns out to be the same as one of the unresolved includes in the
+    // main file.
+    if (auto Replacement =
+            HeaderIncludes.insert(llvm::StringRef{Spelling}.trim("\"<>"),
+                                  Angled, tooling::IncludeDirective::Include))
+      diag(SM->getSpellingLoc(Inc.SymRefLocation),
+           "no header providing %0 is directly included")
+          << Spelling
+          << FixItHint::CreateInsertion(
+                 SM->getComposedLoc(SM->getMainFileID(),
+                                    Replacement->getOffset()),
+                 Replacement->getReplacementText());
+  }
+}
+
+} // namespace clang::tidy::misc
diff --git a/clang-tools-extra/clang-tidy/misc/IncludeCleanerCheck.h b/clang-tools-extra/clang-tidy/misc/IncludeCleanerCheck.h
new file mode 100644
index 000000000000..d5f75f2b1c7f
--- /dev/null
+++ b/clang-tools-extra/clang-tidy/misc/IncludeCleanerCheck.h
@@ -0,0 +1,53 @@
+//===--- IncludeCleanerCheck.h - clang-tidy ---------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_MISC_INCLUDECLEANER_H
+#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_MISC_INCLUDECLEANER_H
+
+#include "../ClangTidyCheck.h"
+#include "../ClangTidyDiagnosticConsumer.h"
+#include "../ClangTidyOptions.h"
+#include "clang-include-cleaner/Record.h"
+#include "clang-include-cleaner/Types.h"
+#include "clang/ASTMatchers/ASTMatchFinder.h"
+#include "clang/Basic/LLVM.h"
+#include "clang/Basic/SourceLocation.h"
+#include "clang/Lex/HeaderSearch.h"
+#include "llvm/Support/Regex.h"
+#include <vector>
+
+namespace clang::tidy::misc {
+
+/// Checks for unused and missing includes. Generates findings only for
+/// the main file of a translation unit.
+/// Findings correspond to https://clangd.llvm.org/design/include-cleaner.
+///
+/// For the user-facing documentation see:
+/// http://clang.llvm.org/extra/clang-tidy/checks/misc/include-cleaner.html
+class IncludeCleanerCheck : public ClangTidyCheck {
+public:
+  IncludeCleanerCheck(StringRef Name, ClangTidyContext *Context);
+  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
+  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
+  void registerPPCallbacks(const SourceManager &SM, Preprocessor *PP,
+                           Preprocessor *ModuleExpanderPP) override;
+  void storeOptions(ClangTidyOptions::OptionMap &Opts) override;
+  bool isLanguageVersionSupported(const LangOptions &LangOpts) const override;
+
+private:
+  include_cleaner::RecordedPP RecordedPreprocessor;
+  include_cleaner::PragmaIncludes RecordedPI;
+  HeaderSearch *HS;
+  std::vector<StringRef> IgnoreHeaders;
+  llvm::SmallVector<llvm::Regex> IgnoreHeadersRegex;
+  bool shouldIgnore(const include_cleaner::Header &H);
+};
+
+} // namespace clang::tidy::misc
+
+#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_MISC_INCLUDECLEANER_H
diff --git a/clang-tools-extra/clang-tidy/misc/MiscTidyModule.cpp b/clang-tools-extra/clang-tidy/misc/MiscTidyModule.cpp
index 2ec61f891263..f63c5ab543fe 100644
--- a/clang-tools-extra/clang-tidy/misc/MiscTidyModule.cpp
+++ b/clang-tools-extra/clang-tidy/misc/MiscTidyModule.cpp
@@ -12,6 +12,7 @@
 #include "ConfusableIdentifierCheck.h"
 #include "ConstCorrectnessCheck.h"
 #include "DefinitionsInHeadersCheck.h"
+#include "IncludeCleanerCheck.h"
 #include "MisleadingBidirectional.h"
 #include "MisleadingIdentifier.h"
 #include "MisplacedConstCheck.h"
@@ -41,6 +42,7 @@ public:
         "misc-const-correctness");
     CheckFactories.registerCheck<DefinitionsInHeadersCheck>(
         "misc-definitions-in-headers");
+    CheckFactories.registerCheck<IncludeCleanerCheck>("misc-include-cleaner");
     CheckFactories.registerCheck<MisleadingBidirectionalCheck>(
         "misc-misleading-bidirectional");
     CheckFactories.registerCheck<MisleadingIdentifierCheck>(
diff --git a/clang-tools-extra/clangd/Config.h b/clang-tools-extra/clangd/Config.h
index f41906b2f0fa..26f55eda3ef0 100644
--- a/clang-tools-extra/clangd/Config.h
+++ b/clang-tools-extra/clangd/Config.h
@@ -88,11 +88,12 @@ struct Config {
     bool StandardLibrary = true;
   } Index;

-  enum UnusedIncludesPolicy {
-    /// Diagnose unused includes.
+  enum IncludesPolicy {
+    /// Diagnose missing and unused includes.
     Strict,
     None,
-    /// The same as Strict, but using the include-cleaner library.
+    /// The same as Strict, but using the include-cleaner library for
+    /// unused includes.
     Experiment,
   };
   /// Controls warnings and errors when parsing code.
@@ -107,7 +108,8 @@ struct Config {
       llvm::StringMap<std::string> CheckOptions;
     } ClangTidy;

-    UnusedIncludesPolicy UnusedIncludes = None;
+    IncludesPolicy UnusedIncludes = IncludesPolicy::None;
+    IncludesPolicy MissingIncludes = IncludesPolicy::None;

     /// IncludeCleaner will not diagnose usages of these headers matched by
     /// these regexes.
diff --git a/clang-tools-extra/clangd/ConfigCompile.cpp b/clang-tools-extra/clangd/ConfigCompile.cpp
index b1876e21ee30..d74d8eb9a904 100644
--- a/clang-tools-extra/clangd/ConfigCompile.cpp
+++ b/clang-tools-extra/clangd/ConfigCompile.cpp
@@ -431,16 +431,26 @@ struct FragmentCompiler {
           });

     if (F.UnusedIncludes)
-      if (auto Val =
-              compileEnum<Config::UnusedIncludesPolicy>("UnusedIncludes",
-                                                        **F.UnusedIncludes)
-                  .map("Strict", Config::UnusedIncludesPolicy::Strict)
-                  .map("Experiment", Config::UnusedIncludesPolicy::Experiment)
-                  .map("None", Config::UnusedIncludesPolicy::None)
-                  .value())
+      if (auto Val = compileEnum<Config::IncludesPolicy>("UnusedIncludes",
+                                                         **F.UnusedIncludes)
+                         .map("Strict", Config::IncludesPolicy::Strict)
+                         .map("Experiment", Config::IncludesPolicy::Experiment)
+                         .map("None", Config::IncludesPolicy::None)
+                         .value())
         Out.Apply.push_back([Val](const Params &, Config &C) {
           C.Diagnostics.UnusedIncludes = *Val;
         });
+
+    if (F.MissingIncludes)
+      if (auto Val = compileEnum<Config::IncludesPolicy>("MissingIncludes",
+                                                         **F.MissingIncludes)
+                         .map("Strict", Config::IncludesPolicy::Strict)
+                         .map("None", Config::IncludesPolicy::None)
+                         .value())
+        Out.Apply.push_back([Val](const Params &, Config &C) {
+          C.Diagnostics.MissingIncludes = *Val;
+        });
+
     compile(std::move(F.Includes));

     compile(std::move(F.ClangTidy));
diff --git a/clang-tools-extra/clangd/ConfigFragment.h b/clang-tools-extra/clangd/ConfigFragment.h
index bcd1a05b4a99..a499ce577c58 100644
--- a/clang-tools-extra/clangd/ConfigFragment.h
+++ b/clang-tools-extra/clangd/ConfigFragment.h
@@ -235,6 +235,19 @@ struct Fragment {
     /// - None
     std::optional<Located<std::string>> UnusedIncludes;

+    /// Controls if clangd should analyze missing #include directives.
+    /// clangd will warn if no header providing a symbol is `#include`d
+    /// (missing) directly, and suggest adding it.
+    ///
+    /// Strict means a header providing a symbol is missing if it is not
+    /// *directly #include'd. The file might still compile if the header is
+    /// included transitively.
+    ///
+    /// Valid values are:
+    /// - Strict
+    /// - None
+    std::optional<Located<std::string>> MissingIncludes;
+
     /// Controls IncludeCleaner diagnostics.
     struct IncludesBlock {
       /// Regexes that will be used to avoid diagnosing certain includes as
diff --git a/clang-tools-extra/clangd/ConfigYAML.cpp b/clang-tools-extra/clangd/ConfigYAML.cpp
index ee91753dd88d..c017fb88a592 100644
--- a/clang-tools-extra/clangd/ConfigYAML.cpp
+++ b/clang-tools-extra/clangd/ConfigYAML.cpp
@@ -128,6 +128,9 @@ private:
     Dict.handle("UnusedIncludes", [&](Node &N) {
       F.UnusedIncludes = scalarValue(N, "UnusedIncludes");
     });
+    Dict.handle("MissingIncludes", [&](Node &N) {
+      F.MissingIncludes = scalarValue(N, "MissingIncludes");
+    });
     Dict.handle("Includes", [&](Node &N) { parse(F.Includes, N); });
     Dict.handle("ClangTidy", [&](Node &N) { parse(F.ClangTidy, N); });
     Dict.parse(N);
diff --git a/clang-tools-extra/clangd/IncludeCleaner.cpp b/clang-tools-extra/clangd/IncludeCleaner.cpp
index 5a7df2fc33f6..8873a432ddc4 100644
--- a/clang-tools-extra/clangd/IncludeCleaner.cpp
+++ b/clang-tools-extra/clangd/IncludeCleaner.cpp
@@ -8,32 +8,55 @@

 #include "IncludeCleaner.h"
 #include "Config.h"
+#include "Diagnostics.h"
 #include "Headers.h"
 #include "ParsedAST.h"
 #include "Protocol.h"
 #include "SourceCode.h"
+#include "URI.h"
 #include "clang-include-cleaner/Analysis.h"
 #include "clang-include-cleaner/Types.h"
 #include "index/CanonicalIncludes.h"
 #include "support/Logger.h"
+#include "support/Path.h"
 #include "support/Trace.h"
 #include "clang/AST/ASTContext.h"
+#include "clang/AST/DeclCXX.h"
+#include "clang/AST/Expr.h"
 #include "clang/AST/ExprCXX.h"
 #include "clang/AST/RecursiveASTVisitor.h"
+#include "clang/AST/TemplateName.h"
+#include "clang/AST/Type.h"
+#include "clang/Basic/Diagnostic.h"
+#include "clang/Basic/LLVM.h"
 #include "clang/Basic/SourceLocation.h"
 #include "clang/Basic/SourceManager.h"
+#include "clang/Format/Format.h"
 #include "clang/Lex/HeaderSearch.h"
 #include "clang/Lex/Preprocessor.h"
+#include "clang/Tooling/Core/Replacement.h"
+#include "clang/Tooling/Inclusions/HeaderIncludes.h"
+#include "clang/Tooling/Inclusions/IncludeStyle.h"
+#include "clang/Tooling/Inclusions/StandardLibrary.h"
 #include "clang/Tooling/Syntax/Tokens.h"
 #include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/DenseSet.h"
+#include "llvm/ADT/STLExtras.h"
 #include "llvm/ADT/STLFunctionalExtras.h"
 #include "llvm/ADT/SmallString.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/ADT/StringRef.h"
 #include "llvm/ADT/StringSet.h"
+#include "llvm/Support/Casting.h"
+#include "llvm/Support/Error.h"
+#include "llvm/Support/ErrorHandling.h"
 #include "llvm/Support/FormatVariadic.h"
 #include "llvm/Support/Path.h"
 #include "llvm/Support/Regex.h"
-#include <functional>
+#include <iterator>
 #include <optional>
+#include <string>
+#include <vector>

 namespace clang {
 namespace clangd {
@@ -258,6 +281,17 @@ void findReferencedMacros(const SourceManager &SM, Preprocessor &PP,
   }
 }

+bool isFilteredByConfig(const Config &Cfg, llvm::StringRef HeaderPath) {
+  // Convert the path to Unix slashes and try to match against the filter.
+  llvm::SmallString<64> NormalizedPath(HeaderPath);
+  llvm::sys::path::native(NormalizedPath, llvm::sys::path::Style::posix);
+  for (auto &Filter : Cfg.Diagnostics.Includes.IgnoreHeader) {
+    if (Filter(NormalizedPath))
+      return true;
+  }
+  return false;
+}
+
 static bool mayConsiderUnused(const Inclusion &Inc, ParsedAST &AST,
                               const Config &Cfg) {
   if (Inc.BehindPragmaKeep)
@@ -288,14 +322,9 @@ static bool mayConsiderUnused(const Inclusion &Inc, ParsedAST &AST,
          FE->getName());
     return false;
   }
-  for (auto &Filter : Cfg.Diagnostics.Includes.IgnoreHeader) {
-    // Convert the path to Unix slashes and try to match against the filter.
-    llvm::SmallString<64> Path(Inc.Resolved);
-    llvm::sys::path::native(Path, llvm::sys::path::Style::posix);
-    if (Filter(Inc.Resolved)) {
-      dlog("{0} header is filtered out by the configuration", FE->getName());
-      return false;
-    }
+  if (isFilteredByConfig(Cfg, Inc.Resolved)) {
+    dlog("{0} header is filtered out by the configuration", FE->getName());
+    return false;
   }
   return true;
 }
@@ -325,6 +354,195 @@ FileID headerResponsible(FileID ID, const SourceManager &SM,
   return ID;
 }

+include_cleaner::Includes
+convertIncludes(const SourceManager &SM,
+                const llvm::ArrayRef<Inclusion> MainFileIncludes) {
+  include_cleaner::Includes Includes;
+  for (const Inclusion &Inc : MainFileIncludes) {
+    include_cleaner::Include TransformedInc;
+    llvm::StringRef WrittenRef = llvm::StringRef(Inc.Written);
+    TransformedInc.Spelled = WrittenRef.trim("\"<>");
+    TransformedInc.HashLocation =
+        SM.getComposedLoc(SM.getMainFileID(), Inc.HashOffset);
+    TransformedInc.Line = Inc.HashLine + 1;
+    TransformedInc.Angled = WrittenRef.starts_with("<");
+    auto FE = SM.getFileManager().getFile(Inc.Resolved);
+    if (!FE) {
+      elog("IncludeCleaner: Failed to get an entry for resolved path {0}: {1}",
+           Inc.Resolved, FE.getError().message());
+      continue;
+    }
+    TransformedInc.Resolved = *FE;
+    Includes.add(std::move(TransformedInc));
+  }
+  return Includes;
+}
+
+std::string spellHeader(ParsedAST &AST, const FileEntry *MainFile,
+                        include_cleaner::Header Provider) {
+  if (Provider.kind() == include_cleaner::Header::Physical) {
+    if (auto CanonicalPath =
+            getCanonicalPath(Provider.physical(), AST.getSourceManager())) {
+      std::string SpelledHeader =
+          llvm::cantFail(URI::includeSpelling(URI::create(*CanonicalPath)));
+      if (!SpelledHeader.empty())
+        return SpelledHeader;
+    }
+  }
+  return include_cleaner::spellHeader(
+      Provider, AST.getPreprocessor().getHeaderSearchInfo(), MainFile);
+}
+
+std::vector<include_cleaner::SymbolReference>
+collectMacroReferences(ParsedAST &AST) {
+  const auto &SM = AST.getSourceManager();
+  //  FIXME: !!this is a hacky way to collect macro references.
+  std::vector<include_cleaner::SymbolReference> Macros;
+  auto &PP = AST.getPreprocessor();
+  for (const syntax::Token &Tok :
+       AST.getTokens().spelledTokens(SM.getMainFileID())) {
+    auto Macro = locateMacroAt(Tok, PP);
+    if (!Macro)
+      continue;
+    if (auto DefLoc = Macro->Info->getDefinitionLoc(); DefLoc.isValid())
+      Macros.push_back(
+          {Tok.location(),
+           include_cleaner::Macro{/*Name=*/PP.getIdentifierInfo(Tok.text(SM)),
+                                  DefLoc},
+           include_cleaner::RefType::Explicit});
+  }
+  return Macros;
+}
+
+llvm::StringRef getResolvedPath(const include_cleaner::Header &SymProvider) {
+  switch (SymProvider.kind()) {
+  case include_cleaner::Header::Physical:
+    return SymProvider.physical()->tryGetRealPathName();
+  case include_cleaner::Header::Standard:
+    return SymProvider.standard().name().trim("<>\"");
+  case include_cleaner::Header::Verbatim:
+    return SymProvider.verbatim().trim("<>\"");
+  }
+  llvm_unreachable("Unknown header kind");
+}
+
+std::string getSymbolName(const include_cleaner::Symbol &Sym) {
+  switch (Sym.kind()) {
+  case include_cleaner::Symbol::Macro:
+    return Sym.macro().Name->getName().str();
+  case include_cleaner::Symbol::Declaration:
+    return llvm::dyn_cast<NamedDecl>(&Sym.declaration())
+        ->getQualifiedNameAsString();
+  }
+  llvm_unreachable("Unknown symbol kind");
+}
+
+std::vector<Diag> generateMissingIncludeDiagnostics(
+    ParsedAST &AST, llvm::ArrayRef<MissingIncludeDiagInfo> MissingIncludes,
+    llvm::StringRef Code) {
+  std::vector<Diag> Result;
+  const Config &Cfg = Config::current();
+  if (Cfg.Diagnostics.MissingIncludes != Config::IncludesPolicy::Strict ||
+      Cfg.Diagnostics.SuppressAll ||
+      Cfg.Diagnostics.Suppress.contains("missing-includes")) {
+    return Result;
+  }
+
+  const SourceManager &SM = AST.getSourceManager();
+  const FileEntry *MainFile = SM.getFileEntryForID(SM.getMainFileID());
+
+  auto FileStyle = format::getStyle(
+      format::DefaultFormatStyle, AST.tuPath(), format::DefaultFallbackStyle,
+      Code, &SM.getFileManager().getVirtualFileSystem());
+  if (!FileStyle) {
+    elog("Couldn't infer style", FileStyle.takeError());
+    FileStyle = format::getLLVMStyle();
+  }
+
+  tooling::HeaderIncludes HeaderIncludes(AST.tuPath(), Code,
+                                         FileStyle->IncludeStyle);
+  for (const auto &SymbolWithMissingInclude : MissingIncludes) {
+    llvm::StringRef ResolvedPath =
+        getResolvedPath(SymbolWithMissingInclude.Providers.front());
+    if (isFilteredByConfig(Cfg, ResolvedPath)) {
+      dlog("IncludeCleaner: not diagnosing missing include {0}, filtered by "
+           "config",
+           ResolvedPath);
+      continue;
+    }
+
+    std::string Spelling =
+        spellHeader(AST, MainFile, SymbolWithMissingInclude.Providers.front());
+    llvm::StringRef HeaderRef{Spelling};
+    bool Angled = HeaderRef.starts_with("<");
+    // We might suggest insertion of an existing include in edge cases, e.g.,
+    // include is present in a PP-disabled region, or spelling of the header
+    // turns out to be the same as one of the unresolved includes in the
+    // main file.
+    std::optional<tooling::Replacement> Replacement = HeaderIncludes.insert(
+        HeaderRef.trim("\"<>"), Angled, tooling::IncludeDirective::Include);
+    if (!Replacement.has_value())
+      continue;
+
+    Diag &D = Result.emplace_back();
+    D.Message =
+        llvm::formatv("No header providing \"{0}\" is directly included",
+                      getSymbolName(SymbolWithMissingInclude.Symbol));
+    D.Name = "missing-includes";
+    D.Source = Diag::DiagSource::Clangd;
+    D.File = AST.tuPath();
+    D.InsideMainFile = true;
+    D.Severity = DiagnosticsEngine::Warning;
+    D.Range = clangd::Range{
+        offsetToPosition(Code,
+                         SymbolWithMissingInclude.SymRefRange.beginOffset()),
+        offsetToPosition(Code,
+                         SymbolWithMissingInclude.SymRefRange.endOffset())};
+    auto &F = D.Fixes.emplace_back();
+    F.Message = "#include " + Spelling;
+    TextEdit Edit = replacementToEdit(Code, *Replacement);
+    F.Edits.emplace_back(std::move(Edit));
+  }
+  return Result;
+}
+
+std::vector<Diag> generateUnusedIncludeDiagnostics(
+    PathRef FileName, llvm::ArrayRef<const Inclusion *> UnusedIncludes,
+    llvm::StringRef Code) {
+  std::vector<Diag> Result;
+  const Config &Cfg = Config::current();
+  if (Cfg.Diagnostics.UnusedIncludes == Config::IncludesPolicy::None ||
+      Cfg.Diagnostics.SuppressAll ||
+      Cfg.Diagnostics.Suppress.contains("unused-includes")) {
+    return Result;
+  }
+  for (const auto *Inc : UnusedIncludes) {
+    Diag &D = Result.emplace_back();
+    D.Message =
+        llvm::formatv("included header {0} is not used directly",
+                      llvm::sys::path::filename(
+                          Inc->Written.substr(1, Inc->Written.size() - 2),
+                          llvm::sys::path::Style::posix));
+    D.Name = "unused-includes";
+    D.Source = Diag::DiagSource::Clangd;
+    D.File = FileName;
+    D.InsideMainFile = true;
+    D.Severity = DiagnosticsEngine::Warning;
+    D.Tags.push_back(Unnecessary);
+    D.Range = getDiagnosticRange(Code, Inc->HashOffset);
+    // FIXME(kirillbobyrev): Removing inclusion might break the code if the
+    // used headers are only reachable transitively through this one. Suggest
+    // including them directly instead.
+    // FIXME(kirillbobyrev): Add fix suggestion for adding IWYU pragmas
+    // (keep/export) remove the warning once we support IWYU pragmas.
+    auto &F = D.Fixes.emplace_back();
+    F.Message = "remove #include directive";
+    F.Edits.emplace_back();
+    F.Edits.back().range.start.line = Inc->HashLine;
+    F.Edits.back().range.end.line = Inc->HashLine + 1;
+  }
+  return Result;
+}
 } // namespace

 ReferencedLocations findReferencedLocations(ASTContext &Ctx, Preprocessor &PP,
@@ -474,105 +692,85 @@ std::vector<const Inclusion *> computeUnusedIncludes(ParsedAST &AST) {
       translateToHeaderIDs(ReferencedFiles, AST.getIncludeStructure(), SM);
   return getUnused(AST, ReferencedHeaders, ReferencedFiles.SpelledUmbrellas);
 }
-std::vector<const Inclusion *> computeUnusedIncludesExperimental(ParsedAST &AST) {
+IncludeCleanerFindings computeIncludeCleanerFindings(ParsedAST &AST) {
    const auto &SM = AST.getSourceManager();
    const auto &Includes = AST.getIncludeStructure();
-   // FIXME: this map should probably be in IncludeStructure.
-   llvm::StringMap<llvm::SmallVector<IncludeStructure::HeaderID>> BySpelling;
-   for (const auto &Inc : Includes.MainFileIncludes) {
-    if (Inc.HeaderID)
-      BySpelling.try_emplace(Inc.Written)
-          .first->second.push_back(
-              static_cast<IncludeStructure::HeaderID>(*Inc.HeaderID));
-   }
-   // FIXME: !!this is a hacky way to collect macro references.
-   std::vector<include_cleaner::SymbolReference> Macros;
-    auto& PP = AST.getPreprocessor();
-   for (const syntax::Token &Tok :
-        AST.getTokens().spelledTokens(SM.getMainFileID())) {
-    auto Macro = locateMacroAt(Tok, PP);
-    if (!Macro)
-      continue;
-    if (auto DefLoc = Macro->Info->getDefinitionLoc(); DefLoc.isValid())
-      Macros.push_back(
-          {Tok.location(),
-           include_cleaner::Macro{/*Name=*/PP.getIdentifierInfo(Tok.text(SM)),
-                                  DefLoc},
-           include_cleaner::RefType::Explicit});
-   }
-   llvm::DenseSet<IncludeStructure::HeaderID> Used;
-   include_cleaner::walkUsed(
-       AST.getLocalTopLevelDecls(), /*MacroRefs=*/Macros,
-       AST.getPragmaIncludes(), SM,
-       [&](const include_cleaner::SymbolReference &Ref,
-           llvm::ArrayRef<include_cleaner::Header> Providers) {
-         for (const auto &H : Providers) {
-           switch (H.kind()) {
-           case include_cleaner::Header::Physical:
-             if (auto HeaderID = Includes.getID(H.physical()))
-               Used.insert(*HeaderID);
-             break;
-           case include_cleaner::Header::Standard:
-             for (auto HeaderID : Includes.StdlibHeaders.lookup(H.standard()))
-               Used.insert(HeaderID);
-             break;
-           case include_cleaner::Header::Verbatim:
-             for (auto HeaderID : BySpelling.lookup(H.verbatim()))
-               Used.insert(HeaderID);
-             break;
-           }
-         }
-       });
-   return getUnused(AST, Used, /*ReferencedPublicHeaders*/{});
+  include_cleaner::Includes ConvertedIncludes =
+      convertIncludes(SM, Includes.MainFileIncludes);
+  const FileEntry *MainFile = SM.getFileEntryForID(SM.getMainFileID());
+
+  std::vector<include_cleaner::SymbolReference> Macros =
+      collectMacroReferences(AST);
+  std::vector<MissingIncludeDiagInfo> MissingIncludes;
+  llvm::DenseSet<IncludeStructure::HeaderID> Used;
+  trace::Span Tracer("include_cleaner::walkUsed");
+  include_cleaner::walkUsed(
+      AST.getLocalTopLevelDecls(), /*MacroRefs=*/Macros,
+      AST.getPragmaIncludes(), SM,
+      [&](const include_cleaner::SymbolReference &Ref,
+          llvm::ArrayRef<include_cleaner::Header> Providers) {
+        bool Satisfied = false;
+        for (const auto &H : Providers) {
+          if (H.kind() == include_cleaner::Header::Physical &&
+              H.physical() == MainFile) {
+            Satisfied = true;
+            continue;
+          }
+          for (auto *Inc : ConvertedIncludes.match(H)) {
+            Satisfied = true;
+            auto HeaderID = Includes.getID(Inc->Resolved);
+            assert(HeaderID.has_value() &&
+                   "ConvertedIncludes only contains resolved includes.");
+            Used.insert(*HeaderID);
+          }
+        }
+
+        if (Satisfied || Providers.empty() ||
+            Ref.RT != include_cleaner::RefType::Explicit)
+          return;
+
+        auto &Tokens = AST.getTokens();
+        auto SpelledForExpanded =
+            Tokens.spelledForExpanded(Tokens.expandedTokens(Ref.RefLocation));
+        if (!SpelledForExpanded)
+          return;
+
+        auto Range = syntax::Token::range(SM, SpelledForExpanded->front(),
+                                          SpelledForExpanded->back());
+        MissingIncludeDiagInfo DiagInfo{Ref.Target, Range, Providers};
+        MissingIncludes.push_back(std::move(DiagInfo));
+      });
+  std::vector<const Inclusion *> UnusedIncludes =
+      getUnused(AST, Used, /*ReferencedPublicHeaders*/ {});
+  return {std::move(UnusedIncludes), std::move(MissingIncludes)};
 }

-std::vector<Diag> issueUnusedIncludesDiagnostics(ParsedAST &AST,
+std::vector<Diag> issueIncludeCleanerDiagnostics(ParsedAST &AST,
                                                  llvm::StringRef Code) {
-  const Config &Cfg = Config::current();
-  if (Cfg.Diagnostics.UnusedIncludes == Config::UnusedIncludesPolicy::None ||
-      Cfg.Diagnostics.SuppressAll ||
-      Cfg.Diagnostics.Suppress.contains("unused-includes"))
-    return {};
   // Interaction is only polished for C/CPP.
   if (AST.getLangOpts().ObjC)
     return {};
-  trace::Span Tracer("IncludeCleaner::issueUnusedIncludesDiagnostics");
-  std::vector<Diag> Result;
-  std::string FileName =
-      AST.getSourceManager()
-          .getFileEntryRefForID(AST.getSourceManager().getMainFileID())
-          ->getName()
-          .str();
-  const auto &UnusedIncludes =
-      Cfg.Diagnostics.UnusedIncludes == Config::UnusedIncludesPolicy::Experiment
-          ? computeUnusedIncludesExperimental(AST)
-          : computeUnusedIncludes(AST);
-  for (const auto *Inc : UnusedIncludes) {
-    Diag D;
-    D.Message =
-        llvm::formatv("included header {0} is not used directly",
-                      llvm::sys::path::filename(
-                          Inc->Written.substr(1, Inc->Written.size() - 2),
-                          llvm::sys::path::Style::posix));
-    D.Name = "unused-includes";
-    D.Source = Diag::DiagSource::Clangd;
-    D.File = FileName;
-    D.Severity = DiagnosticsEngine::Warning;
-    D.Tags.push_back(Unnecessary);
-    D.Range = getDiagnosticRange(Code, Inc->HashOffset);
-    // FIXME(kirillbobyrev): Removing inclusion might break the code if the
-    // used headers are only reachable transitively through this one. Suggest
-    // including them directly instead.
-    // FIXME(kirillbobyrev): Add fix suggestion for adding IWYU pragmas
-    // (keep/export) remove the warning once we support IWYU pragmas.
-    D.Fixes.emplace_back();
-    D.Fixes.back().Message = "remove #include directive";
-    D.Fixes.back().Edits.emplace_back();
-    D.Fixes.back().Edits.back().range.start.line = Inc->HashLine;
-    D.Fixes.back().Edits.back().range.end.line = Inc->HashLine + 1;
-    D.InsideMainFile = true;
-    Result.push_back(std::move(D));
+
+  trace::Span Tracer("IncludeCleaner::issueIncludeCleanerDiagnostics");
+
+  const Config &Cfg = Config::current();
+  IncludeCleanerFindings Findings;
+  if (Cfg.Diagnostics.MissingIncludes == Config::IncludesPolicy::Strict ||
+      Cfg.Diagnostics.UnusedIncludes == Config::IncludesPolicy::Experiment) {
+    // will need include-cleaner results, call it once
+    Findings = computeIncludeCleanerFindings(AST);
   }
+
+  std::vector<Diag> Result = generateUnusedIncludeDiagnostics(
+      AST.tuPath(),
+      Cfg.Diagnostics.UnusedIncludes == Config::IncludesPolicy::Strict
+          ? computeUnusedIncludes(AST)
+          : Findings.UnusedIncludes,
+      Code);
+  llvm::move(
+      generateMissingIncludeDiagnostics(AST, Findings.MissingIncludes, Code),
+      std::back_inserter(Result));
+
   return Result;
 }

diff --git a/clang-tools-extra/clangd/IncludeCleaner.h b/clang-tools-extra/clangd/IncludeCleaner.h
index a7beb9c3c9d4..989067e3d84f 100644
--- a/clang-tools-extra/clangd/IncludeCleaner.h
+++ b/clang-tools-extra/clangd/IncludeCleaner.h
@@ -20,18 +20,38 @@

 #include "Headers.h"
 #include "ParsedAST.h"
+#include "clang-include-cleaner/Types.h"
 #include "index/CanonicalIncludes.h"
 #include "clang/Basic/SourceLocation.h"
 #include "clang/Tooling/Inclusions/StandardLibrary.h"
+#include "clang/Tooling/Syntax/Tokens.h"
 #include "llvm/ADT/DenseSet.h"
 #include "llvm/ADT/STLFunctionalExtras.h"
 #include "llvm/ADT/StringSet.h"
 #include <optional>
+#include <tuple>
 #include <vector>

 namespace clang {
 namespace clangd {

+// Data needed for missing include diagnostics.
+struct MissingIncludeDiagInfo {
+  include_cleaner::Symbol Symbol;
+  syntax::FileRange SymRefRange;
+  std::vector<include_cleaner::Header> Providers;
+
+  bool operator==(const MissingIncludeDiagInfo &Other) const {
+    return std::tie(SymRefRange, Providers, Symbol) ==
+           std::tie(Other.SymRefRange, Other.Providers, Other.Symbol);
+  }
+};
+
+struct IncludeCleanerFindings {
+  std::vector<const Inclusion *> UnusedIncludes;
+  std::vector<MissingIncludeDiagInfo> MissingIncludes;
+};
+
 struct ReferencedLocations {
   llvm::DenseSet<SourceLocation> User;
   llvm::DenseSet<tooling::stdlib::Symbol> Stdlib;
@@ -96,13 +116,10 @@ getUnused(ParsedAST &AST,
           const llvm::DenseSet<IncludeStructure::HeaderID> &ReferencedFiles,
           const llvm::StringSet<> &ReferencedPublicHeaders);

+IncludeCleanerFindings computeIncludeCleanerFindings(ParsedAST &AST);
 std::vector<const Inclusion *> computeUnusedIncludes(ParsedAST &AST);
-// The same as computeUnusedIncludes, but it is an experimental and
-// include-cleaner-lib-based implementation.
-std::vector<const Inclusion *>
-computeUnusedIncludesExperimental(ParsedAST &AST);

-std::vector<Diag> issueUnusedIncludesDiagnostics(ParsedAST &AST,
+std::vector<Diag> issueIncludeCleanerDiagnostics(ParsedAST &AST,
                                                  llvm::StringRef Code);

 /// Affects whether standard library includes should be considered for
diff --git a/clang-tools-extra/clangd/ParsedAST.cpp b/clang-tools-extra/clangd/ParsedAST.cpp
index bf639a6fb58e..e0d385acf73a 100644
--- a/clang-tools-extra/clangd/ParsedAST.cpp
+++ b/clang-tools-extra/clangd/ParsedAST.cpp
@@ -688,13 +688,9 @@ ParsedAST::build(llvm::StringRef Filename, const ParseInputs &Inputs,
                    std::move(Macros), std::move(Marks), std::move(ParsedDecls),
                    std::move(Diags), std::move(Includes),
                    std::move(CanonIncludes));
-  if (Result.Diags) {
-    auto UnusedHeadersDiags =
-        issueUnusedIncludesDiagnostics(Result, Inputs.Contents);
-    Result.Diags->insert(Result.Diags->end(),
-                         make_move_iterator(UnusedHeadersDiags.begin()),
-                         make_move_iterator(UnusedHeadersDiags.end()));
-  }
+  if (Result.Diags)
+    llvm::move(issueIncludeCleanerDiagnostics(Result, Inputs.Contents),
+               std::back_inserter(*Result.Diags));
   return std::move(Result);
 }

diff --git a/clang-tools-extra/clangd/Preamble.cpp b/clang-tools-extra/clangd/Preamble.cpp
index 15eea9bb036b..b960f7765cb7 100644
--- a/clang-tools-extra/clangd/Preamble.cpp
+++ b/clang-tools-extra/clangd/Preamble.cpp
@@ -123,7 +123,9 @@ public:
     SourceMgr = &CI.getSourceManager();
     Includes.collect(CI);
     if (Config::current().Diagnostics.UnusedIncludes ==
-        Config::UnusedIncludesPolicy::Experiment)
+                Config::IncludesPolicy::Experiment ||
+            Config::current().Diagnostics.MissingIncludes ==
+            Config::IncludesPolicy::Strict)
       Pragmas.record(CI);
     if (BeforeExecuteCallback)
       BeforeExecuteCallback(CI);
diff --git a/clang-tools-extra/clangd/TidyProvider.cpp b/clang-tools-extra/clangd/TidyProvider.cpp
index f3ed6f08a9ac..bdf4c7d94a0b 100644
--- a/clang-tools-extra/clangd/TidyProvider.cpp
+++ b/clang-tools-extra/clangd/TidyProvider.cpp
@@ -195,32 +195,35 @@ TidyProvider addTidyChecks(llvm::StringRef Checks,

 TidyProvider disableUnusableChecks(llvm::ArrayRef<std::string> ExtraBadChecks) {
   constexpr llvm::StringLiteral Seperator(",");
-  static const std::string BadChecks =
-      llvm::join_items(Seperator,
-                       // We want this list to start with a seperator to
-                       // simplify appending in the lambda. So including an
-                       // empty string here will force that.
-                       "",
-                       // ----- False Positives -----
-
-                       // Check relies on seeing ifndef/define/endif directives,
-                       // clangd doesn't replay those when using a preamble.
-                       "-llvm-header-guard", "-modernize-macro-to-enum",
-
-                       // ----- Crashing Checks -----
-
-                       // Check can choke on invalid (intermediate) c++
-                       // code, which is often the case when clangd
-                       // tries to build an AST.
-                       "-bugprone-use-after-move",
-                       // Alias for bugprone-use-after-move.
-                       "-hicpp-invalid-access-moved",
-
-                       // ----- Performance problems -----
-
-                       // This check runs expensive analysis for each variable.
-                       // It has been observed to increase reparse time by 10x.
-                       "-misc-const-correctness");
+  static const std::string BadChecks = llvm::join_items(
+      Seperator,
+      // We want this list to start with a seperator to
+      // simplify appending in the lambda. So including an
+      // empty string here will force that.
+      "",
+      // include-cleaner is directly integrated in IncludeCleaner.cpp
+      "-misc-include-cleaner",
+
+      // ----- False Positives -----
+
+      // Check relies on seeing ifndef/define/endif directives,
+      // clangd doesn't replay those when using a preamble.
+      "-llvm-header-guard", "-modernize-macro-to-enum",
+
+      // ----- Crashing Checks -----
+
+      // Check can choke on invalid (intermediate) c++
+      // code, which is often the case when clangd
+      // tries to build an AST.
+      "-bugprone-use-after-move",
+      // Alias for bugprone-use-after-move.
+      "-hicpp-invalid-access-moved",
+
+      // ----- Performance problems -----
+
+      // This check runs expensive analysis for each variable.
+      // It has been observed to increase reparse time by 10x.
+      "-misc-const-correctness");

   size_t Size = BadChecks.size();
   for (const std::string &Str : ExtraBadChecks) {
diff --git a/clang-tools-extra/clangd/unittests/ConfigCompileTests.cpp b/clang-tools-extra/clangd/unittests/ConfigCompileTests.cpp
index 427409bfe634..e6e9eff78f52 100644
--- a/clang-tools-extra/clangd/unittests/ConfigCompileTests.cpp
+++ b/clang-tools-extra/clangd/unittests/ConfigCompileTests.cpp
@@ -249,19 +249,19 @@ TEST_F(ConfigCompileTests, DiagnosticsIncludeCleaner) {
   // Defaults to None.
   EXPECT_TRUE(compileAndApply());
   EXPECT_EQ(Conf.Diagnostics.UnusedIncludes,
-            Config::UnusedIncludesPolicy::None);
+            Config::IncludesPolicy::None);

   Frag = {};
   Frag.Diagnostics.UnusedIncludes.emplace("None");
   EXPECT_TRUE(compileAndApply());
   EXPECT_EQ(Conf.Diagnostics.UnusedIncludes,
-            Config::UnusedIncludesPolicy::None);
+            Config::IncludesPolicy::None);

   Frag = {};
   Frag.Diagnostics.UnusedIncludes.emplace("Strict");
   EXPECT_TRUE(compileAndApply());
   EXPECT_EQ(Conf.Diagnostics.UnusedIncludes,
-            Config::UnusedIncludesPolicy::Strict);
+            Config::IncludesPolicy::Strict);

   Frag = {};
   EXPECT_TRUE(Conf.Diagnostics.Includes.IgnoreHeader.empty())
diff --git a/clang-tools-extra/clangd/unittests/DiagnosticsTests.cpp b/clang-tools-extra/clangd/unittests/DiagnosticsTests.cpp
index 610a290f834a..45bd8ba9f5b6 100644
--- a/clang-tools-extra/clangd/unittests/DiagnosticsTests.cpp
+++ b/clang-tools-extra/clangd/unittests/DiagnosticsTests.cpp
@@ -1897,7 +1897,7 @@ $fix[[  $diag[[#include "unused.h"]]
   // Off by default.
   EXPECT_THAT(*TU.build().getDiagnostics(), IsEmpty());
   Config Cfg;
-  Cfg.Diagnostics.UnusedIncludes = Config::UnusedIncludesPolicy::Strict;
+  Cfg.Diagnostics.UnusedIncludes = Config::IncludesPolicy::Strict;
   // Set filtering.
   Cfg.Diagnostics.Includes.IgnoreHeader.emplace_back(
       [](llvm::StringRef Header) { return Header.endswith("ignore.h"); });
diff --git a/clang-tools-extra/docs/ReleaseNotes.rst b/clang-tools-extra/docs/ReleaseNotes.rst
index 434dcd955679..ddb64014ef78 100644
--- a/clang-tools-extra/docs/ReleaseNotes.rst
+++ b/clang-tools-extra/docs/ReleaseNotes.rst
@@ -141,6 +141,11 @@ New checks
   Warns when `empty()` is used on a range and the result is ignored. Suggests `clear()`
   if it is an existing member function.

+- New :doc:`misc-include-cleaner
+  <clang-tidy/checks/misc/include-cleaner>` check.
+
+  Checks for unused and missing includes.
+
 New check aliases
 ^^^^^^^^^^^^^^^^^

diff --git a/clang-tools-extra/docs/clang-tidy/checks/list.rst b/clang-tools-extra/docs/clang-tidy/checks/list.rst
index ec59eb87ad13..7500d2ee07c6 100644
--- a/clang-tools-extra/docs/clang-tidy/checks/list.rst
+++ b/clang-tools-extra/docs/clang-tidy/checks/list.rst
@@ -246,6 +246,7 @@ Clang-Tidy Checks
    `misc-confusable-identifiers <misc/confusable-identifiers.html>`_,
    `misc-const-correctness <misc/const-correctness.html>`_, "Yes"
    `misc-definitions-in-headers <misc/definitions-in-headers.html>`_, "Yes"
+   `misc-include-cleaner <misc/include-cleaner.html>`_, "Yes"
    `misc-misleading-bidirectional <misc/misleading-bidirectional.html>`_,
    `misc-misleading-identifier <misc/misleading-identifier.html>`_,
    `misc-misplaced-const <misc/misplaced-const.html>`_,
diff --git a/clang-tools-extra/docs/clang-tidy/checks/misc/include-cleaner.rst b/clang-tools-extra/docs/clang-tidy/checks/misc/include-cleaner.rst
new file mode 100644
index 000000000000..5c34df2563ff
--- /dev/null
+++ b/clang-tools-extra/docs/clang-tidy/checks/misc/include-cleaner.rst
@@ -0,0 +1,34 @@
+.. title:: clang-tidy - misc-include-cleaner
+
+misc-include-cleaner
+====================
+
+Checks for unused and missing includes. Generates findings only for
+the main file of a translation unit.
+Findings correspond to https://clangd.llvm.org/design/include-cleaner.
+
+Example:
+
+.. code-block:: c++
+   // foo.h
+   class Foo{};
+   // bar.h
+   #include "baz.h"
+   class Bar{};
+   // baz.h
+   class Baz{};
+   // main.cc
+   #include "bar.h" // OK: uses class Bar from bar.h
+   #include "foo.h" // warning: unused include "foo.h"
+   Bar bar;
+   Baz baz; // warning: missing include "baz.h"
+
+Options
+-------
+
+.. option:: IgnoreHeaders
+
+   A semicolon-separated list of regexes to disable insertion/removal of header
+   files that match this regex as a suffix.  E.g., `foo/.*` disables
+   insertion/removal for all headers under the directory `foo`. By default, no
+   headers will be ignored.
diff --git a/clang-tools-extra/include-cleaner/include/clang-include-cleaner/Analysis.h b/clang-tools-extra/include-cleaner/include/clang-include-cleaner/Analysis.h
index f6afaff09cfd..0365a7a5be1e 100644
--- a/clang-tools-extra/include-cleaner/include/clang-include-cleaner/Analysis.h
+++ b/clang-tools-extra/include-cleaner/include/clang-include-cleaner/Analysis.h
@@ -73,6 +73,9 @@ AnalysisResults analyze(llvm::ArrayRef<Decl *> ASTRoots,
 std::string fixIncludes(const AnalysisResults &Results, llvm::StringRef Code,
                         const format::FormatStyle &IncludeStyle);

+
+std::string spellHeader(const Header &H, HeaderSearch &HS,
+                        const FileEntry *Main);
 } // namespace include_cleaner
 } // namespace clang

diff --git a/clang-tools-extra/include-cleaner/include/clang-include-cleaner/Record.h b/clang-tools-extra/include-cleaner/include/clang-include-cleaner/Record.h
index 140713bf1280..0cbfe4b8f157 100644
--- a/clang-tools-extra/include-cleaner/include/clang-include-cleaner/Record.h
+++ b/clang-tools-extra/include-cleaner/include/clang-include-cleaner/Record.h
@@ -18,6 +18,7 @@
 #define CLANG_INCLUDE_CLEANER_RECORD_H

 #include "clang-include-cleaner/Types.h"
+#include "clang/Basic/SourceLocation.h"
 #include "llvm/ADT/DenseMap.h"
 #include "llvm/ADT/DenseSet.h"
 #include "llvm/ADT/SmallVector.h"
@@ -52,6 +53,10 @@ public:
   /// to the structure.
   void record(const CompilerInstance &CI);

+  /// Installs an analysing PPCallback and CommentHandler and populates results
+  /// to the structure.
+  void record(Preprocessor &P);
+
   /// Returns true if the given #include of the main-file should never be
   /// removed.
   bool shouldKeep(unsigned HashLineNumber) const {
diff --git a/clang-tools-extra/include-cleaner/lib/Analysis.cpp b/clang-tools-extra/include-cleaner/lib/Analysis.cpp
index c5559db57e14..6237bdb46bab 100644
--- a/clang-tools-extra/include-cleaner/lib/Analysis.cpp
+++ b/clang-tools-extra/include-cleaner/lib/Analysis.cpp
@@ -49,8 +49,8 @@ void walkUsed(llvm::ArrayRef<Decl *> ASTRoots,
   }
 }

-static std::string spellHeader(const Header &H, HeaderSearch &HS,
-                               const FileEntry *Main) {
+std::string spellHeader(const Header &H, HeaderSearch &HS,
+                        const FileEntry *Main) {
   switch (H.kind()) {
   case Header::Physical: {
     bool IsSystem = false;
diff --git a/clang-tools-extra/include-cleaner/lib/Record.cpp b/clang-tools-extra/include-cleaner/lib/Record.cpp
index 51fd39300d7c..089d7ea749ca 100644
--- a/clang-tools-extra/include-cleaner/lib/Record.cpp
+++ b/clang-tools-extra/include-cleaner/lib/Record.cpp
@@ -19,6 +19,8 @@
 #include "clang/Lex/Preprocessor.h"
 #include "clang/Tooling/Inclusions/HeaderAnalysis.h"
 #include "clang/Tooling/Inclusions/StandardLibrary.h"
+#include <memory>
+#include <utility>

 namespace clang::include_cleaner {
 namespace {
@@ -148,8 +150,9 @@ private:
 class PragmaIncludes::RecordPragma : public PPCallbacks, public CommentHandler {
 public:
   RecordPragma(const CompilerInstance &CI, PragmaIncludes *Out)
-      : SM(CI.getSourceManager()),
-        HeaderInfo(CI.getPreprocessor().getHeaderSearchInfo()), Out(Out),
+      : RecordPragma(CI.getPreprocessor(), Out) {}
+  RecordPragma(const Preprocessor &P, PragmaIncludes *Out)
+      : SM(P.getSourceManager()), HeaderInfo(P.getHeaderSearchInfo()), Out(Out),
         UniqueStrings(Arena) {}

   void FileChanged(SourceLocation Loc, FileChangeReason Reason,
@@ -342,6 +345,12 @@ void PragmaIncludes::record(const CompilerInstance &CI) {
   CI.getPreprocessor().addPPCallbacks(std::move(Record));
 }

+void PragmaIncludes::record(Preprocessor &P) {
+  auto Record = std::make_unique<RecordPragma>(P, this);
+  P.addCommentHandler(Record.get());
+  P.addPPCallbacks(std::move(Record));
+}
+
 llvm::StringRef PragmaIncludes::getPublic(const FileEntry *F) const {
   auto It = IWYUPublic.find(F->getUniqueID());
   if (It == IWYUPublic.end())
@@ -350,8 +359,8 @@ llvm::StringRef PragmaIncludes::getPublic(const FileEntry *F) const {
 }

 static llvm::SmallVector<const FileEntry *>
-toFileEntries(llvm::ArrayRef<StringRef> FileNames, FileManager& FM) {
-    llvm::SmallVector<const FileEntry *> Results;
+toFileEntries(llvm::ArrayRef<StringRef> FileNames, FileManager &FM) {
+  llvm::SmallVector<const FileEntry *> Results;

   for (auto FName : FileNames) {
     // FIMXE: log the failing cases?
