From 55e4e8614971b745551a99a7f04c72634ceeef69 Mon Sep 17 00:00:00 2001
From: Arthur Eubanks <aeubanks@google.com>
Date: Tue, 1 Nov 2022 11:37:10 -0700
Subject: [PATCH] [GlobalOpt] Don't remove inalloca from varargs functions

Varargs and inalloca have a weird interaction where varargs are actually
passed via the inalloca alloca. Removing inalloca breaks the varargs
because they're still not passed as separate arguments.

Fixes #58718

Reviewed By: rnk

Differential Revision: https://reviews.llvm.org/D137182
---
 llvm/lib/Transforms/IPO/GlobalOpt.cpp         |  2 +-
 .../Transforms/GlobalOpt/inalloca-varargs.ll  | 38 +++++++++++++++++++
 2 files changed, 39 insertions(+), 1 deletion(-)
 create mode 100644 llvm/test/Transforms/GlobalOpt/inalloca-varargs.ll

diff --git a/llvm/lib/Transforms/IPO/GlobalOpt.cpp b/llvm/lib/Transforms/IPO/GlobalOpt.cpp
index 6df0409256bb..6fc7b29c5b78 100644
--- a/llvm/lib/Transforms/IPO/GlobalOpt.cpp
+++ b/llvm/lib/Transforms/IPO/GlobalOpt.cpp
@@ -2003,7 +2003,7 @@ OptimizeFunctions(Module &M,
     // FIXME: We should also hoist alloca affected by this to the entry
     // block if possible.
     if (F.getAttributes().hasAttrSomewhere(Attribute::InAlloca) &&
-        !F.hasAddressTaken() && !hasMustTailCallers(&F)) {
+        !F.hasAddressTaken() && !hasMustTailCallers(&F) && !F.isVarArg()) {
       RemoveAttribute(&F, Attribute::InAlloca);
       Changed = true;
     }
diff --git a/llvm/test/Transforms/GlobalOpt/inalloca-varargs.ll b/llvm/test/Transforms/GlobalOpt/inalloca-varargs.ll
new file mode 100644
index 000000000000..188210782edd
--- /dev/null
+++ b/llvm/test/Transforms/GlobalOpt/inalloca-varargs.ll
@@ -0,0 +1,38 @@
+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature
+; RUN: opt -passes=globalopt -S < %s | FileCheck %s
+
+define i32 @main(ptr %a) {
+; CHECK-LABEL: define {{[^@]+}}@main
+; CHECK-SAME: (ptr [[A:%.*]]) local_unnamed_addr {
+; CHECK-NEXT:    [[ARGMEM:%.*]] = alloca inalloca <{ ptr, i32 }>, align 4
+; CHECK-NEXT:    store ptr [[A]], ptr [[ARGMEM]], align 8
+; CHECK-NEXT:    [[G0:%.*]] = getelementptr inbounds <{ ptr, i32 }>, ptr [[ARGMEM]], i32 0, i32 1
+; CHECK-NEXT:    store i32 5, ptr [[G0]], align 4
+; CHECK-NEXT:    [[CALL3:%.*]] = call i32 (ptr, ...) @i(ptr inalloca(ptr) [[ARGMEM]])
+; CHECK-NEXT:    ret i32 [[CALL3]]
+;
+  %argmem = alloca inalloca <{ ptr, i32 }>, align 4
+  store ptr %a, ptr %argmem, align 8
+  %g0 = getelementptr inbounds <{ ptr, i32 }>, ptr %argmem, i32 0, i32 1
+  store i32 5, ptr %g0, align 4
+  %call3 = call i32 (ptr, ...) @i(ptr inalloca(ptr) %argmem)
+  ret i32 %call3
+}
+
+define internal i32 @i(ptr inalloca(ptr) %a, ...) {
+; CHECK-LABEL: define {{[^@]+}}@i
+; CHECK-SAME: (ptr inalloca(ptr) [[A:%.*]], ...) unnamed_addr {
+; CHECK-NEXT:    [[AP:%.*]] = alloca ptr, align 4
+; CHECK-NEXT:    call void @llvm.va_start(ptr [[AP]])
+; CHECK-NEXT:    [[ARGP_CUR:%.*]] = load ptr, ptr [[AP]], align 4
+; CHECK-NEXT:    [[L:%.*]] = load i32, ptr [[ARGP_CUR]], align 4
+; CHECK-NEXT:    ret i32 [[L]]
+;
+  %ap = alloca ptr, align 4
+  call void @llvm.va_start(ptr %ap)
+  %argp.cur = load ptr, ptr %ap, align 4
+  %l = load i32, ptr %argp.cur, align 4
+  ret i32 %l
+}
+
+declare void @llvm.va_start(ptr)
-- 
2.38.1.1.g6d9df9d320

