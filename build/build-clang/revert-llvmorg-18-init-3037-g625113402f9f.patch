From 482cbe8016544c18ef781504b9feea281da887fd Mon Sep 17 00:00:00 2001
From: Mike Hommey <mh@glandium.org>
Date: Tue, 12 Sep 2023 15:00:11 +0900
Subject: [PATCH] Revert "[IR] Remove support for and/or constant expressions"

This reverts commit 625113402f9febd4d8c907a342ea09a3c0982ba8 because it
breaks reading LLVM IR from rust during cross-language LTO.
---
 llvm/bindings/ocaml/llvm/llvm.ml              |  2 ++
 llvm/bindings/ocaml/llvm/llvm.mli             | 10 +++++++
 llvm/bindings/ocaml/llvm/llvm_ocaml.c         | 12 ++++++++
 llvm/docs/LangRef.rst                         |  4 +++
 llvm/docs/ReleaseNotes.rst                    | 12 --------
 llvm/include/llvm-c/Core.h                    |  2 ++
 llvm/include/llvm/IR/Constants.h              |  2 ++
 llvm/lib/Analysis/ConstantFolding.cpp         | 13 +++++++++
 llvm/lib/AsmParser/LLParser.cpp               |  6 ++--
 llvm/lib/IR/ConstantFold.cpp                  | 29 +++++++++++++++++++
 llvm/lib/IR/Constants.cpp                     | 12 ++++++--
 llvm/lib/IR/Core.cpp                          | 10 +++++++
 .../2004-03-07-FunctionAddressAlignment.ll    | 16 ++++++++++
 llvm/test/Assembler/ConstantExprFold.ll       |  8 +++++
 llvm/test/Bindings/OCaml/core.ml              |  4 +++
 .../InstCombine/constant-fold-alias.ll        | 26 ++++++++++-------
 .../Transforms/InstCombine/select-and-or.ll   |  8 ++---
 .../InstSimplify/ConstProp/constant-expr.ll   | 20 +++++++++++++
 llvm/unittests/IR/ConstantsTest.cpp           | 11 +++----
 19 files changed, 170 insertions(+), 37 deletions(-)
 create mode 100644 llvm/test/Assembler/2004-03-07-FunctionAddressAlignment.ll

diff --git a/llvm/bindings/ocaml/llvm/llvm.ml b/llvm/bindings/ocaml/llvm/llvm.ml
index a768d10d5d4d..77de9a6e46fa 100644
--- a/llvm/bindings/ocaml/llvm/llvm.ml
+++ b/llvm/bindings/ocaml/llvm/llvm.ml
@@ -648,6 +648,8 @@ external const_nuw_sub : llvalue -> llvalue -> llvalue = "llvm_const_nuw_sub"
 external const_mul : llvalue -> llvalue -> llvalue = "llvm_const_mul"
 external const_nsw_mul : llvalue -> llvalue -> llvalue = "llvm_const_nsw_mul"
 external const_nuw_mul : llvalue -> llvalue -> llvalue = "llvm_const_nuw_mul"
+external const_and : llvalue -> llvalue -> llvalue = "llvm_const_and"
+external const_or : llvalue -> llvalue -> llvalue = "llvm_const_or"
 external const_xor : llvalue -> llvalue -> llvalue = "llvm_const_xor"
 external const_icmp : Icmp.t -> llvalue -> llvalue -> llvalue
                     = "llvm_const_icmp"
diff --git a/llvm/bindings/ocaml/llvm/llvm.mli b/llvm/bindings/ocaml/llvm/llvm.mli
index 4ec760a44571..9c8b3b883e14 100644
--- a/llvm/bindings/ocaml/llvm/llvm.mli
+++ b/llvm/bindings/ocaml/llvm/llvm.mli
@@ -1125,6 +1125,16 @@ val const_nsw_mul : llvalue -> llvalue -> llvalue
     See the method [llvm::ConstantExpr::getNSWMul]. *)
 val const_nuw_mul : llvalue -> llvalue -> llvalue
 
+(** [const_and c1 c2] returns the constant bitwise [AND] of two integer
+    constants.
+    See the method [llvm::ConstantExpr::getAnd]. *)
+val const_and : llvalue -> llvalue -> llvalue
+
+(** [const_or c1 c2] returns the constant bitwise [OR] of two integer
+    constants.
+    See the method [llvm::ConstantExpr::getOr]. *)
+val const_or : llvalue -> llvalue -> llvalue
+
 (** [const_xor c1 c2] returns the constant bitwise [XOR] of two integer
     constants.
     See the method [llvm::ConstantExpr::getXor]. *)
diff --git a/llvm/bindings/ocaml/llvm/llvm_ocaml.c b/llvm/bindings/ocaml/llvm/llvm_ocaml.c
index f0e47a31af03..0154b2f49c25 100644
--- a/llvm/bindings/ocaml/llvm/llvm_ocaml.c
+++ b/llvm/bindings/ocaml/llvm/llvm_ocaml.c
@@ -1209,6 +1209,18 @@ value llvm_const_nuw_mul(value LHS, value RHS) {
   return to_val(Value);
 }
 
+/* llvalue -> llvalue -> llvalue */
+value llvm_const_and(value LHS, value RHS) {
+  LLVMValueRef Value = LLVMConstAnd(Value_val(LHS), Value_val(RHS));
+  return to_val(Value);
+}
+
+/* llvalue -> llvalue -> llvalue */
+value llvm_const_or(value LHS, value RHS) {
+  LLVMValueRef Value = LLVMConstOr(Value_val(LHS), Value_val(RHS));
+  return to_val(Value);
+}
+
 /* llvalue -> llvalue -> llvalue */
 value llvm_const_xor(value LHS, value RHS) {
   LLVMValueRef Value = LLVMConstXor(Value_val(LHS), Value_val(RHS));
diff --git a/llvm/docs/LangRef.rst b/llvm/docs/LangRef.rst
index dc5c84de420d..9fd672fde82b 100644
--- a/llvm/docs/LangRef.rst
+++ b/llvm/docs/LangRef.rst
@@ -4638,6 +4638,10 @@ The following is the syntax for constant expressions:
     Perform a logical right shift on constants.
 ``ashr (LHS, RHS)``
     Perform an arithmetic right shift on constants.
+``and (LHS, RHS)``
+    Perform a bitwise and on constants.
+``or (LHS, RHS)``
+    Perform a bitwise or on constants.
 ``xor (LHS, RHS)``
     Perform a bitwise xor on constants.
 
diff --git a/llvm/docs/ReleaseNotes.rst b/llvm/docs/ReleaseNotes.rst
index 533c93e62e5e..3a76959ca564 100644
--- a/llvm/docs/ReleaseNotes.rst
+++ b/llvm/docs/ReleaseNotes.rst
@@ -52,11 +52,6 @@ Changes to the LLVM IR
 
 * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use
   an overloaded pointer type to support non-0 address spaces.
-* The constant expression variants of the following instructions have been
-  removed:
-
-  * ``and``
-  * ``or``
 
 * Added `llvm.exp10` intrinsic.
 
@@ -135,13 +130,6 @@ Changes to the C API
 * Added ``LLVMGetTailCallKind`` and ``LLVMSetTailCallKind`` to
   allow getting and setting ``tail``, ``musttail``, and ``notail``
   attributes on call instructions.
-* The following functions for creating constant expressions have been removed,
-  because the underlying constant expressions are no longer supported. Instead,
-  an instruction should be created using the ``LLVMBuildXYZ`` APIs, which will
-  constant fold the operands if possible and create an instruction otherwise:
-
-  * ``LLVMConstAnd``
-  * ``LLVMConstOr``
 
 Changes to the CodeGen infrastructure
 -------------------------------------
diff --git a/llvm/include/llvm-c/Core.h b/llvm/include/llvm-c/Core.h
index 7ee46cac4304..35c58caee786 100644
--- a/llvm/include/llvm-c/Core.h
+++ b/llvm/include/llvm-c/Core.h
@@ -2276,6 +2276,8 @@ LLVMValueRef LLVMConstNUWSub(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
 LLVMValueRef LLVMConstMul(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
 LLVMValueRef LLVMConstNSWMul(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
 LLVMValueRef LLVMConstNUWMul(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
+LLVMValueRef LLVMConstAnd(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
+LLVMValueRef LLVMConstOr(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
 LLVMValueRef LLVMConstXor(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
 LLVMValueRef LLVMConstICmp(LLVMIntPredicate Predicate,
                            LLVMValueRef LHSConstant, LLVMValueRef RHSConstant);
diff --git a/llvm/include/llvm/IR/Constants.h b/llvm/include/llvm/IR/Constants.h
index 710a9142d5f7..94940c816179 100644
--- a/llvm/include/llvm/IR/Constants.h
+++ b/llvm/include/llvm/IR/Constants.h
@@ -1035,6 +1035,8 @@ public:
                           bool HasNSW = false);
   static Constant *getMul(Constant *C1, Constant *C2, bool HasNUW = false,
                           bool HasNSW = false);
+  static Constant *getAnd(Constant *C1, Constant *C2);
+  static Constant *getOr(Constant *C1, Constant *C2);
   static Constant *getXor(Constant *C1, Constant *C2);
   static Constant *getShl(Constant *C1, Constant *C2, bool HasNUW = false,
                           bool HasNSW = false);
diff --git a/llvm/lib/Analysis/ConstantFolding.cpp b/llvm/lib/Analysis/ConstantFolding.cpp
index ac846ce42c70..2f3a6d4e06ed 100644
--- a/llvm/lib/Analysis/ConstantFolding.cpp
+++ b/llvm/lib/Analysis/ConstantFolding.cpp
@@ -1257,6 +1257,19 @@ Constant *llvm::ConstantFoldCompareInstOperands(
       }
     }
 
+    // icmp eq (or x, y), 0 -> (icmp eq x, 0) & (icmp eq y, 0)
+    // icmp ne (or x, y), 0 -> (icmp ne x, 0) | (icmp ne y, 0)
+    if ((Predicate == ICmpInst::ICMP_EQ || Predicate == ICmpInst::ICMP_NE) &&
+        CE0->getOpcode() == Instruction::Or && Ops1->isNullValue()) {
+      Constant *LHS = ConstantFoldCompareInstOperands(
+          Predicate, CE0->getOperand(0), Ops1, DL, TLI);
+      Constant *RHS = ConstantFoldCompareInstOperands(
+          Predicate, CE0->getOperand(1), Ops1, DL, TLI);
+      unsigned OpC =
+        Predicate == ICmpInst::ICMP_EQ ? Instruction::And : Instruction::Or;
+      return ConstantFoldBinaryOpOperands(OpC, LHS, RHS, DL);
+    }
+
     // Convert pointer comparison (base+offset1) pred (base+offset2) into
     // offset1 pred offset2, for the case where the offset is inbounds. This
     // only works for equality and unsigned comparison, as inbounds permits
diff --git a/llvm/lib/AsmParser/LLParser.cpp b/llvm/lib/AsmParser/LLParser.cpp
index f1f0cdf746ee..38c541663c42 100644
--- a/llvm/lib/AsmParser/LLParser.cpp
+++ b/llvm/lib/AsmParser/LLParser.cpp
@@ -3856,10 +3856,6 @@ bool LLParser::parseValID(ValID &ID, PerFunctionState *PFS, Type *ExpectedTy) {
     return error(ID.Loc, "fdiv constexprs are no longer supported");
   case lltok::kw_frem:
     return error(ID.Loc, "frem constexprs are no longer supported");
-  case lltok::kw_and:
-    return error(ID.Loc, "and constexprs are no longer supported");
-  case lltok::kw_or:
-    return error(ID.Loc, "or constexprs are no longer supported");
   case lltok::kw_fneg:
     return error(ID.Loc, "fneg constexprs are no longer supported");
   case lltok::kw_select:
@@ -3968,6 +3964,8 @@ bool LLParser::parseValID(ValID &ID, PerFunctionState *PFS, Type *ExpectedTy) {
   }
 
   // Logical Operations
+  case lltok::kw_and:
+  case lltok::kw_or:
   case lltok::kw_xor: {
     unsigned Opc = Lex.getUIntVal();
     Constant *Val0, *Val1;
diff --git a/llvm/lib/IR/ConstantFold.cpp b/llvm/lib/IR/ConstantFold.cpp
index f9644079f2d2..04e4217beb08 100644
--- a/llvm/lib/IR/ConstantFold.cpp
+++ b/llvm/lib/IR/ConstantFold.cpp
@@ -213,6 +213,35 @@ static Constant *ExtractConstantBytes(Constant *C, unsigned ByteStart,
 
   switch (CE->getOpcode()) {
   default: return nullptr;
+  case Instruction::Or: {
+    Constant *RHS = ExtractConstantBytes(CE->getOperand(1), ByteStart,ByteSize);
+    if (!RHS)
+      return nullptr;
+
+    // X | -1 -> -1.
+    if (ConstantInt *RHSC = dyn_cast<ConstantInt>(RHS))
+      if (RHSC->isMinusOne())
+        return RHSC;
+
+    Constant *LHS = ExtractConstantBytes(CE->getOperand(0), ByteStart,ByteSize);
+    if (!LHS)
+      return nullptr;
+    return ConstantExpr::getOr(LHS, RHS);
+  }
+  case Instruction::And: {
+    Constant *RHS = ExtractConstantBytes(CE->getOperand(1), ByteStart,ByteSize);
+    if (!RHS)
+      return nullptr;
+
+    // X & 0 -> 0.
+    if (RHS->isNullValue())
+      return RHS;
+
+    Constant *LHS = ExtractConstantBytes(CE->getOperand(0), ByteStart,ByteSize);
+    if (!LHS)
+      return nullptr;
+    return ConstantExpr::getAnd(LHS, RHS);
+  }
   case Instruction::LShr: {
     ConstantInt *Amt = dyn_cast<ConstantInt>(CE->getOperand(1));
     if (!Amt)
diff --git a/llvm/lib/IR/Constants.cpp b/llvm/lib/IR/Constants.cpp
index 6589bd33be76..c9b94ba647c7 100644
--- a/llvm/lib/IR/Constants.cpp
+++ b/llvm/lib/IR/Constants.cpp
@@ -2315,8 +2315,6 @@ bool ConstantExpr::isSupportedBinOp(unsigned Opcode) {
   case Instruction::FMul:
   case Instruction::FDiv:
   case Instruction::FRem:
-  case Instruction::And:
-  case Instruction::Or:
     return false;
   case Instruction::Add:
   case Instruction::Sub:
@@ -2324,6 +2322,8 @@ bool ConstantExpr::isSupportedBinOp(unsigned Opcode) {
   case Instruction::Shl:
   case Instruction::LShr:
   case Instruction::AShr:
+  case Instruction::And:
+  case Instruction::Or:
   case Instruction::Xor:
     return true;
   default:
@@ -2584,6 +2584,14 @@ Constant *ConstantExpr::getMul(Constant *C1, Constant *C2,
   return get(Instruction::Mul, C1, C2, Flags);
 }
 
+Constant *ConstantExpr::getAnd(Constant *C1, Constant *C2) {
+  return get(Instruction::And, C1, C2);
+}
+
+Constant *ConstantExpr::getOr(Constant *C1, Constant *C2) {
+  return get(Instruction::Or, C1, C2);
+}
+
 Constant *ConstantExpr::getXor(Constant *C1, Constant *C2) {
   return get(Instruction::Xor, C1, C2);
 }
diff --git a/llvm/lib/IR/Core.cpp b/llvm/lib/IR/Core.cpp
index 17093fa0ac4e..207d57ecc8b2 100644
--- a/llvm/lib/IR/Core.cpp
+++ b/llvm/lib/IR/Core.cpp
@@ -1688,6 +1688,16 @@ LLVMValueRef LLVMConstNUWMul(LLVMValueRef LHSConstant,
                                       unwrap<Constant>(RHSConstant)));
 }
 
+LLVMValueRef LLVMConstAnd(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant) {
+  return wrap(ConstantExpr::getAnd(unwrap<Constant>(LHSConstant),
+                                   unwrap<Constant>(RHSConstant)));
+}
+
+LLVMValueRef LLVMConstOr(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant) {
+  return wrap(ConstantExpr::getOr(unwrap<Constant>(LHSConstant),
+                                  unwrap<Constant>(RHSConstant)));
+}
+
 LLVMValueRef LLVMConstXor(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant) {
   return wrap(ConstantExpr::getXor(unwrap<Constant>(LHSConstant),
                                    unwrap<Constant>(RHSConstant)));
diff --git a/llvm/test/Assembler/2004-03-07-FunctionAddressAlignment.ll b/llvm/test/Assembler/2004-03-07-FunctionAddressAlignment.ll
new file mode 100644
index 000000000000..5479500f3fd9
--- /dev/null
+++ b/llvm/test/Assembler/2004-03-07-FunctionAddressAlignment.ll
@@ -0,0 +1,16 @@
+; RUN: llvm-as < %s | llvm-dis | not grep ptrtoint
+; RUN: verify-uselistorder %s
+; All of these should be eliminable
+
+
+define i32 @foo() {
+	ret i32 and (i32 ptrtoint (ptr @foo to i32), i32 1)
+}
+
+define i32 @foo2() {
+	ret i32 and (i32 1, i32 ptrtoint (ptr @foo2 to i32))
+}
+
+define i1 @foo3() {
+	ret i1 icmp ne (ptr @foo3, ptr null)
+}
diff --git a/llvm/test/Assembler/ConstantExprFold.ll b/llvm/test/Assembler/ConstantExprFold.ll
index b7e4075ea9e1..4eb9cd01f33b 100644
--- a/llvm/test/Assembler/ConstantExprFold.ll
+++ b/llvm/test/Assembler/ConstantExprFold.ll
@@ -11,6 +11,9 @@
 @add = global ptr inttoptr (i64 add (i64 ptrtoint (ptr @A to i64), i64 0) to ptr) ; X + 0 == X
 @sub = global ptr inttoptr (i64 sub (i64 ptrtoint (ptr @A to i64), i64 0) to ptr) ; X - 0 == X
 @mul = global ptr inttoptr (i64 mul (i64 ptrtoint (ptr @A to i64), i64 0) to ptr) ; X * 0 == 0
+@and1 = global ptr inttoptr (i64 and (i64 ptrtoint (ptr @A to i64), i64 0) to ptr) ; X & 0 == 0
+@and2 = global ptr inttoptr (i64 and (i64 ptrtoint (ptr @A to i64), i64 -1) to ptr) ; X & -1 == X
+@or = global i64 or (i64 ptrtoint (ptr @A to i64), i64 -1)  ; X | -1 == -1
 @xor = global ptr inttoptr (i64 xor (i64 ptrtoint (ptr @A to i64), i64 0) to ptr) ; X ^ 0 == X
 
 %Ty = type { i32, i32 }
@@ -25,6 +28,7 @@
 
 ; PR2206
 @cons = weak global i32 0, align 8              ; <ptr> [#uses=1]
+@and3 = global i64 and (i64 ptrtoint (ptr @cons to i64), i64 7)
 
 @gep1 = global <2 x ptr> getelementptr(i8, <2 x ptr> undef, <2 x i64> <i64 1, i64 1>)
 @gep2 = global <2 x ptr> getelementptr({ i8 }, <2 x ptr> undef, <2 x i64> <i64 1, i64 1>, <2 x i32> <i32 0, i32 0>)
@@ -38,12 +42,16 @@
 ; CHECK: @[[ADD:[a-zA-Z0-9_$"\\.-]+]] = global ptr @A
 ; CHECK: @[[SUB:[a-zA-Z0-9_$"\\.-]+]] = global ptr @A
 ; CHECK: @[[MUL:[a-zA-Z0-9_$"\\.-]+]] = global ptr null
+; CHECK: @[[AND1:[a-zA-Z0-9_$"\\.-]+]] = global ptr null
+; CHECK: @[[AND2:[a-zA-Z0-9_$"\\.-]+]] = global ptr @A
+; CHECK: @[[OR:[a-zA-Z0-9_$"\\.-]+]] = global i64 -1
 ; CHECK: @[[XOR:[a-zA-Z0-9_$"\\.-]+]] = global ptr @A
 ; CHECK: @[[B:[a-zA-Z0-9_$"\\.-]+]] = external global [[TY:%.*]]
 ; CHECK: @[[ICMP_ULT1:[a-zA-Z0-9_$"\\.-]+]] = global i1 icmp ugt (ptr getelementptr inbounds (i64, ptr @A, i64 1), ptr @A)
 ; CHECK: @[[ICMP_SLT:[a-zA-Z0-9_$"\\.-]+]] = global i1 false
 ; CHECK: @[[ICMP_ULT2:[a-zA-Z0-9_$"\\.-]+]] = global i1 icmp ugt (ptr getelementptr inbounds ([[TY:%.*]], ptr @B, i64 0, i32 1), ptr @B)
 ; CHECK: @[[CONS:[a-zA-Z0-9_$"\\.-]+]] = weak global i32 0, align 8
+; CHECK: @[[AND3:[a-zA-Z0-9_$"\\.-]+]] = global i64 0
 ; CHECK: @[[GEP1:[a-zA-Z0-9_$"\\.-]+]] = global <2 x ptr> undef
 ; CHECK: @[[GEP2:[a-zA-Z0-9_$"\\.-]+]] = global <2 x ptr> undef
 ; CHECK: @[[GEP3:[a-zA-Z0-9_$"\\.-]+]] = global <2 x ptr> zeroinitializer
diff --git a/llvm/test/Bindings/OCaml/core.ml b/llvm/test/Bindings/OCaml/core.ml
index 3a9c3c84238d..d2dd52c07608 100644
--- a/llvm/test/Bindings/OCaml/core.ml
+++ b/llvm/test/Bindings/OCaml/core.ml
@@ -263,6 +263,8 @@ let test_constants () =
    * CHECK: @const_mul = global i64 mul
    * CHECK: @const_nsw_mul = global i64 mul nsw
    * CHECK: @const_nuw_mul = global i64 mul nuw
+   * CHECK: @const_and = global i64 and
+   * CHECK: @const_or = global i64 or
    * CHECK: @const_xor = global i64 xor
    * CHECK: @const_icmp = global i1 icmp sle
    * CHECK: @const_fcmp = global i1 fcmp ole
@@ -286,6 +288,8 @@ let test_constants () =
   ignore (define_global "const_mul" (const_mul foldbomb five) m);
   ignore (define_global "const_nsw_mul" (const_nsw_mul foldbomb five) m);
   ignore (define_global "const_nuw_mul" (const_nuw_mul foldbomb five) m);
+  ignore (define_global "const_and" (const_and foldbomb five) m);
+  ignore (define_global "const_or" (const_or foldbomb five) m);
   ignore (define_global "const_xor" (const_xor foldbomb five) m);
   ignore (define_global "const_icmp" (const_icmp Icmp.Sle foldbomb five) m);
   ignore (define_global "const_fcmp" (const_fcmp Fcmp.Ole ffoldbomb ffive) m);
diff --git a/llvm/test/Transforms/InstCombine/constant-fold-alias.ll b/llvm/test/Transforms/InstCombine/constant-fold-alias.ll
index abca77ec2be7..4aee78e71ef6 100644
--- a/llvm/test/Transforms/InstCombine/constant-fold-alias.ll
+++ b/llvm/test/Transforms/InstCombine/constant-fold-alias.ll
@@ -8,15 +8,14 @@ target datalayout = "e-p1:16:16-p2:32:32-p3:64:64"
 @G3 = global [4 x i8] zeroinitializer, align 1
 
 @A1 = alias i32, getelementptr inbounds ([4 x i8], ptr @G3, i32 0, i32 2)
+@A2 = alias i32, inttoptr (i64 and (i64 ptrtoint (ptr getelementptr inbounds ([4 x i8], ptr @G3, i32 0, i32 3) to i64), i64 -4) to ptr)
 
 define i64 @f1() {
 ; This cannot be constant folded because G1 is underaligned.
 ; CHECK-LABEL: define i64 @f1() {
-; CHECK-NEXT:    [[AND:%.*]] = and i64 ptrtoint (ptr @G1 to i64), 1
-; CHECK-NEXT:    ret i64 [[AND]]
+; CHECK-NEXT:    ret i64 and (i64 ptrtoint (ptr @G1 to i64), i64 1)
 ;
-  %and = and i64 ptrtoint (ptr @G1 to i64), 1
-  ret i64 %and
+  ret i64 and (i64 ptrtoint (ptr @G1 to i64), i64 1)
 }
 
 define i64 @f2() {
@@ -24,16 +23,23 @@ define i64 @f2() {
 ; CHECK-LABEL: define i64 @f2() {
 ; CHECK-NEXT:    ret i64 0
 ;
-  %and = and i64 ptrtoint (ptr @G2 to i64), 1
-  ret i64 %and
+  ret i64 and (i64 ptrtoint (ptr @G2 to i64), i64 1)
 }
 
 define i64 @g1() {
 ; This cannot be constant folded because A1 aliases G3 which is underalaigned.
 ; CHECK-LABEL: define i64 @g1() {
-; CHECK-NEXT:    [[AND:%.*]] = and i64 ptrtoint (ptr @A1 to i64), 1
-; CHECK-NEXT:    ret i64 [[AND]]
+; CHECK-NEXT:    ret i64 and (i64 ptrtoint (ptr @A1 to i64), i64 1)
 ;
-  %and = and i64 ptrtoint (ptr @A1 to i64), 1
-  ret i64 %and
+  ret i64 and (i64 ptrtoint (ptr @A1 to i64), i64 1)
 }
+
+define i64 @g2() {
+; While A2 also aliases G3 which is underaligned, the math of A2 forces a
+; certain alignment allowing this to fold to zero.
+; CHECK-LABEL: define i64 @g2() {
+; CHECK-NEXT:    ret i64 0
+;
+  ret i64 and (i64 ptrtoint (ptr @A2 to i64), i64 1)
+}
+
diff --git a/llvm/test/Transforms/InstCombine/select-and-or.ll b/llvm/test/Transforms/InstCombine/select-and-or.ll
index fb78f0affcb8..daaf1005ac04 100644
--- a/llvm/test/Transforms/InstCombine/select-and-or.ll
+++ b/llvm/test/Transforms/InstCombine/select-and-or.ll
@@ -431,11 +431,11 @@ define i1 @not_false_not_use3(i1 %x, i1 %y) {
 define i1 @demorgan_select_infloop1(i1 %L) {
 ; CHECK-LABEL: @demorgan_select_infloop1(
 ; CHECK-NEXT:    [[NOT_L:%.*]] = xor i1 [[L:%.*]], true
-; CHECK-NEXT:    [[C15:%.*]] = select i1 [[NOT_L]], i1 xor (i1 icmp eq (ptr getelementptr inbounds (i16, ptr @g2, i64 1), ptr @g1), i1 icmp eq (ptr getelementptr inbounds (i16, ptr @g2, i64 1), ptr @g1)), i1 false
+; CHECK-NEXT:    [[C15:%.*]] = select i1 [[NOT_L]], i1 xor (i1 and (i1 icmp eq (ptr getelementptr inbounds (i16, ptr @g2, i64 1), ptr @g1), i1 icmp ne (ptr getelementptr inbounds (i16, ptr @g2, i64 1), ptr @g1)), i1 true), i1 false
 ; CHECK-NEXT:    ret i1 [[C15]]
 ;
   %not.L = xor i1 %L, true
-  %C15 = select i1 %not.L, i1 xor (i1 add (i1 icmp eq (ptr getelementptr inbounds (i16, ptr @g2, i64 1), ptr @g1), i1 icmp ne (ptr getelementptr inbounds (i16, ptr @g2, i64 1), ptr @g1)), i1 true), i1 false
+  %C15 = select i1 %not.L, i1 xor (i1 and (i1 icmp eq (ptr getelementptr inbounds (i16, ptr @g2, i64 1), ptr @g1), i1 icmp ne (ptr getelementptr inbounds (i16, ptr @g2, i64 1), ptr @g1)), i1 true), i1 false
   ret i1 %C15
 }
 
@@ -443,11 +443,11 @@ define i1 @demorgan_select_infloop1(i1 %L) {
 define i1 @demorgan_select_infloop2(i1 %L) {
 ; CHECK-LABEL: @demorgan_select_infloop2(
 ; CHECK-NEXT:    [[NOT_L:%.*]] = xor i1 [[L:%.*]], true
-; CHECK-NEXT:    [[C15:%.*]] = select i1 [[NOT_L]], i1 true, i1 xor (i1 icmp eq (ptr getelementptr inbounds (i16, ptr @g2, i64 1), ptr @g1), i1 icmp eq (ptr getelementptr inbounds (i16, ptr @g2, i64 1), ptr @g1))
+; CHECK-NEXT:    [[C15:%.*]] = select i1 [[NOT_L]], i1 true, i1 xor (i1 and (i1 icmp eq (ptr getelementptr inbounds (i16, ptr @g2, i64 1), ptr @g1), i1 icmp ne (ptr getelementptr inbounds (i16, ptr @g2, i64 1), ptr @g1)), i1 true)
 ; CHECK-NEXT:    ret i1 [[C15]]
 ;
   %not.L = xor i1 %L, true
-  %C15 = select i1 %not.L, i1 true, i1 xor (i1 add (i1 icmp eq (ptr getelementptr inbounds (i16, ptr @g2, i64 1), ptr @g1), i1 icmp ne (ptr getelementptr inbounds (i16, ptr @g2, i64 1), ptr @g1)), i1 true)
+  %C15 = select i1 %not.L, i1 true, i1 xor (i1 and (i1 icmp eq (ptr getelementptr inbounds (i16, ptr @g2, i64 1), ptr @g1), i1 icmp ne (ptr getelementptr inbounds (i16, ptr @g2, i64 1), ptr @g1)), i1 true)
   ret i1 %C15
 }
 
diff --git a/llvm/test/Transforms/InstSimplify/ConstProp/constant-expr.ll b/llvm/test/Transforms/InstSimplify/ConstProp/constant-expr.ll
index 7634a4a120f6..55ee7b3a6cad 100644
--- a/llvm/test/Transforms/InstSimplify/ConstProp/constant-expr.ll
+++ b/llvm/test/Transforms/InstSimplify/ConstProp/constant-expr.ll
@@ -31,6 +31,26 @@
 @O = global i1 icmp eq (i32 zext (i1 icmp ult (ptr @X, ptr @Y) to i32), i32 0)
 ; CHECK: @O = global i1 icmp uge (ptr @X, ptr @Y)
 
+
+
+; PR5176
+
+; CHECK: @T1 = global i1 true
+@T1 = global i1 icmp eq (i64 and (i64 trunc (i256 lshr (i256 or (i256 and (i256 and (i256 shl (i256 zext (i64 ptrtoint (ptr @B to i64) to i256), i256 64), i256 -6277101735386680763495507056286727952638980837032266301441), i256 6277101735386680763835789423207666416102355444464034512895), i256 shl (i256 zext (i64 ptrtoint (ptr @A to i64) to i256), i256 192)), i256 64) to i64), i64 1), i64 0)
+
+; CHECK: @T2 = global ptr @B
+@T2 = global ptr inttoptr (i64 add (i64 trunc (i256 lshr (i256 or (i256 and (i256 and (i256 shl (i256 zext (i64 ptrtoint (ptr @A to i64) to i256), i256 64), i256 -6277101735386680763495507056286727952638980837032266301441), i256 6277101735386680763835789423207666416102355444464034512895), i256 shl (i256 zext (i64 ptrtoint (ptr @B to i64) to i256), i256 192)), i256 192) to i64), i64 trunc (i256 lshr (i256 or (i256 and (i256 and (i256 shl (i256 zext (i64 ptrtoint (ptr @A to i64) to i256), i256 64), i256 -6277101735386680763495507056286727952638980837032266301441), i256 6277101735386680763835789423207666416102355444464034512895), i256 shl (i256 zext (i64 ptrtoint (ptr @B to i64) to i256), i256 192)), i256 128) to i64)) to ptr)
+
+; CHECK: @T3 = global i64 add (i64 ptrtoint (ptr @B to i64), i64 -1)
+@T3 = global i64 add (i64 trunc (i256 lshr (i256 or (i256 and (i256 and (i256 shl (i256 zext (i64 ptrtoint (ptr @B to i64) to i256), i256 64), i256 -6277101735386680763495507056286727952638980837032266301441), i256 6277101735386680763835789423207666416102355444464034512895), i256 shl (i256 zext (i64 ptrtoint (ptr @A to i64) to i256), i256 192)), i256 64) to i64), i64 -1)
+
+; CHECK: @T4 = global ptr @B
+@T4 = global ptr inttoptr (i64 trunc (i256 lshr (i256 or (i256 and (i256 and (i256 shl (i256 zext (i64 ptrtoint (ptr @B to i64) to i256), i256 64), i256 -6277101735386680763495507056286727952638980837032266301441), i256 6277101735386680763835789423207666416102355444464034512895), i256 shl (i256 zext (i64 ptrtoint (ptr @A to i64) to i256), i256 192)), i256 64) to i64) to ptr)
+
+; CHECK: @T5 = global ptr @A
+@T5 = global ptr inttoptr (i64 add (i64 trunc (i256 lshr (i256 or (i256 and (i256 and (i256 shl (i256 zext (i64 ptrtoint (ptr @B to i64) to i256), i256 64), i256 -6277101735386680763495507056286727952638980837032266301441), i256 6277101735386680763835789423207666416102355444464034512895), i256 shl (i256 zext (i64 ptrtoint (ptr @A to i64) to i256), i256 192)), i256 192) to i64), i64 trunc (i256 lshr (i256 or (i256 and (i256 and (i256 shl (i256 zext (i64 ptrtoint (ptr @B to i64) to i256), i256 64), i256 -6277101735386680763495507056286727952638980837032266301441), i256 6277101735386680763835789423207666416102355444464034512895), i256 shl (i256 zext (i64 ptrtoint (ptr @A to i64) to i256), i256 192)), i256 128) to i64)) to ptr)
+
+
 ; PR9011
 
 @pr9011_1 = constant <4 x i32> zext (<4 x i8> zeroinitializer to <4 x i32>)
diff --git a/llvm/unittests/IR/ConstantsTest.cpp b/llvm/unittests/IR/ConstantsTest.cpp
index e905452f32b3..57a0a91086a1 100644
--- a/llvm/unittests/IR/ConstantsTest.cpp
+++ b/llvm/unittests/IR/ConstantsTest.cpp
@@ -241,6 +241,8 @@ TEST(ConstantsTest, AsInstructionsTest) {
         "add nuw nsw i32 " P0STR ", " P0STR);
   CHECK(ConstantExpr::getSub(P0, P0), "sub i32 " P0STR ", " P0STR);
   CHECK(ConstantExpr::getMul(P0, P0), "mul i32 " P0STR ", " P0STR);
+  CHECK(ConstantExpr::getAnd(P0, P0), "and i32 " P0STR ", " P0STR);
+  CHECK(ConstantExpr::getOr(P0, P0), "or i32 " P0STR ", " P0STR);
   CHECK(ConstantExpr::getXor(P0, P0), "xor i32 " P0STR ", " P0STR);
   CHECK(ConstantExpr::getShl(P0, P0), "shl i32 " P0STR ", " P0STR);
   CHECK(ConstantExpr::getShl(P0, P0, true), "shl nuw i32 " P0STR ", " P0STR);
@@ -492,9 +494,9 @@ bool foldFuncPtrAndConstToNull(LLVMContext &Context, Module *TheModule,
 
   Constant *TheConstantExpr(ConstantExpr::getPtrToInt(Func, ConstantIntType));
 
-  Constant *C = ConstantFoldBinaryInstruction(Instruction::And, TheConstantExpr,
-                                              TheConstant);
-  bool Result = C && C->isNullValue();
+  bool Result =
+      ConstantExpr::get(Instruction::And, TheConstantExpr, TheConstant)
+          ->isNullValue();
 
   if (!TheModule) {
     // If the Module exists then it will delete the Function.
@@ -580,8 +582,7 @@ TEST(ConstantsTest, FoldGlobalVariablePtr) {
 
   Constant *TheConstantExpr(ConstantExpr::getPtrToInt(Global.get(), IntType));
 
-  ASSERT_TRUE(ConstantFoldBinaryInstruction(Instruction::And, TheConstantExpr,
-                                            TheConstant)
+  ASSERT_TRUE(ConstantExpr::get(Instruction::And, TheConstantExpr, TheConstant)
                   ->isNullValue());
 }
 
-- 
2.41.0.3.g1cb8d410ac

