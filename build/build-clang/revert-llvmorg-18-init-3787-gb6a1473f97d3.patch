From 1d0e1aead2e8fe0456d00e7c9e9b5e7f5241692e Mon Sep 17 00:00:00 2001
From: Mike Hommey <mh@glandium.org>
Date: Wed, 30 Aug 2023 06:45:51 +0900
Subject: [PATCH] Revert "[driver] Refactor getRuntimePaths. NFC"

This reverts commit b6a1473f97d38471b08331dee7ae7f6112c495c0, which
conflicts with one of our changes. Followups to that commit are expected
to make our change unnecessary, but until then...
---
 clang/include/clang/Driver/ToolChain.h |  5 ++---
 clang/lib/Driver/Driver.cpp            | 12 ++++++++++--
 clang/lib/Driver/ToolChain.cpp         | 25 ++++++++++---------------
 3 files changed, 22 insertions(+), 20 deletions(-)

diff --git a/clang/include/clang/Driver/ToolChain.h b/clang/include/clang/Driver/ToolChain.h
index 0b38b939a188..2e74507f7126 100644
--- a/clang/include/clang/Driver/ToolChain.h
+++ b/clang/include/clang/Driver/ToolChain.h
@@ -29,7 +29,6 @@
 #include <cassert>
 #include <climits>
 #include <memory>
-#include <optional>
 #include <string>
 #include <utility>
 
@@ -501,8 +500,8 @@ public:
                                     StringRef Component,
                                     FileType Type = ToolChain::FT_Static) const;
 
-  // Returns the target specific runtime path if it exists.
-  std::optional<std::string> getRuntimePath() const;
+  // Returns target specific runtime paths.
+  path_list getRuntimePaths() const;
 
   // Returns target specific standard library paths.
   path_list getStdlibPaths() const;
diff --git a/clang/lib/Driver/Driver.cpp b/clang/lib/Driver/Driver.cpp
index 07c4561c990a..7b64ef4cc5db 100644
--- a/clang/lib/Driver/Driver.cpp
+++ b/clang/lib/Driver/Driver.cpp
@@ -2163,8 +2163,16 @@ bool Driver::HandleImmediateArgs(const Compilation &C) {
   }
 
   if (C.getArgs().hasArg(options::OPT_print_runtime_dir)) {
-    if (std::optional<std::string> RuntimePath = TC.getRuntimePath())
-      llvm::outs() << *RuntimePath << '\n';
+    std::string RuntimePath;
+    // Get the first existing path, if any.
+    for (auto Path : TC.getRuntimePaths()) {
+      if (getVFS().exists(Path)) {
+        RuntimePath = Path;
+        break;
+      }
+    }
+    if (!RuntimePath.empty())
+      llvm::outs() << RuntimePath << '\n';
     else
       llvm::outs() << TC.getCompilerRTPath() << '\n';
     return false;
diff --git a/clang/lib/Driver/ToolChain.cpp b/clang/lib/Driver/ToolChain.cpp
index f40cee195fa5..8dafc3d481c2 100644
--- a/clang/lib/Driver/ToolChain.cpp
+++ b/clang/lib/Driver/ToolChain.cpp
@@ -86,8 +86,8 @@ ToolChain::ToolChain(const Driver &D, const llvm::Triple &T,
       List.push_back(Path);
   };
 
-  if (std::optional<std::string> Path = getRuntimePath())
-    getLibraryPaths().push_back(*Path);
+  for (const auto &Path : getRuntimePaths())
+    addIfExists(getLibraryPaths(), Path);
   for (const auto &Path : getStdlibPaths())
     addIfExists(getFilePaths(), Path);
   for (const auto &Path : getArchSpecificLibPaths())
@@ -677,18 +677,15 @@ const char *ToolChain::getCompilerRTArgString(const llvm::opt::ArgList &Args,
   return Args.MakeArgString(getCompilerRT(Args, Component, Type));
 }
 
-std::optional<std::string> ToolChain::getRuntimePath() const {
-  auto getPathForTriple =
-      [this](const llvm::Triple &Triple) -> std::optional<std::string> {
+ToolChain::path_list ToolChain::getRuntimePaths() const {
+  path_list Paths;
+  auto addPathForTriple = [this, &Paths](const llvm::Triple &Triple) {
     SmallString<128> P(D.ResourceDir);
     llvm::sys::path::append(P, "lib", Triple.str());
-    if (getVFS().exists(P))
-      return std::string(P);
-    return {};
+    Paths.push_back(std::string(P.str()));
   };
 
-  if (auto Path = getPathForTriple(getTriple()))
-    return *Path;
+  addPathForTriple(getTriple());
 
   // When building with per target runtime directories, various ways of naming
   // the Arm architecture may have been normalised to simply "arm".
@@ -708,8 +705,7 @@ std::optional<std::string> ToolChain::getRuntimePath() const {
   if (getTriple().getArch() == Triple::arm && !getTriple().isArmMClass()) {
     llvm::Triple ArmTriple = getTriple();
     ArmTriple.setArch(Triple::arm);
-    if (auto Path = getPathForTriple(ArmTriple))
-      return *Path;
+    addPathForTriple(ArmTriple);
   }
 
   // Android targets may include an API level at the end. We still want to fall
@@ -718,11 +714,10 @@ std::optional<std::string> ToolChain::getRuntimePath() const {
       getTriple().getEnvironmentName() != "android") {
     llvm::Triple TripleWithoutLevel = getTriple();
     TripleWithoutLevel.setEnvironmentName("android");
-    if (auto Path = getPathForTriple(TripleWithoutLevel))
-      return *Path;
+    addPathForTriple(TripleWithoutLevel);
   }
 
-  return {};
+  return Paths;
 }
 
 ToolChain::path_list ToolChain::getStdlibPaths() const {
-- 
2.41.0.3.g1cb8d410ac

