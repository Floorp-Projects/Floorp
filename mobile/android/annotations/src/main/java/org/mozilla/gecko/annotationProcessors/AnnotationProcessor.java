/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package org.mozilla.gecko.annotationProcessors;

import org.mozilla.gecko.annotationProcessors.classloader.AnnotatableEntity;
import org.mozilla.gecko.annotationProcessors.classloader.ClassWithOptions;
import org.mozilla.gecko.annotationProcessors.classloader.IterableJarLoadingURLClassLoader;
import org.mozilla.gecko.annotationProcessors.utils.GeneratableElementIterator;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.util.Arrays;
import java.util.Iterator;

public class AnnotationProcessor {
    public static final String GENERATED_COMMENT =
            "// GENERATED CODE\n" +
            "// Generated by the Java program at /build/annotationProcessors at compile time\n" +
            "// from annotations on Java methods. To update, change the annotations on the\n" +
            "// corresponding Java methods and rerun the build. Manually updating this file\n" +
            "// will cause your build to fail.\n" +
            "\n";

    public static void main(String[] args) {
        // We expect a list of jars on the commandline. If missing, whinge about it.
        if (args.length < 2) {
            System.err.println("Usage: java AnnotationProcessor outprefix jarfiles ...");
            System.exit(1);
        }

        final String OUTPUT_PREFIX = args[0];

        System.out.println("Processing annotations...");

        // We want to produce the same output as last time as often as possible. Ordering of
        // generated statements, therefore, needs to be consistent.
        final String[] jars = Arrays.copyOfRange(args, 1, args.length);
        Arrays.sort(jars);

        // Start the clock!
        long s = System.currentTimeMillis();

        int ret = 0;

        final String unifiedHeaderFileName = OUTPUT_PREFIX + "JNIWrappers.h";
        final String unifiedNativesFileName = OUTPUT_PREFIX + "JNINatives.h";

        final StringBuilder unifiedHeaderFile = new StringBuilder(GENERATED_COMMENT);
        final StringBuilder unifiedNativesFile = new StringBuilder(GENERATED_COMMENT);

        // Get an iterator over the classes in the jar files given...
        Iterator<ClassWithOptions> jarClassIterator = IterableJarLoadingURLClassLoader.getIteratorOverJars(jars);

        while (jarClassIterator.hasNext()) {
            final ClassWithOptions annotatedClass = jarClassIterator.next();
            if (!annotatedClass.hasGenerated()) {
                continue;
            }

            final String sourceFileName = OUTPUT_PREFIX + annotatedClass.generatedName + "JNIWrappers.cpp";
            final String headerFileName = OUTPUT_PREFIX + annotatedClass.generatedName + "JNIWrappers.h";
            final String nativesFileName = OUTPUT_PREFIX + annotatedClass.generatedName + "JNINatives.h";

            unifiedHeaderFile.append("#include \"" + headerFileName + "\"\n"); // annotatedClass.generatedName + "JNIWrappers.h\"\n");
            unifiedNativesFile.append("#include \"" + nativesFileName + "\"\n"); // annotatedClass.generatedName + "JNINatives.h\"\n");

            final StringBuilder headerFile = new StringBuilder(GENERATED_COMMENT);
            final StringBuilder implementationFile = new StringBuilder(GENERATED_COMMENT);
            final StringBuilder nativesFile = new StringBuilder(GENERATED_COMMENT);

            headerFile.append(
                    "#ifndef " + getHeaderGuardName(headerFileName) + "\n" +
                    "#define " + getHeaderGuardName(headerFileName) + "\n" +
                    "\n" +
                    "#ifndef MOZ_PREPROCESSOR\n" +
                    "#include \"mozilla/jni/Refs.h\"\n" +
                    "#endif\n" +
                    "\n" +
                    "namespace mozilla {\n" +
                    "namespace java {\n" +
                    "\n");

            implementationFile.append(
                    "#ifndef MOZ_PREPROCESSOR\n" +
                    "#include \"" + headerFileName + "\"\n" +
                    "#include \"mozilla/jni/Accessors.h\"\n" +
                    "#endif\n" +
                    "\n" +
                    "namespace mozilla {\n" +
                    "namespace java {\n" +
                    "\n");

            nativesFile.append(
                    "#ifndef " + getHeaderGuardName(nativesFileName) + "\n" +
                    "#define " + getHeaderGuardName(nativesFileName) + "\n" +
                    "\n" +
                    "#ifndef MOZ_PREPROCESSOR\n" +
                    "#include \"" + headerFileName + "\"\n" +
                    "#include \"mozilla/jni/Natives.h\"\n" +
                    "#endif\n" +
                    "\n" +
                    "namespace mozilla {\n" +
                    "namespace java {\n" +
                    "\n");

            generateClass(annotatedClass, headerFile, implementationFile, nativesFile);

            implementationFile.append(
                    "} /* java */\n" +
                    "} /* mozilla */\n");

            headerFile.append(
                    "} /* java */\n" +
                    "} /* mozilla */\n" +
                    "#endif // " + getHeaderGuardName(headerFileName) + "\n");

            nativesFile.append(
                    "} /* java */\n" +
                    "} /* mozilla */\n" +
                    "#endif // " + getHeaderGuardName(nativesFileName) + "\n");

            ret |= writeOutputFile(sourceFileName, implementationFile);
            ret |= writeOutputFile(headerFileName, headerFile);
            ret |= writeOutputFile(nativesFileName, nativesFile);
        }

        ret |= writeOutputFile(unifiedHeaderFileName, unifiedHeaderFile);
        ret |= writeOutputFile(unifiedNativesFileName, unifiedNativesFile);

        long e = System.currentTimeMillis();
        System.out.println("Annotation processing complete in " + (e - s) + "ms");

        System.exit(ret);
    }

    private static void generateClass(final ClassWithOptions annotatedClass,
                                      final StringBuilder headerFile,
                                      final StringBuilder implementationFile,
                                      final StringBuilder nativesFile) {
        // Get an iterator over the appropriately generated methods of this class
        final GeneratableElementIterator methodIterator
                = new GeneratableElementIterator(annotatedClass);
        final ClassWithOptions[] innerClasses = methodIterator.getInnerClasses();

        final CodeGenerator generatorInstance = new CodeGenerator(annotatedClass);
        generatorInstance.generateClasses(innerClasses);

        // Iterate all annotated members in this class..
        while (methodIterator.hasNext()) {
            AnnotatableEntity aElementTuple = methodIterator.next();
            switch (aElementTuple.mEntityType) {
                case METHOD:
                    generatorInstance.generateMethod(aElementTuple);
                    break;
                case NATIVE:
                    generatorInstance.generateNative(aElementTuple);
                    break;
                case FIELD:
                    generatorInstance.generateField(aElementTuple);
                    break;
                case CONSTRUCTOR:
                    generatorInstance.generateConstructor(aElementTuple);
                    break;
            }
        }

        headerFile.append(generatorInstance.getHeaderFileContents());
        implementationFile.append(generatorInstance.getWrapperFileContents());
        nativesFile.append(generatorInstance.getNativesFileContents());

        for (ClassWithOptions innerClass : innerClasses) {
            generateClass(innerClass, headerFile, implementationFile, nativesFile);
        }
    }

    private static String getHeaderGuardName(final String name) {
        return name.replaceAll("\\W", "_");
    }

    private static int writeOutputFile(final String name, final StringBuilder content) {
        final byte[] contentBytes = content.toString().getBytes(StandardCharsets.UTF_8);

        try {
            final byte[] existingBytes = Files.readAllBytes(new File(name).toPath());
            if (Arrays.equals(contentBytes, existingBytes)) {
                return 0;
            }
        } catch (FileNotFoundException e) {
            // Pass.
        } catch (NoSuchFileException e) {
            // Pass.
        } catch (IOException e) {
            System.err.println("Unable to read " + name + ". Perhaps a permissions issue?");
            e.printStackTrace(System.err);
            return 1;
        }

        try (FileOutputStream outStream = new FileOutputStream(name)) {
            outStream.write(contentBytes);
        } catch (IOException e) {
            System.err.println("Unable to write " + name + ". Perhaps a permissions issue?");
            e.printStackTrace(System.err);
            return 1;
        }

        return 0;
    }
}
