// Produce a multi-architecture universal "fat AAR".
//
// This uses Gradle to:
//
// 1) download per-architecture AARs
// 2) ensure that they are "compatible"
// 3) pack the per-architecture JNI libraries into the GeckoView library

import org.gradle.api.file.FileTree

Set contentHashes(FileTree tree) {
    def Set hashes = []
    tree.visit {
        if (!it.isDirectory()) {
            hashes << [it.relativePath.pathString, ext.DigestUtils.md5Hex(it.open())]
        }
    }
    return hashes
}

Set contentDiff(FileTree left, FileTree right) {
    def Set hleft = contentHashes(left)
    def Set hright = contentHashes(right)
    return (hleft + hright) - hleft.intersect(hright)
}

def ANDROID_CPU_ARCH = mozconfig.substs.ANDROID_CPU_ARCH
def MOZ_ANDROID_FAT_AAR_TARGETS = mozconfig.substs.MOZ_ANDROID_FAT_AAR_TARGETS

task downloadMavenZips
task unpackMavenZips

// Turn ["arch1=url1", "arch2=url2"] into ["arch1": "url1", "arch2": "url2"].
def srcs = MOZ_ANDROID_FAT_AAR_TARGETS.collectEntries {
    def pair = it.split('=')
    [(pair.first()): pair.last()]
}

if (!srcs.containsKey(ANDROID_CPU_ARCH)) {
    throw new GradleException("MOZ_ANDROID_FAT_AAR_TARGETS set but current architecture (${ANDROID_CPU_ARCH}) not included: '${MOZ_ANDROID_FAT_AAR_TARGETS}'")
}

for (s in srcs) {
    def downloadMavenZipTask = task "downloadMavenZip${s.key.capitalize()}"(type: Download) {
        src s.value
        dest file("${buildDir}/fat_aar/${s.key}-${s.value.hashCode()}.maven.zip")

        doFirst {
            if (it.dest.exists()) {
                throw new StopExecutionException("File to download already exists: ${it.dest.path}")
            }
        }
        overwrite true
    }
    downloadMavenZips.dependsOn(downloadMavenZipTask)

    // This is awkward, but extracting from nested zipTree instances seems to be
    // very challenging: Gradle really, really, really wants to resolve the
    // internal zipTree dependencies at configure time, before the outer zipTree
    // has been downloaded.
    def unpackMavenZipTask = task "unpackMavenZip${s.key.capitalize()}"(dependsOn: downloadMavenZipTask) {
        inputs.files downloadMavenZipTask.dest
        outputs.dir file("${buildDir}/fat_aar/${s.key}")

        // Capture for the closure below.
        def key = s.key

        // sync { ... } from zipTree doesn't seem to be supported.
        doFirst {
            delete file("${buildDir}/fat_aar/${key}")
        }

        doLast {
            copy {
                from zipTree(zipTree(tasks["downloadMavenZip${key.capitalize()}"].dest).files.find { it.name.endsWith('.aar') })
                into file("${buildDir}/fat_aar/${key}")
            }
        }
    }
    unpackMavenZips.dependsOn(unpackMavenZipTask)
}

task checkAARs(dependsOn: unpackMavenZips) {
    inputs.files unpackMavenZips.outputs.files

    doFirst {
        def base = fileTree("${buildDir}/fat_aar/${ANDROID_CPU_ARCH}")

        for (s in srcs) {
            if (s.key == ANDROID_CPU_ARCH) {
                continue
            }

            def other = fileTree("${buildDir}/fat_aar/${s.key}")

            // So:
            // - obviously the JNI libraries themselves are different across architectures
            // - AndroidManifest.xml embeds MIN_SDK_VERSION, which differs on 64-bit
            //   architectures (21) vs non-64-bit architectures (15)
            // - classes.jar also embeds MIN_SDK_VERSION, which differs on 64-bit
            //   architectures (21) vs non-64-bit architectures (15)
            // - annotations.zip doesn't have constant timestamps
            // - assets/omni.ja is actually different (buildconfig.html embeds target architecture)
            //
            // For reasons unknown, AARs have an empty top-level $ARCH
            // directory, but we ignore directories so it needs no special
            // accommodation.
            def diff = contentDiff(
                base
                    .exclude('jni/**')
                    .exclude('AndroidManifest.xml')
                    .exclude('classes.jar')
                    .exclude('annotations.zip')
                    .exclude('assets/omni.ja'),
                other
                    .exclude('jni/**')
                    .exclude('AndroidManifest.xml')
                    .exclude('classes.jar')
                    .exclude('annotations.zip')
                    .exclude('assets/omni.ja'))

            if (!diff.isEmpty()) {
                throw new GradleException("${ANDROID_CPU_ARCH} AAR and ${s.key} AAR disagree: ${diff}")
            }

            def classes = contentDiff(
                zipTree("${buildDir}/fat_aar/${ANDROID_CPU_ARCH}/classes.jar")
                    .matching {
                        exclude('org/mozilla/geckoview/BuildConfig.class')
                        exclude('org/mozilla/gecko/util/HardwareUtils.class')
                    },
                zipTree("${buildDir}/fat_aar/${s.key}/classes.jar")
                    .matching {
                        exclude('org/mozilla/geckoview/BuildConfig.class')
                        exclude('org/mozilla/gecko/util/HardwareUtils.class')
                    })

            if (!classes.isEmpty()) {
                throw new GradleException("${buildDir}/fat_aar/${ANDROID_CPU_ARCH}/classes.jar and ${buildDir}/fat_aar/${s.key}/classes.jar disagree: ${classes}")
            }

            def annotations = contentDiff(
                zipTree("${buildDir}/fat_aar/${ANDROID_CPU_ARCH}/annotations.zip"),
                zipTree("${buildDir}/fat_aar/${s.key}/annotations.zip"))

            if (!annotations.isEmpty()) {
                throw new GradleException("${buildDir}/fat_aar/${ANDROID_CPU_ARCH}/annotations.zip and ${buildDir}/fat_aar/${s.key}/annotations.zip disagree: ${annotations}")
            }

            // buildconfig.html is special.
            def omnijar = contentDiff(
                zipTree("${buildDir}/fat_aar/${ANDROID_CPU_ARCH}/assets/omni.ja")
                    .matching {
                        exclude('**/buildconfig.html')
                    },
                zipTree("${buildDir}/fat_aar/${s.key}/assets/omni.ja")
                    .matching {
                        exclude('**/buildconfig.html')
                    })

            if (!omnijar.isEmpty()) {
                // Let's make this easy to debug locally, at least.
                def relPaths = omnijar.collectEntries().keySet()

                copy {
                    from zipTree("${buildDir}/fat_aar/${ANDROID_CPU_ARCH}/assets/omni.ja")
                    into file("${buildDir}/fat_aar/${ANDROID_CPU_ARCH}/omnijar")
                    for (relPath in relPaths) {
                        include relPath
                    }
                }

                copy {
                    from zipTree("${buildDir}/fat_aar/${s.key}/assets/omni.ja")
                    into file("${buildDir}/fat_aar/${s.key}/omnijar")
                    for (relPath in relPaths) {
                        include relPath
                    }
                }

                def pairs = relPaths.collect { relPath ->
                    "(${buildDir}/fat_aar/${ANDROID_CPU_ARCH}/omnijar/${relPath}, ${buildDir}/fat_aar/${s.key}/omnijar/${relPath})"
                }

                throw new GradleException("${buildDir}/fat_aar/${ANDROID_CPU_ARCH}/assets/omni.ja and ${buildDir}/fat_aar/${s.key}/assets/omni.ja disagree: ${pairs}")
            }
        }
    }
}

android.libraryVariants.all { variant ->
    if ((variant.productFlavors*.name).contains('withGeckoBinaries')) {
        def assetGenTask = tasks.findByName("generate${variant.name.capitalize()}Assets")
        assetGenTask.dependsOn checkAARs

        for (s in srcs) {
            // We want to ensure that nothing changed between this build and
            // the upstream AAR, but don't want to pack the binaries
            // corresponding to this build's architecture twice.
            if (s.key == ANDROID_CPU_ARCH) {
                continue
            }

            android.sourceSets."${variant.name}".jniLibs.srcDir "${buildDir}/fat_aar/${s.key}/jni"
        }
    }
}
