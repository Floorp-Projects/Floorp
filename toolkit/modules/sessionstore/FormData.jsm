/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. */

"use strict";

var EXPORTED_SYMBOLS = ["FormData"];

/**
 * Returns whether the given URL very likely has input
 * fields that contain serialized session store data.
 */
function isRestorationPage(url) {
  return url == "about:sessionrestore" || url == "about:welcomeback";
}

/**
 * Returns whether the given form |data| object contains nested restoration
 * data for a page like about:sessionrestore or about:welcomeback.
 */
function hasRestorationData(data) {
  if (isRestorationPage(data.url) && data.id) {
    return typeof(data.id.sessionData) == "object";
  }

  return false;
}

/**
 * Returns the given document's current URI and strips
 * off the URI's anchor part, if any.
 */
function getDocumentURI(doc) {
  return doc.documentURI.replace(/#.*$/, "");
}

/**
 * The public API exported by this module that allows to collect
 * and restore form data for a document and its subframes.
 */
var FormData = Object.freeze({
  restore(frame, data) {
    return FormDataInternal.restore(frame, data);
  },

  restoreTree(root, data) {
    FormDataInternal.restoreTree(root, data);
  },
});

/**
 * This module's internal API.
 */
var FormDataInternal = {
  namespaceURIs: {
    "xhtml": "http://www.w3.org/1999/xhtml",
    "xul": "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
  },

  /**
   * Resolves an XPath query generated by node.generateXPath.
   */
  resolve(aDocument, aQuery) {
    let xptype = aDocument.defaultView.XPathResult.FIRST_ORDERED_NODE_TYPE;
    return aDocument.evaluate(aQuery, aDocument, this.resolveNS.bind(this), xptype, null).singleNodeValue;
  },

  /**
   * Namespace resolver for the above XPath resolver.
   */
  resolveNS(aPrefix) {
    return this.namespaceURIs[aPrefix] || null;
  },

  /**
   * @returns an XPath query to all savable form field nodes
   */
  get restorableFormNodesXPath() {
    let formNodesXPath = "//textarea|//xhtml:textarea|" +
      "//select|//xhtml:select|" +
      "//input|//xhtml:input" +
      // Special case for about:config's search field.
      "|/xul:window[@id='config']//xul:textbox[@id='textbox']";

    delete this.restorableFormNodesXPath;
    return (this.restorableFormNodesXPath = formNodesXPath);
  },

  /**
   * Restores form |data| for the given frame. The data is expected to be in
   * the same format that FormData.collect() returns.
   *
   * @param frame (DOMWindow)
   *        The frame to restore form data to.
   * @param data (object)
   *        An object holding form data.
   */
  restore({document: doc}, data) {
    if (!data.url) {
      return true;
    }

    // Don't restore any data for the given frame if the URL
    // stored in the form data doesn't match its current URL.
    if (data.url != getDocumentURI(doc)) {
      return false;
    }

    // For about:{sessionrestore,welcomeback} we saved the field as JSON to
    // avoid nested instances causing humongous sessionstore.js files.
    // cf. bug 467409
    if (hasRestorationData(data)) {
      data.id.sessionData = JSON.stringify(data.id.sessionData);
    }

    if ("id" in data) {
      let retrieveNode = id => doc.getElementById(id);
      this.restoreManyInputValues(data.id, retrieveNode);
    }

    if ("xpath" in data) {
      let retrieveNode = xpath => this.resolve(doc, xpath);
      this.restoreManyInputValues(data.xpath, retrieveNode);
    }

    if ("innerHTML" in data) {
      if (doc.body && doc.designMode == "on") {
      // eslint-disable-next-line no-unsanitized/property
        doc.body.innerHTML = data.innerHTML;
        this.fireInputEvent(doc.body);
      }
    }

    return true;
  },

  /**
   * Iterates the given form data, retrieving nodes for all the keys and
   * restores their appropriate values.
   *
   * @param data (object)
   *        A subset of the form data as collected by FormData.collect(). This
   *        is either data stored under "id" or under "xpath".
   * @param retrieve (function)
   *        The function used to retrieve the input field belonging to a key
   *        in the given |data| object.
   */
  restoreManyInputValues(data, retrieve) {
    for (let key of Object.keys(data)) {
      let input = retrieve(key);
      if (input) {
        this.restoreSingleInputValue(input, data[key]);
      }
    }
  },

  /**
   * Restores a given form value to a given DOMNode and takes care of firing
   * the appropriate DOM event should the input's value change.
   *
   * @param  aNode
   *         DOMNode to set form value on.
   * @param  aValue
   *         Value to set form element to.
   */
  restoreSingleInputValue(aNode, aValue) {
    let fireEvent = false;

    if (typeof aValue == "string" && aNode.type != "file") {
      // Don't dispatch an input event if there is no change.
      if (aNode.value == aValue) {
        return;
      }

      aNode.value = aValue;
      fireEvent = true;
    } else if (typeof aValue == "boolean") {
      // Don't dispatch a change event for no change.
      if (aNode.checked == aValue) {
        return;
      }

      aNode.checked = aValue;
      fireEvent = true;
    } else if (aValue && aValue.selectedIndex >= 0 && aValue.value) {
      // Don't dispatch a change event for no change
      if (aNode.options[aNode.selectedIndex].value == aValue.value) {
        return;
      }

      // find first option with matching aValue if possible
      for (let i = 0; i < aNode.options.length; i++) {
        if (aNode.options[i].value == aValue.value) {
          aNode.selectedIndex = i;
          fireEvent = true;
          break;
        }
      }
    } else if (aValue && aValue.fileList && aValue.type == "file" &&
      aNode.type == "file") {
      try {
        // FIXME (bug 1122855): This won't work in content processes.
        aNode.mozSetFileNameArray(aValue.fileList, aValue.fileList.length);
      } catch (e) {
        Cu.reportError("mozSetFileNameArray: " + e);
      }
      fireEvent = true;
    } else if (Array.isArray(aValue) && aNode.options) {
      Array.forEach(aNode.options, function(opt, index) {
        // don't worry about malformed options with same values
        opt.selected = aValue.indexOf(opt.value) > -1;

        // Only fire the event here if this wasn't selected by default
        if (!opt.defaultSelected) {
          fireEvent = true;
        }
      });
    }

    // Fire events for this node if applicable
    if (fireEvent) {
      this.fireInputEvent(aNode);
    }
  },

  /**
   * Dispatches an event of type "input" to the given |node|.
   *
   * @param node (DOMNode)
   */
  fireInputEvent(node) {
    // "inputType" value hasn't been decided for session restor:
    // https://github.com/w3c/input-events/issues/30#issuecomment-438693664
    let event = node.isInputEventTarget ?
      new node.ownerGlobal.InputEvent("input", {bubbles: true, inputType: ""}) :
      new node.ownerGlobal.Event("input", {bubbles: true});
    node.dispatchEvent(event);
  },

  /**
   * Restores form data for the current frame hierarchy starting at |root|
   * using the given form |data|.
   *
   * If the given |root| frame's hierarchy doesn't match that of the given
   * |data| object we will silently discard data for unreachable frames. For
   * security reasons we will never restore form data to the wrong frames as
   * we bail out silently if the stored URL doesn't match the frame's current
   * URL.
   *
   * @param root (DOMWindow)
   * @param data (object)
   *        {
   *          formdata: {id: {input1: "value1"}},
   *          children: [
   *            {formdata: {id: {input2: "value2"}}},
   *            null,
   *            {formdata: {xpath: { ... }}, children: [ ... ]}
   *          ]
   *        }
   */
  restoreTree(root, data) {
    // Restore data for the given |root| frame and its descendants. If restore()
    // returns false this indicates the |data.url| doesn't match the loaded
    // document URI. We then must ignore this branch for security reasons.
    if (this.restore(root, data) === false) {
      return;
    }

    if (!data.hasOwnProperty("children")) {
      return;
    }

    let frames = root.frames;
    for (let index of Object.keys(data.children)) {
      if (index < frames.length) {
        this.restoreTree(frames[index], data.children[index]);
      }
    }
  },
};
